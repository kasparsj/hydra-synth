(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.Hydra = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}

},{}],2:[function(require,module,exports){
'use strict'

var rationalize = require('./lib/rationalize')

module.exports = add

function add(a, b) {
  return rationalize(
    a[0].mul(b[1]).add(b[0].mul(a[1])),
    a[1].mul(b[1]))
}

},{"./lib/rationalize":12}],3:[function(require,module,exports){
'use strict'

module.exports = cmp

function cmp(a, b) {
    return a[0].mul(b[1]).cmp(b[0].mul(a[1]))
}

},{}],4:[function(require,module,exports){
'use strict'

var rationalize = require('./lib/rationalize')

module.exports = div

function div(a, b) {
  return rationalize(a[0].mul(b[1]), a[1].mul(b[0]))
}

},{"./lib/rationalize":12}],5:[function(require,module,exports){
'use strict'

var isRat = require('./is-rat')
var isBN = require('./lib/is-bn')
var num2bn = require('./lib/num-to-bn')
var str2bn = require('./lib/str-to-bn')
var rationalize = require('./lib/rationalize')
var div = require('./div')

module.exports = makeRational

function makeRational(numer, denom) {
  if(isRat(numer)) {
    if(denom) {
      return div(numer, makeRational(denom))
    }
    return [numer[0].clone(), numer[1].clone()]
  }
  var shift = 0
  var a, b
  if(isBN(numer)) {
    a = numer.clone()
  } else if(typeof numer === 'string') {
    a = str2bn(numer)
  } else if(numer === 0) {
    return [num2bn(0), num2bn(1)]
  } else if(numer === Math.floor(numer)) {
    a = num2bn(numer)
  } else {
    while(numer !== Math.floor(numer)) {
      numer = numer * Math.pow(2, 256)
      shift -= 256
    }
    a = num2bn(numer)
  }
  if(isRat(denom)) {
    a.mul(denom[1])
    b = denom[0].clone()
  } else if(isBN(denom)) {
    b = denom.clone()
  } else if(typeof denom === 'string') {
    b = str2bn(denom)
  } else if(!denom) {
    b = num2bn(1)
  } else if(denom === Math.floor(denom)) {
    b = num2bn(denom)
  } else {
    while(denom !== Math.floor(denom)) {
      denom = denom * Math.pow(2, 256)
      shift += 256
    }
    b = num2bn(denom)
  }
  if(shift > 0) {
    a = a.ushln(shift)
  } else if(shift < 0) {
    b = b.ushln(-shift)
  }
  return rationalize(a, b)
}

},{"./div":4,"./is-rat":6,"./lib/is-bn":10,"./lib/num-to-bn":11,"./lib/rationalize":12,"./lib/str-to-bn":13}],6:[function(require,module,exports){
'use strict'

var isBN = require('./lib/is-bn')

module.exports = isRat

function isRat(x) {
  return Array.isArray(x) && x.length === 2 && isBN(x[0]) && isBN(x[1])
}

},{"./lib/is-bn":10}],7:[function(require,module,exports){
'use strict'

var BN = require('bn.js')

module.exports = sign

function sign (x) {
  return x.cmp(new BN(0))
}

},{"bn.js":15}],8:[function(require,module,exports){
'use strict'

var sign = require('./bn-sign')

module.exports = bn2num

//TODO: Make this better
function bn2num(b) {
  var l = b.length
  var words = b.words
  var out = 0
  if (l === 1) {
    out = words[0]
  } else if (l === 2) {
    out = words[0] + (words[1] * 0x4000000)
  } else {
    for (var i = 0; i < l; i++) {
      var w = words[i]
      out += w * Math.pow(0x4000000, i)
    }
  }
  return sign(b) * out
}

},{"./bn-sign":7}],9:[function(require,module,exports){
'use strict'

var db = require('double-bits')
var ctz = require('bit-twiddle').countTrailingZeros

module.exports = ctzNumber

//Counts the number of trailing zeros
function ctzNumber(x) {
  var l = ctz(db.lo(x))
  if(l < 32) {
    return l
  }
  var h = ctz(db.hi(x))
  if(h > 20) {
    return 52
  }
  return h + 32
}

},{"bit-twiddle":20,"double-bits":42}],10:[function(require,module,exports){
'use strict'

var BN = require('bn.js')

module.exports = isBN

//Test if x is a bignumber
//FIXME: obviously this is the wrong way to do it
function isBN(x) {
  return x && typeof x === 'object' && Boolean(x.words)
}

},{"bn.js":15}],11:[function(require,module,exports){
'use strict'

var BN = require('bn.js')
var db = require('double-bits')

module.exports = num2bn

function num2bn(x) {
  var e = db.exponent(x)
  if(e < 52) {
    return new BN(x)
  } else {
    return (new BN(x * Math.pow(2, 52-e))).ushln(e-52)
  }
}

},{"bn.js":15,"double-bits":42}],12:[function(require,module,exports){
'use strict'

var num2bn = require('./num-to-bn')
var sign = require('./bn-sign')

module.exports = rationalize

function rationalize(numer, denom) {
  var snumer = sign(numer)
  var sdenom = sign(denom)
  if(snumer === 0) {
    return [num2bn(0), num2bn(1)]
  }
  if(sdenom === 0) {
    return [num2bn(0), num2bn(0)]
  }
  if(sdenom < 0) {
    numer = numer.neg()
    denom = denom.neg()
  }
  var d = numer.gcd(denom)
  if(d.cmpn(1)) {
    return [ numer.div(d), denom.div(d) ]
  }
  return [ numer, denom ]
}

},{"./bn-sign":7,"./num-to-bn":11}],13:[function(require,module,exports){
'use strict'

var BN = require('bn.js')

module.exports = str2BN

function str2BN(x) {
  return new BN(x)
}

},{"bn.js":15}],14:[function(require,module,exports){
'use strict'

var rationalize = require('./lib/rationalize')

module.exports = mul

function mul(a, b) {
  return rationalize(a[0].mul(b[0]), a[1].mul(b[1]))
}

},{"./lib/rationalize":12}],15:[function(require,module,exports){
(function (module, exports) {
  'use strict';

  // Utils
  function assert (val, msg) {
    if (!val) throw new Error(msg || 'Assertion failed');
  }

  // Could use `inherits` module, but don't want to move from single file
  // architecture yet.
  function inherits (ctor, superCtor) {
    ctor.super_ = superCtor;
    var TempCtor = function () {};
    TempCtor.prototype = superCtor.prototype;
    ctor.prototype = new TempCtor();
    ctor.prototype.constructor = ctor;
  }

  // BN

  function BN (number, base, endian) {
    if (BN.isBN(number)) {
      return number;
    }

    this.negative = 0;
    this.words = null;
    this.length = 0;

    // Reduction context
    this.red = null;

    if (number !== null) {
      if (base === 'le' || base === 'be') {
        endian = base;
        base = 10;
      }

      this._init(number || 0, base || 10, endian || 'be');
    }
  }
  if (typeof module === 'object') {
    module.exports = BN;
  } else {
    exports.BN = BN;
  }

  BN.BN = BN;
  BN.wordSize = 26;

  var Buffer;
  try {
    if (typeof window !== 'undefined' && typeof window.Buffer !== 'undefined') {
      Buffer = window.Buffer;
    } else {
      Buffer = require('buffer').Buffer;
    }
  } catch (e) {
  }

  BN.isBN = function isBN (num) {
    if (num instanceof BN) {
      return true;
    }

    return num !== null && typeof num === 'object' &&
      num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
  };

  BN.max = function max (left, right) {
    if (left.cmp(right) > 0) return left;
    return right;
  };

  BN.min = function min (left, right) {
    if (left.cmp(right) < 0) return left;
    return right;
  };

  BN.prototype._init = function init (number, base, endian) {
    if (typeof number === 'number') {
      return this._initNumber(number, base, endian);
    }

    if (typeof number === 'object') {
      return this._initArray(number, base, endian);
    }

    if (base === 'hex') {
      base = 16;
    }
    assert(base === (base | 0) && base >= 2 && base <= 36);

    number = number.toString().replace(/\s+/g, '');
    var start = 0;
    if (number[0] === '-') {
      start++;
      this.negative = 1;
    }

    if (start < number.length) {
      if (base === 16) {
        this._parseHex(number, start, endian);
      } else {
        this._parseBase(number, base, start);
        if (endian === 'le') {
          this._initArray(this.toArray(), base, endian);
        }
      }
    }
  };

  BN.prototype._initNumber = function _initNumber (number, base, endian) {
    if (number < 0) {
      this.negative = 1;
      number = -number;
    }
    if (number < 0x4000000) {
      this.words = [ number & 0x3ffffff ];
      this.length = 1;
    } else if (number < 0x10000000000000) {
      this.words = [
        number & 0x3ffffff,
        (number / 0x4000000) & 0x3ffffff
      ];
      this.length = 2;
    } else {
      assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)
      this.words = [
        number & 0x3ffffff,
        (number / 0x4000000) & 0x3ffffff,
        1
      ];
      this.length = 3;
    }

    if (endian !== 'le') return;

    // Reverse the bytes
    this._initArray(this.toArray(), base, endian);
  };

  BN.prototype._initArray = function _initArray (number, base, endian) {
    // Perhaps a Uint8Array
    assert(typeof number.length === 'number');
    if (number.length <= 0) {
      this.words = [ 0 ];
      this.length = 1;
      return this;
    }

    this.length = Math.ceil(number.length / 3);
    this.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      this.words[i] = 0;
    }

    var j, w;
    var off = 0;
    if (endian === 'be') {
      for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
        w = number[i] | (number[i - 1] << 8) | (number[i - 2] << 16);
        this.words[j] |= (w << off) & 0x3ffffff;
        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
        off += 24;
        if (off >= 26) {
          off -= 26;
          j++;
        }
      }
    } else if (endian === 'le') {
      for (i = 0, j = 0; i < number.length; i += 3) {
        w = number[i] | (number[i + 1] << 8) | (number[i + 2] << 16);
        this.words[j] |= (w << off) & 0x3ffffff;
        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
        off += 24;
        if (off >= 26) {
          off -= 26;
          j++;
        }
      }
    }
    return this.strip();
  };

  function parseHex4Bits (string, index) {
    var c = string.charCodeAt(index);
    // 'A' - 'F'
    if (c >= 65 && c <= 70) {
      return c - 55;
    // 'a' - 'f'
    } else if (c >= 97 && c <= 102) {
      return c - 87;
    // '0' - '9'
    } else {
      return (c - 48) & 0xf;
    }
  }

  function parseHexByte (string, lowerBound, index) {
    var r = parseHex4Bits(string, index);
    if (index - 1 >= lowerBound) {
      r |= parseHex4Bits(string, index - 1) << 4;
    }
    return r;
  }

  BN.prototype._parseHex = function _parseHex (number, start, endian) {
    // Create possibly bigger array to ensure that it fits the number
    this.length = Math.ceil((number.length - start) / 6);
    this.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      this.words[i] = 0;
    }

    // 24-bits chunks
    var off = 0;
    var j = 0;

    var w;
    if (endian === 'be') {
      for (i = number.length - 1; i >= start; i -= 2) {
        w = parseHexByte(number, start, i) << off;
        this.words[j] |= w & 0x3ffffff;
        if (off >= 18) {
          off -= 18;
          j += 1;
          this.words[j] |= w >>> 26;
        } else {
          off += 8;
        }
      }
    } else {
      var parseLength = number.length - start;
      for (i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2) {
        w = parseHexByte(number, start, i) << off;
        this.words[j] |= w & 0x3ffffff;
        if (off >= 18) {
          off -= 18;
          j += 1;
          this.words[j] |= w >>> 26;
        } else {
          off += 8;
        }
      }
    }

    this.strip();
  };

  function parseBase (str, start, end, mul) {
    var r = 0;
    var len = Math.min(str.length, end);
    for (var i = start; i < len; i++) {
      var c = str.charCodeAt(i) - 48;

      r *= mul;

      // 'a'
      if (c >= 49) {
        r += c - 49 + 0xa;

      // 'A'
      } else if (c >= 17) {
        r += c - 17 + 0xa;

      // '0' - '9'
      } else {
        r += c;
      }
    }
    return r;
  }

  BN.prototype._parseBase = function _parseBase (number, base, start) {
    // Initialize as zero
    this.words = [ 0 ];
    this.length = 1;

    // Find length of limb in base
    for (var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base) {
      limbLen++;
    }
    limbLen--;
    limbPow = (limbPow / base) | 0;

    var total = number.length - start;
    var mod = total % limbLen;
    var end = Math.min(total, total - mod) + start;

    var word = 0;
    for (var i = start; i < end; i += limbLen) {
      word = parseBase(number, i, i + limbLen, base);

      this.imuln(limbPow);
      if (this.words[0] + word < 0x4000000) {
        this.words[0] += word;
      } else {
        this._iaddn(word);
      }
    }

    if (mod !== 0) {
      var pow = 1;
      word = parseBase(number, i, number.length, base);

      for (i = 0; i < mod; i++) {
        pow *= base;
      }

      this.imuln(pow);
      if (this.words[0] + word < 0x4000000) {
        this.words[0] += word;
      } else {
        this._iaddn(word);
      }
    }

    this.strip();
  };

  BN.prototype.copy = function copy (dest) {
    dest.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      dest.words[i] = this.words[i];
    }
    dest.length = this.length;
    dest.negative = this.negative;
    dest.red = this.red;
  };

  BN.prototype.clone = function clone () {
    var r = new BN(null);
    this.copy(r);
    return r;
  };

  BN.prototype._expand = function _expand (size) {
    while (this.length < size) {
      this.words[this.length++] = 0;
    }
    return this;
  };

  // Remove leading `0` from `this`
  BN.prototype.strip = function strip () {
    while (this.length > 1 && this.words[this.length - 1] === 0) {
      this.length--;
    }
    return this._normSign();
  };

  BN.prototype._normSign = function _normSign () {
    // -0 = 0
    if (this.length === 1 && this.words[0] === 0) {
      this.negative = 0;
    }
    return this;
  };

  BN.prototype.inspect = function inspect () {
    return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';
  };

  /*

  var zeros = [];
  var groupSizes = [];
  var groupBases = [];

  var s = '';
  var i = -1;
  while (++i < BN.wordSize) {
    zeros[i] = s;
    s += '0';
  }
  groupSizes[0] = 0;
  groupSizes[1] = 0;
  groupBases[0] = 0;
  groupBases[1] = 0;
  var base = 2 - 1;
  while (++base < 36 + 1) {
    var groupSize = 0;
    var groupBase = 1;
    while (groupBase < (1 << BN.wordSize) / base) {
      groupBase *= base;
      groupSize += 1;
    }
    groupSizes[base] = groupSize;
    groupBases[base] = groupBase;
  }

  */

  var zeros = [
    '',
    '0',
    '00',
    '000',
    '0000',
    '00000',
    '000000',
    '0000000',
    '00000000',
    '000000000',
    '0000000000',
    '00000000000',
    '000000000000',
    '0000000000000',
    '00000000000000',
    '000000000000000',
    '0000000000000000',
    '00000000000000000',
    '000000000000000000',
    '0000000000000000000',
    '00000000000000000000',
    '000000000000000000000',
    '0000000000000000000000',
    '00000000000000000000000',
    '000000000000000000000000',
    '0000000000000000000000000'
  ];

  var groupSizes = [
    0, 0,
    25, 16, 12, 11, 10, 9, 8,
    8, 7, 7, 7, 7, 6, 6,
    6, 6, 6, 6, 6, 5, 5,
    5, 5, 5, 5, 5, 5, 5,
    5, 5, 5, 5, 5, 5, 5
  ];

  var groupBases = [
    0, 0,
    33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216,
    43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625,
    16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632,
    6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149,
    24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176
  ];

  BN.prototype.toString = function toString (base, padding) {
    base = base || 10;
    padding = padding | 0 || 1;

    var out;
    if (base === 16 || base === 'hex') {
      out = '';
      var off = 0;
      var carry = 0;
      for (var i = 0; i < this.length; i++) {
        var w = this.words[i];
        var word = (((w << off) | carry) & 0xffffff).toString(16);
        carry = (w >>> (24 - off)) & 0xffffff;
        if (carry !== 0 || i !== this.length - 1) {
          out = zeros[6 - word.length] + word + out;
        } else {
          out = word + out;
        }
        off += 2;
        if (off >= 26) {
          off -= 26;
          i--;
        }
      }
      if (carry !== 0) {
        out = carry.toString(16) + out;
      }
      while (out.length % padding !== 0) {
        out = '0' + out;
      }
      if (this.negative !== 0) {
        out = '-' + out;
      }
      return out;
    }

    if (base === (base | 0) && base >= 2 && base <= 36) {
      // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));
      var groupSize = groupSizes[base];
      // var groupBase = Math.pow(base, groupSize);
      var groupBase = groupBases[base];
      out = '';
      var c = this.clone();
      c.negative = 0;
      while (!c.isZero()) {
        var r = c.modn(groupBase).toString(base);
        c = c.idivn(groupBase);

        if (!c.isZero()) {
          out = zeros[groupSize - r.length] + r + out;
        } else {
          out = r + out;
        }
      }
      if (this.isZero()) {
        out = '0' + out;
      }
      while (out.length % padding !== 0) {
        out = '0' + out;
      }
      if (this.negative !== 0) {
        out = '-' + out;
      }
      return out;
    }

    assert(false, 'Base should be between 2 and 36');
  };

  BN.prototype.toNumber = function toNumber () {
    var ret = this.words[0];
    if (this.length === 2) {
      ret += this.words[1] * 0x4000000;
    } else if (this.length === 3 && this.words[2] === 0x01) {
      // NOTE: at this stage it is known that the top bit is set
      ret += 0x10000000000000 + (this.words[1] * 0x4000000);
    } else if (this.length > 2) {
      assert(false, 'Number can only safely store up to 53 bits');
    }
    return (this.negative !== 0) ? -ret : ret;
  };

  BN.prototype.toJSON = function toJSON () {
    return this.toString(16);
  };

  BN.prototype.toBuffer = function toBuffer (endian, length) {
    assert(typeof Buffer !== 'undefined');
    return this.toArrayLike(Buffer, endian, length);
  };

  BN.prototype.toArray = function toArray (endian, length) {
    return this.toArrayLike(Array, endian, length);
  };

  BN.prototype.toArrayLike = function toArrayLike (ArrayType, endian, length) {
    var byteLength = this.byteLength();
    var reqLength = length || Math.max(1, byteLength);
    assert(byteLength <= reqLength, 'byte array longer than desired length');
    assert(reqLength > 0, 'Requested array length <= 0');

    this.strip();
    var littleEndian = endian === 'le';
    var res = new ArrayType(reqLength);

    var b, i;
    var q = this.clone();
    if (!littleEndian) {
      // Assume big-endian
      for (i = 0; i < reqLength - byteLength; i++) {
        res[i] = 0;
      }

      for (i = 0; !q.isZero(); i++) {
        b = q.andln(0xff);
        q.iushrn(8);

        res[reqLength - i - 1] = b;
      }
    } else {
      for (i = 0; !q.isZero(); i++) {
        b = q.andln(0xff);
        q.iushrn(8);

        res[i] = b;
      }

      for (; i < reqLength; i++) {
        res[i] = 0;
      }
    }

    return res;
  };

  if (Math.clz32) {
    BN.prototype._countBits = function _countBits (w) {
      return 32 - Math.clz32(w);
    };
  } else {
    BN.prototype._countBits = function _countBits (w) {
      var t = w;
      var r = 0;
      if (t >= 0x1000) {
        r += 13;
        t >>>= 13;
      }
      if (t >= 0x40) {
        r += 7;
        t >>>= 7;
      }
      if (t >= 0x8) {
        r += 4;
        t >>>= 4;
      }
      if (t >= 0x02) {
        r += 2;
        t >>>= 2;
      }
      return r + t;
    };
  }

  BN.prototype._zeroBits = function _zeroBits (w) {
    // Short-cut
    if (w === 0) return 26;

    var t = w;
    var r = 0;
    if ((t & 0x1fff) === 0) {
      r += 13;
      t >>>= 13;
    }
    if ((t & 0x7f) === 0) {
      r += 7;
      t >>>= 7;
    }
    if ((t & 0xf) === 0) {
      r += 4;
      t >>>= 4;
    }
    if ((t & 0x3) === 0) {
      r += 2;
      t >>>= 2;
    }
    if ((t & 0x1) === 0) {
      r++;
    }
    return r;
  };

  // Return number of used bits in a BN
  BN.prototype.bitLength = function bitLength () {
    var w = this.words[this.length - 1];
    var hi = this._countBits(w);
    return (this.length - 1) * 26 + hi;
  };

  function toBitArray (num) {
    var w = new Array(num.bitLength());

    for (var bit = 0; bit < w.length; bit++) {
      var off = (bit / 26) | 0;
      var wbit = bit % 26;

      w[bit] = (num.words[off] & (1 << wbit)) >>> wbit;
    }

    return w;
  }

  // Number of trailing zero bits
  BN.prototype.zeroBits = function zeroBits () {
    if (this.isZero()) return 0;

    var r = 0;
    for (var i = 0; i < this.length; i++) {
      var b = this._zeroBits(this.words[i]);
      r += b;
      if (b !== 26) break;
    }
    return r;
  };

  BN.prototype.byteLength = function byteLength () {
    return Math.ceil(this.bitLength() / 8);
  };

  BN.prototype.toTwos = function toTwos (width) {
    if (this.negative !== 0) {
      return this.abs().inotn(width).iaddn(1);
    }
    return this.clone();
  };

  BN.prototype.fromTwos = function fromTwos (width) {
    if (this.testn(width - 1)) {
      return this.notn(width).iaddn(1).ineg();
    }
    return this.clone();
  };

  BN.prototype.isNeg = function isNeg () {
    return this.negative !== 0;
  };

  // Return negative clone of `this`
  BN.prototype.neg = function neg () {
    return this.clone().ineg();
  };

  BN.prototype.ineg = function ineg () {
    if (!this.isZero()) {
      this.negative ^= 1;
    }

    return this;
  };

  // Or `num` with `this` in-place
  BN.prototype.iuor = function iuor (num) {
    while (this.length < num.length) {
      this.words[this.length++] = 0;
    }

    for (var i = 0; i < num.length; i++) {
      this.words[i] = this.words[i] | num.words[i];
    }

    return this.strip();
  };

  BN.prototype.ior = function ior (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuor(num);
  };

  // Or `num` with `this`
  BN.prototype.or = function or (num) {
    if (this.length > num.length) return this.clone().ior(num);
    return num.clone().ior(this);
  };

  BN.prototype.uor = function uor (num) {
    if (this.length > num.length) return this.clone().iuor(num);
    return num.clone().iuor(this);
  };

  // And `num` with `this` in-place
  BN.prototype.iuand = function iuand (num) {
    // b = min-length(num, this)
    var b;
    if (this.length > num.length) {
      b = num;
    } else {
      b = this;
    }

    for (var i = 0; i < b.length; i++) {
      this.words[i] = this.words[i] & num.words[i];
    }

    this.length = b.length;

    return this.strip();
  };

  BN.prototype.iand = function iand (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuand(num);
  };

  // And `num` with `this`
  BN.prototype.and = function and (num) {
    if (this.length > num.length) return this.clone().iand(num);
    return num.clone().iand(this);
  };

  BN.prototype.uand = function uand (num) {
    if (this.length > num.length) return this.clone().iuand(num);
    return num.clone().iuand(this);
  };

  // Xor `num` with `this` in-place
  BN.prototype.iuxor = function iuxor (num) {
    // a.length > b.length
    var a;
    var b;
    if (this.length > num.length) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    for (var i = 0; i < b.length; i++) {
      this.words[i] = a.words[i] ^ b.words[i];
    }

    if (this !== a) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    this.length = a.length;

    return this.strip();
  };

  BN.prototype.ixor = function ixor (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuxor(num);
  };

  // Xor `num` with `this`
  BN.prototype.xor = function xor (num) {
    if (this.length > num.length) return this.clone().ixor(num);
    return num.clone().ixor(this);
  };

  BN.prototype.uxor = function uxor (num) {
    if (this.length > num.length) return this.clone().iuxor(num);
    return num.clone().iuxor(this);
  };

  // Not ``this`` with ``width`` bitwidth
  BN.prototype.inotn = function inotn (width) {
    assert(typeof width === 'number' && width >= 0);

    var bytesNeeded = Math.ceil(width / 26) | 0;
    var bitsLeft = width % 26;

    // Extend the buffer with leading zeroes
    this._expand(bytesNeeded);

    if (bitsLeft > 0) {
      bytesNeeded--;
    }

    // Handle complete words
    for (var i = 0; i < bytesNeeded; i++) {
      this.words[i] = ~this.words[i] & 0x3ffffff;
    }

    // Handle the residue
    if (bitsLeft > 0) {
      this.words[i] = ~this.words[i] & (0x3ffffff >> (26 - bitsLeft));
    }

    // And remove leading zeroes
    return this.strip();
  };

  BN.prototype.notn = function notn (width) {
    return this.clone().inotn(width);
  };

  // Set `bit` of `this`
  BN.prototype.setn = function setn (bit, val) {
    assert(typeof bit === 'number' && bit >= 0);

    var off = (bit / 26) | 0;
    var wbit = bit % 26;

    this._expand(off + 1);

    if (val) {
      this.words[off] = this.words[off] | (1 << wbit);
    } else {
      this.words[off] = this.words[off] & ~(1 << wbit);
    }

    return this.strip();
  };

  // Add `num` to `this` in-place
  BN.prototype.iadd = function iadd (num) {
    var r;

    // negative + positive
    if (this.negative !== 0 && num.negative === 0) {
      this.negative = 0;
      r = this.isub(num);
      this.negative ^= 1;
      return this._normSign();

    // positive + negative
    } else if (this.negative === 0 && num.negative !== 0) {
      num.negative = 0;
      r = this.isub(num);
      num.negative = 1;
      return r._normSign();
    }

    // a.length > b.length
    var a, b;
    if (this.length > num.length) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    var carry = 0;
    for (var i = 0; i < b.length; i++) {
      r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
      this.words[i] = r & 0x3ffffff;
      carry = r >>> 26;
    }
    for (; carry !== 0 && i < a.length; i++) {
      r = (a.words[i] | 0) + carry;
      this.words[i] = r & 0x3ffffff;
      carry = r >>> 26;
    }

    this.length = a.length;
    if (carry !== 0) {
      this.words[this.length] = carry;
      this.length++;
    // Copy the rest of the words
    } else if (a !== this) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    return this;
  };

  // Add `num` to `this`
  BN.prototype.add = function add (num) {
    var res;
    if (num.negative !== 0 && this.negative === 0) {
      num.negative = 0;
      res = this.sub(num);
      num.negative ^= 1;
      return res;
    } else if (num.negative === 0 && this.negative !== 0) {
      this.negative = 0;
      res = num.sub(this);
      this.negative = 1;
      return res;
    }

    if (this.length > num.length) return this.clone().iadd(num);

    return num.clone().iadd(this);
  };

  // Subtract `num` from `this` in-place
  BN.prototype.isub = function isub (num) {
    // this - (-num) = this + num
    if (num.negative !== 0) {
      num.negative = 0;
      var r = this.iadd(num);
      num.negative = 1;
      return r._normSign();

    // -this - num = -(this + num)
    } else if (this.negative !== 0) {
      this.negative = 0;
      this.iadd(num);
      this.negative = 1;
      return this._normSign();
    }

    // At this point both numbers are positive
    var cmp = this.cmp(num);

    // Optimization - zeroify
    if (cmp === 0) {
      this.negative = 0;
      this.length = 1;
      this.words[0] = 0;
      return this;
    }

    // a > b
    var a, b;
    if (cmp > 0) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    var carry = 0;
    for (var i = 0; i < b.length; i++) {
      r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
      carry = r >> 26;
      this.words[i] = r & 0x3ffffff;
    }
    for (; carry !== 0 && i < a.length; i++) {
      r = (a.words[i] | 0) + carry;
      carry = r >> 26;
      this.words[i] = r & 0x3ffffff;
    }

    // Copy rest of the words
    if (carry === 0 && i < a.length && a !== this) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    this.length = Math.max(this.length, i);

    if (a !== this) {
      this.negative = 1;
    }

    return this.strip();
  };

  // Subtract `num` from `this`
  BN.prototype.sub = function sub (num) {
    return this.clone().isub(num);
  };

  function smallMulTo (self, num, out) {
    out.negative = num.negative ^ self.negative;
    var len = (self.length + num.length) | 0;
    out.length = len;
    len = (len - 1) | 0;

    // Peel one iteration (compiler can't do it, because of code complexity)
    var a = self.words[0] | 0;
    var b = num.words[0] | 0;
    var r = a * b;

    var lo = r & 0x3ffffff;
    var carry = (r / 0x4000000) | 0;
    out.words[0] = lo;

    for (var k = 1; k < len; k++) {
      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
      // note that ncarry could be >= 0x3ffffff
      var ncarry = carry >>> 26;
      var rword = carry & 0x3ffffff;
      var maxJ = Math.min(k, num.length - 1);
      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
        var i = (k - j) | 0;
        a = self.words[i] | 0;
        b = num.words[j] | 0;
        r = a * b + rword;
        ncarry += (r / 0x4000000) | 0;
        rword = r & 0x3ffffff;
      }
      out.words[k] = rword | 0;
      carry = ncarry | 0;
    }
    if (carry !== 0) {
      out.words[k] = carry | 0;
    } else {
      out.length--;
    }

    return out.strip();
  }

  // TODO(indutny): it may be reasonable to omit it for users who don't need
  // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit
  // multiplication (like elliptic secp256k1).
  var comb10MulTo = function comb10MulTo (self, num, out) {
    var a = self.words;
    var b = num.words;
    var o = out.words;
    var c = 0;
    var lo;
    var mid;
    var hi;
    var a0 = a[0] | 0;
    var al0 = a0 & 0x1fff;
    var ah0 = a0 >>> 13;
    var a1 = a[1] | 0;
    var al1 = a1 & 0x1fff;
    var ah1 = a1 >>> 13;
    var a2 = a[2] | 0;
    var al2 = a2 & 0x1fff;
    var ah2 = a2 >>> 13;
    var a3 = a[3] | 0;
    var al3 = a3 & 0x1fff;
    var ah3 = a3 >>> 13;
    var a4 = a[4] | 0;
    var al4 = a4 & 0x1fff;
    var ah4 = a4 >>> 13;
    var a5 = a[5] | 0;
    var al5 = a5 & 0x1fff;
    var ah5 = a5 >>> 13;
    var a6 = a[6] | 0;
    var al6 = a6 & 0x1fff;
    var ah6 = a6 >>> 13;
    var a7 = a[7] | 0;
    var al7 = a7 & 0x1fff;
    var ah7 = a7 >>> 13;
    var a8 = a[8] | 0;
    var al8 = a8 & 0x1fff;
    var ah8 = a8 >>> 13;
    var a9 = a[9] | 0;
    var al9 = a9 & 0x1fff;
    var ah9 = a9 >>> 13;
    var b0 = b[0] | 0;
    var bl0 = b0 & 0x1fff;
    var bh0 = b0 >>> 13;
    var b1 = b[1] | 0;
    var bl1 = b1 & 0x1fff;
    var bh1 = b1 >>> 13;
    var b2 = b[2] | 0;
    var bl2 = b2 & 0x1fff;
    var bh2 = b2 >>> 13;
    var b3 = b[3] | 0;
    var bl3 = b3 & 0x1fff;
    var bh3 = b3 >>> 13;
    var b4 = b[4] | 0;
    var bl4 = b4 & 0x1fff;
    var bh4 = b4 >>> 13;
    var b5 = b[5] | 0;
    var bl5 = b5 & 0x1fff;
    var bh5 = b5 >>> 13;
    var b6 = b[6] | 0;
    var bl6 = b6 & 0x1fff;
    var bh6 = b6 >>> 13;
    var b7 = b[7] | 0;
    var bl7 = b7 & 0x1fff;
    var bh7 = b7 >>> 13;
    var b8 = b[8] | 0;
    var bl8 = b8 & 0x1fff;
    var bh8 = b8 >>> 13;
    var b9 = b[9] | 0;
    var bl9 = b9 & 0x1fff;
    var bh9 = b9 >>> 13;

    out.negative = self.negative ^ num.negative;
    out.length = 19;
    /* k = 0 */
    lo = Math.imul(al0, bl0);
    mid = Math.imul(al0, bh0);
    mid = (mid + Math.imul(ah0, bl0)) | 0;
    hi = Math.imul(ah0, bh0);
    var w0 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w0 >>> 26)) | 0;
    w0 &= 0x3ffffff;
    /* k = 1 */
    lo = Math.imul(al1, bl0);
    mid = Math.imul(al1, bh0);
    mid = (mid + Math.imul(ah1, bl0)) | 0;
    hi = Math.imul(ah1, bh0);
    lo = (lo + Math.imul(al0, bl1)) | 0;
    mid = (mid + Math.imul(al0, bh1)) | 0;
    mid = (mid + Math.imul(ah0, bl1)) | 0;
    hi = (hi + Math.imul(ah0, bh1)) | 0;
    var w1 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w1 >>> 26)) | 0;
    w1 &= 0x3ffffff;
    /* k = 2 */
    lo = Math.imul(al2, bl0);
    mid = Math.imul(al2, bh0);
    mid = (mid + Math.imul(ah2, bl0)) | 0;
    hi = Math.imul(ah2, bh0);
    lo = (lo + Math.imul(al1, bl1)) | 0;
    mid = (mid + Math.imul(al1, bh1)) | 0;
    mid = (mid + Math.imul(ah1, bl1)) | 0;
    hi = (hi + Math.imul(ah1, bh1)) | 0;
    lo = (lo + Math.imul(al0, bl2)) | 0;
    mid = (mid + Math.imul(al0, bh2)) | 0;
    mid = (mid + Math.imul(ah0, bl2)) | 0;
    hi = (hi + Math.imul(ah0, bh2)) | 0;
    var w2 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w2 >>> 26)) | 0;
    w2 &= 0x3ffffff;
    /* k = 3 */
    lo = Math.imul(al3, bl0);
    mid = Math.imul(al3, bh0);
    mid = (mid + Math.imul(ah3, bl0)) | 0;
    hi = Math.imul(ah3, bh0);
    lo = (lo + Math.imul(al2, bl1)) | 0;
    mid = (mid + Math.imul(al2, bh1)) | 0;
    mid = (mid + Math.imul(ah2, bl1)) | 0;
    hi = (hi + Math.imul(ah2, bh1)) | 0;
    lo = (lo + Math.imul(al1, bl2)) | 0;
    mid = (mid + Math.imul(al1, bh2)) | 0;
    mid = (mid + Math.imul(ah1, bl2)) | 0;
    hi = (hi + Math.imul(ah1, bh2)) | 0;
    lo = (lo + Math.imul(al0, bl3)) | 0;
    mid = (mid + Math.imul(al0, bh3)) | 0;
    mid = (mid + Math.imul(ah0, bl3)) | 0;
    hi = (hi + Math.imul(ah0, bh3)) | 0;
    var w3 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w3 >>> 26)) | 0;
    w3 &= 0x3ffffff;
    /* k = 4 */
    lo = Math.imul(al4, bl0);
    mid = Math.imul(al4, bh0);
    mid = (mid + Math.imul(ah4, bl0)) | 0;
    hi = Math.imul(ah4, bh0);
    lo = (lo + Math.imul(al3, bl1)) | 0;
    mid = (mid + Math.imul(al3, bh1)) | 0;
    mid = (mid + Math.imul(ah3, bl1)) | 0;
    hi = (hi + Math.imul(ah3, bh1)) | 0;
    lo = (lo + Math.imul(al2, bl2)) | 0;
    mid = (mid + Math.imul(al2, bh2)) | 0;
    mid = (mid + Math.imul(ah2, bl2)) | 0;
    hi = (hi + Math.imul(ah2, bh2)) | 0;
    lo = (lo + Math.imul(al1, bl3)) | 0;
    mid = (mid + Math.imul(al1, bh3)) | 0;
    mid = (mid + Math.imul(ah1, bl3)) | 0;
    hi = (hi + Math.imul(ah1, bh3)) | 0;
    lo = (lo + Math.imul(al0, bl4)) | 0;
    mid = (mid + Math.imul(al0, bh4)) | 0;
    mid = (mid + Math.imul(ah0, bl4)) | 0;
    hi = (hi + Math.imul(ah0, bh4)) | 0;
    var w4 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w4 >>> 26)) | 0;
    w4 &= 0x3ffffff;
    /* k = 5 */
    lo = Math.imul(al5, bl0);
    mid = Math.imul(al5, bh0);
    mid = (mid + Math.imul(ah5, bl0)) | 0;
    hi = Math.imul(ah5, bh0);
    lo = (lo + Math.imul(al4, bl1)) | 0;
    mid = (mid + Math.imul(al4, bh1)) | 0;
    mid = (mid + Math.imul(ah4, bl1)) | 0;
    hi = (hi + Math.imul(ah4, bh1)) | 0;
    lo = (lo + Math.imul(al3, bl2)) | 0;
    mid = (mid + Math.imul(al3, bh2)) | 0;
    mid = (mid + Math.imul(ah3, bl2)) | 0;
    hi = (hi + Math.imul(ah3, bh2)) | 0;
    lo = (lo + Math.imul(al2, bl3)) | 0;
    mid = (mid + Math.imul(al2, bh3)) | 0;
    mid = (mid + Math.imul(ah2, bl3)) | 0;
    hi = (hi + Math.imul(ah2, bh3)) | 0;
    lo = (lo + Math.imul(al1, bl4)) | 0;
    mid = (mid + Math.imul(al1, bh4)) | 0;
    mid = (mid + Math.imul(ah1, bl4)) | 0;
    hi = (hi + Math.imul(ah1, bh4)) | 0;
    lo = (lo + Math.imul(al0, bl5)) | 0;
    mid = (mid + Math.imul(al0, bh5)) | 0;
    mid = (mid + Math.imul(ah0, bl5)) | 0;
    hi = (hi + Math.imul(ah0, bh5)) | 0;
    var w5 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w5 >>> 26)) | 0;
    w5 &= 0x3ffffff;
    /* k = 6 */
    lo = Math.imul(al6, bl0);
    mid = Math.imul(al6, bh0);
    mid = (mid + Math.imul(ah6, bl0)) | 0;
    hi = Math.imul(ah6, bh0);
    lo = (lo + Math.imul(al5, bl1)) | 0;
    mid = (mid + Math.imul(al5, bh1)) | 0;
    mid = (mid + Math.imul(ah5, bl1)) | 0;
    hi = (hi + Math.imul(ah5, bh1)) | 0;
    lo = (lo + Math.imul(al4, bl2)) | 0;
    mid = (mid + Math.imul(al4, bh2)) | 0;
    mid = (mid + Math.imul(ah4, bl2)) | 0;
    hi = (hi + Math.imul(ah4, bh2)) | 0;
    lo = (lo + Math.imul(al3, bl3)) | 0;
    mid = (mid + Math.imul(al3, bh3)) | 0;
    mid = (mid + Math.imul(ah3, bl3)) | 0;
    hi = (hi + Math.imul(ah3, bh3)) | 0;
    lo = (lo + Math.imul(al2, bl4)) | 0;
    mid = (mid + Math.imul(al2, bh4)) | 0;
    mid = (mid + Math.imul(ah2, bl4)) | 0;
    hi = (hi + Math.imul(ah2, bh4)) | 0;
    lo = (lo + Math.imul(al1, bl5)) | 0;
    mid = (mid + Math.imul(al1, bh5)) | 0;
    mid = (mid + Math.imul(ah1, bl5)) | 0;
    hi = (hi + Math.imul(ah1, bh5)) | 0;
    lo = (lo + Math.imul(al0, bl6)) | 0;
    mid = (mid + Math.imul(al0, bh6)) | 0;
    mid = (mid + Math.imul(ah0, bl6)) | 0;
    hi = (hi + Math.imul(ah0, bh6)) | 0;
    var w6 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w6 >>> 26)) | 0;
    w6 &= 0x3ffffff;
    /* k = 7 */
    lo = Math.imul(al7, bl0);
    mid = Math.imul(al7, bh0);
    mid = (mid + Math.imul(ah7, bl0)) | 0;
    hi = Math.imul(ah7, bh0);
    lo = (lo + Math.imul(al6, bl1)) | 0;
    mid = (mid + Math.imul(al6, bh1)) | 0;
    mid = (mid + Math.imul(ah6, bl1)) | 0;
    hi = (hi + Math.imul(ah6, bh1)) | 0;
    lo = (lo + Math.imul(al5, bl2)) | 0;
    mid = (mid + Math.imul(al5, bh2)) | 0;
    mid = (mid + Math.imul(ah5, bl2)) | 0;
    hi = (hi + Math.imul(ah5, bh2)) | 0;
    lo = (lo + Math.imul(al4, bl3)) | 0;
    mid = (mid + Math.imul(al4, bh3)) | 0;
    mid = (mid + Math.imul(ah4, bl3)) | 0;
    hi = (hi + Math.imul(ah4, bh3)) | 0;
    lo = (lo + Math.imul(al3, bl4)) | 0;
    mid = (mid + Math.imul(al3, bh4)) | 0;
    mid = (mid + Math.imul(ah3, bl4)) | 0;
    hi = (hi + Math.imul(ah3, bh4)) | 0;
    lo = (lo + Math.imul(al2, bl5)) | 0;
    mid = (mid + Math.imul(al2, bh5)) | 0;
    mid = (mid + Math.imul(ah2, bl5)) | 0;
    hi = (hi + Math.imul(ah2, bh5)) | 0;
    lo = (lo + Math.imul(al1, bl6)) | 0;
    mid = (mid + Math.imul(al1, bh6)) | 0;
    mid = (mid + Math.imul(ah1, bl6)) | 0;
    hi = (hi + Math.imul(ah1, bh6)) | 0;
    lo = (lo + Math.imul(al0, bl7)) | 0;
    mid = (mid + Math.imul(al0, bh7)) | 0;
    mid = (mid + Math.imul(ah0, bl7)) | 0;
    hi = (hi + Math.imul(ah0, bh7)) | 0;
    var w7 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w7 >>> 26)) | 0;
    w7 &= 0x3ffffff;
    /* k = 8 */
    lo = Math.imul(al8, bl0);
    mid = Math.imul(al8, bh0);
    mid = (mid + Math.imul(ah8, bl0)) | 0;
    hi = Math.imul(ah8, bh0);
    lo = (lo + Math.imul(al7, bl1)) | 0;
    mid = (mid + Math.imul(al7, bh1)) | 0;
    mid = (mid + Math.imul(ah7, bl1)) | 0;
    hi = (hi + Math.imul(ah7, bh1)) | 0;
    lo = (lo + Math.imul(al6, bl2)) | 0;
    mid = (mid + Math.imul(al6, bh2)) | 0;
    mid = (mid + Math.imul(ah6, bl2)) | 0;
    hi = (hi + Math.imul(ah6, bh2)) | 0;
    lo = (lo + Math.imul(al5, bl3)) | 0;
    mid = (mid + Math.imul(al5, bh3)) | 0;
    mid = (mid + Math.imul(ah5, bl3)) | 0;
    hi = (hi + Math.imul(ah5, bh3)) | 0;
    lo = (lo + Math.imul(al4, bl4)) | 0;
    mid = (mid + Math.imul(al4, bh4)) | 0;
    mid = (mid + Math.imul(ah4, bl4)) | 0;
    hi = (hi + Math.imul(ah4, bh4)) | 0;
    lo = (lo + Math.imul(al3, bl5)) | 0;
    mid = (mid + Math.imul(al3, bh5)) | 0;
    mid = (mid + Math.imul(ah3, bl5)) | 0;
    hi = (hi + Math.imul(ah3, bh5)) | 0;
    lo = (lo + Math.imul(al2, bl6)) | 0;
    mid = (mid + Math.imul(al2, bh6)) | 0;
    mid = (mid + Math.imul(ah2, bl6)) | 0;
    hi = (hi + Math.imul(ah2, bh6)) | 0;
    lo = (lo + Math.imul(al1, bl7)) | 0;
    mid = (mid + Math.imul(al1, bh7)) | 0;
    mid = (mid + Math.imul(ah1, bl7)) | 0;
    hi = (hi + Math.imul(ah1, bh7)) | 0;
    lo = (lo + Math.imul(al0, bl8)) | 0;
    mid = (mid + Math.imul(al0, bh8)) | 0;
    mid = (mid + Math.imul(ah0, bl8)) | 0;
    hi = (hi + Math.imul(ah0, bh8)) | 0;
    var w8 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w8 >>> 26)) | 0;
    w8 &= 0x3ffffff;
    /* k = 9 */
    lo = Math.imul(al9, bl0);
    mid = Math.imul(al9, bh0);
    mid = (mid + Math.imul(ah9, bl0)) | 0;
    hi = Math.imul(ah9, bh0);
    lo = (lo + Math.imul(al8, bl1)) | 0;
    mid = (mid + Math.imul(al8, bh1)) | 0;
    mid = (mid + Math.imul(ah8, bl1)) | 0;
    hi = (hi + Math.imul(ah8, bh1)) | 0;
    lo = (lo + Math.imul(al7, bl2)) | 0;
    mid = (mid + Math.imul(al7, bh2)) | 0;
    mid = (mid + Math.imul(ah7, bl2)) | 0;
    hi = (hi + Math.imul(ah7, bh2)) | 0;
    lo = (lo + Math.imul(al6, bl3)) | 0;
    mid = (mid + Math.imul(al6, bh3)) | 0;
    mid = (mid + Math.imul(ah6, bl3)) | 0;
    hi = (hi + Math.imul(ah6, bh3)) | 0;
    lo = (lo + Math.imul(al5, bl4)) | 0;
    mid = (mid + Math.imul(al5, bh4)) | 0;
    mid = (mid + Math.imul(ah5, bl4)) | 0;
    hi = (hi + Math.imul(ah5, bh4)) | 0;
    lo = (lo + Math.imul(al4, bl5)) | 0;
    mid = (mid + Math.imul(al4, bh5)) | 0;
    mid = (mid + Math.imul(ah4, bl5)) | 0;
    hi = (hi + Math.imul(ah4, bh5)) | 0;
    lo = (lo + Math.imul(al3, bl6)) | 0;
    mid = (mid + Math.imul(al3, bh6)) | 0;
    mid = (mid + Math.imul(ah3, bl6)) | 0;
    hi = (hi + Math.imul(ah3, bh6)) | 0;
    lo = (lo + Math.imul(al2, bl7)) | 0;
    mid = (mid + Math.imul(al2, bh7)) | 0;
    mid = (mid + Math.imul(ah2, bl7)) | 0;
    hi = (hi + Math.imul(ah2, bh7)) | 0;
    lo = (lo + Math.imul(al1, bl8)) | 0;
    mid = (mid + Math.imul(al1, bh8)) | 0;
    mid = (mid + Math.imul(ah1, bl8)) | 0;
    hi = (hi + Math.imul(ah1, bh8)) | 0;
    lo = (lo + Math.imul(al0, bl9)) | 0;
    mid = (mid + Math.imul(al0, bh9)) | 0;
    mid = (mid + Math.imul(ah0, bl9)) | 0;
    hi = (hi + Math.imul(ah0, bh9)) | 0;
    var w9 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w9 >>> 26)) | 0;
    w9 &= 0x3ffffff;
    /* k = 10 */
    lo = Math.imul(al9, bl1);
    mid = Math.imul(al9, bh1);
    mid = (mid + Math.imul(ah9, bl1)) | 0;
    hi = Math.imul(ah9, bh1);
    lo = (lo + Math.imul(al8, bl2)) | 0;
    mid = (mid + Math.imul(al8, bh2)) | 0;
    mid = (mid + Math.imul(ah8, bl2)) | 0;
    hi = (hi + Math.imul(ah8, bh2)) | 0;
    lo = (lo + Math.imul(al7, bl3)) | 0;
    mid = (mid + Math.imul(al7, bh3)) | 0;
    mid = (mid + Math.imul(ah7, bl3)) | 0;
    hi = (hi + Math.imul(ah7, bh3)) | 0;
    lo = (lo + Math.imul(al6, bl4)) | 0;
    mid = (mid + Math.imul(al6, bh4)) | 0;
    mid = (mid + Math.imul(ah6, bl4)) | 0;
    hi = (hi + Math.imul(ah6, bh4)) | 0;
    lo = (lo + Math.imul(al5, bl5)) | 0;
    mid = (mid + Math.imul(al5, bh5)) | 0;
    mid = (mid + Math.imul(ah5, bl5)) | 0;
    hi = (hi + Math.imul(ah5, bh5)) | 0;
    lo = (lo + Math.imul(al4, bl6)) | 0;
    mid = (mid + Math.imul(al4, bh6)) | 0;
    mid = (mid + Math.imul(ah4, bl6)) | 0;
    hi = (hi + Math.imul(ah4, bh6)) | 0;
    lo = (lo + Math.imul(al3, bl7)) | 0;
    mid = (mid + Math.imul(al3, bh7)) | 0;
    mid = (mid + Math.imul(ah3, bl7)) | 0;
    hi = (hi + Math.imul(ah3, bh7)) | 0;
    lo = (lo + Math.imul(al2, bl8)) | 0;
    mid = (mid + Math.imul(al2, bh8)) | 0;
    mid = (mid + Math.imul(ah2, bl8)) | 0;
    hi = (hi + Math.imul(ah2, bh8)) | 0;
    lo = (lo + Math.imul(al1, bl9)) | 0;
    mid = (mid + Math.imul(al1, bh9)) | 0;
    mid = (mid + Math.imul(ah1, bl9)) | 0;
    hi = (hi + Math.imul(ah1, bh9)) | 0;
    var w10 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w10 >>> 26)) | 0;
    w10 &= 0x3ffffff;
    /* k = 11 */
    lo = Math.imul(al9, bl2);
    mid = Math.imul(al9, bh2);
    mid = (mid + Math.imul(ah9, bl2)) | 0;
    hi = Math.imul(ah9, bh2);
    lo = (lo + Math.imul(al8, bl3)) | 0;
    mid = (mid + Math.imul(al8, bh3)) | 0;
    mid = (mid + Math.imul(ah8, bl3)) | 0;
    hi = (hi + Math.imul(ah8, bh3)) | 0;
    lo = (lo + Math.imul(al7, bl4)) | 0;
    mid = (mid + Math.imul(al7, bh4)) | 0;
    mid = (mid + Math.imul(ah7, bl4)) | 0;
    hi = (hi + Math.imul(ah7, bh4)) | 0;
    lo = (lo + Math.imul(al6, bl5)) | 0;
    mid = (mid + Math.imul(al6, bh5)) | 0;
    mid = (mid + Math.imul(ah6, bl5)) | 0;
    hi = (hi + Math.imul(ah6, bh5)) | 0;
    lo = (lo + Math.imul(al5, bl6)) | 0;
    mid = (mid + Math.imul(al5, bh6)) | 0;
    mid = (mid + Math.imul(ah5, bl6)) | 0;
    hi = (hi + Math.imul(ah5, bh6)) | 0;
    lo = (lo + Math.imul(al4, bl7)) | 0;
    mid = (mid + Math.imul(al4, bh7)) | 0;
    mid = (mid + Math.imul(ah4, bl7)) | 0;
    hi = (hi + Math.imul(ah4, bh7)) | 0;
    lo = (lo + Math.imul(al3, bl8)) | 0;
    mid = (mid + Math.imul(al3, bh8)) | 0;
    mid = (mid + Math.imul(ah3, bl8)) | 0;
    hi = (hi + Math.imul(ah3, bh8)) | 0;
    lo = (lo + Math.imul(al2, bl9)) | 0;
    mid = (mid + Math.imul(al2, bh9)) | 0;
    mid = (mid + Math.imul(ah2, bl9)) | 0;
    hi = (hi + Math.imul(ah2, bh9)) | 0;
    var w11 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w11 >>> 26)) | 0;
    w11 &= 0x3ffffff;
    /* k = 12 */
    lo = Math.imul(al9, bl3);
    mid = Math.imul(al9, bh3);
    mid = (mid + Math.imul(ah9, bl3)) | 0;
    hi = Math.imul(ah9, bh3);
    lo = (lo + Math.imul(al8, bl4)) | 0;
    mid = (mid + Math.imul(al8, bh4)) | 0;
    mid = (mid + Math.imul(ah8, bl4)) | 0;
    hi = (hi + Math.imul(ah8, bh4)) | 0;
    lo = (lo + Math.imul(al7, bl5)) | 0;
    mid = (mid + Math.imul(al7, bh5)) | 0;
    mid = (mid + Math.imul(ah7, bl5)) | 0;
    hi = (hi + Math.imul(ah7, bh5)) | 0;
    lo = (lo + Math.imul(al6, bl6)) | 0;
    mid = (mid + Math.imul(al6, bh6)) | 0;
    mid = (mid + Math.imul(ah6, bl6)) | 0;
    hi = (hi + Math.imul(ah6, bh6)) | 0;
    lo = (lo + Math.imul(al5, bl7)) | 0;
    mid = (mid + Math.imul(al5, bh7)) | 0;
    mid = (mid + Math.imul(ah5, bl7)) | 0;
    hi = (hi + Math.imul(ah5, bh7)) | 0;
    lo = (lo + Math.imul(al4, bl8)) | 0;
    mid = (mid + Math.imul(al4, bh8)) | 0;
    mid = (mid + Math.imul(ah4, bl8)) | 0;
    hi = (hi + Math.imul(ah4, bh8)) | 0;
    lo = (lo + Math.imul(al3, bl9)) | 0;
    mid = (mid + Math.imul(al3, bh9)) | 0;
    mid = (mid + Math.imul(ah3, bl9)) | 0;
    hi = (hi + Math.imul(ah3, bh9)) | 0;
    var w12 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w12 >>> 26)) | 0;
    w12 &= 0x3ffffff;
    /* k = 13 */
    lo = Math.imul(al9, bl4);
    mid = Math.imul(al9, bh4);
    mid = (mid + Math.imul(ah9, bl4)) | 0;
    hi = Math.imul(ah9, bh4);
    lo = (lo + Math.imul(al8, bl5)) | 0;
    mid = (mid + Math.imul(al8, bh5)) | 0;
    mid = (mid + Math.imul(ah8, bl5)) | 0;
    hi = (hi + Math.imul(ah8, bh5)) | 0;
    lo = (lo + Math.imul(al7, bl6)) | 0;
    mid = (mid + Math.imul(al7, bh6)) | 0;
    mid = (mid + Math.imul(ah7, bl6)) | 0;
    hi = (hi + Math.imul(ah7, bh6)) | 0;
    lo = (lo + Math.imul(al6, bl7)) | 0;
    mid = (mid + Math.imul(al6, bh7)) | 0;
    mid = (mid + Math.imul(ah6, bl7)) | 0;
    hi = (hi + Math.imul(ah6, bh7)) | 0;
    lo = (lo + Math.imul(al5, bl8)) | 0;
    mid = (mid + Math.imul(al5, bh8)) | 0;
    mid = (mid + Math.imul(ah5, bl8)) | 0;
    hi = (hi + Math.imul(ah5, bh8)) | 0;
    lo = (lo + Math.imul(al4, bl9)) | 0;
    mid = (mid + Math.imul(al4, bh9)) | 0;
    mid = (mid + Math.imul(ah4, bl9)) | 0;
    hi = (hi + Math.imul(ah4, bh9)) | 0;
    var w13 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w13 >>> 26)) | 0;
    w13 &= 0x3ffffff;
    /* k = 14 */
    lo = Math.imul(al9, bl5);
    mid = Math.imul(al9, bh5);
    mid = (mid + Math.imul(ah9, bl5)) | 0;
    hi = Math.imul(ah9, bh5);
    lo = (lo + Math.imul(al8, bl6)) | 0;
    mid = (mid + Math.imul(al8, bh6)) | 0;
    mid = (mid + Math.imul(ah8, bl6)) | 0;
    hi = (hi + Math.imul(ah8, bh6)) | 0;
    lo = (lo + Math.imul(al7, bl7)) | 0;
    mid = (mid + Math.imul(al7, bh7)) | 0;
    mid = (mid + Math.imul(ah7, bl7)) | 0;
    hi = (hi + Math.imul(ah7, bh7)) | 0;
    lo = (lo + Math.imul(al6, bl8)) | 0;
    mid = (mid + Math.imul(al6, bh8)) | 0;
    mid = (mid + Math.imul(ah6, bl8)) | 0;
    hi = (hi + Math.imul(ah6, bh8)) | 0;
    lo = (lo + Math.imul(al5, bl9)) | 0;
    mid = (mid + Math.imul(al5, bh9)) | 0;
    mid = (mid + Math.imul(ah5, bl9)) | 0;
    hi = (hi + Math.imul(ah5, bh9)) | 0;
    var w14 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w14 >>> 26)) | 0;
    w14 &= 0x3ffffff;
    /* k = 15 */
    lo = Math.imul(al9, bl6);
    mid = Math.imul(al9, bh6);
    mid = (mid + Math.imul(ah9, bl6)) | 0;
    hi = Math.imul(ah9, bh6);
    lo = (lo + Math.imul(al8, bl7)) | 0;
    mid = (mid + Math.imul(al8, bh7)) | 0;
    mid = (mid + Math.imul(ah8, bl7)) | 0;
    hi = (hi + Math.imul(ah8, bh7)) | 0;
    lo = (lo + Math.imul(al7, bl8)) | 0;
    mid = (mid + Math.imul(al7, bh8)) | 0;
    mid = (mid + Math.imul(ah7, bl8)) | 0;
    hi = (hi + Math.imul(ah7, bh8)) | 0;
    lo = (lo + Math.imul(al6, bl9)) | 0;
    mid = (mid + Math.imul(al6, bh9)) | 0;
    mid = (mid + Math.imul(ah6, bl9)) | 0;
    hi = (hi + Math.imul(ah6, bh9)) | 0;
    var w15 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w15 >>> 26)) | 0;
    w15 &= 0x3ffffff;
    /* k = 16 */
    lo = Math.imul(al9, bl7);
    mid = Math.imul(al9, bh7);
    mid = (mid + Math.imul(ah9, bl7)) | 0;
    hi = Math.imul(ah9, bh7);
    lo = (lo + Math.imul(al8, bl8)) | 0;
    mid = (mid + Math.imul(al8, bh8)) | 0;
    mid = (mid + Math.imul(ah8, bl8)) | 0;
    hi = (hi + Math.imul(ah8, bh8)) | 0;
    lo = (lo + Math.imul(al7, bl9)) | 0;
    mid = (mid + Math.imul(al7, bh9)) | 0;
    mid = (mid + Math.imul(ah7, bl9)) | 0;
    hi = (hi + Math.imul(ah7, bh9)) | 0;
    var w16 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w16 >>> 26)) | 0;
    w16 &= 0x3ffffff;
    /* k = 17 */
    lo = Math.imul(al9, bl8);
    mid = Math.imul(al9, bh8);
    mid = (mid + Math.imul(ah9, bl8)) | 0;
    hi = Math.imul(ah9, bh8);
    lo = (lo + Math.imul(al8, bl9)) | 0;
    mid = (mid + Math.imul(al8, bh9)) | 0;
    mid = (mid + Math.imul(ah8, bl9)) | 0;
    hi = (hi + Math.imul(ah8, bh9)) | 0;
    var w17 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w17 >>> 26)) | 0;
    w17 &= 0x3ffffff;
    /* k = 18 */
    lo = Math.imul(al9, bl9);
    mid = Math.imul(al9, bh9);
    mid = (mid + Math.imul(ah9, bl9)) | 0;
    hi = Math.imul(ah9, bh9);
    var w18 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w18 >>> 26)) | 0;
    w18 &= 0x3ffffff;
    o[0] = w0;
    o[1] = w1;
    o[2] = w2;
    o[3] = w3;
    o[4] = w4;
    o[5] = w5;
    o[6] = w6;
    o[7] = w7;
    o[8] = w8;
    o[9] = w9;
    o[10] = w10;
    o[11] = w11;
    o[12] = w12;
    o[13] = w13;
    o[14] = w14;
    o[15] = w15;
    o[16] = w16;
    o[17] = w17;
    o[18] = w18;
    if (c !== 0) {
      o[19] = c;
      out.length++;
    }
    return out;
  };

  // Polyfill comb
  if (!Math.imul) {
    comb10MulTo = smallMulTo;
  }

  function bigMulTo (self, num, out) {
    out.negative = num.negative ^ self.negative;
    out.length = self.length + num.length;

    var carry = 0;
    var hncarry = 0;
    for (var k = 0; k < out.length - 1; k++) {
      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
      // note that ncarry could be >= 0x3ffffff
      var ncarry = hncarry;
      hncarry = 0;
      var rword = carry & 0x3ffffff;
      var maxJ = Math.min(k, num.length - 1);
      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
        var i = k - j;
        var a = self.words[i] | 0;
        var b = num.words[j] | 0;
        var r = a * b;

        var lo = r & 0x3ffffff;
        ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;
        lo = (lo + rword) | 0;
        rword = lo & 0x3ffffff;
        ncarry = (ncarry + (lo >>> 26)) | 0;

        hncarry += ncarry >>> 26;
        ncarry &= 0x3ffffff;
      }
      out.words[k] = rword;
      carry = ncarry;
      ncarry = hncarry;
    }
    if (carry !== 0) {
      out.words[k] = carry;
    } else {
      out.length--;
    }

    return out.strip();
  }

  function jumboMulTo (self, num, out) {
    var fftm = new FFTM();
    return fftm.mulp(self, num, out);
  }

  BN.prototype.mulTo = function mulTo (num, out) {
    var res;
    var len = this.length + num.length;
    if (this.length === 10 && num.length === 10) {
      res = comb10MulTo(this, num, out);
    } else if (len < 63) {
      res = smallMulTo(this, num, out);
    } else if (len < 1024) {
      res = bigMulTo(this, num, out);
    } else {
      res = jumboMulTo(this, num, out);
    }

    return res;
  };

  // Cooley-Tukey algorithm for FFT
  // slightly revisited to rely on looping instead of recursion

  function FFTM (x, y) {
    this.x = x;
    this.y = y;
  }

  FFTM.prototype.makeRBT = function makeRBT (N) {
    var t = new Array(N);
    var l = BN.prototype._countBits(N) - 1;
    for (var i = 0; i < N; i++) {
      t[i] = this.revBin(i, l, N);
    }

    return t;
  };

  // Returns binary-reversed representation of `x`
  FFTM.prototype.revBin = function revBin (x, l, N) {
    if (x === 0 || x === N - 1) return x;

    var rb = 0;
    for (var i = 0; i < l; i++) {
      rb |= (x & 1) << (l - i - 1);
      x >>= 1;
    }

    return rb;
  };

  // Performs "tweedling" phase, therefore 'emulating'
  // behaviour of the recursive algorithm
  FFTM.prototype.permute = function permute (rbt, rws, iws, rtws, itws, N) {
    for (var i = 0; i < N; i++) {
      rtws[i] = rws[rbt[i]];
      itws[i] = iws[rbt[i]];
    }
  };

  FFTM.prototype.transform = function transform (rws, iws, rtws, itws, N, rbt) {
    this.permute(rbt, rws, iws, rtws, itws, N);

    for (var s = 1; s < N; s <<= 1) {
      var l = s << 1;

      var rtwdf = Math.cos(2 * Math.PI / l);
      var itwdf = Math.sin(2 * Math.PI / l);

      for (var p = 0; p < N; p += l) {
        var rtwdf_ = rtwdf;
        var itwdf_ = itwdf;

        for (var j = 0; j < s; j++) {
          var re = rtws[p + j];
          var ie = itws[p + j];

          var ro = rtws[p + j + s];
          var io = itws[p + j + s];

          var rx = rtwdf_ * ro - itwdf_ * io;

          io = rtwdf_ * io + itwdf_ * ro;
          ro = rx;

          rtws[p + j] = re + ro;
          itws[p + j] = ie + io;

          rtws[p + j + s] = re - ro;
          itws[p + j + s] = ie - io;

          /* jshint maxdepth : false */
          if (j !== l) {
            rx = rtwdf * rtwdf_ - itwdf * itwdf_;

            itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
            rtwdf_ = rx;
          }
        }
      }
    }
  };

  FFTM.prototype.guessLen13b = function guessLen13b (n, m) {
    var N = Math.max(m, n) | 1;
    var odd = N & 1;
    var i = 0;
    for (N = N / 2 | 0; N; N = N >>> 1) {
      i++;
    }

    return 1 << i + 1 + odd;
  };

  FFTM.prototype.conjugate = function conjugate (rws, iws, N) {
    if (N <= 1) return;

    for (var i = 0; i < N / 2; i++) {
      var t = rws[i];

      rws[i] = rws[N - i - 1];
      rws[N - i - 1] = t;

      t = iws[i];

      iws[i] = -iws[N - i - 1];
      iws[N - i - 1] = -t;
    }
  };

  FFTM.prototype.normalize13b = function normalize13b (ws, N) {
    var carry = 0;
    for (var i = 0; i < N / 2; i++) {
      var w = Math.round(ws[2 * i + 1] / N) * 0x2000 +
        Math.round(ws[2 * i] / N) +
        carry;

      ws[i] = w & 0x3ffffff;

      if (w < 0x4000000) {
        carry = 0;
      } else {
        carry = w / 0x4000000 | 0;
      }
    }

    return ws;
  };

  FFTM.prototype.convert13b = function convert13b (ws, len, rws, N) {
    var carry = 0;
    for (var i = 0; i < len; i++) {
      carry = carry + (ws[i] | 0);

      rws[2 * i] = carry & 0x1fff; carry = carry >>> 13;
      rws[2 * i + 1] = carry & 0x1fff; carry = carry >>> 13;
    }

    // Pad with zeroes
    for (i = 2 * len; i < N; ++i) {
      rws[i] = 0;
    }

    assert(carry === 0);
    assert((carry & ~0x1fff) === 0);
  };

  FFTM.prototype.stub = function stub (N) {
    var ph = new Array(N);
    for (var i = 0; i < N; i++) {
      ph[i] = 0;
    }

    return ph;
  };

  FFTM.prototype.mulp = function mulp (x, y, out) {
    var N = 2 * this.guessLen13b(x.length, y.length);

    var rbt = this.makeRBT(N);

    var _ = this.stub(N);

    var rws = new Array(N);
    var rwst = new Array(N);
    var iwst = new Array(N);

    var nrws = new Array(N);
    var nrwst = new Array(N);
    var niwst = new Array(N);

    var rmws = out.words;
    rmws.length = N;

    this.convert13b(x.words, x.length, rws, N);
    this.convert13b(y.words, y.length, nrws, N);

    this.transform(rws, _, rwst, iwst, N, rbt);
    this.transform(nrws, _, nrwst, niwst, N, rbt);

    for (var i = 0; i < N; i++) {
      var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
      iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
      rwst[i] = rx;
    }

    this.conjugate(rwst, iwst, N);
    this.transform(rwst, iwst, rmws, _, N, rbt);
    this.conjugate(rmws, _, N);
    this.normalize13b(rmws, N);

    out.negative = x.negative ^ y.negative;
    out.length = x.length + y.length;
    return out.strip();
  };

  // Multiply `this` by `num`
  BN.prototype.mul = function mul (num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return this.mulTo(num, out);
  };

  // Multiply employing FFT
  BN.prototype.mulf = function mulf (num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return jumboMulTo(this, num, out);
  };

  // In-place Multiplication
  BN.prototype.imul = function imul (num) {
    return this.clone().mulTo(num, this);
  };

  BN.prototype.imuln = function imuln (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);

    // Carry
    var carry = 0;
    for (var i = 0; i < this.length; i++) {
      var w = (this.words[i] | 0) * num;
      var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);
      carry >>= 26;
      carry += (w / 0x4000000) | 0;
      // NOTE: lo is 27bit maximum
      carry += lo >>> 26;
      this.words[i] = lo & 0x3ffffff;
    }

    if (carry !== 0) {
      this.words[i] = carry;
      this.length++;
    }

    return this;
  };

  BN.prototype.muln = function muln (num) {
    return this.clone().imuln(num);
  };

  // `this` * `this`
  BN.prototype.sqr = function sqr () {
    return this.mul(this);
  };

  // `this` * `this` in-place
  BN.prototype.isqr = function isqr () {
    return this.imul(this.clone());
  };

  // Math.pow(`this`, `num`)
  BN.prototype.pow = function pow (num) {
    var w = toBitArray(num);
    if (w.length === 0) return new BN(1);

    // Skip leading zeroes
    var res = this;
    for (var i = 0; i < w.length; i++, res = res.sqr()) {
      if (w[i] !== 0) break;
    }

    if (++i < w.length) {
      for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
        if (w[i] === 0) continue;

        res = res.mul(q);
      }
    }

    return res;
  };

  // Shift-left in-place
  BN.prototype.iushln = function iushln (bits) {
    assert(typeof bits === 'number' && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;
    var carryMask = (0x3ffffff >>> (26 - r)) << (26 - r);
    var i;

    if (r !== 0) {
      var carry = 0;

      for (i = 0; i < this.length; i++) {
        var newCarry = this.words[i] & carryMask;
        var c = ((this.words[i] | 0) - newCarry) << r;
        this.words[i] = c | carry;
        carry = newCarry >>> (26 - r);
      }

      if (carry) {
        this.words[i] = carry;
        this.length++;
      }
    }

    if (s !== 0) {
      for (i = this.length - 1; i >= 0; i--) {
        this.words[i + s] = this.words[i];
      }

      for (i = 0; i < s; i++) {
        this.words[i] = 0;
      }

      this.length += s;
    }

    return this.strip();
  };

  BN.prototype.ishln = function ishln (bits) {
    // TODO(indutny): implement me
    assert(this.negative === 0);
    return this.iushln(bits);
  };

  // Shift-right in-place
  // NOTE: `hint` is a lowest bit before trailing zeroes
  // NOTE: if `extended` is present - it will be filled with destroyed bits
  BN.prototype.iushrn = function iushrn (bits, hint, extended) {
    assert(typeof bits === 'number' && bits >= 0);
    var h;
    if (hint) {
      h = (hint - (hint % 26)) / 26;
    } else {
      h = 0;
    }

    var r = bits % 26;
    var s = Math.min((bits - r) / 26, this.length);
    var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
    var maskedWords = extended;

    h -= s;
    h = Math.max(0, h);

    // Extended mode, copy masked part
    if (maskedWords) {
      for (var i = 0; i < s; i++) {
        maskedWords.words[i] = this.words[i];
      }
      maskedWords.length = s;
    }

    if (s === 0) {
      // No-op, we should not move anything at all
    } else if (this.length > s) {
      this.length -= s;
      for (i = 0; i < this.length; i++) {
        this.words[i] = this.words[i + s];
      }
    } else {
      this.words[0] = 0;
      this.length = 1;
    }

    var carry = 0;
    for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
      var word = this.words[i] | 0;
      this.words[i] = (carry << (26 - r)) | (word >>> r);
      carry = word & mask;
    }

    // Push carried bits as a mask
    if (maskedWords && carry !== 0) {
      maskedWords.words[maskedWords.length++] = carry;
    }

    if (this.length === 0) {
      this.words[0] = 0;
      this.length = 1;
    }

    return this.strip();
  };

  BN.prototype.ishrn = function ishrn (bits, hint, extended) {
    // TODO(indutny): implement me
    assert(this.negative === 0);
    return this.iushrn(bits, hint, extended);
  };

  // Shift-left
  BN.prototype.shln = function shln (bits) {
    return this.clone().ishln(bits);
  };

  BN.prototype.ushln = function ushln (bits) {
    return this.clone().iushln(bits);
  };

  // Shift-right
  BN.prototype.shrn = function shrn (bits) {
    return this.clone().ishrn(bits);
  };

  BN.prototype.ushrn = function ushrn (bits) {
    return this.clone().iushrn(bits);
  };

  // Test if n bit is set
  BN.prototype.testn = function testn (bit) {
    assert(typeof bit === 'number' && bit >= 0);
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r;

    // Fast case: bit is much higher than all existing words
    if (this.length <= s) return false;

    // Check bit and return
    var w = this.words[s];

    return !!(w & q);
  };

  // Return only lowers bits of number (in-place)
  BN.prototype.imaskn = function imaskn (bits) {
    assert(typeof bits === 'number' && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;

    assert(this.negative === 0, 'imaskn works only with positive numbers');

    if (this.length <= s) {
      return this;
    }

    if (r !== 0) {
      s++;
    }
    this.length = Math.min(s, this.length);

    if (r !== 0) {
      var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
      this.words[this.length - 1] &= mask;
    }

    return this.strip();
  };

  // Return only lowers bits of number
  BN.prototype.maskn = function maskn (bits) {
    return this.clone().imaskn(bits);
  };

  // Add plain number `num` to `this`
  BN.prototype.iaddn = function iaddn (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);
    if (num < 0) return this.isubn(-num);

    // Possible sign change
    if (this.negative !== 0) {
      if (this.length === 1 && (this.words[0] | 0) < num) {
        this.words[0] = num - (this.words[0] | 0);
        this.negative = 0;
        return this;
      }

      this.negative = 0;
      this.isubn(num);
      this.negative = 1;
      return this;
    }

    // Add without checks
    return this._iaddn(num);
  };

  BN.prototype._iaddn = function _iaddn (num) {
    this.words[0] += num;

    // Carry
    for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) {
      this.words[i] -= 0x4000000;
      if (i === this.length - 1) {
        this.words[i + 1] = 1;
      } else {
        this.words[i + 1]++;
      }
    }
    this.length = Math.max(this.length, i + 1);

    return this;
  };

  // Subtract plain number `num` from `this`
  BN.prototype.isubn = function isubn (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);
    if (num < 0) return this.iaddn(-num);

    if (this.negative !== 0) {
      this.negative = 0;
      this.iaddn(num);
      this.negative = 1;
      return this;
    }

    this.words[0] -= num;

    if (this.length === 1 && this.words[0] < 0) {
      this.words[0] = -this.words[0];
      this.negative = 1;
    } else {
      // Carry
      for (var i = 0; i < this.length && this.words[i] < 0; i++) {
        this.words[i] += 0x4000000;
        this.words[i + 1] -= 1;
      }
    }

    return this.strip();
  };

  BN.prototype.addn = function addn (num) {
    return this.clone().iaddn(num);
  };

  BN.prototype.subn = function subn (num) {
    return this.clone().isubn(num);
  };

  BN.prototype.iabs = function iabs () {
    this.negative = 0;

    return this;
  };

  BN.prototype.abs = function abs () {
    return this.clone().iabs();
  };

  BN.prototype._ishlnsubmul = function _ishlnsubmul (num, mul, shift) {
    var len = num.length + shift;
    var i;

    this._expand(len);

    var w;
    var carry = 0;
    for (i = 0; i < num.length; i++) {
      w = (this.words[i + shift] | 0) + carry;
      var right = (num.words[i] | 0) * mul;
      w -= right & 0x3ffffff;
      carry = (w >> 26) - ((right / 0x4000000) | 0);
      this.words[i + shift] = w & 0x3ffffff;
    }
    for (; i < this.length - shift; i++) {
      w = (this.words[i + shift] | 0) + carry;
      carry = w >> 26;
      this.words[i + shift] = w & 0x3ffffff;
    }

    if (carry === 0) return this.strip();

    // Subtraction overflow
    assert(carry === -1);
    carry = 0;
    for (i = 0; i < this.length; i++) {
      w = -(this.words[i] | 0) + carry;
      carry = w >> 26;
      this.words[i] = w & 0x3ffffff;
    }
    this.negative = 1;

    return this.strip();
  };

  BN.prototype._wordDiv = function _wordDiv (num, mode) {
    var shift = this.length - num.length;

    var a = this.clone();
    var b = num;

    // Normalize
    var bhi = b.words[b.length - 1] | 0;
    var bhiBits = this._countBits(bhi);
    shift = 26 - bhiBits;
    if (shift !== 0) {
      b = b.ushln(shift);
      a.iushln(shift);
      bhi = b.words[b.length - 1] | 0;
    }

    // Initialize quotient
    var m = a.length - b.length;
    var q;

    if (mode !== 'mod') {
      q = new BN(null);
      q.length = m + 1;
      q.words = new Array(q.length);
      for (var i = 0; i < q.length; i++) {
        q.words[i] = 0;
      }
    }

    var diff = a.clone()._ishlnsubmul(b, 1, m);
    if (diff.negative === 0) {
      a = diff;
      if (q) {
        q.words[m] = 1;
      }
    }

    for (var j = m - 1; j >= 0; j--) {
      var qj = (a.words[b.length + j] | 0) * 0x4000000 +
        (a.words[b.length + j - 1] | 0);

      // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max
      // (0x7ffffff)
      qj = Math.min((qj / bhi) | 0, 0x3ffffff);

      a._ishlnsubmul(b, qj, j);
      while (a.negative !== 0) {
        qj--;
        a.negative = 0;
        a._ishlnsubmul(b, 1, j);
        if (!a.isZero()) {
          a.negative ^= 1;
        }
      }
      if (q) {
        q.words[j] = qj;
      }
    }
    if (q) {
      q.strip();
    }
    a.strip();

    // Denormalize
    if (mode !== 'div' && shift !== 0) {
      a.iushrn(shift);
    }

    return {
      div: q || null,
      mod: a
    };
  };

  // NOTE: 1) `mode` can be set to `mod` to request mod only,
  //       to `div` to request div only, or be absent to
  //       request both div & mod
  //       2) `positive` is true if unsigned mod is requested
  BN.prototype.divmod = function divmod (num, mode, positive) {
    assert(!num.isZero());

    if (this.isZero()) {
      return {
        div: new BN(0),
        mod: new BN(0)
      };
    }

    var div, mod, res;
    if (this.negative !== 0 && num.negative === 0) {
      res = this.neg().divmod(num, mode);

      if (mode !== 'mod') {
        div = res.div.neg();
      }

      if (mode !== 'div') {
        mod = res.mod.neg();
        if (positive && mod.negative !== 0) {
          mod.iadd(num);
        }
      }

      return {
        div: div,
        mod: mod
      };
    }

    if (this.negative === 0 && num.negative !== 0) {
      res = this.divmod(num.neg(), mode);

      if (mode !== 'mod') {
        div = res.div.neg();
      }

      return {
        div: div,
        mod: res.mod
      };
    }

    if ((this.negative & num.negative) !== 0) {
      res = this.neg().divmod(num.neg(), mode);

      if (mode !== 'div') {
        mod = res.mod.neg();
        if (positive && mod.negative !== 0) {
          mod.isub(num);
        }
      }

      return {
        div: res.div,
        mod: mod
      };
    }

    // Both numbers are positive at this point

    // Strip both numbers to approximate shift value
    if (num.length > this.length || this.cmp(num) < 0) {
      return {
        div: new BN(0),
        mod: this
      };
    }

    // Very short reduction
    if (num.length === 1) {
      if (mode === 'div') {
        return {
          div: this.divn(num.words[0]),
          mod: null
        };
      }

      if (mode === 'mod') {
        return {
          div: null,
          mod: new BN(this.modn(num.words[0]))
        };
      }

      return {
        div: this.divn(num.words[0]),
        mod: new BN(this.modn(num.words[0]))
      };
    }

    return this._wordDiv(num, mode);
  };

  // Find `this` / `num`
  BN.prototype.div = function div (num) {
    return this.divmod(num, 'div', false).div;
  };

  // Find `this` % `num`
  BN.prototype.mod = function mod (num) {
    return this.divmod(num, 'mod', false).mod;
  };

  BN.prototype.umod = function umod (num) {
    return this.divmod(num, 'mod', true).mod;
  };

  // Find Round(`this` / `num`)
  BN.prototype.divRound = function divRound (num) {
    var dm = this.divmod(num);

    // Fast case - exact division
    if (dm.mod.isZero()) return dm.div;

    var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;

    var half = num.ushrn(1);
    var r2 = num.andln(1);
    var cmp = mod.cmp(half);

    // Round down
    if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div;

    // Round up
    return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
  };

  BN.prototype.modn = function modn (num) {
    assert(num <= 0x3ffffff);
    var p = (1 << 26) % num;

    var acc = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      acc = (p * acc + (this.words[i] | 0)) % num;
    }

    return acc;
  };

  // In-place division by number
  BN.prototype.idivn = function idivn (num) {
    assert(num <= 0x3ffffff);

    var carry = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      var w = (this.words[i] | 0) + carry * 0x4000000;
      this.words[i] = (w / num) | 0;
      carry = w % num;
    }

    return this.strip();
  };

  BN.prototype.divn = function divn (num) {
    return this.clone().idivn(num);
  };

  BN.prototype.egcd = function egcd (p) {
    assert(p.negative === 0);
    assert(!p.isZero());

    var x = this;
    var y = p.clone();

    if (x.negative !== 0) {
      x = x.umod(p);
    } else {
      x = x.clone();
    }

    // A * x + B * y = x
    var A = new BN(1);
    var B = new BN(0);

    // C * x + D * y = y
    var C = new BN(0);
    var D = new BN(1);

    var g = 0;

    while (x.isEven() && y.isEven()) {
      x.iushrn(1);
      y.iushrn(1);
      ++g;
    }

    var yp = y.clone();
    var xp = x.clone();

    while (!x.isZero()) {
      for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
      if (i > 0) {
        x.iushrn(i);
        while (i-- > 0) {
          if (A.isOdd() || B.isOdd()) {
            A.iadd(yp);
            B.isub(xp);
          }

          A.iushrn(1);
          B.iushrn(1);
        }
      }

      for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
      if (j > 0) {
        y.iushrn(j);
        while (j-- > 0) {
          if (C.isOdd() || D.isOdd()) {
            C.iadd(yp);
            D.isub(xp);
          }

          C.iushrn(1);
          D.iushrn(1);
        }
      }

      if (x.cmp(y) >= 0) {
        x.isub(y);
        A.isub(C);
        B.isub(D);
      } else {
        y.isub(x);
        C.isub(A);
        D.isub(B);
      }
    }

    return {
      a: C,
      b: D,
      gcd: y.iushln(g)
    };
  };

  // This is reduced incarnation of the binary EEA
  // above, designated to invert members of the
  // _prime_ fields F(p) at a maximal speed
  BN.prototype._invmp = function _invmp (p) {
    assert(p.negative === 0);
    assert(!p.isZero());

    var a = this;
    var b = p.clone();

    if (a.negative !== 0) {
      a = a.umod(p);
    } else {
      a = a.clone();
    }

    var x1 = new BN(1);
    var x2 = new BN(0);

    var delta = b.clone();

    while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
      for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
      if (i > 0) {
        a.iushrn(i);
        while (i-- > 0) {
          if (x1.isOdd()) {
            x1.iadd(delta);
          }

          x1.iushrn(1);
        }
      }

      for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
      if (j > 0) {
        b.iushrn(j);
        while (j-- > 0) {
          if (x2.isOdd()) {
            x2.iadd(delta);
          }

          x2.iushrn(1);
        }
      }

      if (a.cmp(b) >= 0) {
        a.isub(b);
        x1.isub(x2);
      } else {
        b.isub(a);
        x2.isub(x1);
      }
    }

    var res;
    if (a.cmpn(1) === 0) {
      res = x1;
    } else {
      res = x2;
    }

    if (res.cmpn(0) < 0) {
      res.iadd(p);
    }

    return res;
  };

  BN.prototype.gcd = function gcd (num) {
    if (this.isZero()) return num.abs();
    if (num.isZero()) return this.abs();

    var a = this.clone();
    var b = num.clone();
    a.negative = 0;
    b.negative = 0;

    // Remove common factor of two
    for (var shift = 0; a.isEven() && b.isEven(); shift++) {
      a.iushrn(1);
      b.iushrn(1);
    }

    do {
      while (a.isEven()) {
        a.iushrn(1);
      }
      while (b.isEven()) {
        b.iushrn(1);
      }

      var r = a.cmp(b);
      if (r < 0) {
        // Swap `a` and `b` to make `a` always bigger than `b`
        var t = a;
        a = b;
        b = t;
      } else if (r === 0 || b.cmpn(1) === 0) {
        break;
      }

      a.isub(b);
    } while (true);

    return b.iushln(shift);
  };

  // Invert number in the field F(num)
  BN.prototype.invm = function invm (num) {
    return this.egcd(num).a.umod(num);
  };

  BN.prototype.isEven = function isEven () {
    return (this.words[0] & 1) === 0;
  };

  BN.prototype.isOdd = function isOdd () {
    return (this.words[0] & 1) === 1;
  };

  // And first word and num
  BN.prototype.andln = function andln (num) {
    return this.words[0] & num;
  };

  // Increment at the bit position in-line
  BN.prototype.bincn = function bincn (bit) {
    assert(typeof bit === 'number');
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r;

    // Fast case: bit is much higher than all existing words
    if (this.length <= s) {
      this._expand(s + 1);
      this.words[s] |= q;
      return this;
    }

    // Add bit and propagate, if needed
    var carry = q;
    for (var i = s; carry !== 0 && i < this.length; i++) {
      var w = this.words[i] | 0;
      w += carry;
      carry = w >>> 26;
      w &= 0x3ffffff;
      this.words[i] = w;
    }
    if (carry !== 0) {
      this.words[i] = carry;
      this.length++;
    }
    return this;
  };

  BN.prototype.isZero = function isZero () {
    return this.length === 1 && this.words[0] === 0;
  };

  BN.prototype.cmpn = function cmpn (num) {
    var negative = num < 0;

    if (this.negative !== 0 && !negative) return -1;
    if (this.negative === 0 && negative) return 1;

    this.strip();

    var res;
    if (this.length > 1) {
      res = 1;
    } else {
      if (negative) {
        num = -num;
      }

      assert(num <= 0x3ffffff, 'Number is too big');

      var w = this.words[0] | 0;
      res = w === num ? 0 : w < num ? -1 : 1;
    }
    if (this.negative !== 0) return -res | 0;
    return res;
  };

  // Compare two numbers and return:
  // 1 - if `this` > `num`
  // 0 - if `this` == `num`
  // -1 - if `this` < `num`
  BN.prototype.cmp = function cmp (num) {
    if (this.negative !== 0 && num.negative === 0) return -1;
    if (this.negative === 0 && num.negative !== 0) return 1;

    var res = this.ucmp(num);
    if (this.negative !== 0) return -res | 0;
    return res;
  };

  // Unsigned comparison
  BN.prototype.ucmp = function ucmp (num) {
    // At this point both numbers have the same sign
    if (this.length > num.length) return 1;
    if (this.length < num.length) return -1;

    var res = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      var a = this.words[i] | 0;
      var b = num.words[i] | 0;

      if (a === b) continue;
      if (a < b) {
        res = -1;
      } else if (a > b) {
        res = 1;
      }
      break;
    }
    return res;
  };

  BN.prototype.gtn = function gtn (num) {
    return this.cmpn(num) === 1;
  };

  BN.prototype.gt = function gt (num) {
    return this.cmp(num) === 1;
  };

  BN.prototype.gten = function gten (num) {
    return this.cmpn(num) >= 0;
  };

  BN.prototype.gte = function gte (num) {
    return this.cmp(num) >= 0;
  };

  BN.prototype.ltn = function ltn (num) {
    return this.cmpn(num) === -1;
  };

  BN.prototype.lt = function lt (num) {
    return this.cmp(num) === -1;
  };

  BN.prototype.lten = function lten (num) {
    return this.cmpn(num) <= 0;
  };

  BN.prototype.lte = function lte (num) {
    return this.cmp(num) <= 0;
  };

  BN.prototype.eqn = function eqn (num) {
    return this.cmpn(num) === 0;
  };

  BN.prototype.eq = function eq (num) {
    return this.cmp(num) === 0;
  };

  //
  // A reduce context, could be using montgomery or something better, depending
  // on the `m` itself.
  //
  BN.red = function red (num) {
    return new Red(num);
  };

  BN.prototype.toRed = function toRed (ctx) {
    assert(!this.red, 'Already a number in reduction context');
    assert(this.negative === 0, 'red works only with positives');
    return ctx.convertTo(this)._forceRed(ctx);
  };

  BN.prototype.fromRed = function fromRed () {
    assert(this.red, 'fromRed works only with numbers in reduction context');
    return this.red.convertFrom(this);
  };

  BN.prototype._forceRed = function _forceRed (ctx) {
    this.red = ctx;
    return this;
  };

  BN.prototype.forceRed = function forceRed (ctx) {
    assert(!this.red, 'Already a number in reduction context');
    return this._forceRed(ctx);
  };

  BN.prototype.redAdd = function redAdd (num) {
    assert(this.red, 'redAdd works only with red numbers');
    return this.red.add(this, num);
  };

  BN.prototype.redIAdd = function redIAdd (num) {
    assert(this.red, 'redIAdd works only with red numbers');
    return this.red.iadd(this, num);
  };

  BN.prototype.redSub = function redSub (num) {
    assert(this.red, 'redSub works only with red numbers');
    return this.red.sub(this, num);
  };

  BN.prototype.redISub = function redISub (num) {
    assert(this.red, 'redISub works only with red numbers');
    return this.red.isub(this, num);
  };

  BN.prototype.redShl = function redShl (num) {
    assert(this.red, 'redShl works only with red numbers');
    return this.red.shl(this, num);
  };

  BN.prototype.redMul = function redMul (num) {
    assert(this.red, 'redMul works only with red numbers');
    this.red._verify2(this, num);
    return this.red.mul(this, num);
  };

  BN.prototype.redIMul = function redIMul (num) {
    assert(this.red, 'redMul works only with red numbers');
    this.red._verify2(this, num);
    return this.red.imul(this, num);
  };

  BN.prototype.redSqr = function redSqr () {
    assert(this.red, 'redSqr works only with red numbers');
    this.red._verify1(this);
    return this.red.sqr(this);
  };

  BN.prototype.redISqr = function redISqr () {
    assert(this.red, 'redISqr works only with red numbers');
    this.red._verify1(this);
    return this.red.isqr(this);
  };

  // Square root over p
  BN.prototype.redSqrt = function redSqrt () {
    assert(this.red, 'redSqrt works only with red numbers');
    this.red._verify1(this);
    return this.red.sqrt(this);
  };

  BN.prototype.redInvm = function redInvm () {
    assert(this.red, 'redInvm works only with red numbers');
    this.red._verify1(this);
    return this.red.invm(this);
  };

  // Return negative clone of `this` % `red modulo`
  BN.prototype.redNeg = function redNeg () {
    assert(this.red, 'redNeg works only with red numbers');
    this.red._verify1(this);
    return this.red.neg(this);
  };

  BN.prototype.redPow = function redPow (num) {
    assert(this.red && !num.red, 'redPow(normalNum)');
    this.red._verify1(this);
    return this.red.pow(this, num);
  };

  // Prime numbers with efficient reduction
  var primes = {
    k256: null,
    p224: null,
    p192: null,
    p25519: null
  };

  // Pseudo-Mersenne prime
  function MPrime (name, p) {
    // P = 2 ^ N - K
    this.name = name;
    this.p = new BN(p, 16);
    this.n = this.p.bitLength();
    this.k = new BN(1).iushln(this.n).isub(this.p);

    this.tmp = this._tmp();
  }

  MPrime.prototype._tmp = function _tmp () {
    var tmp = new BN(null);
    tmp.words = new Array(Math.ceil(this.n / 13));
    return tmp;
  };

  MPrime.prototype.ireduce = function ireduce (num) {
    // Assumes that `num` is less than `P^2`
    // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)
    var r = num;
    var rlen;

    do {
      this.split(r, this.tmp);
      r = this.imulK(r);
      r = r.iadd(this.tmp);
      rlen = r.bitLength();
    } while (rlen > this.n);

    var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
    if (cmp === 0) {
      r.words[0] = 0;
      r.length = 1;
    } else if (cmp > 0) {
      r.isub(this.p);
    } else {
      if (r.strip !== undefined) {
        // r is BN v4 instance
        r.strip();
      } else {
        // r is BN v5 instance
        r._strip();
      }
    }

    return r;
  };

  MPrime.prototype.split = function split (input, out) {
    input.iushrn(this.n, 0, out);
  };

  MPrime.prototype.imulK = function imulK (num) {
    return num.imul(this.k);
  };

  function K256 () {
    MPrime.call(
      this,
      'k256',
      'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');
  }
  inherits(K256, MPrime);

  K256.prototype.split = function split (input, output) {
    // 256 = 9 * 26 + 22
    var mask = 0x3fffff;

    var outLen = Math.min(input.length, 9);
    for (var i = 0; i < outLen; i++) {
      output.words[i] = input.words[i];
    }
    output.length = outLen;

    if (input.length <= 9) {
      input.words[0] = 0;
      input.length = 1;
      return;
    }

    // Shift by 9 limbs
    var prev = input.words[9];
    output.words[output.length++] = prev & mask;

    for (i = 10; i < input.length; i++) {
      var next = input.words[i] | 0;
      input.words[i - 10] = ((next & mask) << 4) | (prev >>> 22);
      prev = next;
    }
    prev >>>= 22;
    input.words[i - 10] = prev;
    if (prev === 0 && input.length > 10) {
      input.length -= 10;
    } else {
      input.length -= 9;
    }
  };

  K256.prototype.imulK = function imulK (num) {
    // K = 0x1000003d1 = [ 0x40, 0x3d1 ]
    num.words[num.length] = 0;
    num.words[num.length + 1] = 0;
    num.length += 2;

    // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390
    var lo = 0;
    for (var i = 0; i < num.length; i++) {
      var w = num.words[i] | 0;
      lo += w * 0x3d1;
      num.words[i] = lo & 0x3ffffff;
      lo = w * 0x40 + ((lo / 0x4000000) | 0);
    }

    // Fast length reduction
    if (num.words[num.length - 1] === 0) {
      num.length--;
      if (num.words[num.length - 1] === 0) {
        num.length--;
      }
    }
    return num;
  };

  function P224 () {
    MPrime.call(
      this,
      'p224',
      'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');
  }
  inherits(P224, MPrime);

  function P192 () {
    MPrime.call(
      this,
      'p192',
      'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');
  }
  inherits(P192, MPrime);

  function P25519 () {
    // 2 ^ 255 - 19
    MPrime.call(
      this,
      '25519',
      '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');
  }
  inherits(P25519, MPrime);

  P25519.prototype.imulK = function imulK (num) {
    // K = 0x13
    var carry = 0;
    for (var i = 0; i < num.length; i++) {
      var hi = (num.words[i] | 0) * 0x13 + carry;
      var lo = hi & 0x3ffffff;
      hi >>>= 26;

      num.words[i] = lo;
      carry = hi;
    }
    if (carry !== 0) {
      num.words[num.length++] = carry;
    }
    return num;
  };

  // Exported mostly for testing purposes, use plain name instead
  BN._prime = function prime (name) {
    // Cached version of prime
    if (primes[name]) return primes[name];

    var prime;
    if (name === 'k256') {
      prime = new K256();
    } else if (name === 'p224') {
      prime = new P224();
    } else if (name === 'p192') {
      prime = new P192();
    } else if (name === 'p25519') {
      prime = new P25519();
    } else {
      throw new Error('Unknown prime ' + name);
    }
    primes[name] = prime;

    return prime;
  };

  //
  // Base reduction engine
  //
  function Red (m) {
    if (typeof m === 'string') {
      var prime = BN._prime(m);
      this.m = prime.p;
      this.prime = prime;
    } else {
      assert(m.gtn(1), 'modulus must be greater than 1');
      this.m = m;
      this.prime = null;
    }
  }

  Red.prototype._verify1 = function _verify1 (a) {
    assert(a.negative === 0, 'red works only with positives');
    assert(a.red, 'red works only with red numbers');
  };

  Red.prototype._verify2 = function _verify2 (a, b) {
    assert((a.negative | b.negative) === 0, 'red works only with positives');
    assert(a.red && a.red === b.red,
      'red works only with red numbers');
  };

  Red.prototype.imod = function imod (a) {
    if (this.prime) return this.prime.ireduce(a)._forceRed(this);
    return a.umod(this.m)._forceRed(this);
  };

  Red.prototype.neg = function neg (a) {
    if (a.isZero()) {
      return a.clone();
    }

    return this.m.sub(a)._forceRed(this);
  };

  Red.prototype.add = function add (a, b) {
    this._verify2(a, b);

    var res = a.add(b);
    if (res.cmp(this.m) >= 0) {
      res.isub(this.m);
    }
    return res._forceRed(this);
  };

  Red.prototype.iadd = function iadd (a, b) {
    this._verify2(a, b);

    var res = a.iadd(b);
    if (res.cmp(this.m) >= 0) {
      res.isub(this.m);
    }
    return res;
  };

  Red.prototype.sub = function sub (a, b) {
    this._verify2(a, b);

    var res = a.sub(b);
    if (res.cmpn(0) < 0) {
      res.iadd(this.m);
    }
    return res._forceRed(this);
  };

  Red.prototype.isub = function isub (a, b) {
    this._verify2(a, b);

    var res = a.isub(b);
    if (res.cmpn(0) < 0) {
      res.iadd(this.m);
    }
    return res;
  };

  Red.prototype.shl = function shl (a, num) {
    this._verify1(a);
    return this.imod(a.ushln(num));
  };

  Red.prototype.imul = function imul (a, b) {
    this._verify2(a, b);
    return this.imod(a.imul(b));
  };

  Red.prototype.mul = function mul (a, b) {
    this._verify2(a, b);
    return this.imod(a.mul(b));
  };

  Red.prototype.isqr = function isqr (a) {
    return this.imul(a, a.clone());
  };

  Red.prototype.sqr = function sqr (a) {
    return this.mul(a, a);
  };

  Red.prototype.sqrt = function sqrt (a) {
    if (a.isZero()) return a.clone();

    var mod3 = this.m.andln(3);
    assert(mod3 % 2 === 1);

    // Fast case
    if (mod3 === 3) {
      var pow = this.m.add(new BN(1)).iushrn(2);
      return this.pow(a, pow);
    }

    // Tonelli-Shanks algorithm (Totally unoptimized and slow)
    //
    // Find Q and S, that Q * 2 ^ S = (P - 1)
    var q = this.m.subn(1);
    var s = 0;
    while (!q.isZero() && q.andln(1) === 0) {
      s++;
      q.iushrn(1);
    }
    assert(!q.isZero());

    var one = new BN(1).toRed(this);
    var nOne = one.redNeg();

    // Find quadratic non-residue
    // NOTE: Max is such because of generalized Riemann hypothesis.
    var lpow = this.m.subn(1).iushrn(1);
    var z = this.m.bitLength();
    z = new BN(2 * z * z).toRed(this);

    while (this.pow(z, lpow).cmp(nOne) !== 0) {
      z.redIAdd(nOne);
    }

    var c = this.pow(z, q);
    var r = this.pow(a, q.addn(1).iushrn(1));
    var t = this.pow(a, q);
    var m = s;
    while (t.cmp(one) !== 0) {
      var tmp = t;
      for (var i = 0; tmp.cmp(one) !== 0; i++) {
        tmp = tmp.redSqr();
      }
      assert(i < m);
      var b = this.pow(c, new BN(1).iushln(m - i - 1));

      r = r.redMul(b);
      c = b.redSqr();
      t = t.redMul(c);
      m = i;
    }

    return r;
  };

  Red.prototype.invm = function invm (a) {
    var inv = a._invmp(this.m);
    if (inv.negative !== 0) {
      inv.negative = 0;
      return this.imod(inv).redNeg();
    } else {
      return this.imod(inv);
    }
  };

  Red.prototype.pow = function pow (a, num) {
    if (num.isZero()) return new BN(1).toRed(this);
    if (num.cmpn(1) === 0) return a.clone();

    var windowSize = 4;
    var wnd = new Array(1 << windowSize);
    wnd[0] = new BN(1).toRed(this);
    wnd[1] = a;
    for (var i = 2; i < wnd.length; i++) {
      wnd[i] = this.mul(wnd[i - 1], a);
    }

    var res = wnd[0];
    var current = 0;
    var currentLen = 0;
    var start = num.bitLength() % 26;
    if (start === 0) {
      start = 26;
    }

    for (i = num.length - 1; i >= 0; i--) {
      var word = num.words[i];
      for (var j = start - 1; j >= 0; j--) {
        var bit = (word >> j) & 1;
        if (res !== wnd[0]) {
          res = this.sqr(res);
        }

        if (bit === 0 && current === 0) {
          currentLen = 0;
          continue;
        }

        current <<= 1;
        current |= bit;
        currentLen++;
        if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;

        res = this.mul(res, wnd[current]);
        currentLen = 0;
        current = 0;
      }
      start = 26;
    }

    return res;
  };

  Red.prototype.convertTo = function convertTo (num) {
    var r = num.umod(this.m);

    return r === num ? r.clone() : r;
  };

  Red.prototype.convertFrom = function convertFrom (num) {
    var res = num.clone();
    res.red = null;
    return res;
  };

  //
  // Montgomery method engine
  //

  BN.mont = function mont (num) {
    return new Mont(num);
  };

  function Mont (m) {
    Red.call(this, m);

    this.shift = this.m.bitLength();
    if (this.shift % 26 !== 0) {
      this.shift += 26 - (this.shift % 26);
    }

    this.r = new BN(1).iushln(this.shift);
    this.r2 = this.imod(this.r.sqr());
    this.rinv = this.r._invmp(this.m);

    this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
    this.minv = this.minv.umod(this.r);
    this.minv = this.r.sub(this.minv);
  }
  inherits(Mont, Red);

  Mont.prototype.convertTo = function convertTo (num) {
    return this.imod(num.ushln(this.shift));
  };

  Mont.prototype.convertFrom = function convertFrom (num) {
    var r = this.imod(num.mul(this.rinv));
    r.red = null;
    return r;
  };

  Mont.prototype.imul = function imul (a, b) {
    if (a.isZero() || b.isZero()) {
      a.words[0] = 0;
      a.length = 1;
      return a;
    }

    var t = a.imul(b);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;

    if (u.cmp(this.m) >= 0) {
      res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
      res = u.iadd(this.m);
    }

    return res._forceRed(this);
  };

  Mont.prototype.mul = function mul (a, b) {
    if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);

    var t = a.mul(b);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;
    if (u.cmp(this.m) >= 0) {
      res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
      res = u.iadd(this.m);
    }

    return res._forceRed(this);
  };

  Mont.prototype.invm = function invm (a) {
    // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R
    var res = this.imod(a._invmp(this.m).mul(this.r2));
    return res._forceRed(this);
  };
})(typeof module === 'undefined' || module, this);

},{"buffer":28}],16:[function(require,module,exports){
'use strict'

var bnsign = require('./lib/bn-sign')

module.exports = sign

function sign(x) {
  return bnsign(x[0]) * bnsign(x[1])
}

},{"./lib/bn-sign":7}],17:[function(require,module,exports){
'use strict'

var rationalize = require('./lib/rationalize')

module.exports = sub

function sub(a, b) {
  return rationalize(a[0].mul(b[1]).sub(a[1].mul(b[0])), a[1].mul(b[1]))
}

},{"./lib/rationalize":12}],18:[function(require,module,exports){
'use strict'

var bn2num = require('./lib/bn-to-num')
var ctz = require('./lib/ctz')

module.exports = roundRat

// Round a rational to the closest float
function roundRat (f) {
  var a = f[0]
  var b = f[1]
  if (a.cmpn(0) === 0) {
    return 0
  }
  var h = a.abs().divmod(b.abs())
  var iv = h.div
  var x = bn2num(iv)
  var ir = h.mod
  var sgn = (a.negative !== b.negative) ? -1 : 1
  if (ir.cmpn(0) === 0) {
    return sgn * x
  }
  if (x) {
    var s = ctz(x) + 4
    var y = bn2num(ir.ushln(s).divRound(b))
    return sgn * (x + y * Math.pow(2, -s))
  } else {
    var ybits = b.bitLength() - ir.bitLength() + 53
    var y = bn2num(ir.ushln(ybits).divRound(b))
    if (ybits < 1023) {
      return sgn * y * Math.pow(2, -ybits)
    }
    y *= Math.pow(2, -1023)
    return sgn * y * Math.pow(2, 1023 - ybits)
  }
}

},{"./lib/bn-to-num":8,"./lib/ctz":9}],19:[function(require,module,exports){
"use strict"

// (a, y, c, l, h) = (array, y[, cmp, lo, hi])

function ge(a, y, c, l, h) {
  var i = h + 1;
  while (l <= h) {
    var m = (l + h) >>> 1, x = a[m];
    var p = (c !== undefined) ? c(x, y) : (x - y);
    if (p >= 0) { i = m; h = m - 1 } else { l = m + 1 }
  }
  return i;
};

function gt(a, y, c, l, h) {
  var i = h + 1;
  while (l <= h) {
    var m = (l + h) >>> 1, x = a[m];
    var p = (c !== undefined) ? c(x, y) : (x - y);
    if (p > 0) { i = m; h = m - 1 } else { l = m + 1 }
  }
  return i;
};

function lt(a, y, c, l, h) {
  var i = l - 1;
  while (l <= h) {
    var m = (l + h) >>> 1, x = a[m];
    var p = (c !== undefined) ? c(x, y) : (x - y);
    if (p < 0) { i = m; l = m + 1 } else { h = m - 1 }
  }
  return i;
};

function le(a, y, c, l, h) {
  var i = l - 1;
  while (l <= h) {
    var m = (l + h) >>> 1, x = a[m];
    var p = (c !== undefined) ? c(x, y) : (x - y);
    if (p <= 0) { i = m; l = m + 1 } else { h = m - 1 }
  }
  return i;
};

function eq(a, y, c, l, h) {
  while (l <= h) {
    var m = (l + h) >>> 1, x = a[m];
    var p = (c !== undefined) ? c(x, y) : (x - y);
    if (p === 0) { return m }
    if (p <= 0) { l = m + 1 } else { h = m - 1 }
  }
  return -1;
};

function norm(a, y, c, l, h, f) {
  if (typeof c === 'function') {
    return f(a, y, c, (l === undefined) ? 0 : l | 0, (h === undefined) ? a.length - 1 : h | 0);
  }
  return f(a, y, undefined, (c === undefined) ? 0 : c | 0, (l === undefined) ? a.length - 1 : l | 0);
}

module.exports = {
  ge: function(a, y, c, l, h) { return norm(a, y, c, l, h, ge)},
  gt: function(a, y, c, l, h) { return norm(a, y, c, l, h, gt)},
  lt: function(a, y, c, l, h) { return norm(a, y, c, l, h, lt)},
  le: function(a, y, c, l, h) { return norm(a, y, c, l, h, le)},
  eq: function(a, y, c, l, h) { return norm(a, y, c, l, h, eq)}
}

},{}],20:[function(require,module,exports){
/**
 * Bit twiddling hacks for JavaScript.
 *
 * Author: Mikola Lysenko
 *
 * Ported from Stanford bit twiddling hack library:
 *    http://graphics.stanford.edu/~seander/bithacks.html
 */

"use strict"; "use restrict";

//Number of bits in an integer
var INT_BITS = 32;

//Constants
exports.INT_BITS  = INT_BITS;
exports.INT_MAX   =  0x7fffffff;
exports.INT_MIN   = -1<<(INT_BITS-1);

//Returns -1, 0, +1 depending on sign of x
exports.sign = function(v) {
  return (v > 0) - (v < 0);
}

//Computes absolute value of integer
exports.abs = function(v) {
  var mask = v >> (INT_BITS-1);
  return (v ^ mask) - mask;
}

//Computes minimum of integers x and y
exports.min = function(x, y) {
  return y ^ ((x ^ y) & -(x < y));
}

//Computes maximum of integers x and y
exports.max = function(x, y) {
  return x ^ ((x ^ y) & -(x < y));
}

//Checks if a number is a power of two
exports.isPow2 = function(v) {
  return !(v & (v-1)) && (!!v);
}

//Computes log base 2 of v
exports.log2 = function(v) {
  var r, shift;
  r =     (v > 0xFFFF) << 4; v >>>= r;
  shift = (v > 0xFF  ) << 3; v >>>= shift; r |= shift;
  shift = (v > 0xF   ) << 2; v >>>= shift; r |= shift;
  shift = (v > 0x3   ) << 1; v >>>= shift; r |= shift;
  return r | (v >> 1);
}

//Computes log base 10 of v
exports.log10 = function(v) {
  return  (v >= 1000000000) ? 9 : (v >= 100000000) ? 8 : (v >= 10000000) ? 7 :
          (v >= 1000000) ? 6 : (v >= 100000) ? 5 : (v >= 10000) ? 4 :
          (v >= 1000) ? 3 : (v >= 100) ? 2 : (v >= 10) ? 1 : 0;
}

//Counts number of bits
exports.popCount = function(v) {
  v = v - ((v >>> 1) & 0x55555555);
  v = (v & 0x33333333) + ((v >>> 2) & 0x33333333);
  return ((v + (v >>> 4) & 0xF0F0F0F) * 0x1010101) >>> 24;
}

//Counts number of trailing zeros
function countTrailingZeros(v) {
  var c = 32;
  v &= -v;
  if (v) c--;
  if (v & 0x0000FFFF) c -= 16;
  if (v & 0x00FF00FF) c -= 8;
  if (v & 0x0F0F0F0F) c -= 4;
  if (v & 0x33333333) c -= 2;
  if (v & 0x55555555) c -= 1;
  return c;
}
exports.countTrailingZeros = countTrailingZeros;

//Rounds to next power of 2
exports.nextPow2 = function(v) {
  v += v === 0;
  --v;
  v |= v >>> 1;
  v |= v >>> 2;
  v |= v >>> 4;
  v |= v >>> 8;
  v |= v >>> 16;
  return v + 1;
}

//Rounds down to previous power of 2
exports.prevPow2 = function(v) {
  v |= v >>> 1;
  v |= v >>> 2;
  v |= v >>> 4;
  v |= v >>> 8;
  v |= v >>> 16;
  return v - (v>>>1);
}

//Computes parity of word
exports.parity = function(v) {
  v ^= v >>> 16;
  v ^= v >>> 8;
  v ^= v >>> 4;
  v &= 0xf;
  return (0x6996 >>> v) & 1;
}

var REVERSE_TABLE = new Array(256);

(function(tab) {
  for(var i=0; i<256; ++i) {
    var v = i, r = i, s = 7;
    for (v >>>= 1; v; v >>>= 1) {
      r <<= 1;
      r |= v & 1;
      --s;
    }
    tab[i] = (r << s) & 0xff;
  }
})(REVERSE_TABLE);

//Reverse bits in a 32 bit word
exports.reverse = function(v) {
  return  (REVERSE_TABLE[ v         & 0xff] << 24) |
          (REVERSE_TABLE[(v >>> 8)  & 0xff] << 16) |
          (REVERSE_TABLE[(v >>> 16) & 0xff] << 8)  |
           REVERSE_TABLE[(v >>> 24) & 0xff];
}

//Interleave bits of 2 coordinates with 16 bits.  Useful for fast quadtree codes
exports.interleave2 = function(x, y) {
  x &= 0xFFFF;
  x = (x | (x << 8)) & 0x00FF00FF;
  x = (x | (x << 4)) & 0x0F0F0F0F;
  x = (x | (x << 2)) & 0x33333333;
  x = (x | (x << 1)) & 0x55555555;

  y &= 0xFFFF;
  y = (y | (y << 8)) & 0x00FF00FF;
  y = (y | (y << 4)) & 0x0F0F0F0F;
  y = (y | (y << 2)) & 0x33333333;
  y = (y | (y << 1)) & 0x55555555;

  return x | (y << 1);
}

//Extracts the nth interleaved component
exports.deinterleave2 = function(v, n) {
  v = (v >>> n) & 0x55555555;
  v = (v | (v >>> 1))  & 0x33333333;
  v = (v | (v >>> 2))  & 0x0F0F0F0F;
  v = (v | (v >>> 4))  & 0x00FF00FF;
  v = (v | (v >>> 16)) & 0x000FFFF;
  return (v << 16) >> 16;
}


//Interleave bits of 3 coordinates, each with 10 bits.  Useful for fast octree codes
exports.interleave3 = function(x, y, z) {
  x &= 0x3FF;
  x  = (x | (x<<16)) & 4278190335;
  x  = (x | (x<<8))  & 251719695;
  x  = (x | (x<<4))  & 3272356035;
  x  = (x | (x<<2))  & 1227133513;

  y &= 0x3FF;
  y  = (y | (y<<16)) & 4278190335;
  y  = (y | (y<<8))  & 251719695;
  y  = (y | (y<<4))  & 3272356035;
  y  = (y | (y<<2))  & 1227133513;
  x |= (y << 1);
  
  z &= 0x3FF;
  z  = (z | (z<<16)) & 4278190335;
  z  = (z | (z<<8))  & 251719695;
  z  = (z | (z<<4))  & 3272356035;
  z  = (z | (z<<2))  & 1227133513;
  
  return x | (z << 2);
}

//Extracts nth interleaved component of a 3-tuple
exports.deinterleave3 = function(v, n) {
  v = (v >>> n)       & 1227133513;
  v = (v | (v>>>2))   & 3272356035;
  v = (v | (v>>>4))   & 251719695;
  v = (v | (v>>>8))   & 4278190335;
  v = (v | (v>>>16))  & 0x3FF;
  return (v<<22)>>22;
}

//Computes next combination in colexicographic order (this is mistakenly called nextPermutation on the bit twiddling hacks page)
exports.nextCombination = function(v) {
  var t = v | (v - 1);
  return (t + 1) | (((~t & -~t) - 1) >>> (countTrailingZeros(v) + 1));
}


},{}],21:[function(require,module,exports){
'use strict'

module.exports = boxIntersectWrapper

var pool = require('typedarray-pool')
var sweep = require('./lib/sweep')
var boxIntersectIter = require('./lib/intersect')

function boxEmpty(d, box) {
  for(var j=0; j<d; ++j) {
    if(!(box[j] <= box[j+d])) {
      return true
    }
  }
  return false
}

//Unpack boxes into a flat typed array, remove empty boxes
function convertBoxes(boxes, d, data, ids) {
  var ptr = 0
  var count = 0
  for(var i=0, n=boxes.length; i<n; ++i) {
    var b = boxes[i]
    if(boxEmpty(d, b)) {
      continue
    }
    for(var j=0; j<2*d; ++j) {
      data[ptr++] = b[j]
    }
    ids[count++] = i
  }
  return count
}

//Perform type conversions, check bounds
function boxIntersect(red, blue, visit, full) {
  var n = red.length
  var m = blue.length

  //If either array is empty, then we can skip this whole thing
  if(n <= 0 || m <= 0) {
    return
  }

  //Compute dimension, if it is 0 then we skip
  var d = (red[0].length)>>>1
  if(d <= 0) {
    return
  }

  var retval

  //Convert red boxes
  var redList  = pool.mallocDouble(2*d*n)
  var redIds   = pool.mallocInt32(n)
  n = convertBoxes(red, d, redList, redIds)

  if(n > 0) {
    if(d === 1 && full) {
      //Special case: 1d complete
      sweep.init(n)
      retval = sweep.sweepComplete(
        d, visit, 
        0, n, redList, redIds,
        0, n, redList, redIds)
    } else {

      //Convert blue boxes
      var blueList = pool.mallocDouble(2*d*m)
      var blueIds  = pool.mallocInt32(m)
      m = convertBoxes(blue, d, blueList, blueIds)

      if(m > 0) {
        sweep.init(n+m)

        if(d === 1) {
          //Special case: 1d bipartite
          retval = sweep.sweepBipartite(
            d, visit, 
            0, n, redList,  redIds,
            0, m, blueList, blueIds)
        } else {
          //General case:  d>1
          retval = boxIntersectIter(
            d, visit,    full,
            n, redList,  redIds,
            m, blueList, blueIds)
        }

        pool.free(blueList)
        pool.free(blueIds)
      }
    }

    pool.free(redList)
    pool.free(redIds)
  }

  return retval
}


var RESULT

function appendItem(i,j) {
  RESULT.push([i,j])
}

function intersectFullArray(x) {
  RESULT = []
  boxIntersect(x, x, appendItem, true)
  return RESULT
}

function intersectBipartiteArray(x, y) {
  RESULT = []
  boxIntersect(x, y, appendItem, false)
  return RESULT
}

//User-friendly wrapper, handle full input and no-visitor cases
function boxIntersectWrapper(arg0, arg1, arg2) {
  var result
  switch(arguments.length) {
    case 1:
      return intersectFullArray(arg0)
    case 2:
      if(typeof arg1 === 'function') {
        return boxIntersect(arg0, arg0, arg1, true)
      } else {
        return intersectBipartiteArray(arg0, arg1)
      }
    case 3:
      return boxIntersect(arg0, arg1, arg2, false)
    default:
      throw new Error('box-intersect: Invalid arguments')
  }
}
},{"./lib/intersect":23,"./lib/sweep":27,"typedarray-pool":180}],22:[function(require,module,exports){
'use strict'

var DIMENSION   = 'd'
var AXIS        = 'ax'
var VISIT       = 'vv'
var FLIP        = 'fp'

var ELEM_SIZE   = 'es'

var RED_START   = 'rs'
var RED_END     = 're'
var RED_BOXES   = 'rb'
var RED_INDEX   = 'ri'
var RED_PTR     = 'rp'

var BLUE_START  = 'bs'
var BLUE_END    = 'be'
var BLUE_BOXES  = 'bb'
var BLUE_INDEX  = 'bi'
var BLUE_PTR    = 'bp'

var RETVAL      = 'rv'

var INNER_LABEL = 'Q'

var ARGS = [
  DIMENSION,
  AXIS,
  VISIT,
  RED_START,
  RED_END,
  RED_BOXES,
  RED_INDEX,
  BLUE_START,
  BLUE_END,
  BLUE_BOXES,
  BLUE_INDEX
]

function generateBruteForce(redMajor, flip, full) {
  var funcName = 'bruteForce' + 
    (redMajor ? 'Red' : 'Blue') + 
    (flip ? 'Flip' : '') +
    (full ? 'Full' : '')

  var code = ['function ', funcName, '(', ARGS.join(), '){',
    'var ', ELEM_SIZE, '=2*', DIMENSION, ';']

  var redLoop = 
    'for(var i=' + RED_START + ',' + RED_PTR + '=' + ELEM_SIZE + '*' + RED_START + ';' +
        'i<' + RED_END +';' +
        '++i,' + RED_PTR + '+=' + ELEM_SIZE + '){' +
        'var x0=' + RED_BOXES + '[' + AXIS + '+' + RED_PTR + '],' +
            'x1=' + RED_BOXES + '[' + AXIS + '+' + RED_PTR + '+' + DIMENSION + '],' +
            'xi=' + RED_INDEX + '[i];'

  var blueLoop = 
    'for(var j=' + BLUE_START + ',' + BLUE_PTR + '=' + ELEM_SIZE + '*' + BLUE_START + ';' +
        'j<' + BLUE_END + ';' +
        '++j,' + BLUE_PTR + '+=' + ELEM_SIZE + '){' +
        'var y0=' + BLUE_BOXES + '[' + AXIS + '+' + BLUE_PTR + '],' +
            (full ? 'y1=' + BLUE_BOXES + '[' + AXIS + '+' + BLUE_PTR + '+' + DIMENSION + '],' : '') +
            'yi=' + BLUE_INDEX + '[j];'

  if(redMajor) {
    code.push(redLoop, INNER_LABEL, ':', blueLoop)
  } else {
    code.push(blueLoop, INNER_LABEL, ':', redLoop)
  }

  if(full) {
    code.push('if(y1<x0||x1<y0)continue;')
  } else if(flip) {
    code.push('if(y0<=x0||x1<y0)continue;')
  } else {
    code.push('if(y0<x0||x1<y0)continue;')
  }

  code.push('for(var k='+AXIS+'+1;k<'+DIMENSION+';++k){'+
    'var r0='+RED_BOXES+'[k+'+RED_PTR+'],'+
        'r1='+RED_BOXES+'[k+'+DIMENSION+'+'+RED_PTR+'],'+
        'b0='+BLUE_BOXES+'[k+'+BLUE_PTR+'],'+
        'b1='+BLUE_BOXES+'[k+'+DIMENSION+'+'+BLUE_PTR+'];'+
      'if(r1<b0||b1<r0)continue ' + INNER_LABEL + ';}' +
      'var ' + RETVAL + '=' + VISIT + '(')

  if(flip) {
    code.push('yi,xi')
  } else {
    code.push('xi,yi')
  }

  code.push(');if(' + RETVAL + '!==void 0)return ' + RETVAL + ';}}}')

  return {
    name: funcName, 
    code: code.join('')
  }
}

function bruteForcePlanner(full) {
  var funcName = 'bruteForce' + (full ? 'Full' : 'Partial')
  var prefix = []
  var fargs = ARGS.slice()
  if(!full) {
    fargs.splice(3, 0, FLIP)
  }

  var code = ['function ' + funcName + '(' + fargs.join() + '){']

  function invoke(redMajor, flip) {
    var res = generateBruteForce(redMajor, flip, full)
    prefix.push(res.code)
    code.push('return ' + res.name + '(' + ARGS.join() + ');')
  }

  code.push('if(' + RED_END + '-' + RED_START + '>' +
                    BLUE_END + '-' + BLUE_START + '){')

  if(full) {
    invoke(true, false)
    code.push('}else{')
    invoke(false, false)
  } else {
    code.push('if(' + FLIP + '){')
    invoke(true, true)
    code.push('}else{')
    invoke(true, false)
    code.push('}}else{if(' + FLIP + '){')
    invoke(false, true)
    code.push('}else{')
    invoke(false, false)
    code.push('}')
  }
  code.push('}}return ' + funcName)

  var codeStr = prefix.join('') + code.join('')
  var proc = new Function(codeStr)
  return proc()
}


exports.partial = bruteForcePlanner(false)
exports.full    = bruteForcePlanner(true)
},{}],23:[function(require,module,exports){
'use strict'

module.exports = boxIntersectIter

var pool = require('typedarray-pool')
var bits = require('bit-twiddle')
var bruteForce = require('./brute')
var bruteForcePartial = bruteForce.partial
var bruteForceFull = bruteForce.full
var sweep = require('./sweep')
var findMedian = require('./median')
var genPartition = require('./partition')

//Twiddle parameters
var BRUTE_FORCE_CUTOFF    = 128       //Cut off for brute force search
var SCAN_CUTOFF           = (1<<22)   //Cut off for two way scan
var SCAN_COMPLETE_CUTOFF  = (1<<22)  

//Partition functions
var partitionInteriorContainsInterval = genPartition(
  '!(lo>=p0)&&!(p1>=hi)', 
  ['p0', 'p1'])

var partitionStartEqual = genPartition(
  'lo===p0',
  ['p0'])

var partitionStartLessThan = genPartition(
  'lo<p0',
  ['p0'])

var partitionEndLessThanEqual = genPartition(
  'hi<=p0',
  ['p0'])

var partitionContainsPoint = genPartition(
  'lo<=p0&&p0<=hi',
  ['p0'])

var partitionContainsPointProper = genPartition(
  'lo<p0&&p0<=hi',
  ['p0'])

//Frame size for iterative loop
var IFRAME_SIZE = 6
var DFRAME_SIZE = 2

//Data for box statck
var INIT_CAPACITY = 1024
var BOX_ISTACK  = pool.mallocInt32(INIT_CAPACITY)
var BOX_DSTACK  = pool.mallocDouble(INIT_CAPACITY)

//Initialize iterative loop queue
function iterInit(d, count) {
  var levels = (8 * bits.log2(count+1) * (d+1))|0
  var maxInts = bits.nextPow2(IFRAME_SIZE*levels)
  if(BOX_ISTACK.length < maxInts) {
    pool.free(BOX_ISTACK)
    BOX_ISTACK = pool.mallocInt32(maxInts)
  }
  var maxDoubles = bits.nextPow2(DFRAME_SIZE*levels)
  if(BOX_DSTACK.length < maxDoubles) {
    pool.free(BOX_DSTACK)
    BOX_DSTACK = pool.mallocDouble(maxDoubles)
  }
}

//Append item to queue
function iterPush(ptr,
  axis, 
  redStart, redEnd, 
  blueStart, blueEnd, 
  state, 
  lo, hi) {

  var iptr = IFRAME_SIZE * ptr
  BOX_ISTACK[iptr]   = axis
  BOX_ISTACK[iptr+1] = redStart
  BOX_ISTACK[iptr+2] = redEnd
  BOX_ISTACK[iptr+3] = blueStart
  BOX_ISTACK[iptr+4] = blueEnd
  BOX_ISTACK[iptr+5] = state

  var dptr = DFRAME_SIZE * ptr
  BOX_DSTACK[dptr]   = lo
  BOX_DSTACK[dptr+1] = hi
}

//Special case:  Intersect single point with list of intervals
function onePointPartial(
  d, axis, visit, flip,
  redStart, redEnd, red, redIndex,
  blueOffset, blue, blueId) {

  var elemSize = 2 * d
  var bluePtr  = blueOffset * elemSize
  var blueX    = blue[bluePtr + axis]

red_loop:
  for(var i=redStart, redPtr=redStart*elemSize; i<redEnd; ++i, redPtr+=elemSize) {
    var r0 = red[redPtr+axis]
    var r1 = red[redPtr+axis+d]
    if(blueX < r0 || r1 < blueX) {
      continue
    }
    if(flip && blueX === r0) {
      continue
    }
    var redId = redIndex[i]
    for(var j=axis+1; j<d; ++j) {
      var r0 = red[redPtr+j]
      var r1 = red[redPtr+j+d]
      var b0 = blue[bluePtr+j]
      var b1 = blue[bluePtr+j+d]
      if(r1 < b0 || b1 < r0) {
        continue red_loop
      }
    }
    var retval
    if(flip) {
      retval = visit(blueId, redId)
    } else {
      retval = visit(redId, blueId)
    }
    if(retval !== void 0) {
      return retval
    }
  }
}

//Special case:  Intersect one point with list of intervals
function onePointFull(
  d, axis, visit,
  redStart, redEnd, red, redIndex,
  blueOffset, blue, blueId) {

  var elemSize = 2 * d
  var bluePtr  = blueOffset * elemSize
  var blueX    = blue[bluePtr + axis]

red_loop:
  for(var i=redStart, redPtr=redStart*elemSize; i<redEnd; ++i, redPtr+=elemSize) {
    var redId = redIndex[i]
    if(redId === blueId) {
      continue
    }
    var r0 = red[redPtr+axis]
    var r1 = red[redPtr+axis+d]
    if(blueX < r0 || r1 < blueX) {
      continue
    }
    for(var j=axis+1; j<d; ++j) {
      var r0 = red[redPtr+j]
      var r1 = red[redPtr+j+d]
      var b0 = blue[bluePtr+j]
      var b1 = blue[bluePtr+j+d]
      if(r1 < b0 || b1 < r0) {
        continue red_loop
      }
    }
    var retval = visit(redId, blueId)
    if(retval !== void 0) {
      return retval
    }
  }
}

//The main box intersection routine
function boxIntersectIter(
  d, visit, initFull,
  xSize, xBoxes, xIndex,
  ySize, yBoxes, yIndex) {

  //Reserve memory for stack
  iterInit(d, xSize + ySize)

  var top  = 0
  var elemSize = 2 * d
  var retval

  iterPush(top++,
      0,
      0, xSize,
      0, ySize,
      initFull ? 16 : 0, 
      -Infinity, Infinity)
  if(!initFull) {
    iterPush(top++,
      0,
      0, ySize,
      0, xSize,
      1, 
      -Infinity, Infinity)
  }

  while(top > 0) {
    top  -= 1

    var iptr = top * IFRAME_SIZE
    var axis      = BOX_ISTACK[iptr]
    var redStart  = BOX_ISTACK[iptr+1]
    var redEnd    = BOX_ISTACK[iptr+2]
    var blueStart = BOX_ISTACK[iptr+3]
    var blueEnd   = BOX_ISTACK[iptr+4]
    var state     = BOX_ISTACK[iptr+5]

    var dptr = top * DFRAME_SIZE
    var lo        = BOX_DSTACK[dptr]
    var hi        = BOX_DSTACK[dptr+1]

    //Unpack state info
    var flip      = (state & 1)
    var full      = !!(state & 16)

    //Unpack indices
    var red       = xBoxes
    var redIndex  = xIndex
    var blue      = yBoxes
    var blueIndex = yIndex
    if(flip) {
      red         = yBoxes
      redIndex    = yIndex
      blue        = xBoxes
      blueIndex   = xIndex
    }

    if(state & 2) {
      redEnd = partitionStartLessThan(
        d, axis,
        redStart, redEnd, red, redIndex,
        hi)
      if(redStart >= redEnd) {
        continue
      }
    }
    if(state & 4) {
      redStart = partitionEndLessThanEqual(
        d, axis,
        redStart, redEnd, red, redIndex,
        lo)
      if(redStart >= redEnd) {
        continue
      }
    }
    
    var redCount  = redEnd  - redStart
    var blueCount = blueEnd - blueStart

    if(full) {
      if(d * redCount * (redCount + blueCount) < SCAN_COMPLETE_CUTOFF) {
        retval = sweep.scanComplete(
          d, axis, visit, 
          redStart, redEnd, red, redIndex,
          blueStart, blueEnd, blue, blueIndex)
        if(retval !== void 0) {
          return retval
        }
        continue
      }
    } else {
      if(d * Math.min(redCount, blueCount) < BRUTE_FORCE_CUTOFF) {
        //If input small, then use brute force
        retval = bruteForcePartial(
            d, axis, visit, flip,
            redStart,  redEnd,  red,  redIndex,
            blueStart, blueEnd, blue, blueIndex)
        if(retval !== void 0) {
          return retval
        }
        continue
      } else if(d * redCount * blueCount < SCAN_CUTOFF) {
        //If input medium sized, then use sweep and prune
        retval = sweep.scanBipartite(
          d, axis, visit, flip, 
          redStart, redEnd, red, redIndex,
          blueStart, blueEnd, blue, blueIndex)
        if(retval !== void 0) {
          return retval
        }
        continue
      }
    }
    
    //First, find all red intervals whose interior contains (lo,hi)
    var red0 = partitionInteriorContainsInterval(
      d, axis, 
      redStart, redEnd, red, redIndex,
      lo, hi)

    //Lower dimensional case
    if(redStart < red0) {

      if(d * (red0 - redStart) < BRUTE_FORCE_CUTOFF) {
        //Special case for small inputs: use brute force
        retval = bruteForceFull(
          d, axis+1, visit,
          redStart, red0, red, redIndex,
          blueStart, blueEnd, blue, blueIndex)
        if(retval !== void 0) {
          return retval
        }
      } else if(axis === d-2) {
        if(flip) {
          retval = sweep.sweepBipartite(
            d, visit,
            blueStart, blueEnd, blue, blueIndex,
            redStart, red0, red, redIndex)
        } else {
          retval = sweep.sweepBipartite(
            d, visit,
            redStart, red0, red, redIndex,
            blueStart, blueEnd, blue, blueIndex)
        }
        if(retval !== void 0) {
          return retval
        }
      } else {
        iterPush(top++,
          axis+1,
          redStart, red0,
          blueStart, blueEnd,
          flip,
          -Infinity, Infinity)
        iterPush(top++,
          axis+1,
          blueStart, blueEnd,
          redStart, red0,
          flip^1,
          -Infinity, Infinity)
      }
    }

    //Divide and conquer phase
    if(red0 < redEnd) {

      //Cut blue into 3 parts:
      //
      //  Points < mid point
      //  Points = mid point
      //  Points > mid point
      //
      var blue0 = findMedian(
        d, axis, 
        blueStart, blueEnd, blue, blueIndex)
      var mid = blue[elemSize * blue0 + axis]
      var blue1 = partitionStartEqual(
        d, axis,
        blue0, blueEnd, blue, blueIndex,
        mid)

      //Right case
      if(blue1 < blueEnd) {
        iterPush(top++,
          axis,
          red0, redEnd,
          blue1, blueEnd,
          (flip|4) + (full ? 16 : 0),
          mid, hi)
      }

      //Left case
      if(blueStart < blue0) {
        iterPush(top++,
          axis,
          red0, redEnd,
          blueStart, blue0,
          (flip|2) + (full ? 16 : 0),
          lo, mid)
      }

      //Center case (the hard part)
      if(blue0 + 1 === blue1) {
        //Optimization: Range with exactly 1 point, use a brute force scan
        if(full) {
          retval = onePointFull(
            d, axis, visit,
            red0, redEnd, red, redIndex,
            blue0, blue, blueIndex[blue0])
        } else {
          retval = onePointPartial(
            d, axis, visit, flip,
            red0, redEnd, red, redIndex,
            blue0, blue, blueIndex[blue0])
        }
        if(retval !== void 0) {
          return retval
        }
      } else if(blue0 < blue1) {
        var red1
        if(full) {
          //If full intersection, need to handle special case
          red1 = partitionContainsPoint(
            d, axis,
            red0, redEnd, red, redIndex,
            mid)
          if(red0 < red1) {
            var redX = partitionStartEqual(
              d, axis,
              red0, red1, red, redIndex,
              mid)
            if(axis === d-2) {
              //Degenerate sweep intersection:
              //  [red0, redX] with [blue0, blue1]
              if(red0 < redX) {
                retval = sweep.sweepComplete(
                  d, visit,
                  red0, redX, red, redIndex,
                  blue0, blue1, blue, blueIndex)
                if(retval !== void 0) {
                  return retval
                }
              }

              //Normal sweep intersection:
              //  [redX, red1] with [blue0, blue1]
              if(redX < red1) {
                retval = sweep.sweepBipartite(
                  d, visit,
                  redX, red1, red, redIndex,
                  blue0, blue1, blue, blueIndex)
                if(retval !== void 0) {
                  return retval
                }
              }
            } else {
              if(red0 < redX) {
                iterPush(top++,
                  axis+1,
                  red0, redX,
                  blue0, blue1,
                  16,
                  -Infinity, Infinity)
              }
              if(redX < red1) {
                iterPush(top++,
                  axis+1,
                  redX, red1,
                  blue0, blue1,
                  0,
                  -Infinity, Infinity)
                iterPush(top++,
                  axis+1,
                  blue0, blue1,
                  redX, red1,
                  1,
                  -Infinity, Infinity)
              }
            }
          }
        } else {
          if(flip) {
            red1 = partitionContainsPointProper(
              d, axis,
              red0, redEnd, red, redIndex,
              mid)
          } else {
            red1 = partitionContainsPoint(
              d, axis,
              red0, redEnd, red, redIndex,
              mid)
          }
          if(red0 < red1) {
            if(axis === d-2) {
              if(flip) {
                retval = sweep.sweepBipartite(
                  d, visit,
                  blue0, blue1, blue, blueIndex,
                  red0, red1, red, redIndex)
              } else {
                retval = sweep.sweepBipartite(
                  d, visit,
                  red0, red1, red, redIndex,
                  blue0, blue1, blue, blueIndex)
              }
            } else {
              iterPush(top++,
                axis+1,
                red0, red1,
                blue0, blue1,
                flip,
                -Infinity, Infinity)
              iterPush(top++,
                axis+1,
                blue0, blue1,
                red0, red1,
                flip^1,
                -Infinity, Infinity)
            }
          }
        }
      }
    }
  }
}
},{"./brute":22,"./median":24,"./partition":25,"./sweep":27,"bit-twiddle":20,"typedarray-pool":180}],24:[function(require,module,exports){
'use strict'

module.exports = findMedian

var genPartition = require('./partition')

var partitionStartLessThan = genPartition('lo<p0', ['p0'])

var PARTITION_THRESHOLD = 8   //Cut off for using insertion sort in findMedian

//Base case for median finding:  Use insertion sort
function insertionSort(d, axis, start, end, boxes, ids) {
  var elemSize = 2 * d
  var boxPtr = elemSize * (start+1) + axis
  for(var i=start+1; i<end; ++i, boxPtr+=elemSize) {
    var x = boxes[boxPtr]
    for(var j=i, ptr=elemSize*(i-1); 
        j>start && boxes[ptr+axis] > x; 
        --j, ptr-=elemSize) {
      //Swap
      var aPtr = ptr
      var bPtr = ptr+elemSize
      for(var k=0; k<elemSize; ++k, ++aPtr, ++bPtr) {
        var y = boxes[aPtr]
        boxes[aPtr] = boxes[bPtr]
        boxes[bPtr] = y
      }
      var tmp = ids[j]
      ids[j] = ids[j-1]
      ids[j-1] = tmp
    }
  }
}

//Find median using quick select algorithm
//  takes O(n) time with high probability
function findMedian(d, axis, start, end, boxes, ids) {
  if(end <= start+1) {
    return start
  }

  var lo       = start
  var hi       = end
  var mid      = ((end + start) >>> 1)
  var elemSize = 2*d
  var pivot    = mid
  var value    = boxes[elemSize*mid+axis]
  
  while(lo < hi) {
    if(hi - lo < PARTITION_THRESHOLD) {
      insertionSort(d, axis, lo, hi, boxes, ids)
      value = boxes[elemSize*mid+axis]
      break
    }
    
    //Select pivot using median-of-3
    var count  = hi - lo
    var pivot0 = (Math.random()*count+lo)|0
    var value0 = boxes[elemSize*pivot0 + axis]
    var pivot1 = (Math.random()*count+lo)|0
    var value1 = boxes[elemSize*pivot1 + axis]
    var pivot2 = (Math.random()*count+lo)|0
    var value2 = boxes[elemSize*pivot2 + axis]
    if(value0 <= value1) {
      if(value2 >= value1) {
        pivot = pivot1
        value = value1
      } else if(value0 >= value2) {
        pivot = pivot0
        value = value0
      } else {
        pivot = pivot2
        value = value2
      }
    } else {
      if(value1 >= value2) {
        pivot = pivot1
        value = value1
      } else if(value2 >= value0) {
        pivot = pivot0
        value = value0
      } else {
        pivot = pivot2
        value = value2
      }
    }

    //Swap pivot to end of array
    var aPtr = elemSize * (hi-1)
    var bPtr = elemSize * pivot
    for(var i=0; i<elemSize; ++i, ++aPtr, ++bPtr) {
      var x = boxes[aPtr]
      boxes[aPtr] = boxes[bPtr]
      boxes[bPtr] = x
    }
    var y = ids[hi-1]
    ids[hi-1] = ids[pivot]
    ids[pivot] = y

    //Partition using pivot
    pivot = partitionStartLessThan(
      d, axis, 
      lo, hi-1, boxes, ids,
      value)

    //Swap pivot back
    var aPtr = elemSize * (hi-1)
    var bPtr = elemSize * pivot
    for(var i=0; i<elemSize; ++i, ++aPtr, ++bPtr) {
      var x = boxes[aPtr]
      boxes[aPtr] = boxes[bPtr]
      boxes[bPtr] = x
    }
    var y = ids[hi-1]
    ids[hi-1] = ids[pivot]
    ids[pivot] = y

    //Swap pivot to last pivot
    if(mid < pivot) {
      hi = pivot-1
      while(lo < hi && 
        boxes[elemSize*(hi-1)+axis] === value) {
        hi -= 1
      }
      hi += 1
    } else if(pivot < mid) {
      lo = pivot + 1
      while(lo < hi &&
        boxes[elemSize*lo+axis] === value) {
        lo += 1
      }
    } else {
      break
    }
  }

  //Make sure pivot is at start
  return partitionStartLessThan(
    d, axis, 
    start, mid, boxes, ids,
    boxes[elemSize*mid+axis])
}
},{"./partition":25}],25:[function(require,module,exports){
'use strict'

module.exports = genPartition

var code = 'for(var j=2*a,k=j*c,l=k,m=c,n=b,o=a+b,p=c;d>p;++p,k+=j){var _;if($)if(m===p)m+=1,l+=j;else{for(var s=0;j>s;++s){var t=e[k+s];e[k+s]=e[l],e[l++]=t}var u=f[p];f[p]=f[m],f[m++]=u}}return m'

function genPartition(predicate, args) {
  var fargs ='abcdef'.split('').concat(args)
  var reads = []
  if(predicate.indexOf('lo') >= 0) {
    reads.push('lo=e[k+n]')
  }
  if(predicate.indexOf('hi') >= 0) {
    reads.push('hi=e[k+o]')
  }
  fargs.push(
    code.replace('_', reads.join())
        .replace('$', predicate))
  return Function.apply(void 0, fargs)
}
},{}],26:[function(require,module,exports){
'use strict';

//This code is extracted from ndarray-sort
//It is inlined here as a temporary workaround

module.exports = wrapper;

var INSERT_SORT_CUTOFF = 32

function wrapper(data, n0) {
  if (n0 <= 4*INSERT_SORT_CUTOFF) {
    insertionSort(0, n0 - 1, data);
  } else {
    quickSort(0, n0 - 1, data);
  }
}

function insertionSort(left, right, data) {
  var ptr = 2*(left+1)
  for(var i=left+1; i<=right; ++i) {
    var a = data[ptr++]
    var b = data[ptr++]
    var j = i
    var jptr = ptr-2
    while(j-- > left) {
      var x = data[jptr-2]
      var y = data[jptr-1]
      if(x < a) {
        break
      } else if(x === a && y < b) {
        break
      }
      data[jptr]   = x
      data[jptr+1] = y
      jptr -= 2
    }
    data[jptr]   = a
    data[jptr+1] = b
  }
}

function swap(i, j, data) {
  i *= 2
  j *= 2
  var x = data[i]
  var y = data[i+1]
  data[i] = data[j]
  data[i+1] = data[j+1]
  data[j] = x
  data[j+1] = y
}

function move(i, j, data) {
  i *= 2
  j *= 2
  data[i] = data[j]
  data[i+1] = data[j+1]
}

function rotate(i, j, k, data) {
  i *= 2
  j *= 2
  k *= 2
  var x = data[i]
  var y = data[i+1]
  data[i] = data[j]
  data[i+1] = data[j+1]
  data[j] = data[k]
  data[j+1] = data[k+1]
  data[k] = x
  data[k+1] = y
}

function shufflePivot(i, j, px, py, data) {
  i *= 2
  j *= 2
  data[i] = data[j]
  data[j] = px
  data[i+1] = data[j+1]
  data[j+1] = py
}

function compare(i, j, data) {
  i *= 2
  j *= 2
  var x = data[i],
      y = data[j]
  if(x < y) {
    return false
  } else if(x === y) {
    return data[i+1] > data[j+1]
  }
  return true
}

function comparePivot(i, y, b, data) {
  i *= 2
  var x = data[i]
  if(x < y) {
    return true
  } else if(x === y) {
    return data[i+1] < b
  }
  return false
}

function quickSort(left, right, data) {
  var sixth = (right - left + 1) / 6 | 0, 
      index1 = left + sixth, 
      index5 = right - sixth, 
      index3 = left + right >> 1, 
      index2 = index3 - sixth, 
      index4 = index3 + sixth, 
      el1 = index1, 
      el2 = index2, 
      el3 = index3, 
      el4 = index4, 
      el5 = index5, 
      less = left + 1, 
      great = right - 1, 
      tmp = 0
  if(compare(el1, el2, data)) {
    tmp = el1
    el1 = el2
    el2 = tmp
  }
  if(compare(el4, el5, data)) {
    tmp = el4
    el4 = el5
    el5 = tmp
  }
  if(compare(el1, el3, data)) {
    tmp = el1
    el1 = el3
    el3 = tmp
  }
  if(compare(el2, el3, data)) {
    tmp = el2
    el2 = el3
    el3 = tmp
  }
  if(compare(el1, el4, data)) {
    tmp = el1
    el1 = el4
    el4 = tmp
  }
  if(compare(el3, el4, data)) {
    tmp = el3
    el3 = el4
    el4 = tmp
  }
  if(compare(el2, el5, data)) {
    tmp = el2
    el2 = el5
    el5 = tmp
  }
  if(compare(el2, el3, data)) {
    tmp = el2
    el2 = el3
    el3 = tmp
  }
  if(compare(el4, el5, data)) {
    tmp = el4
    el4 = el5
    el5 = tmp
  }

  var pivot1X = data[2*el2]
  var pivot1Y = data[2*el2+1]
  var pivot2X = data[2*el4]
  var pivot2Y = data[2*el4+1]

  var ptr0 = 2 * el1;
  var ptr2 = 2 * el3;
  var ptr4 = 2 * el5;
  var ptr5 = 2 * index1;
  var ptr6 = 2 * index3;
  var ptr7 = 2 * index5;
  for (var i1 = 0; i1 < 2; ++i1) {
    var x = data[ptr0+i1];
    var y = data[ptr2+i1];
    var z = data[ptr4+i1];
    data[ptr5+i1] = x;
    data[ptr6+i1] = y;
    data[ptr7+i1] = z;
  }

  move(index2, left, data)
  move(index4, right, data)
  for (var k = less; k <= great; ++k) {
    if (comparePivot(k, pivot1X, pivot1Y, data)) {
      if (k !== less) {
        swap(k, less, data)
      }
      ++less;
    } else {
      if (!comparePivot(k, pivot2X, pivot2Y, data)) {
        while (true) {
          if (!comparePivot(great, pivot2X, pivot2Y, data)) {
            if (--great < k) {
              break;
            }
            continue;
          } else {
            if (comparePivot(great, pivot1X, pivot1Y, data)) {
              rotate(k, less, great, data)
              ++less;
              --great;
            } else {
              swap(k, great, data)
              --great;
            }
            break;
          }
        }
      }
    }
  }
  shufflePivot(left, less-1, pivot1X, pivot1Y, data)
  shufflePivot(right, great+1, pivot2X, pivot2Y, data)
  if (less - 2 - left <= INSERT_SORT_CUTOFF) {
    insertionSort(left, less - 2, data);
  } else {
    quickSort(left, less - 2, data);
  }
  if (right - (great + 2) <= INSERT_SORT_CUTOFF) {
    insertionSort(great + 2, right, data);
  } else {
    quickSort(great + 2, right, data);
  }
  if (great - less <= INSERT_SORT_CUTOFF) {
    insertionSort(less, great, data);
  } else {
    quickSort(less, great, data);
  }
}
},{}],27:[function(require,module,exports){
'use strict'

module.exports = {
  init:           sqInit,
  sweepBipartite: sweepBipartite,
  sweepComplete:  sweepComplete,
  scanBipartite:  scanBipartite,
  scanComplete:   scanComplete
}

var pool  = require('typedarray-pool')
var bits  = require('bit-twiddle')
var isort = require('./sort')

//Flag for blue
var BLUE_FLAG = (1<<28)

//1D sweep event queue stuff (use pool to save space)
var INIT_CAPACITY      = 1024
var RED_SWEEP_QUEUE    = pool.mallocInt32(INIT_CAPACITY)
var RED_SWEEP_INDEX    = pool.mallocInt32(INIT_CAPACITY)
var BLUE_SWEEP_QUEUE   = pool.mallocInt32(INIT_CAPACITY)
var BLUE_SWEEP_INDEX   = pool.mallocInt32(INIT_CAPACITY)
var COMMON_SWEEP_QUEUE = pool.mallocInt32(INIT_CAPACITY)
var COMMON_SWEEP_INDEX = pool.mallocInt32(INIT_CAPACITY)
var SWEEP_EVENTS       = pool.mallocDouble(INIT_CAPACITY * 8)

//Reserves memory for the 1D sweep data structures
function sqInit(count) {
  var rcount = bits.nextPow2(count)
  if(RED_SWEEP_QUEUE.length < rcount) {
    pool.free(RED_SWEEP_QUEUE)
    RED_SWEEP_QUEUE = pool.mallocInt32(rcount)
  }
  if(RED_SWEEP_INDEX.length < rcount) {
    pool.free(RED_SWEEP_INDEX)
    RED_SWEEP_INDEX = pool.mallocInt32(rcount)
  }
  if(BLUE_SWEEP_QUEUE.length < rcount) {
    pool.free(BLUE_SWEEP_QUEUE)
    BLUE_SWEEP_QUEUE = pool.mallocInt32(rcount)
  }
  if(BLUE_SWEEP_INDEX.length < rcount) {
    pool.free(BLUE_SWEEP_INDEX)
    BLUE_SWEEP_INDEX = pool.mallocInt32(rcount)
  }
  if(COMMON_SWEEP_QUEUE.length < rcount) {
    pool.free(COMMON_SWEEP_QUEUE)
    COMMON_SWEEP_QUEUE = pool.mallocInt32(rcount)
  }
  if(COMMON_SWEEP_INDEX.length < rcount) {
    pool.free(COMMON_SWEEP_INDEX)
    COMMON_SWEEP_INDEX = pool.mallocInt32(rcount)
  }
  var eventLength = 8 * rcount
  if(SWEEP_EVENTS.length < eventLength) {
    pool.free(SWEEP_EVENTS)
    SWEEP_EVENTS = pool.mallocDouble(eventLength)
  }
}

//Remove an item from the active queue in O(1)
function sqPop(queue, index, count, item) {
  var idx = index[item]
  var top = queue[count-1]
  queue[idx] = top
  index[top] = idx
}

//Insert an item into the active queue in O(1)
function sqPush(queue, index, count, item) {
  queue[count] = item
  index[item]  = count
}

//Recursion base case: use 1D sweep algorithm
function sweepBipartite(
    d, visit,
    redStart,  redEnd, red, redIndex,
    blueStart, blueEnd, blue, blueIndex) {

  //store events as pairs [coordinate, idx]
  //
  //  red create:  -(idx+1)
  //  red destroy: idx
  //  blue create: -(idx+BLUE_FLAG)
  //  blue destroy: idx+BLUE_FLAG
  //
  var ptr      = 0
  var elemSize = 2*d
  var istart   = d-1
  var iend     = elemSize-1

  for(var i=redStart; i<redEnd; ++i) {
    var idx = redIndex[i]
    var redOffset = elemSize*i
    SWEEP_EVENTS[ptr++] = red[redOffset+istart]
    SWEEP_EVENTS[ptr++] = -(idx+1)
    SWEEP_EVENTS[ptr++] = red[redOffset+iend]
    SWEEP_EVENTS[ptr++] = idx
  }

  for(var i=blueStart; i<blueEnd; ++i) {
    var idx = blueIndex[i]+BLUE_FLAG
    var blueOffset = elemSize*i
    SWEEP_EVENTS[ptr++] = blue[blueOffset+istart]
    SWEEP_EVENTS[ptr++] = -idx
    SWEEP_EVENTS[ptr++] = blue[blueOffset+iend]
    SWEEP_EVENTS[ptr++] = idx
  }

  //process events from left->right
  var n = ptr >>> 1
  isort(SWEEP_EVENTS, n)
  
  var redActive  = 0
  var blueActive = 0
  for(var i=0; i<n; ++i) {
    var e = SWEEP_EVENTS[2*i+1]|0
    if(e >= BLUE_FLAG) {
      //blue destroy event
      e = (e-BLUE_FLAG)|0
      sqPop(BLUE_SWEEP_QUEUE, BLUE_SWEEP_INDEX, blueActive--, e)
    } else if(e >= 0) {
      //red destroy event
      sqPop(RED_SWEEP_QUEUE, RED_SWEEP_INDEX, redActive--, e)
    } else if(e <= -BLUE_FLAG) {
      //blue create event
      e = (-e-BLUE_FLAG)|0
      for(var j=0; j<redActive; ++j) {
        var retval = visit(RED_SWEEP_QUEUE[j], e)
        if(retval !== void 0) {
          return retval
        }
      }
      sqPush(BLUE_SWEEP_QUEUE, BLUE_SWEEP_INDEX, blueActive++, e)
    } else {
      //red create event
      e = (-e-1)|0
      for(var j=0; j<blueActive; ++j) {
        var retval = visit(e, BLUE_SWEEP_QUEUE[j])
        if(retval !== void 0) {
          return retval
        }
      }
      sqPush(RED_SWEEP_QUEUE, RED_SWEEP_INDEX, redActive++, e)
    }
  }
}

//Complete sweep
function sweepComplete(d, visit, 
  redStart, redEnd, red, redIndex,
  blueStart, blueEnd, blue, blueIndex) {

  var ptr      = 0
  var elemSize = 2*d
  var istart   = d-1
  var iend     = elemSize-1

  for(var i=redStart; i<redEnd; ++i) {
    var idx = (redIndex[i]+1)<<1
    var redOffset = elemSize*i
    SWEEP_EVENTS[ptr++] = red[redOffset+istart]
    SWEEP_EVENTS[ptr++] = -idx
    SWEEP_EVENTS[ptr++] = red[redOffset+iend]
    SWEEP_EVENTS[ptr++] = idx
  }

  for(var i=blueStart; i<blueEnd; ++i) {
    var idx = (blueIndex[i]+1)<<1
    var blueOffset = elemSize*i
    SWEEP_EVENTS[ptr++] = blue[blueOffset+istart]
    SWEEP_EVENTS[ptr++] = (-idx)|1
    SWEEP_EVENTS[ptr++] = blue[blueOffset+iend]
    SWEEP_EVENTS[ptr++] = idx|1
  }

  //process events from left->right
  var n = ptr >>> 1
  isort(SWEEP_EVENTS, n)
  
  var redActive    = 0
  var blueActive   = 0
  var commonActive = 0
  for(var i=0; i<n; ++i) {
    var e     = SWEEP_EVENTS[2*i+1]|0
    var color = e&1
    if(i < n-1 && (e>>1) === (SWEEP_EVENTS[2*i+3]>>1)) {
      color = 2
      i += 1
    }
    
    if(e < 0) {
      //Create event
      var id = -(e>>1) - 1

      //Intersect with common
      for(var j=0; j<commonActive; ++j) {
        var retval = visit(COMMON_SWEEP_QUEUE[j], id)
        if(retval !== void 0) {
          return retval
        }
      }

      if(color !== 0) {
        //Intersect with red
        for(var j=0; j<redActive; ++j) {
          var retval = visit(RED_SWEEP_QUEUE[j], id)
          if(retval !== void 0) {
            return retval
          }
        }
      }

      if(color !== 1) {
        //Intersect with blue
        for(var j=0; j<blueActive; ++j) {
          var retval = visit(BLUE_SWEEP_QUEUE[j], id)
          if(retval !== void 0) {
            return retval
          }
        }
      }

      if(color === 0) {
        //Red
        sqPush(RED_SWEEP_QUEUE, RED_SWEEP_INDEX, redActive++, id)
      } else if(color === 1) {
        //Blue
        sqPush(BLUE_SWEEP_QUEUE, BLUE_SWEEP_INDEX, blueActive++, id)
      } else if(color === 2) {
        //Both
        sqPush(COMMON_SWEEP_QUEUE, COMMON_SWEEP_INDEX, commonActive++, id)
      }
    } else {
      //Destroy event
      var id = (e>>1) - 1
      if(color === 0) {
        //Red
        sqPop(RED_SWEEP_QUEUE, RED_SWEEP_INDEX, redActive--, id)
      } else if(color === 1) {
        //Blue
        sqPop(BLUE_SWEEP_QUEUE, BLUE_SWEEP_INDEX, blueActive--, id)
      } else if(color === 2) {
        //Both
        sqPop(COMMON_SWEEP_QUEUE, COMMON_SWEEP_INDEX, commonActive--, id)
      }
    }
  }
}

//Sweep and prune/scanline algorithm:
//  Scan along axis, detect intersections
//  Brute force all boxes along axis
function scanBipartite(
  d, axis, visit, flip,
  redStart,  redEnd, red, redIndex,
  blueStart, blueEnd, blue, blueIndex) {
  
  var ptr      = 0
  var elemSize = 2*d
  var istart   = axis
  var iend     = axis+d

  var redShift  = 1
  var blueShift = 1
  if(flip) {
    blueShift = BLUE_FLAG
  } else {
    redShift  = BLUE_FLAG
  }

  for(var i=redStart; i<redEnd; ++i) {
    var idx = i + redShift
    var redOffset = elemSize*i
    SWEEP_EVENTS[ptr++] = red[redOffset+istart]
    SWEEP_EVENTS[ptr++] = -idx
    SWEEP_EVENTS[ptr++] = red[redOffset+iend]
    SWEEP_EVENTS[ptr++] = idx
  }
  for(var i=blueStart; i<blueEnd; ++i) {
    var idx = i + blueShift
    var blueOffset = elemSize*i
    SWEEP_EVENTS[ptr++] = blue[blueOffset+istart]
    SWEEP_EVENTS[ptr++] = -idx
  }

  //process events from left->right
  var n = ptr >>> 1
  isort(SWEEP_EVENTS, n)
  
  var redActive    = 0
  for(var i=0; i<n; ++i) {
    var e = SWEEP_EVENTS[2*i+1]|0
    if(e < 0) {
      var idx   = -e
      var isRed = false
      if(idx >= BLUE_FLAG) {
        isRed = !flip
        idx -= BLUE_FLAG 
      } else {
        isRed = !!flip
        idx -= 1
      }
      if(isRed) {
        sqPush(RED_SWEEP_QUEUE, RED_SWEEP_INDEX, redActive++, idx)
      } else {
        var blueId  = blueIndex[idx]
        var bluePtr = elemSize * idx
        
        var b0 = blue[bluePtr+axis+1]
        var b1 = blue[bluePtr+axis+1+d]

red_loop:
        for(var j=0; j<redActive; ++j) {
          var oidx   = RED_SWEEP_QUEUE[j]
          var redPtr = elemSize * oidx

          if(b1 < red[redPtr+axis+1] || 
             red[redPtr+axis+1+d] < b0) {
            continue
          }

          for(var k=axis+2; k<d; ++k) {
            if(blue[bluePtr + k + d] < red[redPtr + k] || 
               red[redPtr + k + d] < blue[bluePtr + k]) {
              continue red_loop
            }
          }

          var redId  = redIndex[oidx]
          var retval
          if(flip) {
            retval = visit(blueId, redId)
          } else {
            retval = visit(redId, blueId)
          }
          if(retval !== void 0) {
            return retval 
          }
        }
      }
    } else {
      sqPop(RED_SWEEP_QUEUE, RED_SWEEP_INDEX, redActive--, e - redShift)
    }
  }
}

function scanComplete(
  d, axis, visit,
  redStart,  redEnd, red, redIndex,
  blueStart, blueEnd, blue, blueIndex) {

  var ptr      = 0
  var elemSize = 2*d
  var istart   = axis
  var iend     = axis+d

  for(var i=redStart; i<redEnd; ++i) {
    var idx = i + BLUE_FLAG
    var redOffset = elemSize*i
    SWEEP_EVENTS[ptr++] = red[redOffset+istart]
    SWEEP_EVENTS[ptr++] = -idx
    SWEEP_EVENTS[ptr++] = red[redOffset+iend]
    SWEEP_EVENTS[ptr++] = idx
  }
  for(var i=blueStart; i<blueEnd; ++i) {
    var idx = i + 1
    var blueOffset = elemSize*i
    SWEEP_EVENTS[ptr++] = blue[blueOffset+istart]
    SWEEP_EVENTS[ptr++] = -idx
  }

  //process events from left->right
  var n = ptr >>> 1
  isort(SWEEP_EVENTS, n)
  
  var redActive    = 0
  for(var i=0; i<n; ++i) {
    var e = SWEEP_EVENTS[2*i+1]|0
    if(e < 0) {
      var idx   = -e
      if(idx >= BLUE_FLAG) {
        RED_SWEEP_QUEUE[redActive++] = idx - BLUE_FLAG
      } else {
        idx -= 1
        var blueId  = blueIndex[idx]
        var bluePtr = elemSize * idx

        var b0 = blue[bluePtr+axis+1]
        var b1 = blue[bluePtr+axis+1+d]

red_loop:
        for(var j=0; j<redActive; ++j) {
          var oidx   = RED_SWEEP_QUEUE[j]
          var redId  = redIndex[oidx]

          if(redId === blueId) {
            break
          }

          var redPtr = elemSize * oidx
          if(b1 < red[redPtr+axis+1] || 
            red[redPtr+axis+1+d] < b0) {
            continue
          }
          for(var k=axis+2; k<d; ++k) {
            if(blue[bluePtr + k + d] < red[redPtr + k] || 
               red[redPtr + k + d]   < blue[bluePtr + k]) {
              continue red_loop
            }
          }

          var retval = visit(redId, blueId)
          if(retval !== void 0) {
            return retval 
          }
        }
      }
    } else {
      var idx = e - BLUE_FLAG
      for(var j=redActive-1; j>=0; --j) {
        if(RED_SWEEP_QUEUE[j] === idx) {
          for(var k=j+1; k<redActive; ++k) {
            RED_SWEEP_QUEUE[k-1] = RED_SWEEP_QUEUE[k]
          }
          break
        }
      }
      --redActive
    }
  }
}
},{"./sort":26,"bit-twiddle":20,"typedarray-pool":180}],28:[function(require,module,exports){

},{}],29:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var R = typeof Reflect === 'object' ? Reflect : null
var ReflectApply = R && typeof R.apply === 'function'
  ? R.apply
  : function ReflectApply(target, receiver, args) {
    return Function.prototype.apply.call(target, receiver, args);
  }

var ReflectOwnKeys
if (R && typeof R.ownKeys === 'function') {
  ReflectOwnKeys = R.ownKeys
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target)
      .concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
  };
}

function ProcessEmitWarning(warning) {
  if (console && console.warn) console.warn(warning);
}

var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
  return value !== value;
}

function EventEmitter() {
  EventEmitter.init.call(this);
}
module.exports = EventEmitter;
module.exports.once = once;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;

function checkListener(listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
}

Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
  enumerable: true,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(arg) {
    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
    }
    defaultMaxListeners = arg;
  }
});

EventEmitter.init = function() {

  if (this._events === undefined ||
      this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
};

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
  }
  this._maxListeners = n;
  return this;
};

function _getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};

EventEmitter.prototype.emit = function emit(type) {
  var args = [];
  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
  var doError = (type === 'error');

  var events = this._events;
  if (events !== undefined)
    doError = (doError && events.error === undefined);
  else if (!doError)
    return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    var er;
    if (args.length > 0)
      er = args[0];
    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    }
    // At least give some kind of context to the user
    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }

  var handler = events[type];

  if (handler === undefined)
    return false;

  if (typeof handler === 'function') {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      ReflectApply(listeners[i], this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  checkListener(listener);

  events = target._events;
  if (events === undefined) {
    events = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener !== undefined) {
      target.emit('newListener', type,
                  listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (existing === undefined) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] =
        prepend ? [listener, existing] : [existing, listener];
      // If we've already got an array, just append.
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }

    // Check for listener leak
    m = _getMaxListeners(target);
    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true;
      // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax
      var w = new Error('Possible EventEmitter memory leak detected. ' +
                          existing.length + ' ' + String(type) + ' listeners ' +
                          'added. Use emitter.setMaxListeners() to ' +
                          'increase limit');
      w.name = 'MaxListenersExceededWarning';
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0)
      return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}

function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  checkListener(listener);
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      checkListener(listener);

      events = this._events;
      if (events === undefined)
        return this;

      list = events[type];
      if (list === undefined)
        return this;

      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }

        if (list.length === 1)
          events[type] = list[0];

        if (events.removeListener !== undefined)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };

EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events, i;

      events = this._events;
      if (events === undefined)
        return this;

      // not listening for removeListener, no need to emit
      if (events.removeListener === undefined) {
        if (arguments.length === 0) {
          this._events = Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== undefined) {
          if (--this._eventsCount === 0)
            this._events = Object.create(null);
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = Object.create(null);
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners !== undefined) {
        // LIFO order
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }

      return this;
    };

function _listeners(target, type, unwrap) {
  var events = target._events;

  if (events === undefined)
    return [];

  var evlistener = events[type];
  if (evlistener === undefined)
    return [];

  if (typeof evlistener === 'function')
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

  return unwrap ?
    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events !== undefined) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener !== undefined) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}

function spliceOne(list, index) {
  for (; index + 1 < list.length; index++)
    list[index] = list[index + 1];
  list.pop();
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}

function once(emitter, name) {
  return new Promise(function (resolve, reject) {
    function errorListener(err) {
      emitter.removeListener(name, resolver);
      reject(err);
    }

    function resolver() {
      if (typeof emitter.removeListener === 'function') {
        emitter.removeListener('error', errorListener);
      }
      resolve([].slice.call(arguments));
    };

    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
    if (name !== 'error') {
      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
    }
  });
}

function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
  if (typeof emitter.on === 'function') {
    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);
  }
}

function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
  if (typeof emitter.on === 'function') {
    if (flags.once) {
      emitter.once(name, listener);
    } else {
      emitter.on(name, listener);
    }
  } else if (typeof emitter.addEventListener === 'function') {
    // EventTarget does not have `error` event semantics like Node
    // EventEmitters, we do not listen for `error` events here.
    emitter.addEventListener(name, function wrapListener(arg) {
      // IE does not have builtin `{ once: true }` support so we
      // have to do it manually.
      if (flags.once) {
        emitter.removeEventListener(name, wrapListener);
      }
      listener(arg);
    });
  } else {
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
  }
}

},{}],30:[function(require,module,exports){
(function (Buffer){(function (){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

var K_MAX_LENGTH = 0x7fffffff
exports.kMaxLength = K_MAX_LENGTH

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
    typeof console.error === 'function') {
  console.error(
    'This browser lacks typed array (Uint8Array) support which is required by ' +
    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
  )
}

function typedArraySupport () {
  // Can typed array instances can be augmented?
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function () { return 42 } }
    return arr.foo() === 42
  } catch (e) {
    return false
  }
}

Object.defineProperty(Buffer.prototype, 'parent', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.buffer
  }
})

Object.defineProperty(Buffer.prototype, 'offset', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.byteOffset
  }
})

function createBuffer (length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('The value "' + length + '" is invalid for option "size"')
  }
  // Return an augmented `Uint8Array` instance
  var buf = new Uint8Array(length)
  buf.__proto__ = Buffer.prototype
  return buf
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new TypeError(
        'The "string" argument must be of type string. Received type number'
      )
    }
    return allocUnsafe(arg)
  }
  return from(arg, encodingOrOffset, length)
}

// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
if (typeof Symbol !== 'undefined' && Symbol.species != null &&
    Buffer[Symbol.species] === Buffer) {
  Object.defineProperty(Buffer, Symbol.species, {
    value: null,
    configurable: true,
    enumerable: false,
    writable: false
  })
}

Buffer.poolSize = 8192 // not used by this implementation

function from (value, encodingOrOffset, length) {
  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  if (ArrayBuffer.isView(value)) {
    return fromArrayLike(value)
  }

  if (value == null) {
    throw TypeError(
      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
      'or Array-like Object. Received type ' + (typeof value)
    )
  }

  if (isInstance(value, ArrayBuffer) ||
      (value && isInstance(value.buffer, ArrayBuffer))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'number') {
    throw new TypeError(
      'The "value" argument must not be of type number. Received type number'
    )
  }

  var valueOf = value.valueOf && value.valueOf()
  if (valueOf != null && valueOf !== value) {
    return Buffer.from(valueOf, encodingOrOffset, length)
  }

  var b = fromObject(value)
  if (b) return b

  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&
      typeof value[Symbol.toPrimitive] === 'function') {
    return Buffer.from(
      value[Symbol.toPrimitive]('string'), encodingOrOffset, length
    )
  }

  throw new TypeError(
    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
    'or Array-like Object. Received type ' + (typeof value)
  )
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length)
}

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Buffer.prototype.__proto__ = Uint8Array.prototype
Buffer.__proto__ = Uint8Array

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be of type number')
  } else if (size < 0) {
    throw new RangeError('The value "' + size + '" is invalid for option "size"')
  }
}

function alloc (size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(size).fill(fill, encoding)
      : createBuffer(size).fill(fill)
  }
  return createBuffer(size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding)
}

function allocUnsafe (size) {
  assertSize(size)
  return createBuffer(size < 0 ? 0 : checked(size) | 0)
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size)
}

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('Unknown encoding: ' + encoding)
  }

  var length = byteLength(string, encoding) | 0
  var buf = createBuffer(length)

  var actual = buf.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual)
  }

  return buf
}

function fromArrayLike (array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  var buf = createBuffer(length)
  for (var i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255
  }
  return buf
}

function fromArrayBuffer (array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('"offset" is outside of buffer bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('"length" is outside of buffer bounds')
  }

  var buf
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array)
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset)
  } else {
    buf = new Uint8Array(array, byteOffset, length)
  }

  // Return an augmented `Uint8Array` instance
  buf.__proto__ = Buffer.prototype
  return buf
}

function fromObject (obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    var buf = createBuffer(len)

    if (buf.length === 0) {
      return buf
    }

    obj.copy(buf, 0, 0, len)
    return buf
  }

  if (obj.length !== undefined) {
    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
      return createBuffer(0)
    }
    return fromArrayLike(obj)
  }

  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
    return fromArrayLike(obj.data)
  }
}

function checked (length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return b != null && b._isBuffer === true &&
    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
}

Buffer.compare = function compare (a, b) {
  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)
  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError(
      'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
    )
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (isInstance(buf, Uint8Array)) {
      buf = Buffer.from(buf)
    }
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    throw new TypeError(
      'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
      'Received type ' + typeof string
    )
  }

  var len = string.length
  var mustMatch = (arguments.length > 2 && arguments[2] === true)
  if (!mustMatch && len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) {
          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
        }
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.toLocaleString = Buffer.prototype.toString

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()
  if (this.length > max) str += ' ... '
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (isInstance(target, Uint8Array)) {
    target = Buffer.from(target, target.offset, target.byteLength)
  }
  if (!Buffer.isBuffer(target)) {
    throw new TypeError(
      'The "target" argument must be one of type Buffer or Uint8Array. ' +
      'Received type ' + (typeof target)
    )
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset // Coerce to Number.
  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  var strLen = string.length

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (numberIsNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0
    if (isFinite(length)) {
      length = length >>> 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
        : (firstByte > 0xBF) ? 2
          : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf = this.subarray(start, end)
  // Return an augmented `Uint8Array` instance
  newBuf.__proto__ = Buffer.prototype
  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset + 3] = (value >>> 24)
  this[offset + 2] = (value >>> 16)
  this[offset + 1] = (value >>> 8)
  this[offset] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  this[offset + 2] = (value >>> 16)
  this[offset + 3] = (value >>> 24)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start

  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
    // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end)
  } else if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (var i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, end),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if ((encoding === 'utf8' && code < 128) ||
          encoding === 'latin1') {
        // Fast path: If `val` fits into a single byte, use that numeric value.
        val = code
      }
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : Buffer.from(val, encoding)
    var len = bytes.length
    if (len === 0) {
      throw new TypeError('The value "' + val +
        '" is invalid for argument "value"')
    }
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node takes equal signs as end of the Base64 encoding
  str = str.split('=')[0]
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance (obj, type) {
  return obj instanceof type ||
    (obj != null && obj.constructor != null && obj.constructor.name != null &&
      obj.constructor.name === type.name)
}
function numberIsNaN (obj) {
  // For IE11 support
  return obj !== obj // eslint-disable-line no-self-compare
}

}).call(this)}).call(this,require("buffer").Buffer)

},{"base64-js":1,"buffer":30,"ieee754":78}],31:[function(require,module,exports){
'use strict'

var monotoneTriangulate = require('./lib/monotone')
var makeIndex = require('./lib/triangulation')
var delaunayFlip = require('./lib/delaunay')
var filterTriangulation = require('./lib/filter')

module.exports = cdt2d

function canonicalizeEdge(e) {
  return [Math.min(e[0], e[1]), Math.max(e[0], e[1])]
}

function compareEdge(a, b) {
  return a[0]-b[0] || a[1]-b[1]
}

function canonicalizeEdges(edges) {
  return edges.map(canonicalizeEdge).sort(compareEdge)
}

function getDefault(options, property, dflt) {
  if(property in options) {
    return options[property]
  }
  return dflt
}

function cdt2d(points, edges, options) {

  if(!Array.isArray(edges)) {
    options = edges || {}
    edges = []
  } else {
    options = options || {}
    edges = edges || []
  }

  //Parse out options
  var delaunay = !!getDefault(options, 'delaunay', true)
  var interior = !!getDefault(options, 'interior', true)
  var exterior = !!getDefault(options, 'exterior', true)
  var infinity = !!getDefault(options, 'infinity', false)

  //Handle trivial case
  if((!interior && !exterior) || points.length === 0) {
    return []
  }

  //Construct initial triangulation
  var cells = monotoneTriangulate(points, edges)

  //If delaunay refinement needed, then improve quality by edge flipping
  if(delaunay || interior !== exterior || infinity) {

    //Index all of the cells to support fast neighborhood queries
    var triangulation = makeIndex(points.length, canonicalizeEdges(edges))
    for(var i=0; i<cells.length; ++i) {
      var f = cells[i]
      triangulation.addTriangle(f[0], f[1], f[2])
    }

    //Run edge flipping
    if(delaunay) {
      delaunayFlip(points, triangulation)
    }

    //Filter points
    if(!exterior) {
      return filterTriangulation(triangulation, -1)
    } else if(!interior) {
      return filterTriangulation(triangulation,  1, infinity)
    } else if(infinity) {
      return filterTriangulation(triangulation, 0, infinity)
    } else {
      return triangulation.cells()
    }
    
  } else {
    return cells
  }
}

},{"./lib/delaunay":32,"./lib/filter":33,"./lib/monotone":34,"./lib/triangulation":35}],32:[function(require,module,exports){
'use strict'

var inCircle = require('robust-in-sphere')[4]
var bsearch = require('binary-search-bounds')

module.exports = delaunayRefine

function testFlip(points, triangulation, stack, a, b, x) {
  var y = triangulation.opposite(a, b)

  //Test boundary edge
  if(y < 0) {
    return
  }

  //Swap edge if order flipped
  if(b < a) {
    var tmp = a
    a = b
    b = tmp
    tmp = x
    x = y
    y = tmp
  }

  //Test if edge is constrained
  if(triangulation.isConstraint(a, b)) {
    return
  }

  //Test if edge is delaunay
  if(inCircle(points[a], points[b], points[x], points[y]) < 0) {
    stack.push(a, b)
  }
}

//Assume edges are sorted lexicographically
function delaunayRefine(points, triangulation) {
  var stack = []

  var numPoints = points.length
  var stars = triangulation.stars
  for(var a=0; a<numPoints; ++a) {
    var star = stars[a]
    for(var j=1; j<star.length; j+=2) {
      var b = star[j]

      //If order is not consistent, then skip edge
      if(b < a) {
        continue
      }

      //Check if edge is constrained
      if(triangulation.isConstraint(a, b)) {
        continue
      }

      //Find opposite edge
      var x = star[j-1], y = -1
      for(var k=1; k<star.length; k+=2) {
        if(star[k-1] === b) {
          y = star[k]
          break
        }
      }

      //If this is a boundary edge, don't flip it
      if(y < 0) {
        continue
      }

      //If edge is in circle, flip it
      if(inCircle(points[a], points[b], points[x], points[y]) < 0) {
        stack.push(a, b)
      }
    }
  }

  while(stack.length > 0) {
    var b = stack.pop()
    var a = stack.pop()

    //Find opposite pairs
    var x = -1, y = -1
    var star = stars[a]
    for(var i=1; i<star.length; i+=2) {
      var s = star[i-1]
      var t = star[i]
      if(s === b) {
        y = t
      } else if(t === b) {
        x = s
      }
    }

    //If x/y are both valid then skip edge
    if(x < 0 || y < 0) {
      continue
    }

    //If edge is now delaunay, then don't flip it
    if(inCircle(points[a], points[b], points[x], points[y]) >= 0) {
      continue
    }

    //Flip the edge
    triangulation.flip(a, b)

    //Test flipping neighboring edges
    testFlip(points, triangulation, stack, x, a, y)
    testFlip(points, triangulation, stack, a, y, x)
    testFlip(points, triangulation, stack, y, b, x)
    testFlip(points, triangulation, stack, b, x, y)
  }
}

},{"binary-search-bounds":19,"robust-in-sphere":104}],33:[function(require,module,exports){
'use strict'

var bsearch = require('binary-search-bounds')

module.exports = classifyFaces

function FaceIndex(cells, neighbor, constraint, flags, active, next, boundary) {
  this.cells       = cells
  this.neighbor    = neighbor
  this.flags       = flags
  this.constraint  = constraint
  this.active      = active
  this.next        = next
  this.boundary    = boundary
}

var proto = FaceIndex.prototype

function compareCell(a, b) {
  return a[0] - b[0] ||
         a[1] - b[1] ||
         a[2] - b[2]
}

proto.locate = (function() {
  var key = [0,0,0]
  return function(a, b, c) {
    var x = a, y = b, z = c
    if(b < c) {
      if(b < a) {
        x = b
        y = c
        z = a
      }
    } else if(c < a) {
      x = c
      y = a
      z = b
    }
    if(x < 0) {
      return -1
    }
    key[0] = x
    key[1] = y
    key[2] = z
    return bsearch.eq(this.cells, key, compareCell)
  }
})()

function indexCells(triangulation, infinity) {
  //First get cells and canonicalize
  var cells = triangulation.cells()
  var nc = cells.length
  for(var i=0; i<nc; ++i) {
    var c = cells[i]
    var x = c[0], y = c[1], z = c[2]
    if(y < z) {
      if(y < x) {
        c[0] = y
        c[1] = z
        c[2] = x
      }
    } else if(z < x) {
      c[0] = z
      c[1] = x
      c[2] = y
    }
  }
  cells.sort(compareCell)

  //Initialize flag array
  var flags = new Array(nc)
  for(var i=0; i<flags.length; ++i) {
    flags[i] = 0
  }

  //Build neighbor index, initialize queues
  var active = []
  var next   = []
  var neighbor = new Array(3*nc)
  var constraint = new Array(3*nc)
  var boundary = null
  if(infinity) {
    boundary = []
  }
  var index = new FaceIndex(
    cells,
    neighbor,
    constraint,
    flags,
    active,
    next,
    boundary)
  for(var i=0; i<nc; ++i) {
    var c = cells[i]
    for(var j=0; j<3; ++j) {
      var x = c[j], y = c[(j+1)%3]
      var a = neighbor[3*i+j] = index.locate(y, x, triangulation.opposite(y, x))
      var b = constraint[3*i+j] = triangulation.isConstraint(x, y)
      if(a < 0) {
        if(b) {
          next.push(i)
        } else {
          active.push(i)
          flags[i] = 1
        }
        if(infinity) {
          boundary.push([y, x, -1])
        }
      }
    }
  }
  return index
}

function filterCells(cells, flags, target) {
  var ptr = 0
  for(var i=0; i<cells.length; ++i) {
    if(flags[i] === target) {
      cells[ptr++] = cells[i]
    }
  }
  cells.length = ptr
  return cells
}

function classifyFaces(triangulation, target, infinity) {
  var index = indexCells(triangulation, infinity)

  if(target === 0) {
    if(infinity) {
      return index.cells.concat(index.boundary)
    } else {
      return index.cells
    }
  }

  var side = 1
  var active = index.active
  var next = index.next
  var flags = index.flags
  var cells = index.cells
  var constraint = index.constraint
  var neighbor = index.neighbor

  while(active.length > 0 || next.length > 0) {
    while(active.length > 0) {
      var t = active.pop()
      if(flags[t] === -side) {
        continue
      }
      flags[t] = side
      var c = cells[t]
      for(var j=0; j<3; ++j) {
        var f = neighbor[3*t+j]
        if(f >= 0 && flags[f] === 0) {
          if(constraint[3*t+j]) {
            next.push(f)
          } else {
            active.push(f)
            flags[f] = side
          }
        }
      }
    }

    //Swap arrays and loop
    var tmp = next
    next = active
    active = tmp
    next.length = 0
    side = -side
  }

  var result = filterCells(cells, flags, target)
  if(infinity) {
    return result.concat(index.boundary)
  }
  return result
}

},{"binary-search-bounds":19}],34:[function(require,module,exports){
'use strict'

var bsearch = require('binary-search-bounds')
var orient = require('robust-orientation')[3]

var EVENT_POINT = 0
var EVENT_END   = 1
var EVENT_START = 2

module.exports = monotoneTriangulate

//A partial convex hull fragment, made of two unimonotone polygons
function PartialHull(a, b, idx, lowerIds, upperIds) {
  this.a = a
  this.b = b
  this.idx = idx
  this.lowerIds = lowerIds
  this.upperIds = upperIds
}

//An event in the sweep line procedure
function Event(a, b, type, idx) {
  this.a    = a
  this.b    = b
  this.type = type
  this.idx  = idx
}

//This is used to compare events for the sweep line procedure
// Points are:
//  1. sorted lexicographically
//  2. sorted by type  (point < end < start)
//  3. segments sorted by winding order
//  4. sorted by index
function compareEvent(a, b) {
  var d =
    (a.a[0] - b.a[0]) ||
    (a.a[1] - b.a[1]) ||
    (a.type - b.type)
  if(d) { return d }
  if(a.type !== EVENT_POINT) {
    d = orient(a.a, a.b, b.b)
    if(d) { return d }
  }
  return a.idx - b.idx
}

function testPoint(hull, p) {
  return orient(hull.a, hull.b, p)
}

function addPoint(cells, hulls, points, p, idx) {
  var lo = bsearch.lt(hulls, p, testPoint)
  var hi = bsearch.gt(hulls, p, testPoint)
  for(var i=lo; i<hi; ++i) {
    var hull = hulls[i]

    //Insert p into lower hull
    var lowerIds = hull.lowerIds
    var m = lowerIds.length
    while(m > 1 && orient(
        points[lowerIds[m-2]],
        points[lowerIds[m-1]],
        p) > 0) {
      cells.push(
        [lowerIds[m-1],
         lowerIds[m-2],
         idx])
      m -= 1
    }
    lowerIds.length = m
    lowerIds.push(idx)

    //Insert p into upper hull
    var upperIds = hull.upperIds
    var m = upperIds.length
    while(m > 1 && orient(
        points[upperIds[m-2]],
        points[upperIds[m-1]],
        p) < 0) {
      cells.push(
        [upperIds[m-2],
         upperIds[m-1],
         idx])
      m -= 1
    }
    upperIds.length = m
    upperIds.push(idx)
  }
}

function findSplit(hull, edge) {
  var d
  if(hull.a[0] < edge.a[0]) {
    d = orient(hull.a, hull.b, edge.a)
  } else {
    d = orient(edge.b, edge.a, hull.a)
  }
  if(d) { return d }
  if(edge.b[0] < hull.b[0]) {
    d = orient(hull.a, hull.b, edge.b)
  } else {
    d = orient(edge.b, edge.a, hull.b)
  }
  return d || hull.idx - edge.idx
}

function splitHulls(hulls, points, event) {
  var splitIdx = bsearch.le(hulls, event, findSplit)
  var hull = hulls[splitIdx]
  var upperIds = hull.upperIds
  var x = upperIds[upperIds.length-1]
  hull.upperIds = [x]
  hulls.splice(splitIdx+1, 0,
    new PartialHull(event.a, event.b, event.idx, [x], upperIds))
}


function mergeHulls(hulls, points, event) {
  //Swap pointers for merge search
  var tmp = event.a
  event.a = event.b
  event.b = tmp
  var mergeIdx = bsearch.eq(hulls, event, findSplit)
  var upper = hulls[mergeIdx]
  var lower = hulls[mergeIdx-1]
  lower.upperIds = upper.upperIds
  hulls.splice(mergeIdx, 1)
}


function monotoneTriangulate(points, edges) {

  var numPoints = points.length
  var numEdges = edges.length

  var events = []

  //Create point events
  for(var i=0; i<numPoints; ++i) {
    events.push(new Event(
      points[i],
      null,
      EVENT_POINT,
      i))
  }

  //Create edge events
  for(var i=0; i<numEdges; ++i) {
    var e = edges[i]
    var a = points[e[0]]
    var b = points[e[1]]
    if(a[0] < b[0]) {
      events.push(
        new Event(a, b, EVENT_START, i),
        new Event(b, a, EVENT_END, i))
    } else if(a[0] > b[0]) {
      events.push(
        new Event(b, a, EVENT_START, i),
        new Event(a, b, EVENT_END, i))
    }
  }

  //Sort events
  events.sort(compareEvent)

  //Initialize hull
  var minX = events[0].a[0] - (1 + Math.abs(events[0].a[0])) * Math.pow(2, -52)
  var hull = [ new PartialHull([minX, 1], [minX, 0], -1, [], [], [], []) ]

  //Process events in order
  var cells = []
  for(var i=0, numEvents=events.length; i<numEvents; ++i) {
    var event = events[i]
    var type = event.type
    if(type === EVENT_POINT) {
      addPoint(cells, hull, points, event.a, event.idx)
    } else if(type === EVENT_START) {
      splitHulls(hull, points, event)
    } else {
      mergeHulls(hull, points, event)
    }
  }

  //Return triangulation
  return cells
}

},{"binary-search-bounds":19,"robust-orientation":105}],35:[function(require,module,exports){
'use strict'

var bsearch = require('binary-search-bounds')

module.exports = createTriangulation

function Triangulation(stars, edges) {
  this.stars = stars
  this.edges = edges
}

var proto = Triangulation.prototype

function removePair(list, j, k) {
  for(var i=1, n=list.length; i<n; i+=2) {
    if(list[i-1] === j && list[i] === k) {
      list[i-1] = list[n-2]
      list[i] = list[n-1]
      list.length = n - 2
      return
    }
  }
}

proto.isConstraint = (function() {
  var e = [0,0]
  function compareLex(a, b) {
    return a[0] - b[0] || a[1] - b[1]
  }
  return function(i, j) {
    e[0] = Math.min(i,j)
    e[1] = Math.max(i,j)
    return bsearch.eq(this.edges, e, compareLex) >= 0
  }
})()

proto.removeTriangle = function(i, j, k) {
  var stars = this.stars
  removePair(stars[i], j, k)
  removePair(stars[j], k, i)
  removePair(stars[k], i, j)
}

proto.addTriangle = function(i, j, k) {
  var stars = this.stars
  stars[i].push(j, k)
  stars[j].push(k, i)
  stars[k].push(i, j)
}

proto.opposite = function(j, i) {
  var list = this.stars[i]
  for(var k=1, n=list.length; k<n; k+=2) {
    if(list[k] === j) {
      return list[k-1]
    }
  }
  return -1
}

proto.flip = function(i, j) {
  var a = this.opposite(i, j)
  var b = this.opposite(j, i)
  this.removeTriangle(i, j, a)
  this.removeTriangle(j, i, b)
  this.addTriangle(i, b, a)
  this.addTriangle(j, a, b)
}

proto.edges = function() {
  var stars = this.stars
  var result = []
  for(var i=0, n=stars.length; i<n; ++i) {
    var list = stars[i]
    for(var j=0, m=list.length; j<m; j+=2) {
      result.push([list[j], list[j+1]])
    }
  }
  return result
}

proto.cells = function() {
  var stars = this.stars
  var result = []
  for(var i=0, n=stars.length; i<n; ++i) {
    var list = stars[i]
    for(var j=0, m=list.length; j<m; j+=2) {
      var s = list[j]
      var t = list[j+1]
      if(i < Math.min(s, t)) {
        result.push([i, s, t])
      }
    }
  }
  return result
}

function createTriangulation(numVerts, edges) {
  var stars = new Array(numVerts)
  for(var i=0; i<numVerts; ++i) {
    stars[i] = []
  }
  return new Triangulation(stars, edges)
}

},{"binary-search-bounds":19}],36:[function(require,module,exports){
'use strict'

module.exports = cleanPSLG

var UnionFind = require('union-find')
var boxIntersect = require('box-intersect')
var segseg = require('robust-segment-intersect')
var rat = require('big-rat')
var ratCmp = require('big-rat/cmp')
var ratToFloat = require('big-rat/to-float')
var ratVec = require('rat-vec')
var nextafter = require('nextafter')

var solveIntersection = require('./lib/rat-seg-intersect')

// Bounds on a rational number when rounded to a float
function boundRat (r) {
  var f = ratToFloat(r)
  return [
    nextafter(f, -Infinity),
    nextafter(f, Infinity)
  ]
}

// Convert a list of edges in a pslg to bounding boxes
function boundEdges (points, edges) {
  var bounds = new Array(edges.length)
  for (var i = 0; i < edges.length; ++i) {
    var e = edges[i]
    var a = points[e[0]]
    var b = points[e[1]]
    bounds[i] = [
      nextafter(Math.min(a[0], b[0]), -Infinity),
      nextafter(Math.min(a[1], b[1]), -Infinity),
      nextafter(Math.max(a[0], b[0]), Infinity),
      nextafter(Math.max(a[1], b[1]), Infinity)
    ]
  }
  return bounds
}

// Convert a list of points into bounding boxes by duplicating coords
function boundPoints (points) {
  var bounds = new Array(points.length)
  for (var i = 0; i < points.length; ++i) {
    var p = points[i]
    bounds[i] = [
      nextafter(p[0], -Infinity),
      nextafter(p[1], -Infinity),
      nextafter(p[0], Infinity),
      nextafter(p[1], Infinity)
    ]
  }
  return bounds
}

// Find all pairs of crossing edges in a pslg (given edge bounds)
function getCrossings (points, edges, edgeBounds) {
  var result = []
  boxIntersect(edgeBounds, function (i, j) {
    var e = edges[i]
    var f = edges[j]
    if (e[0] === f[0] || e[0] === f[1] ||
      e[1] === f[0] || e[1] === f[1]) {
      return
    }
    var a = points[e[0]]
    var b = points[e[1]]
    var c = points[f[0]]
    var d = points[f[1]]
    if (segseg(a, b, c, d)) {
      result.push([i, j])
    }
  })
  return result
}

// Find all pairs of crossing vertices in a pslg (given edge/vert bounds)
function getTJunctions (points, edges, edgeBounds, vertBounds) {
  var result = []
  boxIntersect(edgeBounds, vertBounds, function (i, v) {
    var e = edges[i]
    if (e[0] === v || e[1] === v) {
      return
    }
    var p = points[v]
    var a = points[e[0]]
    var b = points[e[1]]
    if (segseg(a, b, p, p)) {
      result.push([i, v])
    }
  })
  return result
}

// Cut edges along crossings/tjunctions
function cutEdges (floatPoints, edges, crossings, junctions, useColor) {
  var i, e

  // Convert crossings into tjunctions by constructing rational points
  var ratPoints = floatPoints.map(function(p) {
      return [
          rat(p[0]),
          rat(p[1])
      ]
  })
  for (i = 0; i < crossings.length; ++i) {
    var crossing = crossings[i]
    e = crossing[0]
    var f = crossing[1]
    var ee = edges[e]
    var ef = edges[f]
    var x = solveIntersection(
      ratVec(floatPoints[ee[0]]),
      ratVec(floatPoints[ee[1]]),
      ratVec(floatPoints[ef[0]]),
      ratVec(floatPoints[ef[1]]))
    if (!x) {
      // Segments are parallel, should already be handled by t-junctions
      continue
    }
    var idx = floatPoints.length
    floatPoints.push([ratToFloat(x[0]), ratToFloat(x[1])])
    ratPoints.push(x)
    junctions.push([e, idx], [f, idx])
  }

  // Sort tjunctions
  junctions.sort(function (a, b) {
    if (a[0] !== b[0]) {
      return a[0] - b[0]
    }
    var u = ratPoints[a[1]]
    var v = ratPoints[b[1]]
    return ratCmp(u[0], v[0]) || ratCmp(u[1], v[1])
  })

  // Split edges along junctions
  for (i = junctions.length - 1; i >= 0; --i) {
    var junction = junctions[i]
    e = junction[0]

    var edge = edges[e]
    var s = edge[0]
    var t = edge[1]

    // Check if edge is not lexicographically sorted
    var a = floatPoints[s]
    var b = floatPoints[t]
    if (((a[0] - b[0]) || (a[1] - b[1])) < 0) {
      var tmp = s
      s = t
      t = tmp
    }

    // Split leading edge
    edge[0] = s
    var last = edge[1] = junction[1]

    // If we are grouping edges by color, remember to track data
    var color
    if (useColor) {
      color = edge[2]
    }

    // Split other edges
    while (i > 0 && junctions[i - 1][0] === e) {
      var junction = junctions[--i]
      var next = junction[1]
      if (useColor) {
        edges.push([last, next, color])
      } else {
        edges.push([last, next])
      }
      last = next
    }

    // Add final edge
    if (useColor) {
      edges.push([last, t, color])
    } else {
      edges.push([last, t])
    }
  }

  // Return constructed rational points
  return ratPoints
}

// Merge overlapping points
function dedupPoints (floatPoints, ratPoints, floatBounds) {
  var numPoints = ratPoints.length
  var uf = new UnionFind(numPoints)

  // Compute rational bounds
  var bounds = []
  for (var i = 0; i < ratPoints.length; ++i) {
    var p = ratPoints[i]
    var xb = boundRat(p[0])
    var yb = boundRat(p[1])
    bounds.push([
      nextafter(xb[0], -Infinity),
      nextafter(yb[0], -Infinity),
      nextafter(xb[1], Infinity),
      nextafter(yb[1], Infinity)
    ])
  }

  // Link all points with over lapping boxes
  boxIntersect(bounds, function (i, j) {
    uf.link(i, j)
  })

  // Do 1 pass over points to combine points in label sets
  var noDupes = true
  var labels = new Array(numPoints)
  for (var i = 0; i < numPoints; ++i) {
    var j = uf.find(i)
    if (j !== i) {
      // Clear no-dupes flag, zero out label
      noDupes = false
      // Make each point the top-left point from its cell
      floatPoints[j] = [
        Math.min(floatPoints[i][0], floatPoints[j][0]),
        Math.min(floatPoints[i][1], floatPoints[j][1])
      ]
    }
  }

  // If no duplicates, return null to signal termination
  if (noDupes) {
    return null
  }

  var ptr = 0
  for (var i = 0; i < numPoints; ++i) {
    var j = uf.find(i)
    if (j === i) {
      labels[i] = ptr
      floatPoints[ptr++] = floatPoints[i]
    } else {
      labels[i] = -1
    }
  }

  floatPoints.length = ptr

  // Do a second pass to fix up missing labels
  for (var i = 0; i < numPoints; ++i) {
    if (labels[i] < 0) {
      labels[i] = labels[uf.find(i)]
    }
  }

  // Return resulting union-find data structure
  return labels
}

function compareLex2 (a, b) { return (a[0] - b[0]) || (a[1] - b[1]) }
function compareLex3 (a, b) {
  var d = (a[0] - b[0]) || (a[1] - b[1])
  if (d) {
    return d
  }
  if (a[2] < b[2]) {
    return -1
  } else if (a[2] > b[2]) {
    return 1
  }
  return 0
}

// Remove duplicate edge labels
function dedupEdges (edges, labels, useColor) {
  if (edges.length === 0) {
    return
  }
  if (labels) {
    for (var i = 0; i < edges.length; ++i) {
      var e = edges[i]
      var a = labels[e[0]]
      var b = labels[e[1]]
      e[0] = Math.min(a, b)
      e[1] = Math.max(a, b)
    }
  } else {
    for (var i = 0; i < edges.length; ++i) {
      var e = edges[i]
      var a = e[0]
      var b = e[1]
      e[0] = Math.min(a, b)
      e[1] = Math.max(a, b)
    }
  }
  if (useColor) {
    edges.sort(compareLex3)
  } else {
    edges.sort(compareLex2)
  }
  var ptr = 1
  for (var i = 1; i < edges.length; ++i) {
    var prev = edges[i - 1]
    var next = edges[i]
    if (next[0] === prev[0] && next[1] === prev[1] &&
      (!useColor || next[2] === prev[2])) {
      continue
    }
    edges[ptr++] = next
  }
  edges.length = ptr
}

function preRound (points, edges, useColor) {
  var labels = dedupPoints(points, [], boundPoints(points))
  dedupEdges(edges, labels, useColor)
  return !!labels
}

// Repeat until convergence
function snapRound (points, edges, useColor) {
  // 1. find edge crossings
  var edgeBounds = boundEdges(points, edges)
  var crossings = getCrossings(points, edges, edgeBounds)

  // 2. find t-junctions
  var vertBounds = boundPoints(points)
  var tjunctions = getTJunctions(points, edges, edgeBounds, vertBounds)

  // 3. cut edges, construct rational points
  var ratPoints = cutEdges(points, edges, crossings, tjunctions, useColor)

  // 4. dedupe verts
  var labels = dedupPoints(points, ratPoints, vertBounds)

  // 5. dedupe edges
  dedupEdges(edges, labels, useColor)

  // 6. check termination
  if (!labels) {
    return (crossings.length > 0 || tjunctions.length > 0)
  }

  // More iterations necessary
  return true
}

// Main loop, runs PSLG clean up until completion
function cleanPSLG (points, edges, colors) {
  // If using colors, augment edges with color data
  var prevEdges
  if (colors) {
    prevEdges = edges
    var augEdges = new Array(edges.length)
    for (var i = 0; i < edges.length; ++i) {
      var e = edges[i]
      augEdges[i] = [e[0], e[1], colors[i]]
    }
    edges = augEdges
  }

  // First round: remove duplicate edges and points
  var modified = preRound(points, edges, !!colors)

  // Run snap rounding until convergence
  while (snapRound(points, edges, !!colors)) {
    modified = true
  }

  // Strip color tags
  if (!!colors && modified) {
    prevEdges.length = 0
    colors.length = 0
    for (var i = 0; i < edges.length; ++i) {
      var e = edges[i]
      prevEdges.push([e[0], e[1]])
      colors.push(e[2])
    }
  }

  return modified
}

},{"./lib/rat-seg-intersect":37,"big-rat":5,"big-rat/cmp":3,"big-rat/to-float":18,"box-intersect":21,"nextafter":87,"rat-vec":99,"robust-segment-intersect":108,"union-find":181}],37:[function(require,module,exports){
'use strict'

module.exports = solveIntersection

var ratMul = require('big-rat/mul')
var ratDiv = require('big-rat/div')
var ratSub = require('big-rat/sub')
var ratSign = require('big-rat/sign')
var rvSub = require('rat-vec/sub')
var rvAdd = require('rat-vec/add')
var rvMuls = require('rat-vec/muls')

function ratPerp (a, b) {
  return ratSub(ratMul(a[0], b[1]), ratMul(a[1], b[0]))
}

// Solve for intersection
//  x = a + t (b-a)
//  (x - c) ^ (d-c) = 0
//  (t * (b-a) + (a-c) ) ^ (d-c) = 0
//  t * (b-a)^(d-c) = (d-c)^(a-c)
//  t = (d-c)^(a-c) / (b-a)^(d-c)

function solveIntersection (a, b, c, d) {
  var ba = rvSub(b, a)
  var dc = rvSub(d, c)

  var baXdc = ratPerp(ba, dc)

  if (ratSign(baXdc) === 0) {
    return null
  }

  var ac = rvSub(a, c)
  var dcXac = ratPerp(dc, ac)

  var t = ratDiv(dcXac, baXdc)
  var s = rvMuls(ba, t)
  var r = rvAdd(a, s)

  return r
}

},{"big-rat/div":4,"big-rat/mul":14,"big-rat/sign":16,"big-rat/sub":17,"rat-vec/add":98,"rat-vec/muls":100,"rat-vec/sub":101}],38:[function(require,module,exports){
"use strict"

module.exports = compareAngle

var orient = require("robust-orientation")
var sgn = require("signum")
var twoSum = require("two-sum")
var robustProduct = require("robust-product")
var robustSum = require("robust-sum")

function testInterior(a, b, c) {
  var x0 = twoSum(a[0], -b[0])
  var y0 = twoSum(a[1], -b[1])
  var x1 = twoSum(c[0], -b[0])
  var y1 = twoSum(c[1], -b[1])

  var d = robustSum(
    robustProduct(x0, x1),
    robustProduct(y0, y1))

  return d[d.length-1] >= 0
}

function compareAngle(a, b, c, d) {
  var bcd = orient(b, c, d)
  if(bcd === 0) {
    //Handle degenerate cases
    var sabc = sgn(orient(a, b, c))
    var sabd = sgn(orient(a, b, d))
    if(sabc === sabd) {
      if(sabc === 0) {
        var ic = testInterior(a, b, c)
        var id = testInterior(a, b, d)
        if(ic === id) {
          return 0
        } else if(ic) {
          return 1
        } else {
          return -1
        }
      }
      return 0
    } else if(sabd === 0) {
      if(sabc > 0) {
        return -1
      } else if(testInterior(a, b, d)) {
        return -1
      } else {
        return 1
      }
    } else if(sabc === 0) {
      if(sabd > 0) {
        return 1
      } else if(testInterior(a, b, c)) {
        return 1
      } else {
        return -1
      }
    }
    return sgn(sabd - sabc)
  }
  var abc = orient(a, b, c)
  if(abc > 0) {
    if(bcd > 0 && orient(a, b, d) > 0) {
      return 1
    }
    return -1
  } else if(abc < 0) {
    if(bcd > 0 || orient(a, b, d) > 0) {
      return 1
    }
    return -1
  } else {
    var abd = orient(a, b, d)
    if(abd > 0) {
      return 1
    } else {
      if(testInterior(a, b, c)) {
        return 1
      } else {
        return -1
      }
    }
  }
}
},{"robust-orientation":105,"robust-product":106,"robust-sum":110,"signum":111,"two-sum":179}],39:[function(require,module,exports){
"use strict"

var createThunk = require("./lib/thunk.js")

function Procedure() {
  this.argTypes = []
  this.shimArgs = []
  this.arrayArgs = []
  this.arrayBlockIndices = []
  this.scalarArgs = []
  this.offsetArgs = []
  this.offsetArgIndex = []
  this.indexArgs = []
  this.shapeArgs = []
  this.funcName = ""
  this.pre = null
  this.body = null
  this.post = null
  this.debug = false
}

function compileCwise(user_args) {
  //Create procedure
  var proc = new Procedure()
  
  //Parse blocks
  proc.pre    = user_args.pre
  proc.body   = user_args.body
  proc.post   = user_args.post

  //Parse arguments
  var proc_args = user_args.args.slice(0)
  proc.argTypes = proc_args
  for(var i=0; i<proc_args.length; ++i) {
    var arg_type = proc_args[i]
    if(arg_type === "array" || (typeof arg_type === "object" && arg_type.blockIndices)) {
      proc.argTypes[i] = "array"
      proc.arrayArgs.push(i)
      proc.arrayBlockIndices.push(arg_type.blockIndices ? arg_type.blockIndices : 0)
      proc.shimArgs.push("array" + i)
      if(i < proc.pre.args.length && proc.pre.args[i].count>0) {
        throw new Error("cwise: pre() block may not reference array args")
      }
      if(i < proc.post.args.length && proc.post.args[i].count>0) {
        throw new Error("cwise: post() block may not reference array args")
      }
    } else if(arg_type === "scalar") {
      proc.scalarArgs.push(i)
      proc.shimArgs.push("scalar" + i)
    } else if(arg_type === "index") {
      proc.indexArgs.push(i)
      if(i < proc.pre.args.length && proc.pre.args[i].count > 0) {
        throw new Error("cwise: pre() block may not reference array index")
      }
      if(i < proc.body.args.length && proc.body.args[i].lvalue) {
        throw new Error("cwise: body() block may not write to array index")
      }
      if(i < proc.post.args.length && proc.post.args[i].count > 0) {
        throw new Error("cwise: post() block may not reference array index")
      }
    } else if(arg_type === "shape") {
      proc.shapeArgs.push(i)
      if(i < proc.pre.args.length && proc.pre.args[i].lvalue) {
        throw new Error("cwise: pre() block may not write to array shape")
      }
      if(i < proc.body.args.length && proc.body.args[i].lvalue) {
        throw new Error("cwise: body() block may not write to array shape")
      }
      if(i < proc.post.args.length && proc.post.args[i].lvalue) {
        throw new Error("cwise: post() block may not write to array shape")
      }
    } else if(typeof arg_type === "object" && arg_type.offset) {
      proc.argTypes[i] = "offset"
      proc.offsetArgs.push({ array: arg_type.array, offset:arg_type.offset })
      proc.offsetArgIndex.push(i)
    } else {
      throw new Error("cwise: Unknown argument type " + proc_args[i])
    }
  }
  
  //Make sure at least one array argument was specified
  if(proc.arrayArgs.length <= 0) {
    throw new Error("cwise: No array arguments specified")
  }
  
  //Make sure arguments are correct
  if(proc.pre.args.length > proc_args.length) {
    throw new Error("cwise: Too many arguments in pre() block")
  }
  if(proc.body.args.length > proc_args.length) {
    throw new Error("cwise: Too many arguments in body() block")
  }
  if(proc.post.args.length > proc_args.length) {
    throw new Error("cwise: Too many arguments in post() block")
  }

  //Check debug flag
  proc.debug = !!user_args.printCode || !!user_args.debug
  
  //Retrieve name
  proc.funcName = user_args.funcName || "cwise"
  
  //Read in block size
  proc.blockSize = user_args.blockSize || 64

  return createThunk(proc)
}

module.exports = compileCwise

},{"./lib/thunk.js":41}],40:[function(require,module,exports){
"use strict"

var uniq = require("uniq")

// This function generates very simple loops analogous to how you typically traverse arrays (the outermost loop corresponds to the slowest changing index, the innermost loop to the fastest changing index)
// TODO: If two arrays have the same strides (and offsets) there is potential for decreasing the number of "pointers" and related variables. The drawback is that the type signature would become more specific and that there would thus be less potential for caching, but it might still be worth it, especially when dealing with large numbers of arguments.
function innerFill(order, proc, body) {
  var dimension = order.length
    , nargs = proc.arrayArgs.length
    , has_index = proc.indexArgs.length>0
    , code = []
    , vars = []
    , idx=0, pidx=0, i, j
  for(i=0; i<dimension; ++i) { // Iteration variables
    vars.push(["i",i,"=0"].join(""))
  }
  //Compute scan deltas
  for(j=0; j<nargs; ++j) {
    for(i=0; i<dimension; ++i) {
      pidx = idx
      idx = order[i]
      if(i === 0) { // The innermost/fastest dimension's delta is simply its stride
        vars.push(["d",j,"s",i,"=t",j,"p",idx].join(""))
      } else { // For other dimensions the delta is basically the stride minus something which essentially "rewinds" the previous (more inner) dimension
        vars.push(["d",j,"s",i,"=(t",j,"p",idx,"-s",pidx,"*t",j,"p",pidx,")"].join(""))
      }
    }
  }
  if (vars.length > 0) {
    code.push("var " + vars.join(","))
  }  
  //Scan loop
  for(i=dimension-1; i>=0; --i) { // Start at largest stride and work your way inwards
    idx = order[i]
    code.push(["for(i",i,"=0;i",i,"<s",idx,";++i",i,"){"].join(""))
  }
  //Push body of inner loop
  code.push(body)
  //Advance scan pointers
  for(i=0; i<dimension; ++i) {
    pidx = idx
    idx = order[i]
    for(j=0; j<nargs; ++j) {
      code.push(["p",j,"+=d",j,"s",i].join(""))
    }
    if(has_index) {
      if(i > 0) {
        code.push(["index[",pidx,"]-=s",pidx].join(""))
      }
      code.push(["++index[",idx,"]"].join(""))
    }
    code.push("}")
  }
  return code.join("\n")
}

// Generate "outer" loops that loop over blocks of data, applying "inner" loops to the blocks by manipulating the local variables in such a way that the inner loop only "sees" the current block.
// TODO: If this is used, then the previous declaration (done by generateCwiseOp) of s* is essentially unnecessary.
//       I believe the s* are not used elsewhere (in particular, I don't think they're used in the pre/post parts and "shape" is defined independently), so it would be possible to make defining the s* dependent on what loop method is being used.
function outerFill(matched, order, proc, body) {
  var dimension = order.length
    , nargs = proc.arrayArgs.length
    , blockSize = proc.blockSize
    , has_index = proc.indexArgs.length > 0
    , code = []
  for(var i=0; i<nargs; ++i) {
    code.push(["var offset",i,"=p",i].join(""))
  }
  //Generate loops for unmatched dimensions
  // The order in which these dimensions are traversed is fairly arbitrary (from small stride to large stride, for the first argument)
  // TODO: It would be nice if the order in which these loops are placed would also be somehow "optimal" (at the very least we should check that it really doesn't hurt us if they're not).
  for(var i=matched; i<dimension; ++i) {
    code.push(["for(var j"+i+"=SS[", order[i], "]|0;j", i, ">0;){"].join("")) // Iterate back to front
    code.push(["if(j",i,"<",blockSize,"){"].join("")) // Either decrease j by blockSize (s = blockSize), or set it to zero (after setting s = j).
    code.push(["s",order[i],"=j",i].join(""))
    code.push(["j",i,"=0"].join(""))
    code.push(["}else{s",order[i],"=",blockSize].join(""))
    code.push(["j",i,"-=",blockSize,"}"].join(""))
    if(has_index) {
      code.push(["index[",order[i],"]=j",i].join(""))
    }
  }
  for(var i=0; i<nargs; ++i) {
    var indexStr = ["offset"+i]
    for(var j=matched; j<dimension; ++j) {
      indexStr.push(["j",j,"*t",i,"p",order[j]].join(""))
    }
    code.push(["p",i,"=(",indexStr.join("+"),")"].join(""))
  }
  code.push(innerFill(order, proc, body))
  for(var i=matched; i<dimension; ++i) {
    code.push("}")
  }
  return code.join("\n")
}

//Count the number of compatible inner orders
// This is the length of the longest common prefix of the arrays in orders.
// Each array in orders lists the dimensions of the correspond ndarray in order of increasing stride.
// This is thus the maximum number of dimensions that can be efficiently traversed by simple nested loops for all arrays.
function countMatches(orders) {
  var matched = 0, dimension = orders[0].length
  while(matched < dimension) {
    for(var j=1; j<orders.length; ++j) {
      if(orders[j][matched] !== orders[0][matched]) {
        return matched
      }
    }
    ++matched
  }
  return matched
}

//Processes a block according to the given data types
// Replaces variable names by different ones, either "local" ones (that are then ferried in and out of the given array) or ones matching the arguments that the function performing the ultimate loop will accept.
function processBlock(block, proc, dtypes) {
  var code = block.body
  var pre = []
  var post = []
  for(var i=0; i<block.args.length; ++i) {
    var carg = block.args[i]
    if(carg.count <= 0) {
      continue
    }
    var re = new RegExp(carg.name, "g")
    var ptrStr = ""
    var arrNum = proc.arrayArgs.indexOf(i)
    switch(proc.argTypes[i]) {
      case "offset":
        var offArgIndex = proc.offsetArgIndex.indexOf(i)
        var offArg = proc.offsetArgs[offArgIndex]
        arrNum = offArg.array
        ptrStr = "+q" + offArgIndex // Adds offset to the "pointer" in the array
      case "array":
        ptrStr = "p" + arrNum + ptrStr
        var localStr = "l" + i
        var arrStr = "a" + arrNum
        if (proc.arrayBlockIndices[arrNum] === 0) { // Argument to body is just a single value from this array
          if(carg.count === 1) { // Argument/array used only once(?)
            if(dtypes[arrNum] === "generic") {
              if(carg.lvalue) {
                pre.push(["var ", localStr, "=", arrStr, ".get(", ptrStr, ")"].join("")) // Is this necessary if the argument is ONLY used as an lvalue? (keep in mind that we can have a += something, so we would actually need to check carg.rvalue)
                code = code.replace(re, localStr)
                post.push([arrStr, ".set(", ptrStr, ",", localStr,")"].join(""))
              } else {
                code = code.replace(re, [arrStr, ".get(", ptrStr, ")"].join(""))
              }
            } else {
              code = code.replace(re, [arrStr, "[", ptrStr, "]"].join(""))
            }
          } else if(dtypes[arrNum] === "generic") {
            pre.push(["var ", localStr, "=", arrStr, ".get(", ptrStr, ")"].join("")) // TODO: Could we optimize by checking for carg.rvalue?
            code = code.replace(re, localStr)
            if(carg.lvalue) {
              post.push([arrStr, ".set(", ptrStr, ",", localStr,")"].join(""))
            }
          } else {
            pre.push(["var ", localStr, "=", arrStr, "[", ptrStr, "]"].join("")) // TODO: Could we optimize by checking for carg.rvalue?
            code = code.replace(re, localStr)
            if(carg.lvalue) {
              post.push([arrStr, "[", ptrStr, "]=", localStr].join(""))
            }
          }
        } else { // Argument to body is a "block"
          var reStrArr = [carg.name], ptrStrArr = [ptrStr]
          for(var j=0; j<Math.abs(proc.arrayBlockIndices[arrNum]); j++) {
            reStrArr.push("\\s*\\[([^\\]]+)\\]")
            ptrStrArr.push("$" + (j+1) + "*t" + arrNum + "b" + j) // Matched index times stride
          }
          re = new RegExp(reStrArr.join(""), "g")
          ptrStr = ptrStrArr.join("+")
          if(dtypes[arrNum] === "generic") {
            /*if(carg.lvalue) {
              pre.push(["var ", localStr, "=", arrStr, ".get(", ptrStr, ")"].join("")) // Is this necessary if the argument is ONLY used as an lvalue? (keep in mind that we can have a += something, so we would actually need to check carg.rvalue)
              code = code.replace(re, localStr)
              post.push([arrStr, ".set(", ptrStr, ",", localStr,")"].join(""))
            } else {
              code = code.replace(re, [arrStr, ".get(", ptrStr, ")"].join(""))
            }*/
            throw new Error("cwise: Generic arrays not supported in combination with blocks!")
          } else {
            // This does not produce any local variables, even if variables are used multiple times. It would be possible to do so, but it would complicate things quite a bit.
            code = code.replace(re, [arrStr, "[", ptrStr, "]"].join(""))
          }
        }
      break
      case "scalar":
        code = code.replace(re, "Y" + proc.scalarArgs.indexOf(i))
      break
      case "index":
        code = code.replace(re, "index")
      break
      case "shape":
        code = code.replace(re, "shape")
      break
    }
  }
  return [pre.join("\n"), code, post.join("\n")].join("\n").trim()
}

function typeSummary(dtypes) {
  var summary = new Array(dtypes.length)
  var allEqual = true
  for(var i=0; i<dtypes.length; ++i) {
    var t = dtypes[i]
    var digits = t.match(/\d+/)
    if(!digits) {
      digits = ""
    } else {
      digits = digits[0]
    }
    if(t.charAt(0) === 0) {
      summary[i] = "u" + t.charAt(1) + digits
    } else {
      summary[i] = t.charAt(0) + digits
    }
    if(i > 0) {
      allEqual = allEqual && summary[i] === summary[i-1]
    }
  }
  if(allEqual) {
    return summary[0]
  }
  return summary.join("")
}

//Generates a cwise operator
function generateCWiseOp(proc, typesig) {

  //Compute dimension
  // Arrays get put first in typesig, and there are two entries per array (dtype and order), so this gets the number of dimensions in the first array arg.
  var dimension = (typesig[1].length - Math.abs(proc.arrayBlockIndices[0]))|0
  var orders = new Array(proc.arrayArgs.length)
  var dtypes = new Array(proc.arrayArgs.length)
  for(var i=0; i<proc.arrayArgs.length; ++i) {
    dtypes[i] = typesig[2*i]
    orders[i] = typesig[2*i+1]
  }
  
  //Determine where block and loop indices start and end
  var blockBegin = [], blockEnd = [] // These indices are exposed as blocks
  var loopBegin = [], loopEnd = [] // These indices are iterated over
  var loopOrders = [] // orders restricted to the loop indices
  for(var i=0; i<proc.arrayArgs.length; ++i) {
    if (proc.arrayBlockIndices[i]<0) {
      loopBegin.push(0)
      loopEnd.push(dimension)
      blockBegin.push(dimension)
      blockEnd.push(dimension+proc.arrayBlockIndices[i])
    } else {
      loopBegin.push(proc.arrayBlockIndices[i]) // Non-negative
      loopEnd.push(proc.arrayBlockIndices[i]+dimension)
      blockBegin.push(0)
      blockEnd.push(proc.arrayBlockIndices[i])
    }
    var newOrder = []
    for(var j=0; j<orders[i].length; j++) {
      if (loopBegin[i]<=orders[i][j] && orders[i][j]<loopEnd[i]) {
        newOrder.push(orders[i][j]-loopBegin[i]) // If this is a loop index, put it in newOrder, subtracting loopBegin, to make sure that all loopOrders are using a common set of indices.
      }
    }
    loopOrders.push(newOrder)
  }

  //First create arguments for procedure
  var arglist = ["SS"] // SS is the overall shape over which we iterate
  var code = ["'use strict'"]
  var vars = []
  
  for(var j=0; j<dimension; ++j) {
    vars.push(["s", j, "=SS[", j, "]"].join("")) // The limits for each dimension.
  }
  for(var i=0; i<proc.arrayArgs.length; ++i) {
    arglist.push("a"+i) // Actual data array
    arglist.push("t"+i) // Strides
    arglist.push("p"+i) // Offset in the array at which the data starts (also used for iterating over the data)
    
    for(var j=0; j<dimension; ++j) { // Unpack the strides into vars for looping
      vars.push(["t",i,"p",j,"=t",i,"[",loopBegin[i]+j,"]"].join(""))
    }
    
    for(var j=0; j<Math.abs(proc.arrayBlockIndices[i]); ++j) { // Unpack the strides into vars for block iteration
      vars.push(["t",i,"b",j,"=t",i,"[",blockBegin[i]+j,"]"].join(""))
    }
  }
  for(var i=0; i<proc.scalarArgs.length; ++i) {
    arglist.push("Y" + i)
  }
  if(proc.shapeArgs.length > 0) {
    vars.push("shape=SS.slice(0)") // Makes the shape over which we iterate available to the user defined functions (so you can use width/height for example)
  }
  if(proc.indexArgs.length > 0) {
    // Prepare an array to keep track of the (logical) indices, initialized to dimension zeroes.
    var zeros = new Array(dimension)
    for(var i=0; i<dimension; ++i) {
      zeros[i] = "0"
    }
    vars.push(["index=[", zeros.join(","), "]"].join(""))
  }
  for(var i=0; i<proc.offsetArgs.length; ++i) { // Offset arguments used for stencil operations
    var off_arg = proc.offsetArgs[i]
    var init_string = []
    for(var j=0; j<off_arg.offset.length; ++j) {
      if(off_arg.offset[j] === 0) {
        continue
      } else if(off_arg.offset[j] === 1) {
        init_string.push(["t", off_arg.array, "p", j].join(""))      
      } else {
        init_string.push([off_arg.offset[j], "*t", off_arg.array, "p", j].join(""))
      }
    }
    if(init_string.length === 0) {
      vars.push("q" + i + "=0")
    } else {
      vars.push(["q", i, "=", init_string.join("+")].join(""))
    }
  }

  //Prepare this variables
  var thisVars = uniq([].concat(proc.pre.thisVars)
                      .concat(proc.body.thisVars)
                      .concat(proc.post.thisVars))
  vars = vars.concat(thisVars)
  if (vars.length > 0) {
    code.push("var " + vars.join(","))
  }
  for(var i=0; i<proc.arrayArgs.length; ++i) {
    code.push("p"+i+"|=0")
  }
  
  //Inline prelude
  if(proc.pre.body.length > 3) {
    code.push(processBlock(proc.pre, proc, dtypes))
  }

  //Process body
  var body = processBlock(proc.body, proc, dtypes)
  var matched = countMatches(loopOrders)
  if(matched < dimension) {
    code.push(outerFill(matched, loopOrders[0], proc, body)) // TODO: Rather than passing loopOrders[0], it might be interesting to look at passing an order that represents the majority of the arguments for example.
  } else {
    code.push(innerFill(loopOrders[0], proc, body))
  }

  //Inline epilog
  if(proc.post.body.length > 3) {
    code.push(processBlock(proc.post, proc, dtypes))
  }
  
  if(proc.debug) {
    console.log("-----Generated cwise routine for ", typesig, ":\n" + code.join("\n") + "\n----------")
  }
  
  var loopName = [(proc.funcName||"unnamed"), "_cwise_loop_", orders[0].join("s"),"m",matched,typeSummary(dtypes)].join("")
  var f = new Function(["function ",loopName,"(", arglist.join(","),"){", code.join("\n"),"} return ", loopName].join(""))
  return f()
}
module.exports = generateCWiseOp

},{"uniq":182}],41:[function(require,module,exports){
"use strict"

// The function below is called when constructing a cwise function object, and does the following:
// A function object is constructed which accepts as argument a compilation function and returns another function.
// It is this other function that is eventually returned by createThunk, and this function is the one that actually
// checks whether a certain pattern of arguments has already been used before and compiles new loops as needed.
// The compilation passed to the first function object is used for compiling new functions.
// Once this function object is created, it is called with compile as argument, where the first argument of compile
// is bound to "proc" (essentially containing a preprocessed version of the user arguments to cwise).
// So createThunk roughly works like this:
// function createThunk(proc) {
//   var thunk = function(compileBound) {
//     var CACHED = {}
//     return function(arrays and scalars) {
//       if (dtype and order of arrays in CACHED) {
//         var func = CACHED[dtype and order of arrays]
//       } else {
//         var func = CACHED[dtype and order of arrays] = compileBound(dtype and order of arrays)
//       }
//       return func(arrays and scalars)
//     }
//   }
//   return thunk(compile.bind1(proc))
// }

var compile = require("./compile.js")

function createThunk(proc) {
  var code = ["'use strict'", "var CACHED={}"]
  var vars = []
  var thunkName = proc.funcName + "_cwise_thunk"
  
  //Build thunk
  code.push(["return function ", thunkName, "(", proc.shimArgs.join(","), "){"].join(""))
  var typesig = []
  var string_typesig = []
  var proc_args = [["array",proc.arrayArgs[0],".shape.slice(", // Slice shape so that we only retain the shape over which we iterate (which gets passed to the cwise operator as SS).
                    Math.max(0,proc.arrayBlockIndices[0]),proc.arrayBlockIndices[0]<0?(","+proc.arrayBlockIndices[0]+")"):")"].join("")]
  var shapeLengthConditions = [], shapeConditions = []
  // Process array arguments
  for(var i=0; i<proc.arrayArgs.length; ++i) {
    var j = proc.arrayArgs[i]
    vars.push(["t", j, "=array", j, ".dtype,",
               "r", j, "=array", j, ".order"].join(""))
    typesig.push("t" + j)
    typesig.push("r" + j)
    string_typesig.push("t"+j)
    string_typesig.push("r"+j+".join()")
    proc_args.push("array" + j + ".data")
    proc_args.push("array" + j + ".stride")
    proc_args.push("array" + j + ".offset|0")
    if (i>0) { // Gather conditions to check for shape equality (ignoring block indices)
      shapeLengthConditions.push("array" + proc.arrayArgs[0] + ".shape.length===array" + j + ".shape.length+" + (Math.abs(proc.arrayBlockIndices[0])-Math.abs(proc.arrayBlockIndices[i])))
      shapeConditions.push("array" + proc.arrayArgs[0] + ".shape[shapeIndex+" + Math.max(0,proc.arrayBlockIndices[0]) + "]===array" + j + ".shape[shapeIndex+" + Math.max(0,proc.arrayBlockIndices[i]) + "]")
    }
  }
  // Check for shape equality
  if (proc.arrayArgs.length > 1) {
    code.push("if (!(" + shapeLengthConditions.join(" && ") + ")) throw new Error('cwise: Arrays do not all have the same dimensionality!')")
    code.push("for(var shapeIndex=array" + proc.arrayArgs[0] + ".shape.length-" + Math.abs(proc.arrayBlockIndices[0]) + "; shapeIndex-->0;) {")
    code.push("if (!(" + shapeConditions.join(" && ") + ")) throw new Error('cwise: Arrays do not all have the same shape!')")
    code.push("}")
  }
  // Process scalar arguments
  for(var i=0; i<proc.scalarArgs.length; ++i) {
    proc_args.push("scalar" + proc.scalarArgs[i])
  }
  // Check for cached function (and if not present, generate it)
  vars.push(["type=[", string_typesig.join(","), "].join()"].join(""))
  vars.push("proc=CACHED[type]")
  code.push("var " + vars.join(","))
  
  code.push(["if(!proc){",
             "CACHED[type]=proc=compile([", typesig.join(","), "])}",
             "return proc(", proc_args.join(","), ")}"].join(""))

  if(proc.debug) {
    console.log("-----Generated thunk:\n" + code.join("\n") + "\n----------")
  }
  
  //Compile thunk
  var thunk = new Function("compile", code.join("\n"))
  return thunk(compile.bind(undefined, proc))
}

module.exports = createThunk

},{"./compile.js":40}],42:[function(require,module,exports){
(function (Buffer){(function (){
var hasTypedArrays = false
if(typeof Float64Array !== "undefined") {
  var DOUBLE_VIEW = new Float64Array(1)
    , UINT_VIEW   = new Uint32Array(DOUBLE_VIEW.buffer)
  DOUBLE_VIEW[0] = 1.0
  hasTypedArrays = true
  if(UINT_VIEW[1] === 0x3ff00000) {
    //Use little endian
    module.exports = function doubleBitsLE(n) {
      DOUBLE_VIEW[0] = n
      return [ UINT_VIEW[0], UINT_VIEW[1] ]
    }
    function toDoubleLE(lo, hi) {
      UINT_VIEW[0] = lo
      UINT_VIEW[1] = hi
      return DOUBLE_VIEW[0]
    }
    module.exports.pack = toDoubleLE
    function lowUintLE(n) {
      DOUBLE_VIEW[0] = n
      return UINT_VIEW[0]
    }
    module.exports.lo = lowUintLE
    function highUintLE(n) {
      DOUBLE_VIEW[0] = n
      return UINT_VIEW[1]
    }
    module.exports.hi = highUintLE
  } else if(UINT_VIEW[0] === 0x3ff00000) {
    //Use big endian
    module.exports = function doubleBitsBE(n) {
      DOUBLE_VIEW[0] = n
      return [ UINT_VIEW[1], UINT_VIEW[0] ]
    }
    function toDoubleBE(lo, hi) {
      UINT_VIEW[1] = lo
      UINT_VIEW[0] = hi
      return DOUBLE_VIEW[0]
    }
    module.exports.pack = toDoubleBE
    function lowUintBE(n) {
      DOUBLE_VIEW[0] = n
      return UINT_VIEW[1]
    }
    module.exports.lo = lowUintBE
    function highUintBE(n) {
      DOUBLE_VIEW[0] = n
      return UINT_VIEW[0]
    }
    module.exports.hi = highUintBE
  } else {
    hasTypedArrays = false
  }
}
if(!hasTypedArrays) {
  var buffer = new Buffer(8)
  module.exports = function doubleBits(n) {
    buffer.writeDoubleLE(n, 0, true)
    return [ buffer.readUInt32LE(0, true), buffer.readUInt32LE(4, true) ]
  }
  function toDouble(lo, hi) {
    buffer.writeUInt32LE(lo, 0, true)
    buffer.writeUInt32LE(hi, 4, true)
    return buffer.readDoubleLE(0, true)
  }
  module.exports.pack = toDouble  
  function lowUint(n) {
    buffer.writeDoubleLE(n, 0, true)
    return buffer.readUInt32LE(0, true)
  }
  module.exports.lo = lowUint
  function highUint(n) {
    buffer.writeDoubleLE(n, 0, true)
    return buffer.readUInt32LE(4, true)
  }
  module.exports.hi = highUint
}

module.exports.sign = function(n) {
  return module.exports.hi(n) >>> 31
}

module.exports.exponent = function(n) {
  var b = module.exports.hi(n)
  return ((b<<1) >>> 21) - 1023
}

module.exports.fraction = function(n) {
  var lo = module.exports.lo(n)
  var hi = module.exports.hi(n)
  var b = hi & ((1<<20) - 1)
  if(hi & 0x7ff00000) {
    b += (1<<20)
  }
  return [lo, b]
}

module.exports.denormalized = function(n) {
  var hi = module.exports.hi(n)
  return !(hi & 0x7ff00000)
}
}).call(this)}).call(this,require("buffer").Buffer)

},{"buffer":30}],43:[function(require,module,exports){
"use strict"

function dupe_array(count, value, i) {
  var c = count[i]|0
  if(c <= 0) {
    return []
  }
  var result = new Array(c), j
  if(i === count.length-1) {
    for(j=0; j<c; ++j) {
      result[j] = value
    }
  } else {
    for(j=0; j<c; ++j) {
      result[j] = dupe_array(count, value, i+1)
    }
  }
  return result
}

function dupe_number(count, value) {
  var result, i
  result = new Array(count)
  for(i=0; i<count; ++i) {
    result[i] = value
  }
  return result
}

function dupe(count, value) {
  if(typeof value === "undefined") {
    value = 0
  }
  switch(typeof count) {
    case "number":
      if(count > 0) {
        return dupe_number(count|0, value)
      }
    break
    case "object":
      if(typeof (count.length) === "number") {
        return dupe_array(count, value, 0)
      }
    break
  }
  return []
}

module.exports = dupe
},{}],44:[function(require,module,exports){
"use strict"

module.exports = edgeToAdjacency

var uniq = require("uniq")

function edgeToAdjacency(edges, numVertices) {
  var numEdges = edges.length
  if(typeof numVertices !== "number") {
    numVertices = 0
    for(var i=0; i<numEdges; ++i) {
      var e = edges[i]
      numVertices = Math.max(numVertices, e[0], e[1])
    }
    numVertices = (numVertices|0) + 1
  }
  numVertices = numVertices|0
  var adj = new Array(numVertices)
  for(var i=0; i<numVertices; ++i) {
    adj[i] = []
  }
  for(var i=0; i<numEdges; ++i) {
    var e = edges[i]
    adj[e[0]].push(e[1])
    adj[e[1]].push(e[0])
  }
  for(var j=0; j<numVertices; ++j) {
    uniq(adj[j], function(a, b) {
      return a - b
    })
  }
  return adj
}
},{"uniq":182}],45:[function(require,module,exports){
"use strict"

module.exports = createRBTree

var RED   = 0
var BLACK = 1

function RBNode(color, key, value, left, right, count) {
  this._color = color
  this.key = key
  this.value = value
  this.left = left
  this.right = right
  this._count = count
}

function cloneNode(node) {
  return new RBNode(node._color, node.key, node.value, node.left, node.right, node._count)
}

function repaint(color, node) {
  return new RBNode(color, node.key, node.value, node.left, node.right, node._count)
}

function recount(node) {
  node._count = 1 + (node.left ? node.left._count : 0) + (node.right ? node.right._count : 0)
}

function RedBlackTree(compare, root) {
  this._compare = compare
  this.root = root
}

var proto = RedBlackTree.prototype

Object.defineProperty(proto, "keys", {
  get: function() {
    var result = []
    this.forEach(function(k,v) {
      result.push(k)
    })
    return result
  }
})

Object.defineProperty(proto, "values", {
  get: function() {
    var result = []
    this.forEach(function(k,v) {
      result.push(v)
    })
    return result
  }
})

//Returns the number of nodes in the tree
Object.defineProperty(proto, "length", {
  get: function() {
    if(this.root) {
      return this.root._count
    }
    return 0
  }
})

//Insert a new item into the tree
proto.insert = function(key, value) {
  var cmp = this._compare
  //Find point to insert new node at
  var n = this.root
  var n_stack = []
  var d_stack = []
  while(n) {
    var d = cmp(key, n.key)
    n_stack.push(n)
    d_stack.push(d)
    if(d <= 0) {
      n = n.left
    } else {
      n = n.right
    }
  }
  //Rebuild path to leaf node
  n_stack.push(new RBNode(RED, key, value, null, null, 1))
  for(var s=n_stack.length-2; s>=0; --s) {
    var n = n_stack[s]
    if(d_stack[s] <= 0) {
      n_stack[s] = new RBNode(n._color, n.key, n.value, n_stack[s+1], n.right, n._count+1)
    } else {
      n_stack[s] = new RBNode(n._color, n.key, n.value, n.left, n_stack[s+1], n._count+1)
    }
  }
  //Rebalance tree using rotations
  //console.log("start insert", key, d_stack)
  for(var s=n_stack.length-1; s>1; --s) {
    var p = n_stack[s-1]
    var n = n_stack[s]
    if(p._color === BLACK || n._color === BLACK) {
      break
    }
    var pp = n_stack[s-2]
    if(pp.left === p) {
      if(p.left === n) {
        var y = pp.right
        if(y && y._color === RED) {
          //console.log("LLr")
          p._color = BLACK
          pp.right = repaint(BLACK, y)
          pp._color = RED
          s -= 1
        } else {
          //console.log("LLb")
          pp._color = RED
          pp.left = p.right
          p._color = BLACK
          p.right = pp
          n_stack[s-2] = p
          n_stack[s-1] = n
          recount(pp)
          recount(p)
          if(s >= 3) {
            var ppp = n_stack[s-3]
            if(ppp.left === pp) {
              ppp.left = p
            } else {
              ppp.right = p
            }
          }
          break
        }
      } else {
        var y = pp.right
        if(y && y._color === RED) {
          //console.log("LRr")
          p._color = BLACK
          pp.right = repaint(BLACK, y)
          pp._color = RED
          s -= 1
        } else {
          //console.log("LRb")
          p.right = n.left
          pp._color = RED
          pp.left = n.right
          n._color = BLACK
          n.left = p
          n.right = pp
          n_stack[s-2] = n
          n_stack[s-1] = p
          recount(pp)
          recount(p)
          recount(n)
          if(s >= 3) {
            var ppp = n_stack[s-3]
            if(ppp.left === pp) {
              ppp.left = n
            } else {
              ppp.right = n
            }
          }
          break
        }
      }
    } else {
      if(p.right === n) {
        var y = pp.left
        if(y && y._color === RED) {
          //console.log("RRr", y.key)
          p._color = BLACK
          pp.left = repaint(BLACK, y)
          pp._color = RED
          s -= 1
        } else {
          //console.log("RRb")
          pp._color = RED
          pp.right = p.left
          p._color = BLACK
          p.left = pp
          n_stack[s-2] = p
          n_stack[s-1] = n
          recount(pp)
          recount(p)
          if(s >= 3) {
            var ppp = n_stack[s-3]
            if(ppp.right === pp) {
              ppp.right = p
            } else {
              ppp.left = p
            }
          }
          break
        }
      } else {
        var y = pp.left
        if(y && y._color === RED) {
          //console.log("RLr")
          p._color = BLACK
          pp.left = repaint(BLACK, y)
          pp._color = RED
          s -= 1
        } else {
          //console.log("RLb")
          p.left = n.right
          pp._color = RED
          pp.right = n.left
          n._color = BLACK
          n.right = p
          n.left = pp
          n_stack[s-2] = n
          n_stack[s-1] = p
          recount(pp)
          recount(p)
          recount(n)
          if(s >= 3) {
            var ppp = n_stack[s-3]
            if(ppp.right === pp) {
              ppp.right = n
            } else {
              ppp.left = n
            }
          }
          break
        }
      }
    }
  }
  //Return new tree
  n_stack[0]._color = BLACK
  return new RedBlackTree(cmp, n_stack[0])
}


//Visit all nodes inorder
function doVisitFull(visit, node) {
  if(node.left) {
    var v = doVisitFull(visit, node.left)
    if(v) { return v }
  }
  var v = visit(node.key, node.value)
  if(v) { return v }
  if(node.right) {
    return doVisitFull(visit, node.right)
  }
}

//Visit half nodes in order
function doVisitHalf(lo, compare, visit, node) {
  var l = compare(lo, node.key)
  if(l <= 0) {
    if(node.left) {
      var v = doVisitHalf(lo, compare, visit, node.left)
      if(v) { return v }
    }
    var v = visit(node.key, node.value)
    if(v) { return v }
  }
  if(node.right) {
    return doVisitHalf(lo, compare, visit, node.right)
  }
}

//Visit all nodes within a range
function doVisit(lo, hi, compare, visit, node) {
  var l = compare(lo, node.key)
  var h = compare(hi, node.key)
  var v
  if(l <= 0) {
    if(node.left) {
      v = doVisit(lo, hi, compare, visit, node.left)
      if(v) { return v }
    }
    if(h > 0) {
      v = visit(node.key, node.value)
      if(v) { return v }
    }
  }
  if(h > 0 && node.right) {
    return doVisit(lo, hi, compare, visit, node.right)
  }
}


proto.forEach = function rbTreeForEach(visit, lo, hi) {
  if(!this.root) {
    return
  }
  switch(arguments.length) {
    case 1:
      return doVisitFull(visit, this.root)
    break

    case 2:
      return doVisitHalf(lo, this._compare, visit, this.root)
    break

    case 3:
      if(this._compare(lo, hi) >= 0) {
        return
      }
      return doVisit(lo, hi, this._compare, visit, this.root)
    break
  }
}

//First item in list
Object.defineProperty(proto, "begin", {
  get: function() {
    var stack = []
    var n = this.root
    while(n) {
      stack.push(n)
      n = n.left
    }
    return new RedBlackTreeIterator(this, stack)
  }
})

//Last item in list
Object.defineProperty(proto, "end", {
  get: function() {
    var stack = []
    var n = this.root
    while(n) {
      stack.push(n)
      n = n.right
    }
    return new RedBlackTreeIterator(this, stack)
  }
})

//Find the ith item in the tree
proto.at = function(idx) {
  if(idx < 0) {
    return new RedBlackTreeIterator(this, [])
  }
  var n = this.root
  var stack = []
  while(true) {
    stack.push(n)
    if(n.left) {
      if(idx < n.left._count) {
        n = n.left
        continue
      }
      idx -= n.left._count
    }
    if(!idx) {
      return new RedBlackTreeIterator(this, stack)
    }
    idx -= 1
    if(n.right) {
      if(idx >= n.right._count) {
        break
      }
      n = n.right
    } else {
      break
    }
  }
  return new RedBlackTreeIterator(this, [])
}

proto.ge = function(key) {
  var cmp = this._compare
  var n = this.root
  var stack = []
  var last_ptr = 0
  while(n) {
    var d = cmp(key, n.key)
    stack.push(n)
    if(d <= 0) {
      last_ptr = stack.length
    }
    if(d <= 0) {
      n = n.left
    } else {
      n = n.right
    }
  }
  stack.length = last_ptr
  return new RedBlackTreeIterator(this, stack)
}

proto.gt = function(key) {
  var cmp = this._compare
  var n = this.root
  var stack = []
  var last_ptr = 0
  while(n) {
    var d = cmp(key, n.key)
    stack.push(n)
    if(d < 0) {
      last_ptr = stack.length
    }
    if(d < 0) {
      n = n.left
    } else {
      n = n.right
    }
  }
  stack.length = last_ptr
  return new RedBlackTreeIterator(this, stack)
}

proto.lt = function(key) {
  var cmp = this._compare
  var n = this.root
  var stack = []
  var last_ptr = 0
  while(n) {
    var d = cmp(key, n.key)
    stack.push(n)
    if(d > 0) {
      last_ptr = stack.length
    }
    if(d <= 0) {
      n = n.left
    } else {
      n = n.right
    }
  }
  stack.length = last_ptr
  return new RedBlackTreeIterator(this, stack)
}

proto.le = function(key) {
  var cmp = this._compare
  var n = this.root
  var stack = []
  var last_ptr = 0
  while(n) {
    var d = cmp(key, n.key)
    stack.push(n)
    if(d >= 0) {
      last_ptr = stack.length
    }
    if(d < 0) {
      n = n.left
    } else {
      n = n.right
    }
  }
  stack.length = last_ptr
  return new RedBlackTreeIterator(this, stack)
}

//Finds the item with key if it exists
proto.find = function(key) {
  var cmp = this._compare
  var n = this.root
  var stack = []
  while(n) {
    var d = cmp(key, n.key)
    stack.push(n)
    if(d === 0) {
      return new RedBlackTreeIterator(this, stack)
    }
    if(d <= 0) {
      n = n.left
    } else {
      n = n.right
    }
  }
  return new RedBlackTreeIterator(this, [])
}

//Removes item with key from tree
proto.remove = function(key) {
  var iter = this.find(key)
  if(iter) {
    return iter.remove()
  }
  return this
}

//Returns the item at `key`
proto.get = function(key) {
  var cmp = this._compare
  var n = this.root
  while(n) {
    var d = cmp(key, n.key)
    if(d === 0) {
      return n.value
    }
    if(d <= 0) {
      n = n.left
    } else {
      n = n.right
    }
  }
  return
}

//Iterator for red black tree
function RedBlackTreeIterator(tree, stack) {
  this.tree = tree
  this._stack = stack
}

var iproto = RedBlackTreeIterator.prototype

//Test if iterator is valid
Object.defineProperty(iproto, "valid", {
  get: function() {
    return this._stack.length > 0
  }
})

//Node of the iterator
Object.defineProperty(iproto, "node", {
  get: function() {
    if(this._stack.length > 0) {
      return this._stack[this._stack.length-1]
    }
    return null
  },
  enumerable: true
})

//Makes a copy of an iterator
iproto.clone = function() {
  return new RedBlackTreeIterator(this.tree, this._stack.slice())
}

//Swaps two nodes
function swapNode(n, v) {
  n.key = v.key
  n.value = v.value
  n.left = v.left
  n.right = v.right
  n._color = v._color
  n._count = v._count
}

//Fix up a double black node in a tree
function fixDoubleBlack(stack) {
  var n, p, s, z
  for(var i=stack.length-1; i>=0; --i) {
    n = stack[i]
    if(i === 0) {
      n._color = BLACK
      return
    }
    //console.log("visit node:", n.key, i, stack[i].key, stack[i-1].key)
    p = stack[i-1]
    if(p.left === n) {
      //console.log("left child")
      s = p.right
      if(s.right && s.right._color === RED) {
        //console.log("case 1: right sibling child red")
        s = p.right = cloneNode(s)
        z = s.right = cloneNode(s.right)
        p.right = s.left
        s.left = p
        s.right = z
        s._color = p._color
        n._color = BLACK
        p._color = BLACK
        z._color = BLACK
        recount(p)
        recount(s)
        if(i > 1) {
          var pp = stack[i-2]
          if(pp.left === p) {
            pp.left = s
          } else {
            pp.right = s
          }
        }
        stack[i-1] = s
        return
      } else if(s.left && s.left._color === RED) {
        //console.log("case 1: left sibling child red")
        s = p.right = cloneNode(s)
        z = s.left = cloneNode(s.left)
        p.right = z.left
        s.left = z.right
        z.left = p
        z.right = s
        z._color = p._color
        p._color = BLACK
        s._color = BLACK
        n._color = BLACK
        recount(p)
        recount(s)
        recount(z)
        if(i > 1) {
          var pp = stack[i-2]
          if(pp.left === p) {
            pp.left = z
          } else {
            pp.right = z
          }
        }
        stack[i-1] = z
        return
      }
      if(s._color === BLACK) {
        if(p._color === RED) {
          //console.log("case 2: black sibling, red parent", p.right.value)
          p._color = BLACK
          p.right = repaint(RED, s)
          return
        } else {
          //console.log("case 2: black sibling, black parent", p.right.value)
          p.right = repaint(RED, s)
          continue  
        }
      } else {
        //console.log("case 3: red sibling")
        s = cloneNode(s)
        p.right = s.left
        s.left = p
        s._color = p._color
        p._color = RED
        recount(p)
        recount(s)
        if(i > 1) {
          var pp = stack[i-2]
          if(pp.left === p) {
            pp.left = s
          } else {
            pp.right = s
          }
        }
        stack[i-1] = s
        stack[i] = p
        if(i+1 < stack.length) {
          stack[i+1] = n
        } else {
          stack.push(n)
        }
        i = i+2
      }
    } else {
      //console.log("right child")
      s = p.left
      if(s.left && s.left._color === RED) {
        //console.log("case 1: left sibling child red", p.value, p._color)
        s = p.left = cloneNode(s)
        z = s.left = cloneNode(s.left)
        p.left = s.right
        s.right = p
        s.left = z
        s._color = p._color
        n._color = BLACK
        p._color = BLACK
        z._color = BLACK
        recount(p)
        recount(s)
        if(i > 1) {
          var pp = stack[i-2]
          if(pp.right === p) {
            pp.right = s
          } else {
            pp.left = s
          }
        }
        stack[i-1] = s
        return
      } else if(s.right && s.right._color === RED) {
        //console.log("case 1: right sibling child red")
        s = p.left = cloneNode(s)
        z = s.right = cloneNode(s.right)
        p.left = z.right
        s.right = z.left
        z.right = p
        z.left = s
        z._color = p._color
        p._color = BLACK
        s._color = BLACK
        n._color = BLACK
        recount(p)
        recount(s)
        recount(z)
        if(i > 1) {
          var pp = stack[i-2]
          if(pp.right === p) {
            pp.right = z
          } else {
            pp.left = z
          }
        }
        stack[i-1] = z
        return
      }
      if(s._color === BLACK) {
        if(p._color === RED) {
          //console.log("case 2: black sibling, red parent")
          p._color = BLACK
          p.left = repaint(RED, s)
          return
        } else {
          //console.log("case 2: black sibling, black parent")
          p.left = repaint(RED, s)
          continue  
        }
      } else {
        //console.log("case 3: red sibling")
        s = cloneNode(s)
        p.left = s.right
        s.right = p
        s._color = p._color
        p._color = RED
        recount(p)
        recount(s)
        if(i > 1) {
          var pp = stack[i-2]
          if(pp.right === p) {
            pp.right = s
          } else {
            pp.left = s
          }
        }
        stack[i-1] = s
        stack[i] = p
        if(i+1 < stack.length) {
          stack[i+1] = n
        } else {
          stack.push(n)
        }
        i = i+2
      }
    }
  }
}

//Removes item at iterator from tree
iproto.remove = function() {
  var stack = this._stack
  if(stack.length === 0) {
    return this.tree
  }
  //First copy path to node
  var cstack = new Array(stack.length)
  var n = stack[stack.length-1]
  cstack[cstack.length-1] = new RBNode(n._color, n.key, n.value, n.left, n.right, n._count)
  for(var i=stack.length-2; i>=0; --i) {
    var n = stack[i]
    if(n.left === stack[i+1]) {
      cstack[i] = new RBNode(n._color, n.key, n.value, cstack[i+1], n.right, n._count)
    } else {
      cstack[i] = new RBNode(n._color, n.key, n.value, n.left, cstack[i+1], n._count)
    }
  }

  //Get node
  n = cstack[cstack.length-1]
  //console.log("start remove: ", n.value)

  //If not leaf, then swap with previous node
  if(n.left && n.right) {
    //console.log("moving to leaf")

    //First walk to previous leaf
    var split = cstack.length
    n = n.left
    while(n.right) {
      cstack.push(n)
      n = n.right
    }
    //Copy path to leaf
    var v = cstack[split-1]
    cstack.push(new RBNode(n._color, v.key, v.value, n.left, n.right, n._count))
    cstack[split-1].key = n.key
    cstack[split-1].value = n.value

    //Fix up stack
    for(var i=cstack.length-2; i>=split; --i) {
      n = cstack[i]
      cstack[i] = new RBNode(n._color, n.key, n.value, n.left, cstack[i+1], n._count)
    }
    cstack[split-1].left = cstack[split]
  }
  //console.log("stack=", cstack.map(function(v) { return v.value }))

  //Remove leaf node
  n = cstack[cstack.length-1]
  if(n._color === RED) {
    //Easy case: removing red leaf
    //console.log("RED leaf")
    var p = cstack[cstack.length-2]
    if(p.left === n) {
      p.left = null
    } else if(p.right === n) {
      p.right = null
    }
    cstack.pop()
    for(var i=0; i<cstack.length; ++i) {
      cstack[i]._count--
    }
    return new RedBlackTree(this.tree._compare, cstack[0])
  } else {
    if(n.left || n.right) {
      //Second easy case:  Single child black parent
      //console.log("BLACK single child")
      if(n.left) {
        swapNode(n, n.left)
      } else if(n.right) {
        swapNode(n, n.right)
      }
      //Child must be red, so repaint it black to balance color
      n._color = BLACK
      for(var i=0; i<cstack.length-1; ++i) {
        cstack[i]._count--
      }
      return new RedBlackTree(this.tree._compare, cstack[0])
    } else if(cstack.length === 1) {
      //Third easy case: root
      //console.log("ROOT")
      return new RedBlackTree(this.tree._compare, null)
    } else {
      //Hard case: Repaint n, and then do some nasty stuff
      //console.log("BLACK leaf no children")
      for(var i=0; i<cstack.length; ++i) {
        cstack[i]._count--
      }
      var parent = cstack[cstack.length-2]
      fixDoubleBlack(cstack)
      //Fix up links
      if(parent.left === n) {
        parent.left = null
      } else {
        parent.right = null
      }
    }
  }
  return new RedBlackTree(this.tree._compare, cstack[0])
}

//Returns key
Object.defineProperty(iproto, "key", {
  get: function() {
    if(this._stack.length > 0) {
      return this._stack[this._stack.length-1].key
    }
    return
  },
  enumerable: true
})

//Returns value
Object.defineProperty(iproto, "value", {
  get: function() {
    if(this._stack.length > 0) {
      return this._stack[this._stack.length-1].value
    }
    return
  },
  enumerable: true
})


//Returns the position of this iterator in the sorted list
Object.defineProperty(iproto, "index", {
  get: function() {
    var idx = 0
    var stack = this._stack
    if(stack.length === 0) {
      var r = this.tree.root
      if(r) {
        return r._count
      }
      return 0
    } else if(stack[stack.length-1].left) {
      idx = stack[stack.length-1].left._count
    }
    for(var s=stack.length-2; s>=0; --s) {
      if(stack[s+1] === stack[s].right) {
        ++idx
        if(stack[s].left) {
          idx += stack[s].left._count
        }
      }
    }
    return idx
  },
  enumerable: true
})

//Advances iterator to next element in list
iproto.next = function() {
  var stack = this._stack
  if(stack.length === 0) {
    return
  }
  var n = stack[stack.length-1]
  if(n.right) {
    n = n.right
    while(n) {
      stack.push(n)
      n = n.left
    }
  } else {
    stack.pop()
    while(stack.length > 0 && stack[stack.length-1].right === n) {
      n = stack[stack.length-1]
      stack.pop()
    }
  }
}

//Checks if iterator is at end of tree
Object.defineProperty(iproto, "hasNext", {
  get: function() {
    var stack = this._stack
    if(stack.length === 0) {
      return false
    }
    if(stack[stack.length-1].right) {
      return true
    }
    for(var s=stack.length-1; s>0; --s) {
      if(stack[s-1].left === stack[s]) {
        return true
      }
    }
    return false
  }
})

//Update value
iproto.update = function(value) {
  var stack = this._stack
  if(stack.length === 0) {
    throw new Error("Can't update empty node!")
  }
  var cstack = new Array(stack.length)
  var n = stack[stack.length-1]
  cstack[cstack.length-1] = new RBNode(n._color, n.key, value, n.left, n.right, n._count)
  for(var i=stack.length-2; i>=0; --i) {
    n = stack[i]
    if(n.left === stack[i+1]) {
      cstack[i] = new RBNode(n._color, n.key, n.value, cstack[i+1], n.right, n._count)
    } else {
      cstack[i] = new RBNode(n._color, n.key, n.value, n.left, cstack[i+1], n._count)
    }
  }
  return new RedBlackTree(this.tree._compare, cstack[0])
}

//Moves iterator backward one element
iproto.prev = function() {
  var stack = this._stack
  if(stack.length === 0) {
    return
  }
  var n = stack[stack.length-1]
  if(n.left) {
    n = n.left
    while(n) {
      stack.push(n)
      n = n.right
    }
  } else {
    stack.pop()
    while(stack.length > 0 && stack[stack.length-1].left === n) {
      n = stack[stack.length-1]
      stack.pop()
    }
  }
}

//Checks if iterator is at start of tree
Object.defineProperty(iproto, "hasPrev", {
  get: function() {
    var stack = this._stack
    if(stack.length === 0) {
      return false
    }
    if(stack[stack.length-1].left) {
      return true
    }
    for(var s=stack.length-1; s>0; --s) {
      if(stack[s-1].right === stack[s]) {
        return true
      }
    }
    return false
  }
})

//Default comparison function
function defaultCompare(a, b) {
  if(a < b) {
    return -1
  }
  if(a > b) {
    return 1
  }
  return 0
}

//Build a tree
function createRBTree(compare) {
  return new RedBlackTree(compare || defaultCompare, null)
}
},{}],46:[function(require,module,exports){
// transliterated from the python snippet here:
// http://en.wikipedia.org/wiki/Lanczos_approximation

var g = 7;
var p = [
    0.99999999999980993,
    676.5203681218851,
    -1259.1392167224028,
    771.32342877765313,
    -176.61502916214059,
    12.507343278686905,
    -0.13857109526572012,
    9.9843695780195716e-6,
    1.5056327351493116e-7
];

var g_ln = 607/128;
var p_ln = [
    0.99999999999999709182,
    57.156235665862923517,
    -59.597960355475491248,
    14.136097974741747174,
    -0.49191381609762019978,
    0.33994649984811888699e-4,
    0.46523628927048575665e-4,
    -0.98374475304879564677e-4,
    0.15808870322491248884e-3,
    -0.21026444172410488319e-3,
    0.21743961811521264320e-3,
    -0.16431810653676389022e-3,
    0.84418223983852743293e-4,
    -0.26190838401581408670e-4,
    0.36899182659531622704e-5
];

// Spouge approximation (suitable for large arguments)
function lngamma(z) {

    if(z < 0) return Number('0/0');
    var x = p_ln[0];
    for(var i = p_ln.length - 1; i > 0; --i) x += p_ln[i] / (z + i);
    var t = z + g_ln + 0.5;
    return .5*Math.log(2*Math.PI)+(z+.5)*Math.log(t)-t+Math.log(x)-Math.log(z);
}

module.exports = function gamma (z) {
    if (z < 0.5) {
        return Math.PI / (Math.sin(Math.PI * z) * gamma(1 - z));
    }
    else if(z > 100) return Math.exp(lngamma(z));
    else {
        z -= 1;
        var x = p[0];
        for (var i = 1; i < g + 2; i++) {
            x += p[i] / (z + i);
        }
        var t = z + g + 0.5;

        return Math.sqrt(2 * Math.PI)
            * Math.pow(t, z + 0.5)
            * Math.exp(-t)
            * x
        ;
    }
};

module.exports.log = lngamma;

},{}],47:[function(require,module,exports){
module.exports = adjoint;

/**
 * Calculates the adjugate of a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
function adjoint(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

    out[0]  =  (a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22));
    out[1]  = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));
    out[2]  =  (a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12));
    out[3]  = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));
    out[4]  = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));
    out[5]  =  (a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22));
    out[6]  = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));
    out[7]  =  (a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12));
    out[8]  =  (a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21));
    out[9]  = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));
    out[10] =  (a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11));
    out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));
    out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));
    out[13] =  (a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21));
    out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));
    out[15] =  (a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11));
    return out;
};
},{}],48:[function(require,module,exports){
module.exports = clone;

/**
 * Creates a new mat4 initialized with values from an existing matrix
 *
 * @param {mat4} a matrix to clone
 * @returns {mat4} a new 4x4 matrix
 */
function clone(a) {
    var out = new Float32Array(16);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
};
},{}],49:[function(require,module,exports){
module.exports = copy;

/**
 * Copy the values from one mat4 to another
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
function copy(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
};
},{}],50:[function(require,module,exports){
module.exports = create;

/**
 * Creates a new identity mat4
 *
 * @returns {mat4} a new 4x4 matrix
 */
function create() {
    var out = new Float32Array(16);
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
};
},{}],51:[function(require,module,exports){
module.exports = determinant;

/**
 * Calculates the determinant of a mat4
 *
 * @param {mat4} a the source matrix
 * @returns {Number} determinant of a
 */
function determinant(a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

        b00 = a00 * a11 - a01 * a10,
        b01 = a00 * a12 - a02 * a10,
        b02 = a00 * a13 - a03 * a10,
        b03 = a01 * a12 - a02 * a11,
        b04 = a01 * a13 - a03 * a11,
        b05 = a02 * a13 - a03 * a12,
        b06 = a20 * a31 - a21 * a30,
        b07 = a20 * a32 - a22 * a30,
        b08 = a20 * a33 - a23 * a30,
        b09 = a21 * a32 - a22 * a31,
        b10 = a21 * a33 - a23 * a31,
        b11 = a22 * a33 - a23 * a32;

    // Calculate the determinant
    return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
};
},{}],52:[function(require,module,exports){
module.exports = fromQuat;

/**
 * Creates a matrix from a quaternion rotation.
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @returns {mat4} out
 */
function fromQuat(out, q) {
    var x = q[0], y = q[1], z = q[2], w = q[3],
        x2 = x + x,
        y2 = y + y,
        z2 = z + z,

        xx = x * x2,
        yx = y * x2,
        yy = y * y2,
        zx = z * x2,
        zy = z * y2,
        zz = z * z2,
        wx = w * x2,
        wy = w * y2,
        wz = w * z2;

    out[0] = 1 - yy - zz;
    out[1] = yx + wz;
    out[2] = zx - wy;
    out[3] = 0;

    out[4] = yx - wz;
    out[5] = 1 - xx - zz;
    out[6] = zy + wx;
    out[7] = 0;

    out[8] = zx + wy;
    out[9] = zy - wx;
    out[10] = 1 - xx - yy;
    out[11] = 0;

    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;

    return out;
};
},{}],53:[function(require,module,exports){
module.exports = fromRotation

/**
 * Creates a matrix from a given angle around a given axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest)
 *     mat4.rotate(dest, dest, rad, axis)
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @param {vec3} axis the axis to rotate around
 * @returns {mat4} out
 */
function fromRotation(out, rad, axis) {
  var s, c, t
  var x = axis[0]
  var y = axis[1]
  var z = axis[2]
  var len = Math.sqrt(x * x + y * y + z * z)

  if (Math.abs(len) < 0.000001) {
    return null
  }

  len = 1 / len
  x *= len
  y *= len
  z *= len

  s = Math.sin(rad)
  c = Math.cos(rad)
  t = 1 - c

  // Perform rotation-specific matrix multiplication
  out[0] = x * x * t + c
  out[1] = y * x * t + z * s
  out[2] = z * x * t - y * s
  out[3] = 0
  out[4] = x * y * t - z * s
  out[5] = y * y * t + c
  out[6] = z * y * t + x * s
  out[7] = 0
  out[8] = x * z * t + y * s
  out[9] = y * z * t - x * s
  out[10] = z * z * t + c
  out[11] = 0
  out[12] = 0
  out[13] = 0
  out[14] = 0
  out[15] = 1
  return out
}

},{}],54:[function(require,module,exports){
module.exports = fromRotationTranslation;

/**
 * Creates a matrix from a quaternion rotation and vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     var quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {vec3} v Translation vector
 * @returns {mat4} out
 */
function fromRotationTranslation(out, q, v) {
    // Quaternion math
    var x = q[0], y = q[1], z = q[2], w = q[3],
        x2 = x + x,
        y2 = y + y,
        z2 = z + z,

        xx = x * x2,
        xy = x * y2,
        xz = x * z2,
        yy = y * y2,
        yz = y * z2,
        zz = z * z2,
        wx = w * x2,
        wy = w * y2,
        wz = w * z2;

    out[0] = 1 - (yy + zz);
    out[1] = xy + wz;
    out[2] = xz - wy;
    out[3] = 0;
    out[4] = xy - wz;
    out[5] = 1 - (xx + zz);
    out[6] = yz + wx;
    out[7] = 0;
    out[8] = xz + wy;
    out[9] = yz - wx;
    out[10] = 1 - (xx + yy);
    out[11] = 0;
    out[12] = v[0];
    out[13] = v[1];
    out[14] = v[2];
    out[15] = 1;
    
    return out;
};
},{}],55:[function(require,module,exports){
module.exports = fromScaling

/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest)
 *     mat4.scale(dest, dest, vec)
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {vec3} v Scaling vector
 * @returns {mat4} out
 */
function fromScaling(out, v) {
  out[0] = v[0]
  out[1] = 0
  out[2] = 0
  out[3] = 0
  out[4] = 0
  out[5] = v[1]
  out[6] = 0
  out[7] = 0
  out[8] = 0
  out[9] = 0
  out[10] = v[2]
  out[11] = 0
  out[12] = 0
  out[13] = 0
  out[14] = 0
  out[15] = 1
  return out
}

},{}],56:[function(require,module,exports){
module.exports = fromTranslation

/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest)
 *     mat4.translate(dest, dest, vec)
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {vec3} v Translation vector
 * @returns {mat4} out
 */
function fromTranslation(out, v) {
  out[0] = 1
  out[1] = 0
  out[2] = 0
  out[3] = 0
  out[4] = 0
  out[5] = 1
  out[6] = 0
  out[7] = 0
  out[8] = 0
  out[9] = 0
  out[10] = 1
  out[11] = 0
  out[12] = v[0]
  out[13] = v[1]
  out[14] = v[2]
  out[15] = 1
  return out
}

},{}],57:[function(require,module,exports){
module.exports = fromXRotation

/**
 * Creates a matrix from the given angle around the X axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest)
 *     mat4.rotateX(dest, dest, rad)
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
function fromXRotation(out, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad)

    // Perform axis-specific matrix multiplication
    out[0] = 1
    out[1] = 0
    out[2] = 0
    out[3] = 0
    out[4] = 0
    out[5] = c
    out[6] = s
    out[7] = 0
    out[8] = 0
    out[9] = -s
    out[10] = c
    out[11] = 0
    out[12] = 0
    out[13] = 0
    out[14] = 0
    out[15] = 1
    return out
}
},{}],58:[function(require,module,exports){
module.exports = fromYRotation

/**
 * Creates a matrix from the given angle around the Y axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest)
 *     mat4.rotateY(dest, dest, rad)
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
function fromYRotation(out, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad)

    // Perform axis-specific matrix multiplication
    out[0] = c
    out[1] = 0
    out[2] = -s
    out[3] = 0
    out[4] = 0
    out[5] = 1
    out[6] = 0
    out[7] = 0
    out[8] = s
    out[9] = 0
    out[10] = c
    out[11] = 0
    out[12] = 0
    out[13] = 0
    out[14] = 0
    out[15] = 1
    return out
}
},{}],59:[function(require,module,exports){
module.exports = fromZRotation

/**
 * Creates a matrix from the given angle around the Z axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest)
 *     mat4.rotateZ(dest, dest, rad)
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
function fromZRotation(out, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad)

    // Perform axis-specific matrix multiplication
    out[0] = c
    out[1] = s
    out[2] = 0
    out[3] = 0
    out[4] = -s
    out[5] = c
    out[6] = 0
    out[7] = 0
    out[8] = 0
    out[9] = 0
    out[10] = 1
    out[11] = 0
    out[12] = 0
    out[13] = 0
    out[14] = 0
    out[15] = 1
    return out
}
},{}],60:[function(require,module,exports){
module.exports = frustum;

/**
 * Generates a frustum matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {Number} left Left bound of the frustum
 * @param {Number} right Right bound of the frustum
 * @param {Number} bottom Bottom bound of the frustum
 * @param {Number} top Top bound of the frustum
 * @param {Number} near Near bound of the frustum
 * @param {Number} far Far bound of the frustum
 * @returns {mat4} out
 */
function frustum(out, left, right, bottom, top, near, far) {
    var rl = 1 / (right - left),
        tb = 1 / (top - bottom),
        nf = 1 / (near - far);
    out[0] = (near * 2) * rl;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = (near * 2) * tb;
    out[6] = 0;
    out[7] = 0;
    out[8] = (right + left) * rl;
    out[9] = (top + bottom) * tb;
    out[10] = (far + near) * nf;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[14] = (far * near * 2) * nf;
    out[15] = 0;
    return out;
};
},{}],61:[function(require,module,exports){
module.exports = identity;

/**
 * Set a mat4 to the identity matrix
 *
 * @param {mat4} out the receiving matrix
 * @returns {mat4} out
 */
function identity(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
};
},{}],62:[function(require,module,exports){
module.exports = {
  create: require('./create')
  , clone: require('./clone')
  , copy: require('./copy')
  , identity: require('./identity')
  , transpose: require('./transpose')
  , invert: require('./invert')
  , adjoint: require('./adjoint')
  , determinant: require('./determinant')
  , multiply: require('./multiply')
  , translate: require('./translate')
  , scale: require('./scale')
  , rotate: require('./rotate')
  , rotateX: require('./rotateX')
  , rotateY: require('./rotateY')
  , rotateZ: require('./rotateZ')
  , fromRotation: require('./fromRotation')
  , fromRotationTranslation: require('./fromRotationTranslation')
  , fromScaling: require('./fromScaling')
  , fromTranslation: require('./fromTranslation')
  , fromXRotation: require('./fromXRotation')
  , fromYRotation: require('./fromYRotation')
  , fromZRotation: require('./fromZRotation')
  , fromQuat: require('./fromQuat')
  , frustum: require('./frustum')
  , perspective: require('./perspective')
  , perspectiveFromFieldOfView: require('./perspectiveFromFieldOfView')
  , ortho: require('./ortho')
  , lookAt: require('./lookAt')
  , str: require('./str')
}

},{"./adjoint":47,"./clone":48,"./copy":49,"./create":50,"./determinant":51,"./fromQuat":52,"./fromRotation":53,"./fromRotationTranslation":54,"./fromScaling":55,"./fromTranslation":56,"./fromXRotation":57,"./fromYRotation":58,"./fromZRotation":59,"./frustum":60,"./identity":61,"./invert":63,"./lookAt":64,"./multiply":65,"./ortho":66,"./perspective":67,"./perspectiveFromFieldOfView":68,"./rotate":69,"./rotateX":70,"./rotateY":71,"./rotateZ":72,"./scale":73,"./str":74,"./translate":75,"./transpose":76}],63:[function(require,module,exports){
module.exports = invert;

/**
 * Inverts a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
function invert(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

        b00 = a00 * a11 - a01 * a10,
        b01 = a00 * a12 - a02 * a10,
        b02 = a00 * a13 - a03 * a10,
        b03 = a01 * a12 - a02 * a11,
        b04 = a01 * a13 - a03 * a11,
        b05 = a02 * a13 - a03 * a12,
        b06 = a20 * a31 - a21 * a30,
        b07 = a20 * a32 - a22 * a30,
        b08 = a20 * a33 - a23 * a30,
        b09 = a21 * a32 - a22 * a31,
        b10 = a21 * a33 - a23 * a31,
        b11 = a22 * a33 - a23 * a32,

        // Calculate the determinant
        det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

    if (!det) { 
        return null; 
    }
    det = 1.0 / det;

    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
    out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
    out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
    out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
    out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
    out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
    out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
    out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
    out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
    out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
    out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
    out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
    out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
    out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
    out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
    out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;

    return out;
};
},{}],64:[function(require,module,exports){
var identity = require('./identity');

module.exports = lookAt;

/**
 * Generates a look-at matrix with the given eye position, focal point, and up axis
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {vec3} eye Position of the viewer
 * @param {vec3} center Point the viewer is looking at
 * @param {vec3} up vec3 pointing up
 * @returns {mat4} out
 */
function lookAt(out, eye, center, up) {
    var x0, x1, x2, y0, y1, y2, z0, z1, z2, len,
        eyex = eye[0],
        eyey = eye[1],
        eyez = eye[2],
        upx = up[0],
        upy = up[1],
        upz = up[2],
        centerx = center[0],
        centery = center[1],
        centerz = center[2];

    if (Math.abs(eyex - centerx) < 0.000001 &&
        Math.abs(eyey - centery) < 0.000001 &&
        Math.abs(eyez - centerz) < 0.000001) {
        return identity(out);
    }

    z0 = eyex - centerx;
    z1 = eyey - centery;
    z2 = eyez - centerz;

    len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
    z0 *= len;
    z1 *= len;
    z2 *= len;

    x0 = upy * z2 - upz * z1;
    x1 = upz * z0 - upx * z2;
    x2 = upx * z1 - upy * z0;
    len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
    if (!len) {
        x0 = 0;
        x1 = 0;
        x2 = 0;
    } else {
        len = 1 / len;
        x0 *= len;
        x1 *= len;
        x2 *= len;
    }

    y0 = z1 * x2 - z2 * x1;
    y1 = z2 * x0 - z0 * x2;
    y2 = z0 * x1 - z1 * x0;

    len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);
    if (!len) {
        y0 = 0;
        y1 = 0;
        y2 = 0;
    } else {
        len = 1 / len;
        y0 *= len;
        y1 *= len;
        y2 *= len;
    }

    out[0] = x0;
    out[1] = y0;
    out[2] = z0;
    out[3] = 0;
    out[4] = x1;
    out[5] = y1;
    out[6] = z1;
    out[7] = 0;
    out[8] = x2;
    out[9] = y2;
    out[10] = z2;
    out[11] = 0;
    out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
    out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
    out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
    out[15] = 1;

    return out;
};
},{"./identity":61}],65:[function(require,module,exports){
module.exports = multiply;

/**
 * Multiplies two mat4's
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */
function multiply(out, a, b) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

    // Cache only the current line of the second matrix
    var b0  = b[0], b1 = b[1], b2 = b[2], b3 = b[3];  
    out[0] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[1] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[2] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[3] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

    b0 = b[4]; b1 = b[5]; b2 = b[6]; b3 = b[7];
    out[4] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[5] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[6] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[7] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

    b0 = b[8]; b1 = b[9]; b2 = b[10]; b3 = b[11];
    out[8] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[9] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[10] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[11] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

    b0 = b[12]; b1 = b[13]; b2 = b[14]; b3 = b[15];
    out[12] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[13] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[14] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[15] = b0*a03 + b1*a13 + b2*a23 + b3*a33;
    return out;
};
},{}],66:[function(require,module,exports){
module.exports = ortho;

/**
 * Generates a orthogonal projection matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} left Left bound of the frustum
 * @param {number} right Right bound of the frustum
 * @param {number} bottom Bottom bound of the frustum
 * @param {number} top Top bound of the frustum
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */
function ortho(out, left, right, bottom, top, near, far) {
    var lr = 1 / (left - right),
        bt = 1 / (bottom - top),
        nf = 1 / (near - far);
    out[0] = -2 * lr;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = -2 * bt;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 2 * nf;
    out[11] = 0;
    out[12] = (left + right) * lr;
    out[13] = (top + bottom) * bt;
    out[14] = (far + near) * nf;
    out[15] = 1;
    return out;
};
},{}],67:[function(require,module,exports){
module.exports = perspective;

/**
 * Generates a perspective projection matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} fovy Vertical field of view in radians
 * @param {number} aspect Aspect ratio. typically viewport width/height
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */
function perspective(out, fovy, aspect, near, far) {
    var f = 1.0 / Math.tan(fovy / 2),
        nf = 1 / (near - far);
    out[0] = f / aspect;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = f;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = (far + near) * nf;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[14] = (2 * far * near) * nf;
    out[15] = 0;
    return out;
};
},{}],68:[function(require,module,exports){
module.exports = perspectiveFromFieldOfView;

/**
 * Generates a perspective projection matrix with the given field of view.
 * This is primarily useful for generating projection matrices to be used
 * with the still experiemental WebVR API.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} fov Object containing the following values: upDegrees, downDegrees, leftDegrees, rightDegrees
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */
function perspectiveFromFieldOfView(out, fov, near, far) {
    var upTan = Math.tan(fov.upDegrees * Math.PI/180.0),
        downTan = Math.tan(fov.downDegrees * Math.PI/180.0),
        leftTan = Math.tan(fov.leftDegrees * Math.PI/180.0),
        rightTan = Math.tan(fov.rightDegrees * Math.PI/180.0),
        xScale = 2.0 / (leftTan + rightTan),
        yScale = 2.0 / (upTan + downTan);

    out[0] = xScale;
    out[1] = 0.0;
    out[2] = 0.0;
    out[3] = 0.0;
    out[4] = 0.0;
    out[5] = yScale;
    out[6] = 0.0;
    out[7] = 0.0;
    out[8] = -((leftTan - rightTan) * xScale * 0.5);
    out[9] = ((upTan - downTan) * yScale * 0.5);
    out[10] = far / (near - far);
    out[11] = -1.0;
    out[12] = 0.0;
    out[13] = 0.0;
    out[14] = (far * near) / (near - far);
    out[15] = 0.0;
    return out;
}


},{}],69:[function(require,module,exports){
module.exports = rotate;

/**
 * Rotates a mat4 by the given angle
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @param {vec3} axis the axis to rotate around
 * @returns {mat4} out
 */
function rotate(out, a, rad, axis) {
    var x = axis[0], y = axis[1], z = axis[2],
        len = Math.sqrt(x * x + y * y + z * z),
        s, c, t,
        a00, a01, a02, a03,
        a10, a11, a12, a13,
        a20, a21, a22, a23,
        b00, b01, b02,
        b10, b11, b12,
        b20, b21, b22;

    if (Math.abs(len) < 0.000001) { return null; }
    
    len = 1 / len;
    x *= len;
    y *= len;
    z *= len;

    s = Math.sin(rad);
    c = Math.cos(rad);
    t = 1 - c;

    a00 = a[0]; a01 = a[1]; a02 = a[2]; a03 = a[3];
    a10 = a[4]; a11 = a[5]; a12 = a[6]; a13 = a[7];
    a20 = a[8]; a21 = a[9]; a22 = a[10]; a23 = a[11];

    // Construct the elements of the rotation matrix
    b00 = x * x * t + c; b01 = y * x * t + z * s; b02 = z * x * t - y * s;
    b10 = x * y * t - z * s; b11 = y * y * t + c; b12 = z * y * t + x * s;
    b20 = x * z * t + y * s; b21 = y * z * t - x * s; b22 = z * z * t + c;

    // Perform rotation-specific matrix multiplication
    out[0] = a00 * b00 + a10 * b01 + a20 * b02;
    out[1] = a01 * b00 + a11 * b01 + a21 * b02;
    out[2] = a02 * b00 + a12 * b01 + a22 * b02;
    out[3] = a03 * b00 + a13 * b01 + a23 * b02;
    out[4] = a00 * b10 + a10 * b11 + a20 * b12;
    out[5] = a01 * b10 + a11 * b11 + a21 * b12;
    out[6] = a02 * b10 + a12 * b11 + a22 * b12;
    out[7] = a03 * b10 + a13 * b11 + a23 * b12;
    out[8] = a00 * b20 + a10 * b21 + a20 * b22;
    out[9] = a01 * b20 + a11 * b21 + a21 * b22;
    out[10] = a02 * b20 + a12 * b21 + a22 * b22;
    out[11] = a03 * b20 + a13 * b21 + a23 * b22;

    if (a !== out) { // If the source and destination differ, copy the unchanged last row
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }
    return out;
};
},{}],70:[function(require,module,exports){
module.exports = rotateX;

/**
 * Rotates a matrix by the given angle around the X axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
function rotateX(out, a, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad),
        a10 = a[4],
        a11 = a[5],
        a12 = a[6],
        a13 = a[7],
        a20 = a[8],
        a21 = a[9],
        a22 = a[10],
        a23 = a[11];

    if (a !== out) { // If the source and destination differ, copy the unchanged rows
        out[0]  = a[0];
        out[1]  = a[1];
        out[2]  = a[2];
        out[3]  = a[3];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }

    // Perform axis-specific matrix multiplication
    out[4] = a10 * c + a20 * s;
    out[5] = a11 * c + a21 * s;
    out[6] = a12 * c + a22 * s;
    out[7] = a13 * c + a23 * s;
    out[8] = a20 * c - a10 * s;
    out[9] = a21 * c - a11 * s;
    out[10] = a22 * c - a12 * s;
    out[11] = a23 * c - a13 * s;
    return out;
};
},{}],71:[function(require,module,exports){
module.exports = rotateY;

/**
 * Rotates a matrix by the given angle around the Y axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
function rotateY(out, a, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad),
        a00 = a[0],
        a01 = a[1],
        a02 = a[2],
        a03 = a[3],
        a20 = a[8],
        a21 = a[9],
        a22 = a[10],
        a23 = a[11];

    if (a !== out) { // If the source and destination differ, copy the unchanged rows
        out[4]  = a[4];
        out[5]  = a[5];
        out[6]  = a[6];
        out[7]  = a[7];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }

    // Perform axis-specific matrix multiplication
    out[0] = a00 * c - a20 * s;
    out[1] = a01 * c - a21 * s;
    out[2] = a02 * c - a22 * s;
    out[3] = a03 * c - a23 * s;
    out[8] = a00 * s + a20 * c;
    out[9] = a01 * s + a21 * c;
    out[10] = a02 * s + a22 * c;
    out[11] = a03 * s + a23 * c;
    return out;
};
},{}],72:[function(require,module,exports){
module.exports = rotateZ;

/**
 * Rotates a matrix by the given angle around the Z axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
function rotateZ(out, a, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad),
        a00 = a[0],
        a01 = a[1],
        a02 = a[2],
        a03 = a[3],
        a10 = a[4],
        a11 = a[5],
        a12 = a[6],
        a13 = a[7];

    if (a !== out) { // If the source and destination differ, copy the unchanged last row
        out[8]  = a[8];
        out[9]  = a[9];
        out[10] = a[10];
        out[11] = a[11];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }

    // Perform axis-specific matrix multiplication
    out[0] = a00 * c + a10 * s;
    out[1] = a01 * c + a11 * s;
    out[2] = a02 * c + a12 * s;
    out[3] = a03 * c + a13 * s;
    out[4] = a10 * c - a00 * s;
    out[5] = a11 * c - a01 * s;
    out[6] = a12 * c - a02 * s;
    out[7] = a13 * c - a03 * s;
    return out;
};
},{}],73:[function(require,module,exports){
module.exports = scale;

/**
 * Scales the mat4 by the dimensions in the given vec3
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to scale
 * @param {vec3} v the vec3 to scale the matrix by
 * @returns {mat4} out
 **/
function scale(out, a, v) {
    var x = v[0], y = v[1], z = v[2];

    out[0] = a[0] * x;
    out[1] = a[1] * x;
    out[2] = a[2] * x;
    out[3] = a[3] * x;
    out[4] = a[4] * y;
    out[5] = a[5] * y;
    out[6] = a[6] * y;
    out[7] = a[7] * y;
    out[8] = a[8] * z;
    out[9] = a[9] * z;
    out[10] = a[10] * z;
    out[11] = a[11] * z;
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
};
},{}],74:[function(require,module,exports){
module.exports = str;

/**
 * Returns a string representation of a mat4
 *
 * @param {mat4} mat matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
function str(a) {
    return 'mat4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' +
                    a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ', ' +
                    a[8] + ', ' + a[9] + ', ' + a[10] + ', ' + a[11] + ', ' + 
                    a[12] + ', ' + a[13] + ', ' + a[14] + ', ' + a[15] + ')';
};
},{}],75:[function(require,module,exports){
module.exports = translate;

/**
 * Translate a mat4 by the given vector
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to translate
 * @param {vec3} v vector to translate by
 * @returns {mat4} out
 */
function translate(out, a, v) {
    var x = v[0], y = v[1], z = v[2],
        a00, a01, a02, a03,
        a10, a11, a12, a13,
        a20, a21, a22, a23;

    if (a === out) {
        out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
        out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
        out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
        out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
    } else {
        a00 = a[0]; a01 = a[1]; a02 = a[2]; a03 = a[3];
        a10 = a[4]; a11 = a[5]; a12 = a[6]; a13 = a[7];
        a20 = a[8]; a21 = a[9]; a22 = a[10]; a23 = a[11];

        out[0] = a00; out[1] = a01; out[2] = a02; out[3] = a03;
        out[4] = a10; out[5] = a11; out[6] = a12; out[7] = a13;
        out[8] = a20; out[9] = a21; out[10] = a22; out[11] = a23;

        out[12] = a00 * x + a10 * y + a20 * z + a[12];
        out[13] = a01 * x + a11 * y + a21 * z + a[13];
        out[14] = a02 * x + a12 * y + a22 * z + a[14];
        out[15] = a03 * x + a13 * y + a23 * z + a[15];
    }

    return out;
};
},{}],76:[function(require,module,exports){
module.exports = transpose;

/**
 * Transpose the values of a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
function transpose(out, a) {
    // If we are transposing ourselves we can skip a few steps but have to cache some values
    if (out === a) {
        var a01 = a[1], a02 = a[2], a03 = a[3],
            a12 = a[6], a13 = a[7],
            a23 = a[11];

        out[1] = a[4];
        out[2] = a[8];
        out[3] = a[12];
        out[4] = a01;
        out[6] = a[9];
        out[7] = a[13];
        out[8] = a02;
        out[9] = a12;
        out[11] = a[14];
        out[12] = a03;
        out[13] = a13;
        out[14] = a23;
    } else {
        out[0] = a[0];
        out[1] = a[4];
        out[2] = a[8];
        out[3] = a[12];
        out[4] = a[1];
        out[5] = a[5];
        out[6] = a[9];
        out[7] = a[13];
        out[8] = a[2];
        out[9] = a[6];
        out[10] = a[10];
        out[11] = a[14];
        out[12] = a[3];
        out[13] = a[7];
        out[14] = a[11];
        out[15] = a[15];
    }
    
    return out;
};
},{}],77:[function(require,module,exports){
module.exports = function(strings) {
  if (typeof strings === 'string') strings = [strings]
  var exprs = [].slice.call(arguments,1)
  var parts = []
  for (var i = 0; i < strings.length-1; i++) {
    parts.push(strings[i], exprs[i] || '')
  }
  parts.push(strings[i])
  return parts.join('')
}

},{}],78:[function(require,module,exports){
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],79:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      })
    }
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      var TempCtor = function () {}
      TempCtor.prototype = superCtor.prototype
      ctor.prototype = new TempCtor()
      ctor.prototype.constructor = ctor
    }
  }
}

},{}],80:[function(require,module,exports){
"use strict"

var bounds = require("binary-search-bounds")

var NOT_FOUND = 0
var SUCCESS = 1
var EMPTY = 2

module.exports = createWrapper

function IntervalTreeNode(mid, left, right, leftPoints, rightPoints) {
  this.mid = mid
  this.left = left
  this.right = right
  this.leftPoints = leftPoints
  this.rightPoints = rightPoints
  this.count = (left ? left.count : 0) + (right ? right.count : 0) + leftPoints.length
}

var proto = IntervalTreeNode.prototype

function copy(a, b) {
  a.mid = b.mid
  a.left = b.left
  a.right = b.right
  a.leftPoints = b.leftPoints
  a.rightPoints = b.rightPoints
  a.count = b.count
}

function rebuild(node, intervals) {
  var ntree = createIntervalTree(intervals)
  node.mid = ntree.mid
  node.left = ntree.left
  node.right = ntree.right
  node.leftPoints = ntree.leftPoints
  node.rightPoints = ntree.rightPoints
  node.count = ntree.count
}

function rebuildWithInterval(node, interval) {
  var intervals = node.intervals([])
  intervals.push(interval)
  rebuild(node, intervals)    
}

function rebuildWithoutInterval(node, interval) {
  var intervals = node.intervals([])
  var idx = intervals.indexOf(interval)
  if(idx < 0) {
    return NOT_FOUND
  }
  intervals.splice(idx, 1)
  rebuild(node, intervals)
  return SUCCESS
}

proto.intervals = function(result) {
  result.push.apply(result, this.leftPoints)
  if(this.left) {
    this.left.intervals(result)
  }
  if(this.right) {
    this.right.intervals(result)
  }
  return result
}

proto.insert = function(interval) {
  var weight = this.count - this.leftPoints.length
  this.count += 1
  if(interval[1] < this.mid) {
    if(this.left) {
      if(4*(this.left.count+1) > 3*(weight+1)) {
        rebuildWithInterval(this, interval)
      } else {
        this.left.insert(interval)
      }
    } else {
      this.left = createIntervalTree([interval])
    }
  } else if(interval[0] > this.mid) {
    if(this.right) {
      if(4*(this.right.count+1) > 3*(weight+1)) {
        rebuildWithInterval(this, interval)
      } else {
        this.right.insert(interval)
      }
    } else {
      this.right = createIntervalTree([interval])
    }
  } else {
    var l = bounds.ge(this.leftPoints, interval, compareBegin)
    var r = bounds.ge(this.rightPoints, interval, compareEnd)
    this.leftPoints.splice(l, 0, interval)
    this.rightPoints.splice(r, 0, interval)
  }
}

proto.remove = function(interval) {
  var weight = this.count - this.leftPoints
  if(interval[1] < this.mid) {
    if(!this.left) {
      return NOT_FOUND
    }
    var rw = this.right ? this.right.count : 0
    if(4 * rw > 3 * (weight-1)) {
      return rebuildWithoutInterval(this, interval)
    }
    var r = this.left.remove(interval)
    if(r === EMPTY) {
      this.left = null
      this.count -= 1
      return SUCCESS
    } else if(r === SUCCESS) {
      this.count -= 1
    }
    return r
  } else if(interval[0] > this.mid) {
    if(!this.right) {
      return NOT_FOUND
    }
    var lw = this.left ? this.left.count : 0
    if(4 * lw > 3 * (weight-1)) {
      return rebuildWithoutInterval(this, interval)
    }
    var r = this.right.remove(interval)
    if(r === EMPTY) {
      this.right = null
      this.count -= 1
      return SUCCESS
    } else if(r === SUCCESS) {
      this.count -= 1
    }
    return r
  } else {
    if(this.count === 1) {
      if(this.leftPoints[0] === interval) {
        return EMPTY
      } else {
        return NOT_FOUND
      }
    }
    if(this.leftPoints.length === 1 && this.leftPoints[0] === interval) {
      if(this.left && this.right) {
        var p = this
        var n = this.left
        while(n.right) {
          p = n
          n = n.right
        }
        if(p === this) {
          n.right = this.right
        } else {
          var l = this.left
          var r = this.right
          p.count -= n.count
          p.right = n.left
          n.left = l
          n.right = r
        }
        copy(this, n)
        this.count = (this.left?this.left.count:0) + (this.right?this.right.count:0) + this.leftPoints.length
      } else if(this.left) {
        copy(this, this.left)
      } else {
        copy(this, this.right)
      }
      return SUCCESS
    }
    for(var l = bounds.ge(this.leftPoints, interval, compareBegin); l<this.leftPoints.length; ++l) {
      if(this.leftPoints[l][0] !== interval[0]) {
        break
      }
      if(this.leftPoints[l] === interval) {
        this.count -= 1
        this.leftPoints.splice(l, 1)
        for(var r = bounds.ge(this.rightPoints, interval, compareEnd); r<this.rightPoints.length; ++r) {
          if(this.rightPoints[r][1] !== interval[1]) {
            break
          } else if(this.rightPoints[r] === interval) {
            this.rightPoints.splice(r, 1)
            return SUCCESS
          }
        }
      }
    }
    return NOT_FOUND
  }
}

function reportLeftRange(arr, hi, cb) {
  for(var i=0; i<arr.length && arr[i][0] <= hi; ++i) {
    var r = cb(arr[i])
    if(r) { return r }
  }
}

function reportRightRange(arr, lo, cb) {
  for(var i=arr.length-1; i>=0 && arr[i][1] >= lo; --i) {
    var r = cb(arr[i])
    if(r) { return r }
  }
}

function reportRange(arr, cb) {
  for(var i=0; i<arr.length; ++i) {
    var r = cb(arr[i])
    if(r) { return r }
  }
}

proto.queryPoint = function(x, cb) {
  if(x < this.mid) {
    if(this.left) {
      var r = this.left.queryPoint(x, cb)
      if(r) { return r }
    }
    return reportLeftRange(this.leftPoints, x, cb)
  } else if(x > this.mid) {
    if(this.right) {
      var r = this.right.queryPoint(x, cb)
      if(r) { return r }
    }
    return reportRightRange(this.rightPoints, x, cb)
  } else {
    return reportRange(this.leftPoints, cb)
  }
}

proto.queryInterval = function(lo, hi, cb) {
  if(lo < this.mid && this.left) {
    var r = this.left.queryInterval(lo, hi, cb)
    if(r) { return r }
  }
  if(hi > this.mid && this.right) {
    var r = this.right.queryInterval(lo, hi, cb)
    if(r) { return r }
  }
  if(hi < this.mid) {
    return reportLeftRange(this.leftPoints, hi, cb)
  } else if(lo > this.mid) {
    return reportRightRange(this.rightPoints, lo, cb)
  } else {
    return reportRange(this.leftPoints, cb)
  }
}

function compareNumbers(a, b) {
  return a - b
}

function compareBegin(a, b) {
  var d = a[0] - b[0]
  if(d) { return d }
  return a[1] - b[1]
}

function compareEnd(a, b) {
  var d = a[1] - b[1]
  if(d) { return d }
  return a[0] - b[0]
}

function createIntervalTree(intervals) {
  if(intervals.length === 0) {
    return null
  }
  var pts = []
  for(var i=0; i<intervals.length; ++i) {
    pts.push(intervals[i][0], intervals[i][1])
  }
  pts.sort(compareNumbers)

  var mid = pts[pts.length>>1]

  var leftIntervals = []
  var rightIntervals = []
  var centerIntervals = []
  for(var i=0; i<intervals.length; ++i) {
    var s = intervals[i]
    if(s[1] < mid) {
      leftIntervals.push(s)
    } else if(mid < s[0]) {
      rightIntervals.push(s)
    } else {
      centerIntervals.push(s)
    }
  }

  //Split center intervals
  var leftPoints = centerIntervals
  var rightPoints = centerIntervals.slice()
  leftPoints.sort(compareBegin)
  rightPoints.sort(compareEnd)

  return new IntervalTreeNode(mid, 
    createIntervalTree(leftIntervals),
    createIntervalTree(rightIntervals),
    leftPoints,
    rightPoints)
}

//User friendly wrapper that makes it possible to support empty trees
function IntervalTree(root) {
  this.root = root
}

var tproto = IntervalTree.prototype

tproto.insert = function(interval) {
  if(this.root) {
    this.root.insert(interval)
  } else {
    this.root = new IntervalTreeNode(interval[0], null, null, [interval], [interval])
  }
}

tproto.remove = function(interval) {
  if(this.root) {
    var r = this.root.remove(interval)
    if(r === EMPTY) {
      this.root = null
    }
    return r !== NOT_FOUND
  }
  return false
}

tproto.queryPoint = function(p, cb) {
  if(this.root) {
    return this.root.queryPoint(p, cb)
  }
}

tproto.queryInterval = function(lo, hi, cb) {
  if(lo <= hi && this.root) {
    return this.root.queryInterval(lo, hi, cb)
  }
}

Object.defineProperty(tproto, "count", {
  get: function() {
    if(this.root) {
      return this.root.count
    }
    return 0
  }
})

Object.defineProperty(tproto, "intervals", {
  get: function() {
    if(this.root) {
      return this.root.intervals([])
    }
    return []
  }
})

function createWrapper(intervals) {
  if(!intervals || intervals.length === 0) {
    return new IntervalTree(null)
  }
  return new IntervalTree(createIntervalTree(intervals))
}

},{"binary-search-bounds":19}],81:[function(require,module,exports){
"use strict"

function invertPermutation(pi, result) {
  result = result || new Array(pi.length)
  for(var i=0; i<pi.length; ++i) {
    result[pi[i]] = i
  }
  return result
}

module.exports = invertPermutation
},{}],82:[function(require,module,exports){
"use strict"

function iota(n) {
  var result = new Array(n)
  for(var i=0; i<n; ++i) {
    result[i] = i
  }
  return result
}

module.exports = iota
},{}],83:[function(require,module,exports){
/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */

// The _isBuffer check is for Safari 5-7 support, because it's missing
// Object.prototype.constructor. Remove this eventually
module.exports = function (obj) {
  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)
}

function isBuffer (obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
}

// For Node v0.10 support. Remove this eventually.
function isSlowBuffer (obj) {
  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0))
}

},{}],84:[function(require,module,exports){
!function(r,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):(r="undefined"!=typeof globalThis?globalThis:r||self).Meyda=t()}(this,(function(){"use strict";function r(r,t,e){if(e||2===arguments.length)for(var a,n=0,o=t.length;n<o;n++)!a&&n in t||(a||(a=Array.prototype.slice.call(t,0,n)),a[n]=t[n]);return r.concat(a||Array.prototype.slice.call(t))}var t=Object.freeze({__proto__:null,blackman:function(r){for(var t=new Float32Array(r),e=2*Math.PI/(r-1),a=2*e,n=0;n<r/2;n++)t[n]=.42-.5*Math.cos(n*e)+.08*Math.cos(n*a);for(n=Math.ceil(r/2);n>0;n--)t[r-n]=t[n-1];return t},sine:function(r){for(var t=Math.PI/(r-1),e=new Float32Array(r),a=0;a<r;a++)e[a]=Math.sin(t*a);return e},hanning:function(r){for(var t=new Float32Array(r),e=0;e<r;e++)t[e]=.5-.5*Math.cos(2*Math.PI*e/(r-1));return t},hamming:function(r){for(var t=new Float32Array(r),e=0;e<r;e++)t[e]=.54-.46*Math.cos(2*Math.PI*(e/r-1));return t}}),e={};function a(r){for(;r%2==0&&r>1;)r/=2;return 1===r}function n(r,a){if("rect"!==a){if(""!==a&&a||(a="hanning"),e[a]||(e[a]={}),!e[a][r.length])try{e[a][r.length]=t[a](r.length)}catch(r){throw new Error("Invalid windowing function")}r=function(r,t){for(var e=[],a=0;a<Math.min(r.length,t.length);a++)e[a]=r[a]*t[a];return e}(r,e[a][r.length])}return r}function o(r,t,e){for(var a=new Float32Array(r),n=0;n<a.length;n++)a[n]=n*t/e,a[n]=13*Math.atan(a[n]/1315.8)+3.5*Math.atan(Math.pow(a[n]/7518,2));return a}function i(r){return Float32Array.from(r)}function u(r){return 1125*Math.log(1+r/700)}function f(r,t,e){for(var a,n=new Float32Array(r+2),o=new Float32Array(r+2),i=t/2,f=u(0),c=(u(i)-f)/(r+1),l=new Array(r+2),s=0;s<n.length;s++)n[s]=s*c,o[s]=(a=n[s],700*(Math.exp(a/1125)-1)),l[s]=Math.floor((e+1)*o[s]/t);for(var m=new Array(r),p=0;p<m.length;p++){m[p]=new Array(e/2+1).fill(0);for(s=l[p];s<l[p+1];s++)m[p][s]=(s-l[p])/(l[p+1]-l[p]);for(s=l[p+1];s<l[p+2];s++)m[p][s]=(l[p+2]-s)/(l[p+2]-l[p+1])}return m}function c(t,e,a,n,o,i,u){void 0===n&&(n=5),void 0===o&&(o=2),void 0===i&&(i=!0),void 0===u&&(u=440);var f=Math.floor(a/2)+1,c=new Array(a).fill(0).map((function(r,n){return t*function(r,t){return Math.log2(16*r/t)}(e*n/a,u)}));c[0]=c[1]-1.5*t;var l,s,m,p=c.slice(1).map((function(r,t){return Math.max(r-c[t])}),1).concat([1]),h=Math.round(t/2),g=new Array(t).fill(0).map((function(r,e){return c.map((function(r){return(10*t+h+r-e)%t-h}))})),w=g.map((function(r,t){return r.map((function(r,e){return Math.exp(-.5*Math.pow(2*g[t][e]/p[e],2))}))}));if(s=(l=w)[0].map((function(){return 0})),m=l.reduce((function(r,t){return t.forEach((function(t,e){r[e]+=Math.pow(t,2)})),r}),s).map(Math.sqrt),w=l.map((function(r,t){return r.map((function(r,t){return r/(m[t]||1)}))})),o){var v=c.map((function(r){return Math.exp(-.5*Math.pow((r/t-n)/o,2))}));w=w.map((function(r){return r.map((function(r,t){return r*v[t]}))}))}return i&&(w=r(r([],w.slice(3),!0),w.slice(0,3),!0)),w.map((function(r){return r.slice(0,f)}))}function l(r,t){for(var e=0,a=0,n=0;n<t.length;n++)e+=Math.pow(n,r)*Math.abs(t[n]),a+=t[n];return e/a}function s(r){var t=r.ampSpectrum,e=r.barkScale,a=r.numberOfBarkBands,n=void 0===a?24:a;if("object"!=typeof t||"object"!=typeof e)throw new TypeError;var o=n,i=new Float32Array(o),u=0,f=t,c=new Int32Array(o+1);c[0]=0;for(var l=e[f.length-1]/o,s=1,m=0;m<f.length;m++)for(;e[m]>l;)c[s++]=m,l=s*e[f.length-1]/o;c[o]=f.length-1;for(m=0;m<o;m++){for(var p=0,h=c[m];h<c[m+1];h++)p+=f[h];i[m]=Math.pow(p,.23)}for(m=0;m<i.length;m++)u+=i[m];return{specific:i,total:u}}function m(r){var t=r.ampSpectrum;if("object"!=typeof t)throw new TypeError;for(var e=new Float32Array(t.length),a=0;a<e.length;a++)e[a]=Math.pow(t[a],2);return e}function p(r){var t=r.ampSpectrum,e=r.melFilterBank,a=r.bufferSize;if("object"!=typeof t)throw new TypeError("Valid ampSpectrum is required to generate melBands");if("object"!=typeof e)throw new TypeError("Valid melFilterBank is required to generate melBands");for(var n=m({ampSpectrum:t}),o=e.length,i=Array(o),u=new Float32Array(o),f=0;f<u.length;f++){i[f]=new Float32Array(a/2),u[f]=0;for(var c=0;c<a/2;c++)i[f][c]=e[f][c]*n[c],u[f]+=i[f][c];u[f]=Math.log(u[f]+1)}return Array.prototype.slice.call(u)}function h(r){return r&&r.__esModule&&Object.prototype.hasOwnProperty.call(r,"default")?r.default:r}var g={exports:{}},w=null;var v=function(r,t){var e=r.length;return t=t||2,w&&w[e]||function(r){(w=w||{})[r]=new Array(r*r);for(var t=Math.PI/r,e=0;e<r;e++)for(var a=0;a<r;a++)w[r][a+e*r]=Math.cos(t*(a+.5)*e)}(e),r.map((function(){return 0})).map((function(a,n){return t*r.reduce((function(r,t,a,o){return r+t*w[e][a+n*e]}),0)}))};!function(r){r.exports=v}(g);var d=h(g.exports);var y=Object.freeze({__proto__:null,buffer:function(r){return r.signal},rms:function(r){var t=r.signal;if("object"!=typeof t)throw new TypeError;for(var e=0,a=0;a<t.length;a++)e+=Math.pow(t[a],2);return e/=t.length,e=Math.sqrt(e)},energy:function(r){var t=r.signal;if("object"!=typeof t)throw new TypeError;for(var e=0,a=0;a<t.length;a++)e+=Math.pow(Math.abs(t[a]),2);return e},complexSpectrum:function(r){return r.complexSpectrum},spectralSlope:function(r){var t=r.ampSpectrum,e=r.sampleRate,a=r.bufferSize;if("object"!=typeof t)throw new TypeError;for(var n=0,o=0,i=new Float32Array(t.length),u=0,f=0,c=0;c<t.length;c++){n+=t[c];var l=c*e/a;i[c]=l,u+=l*l,o+=l,f+=l*t[c]}return(t.length*f-o*n)/(n*(u-Math.pow(o,2)))},spectralCentroid:function(r){var t=r.ampSpectrum;if("object"!=typeof t)throw new TypeError;return l(1,t)},spectralRolloff:function(r){var t=r.ampSpectrum,e=r.sampleRate;if("object"!=typeof t)throw new TypeError;for(var a=t,n=e/(2*(a.length-1)),o=0,i=0;i<a.length;i++)o+=a[i];for(var u=.99*o,f=a.length-1;o>u&&f>=0;)o-=a[f],--f;return(f+1)*n},spectralFlatness:function(r){var t=r.ampSpectrum;if("object"!=typeof t)throw new TypeError;for(var e=0,a=0,n=0;n<t.length;n++)e+=Math.log(t[n]),a+=t[n];return Math.exp(e/t.length)*t.length/a},spectralSpread:function(r){var t=r.ampSpectrum;if("object"!=typeof t)throw new TypeError;return Math.sqrt(l(2,t)-Math.pow(l(1,t),2))},spectralSkewness:function(r){var t=r.ampSpectrum;if("object"!=typeof t)throw new TypeError;var e=l(1,t),a=l(2,t),n=l(3,t);return(2*Math.pow(e,3)-3*e*a+n)/Math.pow(Math.sqrt(a-Math.pow(e,2)),3)},spectralKurtosis:function(r){var t=r.ampSpectrum;if("object"!=typeof t)throw new TypeError;var e=t,a=l(1,e),n=l(2,e),o=l(3,e),i=l(4,e);return(-3*Math.pow(a,4)+6*a*n-4*a*o+i)/Math.pow(Math.sqrt(n-Math.pow(a,2)),4)},amplitudeSpectrum:function(r){return r.ampSpectrum},zcr:function(r){var t=r.signal;if("object"!=typeof t)throw new TypeError;for(var e=0,a=1;a<t.length;a++)(t[a-1]>=0&&t[a]<0||t[a-1]<0&&t[a]>=0)&&e++;return e},loudness:s,perceptualSpread:function(r){for(var t=s({ampSpectrum:r.ampSpectrum,barkScale:r.barkScale}),e=0,a=0;a<t.specific.length;a++)t.specific[a]>e&&(e=t.specific[a]);return Math.pow((t.total-e)/t.total,2)},perceptualSharpness:function(r){for(var t=s({ampSpectrum:r.ampSpectrum,barkScale:r.barkScale}),e=t.specific,a=0,n=0;n<e.length;n++)a+=n<15?(n+1)*e[n+1]:.066*Math.exp(.171*(n+1));return a*=.11/t.total},powerSpectrum:m,mfcc:function(r){var t=r.ampSpectrum,e=r.melFilterBank,a=r.numberOfMFCCCoefficients,n=r.bufferSize,o=Math.min(40,Math.max(1,a||13));if(e.length<o)throw new Error("Insufficient filter bank for requested number of coefficients");var i=p({ampSpectrum:t,melFilterBank:e,bufferSize:n});return d(i).slice(0,o)},chroma:function(r){var t=r.ampSpectrum,e=r.chromaFilterBank;if("object"!=typeof t)throw new TypeError("Valid ampSpectrum is required to generate chroma");if("object"!=typeof e)throw new TypeError("Valid chromaFilterBank is required to generate chroma");var a=e.map((function(r,e){return t.reduce((function(t,e,a){return t+e*r[a]}),0)})),n=Math.max.apply(Math,a);return n?a.map((function(r){return r/n})):a},spectralFlux:function(r){var t=r.signal,e=r.previousSignal,a=r.bufferSize;if("object"!=typeof t||"object"!=typeof e)throw new TypeError;for(var n=0,o=-a/2;o<t.length/2-1;o++)x=Math.abs(t[o])-Math.abs(e[o]),n+=(x+Math.abs(x))/2;return n},spectralCrest:function(r){var t=r.ampSpectrum;if("object"!=typeof t)throw new TypeError;var e=0,a=-1/0;return t.forEach((function(r){e+=Math.pow(r,2),a=r>a?r:a})),e/=t.length,e=Math.sqrt(e),a/e},melBands:p});function S(r){if(Array.isArray(r)){for(var t=0,e=Array(r.length);t<r.length;t++)e[t]=r[t];return e}return Array.from(r)}var _={},b={},M={bitReverseArray:function(r){if(void 0===_[r]){for(var t=(r-1).toString(2).length,e="0".repeat(t),a={},n=0;n<r;n++){var o=n.toString(2);o=e.substr(o.length)+o,o=[].concat(S(o)).reverse().join(""),a[n]=parseInt(o,2)}_[r]=a}return _[r]},multiply:function(r,t){return{real:r.real*t.real-r.imag*t.imag,imag:r.real*t.imag+r.imag*t.real}},add:function(r,t){return{real:r.real+t.real,imag:r.imag+t.imag}},subtract:function(r,t){return{real:r.real-t.real,imag:r.imag-t.imag}},euler:function(r,t){var e=-2*Math.PI*r/t;return{real:Math.cos(e),imag:Math.sin(e)}},conj:function(r){return r.imag*=-1,r},constructComplexArray:function(r){var t={};t.real=void 0===r.real?r.slice():r.real.slice();var e=t.real.length;return void 0===b[e]&&(b[e]=Array.apply(null,Array(e)).map(Number.prototype.valueOf,0)),t.imag=b[e].slice(),t}},F=function(r){var t={};void 0===r.real||void 0===r.imag?t=M.constructComplexArray(r):(t.real=r.real.slice(),t.imag=r.imag.slice());var e=t.real.length,a=Math.log2(e);if(Math.round(a)!=a)throw new Error("Input size must be a power of 2.");if(t.real.length!=t.imag.length)throw new Error("Real and imaginary components must have the same length.");for(var n=M.bitReverseArray(e),o={real:[],imag:[]},i=0;i<e;i++)o.real[n[i]]=t.real[i],o.imag[n[i]]=t.imag[i];for(var u=0;u<e;u++)t.real[u]=o.real[u],t.imag[u]=o.imag[u];for(var f=1;f<=a;f++)for(var c=Math.pow(2,f),l=0;l<c/2;l++)for(var s=M.euler(l,c),m=0;m<e/c;m++){var p=c*m+l,h=c*m+l+c/2,g={real:t.real[p],imag:t.imag[p]},w={real:t.real[h],imag:t.imag[h]},v=M.multiply(s,w),d=M.subtract(g,v);t.real[h]=d.real,t.imag[h]=d.imag;var y=M.add(v,g);t.real[p]=y.real,t.imag[p]=y.imag}return t},A=F,E=function(){function r(r,t){var e=this;if(this._m=t,!r.audioContext)throw this._m.errors.noAC;if(r.bufferSize&&!a(r.bufferSize))throw this._m._errors.notPow2;if(!r.source)throw this._m._errors.noSource;this._m.audioContext=r.audioContext,this._m.bufferSize=r.bufferSize||this._m.bufferSize||256,this._m.hopSize=r.hopSize||this._m.hopSize||this._m.bufferSize,this._m.sampleRate=r.sampleRate||this._m.audioContext.sampleRate||44100,this._m.callback=r.callback,this._m.windowingFunction=r.windowingFunction||"hanning",this._m.featureExtractors=y,this._m.EXTRACTION_STARTED=r.startImmediately||!1,this._m.channel="number"==typeof r.channel?r.channel:0,this._m.inputs=r.inputs||1,this._m.outputs=r.outputs||1,this._m.numberOfMFCCCoefficients=r.numberOfMFCCCoefficients||this._m.numberOfMFCCCoefficients||13,this._m.numberOfBarkBands=r.numberOfBarkBands||this._m.numberOfBarkBands||24,this._m.spn=this._m.audioContext.createScriptProcessor(this._m.bufferSize,this._m.inputs,this._m.outputs),this._m.spn.connect(this._m.audioContext.destination),this._m._featuresToExtract=r.featureExtractors||[],this._m.barkScale=o(this._m.bufferSize,this._m.sampleRate,this._m.bufferSize),this._m.melFilterBank=f(Math.max(this._m.melBands,this._m.numberOfMFCCCoefficients),this._m.sampleRate,this._m.bufferSize),this._m.inputData=null,this._m.previousInputData=null,this._m.frame=null,this._m.previousFrame=null,this.setSource(r.source),this._m.spn.onaudioprocess=function(r){var t;null!==e._m.inputData&&(e._m.previousInputData=e._m.inputData),e._m.inputData=r.inputBuffer.getChannelData(e._m.channel),e._m.previousInputData?((t=new Float32Array(e._m.previousInputData.length+e._m.inputData.length-e._m.hopSize)).set(e._m.previousInputData.slice(e._m.hopSize)),t.set(e._m.inputData,e._m.previousInputData.length-e._m.hopSize)):t=e._m.inputData,function(r,t,e){if(r.length<t)throw new Error("Buffer is too short for frame length");if(e<1)throw new Error("Hop length cannot be less that 1");if(t<1)throw new Error("Frame length cannot be less that 1");var a=1+Math.floor((r.length-t)/e);return new Array(a).fill(0).map((function(a,n){return r.slice(n*e,n*e+t)}))}(t,e._m.bufferSize,e._m.hopSize).forEach((function(r){e._m.frame=r;var t=e._m.extract(e._m._featuresToExtract,e._m.frame,e._m.previousFrame);"function"==typeof e._m.callback&&e._m.EXTRACTION_STARTED&&e._m.callback(t),e._m.previousFrame=e._m.frame}))}}return r.prototype.start=function(r){this._m._featuresToExtract=r||this._m._featuresToExtract,this._m.EXTRACTION_STARTED=!0},r.prototype.stop=function(){this._m.EXTRACTION_STARTED=!1},r.prototype.setSource=function(r){this._m.source&&this._m.source.disconnect(this._m.spn),this._m.source=r,this._m.source.connect(this._m.spn)},r.prototype.setChannel=function(r){r<=this._m.inputs?this._m.channel=r:console.error("Channel ".concat(r," does not exist. Make sure you've provided a value for 'inputs' that is greater than ").concat(r," when instantiating the MeydaAnalyzer"))},r.prototype.get=function(r){return this._m.inputData?this._m.extract(r||this._m._featuresToExtract,this._m.inputData,this._m.previousInputData):null},r}(),C={audioContext:null,spn:null,bufferSize:512,sampleRate:44100,melBands:26,chromaBands:12,callback:null,windowingFunction:"hanning",featureExtractors:y,EXTRACTION_STARTED:!1,numberOfMFCCCoefficients:13,numberOfBarkBands:24,_featuresToExtract:[],windowing:n,_errors:{notPow2:new Error("Meyda: Buffer size must be a power of 2, e.g. 64 or 512"),featureUndef:new Error("Meyda: No features defined."),invalidFeatureFmt:new Error("Meyda: Invalid feature format"),invalidInput:new Error("Meyda: Invalid input."),noAC:new Error("Meyda: No AudioContext specified."),noSource:new Error("Meyda: No source node specified.")},createMeydaAnalyzer:function(r){return new E(r,Object.assign({},C))},listAvailableFeatureExtractors:function(){return Object.keys(this.featureExtractors)},extract:function(r,t,e){var n=this;if(!t)throw this._errors.invalidInput;if("object"!=typeof t)throw this._errors.invalidInput;if(!r)throw this._errors.featureUndef;if(!a(t.length))throw this._errors.notPow2;void 0!==this.barkScale&&this.barkScale.length==this.bufferSize||(this.barkScale=o(this.bufferSize,this.sampleRate,this.bufferSize)),void 0!==this.melFilterBank&&this.barkScale.length==this.bufferSize&&this.melFilterBank.length==this.melBands||(this.melFilterBank=f(Math.max(this.melBands,this.numberOfMFCCCoefficients),this.sampleRate,this.bufferSize)),void 0!==this.chromaFilterBank&&this.chromaFilterBank.length==this.chromaBands||(this.chromaFilterBank=c(this.chromaBands,this.sampleRate,this.bufferSize)),"buffer"in t&&void 0===t.buffer?this.signal=i(t):this.signal=t;var u=k(t,this.windowingFunction,this.bufferSize);if(this.signal=u.windowedSignal,this.complexSpectrum=u.complexSpectrum,this.ampSpectrum=u.ampSpectrum,e){var l=k(e,this.windowingFunction,this.bufferSize);this.previousSignal=l.windowedSignal,this.previousComplexSpectrum=l.complexSpectrum,this.previousAmpSpectrum=l.ampSpectrum}var s=function(r){return n.featureExtractors[r]({ampSpectrum:n.ampSpectrum,chromaFilterBank:n.chromaFilterBank,complexSpectrum:n.complexSpectrum,signal:n.signal,bufferSize:n.bufferSize,sampleRate:n.sampleRate,barkScale:n.barkScale,melFilterBank:n.melFilterBank,previousSignal:n.previousSignal,previousAmpSpectrum:n.previousAmpSpectrum,previousComplexSpectrum:n.previousComplexSpectrum,numberOfMFCCCoefficients:n.numberOfMFCCCoefficients,numberOfBarkBands:n.numberOfBarkBands})};if("object"==typeof r)return r.reduce((function(r,t){var e;return Object.assign({},r,((e={})[t]=s(t),e))}),{});if("string"==typeof r)return s(r);throw this._errors.invalidFeatureFmt}},k=function(r,t,e){var a={};void 0===r.buffer?a.signal=i(r):a.signal=r,a.windowedSignal=n(a.signal,t),a.complexSpectrum=A(a.windowedSignal),a.ampSpectrum=new Float32Array(e/2);for(var o=0;o<e/2;o++)a.ampSpectrum[o]=Math.sqrt(Math.pow(a.complexSpectrum.real[o],2)+Math.pow(a.complexSpectrum.imag[o],2));return a};return"undefined"!=typeof window&&(window.Meyda=C),C}));


},{}],85:[function(require,module,exports){
"use strict"

var pool = require("typedarray-pool")

module.exports = createSurfaceExtractor

//Helper macros
function array(i) {
  return "a" + i
}
function data(i) {
  return "d" + i
}
function cube(i,bitmask) {
  return "c" + i + "_" + bitmask
}
function shape(i) {
  return "s" + i
}
function stride(i,j) {
  return "t" + i + "_" + j
}
function offset(i) {
  return "o" + i
}
function scalar(i) {
  return "x" + i
}
function pointer(i) {
  return "p" + i
}
function delta(i,bitmask) {
  return "d" + i + "_" + bitmask
}
function index(i) {
  return "i" + i
}
function step(i,j) {
  return "u" + i + "_" + j
}
function pcube(bitmask) {
  return "b" + bitmask
}
function qcube(bitmask) {
  return "y" + bitmask
}
function pdelta(bitmask) {
  return "e" + bitmask
}
function vert(i) {
  return "v" + i
}
var VERTEX_IDS = "V"
var PHASES = "P"
var VERTEX_COUNT = "N"
var POOL_SIZE = "Q"
var POINTER = "X"
var TEMPORARY = "T"

function permBitmask(dimension, mask, order) {
  var r = 0
  for(var i=0; i<dimension; ++i) {
    if(mask & (1<<i)) {
      r |= (1<<order[i])
    }
  }
  return r
}

//Generates the surface procedure
function compileSurfaceProcedure(vertexFunc, faceFunc, phaseFunc, scalarArgs, order, typesig) {
  var arrayArgs = typesig.length
  var dimension = order.length

  if(dimension < 2) {
    throw new Error("ndarray-extract-contour: Dimension must be at least 2")
  }

  var funcName = "extractContour" + order.join("_")
  var code = []
  var vars = []
  var args = []

  //Assemble arguments
  for(var i=0; i<arrayArgs; ++i) {
    args.push(array(i))  
  }
  for(var i=0; i<scalarArgs; ++i) {
    args.push(scalar(i))
  }

  //Shape
  for(var i=0; i<dimension; ++i) {
    vars.push(shape(i) + "=" + array(0) + ".shape[" + i + "]|0")
  }
  //Data, stride, offset pointers
  for(var i=0; i<arrayArgs; ++i) {
    vars.push(data(i) + "=" + array(i) + ".data",
              offset(i) + "=" + array(i) + ".offset|0")
    for(var j=0; j<dimension; ++j) {
      vars.push(stride(i,j) + "=" + array(i) + ".stride[" + j + "]|0")
    }
  }
  //Pointer, delta and cube variables
  for(var i=0; i<arrayArgs; ++i) {
    vars.push(pointer(i) + "=" + offset(i))
    vars.push(cube(i,0))
    for(var j=1; j<(1<<dimension); ++j) {
      var ptrStr = []
      for(var k=0; k<dimension; ++k) {
        if(j & (1<<k)) {
          ptrStr.push("-" + stride(i,k))
        }
      }
      vars.push(delta(i,j) + "=(" + ptrStr.join("") + ")|0")
      vars.push(cube(i,j) + "=0")
    }
  }
  //Create step variables
  for(var i=0; i<arrayArgs; ++i) {
    for(var j=0; j<dimension; ++j) {
      var stepVal = [ stride(i,order[j]) ]
      if(j > 0) {
        stepVal.push(stride(i, order[j-1]) + "*" + shape(order[j-1]) )
      }
      vars.push(step(i,order[j]) + "=(" + stepVal.join("-") + ")|0")
    }
  }
  //Create index variables
  for(var i=0; i<dimension; ++i) {
    vars.push(index(i) + "=0")
  }
  //Vertex count
  vars.push(VERTEX_COUNT + "=0")
  //Compute pool size, initialize pool step
  var sizeVariable = ["2"]
  for(var i=dimension-2; i>=0; --i) {
    sizeVariable.push(shape(order[i]))
  }
  //Previous phases and vertex_ids
  vars.push(POOL_SIZE + "=(" + sizeVariable.join("*") + ")|0",
            PHASES + "=mallocUint32(" + POOL_SIZE + ")",
            VERTEX_IDS + "=mallocUint32(" + POOL_SIZE + ")",
            POINTER + "=0")
  //Create cube variables for phases
  vars.push(pcube(0) + "=0")
  for(var j=1; j<(1<<dimension); ++j) {
    var cubeDelta = []
    var cubeStep = [ ]
    for(var k=0; k<dimension; ++k) {
      if(j & (1<<k)) {
        if(cubeStep.length === 0) {
          cubeDelta.push("1")
        } else {
          cubeDelta.unshift(cubeStep.join("*"))
        }
      }
      cubeStep.push(shape(order[k]))
    }
    var signFlag = ""
    if(cubeDelta[0].indexOf(shape(order[dimension-2])) < 0) {
      signFlag = "-"
    }
    var jperm = permBitmask(dimension, j, order)
    vars.push(pdelta(jperm) + "=(-" + cubeDelta.join("-") + ")|0",
              qcube(jperm) + "=(" + signFlag + cubeDelta.join("-") + ")|0",
              pcube(jperm) + "=0")
  }
  vars.push(vert(0) + "=0", TEMPORARY + "=0")

  function forLoopBegin(i, start) {
    code.push("for(", index(order[i]), "=", start, ";",
      index(order[i]), "<", shape(order[i]), ";",
      "++", index(order[i]), "){")
  }

  function forLoopEnd(i) {
    for(var j=0; j<arrayArgs; ++j) {
      code.push(pointer(j), "+=", step(j,order[i]), ";")
    }
    code.push("}")
  }

  function fillEmptySlice(k) {
    for(var i=k-1; i>=0; --i) {
      forLoopBegin(i, 0) 
    }
    var phaseFuncArgs = []
    for(var i=0; i<arrayArgs; ++i) {
      if(typesig[i]) {
        phaseFuncArgs.push(data(i) + ".get(" + pointer(i) + ")")
      } else {
        phaseFuncArgs.push(data(i) + "[" + pointer(i) + "]")
      }
    }
    for(var i=0; i<scalarArgs; ++i) {
      phaseFuncArgs.push(scalar(i))
    }
    code.push(PHASES, "[", POINTER, "++]=phase(", phaseFuncArgs.join(), ");")
    for(var i=0; i<k; ++i) {
      forLoopEnd(i)
    }
    for(var j=0; j<arrayArgs; ++j) {
      code.push(pointer(j), "+=", step(j,order[k]), ";")
    }
  }

  function processGridCell(mask) {
    //Read in local data
    for(var i=0; i<arrayArgs; ++i) {
      if(typesig[i]) {
        code.push(cube(i,0), "=", data(i), ".get(", pointer(i), ");")
      } else {
        code.push(cube(i,0), "=", data(i), "[", pointer(i), "];")
      }
    }

    //Read in phase
    var phaseFuncArgs = []
    for(var i=0; i<arrayArgs; ++i) {
      phaseFuncArgs.push(cube(i,0))
    }
    for(var i=0; i<scalarArgs; ++i) {
      phaseFuncArgs.push(scalar(i))
    }
    
    code.push(pcube(0), "=", PHASES, "[", POINTER, "]=phase(", phaseFuncArgs.join(), ");")
    
    //Read in other cube data
    for(var j=1; j<(1<<dimension); ++j) {
      code.push(pcube(j), "=", PHASES, "[", POINTER, "+", pdelta(j), "];")
    }

    //Check for boundary crossing
    var vertexPredicate = []
    for(var j=1; j<(1<<dimension); ++j) {
      vertexPredicate.push("(" + pcube(0) + "!==" + pcube(j) + ")")
    }
    code.push("if(", vertexPredicate.join("||"), "){")

    //Read in boundary data
    var vertexArgs = []
    for(var i=0; i<dimension; ++i) {
      vertexArgs.push(index(i))
    }
    for(var i=0; i<arrayArgs; ++i) {
      vertexArgs.push(cube(i,0))
      for(var j=1; j<(1<<dimension); ++j) {
        if(typesig[i]) {
          code.push(cube(i,j), "=", data(i), ".get(", pointer(i), "+", delta(i,j), ");")
        } else {
          code.push(cube(i,j), "=", data(i), "[", pointer(i), "+", delta(i,j), "];")
        }
        vertexArgs.push(cube(i,j))
      }
    }
    for(var i=0; i<(1<<dimension); ++i) {
      vertexArgs.push(pcube(i))
    }
    for(var i=0; i<scalarArgs; ++i) {
      vertexArgs.push(scalar(i))
    }

    //Generate vertex
    code.push("vertex(", vertexArgs.join(), ");",
      vert(0), "=", VERTEX_IDS, "[", POINTER, "]=", VERTEX_COUNT, "++;")

    //Check for face crossings
    var base = (1<<dimension)-1
    var corner = pcube(base)
    for(var j=0; j<dimension; ++j) {
      if((mask & ~(1<<j))===0) {
        //Check face
        var subset = base^(1<<j)
        var edge = pcube(subset)
        var faceArgs = [ ]
        for(var k=subset; k>0; k=(k-1)&subset) {
          faceArgs.push(VERTEX_IDS + "[" + POINTER + "+" + pdelta(k) + "]")
        }
        faceArgs.push(vert(0))
        for(var k=0; k<arrayArgs; ++k) {
          if(j&1) {
            faceArgs.push(cube(k,base), cube(k,subset))
          } else {
            faceArgs.push(cube(k,subset), cube(k,base))
          }
        }
        if(j&1) {
          faceArgs.push(corner, edge)
        } else {
          faceArgs.push(edge, corner)
        }
        for(var k=0; k<scalarArgs; ++k) {
          faceArgs.push(scalar(k))
        }
        code.push("if(", corner, "!==", edge, "){",
          "face(", faceArgs.join(), ")}")
      }
    }
    
    //Increment pointer, close off if statement
    code.push("}",
      POINTER, "+=1;")
  }

  function flip() {
    for(var j=1; j<(1<<dimension); ++j) {
      code.push(TEMPORARY, "=", pdelta(j), ";",
                pdelta(j), "=", qcube(j), ";",
                qcube(j), "=", TEMPORARY, ";")
    }
  }

  function createLoop(i, mask) {
    if(i < 0) {
      processGridCell(mask)
      return
    }
    fillEmptySlice(i)
    code.push("if(", shape(order[i]), ">0){",
      index(order[i]), "=1;")
    createLoop(i-1, mask|(1<<order[i]))

    for(var j=0; j<arrayArgs; ++j) {
      code.push(pointer(j), "+=", step(j,order[i]), ";")
    }
    if(i === dimension-1) {
      code.push(POINTER, "=0;")
      flip()
    }
    forLoopBegin(i, 2)
    createLoop(i-1, mask)
    if(i === dimension-1) {
      code.push("if(", index(order[dimension-1]), "&1){",
        POINTER, "=0;}")
      flip()
    }
    forLoopEnd(i)
    code.push("}")
  }

  createLoop(dimension-1, 0)

  //Release scratch memory
  code.push("freeUint32(", VERTEX_IDS, ");freeUint32(", PHASES, ");")

  //Compile and link procedure
  var procedureCode = [
    "'use strict';",
    "function ", funcName, "(", args.join(), "){",
      "var ", vars.join(), ";",
      code.join(""),
    "}",
    "return ", funcName ].join("")

  var proc = new Function(
    "vertex", 
    "face", 
    "phase", 
    "mallocUint32", 
    "freeUint32",
    procedureCode)
  return proc(
    vertexFunc, 
    faceFunc, 
    phaseFunc, 
    pool.mallocUint32, 
    pool.freeUint32)
}

function createSurfaceExtractor(args) {
  function error(msg) {
    throw new Error("ndarray-extract-contour: " + msg)
  }
  if(typeof args !== "object") {
    error("Must specify arguments")
  }
  var order = args.order
  if(!Array.isArray(order)) {
    error("Must specify order")
  }
  var arrays = args.arrayArguments||1
  if(arrays < 1) {
    error("Must have at least one array argument")
  }
  var scalars = args.scalarArguments||0
  if(scalars < 0) {
    error("Scalar arg count must be > 0")
  }
  if(typeof args.vertex !== "function") {
    error("Must specify vertex creation function")
  }
  if(typeof args.cell !== "function") {
    error("Must specify cell creation function")
  }
  if(typeof args.phase !== "function") {
    error("Must specify phase function")
  }
  var getters = args.getters || []
  var typesig = new Array(arrays)
  for(var i=0; i<arrays; ++i) {
    if(getters.indexOf(i) >= 0) {
      typesig[i] = true
    } else {
      typesig[i] = false
    }
  }
  return compileSurfaceProcedure(
    args.vertex,
    args.cell,
    args.phase,
    scalars,
    order,
    typesig)
}
},{"typedarray-pool":180}],86:[function(require,module,exports){
var iota = require("iota-array")
var isBuffer = require("is-buffer")

var hasTypedArrays  = ((typeof Float64Array) !== "undefined")

function compare1st(a, b) {
  return a[0] - b[0]
}

function order() {
  var stride = this.stride
  var terms = new Array(stride.length)
  var i
  for(i=0; i<terms.length; ++i) {
    terms[i] = [Math.abs(stride[i]), i]
  }
  terms.sort(compare1st)
  var result = new Array(terms.length)
  for(i=0; i<result.length; ++i) {
    result[i] = terms[i][1]
  }
  return result
}

function compileConstructor(dtype, dimension) {
  var className = ["View", dimension, "d", dtype].join("")
  if(dimension < 0) {
    className = "View_Nil" + dtype
  }
  var useGetters = (dtype === "generic")

  if(dimension === -1) {
    //Special case for trivial arrays
    var code =
      "function "+className+"(a){this.data=a;};\
var proto="+className+".prototype;\
proto.dtype='"+dtype+"';\
proto.index=function(){return -1};\
proto.size=0;\
proto.dimension=-1;\
proto.shape=proto.stride=proto.order=[];\
proto.lo=proto.hi=proto.transpose=proto.step=\
function(){return new "+className+"(this.data);};\
proto.get=proto.set=function(){};\
proto.pick=function(){return null};\
return function construct_"+className+"(a){return new "+className+"(a);}"
    var procedure = new Function(code)
    return procedure()
  } else if(dimension === 0) {
    //Special case for 0d arrays
    var code =
      "function "+className+"(a,d) {\
this.data = a;\
this.offset = d\
};\
var proto="+className+".prototype;\
proto.dtype='"+dtype+"';\
proto.index=function(){return this.offset};\
proto.dimension=0;\
proto.size=1;\
proto.shape=\
proto.stride=\
proto.order=[];\
proto.lo=\
proto.hi=\
proto.transpose=\
proto.step=function "+className+"_copy() {\
return new "+className+"(this.data,this.offset)\
};\
proto.pick=function "+className+"_pick(){\
return TrivialArray(this.data);\
};\
proto.valueOf=proto.get=function "+className+"_get(){\
return "+(useGetters ? "this.data.get(this.offset)" : "this.data[this.offset]")+
"};\
proto.set=function "+className+"_set(v){\
return "+(useGetters ? "this.data.set(this.offset,v)" : "this.data[this.offset]=v")+"\
};\
return function construct_"+className+"(a,b,c,d){return new "+className+"(a,d)}"
    var procedure = new Function("TrivialArray", code)
    return procedure(CACHED_CONSTRUCTORS[dtype][0])
  }

  var code = ["'use strict'"]

  //Create constructor for view
  var indices = iota(dimension)
  var args = indices.map(function(i) { return "i"+i })
  var index_str = "this.offset+" + indices.map(function(i) {
        return "this.stride[" + i + "]*i" + i
      }).join("+")
  var shapeArg = indices.map(function(i) {
      return "b"+i
    }).join(",")
  var strideArg = indices.map(function(i) {
      return "c"+i
    }).join(",")
  code.push(
    "function "+className+"(a," + shapeArg + "," + strideArg + ",d){this.data=a",
      "this.shape=[" + shapeArg + "]",
      "this.stride=[" + strideArg + "]",
      "this.offset=d|0}",
    "var proto="+className+".prototype",
    "proto.dtype='"+dtype+"'",
    "proto.dimension="+dimension)

  //view.size:
  code.push("Object.defineProperty(proto,'size',{get:function "+className+"_size(){\
return "+indices.map(function(i) { return "this.shape["+i+"]" }).join("*"),
"}})")

  //view.order:
  if(dimension === 1) {
    code.push("proto.order=[0]")
  } else {
    code.push("Object.defineProperty(proto,'order',{get:")
    if(dimension < 4) {
      code.push("function "+className+"_order(){")
      if(dimension === 2) {
        code.push("return (Math.abs(this.stride[0])>Math.abs(this.stride[1]))?[1,0]:[0,1]}})")
      } else if(dimension === 3) {
        code.push(
"var s0=Math.abs(this.stride[0]),s1=Math.abs(this.stride[1]),s2=Math.abs(this.stride[2]);\
if(s0>s1){\
if(s1>s2){\
return [2,1,0];\
}else if(s0>s2){\
return [1,2,0];\
}else{\
return [1,0,2];\
}\
}else if(s0>s2){\
return [2,0,1];\
}else if(s2>s1){\
return [0,1,2];\
}else{\
return [0,2,1];\
}}})")
      }
    } else {
      code.push("ORDER})")
    }
  }

  //view.set(i0, ..., v):
  code.push(
"proto.set=function "+className+"_set("+args.join(",")+",v){")
  if(useGetters) {
    code.push("return this.data.set("+index_str+",v)}")
  } else {
    code.push("return this.data["+index_str+"]=v}")
  }

  //view.get(i0, ...):
  code.push("proto.get=function "+className+"_get("+args.join(",")+"){")
  if(useGetters) {
    code.push("return this.data.get("+index_str+")}")
  } else {
    code.push("return this.data["+index_str+"]}")
  }

  //view.index:
  code.push(
    "proto.index=function "+className+"_index(", args.join(), "){return "+index_str+"}")

  //view.hi():
  code.push("proto.hi=function "+className+"_hi("+args.join(",")+"){return new "+className+"(this.data,"+
    indices.map(function(i) {
      return ["(typeof i",i,"!=='number'||i",i,"<0)?this.shape[", i, "]:i", i,"|0"].join("")
    }).join(",")+","+
    indices.map(function(i) {
      return "this.stride["+i + "]"
    }).join(",")+",this.offset)}")

  //view.lo():
  var a_vars = indices.map(function(i) { return "a"+i+"=this.shape["+i+"]" })
  var c_vars = indices.map(function(i) { return "c"+i+"=this.stride["+i+"]" })
  code.push("proto.lo=function "+className+"_lo("+args.join(",")+"){var b=this.offset,d=0,"+a_vars.join(",")+","+c_vars.join(","))
  for(var i=0; i<dimension; ++i) {
    code.push(
"if(typeof i"+i+"==='number'&&i"+i+">=0){\
d=i"+i+"|0;\
b+=c"+i+"*d;\
a"+i+"-=d}")
  }
  code.push("return new "+className+"(this.data,"+
    indices.map(function(i) {
      return "a"+i
    }).join(",")+","+
    indices.map(function(i) {
      return "c"+i
    }).join(",")+",b)}")

  //view.step():
  code.push("proto.step=function "+className+"_step("+args.join(",")+"){var "+
    indices.map(function(i) {
      return "a"+i+"=this.shape["+i+"]"
    }).join(",")+","+
    indices.map(function(i) {
      return "b"+i+"=this.stride["+i+"]"
    }).join(",")+",c=this.offset,d=0,ceil=Math.ceil")
  for(var i=0; i<dimension; ++i) {
    code.push(
"if(typeof i"+i+"==='number'){\
d=i"+i+"|0;\
if(d<0){\
c+=b"+i+"*(a"+i+"-1);\
a"+i+"=ceil(-a"+i+"/d)\
}else{\
a"+i+"=ceil(a"+i+"/d)\
}\
b"+i+"*=d\
}")
  }
  code.push("return new "+className+"(this.data,"+
    indices.map(function(i) {
      return "a" + i
    }).join(",")+","+
    indices.map(function(i) {
      return "b" + i
    }).join(",")+",c)}")

  //view.transpose():
  var tShape = new Array(dimension)
  var tStride = new Array(dimension)
  for(var i=0; i<dimension; ++i) {
    tShape[i] = "a[i"+i+"]"
    tStride[i] = "b[i"+i+"]"
  }
  code.push("proto.transpose=function "+className+"_transpose("+args+"){"+
    args.map(function(n,idx) { return n + "=(" + n + "===undefined?" + idx + ":" + n + "|0)"}).join(";"),
    "var a=this.shape,b=this.stride;return new "+className+"(this.data,"+tShape.join(",")+","+tStride.join(",")+",this.offset)}")

  //view.pick():
  code.push("proto.pick=function "+className+"_pick("+args+"){var a=[],b=[],c=this.offset")
  for(var i=0; i<dimension; ++i) {
    code.push("if(typeof i"+i+"==='number'&&i"+i+">=0){c=(c+this.stride["+i+"]*i"+i+")|0}else{a.push(this.shape["+i+"]);b.push(this.stride["+i+"])}")
  }
  code.push("var ctor=CTOR_LIST[a.length+1];return ctor(this.data,a,b,c)}")

  //Add return statement
  code.push("return function construct_"+className+"(data,shape,stride,offset){return new "+className+"(data,"+
    indices.map(function(i) {
      return "shape["+i+"]"
    }).join(",")+","+
    indices.map(function(i) {
      return "stride["+i+"]"
    }).join(",")+",offset)}")

  //Compile procedure
  var procedure = new Function("CTOR_LIST", "ORDER", code.join("\n"))
  return procedure(CACHED_CONSTRUCTORS[dtype], order)
}

function arrayDType(data) {
  if(isBuffer(data)) {
    return "buffer"
  }
  if(hasTypedArrays) {
    switch(Object.prototype.toString.call(data)) {
      case "[object Float64Array]":
        return "float64"
      case "[object Float32Array]":
        return "float32"
      case "[object Int8Array]":
        return "int8"
      case "[object Int16Array]":
        return "int16"
      case "[object Int32Array]":
        return "int32"
      case "[object Uint8Array]":
        return "uint8"
      case "[object Uint16Array]":
        return "uint16"
      case "[object Uint32Array]":
        return "uint32"
      case "[object Uint8ClampedArray]":
        return "uint8_clamped"
      case "[object BigInt64Array]":
        return "bigint64"
      case "[object BigUint64Array]":
        return "biguint64"
    }
  }
  if(Array.isArray(data)) {
    return "array"
  }
  return "generic"
}

var CACHED_CONSTRUCTORS = {
  "float32":[],
  "float64":[],
  "int8":[],
  "int16":[],
  "int32":[],
  "uint8":[],
  "uint16":[],
  "uint32":[],
  "array":[],
  "uint8_clamped":[],
  "bigint64": [],
  "biguint64": [],
  "buffer":[],
  "generic":[]
}

;(function() {
  for(var id in CACHED_CONSTRUCTORS) {
    CACHED_CONSTRUCTORS[id].push(compileConstructor(id, -1))
  }
});

function wrappedNDArrayCtor(data, shape, stride, offset) {
  if(data === undefined) {
    var ctor = CACHED_CONSTRUCTORS.array[0]
    return ctor([])
  } else if(typeof data === "number") {
    data = [data]
  }
  if(shape === undefined) {
    shape = [ data.length ]
  }
  var d = shape.length
  if(stride === undefined) {
    stride = new Array(d)
    for(var i=d-1, sz=1; i>=0; --i) {
      stride[i] = sz
      sz *= shape[i]
    }
  }
  if(offset === undefined) {
    offset = 0
    for(var i=0; i<d; ++i) {
      if(stride[i] < 0) {
        offset -= (shape[i]-1)*stride[i]
      }
    }
  }
  var dtype = arrayDType(data)
  var ctor_list = CACHED_CONSTRUCTORS[dtype]
  while(ctor_list.length <= d+1) {
    ctor_list.push(compileConstructor(dtype, ctor_list.length-1))
  }
  var ctor = ctor_list[d+1]
  return ctor(data, shape, stride, offset)
}

module.exports = wrappedNDArrayCtor

},{"iota-array":82,"is-buffer":83}],87:[function(require,module,exports){
"use strict"

var doubleBits = require("double-bits")

var SMALLEST_DENORM = Math.pow(2, -1074)
var UINT_MAX = (-1)>>>0

module.exports = nextafter

function nextafter(x, y) {
  if(isNaN(x) || isNaN(y)) {
    return NaN
  }
  if(x === y) {
    return x
  }
  if(x === 0) {
    if(y < 0) {
      return -SMALLEST_DENORM
    } else {
      return SMALLEST_DENORM
    }
  }
  var hi = doubleBits.hi(x)
  var lo = doubleBits.lo(x)
  if((y > x) === (x > 0)) {
    if(lo === UINT_MAX) {
      hi += 1
      lo = 0
    } else {
      lo += 1
    }
  } else {
    if(lo === 0) {
      lo = UINT_MAX
      hi -= 1
    } else {
      lo -= 1
    }
  }
  return doubleBits.pack(lo, hi)
}
},{"double-bits":42}],88:[function(require,module,exports){
(function (process){(function (){
// Generated by CoffeeScript 1.12.2
(function() {
  var getNanoSeconds, hrtime, loadTime, moduleLoadTime, nodeLoadTime, upTime;

  if ((typeof performance !== "undefined" && performance !== null) && performance.now) {
    module.exports = function() {
      return performance.now();
    };
  } else if ((typeof process !== "undefined" && process !== null) && process.hrtime) {
    module.exports = function() {
      return (getNanoSeconds() - nodeLoadTime) / 1e6;
    };
    hrtime = process.hrtime;
    getNanoSeconds = function() {
      var hr;
      hr = hrtime();
      return hr[0] * 1e9 + hr[1];
    };
    moduleLoadTime = getNanoSeconds();
    upTime = process.uptime() * 1e9;
    nodeLoadTime = moduleLoadTime - upTime;
  } else if (Date.now) {
    module.exports = function() {
      return Date.now() - loadTime;
    };
    loadTime = Date.now();
  } else {
    module.exports = function() {
      return new Date().getTime() - loadTime;
    };
    loadTime = new Date().getTime();
  }

}).call(this);



}).call(this)}).call(this,require('_process'))

},{"_process":95}],89:[function(require,module,exports){
"use strict"

module.exports = permutationSign

var BRUTE_FORCE_CUTOFF = 32

var pool = require("typedarray-pool")

function permutationSign(p) {
  var n = p.length
  if(n < BRUTE_FORCE_CUTOFF) {
    //Use quadratic algorithm for small n
    var sgn = 1
    for(var i=0; i<n; ++i) {
      for(var j=0; j<i; ++j) {
        if(p[i] < p[j]) {
          sgn = -sgn
        } else if(p[i] === p[j]) {
          return 0
        }
      }
    }
    return sgn
  } else {
    //Otherwise use linear time algorithm
    var visited = pool.mallocUint8(n)
    for(var i=0; i<n; ++i) {
      visited[i] = 0
    }
    var sgn = 1
    for(var i=0; i<n; ++i) {
      if(!visited[i]) {
        var count = 1
        visited[i] = 1
        for(var j=p[i]; j!==i; j=p[j]) {
          if(visited[j]) {
            pool.freeUint8(visited)
            return 0
          }
          count += 1
          visited[j] = 1
        }
        if(!(count & 1)) {
          sgn = -sgn
        }
      }
    }
    pool.freeUint8(visited)
    return sgn
  }
}
},{"typedarray-pool":180}],90:[function(require,module,exports){
"use strict"

var pool = require("typedarray-pool")
var inverse = require("invert-permutation")

function rank(permutation) {
  var n = permutation.length
  switch(n) {
    case 0:
    case 1:
      return 0
    case 2:
      return permutation[1]
    default:
      break
  }
  var p = pool.mallocUint32(n)
  var pinv = pool.mallocUint32(n)
  var r = 0, s, t, i
  inverse(permutation, pinv)
  for(i=0; i<n; ++i) {
    p[i] = permutation[i]
  }
  for(i=n-1; i>0; --i) {
    t = pinv[i]
    s = p[i]
    p[i] = p[t]
    p[t] = s
    pinv[i] = pinv[s]
    pinv[s] = t
    r = (r + s) * i
  }
  pool.freeUint32(pinv)
  pool.freeUint32(p)
  return r
}

function unrank(n, r, p) {
  switch(n) {
    case 0:
      if(p) { return p }
      return []
    case 1:
      if(p) {
        p[0] = 0
        return p
      } else {
        return [0]
      }
    case 2:
      if(p) {
        if(r) {
          p[0] = 0
          p[1] = 1
        } else {
          p[0] = 1
          p[1] = 0
        }
        return p
      } else {
        return r ? [0,1] : [1,0]
      }
    default:
      break
  }
  p = p || new Array(n)
  var s, t, i, nf=1
  p[0] = 0
  for(i=1; i<n; ++i) {
    p[i] = i
    nf = (nf*i)|0
  }
  for(i=n-1; i>0; --i) {
    s = (r / nf)|0
    r = (r - s * nf)|0
    nf = (nf / i)|0
    t = p[i]|0
    p[i] = p[s]|0
    p[s] = t|0
  }
  return p
}

exports.rank = rank
exports.unrank = unrank

},{"invert-permutation":81,"typedarray-pool":180}],91:[function(require,module,exports){
"use strict"

module.exports = planarDual

var compareAngle = require("compare-angle")

function planarDual(cells, positions) {

  var numVertices = positions.length|0
  var numEdges = cells.length
  var adj = [new Array(numVertices), new Array(numVertices)]
  for(var i=0; i<numVertices; ++i) {
    adj[0][i] = []
    adj[1][i] = []
  }
  for(var i=0; i<numEdges; ++i) {
    var c = cells[i]
    adj[0][c[0]].push(c)
    adj[1][c[1]].push(c)
  }

  var cycles = []

  //Add isolated vertices as trivial case
  for(var i=0; i<numVertices; ++i) {
    if(adj[0][i].length + adj[1][i].length === 0) {
      cycles.push( [i] )
    }
  }

  //Remove a half edge
  function cut(c, i) {
    var a = adj[i][c[i]]
    a.splice(a.indexOf(c), 1)
  }

  //Find next vertex and cut edge
  function next(a, b, noCut) {
    var nextCell, nextVertex, nextDir
    for(var i=0; i<2; ++i) {
      if(adj[i][b].length > 0) {
        nextCell = adj[i][b][0]
        nextDir = i
        break
      }
    }
    nextVertex = nextCell[nextDir^1]

    for(var dir=0; dir<2; ++dir) {
      var nbhd = adj[dir][b]
      for(var k=0; k<nbhd.length; ++k) {
        var e = nbhd[k]
        var p = e[dir^1]
        var cmp = compareAngle(
            positions[a], 
            positions[b], 
            positions[nextVertex],
            positions[p])
        if(cmp > 0) {
          nextCell = e
          nextVertex = p
          nextDir = dir
        }
      }
    }
    if(noCut) {
      return nextVertex
    }
    if(nextCell) {
      cut(nextCell, nextDir)
    }
    return nextVertex
  }

  function extractCycle(v, dir) {
    var e0 = adj[dir][v][0]
    var cycle = [v]
    cut(e0, dir)
    var u = e0[dir^1]
    var d0 = dir
    while(true) {
      while(u !== v) {
        cycle.push(u)
        u = next(cycle[cycle.length-2], u, false)
      }
      if(adj[0][v].length + adj[1][v].length === 0) {
        break
      }
      var a = cycle[cycle.length-1]
      var b = v
      var c = cycle[1]
      var d = next(a, b, true)
      if(compareAngle(positions[a], positions[b], positions[c], positions[d]) < 0) {
        break
      }
      cycle.push(v)
      u = next(a, b)
    }
    return cycle
  }

  function shouldGlue(pcycle, ncycle) {
    return (ncycle[1] === ncycle[ncycle.length-1])
  }

  for(var i=0; i<numVertices; ++i) {
    for(var j=0; j<2; ++j) {
      var pcycle = []
      while(adj[j][i].length > 0) {
        var ni = adj[0][i].length
        var ncycle = extractCycle(i,j)
        if(shouldGlue(pcycle, ncycle)) {
          //Glue together trivial cycles
          pcycle.push.apply(pcycle, ncycle)
        } else {
          if(pcycle.length > 0) {
            cycles.push(pcycle)
          }
          pcycle = ncycle
        }
      }
      if(pcycle.length > 0) {
        cycles.push(pcycle)
      }
    }
  }

  //Combine paths and loops together
  return cycles
}
},{"compare-angle":38}],92:[function(require,module,exports){
'use strict'

module.exports = trimLeaves

var e2a = require('edges-to-adjacency-list')

function trimLeaves(edges, positions) {
  var adj = e2a(edges, positions.length)
  var live = new Array(positions.length)
  var nbhd = new Array(positions.length)

  var dead = []
  for(var i=0; i<positions.length; ++i) {
    var count = adj[i].length
    nbhd[i] = count
    live[i] = true
    if(count <= 1) {
      dead.push(i)
    }
  }

  while(dead.length > 0) {
    var v = dead.pop()
    live[v] = false
    var n = adj[v]
    for(var i=0; i<n.length; ++i) {
      var u = n[i]
      if(--nbhd[u] === 0) {
        dead.push(u)
      }
    }
  }

  var newIndex = new Array(positions.length)
  var npositions = []
  for(var i=0; i<positions.length; ++i) {
    if(live[i]) {
      var v = npositions.length
      newIndex[i] = v
      npositions.push(positions[i])
    } else {
      newIndex[i] = -1
    }
  }

  var nedges = []
  for(var i=0; i<edges.length; ++i) {
    var e = edges[i]
    if(live[e[0]] && live[e[1]]) {
      nedges.push([ newIndex[e[0]], newIndex[e[1]] ])
    }
  }
  
  return [ nedges, npositions ]
}
},{"edges-to-adjacency-list":44}],93:[function(require,module,exports){
'use strict'

module.exports = planarGraphToPolyline

var e2a = require('edges-to-adjacency-list')
var planarDual = require('planar-dual')
var preprocessPolygon = require('point-in-big-polygon')
var twoProduct = require('two-product')
var robustSum = require('robust-sum')
var uniq = require('uniq')
var trimLeaves = require('./lib/trim-leaves')

function makeArray(length, fill) {
  var result = new Array(length)
  for(var i=0; i<length; ++i) {
    result[i] = fill
  }
  return result
}

function makeArrayOfArrays(length) {
  var result = new Array(length)
  for(var i=0; i<length; ++i) {
    result[i] = []
  }
  return result
}


function planarGraphToPolyline(edges, positions) {

  //Trim leaves
  var result = trimLeaves(edges, positions)
  edges = result[0]
  positions = result[1]

  var numVertices = positions.length
  var numEdges = edges.length

  //Calculate adjacency list, check manifold
  var adj = e2a(edges, positions.length)
  for(var i=0; i<numVertices; ++i) {
    if(adj[i].length % 2 === 1) {
      throw new Error('planar-graph-to-polyline: graph must be manifold')
    }
  }

  //Get faces
  var faces = planarDual(edges, positions)

  //Check orientation of a polygon using exact arithmetic
  function ccw(c) {
    var n = c.length
    var area = [0]
    for(var j=0; j<n; ++j) {
      var a = positions[c[j]]
      var b = positions[c[(j+1)%n]]
      var t00 = twoProduct(-a[0], a[1])
      var t01 = twoProduct(-a[0], b[1])
      var t10 = twoProduct( b[0], a[1])
      var t11 = twoProduct( b[0], b[1])
      area = robustSum(area, robustSum(robustSum(t00, t01), robustSum(t10, t11)))
    }
    return area[area.length-1] > 0
  }

  //Extract all clockwise faces
  faces = faces.filter(ccw)

  //Detect which loops are contained in one another to handle parent-of relation
  var numFaces = faces.length
  var parent = new Array(numFaces)
  var containment = new Array(numFaces)
  for(var i=0; i<numFaces; ++i) {
    parent[i] = i
    var row = new Array(numFaces)
    var loopVertices = faces[i].map(function(v) {
      return positions[v]
    })
    var pmc = preprocessPolygon([loopVertices])
    var count = 0
    outer:
    for(var j=0; j<numFaces; ++j) {
      row[j] = 0
      if(i === j) {
        continue
      }
      var c = faces[j]
      var n = c.length
      for(var k=0; k<n; ++k) {
        var d = pmc(positions[c[k]])
        if(d !== 0) {
          if(d < 0) {
            row[j] = 1
            count += 1
          }
          continue outer
        }
      }
      row[j] = 1
      count += 1
    }
    containment[i] = [count, i, row]
  }
  containment.sort(function(a,b) {
    return b[0] - a[0]
  })
  for(var i=0; i<numFaces; ++i) {
    var row = containment[i]
    var idx = row[1]
    var children = row[2]
    for(var j=0; j<numFaces; ++j) {
      if(children[j]) {
        parent[j] = idx
      }
    }
  }

  //Initialize face adjacency list
  var fadj = makeArrayOfArrays(numFaces)
  for(var i=0; i<numFaces; ++i) {
    fadj[i].push(parent[i])
    fadj[parent[i]].push(i)
  }

  //Build adjacency matrix for edges
  var edgeAdjacency = {}
  var internalVertices = makeArray(numVertices, false)
  for(var i=0; i<numFaces; ++i) {
    var c = faces[i]
    var n = c.length
    for(var j=0; j<n; ++j) {
      var a = c[j]
      var b = c[(j+1)%n]
      var key = Math.min(a,b) + ":" + Math.max(a,b)
      if(key in edgeAdjacency) {
        var neighbor = edgeAdjacency[key]
        fadj[neighbor].push(i)
        fadj[i].push(neighbor)
        internalVertices[a] = internalVertices[b] = true
      } else {
        edgeAdjacency[key] = i
      }
    }
  }

  function sharedBoundary(c) {
    var n = c.length
    for(var i=0; i<n; ++i) {
      if(!internalVertices[c[i]]) {
        return false
      }
    }
    return true
  }

  var toVisit = []
  var parity = makeArray(numFaces, -1)
  for(var i=0; i<numFaces; ++i) {
    if(parent[i] === i && !sharedBoundary(faces[i])) {
      toVisit.push(i)
      parity[i] = 0
    } else {
      parity[i] = -1
    }
  }

  //Using face adjacency, classify faces as in/out
  var result = []
  while(toVisit.length > 0) {
    var top = toVisit.pop()
    var nbhd = fadj[top]
    uniq(nbhd, function(a,b) {
      return a-b
    })
    var nnbhr = nbhd.length
    var p = parity[top]
    var polyline
    if(p === 0) {
      var c = faces[top]
      polyline = [c]
    }
    for(var i=0; i<nnbhr; ++i) {
      var f = nbhd[i]
      if(parity[f] >= 0) {
        continue
      }
      parity[f] = p^1
      toVisit.push(f)
      if(p === 0) {
        var c = faces[f]
        if(!sharedBoundary(c)) {
          c.reverse()
          polyline.push(c)
        }
      }
    }
    if(p === 0) {
      result.push(polyline)
    }
  }

  return result
}
},{"./lib/trim-leaves":92,"edges-to-adjacency-list":44,"planar-dual":91,"point-in-big-polygon":94,"robust-sum":110,"two-product":178,"uniq":182}],94:[function(require,module,exports){
module.exports = preprocessPolygon

var orient = require('robust-orientation')[3]
var makeSlabs = require('slab-decomposition')
var makeIntervalTree = require('interval-tree-1d')
var bsearch = require('binary-search-bounds')

function visitInterval() {
  return true
}

function intervalSearch(table) {
  return function(x, y) {
    var tree = table[x]
    if(tree) {
      return !!tree.queryPoint(y, visitInterval)
    }
    return false
  }
}

function buildVerticalIndex(segments) {
  var table = {}
  for(var i=0; i<segments.length; ++i) {
    var s = segments[i]
    var x = s[0][0]
    var y0 = s[0][1]
    var y1 = s[1][1]
    var p = [ Math.min(y0, y1), Math.max(y0, y1) ]
    if(x in table) {
      table[x].push(p)
    } else {
      table[x] = [ p ]
    }
  }
  var intervalTable = {}
  var keys = Object.keys(table)
  for(var i=0; i<keys.length; ++i) {
    var segs = table[keys[i]]
    intervalTable[keys[i]] = makeIntervalTree(segs)
  }
  return intervalSearch(intervalTable)
}

function buildSlabSearch(slabs, coordinates) {
  return function(p) {
    var bucket = bsearch.le(coordinates, p[0])
    if(bucket < 0) {
      return 1
    }
    var root = slabs[bucket]
    if(!root) {
      if(bucket > 0 && coordinates[bucket] === p[0]) {
        root = slabs[bucket-1]
      } else {
        return 1
      }
    }
    var lastOrientation = 1
    while(root) {
      var s = root.key
      var o = orient(p, s[0], s[1])
      if(s[0][0] < s[1][0]) {
        if(o < 0) {
          root = root.left
        } else if(o > 0) {
          lastOrientation = -1
          root = root.right
        } else {
          return 0
        }
      } else {
        if(o > 0) {
          root = root.left
        } else if(o < 0) {
          lastOrientation = 1
          root = root.right
        } else {
          return 0
        }
      }
    }
    return lastOrientation
  }
}

function classifyEmpty(p) {
  return 1
}

function createClassifyVertical(testVertical) {
  return function classify(p) {
    if(testVertical(p[0], p[1])) {
      return 0
    }
    return 1
  }
}

function createClassifyPointDegen(testVertical, testNormal) {
  return function classify(p) {
    if(testVertical(p[0], p[1])) {
      return 0
    }
    return testNormal(p)
  }
}

function preprocessPolygon(loops) {
  //Compute number of loops
  var numLoops = loops.length

  //Unpack segments
  var segments = []
  var vsegments = []
  var ptr = 0
  for(var i=0; i<numLoops; ++i) {
    var loop = loops[i]
    var numVertices = loop.length
    for(var s=numVertices-1,t=0; t<numVertices; s=(t++)) {
      var a = loop[s]
      var b = loop[t]
      if(a[0] === b[0]) {
        vsegments.push([a,b])
      } else {
        segments.push([a,b])
      }
    }
  }

  //Degenerate case: All loops are empty
  if(segments.length === 0) {
    if(vsegments.length === 0) {
      return classifyEmpty
    } else {
      return createClassifyVertical(buildVerticalIndex(vsegments))
    }
  }

  //Build slab decomposition
  var slabs = makeSlabs(segments)
  var testSlab = buildSlabSearch(slabs.slabs, slabs.coordinates)

  if(vsegments.length === 0) {
    return testSlab
  } else {
    return createClassifyPointDegen(
      buildVerticalIndex(vsegments),
      testSlab)
  }
}
},{"binary-search-bounds":19,"interval-tree-1d":80,"robust-orientation":105,"slab-decomposition":117}],95:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],96:[function(require,module,exports){
var inherits = require('inherits')
var EventEmitter = require('events').EventEmitter
var now = require('right-now')
var raf = require('raf')

module.exports = Engine
function Engine(fn) {
    if (!(this instanceof Engine)) 
        return new Engine(fn)
    this.running = false
    this.last = now()
    this._frame = 0
    this._tick = this.tick.bind(this)

    if (fn)
        this.on('tick', fn)
}

inherits(Engine, EventEmitter)

Engine.prototype.start = function() {
    if (this.running) 
        return
    this.running = true
    this.last = now()
    this._frame = raf(this._tick)
    return this
}

Engine.prototype.stop = function() {
    this.running = false
    if (this._frame !== 0)
        raf.cancel(this._frame)
    this._frame = 0
    return this
}

Engine.prototype.tick = function() {
    this._frame = raf(this._tick)
    var time = now()
    var dt = time - this.last
    this.emit('tick', dt)
    this.last = time
}
},{"events":29,"inherits":79,"raf":97,"right-now":103}],97:[function(require,module,exports){
(function (global){(function (){
var now = require('performance-now')
  , root = typeof window === 'undefined' ? global : window
  , vendors = ['moz', 'webkit']
  , suffix = 'AnimationFrame'
  , raf = root['request' + suffix]
  , caf = root['cancel' + suffix] || root['cancelRequest' + suffix]

for(var i = 0; !raf && i < vendors.length; i++) {
  raf = root[vendors[i] + 'Request' + suffix]
  caf = root[vendors[i] + 'Cancel' + suffix]
      || root[vendors[i] + 'CancelRequest' + suffix]
}

// Some versions of FF have rAF but not cAF
if(!raf || !caf) {
  var last = 0
    , id = 0
    , queue = []
    , frameDuration = 1000 / 60

  raf = function(callback) {
    if(queue.length === 0) {
      var _now = now()
        , next = Math.max(0, frameDuration - (_now - last))
      last = next + _now
      setTimeout(function() {
        var cp = queue.slice(0)
        // Clear queue here to prevent
        // callbacks from appending listeners
        // to the current frame's queue
        queue.length = 0
        for(var i = 0; i < cp.length; i++) {
          if(!cp[i].cancelled) {
            try{
              cp[i].callback(last)
            } catch(e) {
              setTimeout(function() { throw e }, 0)
            }
          }
        }
      }, Math.round(next))
    }
    queue.push({
      handle: ++id,
      callback: callback,
      cancelled: false
    })
    return id
  }

  caf = function(handle) {
    for(var i = 0; i < queue.length; i++) {
      if(queue[i].handle === handle) {
        queue[i].cancelled = true
      }
    }
  }
}

module.exports = function(fn) {
  // Wrap in a new function to prevent
  // `cancel` potentially being assigned
  // to the native rAF function
  return raf.call(root, fn)
}
module.exports.cancel = function() {
  caf.apply(root, arguments)
}
module.exports.polyfill = function(object) {
  if (!object) {
    object = root;
  }
  object.requestAnimationFrame = raf
  object.cancelAnimationFrame = caf
}

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"performance-now":88}],98:[function(require,module,exports){
'use strict'

var bnadd = require('big-rat/add')

module.exports = add

function add (a, b) {
  var n = a.length
  var r = new Array(n)
  for (var i=0; i<n; ++i) {
    r[i] = bnadd(a[i], b[i])
  }
  return r
}

},{"big-rat/add":2}],99:[function(require,module,exports){
'use strict'

module.exports = float2rat

var rat = require('big-rat')

function float2rat(v) {
  var result = new Array(v.length)
  for(var i=0; i<v.length; ++i) {
    result[i] = rat(v[i])
  }
  return result
}

},{"big-rat":5}],100:[function(require,module,exports){
'use strict'

var rat = require('big-rat')
var mul = require('big-rat/mul')

module.exports = muls

function muls(a, x) {
  var s = rat(x)
  var n = a.length
  var r = new Array(n)
  for(var i=0; i<n; ++i) {
    r[i] = mul(a[i], s)
  }
  return r
}

},{"big-rat":5,"big-rat/mul":14}],101:[function(require,module,exports){
'use strict'

var bnsub = require('big-rat/sub')

module.exports = sub

function sub(a, b) {
  var n = a.length
  var r = new Array(n)
    for(var i=0; i<n; ++i) {
    r[i] = bnsub(a[i], b[i])
  }
  return r
}

},{"big-rat/sub":17}],102:[function(require,module,exports){
(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(factory) :
    (global.createREGL = factory());
}(this, (function () { 'use strict';

var isTypedArray = function (x) {
  return (
    x instanceof Uint8Array ||
    x instanceof Uint16Array ||
    x instanceof Uint32Array ||
    x instanceof Int8Array ||
    x instanceof Int16Array ||
    x instanceof Int32Array ||
    x instanceof Float32Array ||
    x instanceof Float64Array ||
    x instanceof Uint8ClampedArray
  )
}

var extend = function (base, opts) {
  var keys = Object.keys(opts)
  for (var i = 0; i < keys.length; ++i) {
    base[keys[i]] = opts[keys[i]]
  }
  return base
}

// Error checking and parameter validation.
//
// Statements for the form `check.someProcedure(...)` get removed by
// a browserify transform for optimized/minified bundles.
//
/* globals atob */
var endl = '\n'

// only used for extracting shader names.  if atob not present, then errors
// will be slightly crappier
function decodeB64 (str) {
  if (typeof atob !== 'undefined') {
    return atob(str)
  }
  return 'base64:' + str
}

function raise (message) {
  var error = new Error('(regl) ' + message)
  console.error(error)
  throw error
}

function check (pred, message) {
  if (!pred) {
    raise(message)
  }
}

function encolon (message) {
  if (message) {
    return ': ' + message
  }
  return ''
}

function checkParameter (param, possibilities, message) {
  if (!(param in possibilities)) {
    raise('unknown parameter (' + param + ')' + encolon(message) +
          '. possible values: ' + Object.keys(possibilities).join())
  }
}

function checkIsTypedArray (data, message) {
  if (!isTypedArray(data)) {
    raise(
      'invalid parameter type' + encolon(message) +
      '. must be a typed array')
  }
}

function standardTypeEh (value, type) {
  switch (type) {
    case 'number': return typeof value === 'number'
    case 'object': return typeof value === 'object'
    case 'string': return typeof value === 'string'
    case 'boolean': return typeof value === 'boolean'
    case 'function': return typeof value === 'function'
    case 'undefined': return typeof value === 'undefined'
    case 'symbol': return typeof value === 'symbol'
  }
}

function checkTypeOf (value, type, message) {
  if (!standardTypeEh(value, type)) {
    raise(
      'invalid parameter type' + encolon(message) +
      '. expected ' + type + ', got ' + (typeof value))
  }
}

function checkNonNegativeInt (value, message) {
  if (!((value >= 0) &&
        ((value | 0) === value))) {
    raise('invalid parameter type, (' + value + ')' + encolon(message) +
          '. must be a nonnegative integer')
  }
}

function checkOneOf (value, list, message) {
  if (list.indexOf(value) < 0) {
    raise('invalid value' + encolon(message) + '. must be one of: ' + list)
  }
}

var constructorKeys = [
  'gl',
  'canvas',
  'container',
  'attributes',
  'pixelRatio',
  'extensions',
  'optionalExtensions',
  'profile',
  'onDone'
]

function checkConstructor (obj) {
  Object.keys(obj).forEach(function (key) {
    if (constructorKeys.indexOf(key) < 0) {
      raise('invalid regl constructor argument "' + key + '". must be one of ' + constructorKeys)
    }
  })
}

function leftPad (str, n) {
  str = str + ''
  while (str.length < n) {
    str = ' ' + str
  }
  return str
}

function ShaderFile () {
  this.name = 'unknown'
  this.lines = []
  this.index = {}
  this.hasErrors = false
}

function ShaderLine (number, line) {
  this.number = number
  this.line = line
  this.errors = []
}

function ShaderError (fileNumber, lineNumber, message) {
  this.file = fileNumber
  this.line = lineNumber
  this.message = message
}

function guessCommand () {
  var error = new Error()
  var stack = (error.stack || error).toString()
  var pat = /compileProcedure.*\n\s*at.*\((.*)\)/.exec(stack)
  if (pat) {
    return pat[1]
  }
  var pat2 = /compileProcedure.*\n\s*at\s+(.*)(\n|$)/.exec(stack)
  if (pat2) {
    return pat2[1]
  }
  return 'unknown'
}

function guessCallSite () {
  var error = new Error()
  var stack = (error.stack || error).toString()
  var pat = /at REGLCommand.*\n\s+at.*\((.*)\)/.exec(stack)
  if (pat) {
    return pat[1]
  }
  var pat2 = /at REGLCommand.*\n\s+at\s+(.*)\n/.exec(stack)
  if (pat2) {
    return pat2[1]
  }
  return 'unknown'
}

function parseSource (source, command) {
  var lines = source.split('\n')
  var lineNumber = 1
  var fileNumber = 0
  var files = {
    unknown: new ShaderFile(),
    0: new ShaderFile()
  }
  files.unknown.name = files[0].name = command || guessCommand()
  files.unknown.lines.push(new ShaderLine(0, ''))
  for (var i = 0; i < lines.length; ++i) {
    var line = lines[i]
    var parts = /^\s*#\s*(\w+)\s+(.+)\s*$/.exec(line)
    if (parts) {
      switch (parts[1]) {
        case 'line':
          var lineNumberInfo = /(\d+)(\s+\d+)?/.exec(parts[2])
          if (lineNumberInfo) {
            lineNumber = lineNumberInfo[1] | 0
            if (lineNumberInfo[2]) {
              fileNumber = lineNumberInfo[2] | 0
              if (!(fileNumber in files)) {
                files[fileNumber] = new ShaderFile()
              }
            }
          }
          break
        case 'define':
          var nameInfo = /SHADER_NAME(_B64)?\s+(.*)$/.exec(parts[2])
          if (nameInfo) {
            files[fileNumber].name = (nameInfo[1]
              ? decodeB64(nameInfo[2])
              : nameInfo[2])
          }
          break
      }
    }
    files[fileNumber].lines.push(new ShaderLine(lineNumber++, line))
  }
  Object.keys(files).forEach(function (fileNumber) {
    var file = files[fileNumber]
    file.lines.forEach(function (line) {
      file.index[line.number] = line
    })
  })
  return files
}

function parseErrorLog (errLog) {
  var result = []
  errLog.split('\n').forEach(function (errMsg) {
    if (errMsg.length < 5) {
      return
    }
    var parts = /^ERROR:\s+(\d+):(\d+):\s*(.*)$/.exec(errMsg)
    if (parts) {
      result.push(new ShaderError(
        parts[1] | 0,
        parts[2] | 0,
        parts[3].trim()))
    } else if (errMsg.length > 0) {
      result.push(new ShaderError('unknown', 0, errMsg))
    }
  })
  return result
}

function annotateFiles (files, errors) {
  errors.forEach(function (error) {
    var file = files[error.file]
    if (file) {
      var line = file.index[error.line]
      if (line) {
        line.errors.push(error)
        file.hasErrors = true
        return
      }
    }
    files.unknown.hasErrors = true
    files.unknown.lines[0].errors.push(error)
  })
}

function checkShaderError (gl, shader, source, type, command) {
  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
    var errLog = gl.getShaderInfoLog(shader)
    var typeName = type === gl.FRAGMENT_SHADER ? 'fragment' : 'vertex'
    checkCommandType(source, 'string', typeName + ' shader source must be a string', command)
    var files = parseSource(source, command)
    var errors = parseErrorLog(errLog)
    annotateFiles(files, errors)

    Object.keys(files).forEach(function (fileNumber) {
      var file = files[fileNumber]
      if (!file.hasErrors) {
        return
      }

      var strings = ['']
      var styles = ['']

      function push (str, style) {
        strings.push(str)
        styles.push(style || '')
      }

      push('file number ' + fileNumber + ': ' + file.name + '\n', 'color:red;text-decoration:underline;font-weight:bold')

      file.lines.forEach(function (line) {
        if (line.errors.length > 0) {
          push(leftPad(line.number, 4) + '|  ', 'background-color:yellow; font-weight:bold')
          push(line.line + endl, 'color:red; background-color:yellow; font-weight:bold')

          // try to guess token
          var offset = 0
          line.errors.forEach(function (error) {
            var message = error.message
            var token = /^\s*'(.*)'\s*:\s*(.*)$/.exec(message)
            if (token) {
              var tokenPat = token[1]
              message = token[2]
              switch (tokenPat) {
                case 'assign':
                  tokenPat = '='
                  break
              }
              offset = Math.max(line.line.indexOf(tokenPat, offset), 0)
            } else {
              offset = 0
            }

            push(leftPad('| ', 6))
            push(leftPad('^^^', offset + 3) + endl, 'font-weight:bold')
            push(leftPad('| ', 6))
            push(message + endl, 'font-weight:bold')
          })
          push(leftPad('| ', 6) + endl)
        } else {
          push(leftPad(line.number, 4) + '|  ')
          push(line.line + endl, 'color:red')
        }
      })
      if (typeof document !== 'undefined' && !window.chrome) {
        styles[0] = strings.join('%c')
        console.log.apply(console, styles)
      } else {
        console.log(strings.join(''))
      }
    })

    check.raise('Error compiling ' + typeName + ' shader, ' + files[0].name)
  }
}

function checkLinkError (gl, program, fragShader, vertShader, command) {
  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
    var errLog = gl.getProgramInfoLog(program)
    var fragParse = parseSource(fragShader, command)
    var vertParse = parseSource(vertShader, command)

    var header = 'Error linking program with vertex shader, "' +
      vertParse[0].name + '", and fragment shader "' + fragParse[0].name + '"'

    if (typeof document !== 'undefined') {
      console.log('%c' + header + endl + '%c' + errLog,
        'color:red;text-decoration:underline;font-weight:bold',
        'color:red')
    } else {
      console.log(header + endl + errLog)
    }
    check.raise(header)
  }
}

function saveCommandRef (object) {
  object._commandRef = guessCommand()
}

function saveDrawCommandInfo (opts, uniforms, attributes, stringStore) {
  saveCommandRef(opts)

  function id (str) {
    if (str) {
      return stringStore.id(str)
    }
    return 0
  }
  opts._fragId = id(opts.static.frag)
  opts._vertId = id(opts.static.vert)

  function addProps (dict, set) {
    Object.keys(set).forEach(function (u) {
      dict[stringStore.id(u)] = true
    })
  }

  var uniformSet = opts._uniformSet = {}
  addProps(uniformSet, uniforms.static)
  addProps(uniformSet, uniforms.dynamic)

  var attributeSet = opts._attributeSet = {}
  addProps(attributeSet, attributes.static)
  addProps(attributeSet, attributes.dynamic)

  opts._hasCount = (
    'count' in opts.static ||
    'count' in opts.dynamic ||
    'elements' in opts.static ||
    'elements' in opts.dynamic)
}

function commandRaise (message, command) {
  var callSite = guessCallSite()
  raise(message +
    ' in command ' + (command || guessCommand()) +
    (callSite === 'unknown' ? '' : ' called from ' + callSite))
}

function checkCommand (pred, message, command) {
  if (!pred) {
    commandRaise(message, command || guessCommand())
  }
}

function checkParameterCommand (param, possibilities, message, command) {
  if (!(param in possibilities)) {
    commandRaise(
      'unknown parameter (' + param + ')' + encolon(message) +
      '. possible values: ' + Object.keys(possibilities).join(),
      command || guessCommand())
  }
}

function checkCommandType (value, type, message, command) {
  if (!standardTypeEh(value, type)) {
    commandRaise(
      'invalid parameter type' + encolon(message) +
      '. expected ' + type + ', got ' + (typeof value),
      command || guessCommand())
  }
}

function checkOptional (block) {
  block()
}

function checkFramebufferFormat (attachment, texFormats, rbFormats) {
  if (attachment.texture) {
    checkOneOf(
      attachment.texture._texture.internalformat,
      texFormats,
      'unsupported texture format for attachment')
  } else {
    checkOneOf(
      attachment.renderbuffer._renderbuffer.format,
      rbFormats,
      'unsupported renderbuffer format for attachment')
  }
}

var GL_CLAMP_TO_EDGE = 0x812F

var GL_NEAREST = 0x2600
var GL_NEAREST_MIPMAP_NEAREST = 0x2700
var GL_LINEAR_MIPMAP_NEAREST = 0x2701
var GL_NEAREST_MIPMAP_LINEAR = 0x2702
var GL_LINEAR_MIPMAP_LINEAR = 0x2703

var GL_BYTE = 5120
var GL_UNSIGNED_BYTE = 5121
var GL_SHORT = 5122
var GL_UNSIGNED_SHORT = 5123
var GL_INT = 5124
var GL_UNSIGNED_INT = 5125
var GL_FLOAT = 5126

var GL_UNSIGNED_SHORT_4_4_4_4 = 0x8033
var GL_UNSIGNED_SHORT_5_5_5_1 = 0x8034
var GL_UNSIGNED_SHORT_5_6_5 = 0x8363
var GL_UNSIGNED_INT_24_8_WEBGL = 0x84FA

var GL_HALF_FLOAT_OES = 0x8D61

var TYPE_SIZE = {}

TYPE_SIZE[GL_BYTE] =
TYPE_SIZE[GL_UNSIGNED_BYTE] = 1

TYPE_SIZE[GL_SHORT] =
TYPE_SIZE[GL_UNSIGNED_SHORT] =
TYPE_SIZE[GL_HALF_FLOAT_OES] =
TYPE_SIZE[GL_UNSIGNED_SHORT_5_6_5] =
TYPE_SIZE[GL_UNSIGNED_SHORT_4_4_4_4] =
TYPE_SIZE[GL_UNSIGNED_SHORT_5_5_5_1] = 2

TYPE_SIZE[GL_INT] =
TYPE_SIZE[GL_UNSIGNED_INT] =
TYPE_SIZE[GL_FLOAT] =
TYPE_SIZE[GL_UNSIGNED_INT_24_8_WEBGL] = 4

function pixelSize (type, channels) {
  if (type === GL_UNSIGNED_SHORT_5_5_5_1 ||
      type === GL_UNSIGNED_SHORT_4_4_4_4 ||
      type === GL_UNSIGNED_SHORT_5_6_5) {
    return 2
  } else if (type === GL_UNSIGNED_INT_24_8_WEBGL) {
    return 4
  } else {
    return TYPE_SIZE[type] * channels
  }
}

function isPow2 (v) {
  return !(v & (v - 1)) && (!!v)
}

function checkTexture2D (info, mipData, limits) {
  var i
  var w = mipData.width
  var h = mipData.height
  var c = mipData.channels

  // Check texture shape
  check(w > 0 && w <= limits.maxTextureSize &&
        h > 0 && h <= limits.maxTextureSize,
  'invalid texture shape')

  // check wrap mode
  if (info.wrapS !== GL_CLAMP_TO_EDGE || info.wrapT !== GL_CLAMP_TO_EDGE) {
    check(isPow2(w) && isPow2(h),
      'incompatible wrap mode for texture, both width and height must be power of 2')
  }

  if (mipData.mipmask === 1) {
    if (w !== 1 && h !== 1) {
      check(
        info.minFilter !== GL_NEAREST_MIPMAP_NEAREST &&
        info.minFilter !== GL_NEAREST_MIPMAP_LINEAR &&
        info.minFilter !== GL_LINEAR_MIPMAP_NEAREST &&
        info.minFilter !== GL_LINEAR_MIPMAP_LINEAR,
        'min filter requires mipmap')
    }
  } else {
    // texture must be power of 2
    check(isPow2(w) && isPow2(h),
      'texture must be a square power of 2 to support mipmapping')
    check(mipData.mipmask === (w << 1) - 1,
      'missing or incomplete mipmap data')
  }

  if (mipData.type === GL_FLOAT) {
    if (limits.extensions.indexOf('oes_texture_float_linear') < 0) {
      check(info.minFilter === GL_NEAREST && info.magFilter === GL_NEAREST,
        'filter not supported, must enable oes_texture_float_linear')
    }
    check(!info.genMipmaps,
      'mipmap generation not supported with float textures')
  }

  // check image complete
  var mipimages = mipData.images
  for (i = 0; i < 16; ++i) {
    if (mipimages[i]) {
      var mw = w >> i
      var mh = h >> i
      check(mipData.mipmask & (1 << i), 'missing mipmap data')

      var img = mipimages[i]

      check(
        img.width === mw &&
        img.height === mh,
        'invalid shape for mip images')

      check(
        img.format === mipData.format &&
        img.internalformat === mipData.internalformat &&
        img.type === mipData.type,
        'incompatible type for mip image')

      if (img.compressed) {
        // TODO: check size for compressed images
      } else if (img.data) {
        // check(img.data.byteLength === mw * mh *
        // Math.max(pixelSize(img.type, c), img.unpackAlignment),
        var rowSize = Math.ceil(pixelSize(img.type, c) * mw / img.unpackAlignment) * img.unpackAlignment
        check(img.data.byteLength === rowSize * mh,
          'invalid data for image, buffer size is inconsistent with image format')
      } else if (img.element) {
        // TODO: check element can be loaded
      } else if (img.copy) {
        // TODO: check compatible format and type
      }
    } else if (!info.genMipmaps) {
      check((mipData.mipmask & (1 << i)) === 0, 'extra mipmap data')
    }
  }

  if (mipData.compressed) {
    check(!info.genMipmaps,
      'mipmap generation for compressed images not supported')
  }
}

function checkTextureCube (texture, info, faces, limits) {
  var w = texture.width
  var h = texture.height
  var c = texture.channels

  // Check texture shape
  check(
    w > 0 && w <= limits.maxTextureSize && h > 0 && h <= limits.maxTextureSize,
    'invalid texture shape')
  check(
    w === h,
    'cube map must be square')
  check(
    info.wrapS === GL_CLAMP_TO_EDGE && info.wrapT === GL_CLAMP_TO_EDGE,
    'wrap mode not supported by cube map')

  for (var i = 0; i < faces.length; ++i) {
    var face = faces[i]
    check(
      face.width === w && face.height === h,
      'inconsistent cube map face shape')

    if (info.genMipmaps) {
      check(!face.compressed,
        'can not generate mipmap for compressed textures')
      check(face.mipmask === 1,
        'can not specify mipmaps and generate mipmaps')
    } else {
      // TODO: check mip and filter mode
    }

    var mipmaps = face.images
    for (var j = 0; j < 16; ++j) {
      var img = mipmaps[j]
      if (img) {
        var mw = w >> j
        var mh = h >> j
        check(face.mipmask & (1 << j), 'missing mipmap data')
        check(
          img.width === mw &&
          img.height === mh,
          'invalid shape for mip images')
        check(
          img.format === texture.format &&
          img.internalformat === texture.internalformat &&
          img.type === texture.type,
          'incompatible type for mip image')

        if (img.compressed) {
          // TODO: check size for compressed images
        } else if (img.data) {
          check(img.data.byteLength === mw * mh *
            Math.max(pixelSize(img.type, c), img.unpackAlignment),
          'invalid data for image, buffer size is inconsistent with image format')
        } else if (img.element) {
          // TODO: check element can be loaded
        } else if (img.copy) {
          // TODO: check compatible format and type
        }
      }
    }
  }
}

var check$1 = extend(check, {
  optional: checkOptional,
  raise: raise,
  commandRaise: commandRaise,
  command: checkCommand,
  parameter: checkParameter,
  commandParameter: checkParameterCommand,
  constructor: checkConstructor,
  type: checkTypeOf,
  commandType: checkCommandType,
  isTypedArray: checkIsTypedArray,
  nni: checkNonNegativeInt,
  oneOf: checkOneOf,
  shaderError: checkShaderError,
  linkError: checkLinkError,
  callSite: guessCallSite,
  saveCommandRef: saveCommandRef,
  saveDrawInfo: saveDrawCommandInfo,
  framebufferFormat: checkFramebufferFormat,
  guessCommand: guessCommand,
  texture2D: checkTexture2D,
  textureCube: checkTextureCube
});

var VARIABLE_COUNTER = 0

var DYN_FUNC = 0
var DYN_CONSTANT = 5
var DYN_ARRAY = 6

function DynamicVariable (type, data) {
  this.id = (VARIABLE_COUNTER++)
  this.type = type
  this.data = data
}

function escapeStr (str) {
  return str.replace(/\\/g, '\\\\').replace(/"/g, '\\"')
}

function splitParts (str) {
  if (str.length === 0) {
    return []
  }

  var firstChar = str.charAt(0)
  var lastChar = str.charAt(str.length - 1)

  if (str.length > 1 &&
      firstChar === lastChar &&
      (firstChar === '"' || firstChar === "'")) {
    return ['"' + escapeStr(str.substr(1, str.length - 2)) + '"']
  }

  var parts = /\[(false|true|null|\d+|'[^']*'|"[^"]*")\]/.exec(str)
  if (parts) {
    return (
      splitParts(str.substr(0, parts.index))
        .concat(splitParts(parts[1]))
        .concat(splitParts(str.substr(parts.index + parts[0].length)))
    )
  }

  var subparts = str.split('.')
  if (subparts.length === 1) {
    return ['"' + escapeStr(str) + '"']
  }

  var result = []
  for (var i = 0; i < subparts.length; ++i) {
    result = result.concat(splitParts(subparts[i]))
  }
  return result
}

function toAccessorString (str) {
  return '[' + splitParts(str).join('][') + ']'
}

function defineDynamic (type, data) {
  return new DynamicVariable(type, toAccessorString(data + ''))
}

function isDynamic (x) {
  return (typeof x === 'function' && !x._reglType) || (x instanceof DynamicVariable)
}

function unbox (x, path) {
  if (typeof x === 'function') {
    return new DynamicVariable(DYN_FUNC, x)
  } else if (typeof x === 'number' || typeof x === 'boolean') {
    return new DynamicVariable(DYN_CONSTANT, x)
  } else if (Array.isArray(x)) {
    return new DynamicVariable(DYN_ARRAY, x.map((y, i) => unbox(y, path + '[' + i + ']')))
  } else if (x instanceof DynamicVariable) {
    return x
  }
  check$1(false, 'invalid option type in uniform ' + path)
}

var dynamic = {
  DynamicVariable: DynamicVariable,
  define: defineDynamic,
  isDynamic: isDynamic,
  unbox: unbox,
  accessor: toAccessorString
};

/* globals requestAnimationFrame, cancelAnimationFrame */
var raf = {
  next: typeof requestAnimationFrame === 'function'
    ? function (cb) { return requestAnimationFrame(cb) }
    : function (cb) { return setTimeout(cb, 16) },
  cancel: typeof cancelAnimationFrame === 'function'
    ? function (raf) { return cancelAnimationFrame(raf) }
    : clearTimeout
};

/* globals performance */
var clock = (typeof performance !== 'undefined' && performance.now)
    ? function () { return performance.now() }
    : function () { return +(new Date()) };

function createStringStore () {
  var stringIds = { '': 0 }
  var stringValues = ['']
  return {
    id: function (str) {
      var result = stringIds[str]
      if (result) {
        return result
      }
      result = stringIds[str] = stringValues.length
      stringValues.push(str)
      return result
    },

    str: function (id) {
      return stringValues[id]
    }
  }
}

// Context and canvas creation helper functions
function createCanvas (element, onDone, pixelRatio) {
  var canvas = document.createElement('canvas')
  extend(canvas.style, {
    border: 0,
    margin: 0,
    padding: 0,
    top: 0,
    left: 0
  })
  element.appendChild(canvas)

  if (element === document.body) {
    canvas.style.position = 'absolute'
    extend(element.style, {
      margin: 0,
      padding: 0
    })
  }

  function resize () {
    var w = window.innerWidth
    var h = window.innerHeight
    if (element !== document.body) {
      var bounds = element.getBoundingClientRect()
      w = bounds.right - bounds.left
      h = bounds.bottom - bounds.top
    }
    canvas.width = pixelRatio * w
    canvas.height = pixelRatio * h
    extend(canvas.style, {
      width: w + 'px',
      height: h + 'px'
    })
  }

  var resizeObserver
  if (element !== document.body && typeof ResizeObserver === 'function') {
    // ignore 'ResizeObserver' is not defined
    // eslint-disable-next-line
    resizeObserver = new ResizeObserver(function () {
      // setTimeout to avoid flicker
      setTimeout(resize)
    })
    resizeObserver.observe(element)
  } else {
    window.addEventListener('resize', resize, false)
  }

  function onDestroy () {
    if (resizeObserver) {
      resizeObserver.disconnect()
    } else {
      window.removeEventListener('resize', resize)
    }
    element.removeChild(canvas)
  }

  resize()

  return {
    canvas: canvas,
    onDestroy: onDestroy
  }
}

function createContext (canvas, contextAttributes) {
  function get (name) {
    try {
      return canvas.getContext(name, contextAttributes)
    } catch (e) {
      return null
    }
  }
  return (
    get('webgl') ||
    get('experimental-webgl') ||
    get('webgl-experimental')
  )
}

function isHTMLElement (obj) {
  return (
    typeof obj.nodeName === 'string' &&
    typeof obj.appendChild === 'function' &&
    typeof obj.getBoundingClientRect === 'function'
  )
}

function isWebGLContext (obj) {
  return (
    typeof obj.drawArrays === 'function' ||
    typeof obj.drawElements === 'function'
  )
}

function parseExtensions (input) {
  if (typeof input === 'string') {
    return input.split()
  }
  check$1(Array.isArray(input), 'invalid extension array')
  return input
}

function getElement (desc) {
  if (typeof desc === 'string') {
    check$1(typeof document !== 'undefined', 'not supported outside of DOM')
    return document.querySelector(desc)
  }
  return desc
}

function parseArgs (args_) {
  var args = args_ || {}
  var element, container, canvas, gl
  var contextAttributes = {}
  var extensions = []
  var optionalExtensions = []
  var pixelRatio = (typeof window === 'undefined' ? 1 : window.devicePixelRatio)
  var profile = false
  var onDone = function (err) {
    if (err) {
      check$1.raise(err)
    }
  }
  var onDestroy = function () {}
  if (typeof args === 'string') {
    check$1(
      typeof document !== 'undefined',
      'selector queries only supported in DOM enviroments')
    element = document.querySelector(args)
    check$1(element, 'invalid query string for element')
  } else if (typeof args === 'object') {
    if (isHTMLElement(args)) {
      element = args
    } else if (isWebGLContext(args)) {
      gl = args
      canvas = gl.canvas
    } else {
      check$1.constructor(args)
      if ('gl' in args) {
        gl = args.gl
      } else if ('canvas' in args) {
        canvas = getElement(args.canvas)
      } else if ('container' in args) {
        container = getElement(args.container)
      }
      if ('attributes' in args) {
        contextAttributes = args.attributes
        check$1.type(contextAttributes, 'object', 'invalid context attributes')
      }
      if ('extensions' in args) {
        extensions = parseExtensions(args.extensions)
      }
      if ('optionalExtensions' in args) {
        optionalExtensions = parseExtensions(args.optionalExtensions)
      }
      if ('onDone' in args) {
        check$1.type(
          args.onDone, 'function',
          'invalid or missing onDone callback')
        onDone = args.onDone
      }
      if ('profile' in args) {
        profile = !!args.profile
      }
      if ('pixelRatio' in args) {
        pixelRatio = +args.pixelRatio
        check$1(pixelRatio > 0, 'invalid pixel ratio')
      }
    }
  } else {
    check$1.raise('invalid arguments to regl')
  }

  if (element) {
    if (element.nodeName.toLowerCase() === 'canvas') {
      canvas = element
    } else {
      container = element
    }
  }

  if (!gl) {
    if (!canvas) {
      check$1(
        typeof document !== 'undefined',
        'must manually specify webgl context outside of DOM environments')
      var result = createCanvas(container || document.body, onDone, pixelRatio)
      if (!result) {
        return null
      }
      canvas = result.canvas
      onDestroy = result.onDestroy
    }
    // workaround for chromium bug, premultiplied alpha value is platform dependent
    if (contextAttributes.premultipliedAlpha === undefined) contextAttributes.premultipliedAlpha = true
    gl = createContext(canvas, contextAttributes)
  }

  if (!gl) {
    onDestroy()
    onDone('webgl not supported, try upgrading your browser or graphics drivers http://get.webgl.org')
    return null
  }

  return {
    gl: gl,
    canvas: canvas,
    container: container,
    extensions: extensions,
    optionalExtensions: optionalExtensions,
    pixelRatio: pixelRatio,
    profile: profile,
    onDone: onDone,
    onDestroy: onDestroy
  }
}

function createExtensionCache (gl, config) {
  var extensions = {}

  function tryLoadExtension (name_) {
    check$1.type(name_, 'string', 'extension name must be string')
    var name = name_.toLowerCase()
    var ext
    try {
      ext = extensions[name] = gl.getExtension(name)
    } catch (e) {}
    return !!ext
  }

  for (var i = 0; i < config.extensions.length; ++i) {
    var name = config.extensions[i]
    if (!tryLoadExtension(name)) {
      config.onDestroy()
      config.onDone('"' + name + '" extension is not supported by the current WebGL context, try upgrading your system or a different browser')
      return null
    }
  }

  config.optionalExtensions.forEach(tryLoadExtension)

  return {
    extensions: extensions,
    restore: function () {
      Object.keys(extensions).forEach(function (name) {
        if (extensions[name] && !tryLoadExtension(name)) {
          throw new Error('(regl): error restoring extension ' + name)
        }
      })
    }
  }
}

function loop (n, f) {
  var result = Array(n)
  for (var i = 0; i < n; ++i) {
    result[i] = f(i)
  }
  return result
}

var GL_BYTE$1 = 5120
var GL_UNSIGNED_BYTE$2 = 5121
var GL_SHORT$1 = 5122
var GL_UNSIGNED_SHORT$1 = 5123
var GL_INT$1 = 5124
var GL_UNSIGNED_INT$1 = 5125
var GL_FLOAT$2 = 5126

function nextPow16 (v) {
  for (var i = 16; i <= (1 << 28); i *= 16) {
    if (v <= i) {
      return i
    }
  }
  return 0
}

function log2 (v) {
  var r, shift
  r = (v > 0xFFFF) << 4
  v >>>= r
  shift = (v > 0xFF) << 3
  v >>>= shift; r |= shift
  shift = (v > 0xF) << 2
  v >>>= shift; r |= shift
  shift = (v > 0x3) << 1
  v >>>= shift; r |= shift
  return r | (v >> 1)
}

function createPool () {
  var bufferPool = loop(8, function () {
    return []
  })

  function alloc (n) {
    var sz = nextPow16(n)
    var bin = bufferPool[log2(sz) >> 2]
    if (bin.length > 0) {
      return bin.pop()
    }
    return new ArrayBuffer(sz)
  }

  function free (buf) {
    bufferPool[log2(buf.byteLength) >> 2].push(buf)
  }

  function allocType (type, n) {
    var result = null
    switch (type) {
      case GL_BYTE$1:
        result = new Int8Array(alloc(n), 0, n)
        break
      case GL_UNSIGNED_BYTE$2:
        result = new Uint8Array(alloc(n), 0, n)
        break
      case GL_SHORT$1:
        result = new Int16Array(alloc(2 * n), 0, n)
        break
      case GL_UNSIGNED_SHORT$1:
        result = new Uint16Array(alloc(2 * n), 0, n)
        break
      case GL_INT$1:
        result = new Int32Array(alloc(4 * n), 0, n)
        break
      case GL_UNSIGNED_INT$1:
        result = new Uint32Array(alloc(4 * n), 0, n)
        break
      case GL_FLOAT$2:
        result = new Float32Array(alloc(4 * n), 0, n)
        break
      default:
        return null
    }
    if (result.length !== n) {
      return result.subarray(0, n)
    }
    return result
  }

  function freeType (array) {
    free(array.buffer)
  }

  return {
    alloc: alloc,
    free: free,
    allocType: allocType,
    freeType: freeType
  }
}

var pool = createPool()

// zero pool for initial zero data
pool.zero = createPool()

var GL_SUBPIXEL_BITS = 0x0D50
var GL_RED_BITS = 0x0D52
var GL_GREEN_BITS = 0x0D53
var GL_BLUE_BITS = 0x0D54
var GL_ALPHA_BITS = 0x0D55
var GL_DEPTH_BITS = 0x0D56
var GL_STENCIL_BITS = 0x0D57

var GL_ALIASED_POINT_SIZE_RANGE = 0x846D
var GL_ALIASED_LINE_WIDTH_RANGE = 0x846E

var GL_MAX_TEXTURE_SIZE = 0x0D33
var GL_MAX_VIEWPORT_DIMS = 0x0D3A
var GL_MAX_VERTEX_ATTRIBS = 0x8869
var GL_MAX_VERTEX_UNIFORM_VECTORS = 0x8DFB
var GL_MAX_VARYING_VECTORS = 0x8DFC
var GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS = 0x8B4D
var GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS = 0x8B4C
var GL_MAX_TEXTURE_IMAGE_UNITS = 0x8872
var GL_MAX_FRAGMENT_UNIFORM_VECTORS = 0x8DFD
var GL_MAX_CUBE_MAP_TEXTURE_SIZE = 0x851C
var GL_MAX_RENDERBUFFER_SIZE = 0x84E8

var GL_VENDOR = 0x1F00
var GL_RENDERER = 0x1F01
var GL_VERSION = 0x1F02
var GL_SHADING_LANGUAGE_VERSION = 0x8B8C

var GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT = 0x84FF

var GL_MAX_COLOR_ATTACHMENTS_WEBGL = 0x8CDF
var GL_MAX_DRAW_BUFFERS_WEBGL = 0x8824

var GL_TEXTURE_2D = 0x0DE1
var GL_TEXTURE_CUBE_MAP = 0x8513
var GL_TEXTURE_CUBE_MAP_POSITIVE_X = 0x8515
var GL_TEXTURE0 = 0x84C0
var GL_RGBA = 0x1908
var GL_FLOAT$1 = 0x1406
var GL_UNSIGNED_BYTE$1 = 0x1401
var GL_FRAMEBUFFER = 0x8D40
var GL_FRAMEBUFFER_COMPLETE = 0x8CD5
var GL_COLOR_ATTACHMENT0 = 0x8CE0
var GL_COLOR_BUFFER_BIT$1 = 0x4000

var wrapLimits = function (gl, extensions) {
  var maxAnisotropic = 1
  if (extensions.ext_texture_filter_anisotropic) {
    maxAnisotropic = gl.getParameter(GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT)
  }

  var maxDrawbuffers = 1
  var maxColorAttachments = 1
  if (extensions.webgl_draw_buffers) {
    maxDrawbuffers = gl.getParameter(GL_MAX_DRAW_BUFFERS_WEBGL)
    maxColorAttachments = gl.getParameter(GL_MAX_COLOR_ATTACHMENTS_WEBGL)
  }

  // detect if reading float textures is available (Safari doesn't support)
  var readFloat = !!extensions.oes_texture_float
  if (readFloat) {
    var readFloatTexture = gl.createTexture()
    gl.bindTexture(GL_TEXTURE_2D, readFloatTexture)
    gl.texImage2D(GL_TEXTURE_2D, 0, GL_RGBA, 1, 1, 0, GL_RGBA, GL_FLOAT$1, null)

    var fbo = gl.createFramebuffer()
    gl.bindFramebuffer(GL_FRAMEBUFFER, fbo)
    gl.framebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, readFloatTexture, 0)
    gl.bindTexture(GL_TEXTURE_2D, null)

    if (gl.checkFramebufferStatus(GL_FRAMEBUFFER) !== GL_FRAMEBUFFER_COMPLETE) readFloat = false

    else {
      gl.viewport(0, 0, 1, 1)
      gl.clearColor(1.0, 0.0, 0.0, 1.0)
      gl.clear(GL_COLOR_BUFFER_BIT$1)
      var pixels = pool.allocType(GL_FLOAT$1, 4)
      gl.readPixels(0, 0, 1, 1, GL_RGBA, GL_FLOAT$1, pixels)

      if (gl.getError()) readFloat = false
      else {
        gl.deleteFramebuffer(fbo)
        gl.deleteTexture(readFloatTexture)

        readFloat = pixels[0] === 1.0
      }

      pool.freeType(pixels)
    }
  }

  // detect non power of two cube textures support (IE doesn't support)
  var isIE = typeof navigator !== 'undefined' && (/MSIE/.test(navigator.userAgent) || /Trident\//.test(navigator.appVersion) || /Edge/.test(navigator.userAgent))

  var npotTextureCube = true

  if (!isIE) {
    var cubeTexture = gl.createTexture()
    var data = pool.allocType(GL_UNSIGNED_BYTE$1, 36)
    gl.activeTexture(GL_TEXTURE0)
    gl.bindTexture(GL_TEXTURE_CUBE_MAP, cubeTexture)
    gl.texImage2D(GL_TEXTURE_CUBE_MAP_POSITIVE_X, 0, GL_RGBA, 3, 3, 0, GL_RGBA, GL_UNSIGNED_BYTE$1, data)
    pool.freeType(data)
    gl.bindTexture(GL_TEXTURE_CUBE_MAP, null)
    gl.deleteTexture(cubeTexture)
    npotTextureCube = !gl.getError()
  }

  return {
    // drawing buffer bit depth
    colorBits: [
      gl.getParameter(GL_RED_BITS),
      gl.getParameter(GL_GREEN_BITS),
      gl.getParameter(GL_BLUE_BITS),
      gl.getParameter(GL_ALPHA_BITS)
    ],
    depthBits: gl.getParameter(GL_DEPTH_BITS),
    stencilBits: gl.getParameter(GL_STENCIL_BITS),
    subpixelBits: gl.getParameter(GL_SUBPIXEL_BITS),

    // supported extensions
    extensions: Object.keys(extensions).filter(function (ext) {
      return !!extensions[ext]
    }),

    // max aniso samples
    maxAnisotropic: maxAnisotropic,

    // max draw buffers
    maxDrawbuffers: maxDrawbuffers,
    maxColorAttachments: maxColorAttachments,

    // point and line size ranges
    pointSizeDims: gl.getParameter(GL_ALIASED_POINT_SIZE_RANGE),
    lineWidthDims: gl.getParameter(GL_ALIASED_LINE_WIDTH_RANGE),
    maxViewportDims: gl.getParameter(GL_MAX_VIEWPORT_DIMS),
    maxCombinedTextureUnits: gl.getParameter(GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS),
    maxCubeMapSize: gl.getParameter(GL_MAX_CUBE_MAP_TEXTURE_SIZE),
    maxRenderbufferSize: gl.getParameter(GL_MAX_RENDERBUFFER_SIZE),
    maxTextureUnits: gl.getParameter(GL_MAX_TEXTURE_IMAGE_UNITS),
    maxTextureSize: gl.getParameter(GL_MAX_TEXTURE_SIZE),
    maxAttributes: gl.getParameter(GL_MAX_VERTEX_ATTRIBS),
    maxVertexUniforms: gl.getParameter(GL_MAX_VERTEX_UNIFORM_VECTORS),
    maxVertexTextureUnits: gl.getParameter(GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS),
    maxVaryingVectors: gl.getParameter(GL_MAX_VARYING_VECTORS),
    maxFragmentUniforms: gl.getParameter(GL_MAX_FRAGMENT_UNIFORM_VECTORS),

    // vendor info
    glsl: gl.getParameter(GL_SHADING_LANGUAGE_VERSION),
    renderer: gl.getParameter(GL_RENDERER),
    vendor: gl.getParameter(GL_VENDOR),
    version: gl.getParameter(GL_VERSION),

    // quirks
    readFloat: readFloat,
    npotTextureCube: npotTextureCube
  }
}

function isNDArrayLike (obj) {
  return (
    !!obj &&
    typeof obj === 'object' &&
    Array.isArray(obj.shape) &&
    Array.isArray(obj.stride) &&
    typeof obj.offset === 'number' &&
    obj.shape.length === obj.stride.length &&
    (Array.isArray(obj.data) ||
      isTypedArray(obj.data)))
}

var values = function (obj) {
  return Object.keys(obj).map(function (key) { return obj[key] })
}

var flattenUtils = {
  shape: arrayShape$1,
  flatten: flattenArray
};

function flatten1D (array, nx, out) {
  for (var i = 0; i < nx; ++i) {
    out[i] = array[i]
  }
}

function flatten2D (array, nx, ny, out) {
  var ptr = 0
  for (var i = 0; i < nx; ++i) {
    var row = array[i]
    for (var j = 0; j < ny; ++j) {
      out[ptr++] = row[j]
    }
  }
}

function flatten3D (array, nx, ny, nz, out, ptr_) {
  var ptr = ptr_
  for (var i = 0; i < nx; ++i) {
    var row = array[i]
    for (var j = 0; j < ny; ++j) {
      var col = row[j]
      for (var k = 0; k < nz; ++k) {
        out[ptr++] = col[k]
      }
    }
  }
}

function flattenRec (array, shape, level, out, ptr) {
  var stride = 1
  for (var i = level + 1; i < shape.length; ++i) {
    stride *= shape[i]
  }
  var n = shape[level]
  if (shape.length - level === 4) {
    var nx = shape[level + 1]
    var ny = shape[level + 2]
    var nz = shape[level + 3]
    for (i = 0; i < n; ++i) {
      flatten3D(array[i], nx, ny, nz, out, ptr)
      ptr += stride
    }
  } else {
    for (i = 0; i < n; ++i) {
      flattenRec(array[i], shape, level + 1, out, ptr)
      ptr += stride
    }
  }
}

function flattenArray (array, shape, type, out_) {
  var sz = 1
  if (shape.length) {
    for (var i = 0; i < shape.length; ++i) {
      sz *= shape[i]
    }
  } else {
    sz = 0
  }
  var out = out_ || pool.allocType(type, sz)
  switch (shape.length) {
    case 0:
      break
    case 1:
      flatten1D(array, shape[0], out)
      break
    case 2:
      flatten2D(array, shape[0], shape[1], out)
      break
    case 3:
      flatten3D(array, shape[0], shape[1], shape[2], out, 0)
      break
    default:
      flattenRec(array, shape, 0, out, 0)
  }
  return out
}

function arrayShape$1 (array_) {
  var shape = []
  for (var array = array_; array.length; array = array[0]) {
    shape.push(array.length)
  }
  return shape
}

var arrayTypes =  {
	"[object Int8Array]": 5120,
	"[object Int16Array]": 5122,
	"[object Int32Array]": 5124,
	"[object Uint8Array]": 5121,
	"[object Uint8ClampedArray]": 5121,
	"[object Uint16Array]": 5123,
	"[object Uint32Array]": 5125,
	"[object Float32Array]": 5126,
	"[object Float64Array]": 5121,
	"[object ArrayBuffer]": 5121
};

var int8 = 5120;
var int16 = 5122;
var int32 = 5124;
var uint8 = 5121;
var uint16 = 5123;
var uint32 = 5125;
var float = 5126;
var float32 = 5126;
var glTypes = {
	int8: int8,
	int16: int16,
	int32: int32,
	uint8: uint8,
	uint16: uint16,
	uint32: uint32,
	float: float,
	float32: float32
};

var dynamic$1 = 35048;
var stream = 35040;
var usageTypes = {
	dynamic: dynamic$1,
	stream: stream,
	"static": 35044
};

var arrayFlatten = flattenUtils.flatten
var arrayShape = flattenUtils.shape

var GL_STATIC_DRAW = 0x88E4
var GL_STREAM_DRAW = 0x88E0

var GL_UNSIGNED_BYTE$3 = 5121
var GL_FLOAT$3 = 5126

var DTYPES_SIZES = []
DTYPES_SIZES[5120] = 1 // int8
DTYPES_SIZES[5122] = 2 // int16
DTYPES_SIZES[5124] = 4 // int32
DTYPES_SIZES[5121] = 1 // uint8
DTYPES_SIZES[5123] = 2 // uint16
DTYPES_SIZES[5125] = 4 // uint32
DTYPES_SIZES[5126] = 4 // float32

function typedArrayCode (data) {
  return arrayTypes[Object.prototype.toString.call(data)] | 0
}

function copyArray (out, inp) {
  for (var i = 0; i < inp.length; ++i) {
    out[i] = inp[i]
  }
}

function transpose (
  result, data, shapeX, shapeY, strideX, strideY, offset) {
  var ptr = 0
  for (var i = 0; i < shapeX; ++i) {
    for (var j = 0; j < shapeY; ++j) {
      result[ptr++] = data[strideX * i + strideY * j + offset]
    }
  }
}

function wrapBufferState (gl, stats, config, destroyBuffer) {
  var bufferCount = 0
  var bufferSet = {}

  function REGLBuffer (type) {
    this.id = bufferCount++
    this.buffer = gl.createBuffer()
    this.type = type
    this.usage = GL_STATIC_DRAW
    this.byteLength = 0
    this.dimension = 1
    this.dtype = GL_UNSIGNED_BYTE$3

    this.persistentData = null

    if (config.profile) {
      this.stats = { size: 0 }
    }
  }

  REGLBuffer.prototype.bind = function () {
    gl.bindBuffer(this.type, this.buffer)
  }

  REGLBuffer.prototype.destroy = function () {
    destroy(this)
  }

  var streamPool = []

  function createStream (type, data) {
    var buffer = streamPool.pop()
    if (!buffer) {
      buffer = new REGLBuffer(type)
    }
    buffer.bind()
    initBufferFromData(buffer, data, GL_STREAM_DRAW, 0, 1, false)
    return buffer
  }

  function destroyStream (stream$$1) {
    streamPool.push(stream$$1)
  }

  function initBufferFromTypedArray (buffer, data, usage) {
    buffer.byteLength = data.byteLength
    gl.bufferData(buffer.type, data, usage)
  }

  function initBufferFromData (buffer, data, usage, dtype, dimension, persist) {
    var shape
    buffer.usage = usage
    if (Array.isArray(data)) {
      buffer.dtype = dtype || GL_FLOAT$3
      if (data.length > 0) {
        var flatData
        if (Array.isArray(data[0])) {
          shape = arrayShape(data)
          var dim = 1
          for (var i = 1; i < shape.length; ++i) {
            dim *= shape[i]
          }
          buffer.dimension = dim
          flatData = arrayFlatten(data, shape, buffer.dtype)
          initBufferFromTypedArray(buffer, flatData, usage)
          if (persist) {
            buffer.persistentData = flatData
          } else {
            pool.freeType(flatData)
          }
        } else if (typeof data[0] === 'number') {
          buffer.dimension = dimension
          var typedData = pool.allocType(buffer.dtype, data.length)
          copyArray(typedData, data)
          initBufferFromTypedArray(buffer, typedData, usage)
          if (persist) {
            buffer.persistentData = typedData
          } else {
            pool.freeType(typedData)
          }
        } else if (isTypedArray(data[0])) {
          buffer.dimension = data[0].length
          buffer.dtype = dtype || typedArrayCode(data[0]) || GL_FLOAT$3
          flatData = arrayFlatten(
            data,
            [data.length, data[0].length],
            buffer.dtype)
          initBufferFromTypedArray(buffer, flatData, usage)
          if (persist) {
            buffer.persistentData = flatData
          } else {
            pool.freeType(flatData)
          }
        } else {
          check$1.raise('invalid buffer data')
        }
      }
    } else if (isTypedArray(data)) {
      buffer.dtype = dtype || typedArrayCode(data)
      buffer.dimension = dimension
      initBufferFromTypedArray(buffer, data, usage)
      if (persist) {
        buffer.persistentData = new Uint8Array(new Uint8Array(data.buffer))
      }
    } else if (isNDArrayLike(data)) {
      shape = data.shape
      var stride = data.stride
      var offset = data.offset

      var shapeX = 0
      var shapeY = 0
      var strideX = 0
      var strideY = 0
      if (shape.length === 1) {
        shapeX = shape[0]
        shapeY = 1
        strideX = stride[0]
        strideY = 0
      } else if (shape.length === 2) {
        shapeX = shape[0]
        shapeY = shape[1]
        strideX = stride[0]
        strideY = stride[1]
      } else {
        check$1.raise('invalid shape')
      }

      buffer.dtype = dtype || typedArrayCode(data.data) || GL_FLOAT$3
      buffer.dimension = shapeY

      var transposeData = pool.allocType(buffer.dtype, shapeX * shapeY)
      transpose(transposeData,
        data.data,
        shapeX, shapeY,
        strideX, strideY,
        offset)
      initBufferFromTypedArray(buffer, transposeData, usage)
      if (persist) {
        buffer.persistentData = transposeData
      } else {
        pool.freeType(transposeData)
      }
    } else if (data instanceof ArrayBuffer) {
      buffer.dtype = GL_UNSIGNED_BYTE$3
      buffer.dimension = dimension
      initBufferFromTypedArray(buffer, data, usage)
      if (persist) {
        buffer.persistentData = new Uint8Array(new Uint8Array(data))
      }
    } else {
      check$1.raise('invalid buffer data')
    }
  }

  function destroy (buffer) {
    stats.bufferCount--

    // remove attribute link
    destroyBuffer(buffer)

    var handle = buffer.buffer
    check$1(handle, 'buffer must not be deleted already')
    gl.deleteBuffer(handle)
    buffer.buffer = null
    delete bufferSet[buffer.id]
  }

  function createBuffer (options, type, deferInit, persistent) {
    stats.bufferCount++

    var buffer = new REGLBuffer(type)
    bufferSet[buffer.id] = buffer

    function reglBuffer (options) {
      var usage = GL_STATIC_DRAW
      var data = null
      var byteLength = 0
      var dtype = 0
      var dimension = 1
      if (Array.isArray(options) ||
          isTypedArray(options) ||
          isNDArrayLike(options) ||
          options instanceof ArrayBuffer) {
        data = options
      } else if (typeof options === 'number') {
        byteLength = options | 0
      } else if (options) {
        check$1.type(
          options, 'object',
          'buffer arguments must be an object, a number or an array')

        if ('data' in options) {
          check$1(
            data === null ||
            Array.isArray(data) ||
            isTypedArray(data) ||
            isNDArrayLike(data),
            'invalid data for buffer')
          data = options.data
        }

        if ('usage' in options) {
          check$1.parameter(options.usage, usageTypes, 'invalid buffer usage')
          usage = usageTypes[options.usage]
        }

        if ('type' in options) {
          check$1.parameter(options.type, glTypes, 'invalid buffer type')
          dtype = glTypes[options.type]
        }

        if ('dimension' in options) {
          check$1.type(options.dimension, 'number', 'invalid dimension')
          dimension = options.dimension | 0
        }

        if ('length' in options) {
          check$1.nni(byteLength, 'buffer length must be a nonnegative integer')
          byteLength = options.length | 0
        }
      }

      buffer.bind()
      if (!data) {
        // #475
        if (byteLength) gl.bufferData(buffer.type, byteLength, usage)
        buffer.dtype = dtype || GL_UNSIGNED_BYTE$3
        buffer.usage = usage
        buffer.dimension = dimension
        buffer.byteLength = byteLength
      } else {
        initBufferFromData(buffer, data, usage, dtype, dimension, persistent)
      }

      if (config.profile) {
        buffer.stats.size = buffer.byteLength * DTYPES_SIZES[buffer.dtype]
      }

      return reglBuffer
    }

    function setSubData (data, offset) {
      check$1(offset + data.byteLength <= buffer.byteLength,
        'invalid buffer subdata call, buffer is too small. ' + ' Can\'t write data of size ' + data.byteLength + ' starting from offset ' + offset + ' to a buffer of size ' + buffer.byteLength)

      gl.bufferSubData(buffer.type, offset, data)
    }

    function subdata (data, offset_) {
      var offset = (offset_ || 0) | 0
      var shape
      buffer.bind()
      if (isTypedArray(data) || data instanceof ArrayBuffer) {
        setSubData(data, offset)
      } else if (Array.isArray(data)) {
        if (data.length > 0) {
          if (typeof data[0] === 'number') {
            var converted = pool.allocType(buffer.dtype, data.length)
            copyArray(converted, data)
            setSubData(converted, offset)
            pool.freeType(converted)
          } else if (Array.isArray(data[0]) || isTypedArray(data[0])) {
            shape = arrayShape(data)
            var flatData = arrayFlatten(data, shape, buffer.dtype)
            setSubData(flatData, offset)
            pool.freeType(flatData)
          } else {
            check$1.raise('invalid buffer data')
          }
        }
      } else if (isNDArrayLike(data)) {
        shape = data.shape
        var stride = data.stride

        var shapeX = 0
        var shapeY = 0
        var strideX = 0
        var strideY = 0
        if (shape.length === 1) {
          shapeX = shape[0]
          shapeY = 1
          strideX = stride[0]
          strideY = 0
        } else if (shape.length === 2) {
          shapeX = shape[0]
          shapeY = shape[1]
          strideX = stride[0]
          strideY = stride[1]
        } else {
          check$1.raise('invalid shape')
        }
        var dtype = Array.isArray(data.data)
          ? buffer.dtype
          : typedArrayCode(data.data)

        var transposeData = pool.allocType(dtype, shapeX * shapeY)
        transpose(transposeData,
          data.data,
          shapeX, shapeY,
          strideX, strideY,
          data.offset)
        setSubData(transposeData, offset)
        pool.freeType(transposeData)
      } else {
        check$1.raise('invalid data for buffer subdata')
      }
      return reglBuffer
    }

    if (!deferInit) {
      reglBuffer(options)
    }

    reglBuffer._reglType = 'buffer'
    reglBuffer._buffer = buffer
    reglBuffer.subdata = subdata
    if (config.profile) {
      reglBuffer.stats = buffer.stats
    }
    reglBuffer.destroy = function () { destroy(buffer) }

    return reglBuffer
  }

  function restoreBuffers () {
    values(bufferSet).forEach(function (buffer) {
      buffer.buffer = gl.createBuffer()
      gl.bindBuffer(buffer.type, buffer.buffer)
      gl.bufferData(
        buffer.type, buffer.persistentData || buffer.byteLength, buffer.usage)
    })
  }

  if (config.profile) {
    stats.getTotalBufferSize = function () {
      var total = 0
      // TODO: Right now, the streams are not part of the total count.
      Object.keys(bufferSet).forEach(function (key) {
        total += bufferSet[key].stats.size
      })
      return total
    }
  }

  return {
    create: createBuffer,

    createStream: createStream,
    destroyStream: destroyStream,

    clear: function () {
      values(bufferSet).forEach(destroy)
      streamPool.forEach(destroy)
    },

    getBuffer: function (wrapper) {
      if (wrapper && wrapper._buffer instanceof REGLBuffer) {
        return wrapper._buffer
      }
      return null
    },

    restore: restoreBuffers,

    _initBuffer: initBufferFromData
  }
}

var points = 0;
var point = 0;
var lines = 1;
var line = 1;
var triangles = 4;
var triangle = 4;
var primTypes = {
	points: points,
	point: point,
	lines: lines,
	line: line,
	triangles: triangles,
	triangle: triangle,
	"line loop": 2,
	"line strip": 3,
	"triangle strip": 5,
	"triangle fan": 6
};

var GL_POINTS = 0
var GL_LINES = 1
var GL_TRIANGLES = 4

var GL_BYTE$2 = 5120
var GL_UNSIGNED_BYTE$4 = 5121
var GL_SHORT$2 = 5122
var GL_UNSIGNED_SHORT$2 = 5123
var GL_INT$2 = 5124
var GL_UNSIGNED_INT$2 = 5125

var GL_ELEMENT_ARRAY_BUFFER = 34963

var GL_STREAM_DRAW$1 = 0x88E0
var GL_STATIC_DRAW$1 = 0x88E4

function wrapElementsState (gl, extensions, bufferState, stats) {
  var elementSet = {}
  var elementCount = 0

  var elementTypes = {
    'uint8': GL_UNSIGNED_BYTE$4,
    'uint16': GL_UNSIGNED_SHORT$2
  }

  if (extensions.oes_element_index_uint) {
    elementTypes.uint32 = GL_UNSIGNED_INT$2
  }

  function REGLElementBuffer (buffer) {
    this.id = elementCount++
    elementSet[this.id] = this
    this.buffer = buffer
    this.primType = GL_TRIANGLES
    this.vertCount = 0
    this.type = 0
  }

  REGLElementBuffer.prototype.bind = function () {
    this.buffer.bind()
  }

  var bufferPool = []

  function createElementStream (data) {
    var result = bufferPool.pop()
    if (!result) {
      result = new REGLElementBuffer(bufferState.create(
        null,
        GL_ELEMENT_ARRAY_BUFFER,
        true,
        false)._buffer)
    }
    initElements(result, data, GL_STREAM_DRAW$1, -1, -1, 0, 0)
    return result
  }

  function destroyElementStream (elements) {
    bufferPool.push(elements)
  }

  function initElements (
    elements,
    data,
    usage,
    prim,
    count,
    byteLength,
    type) {
    elements.buffer.bind()
    var dtype
    if (data) {
      var predictedType = type
      if (!type && (
        !isTypedArray(data) ||
         (isNDArrayLike(data) && !isTypedArray(data.data)))) {
        predictedType = extensions.oes_element_index_uint
          ? GL_UNSIGNED_INT$2
          : GL_UNSIGNED_SHORT$2
      }
      bufferState._initBuffer(
        elements.buffer,
        data,
        usage,
        predictedType,
        3)
    } else {
      gl.bufferData(GL_ELEMENT_ARRAY_BUFFER, byteLength, usage)
      elements.buffer.dtype = dtype || GL_UNSIGNED_BYTE$4
      elements.buffer.usage = usage
      elements.buffer.dimension = 3
      elements.buffer.byteLength = byteLength
    }

    dtype = type
    if (!type) {
      switch (elements.buffer.dtype) {
        case GL_UNSIGNED_BYTE$4:
        case GL_BYTE$2:
          dtype = GL_UNSIGNED_BYTE$4
          break

        case GL_UNSIGNED_SHORT$2:
        case GL_SHORT$2:
          dtype = GL_UNSIGNED_SHORT$2
          break

        case GL_UNSIGNED_INT$2:
        case GL_INT$2:
          dtype = GL_UNSIGNED_INT$2
          break

        default:
          check$1.raise('unsupported type for element array')
      }
      elements.buffer.dtype = dtype
    }
    elements.type = dtype

    // Check oes_element_index_uint extension
    check$1(
      dtype !== GL_UNSIGNED_INT$2 ||
      !!extensions.oes_element_index_uint,
      '32 bit element buffers not supported, enable oes_element_index_uint first')

    // try to guess default primitive type and arguments
    var vertCount = count
    if (vertCount < 0) {
      vertCount = elements.buffer.byteLength
      if (dtype === GL_UNSIGNED_SHORT$2) {
        vertCount >>= 1
      } else if (dtype === GL_UNSIGNED_INT$2) {
        vertCount >>= 2
      }
    }
    elements.vertCount = vertCount

    // try to guess primitive type from cell dimension
    var primType = prim
    if (prim < 0) {
      primType = GL_TRIANGLES
      var dimension = elements.buffer.dimension
      if (dimension === 1) primType = GL_POINTS
      if (dimension === 2) primType = GL_LINES
      if (dimension === 3) primType = GL_TRIANGLES
    }
    elements.primType = primType
  }

  function destroyElements (elements) {
    stats.elementsCount--

    check$1(elements.buffer !== null, 'must not double destroy elements')
    delete elementSet[elements.id]
    elements.buffer.destroy()
    elements.buffer = null
  }

  function createElements (options, persistent) {
    var buffer = bufferState.create(null, GL_ELEMENT_ARRAY_BUFFER, true)
    var elements = new REGLElementBuffer(buffer._buffer)
    stats.elementsCount++

    function reglElements (options) {
      if (!options) {
        buffer()
        elements.primType = GL_TRIANGLES
        elements.vertCount = 0
        elements.type = GL_UNSIGNED_BYTE$4
      } else if (typeof options === 'number') {
        buffer(options)
        elements.primType = GL_TRIANGLES
        elements.vertCount = options | 0
        elements.type = GL_UNSIGNED_BYTE$4
      } else {
        var data = null
        var usage = GL_STATIC_DRAW$1
        var primType = -1
        var vertCount = -1
        var byteLength = 0
        var dtype = 0
        if (Array.isArray(options) ||
            isTypedArray(options) ||
            isNDArrayLike(options)) {
          data = options
        } else {
          check$1.type(options, 'object', 'invalid arguments for elements')
          if ('data' in options) {
            data = options.data
            check$1(
              Array.isArray(data) ||
                isTypedArray(data) ||
                isNDArrayLike(data),
              'invalid data for element buffer')
          }
          if ('usage' in options) {
            check$1.parameter(
              options.usage,
              usageTypes,
              'invalid element buffer usage')
            usage = usageTypes[options.usage]
          }
          if ('primitive' in options) {
            check$1.parameter(
              options.primitive,
              primTypes,
              'invalid element buffer primitive')
            primType = primTypes[options.primitive]
          }
          if ('count' in options) {
            check$1(
              typeof options.count === 'number' && options.count >= 0,
              'invalid vertex count for elements')
            vertCount = options.count | 0
          }
          if ('type' in options) {
            check$1.parameter(
              options.type,
              elementTypes,
              'invalid buffer type')
            dtype = elementTypes[options.type]
          }
          if ('length' in options) {
            byteLength = options.length | 0
          } else {
            byteLength = vertCount
            if (dtype === GL_UNSIGNED_SHORT$2 || dtype === GL_SHORT$2) {
              byteLength *= 2
            } else if (dtype === GL_UNSIGNED_INT$2 || dtype === GL_INT$2) {
              byteLength *= 4
            }
          }
        }
        initElements(
          elements,
          data,
          usage,
          primType,
          vertCount,
          byteLength,
          dtype)
      }

      return reglElements
    }

    reglElements(options)

    reglElements._reglType = 'elements'
    reglElements._elements = elements
    reglElements.subdata = function (data, offset) {
      buffer.subdata(data, offset)
      return reglElements
    }
    reglElements.destroy = function () {
      destroyElements(elements)
    }

    return reglElements
  }

  return {
    create: createElements,
    createStream: createElementStream,
    destroyStream: destroyElementStream,
    getElements: function (elements) {
      if (typeof elements === 'function' &&
          elements._elements instanceof REGLElementBuffer) {
        return elements._elements
      }
      return null
    },
    clear: function () {
      values(elementSet).forEach(destroyElements)
    }
  }
}

var FLOAT = new Float32Array(1)
var INT = new Uint32Array(FLOAT.buffer)

var GL_UNSIGNED_SHORT$4 = 5123

function convertToHalfFloat (array) {
  var ushorts = pool.allocType(GL_UNSIGNED_SHORT$4, array.length)

  for (var i = 0; i < array.length; ++i) {
    if (isNaN(array[i])) {
      ushorts[i] = 0xffff
    } else if (array[i] === Infinity) {
      ushorts[i] = 0x7c00
    } else if (array[i] === -Infinity) {
      ushorts[i] = 0xfc00
    } else {
      FLOAT[0] = array[i]
      var x = INT[0]

      var sgn = (x >>> 31) << 15
      var exp = ((x << 1) >>> 24) - 127
      var frac = (x >> 13) & ((1 << 10) - 1)

      if (exp < -24) {
        // round non-representable denormals to 0
        ushorts[i] = sgn
      } else if (exp < -14) {
        // handle denormals
        var s = -14 - exp
        ushorts[i] = sgn + ((frac + (1 << 10)) >> s)
      } else if (exp > 15) {
        // round overflow to +/- Infinity
        ushorts[i] = sgn + 0x7c00
      } else {
        // otherwise convert directly
        ushorts[i] = sgn + ((exp + 15) << 10) + frac
      }
    }
  }

  return ushorts
}

function isArrayLike (s) {
  return Array.isArray(s) || isTypedArray(s)
}

var isPow2$1 = function (v) {
  return !(v & (v - 1)) && (!!v)
}

var GL_COMPRESSED_TEXTURE_FORMATS = 0x86A3

var GL_TEXTURE_2D$1 = 0x0DE1
var GL_TEXTURE_CUBE_MAP$1 = 0x8513
var GL_TEXTURE_CUBE_MAP_POSITIVE_X$1 = 0x8515

var GL_RGBA$1 = 0x1908
var GL_ALPHA = 0x1906
var GL_RGB = 0x1907
var GL_LUMINANCE = 0x1909
var GL_LUMINANCE_ALPHA = 0x190A

var GL_RGBA4 = 0x8056
var GL_RGB5_A1 = 0x8057
var GL_RGB565 = 0x8D62

var GL_UNSIGNED_SHORT_4_4_4_4$1 = 0x8033
var GL_UNSIGNED_SHORT_5_5_5_1$1 = 0x8034
var GL_UNSIGNED_SHORT_5_6_5$1 = 0x8363
var GL_UNSIGNED_INT_24_8_WEBGL$1 = 0x84FA

var GL_DEPTH_COMPONENT = 0x1902
var GL_DEPTH_STENCIL = 0x84F9

var GL_SRGB_EXT = 0x8C40
var GL_SRGB_ALPHA_EXT = 0x8C42

var GL_HALF_FLOAT_OES$1 = 0x8D61

var GL_COMPRESSED_RGB_S3TC_DXT1_EXT = 0x83F0
var GL_COMPRESSED_RGBA_S3TC_DXT1_EXT = 0x83F1
var GL_COMPRESSED_RGBA_S3TC_DXT3_EXT = 0x83F2
var GL_COMPRESSED_RGBA_S3TC_DXT5_EXT = 0x83F3

var GL_COMPRESSED_RGB_ATC_WEBGL = 0x8C92
var GL_COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL = 0x8C93
var GL_COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL = 0x87EE

var GL_COMPRESSED_RGB_PVRTC_4BPPV1_IMG = 0x8C00
var GL_COMPRESSED_RGB_PVRTC_2BPPV1_IMG = 0x8C01
var GL_COMPRESSED_RGBA_PVRTC_4BPPV1_IMG = 0x8C02
var GL_COMPRESSED_RGBA_PVRTC_2BPPV1_IMG = 0x8C03

var GL_COMPRESSED_RGB_ETC1_WEBGL = 0x8D64

var GL_UNSIGNED_BYTE$5 = 0x1401
var GL_UNSIGNED_SHORT$3 = 0x1403
var GL_UNSIGNED_INT$3 = 0x1405
var GL_FLOAT$4 = 0x1406

var GL_TEXTURE_WRAP_S = 0x2802
var GL_TEXTURE_WRAP_T = 0x2803

var GL_REPEAT = 0x2901
var GL_CLAMP_TO_EDGE$1 = 0x812F
var GL_MIRRORED_REPEAT = 0x8370

var GL_TEXTURE_MAG_FILTER = 0x2800
var GL_TEXTURE_MIN_FILTER = 0x2801

var GL_NEAREST$1 = 0x2600
var GL_LINEAR = 0x2601
var GL_NEAREST_MIPMAP_NEAREST$1 = 0x2700
var GL_LINEAR_MIPMAP_NEAREST$1 = 0x2701
var GL_NEAREST_MIPMAP_LINEAR$1 = 0x2702
var GL_LINEAR_MIPMAP_LINEAR$1 = 0x2703

var GL_GENERATE_MIPMAP_HINT = 0x8192
var GL_DONT_CARE = 0x1100
var GL_FASTEST = 0x1101
var GL_NICEST = 0x1102

var GL_TEXTURE_MAX_ANISOTROPY_EXT = 0x84FE

var GL_UNPACK_ALIGNMENT = 0x0CF5
var GL_UNPACK_FLIP_Y_WEBGL = 0x9240
var GL_UNPACK_PREMULTIPLY_ALPHA_WEBGL = 0x9241
var GL_UNPACK_COLORSPACE_CONVERSION_WEBGL = 0x9243

var GL_BROWSER_DEFAULT_WEBGL = 0x9244

var GL_TEXTURE0$1 = 0x84C0

var MIPMAP_FILTERS = [
  GL_NEAREST_MIPMAP_NEAREST$1,
  GL_NEAREST_MIPMAP_LINEAR$1,
  GL_LINEAR_MIPMAP_NEAREST$1,
  GL_LINEAR_MIPMAP_LINEAR$1
]

var CHANNELS_FORMAT = [
  0,
  GL_LUMINANCE,
  GL_LUMINANCE_ALPHA,
  GL_RGB,
  GL_RGBA$1
]

var FORMAT_CHANNELS = {}
FORMAT_CHANNELS[GL_LUMINANCE] =
FORMAT_CHANNELS[GL_ALPHA] =
FORMAT_CHANNELS[GL_DEPTH_COMPONENT] = 1
FORMAT_CHANNELS[GL_DEPTH_STENCIL] =
FORMAT_CHANNELS[GL_LUMINANCE_ALPHA] = 2
FORMAT_CHANNELS[GL_RGB] =
FORMAT_CHANNELS[GL_SRGB_EXT] = 3
FORMAT_CHANNELS[GL_RGBA$1] =
FORMAT_CHANNELS[GL_SRGB_ALPHA_EXT] = 4

function objectName (str) {
  return '[object ' + str + ']'
}

var CANVAS_CLASS = objectName('HTMLCanvasElement')
var OFFSCREENCANVAS_CLASS = objectName('OffscreenCanvas')
var CONTEXT2D_CLASS = objectName('CanvasRenderingContext2D')
var BITMAP_CLASS = objectName('ImageBitmap')
var IMAGE_CLASS = objectName('HTMLImageElement')
var VIDEO_CLASS = objectName('HTMLVideoElement')

var PIXEL_CLASSES = Object.keys(arrayTypes).concat([
  CANVAS_CLASS,
  OFFSCREENCANVAS_CLASS,
  CONTEXT2D_CLASS,
  BITMAP_CLASS,
  IMAGE_CLASS,
  VIDEO_CLASS
])

// for every texture type, store
// the size in bytes.
var TYPE_SIZES = []
TYPE_SIZES[GL_UNSIGNED_BYTE$5] = 1
TYPE_SIZES[GL_FLOAT$4] = 4
TYPE_SIZES[GL_HALF_FLOAT_OES$1] = 2

TYPE_SIZES[GL_UNSIGNED_SHORT$3] = 2
TYPE_SIZES[GL_UNSIGNED_INT$3] = 4

var FORMAT_SIZES_SPECIAL = []
FORMAT_SIZES_SPECIAL[GL_RGBA4] = 2
FORMAT_SIZES_SPECIAL[GL_RGB5_A1] = 2
FORMAT_SIZES_SPECIAL[GL_RGB565] = 2
FORMAT_SIZES_SPECIAL[GL_DEPTH_STENCIL] = 4

FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGB_S3TC_DXT1_EXT] = 0.5
FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGBA_S3TC_DXT1_EXT] = 0.5
FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGBA_S3TC_DXT3_EXT] = 1
FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGBA_S3TC_DXT5_EXT] = 1

FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGB_ATC_WEBGL] = 0.5
FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL] = 1
FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL] = 1

FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGB_PVRTC_4BPPV1_IMG] = 0.5
FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGB_PVRTC_2BPPV1_IMG] = 0.25
FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGBA_PVRTC_4BPPV1_IMG] = 0.5
FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGBA_PVRTC_2BPPV1_IMG] = 0.25

FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGB_ETC1_WEBGL] = 0.5

function isNumericArray (arr) {
  return (
    Array.isArray(arr) &&
    (arr.length === 0 ||
    typeof arr[0] === 'number'))
}

function isRectArray (arr) {
  if (!Array.isArray(arr)) {
    return false
  }
  var width = arr.length
  if (width === 0 || !isArrayLike(arr[0])) {
    return false
  }
  return true
}

function classString (x) {
  return Object.prototype.toString.call(x)
}

function isCanvasElement (object) {
  return classString(object) === CANVAS_CLASS
}

function isOffscreenCanvas (object) {
  return classString(object) === OFFSCREENCANVAS_CLASS
}

function isContext2D (object) {
  return classString(object) === CONTEXT2D_CLASS
}

function isBitmap (object) {
  return classString(object) === BITMAP_CLASS
}

function isImageElement (object) {
  return classString(object) === IMAGE_CLASS
}

function isVideoElement (object) {
  return classString(object) === VIDEO_CLASS
}

function isPixelData (object) {
  if (!object) {
    return false
  }
  var className = classString(object)
  if (PIXEL_CLASSES.indexOf(className) >= 0) {
    return true
  }
  return (
    isNumericArray(object) ||
    isRectArray(object) ||
    isNDArrayLike(object))
}

function typedArrayCode$1 (data) {
  return arrayTypes[Object.prototype.toString.call(data)] | 0
}

function convertData (result, data) {
  var n = data.length
  switch (result.type) {
    case GL_UNSIGNED_BYTE$5:
    case GL_UNSIGNED_SHORT$3:
    case GL_UNSIGNED_INT$3:
    case GL_FLOAT$4:
      var converted = pool.allocType(result.type, n)
      converted.set(data)
      result.data = converted
      break

    case GL_HALF_FLOAT_OES$1:
      result.data = convertToHalfFloat(data)
      break

    default:
      check$1.raise('unsupported texture type, must specify a typed array')
  }
}

function preConvert (image, n) {
  return pool.allocType(
    image.type === GL_HALF_FLOAT_OES$1
      ? GL_FLOAT$4
      : image.type, n)
}

function postConvert (image, data) {
  if (image.type === GL_HALF_FLOAT_OES$1) {
    image.data = convertToHalfFloat(data)
    pool.freeType(data)
  } else {
    image.data = data
  }
}

function transposeData (image, array, strideX, strideY, strideC, offset) {
  var w = image.width
  var h = image.height
  var c = image.channels
  var n = w * h * c
  var data = preConvert(image, n)

  var p = 0
  for (var i = 0; i < h; ++i) {
    for (var j = 0; j < w; ++j) {
      for (var k = 0; k < c; ++k) {
        data[p++] = array[strideX * j + strideY * i + strideC * k + offset]
      }
    }
  }

  postConvert(image, data)
}

function getTextureSize (format, type, width, height, isMipmap, isCube) {
  var s
  if (typeof FORMAT_SIZES_SPECIAL[format] !== 'undefined') {
    // we have a special array for dealing with weird color formats such as RGB5A1
    s = FORMAT_SIZES_SPECIAL[format]
  } else {
    s = FORMAT_CHANNELS[format] * TYPE_SIZES[type]
  }

  if (isCube) {
    s *= 6
  }

  if (isMipmap) {
    // compute the total size of all the mipmaps.
    var total = 0

    var w = width
    while (w >= 1) {
      // we can only use mipmaps on a square image,
      // so we can simply use the width and ignore the height:
      total += s * w * w
      w /= 2
    }
    return total
  } else {
    return s * width * height
  }
}

function createTextureSet (
  gl, extensions, limits, reglPoll, contextState, stats, config) {
  // -------------------------------------------------------
  // Initialize constants and parameter tables here
  // -------------------------------------------------------
  var mipmapHint = {
    "don't care": GL_DONT_CARE,
    'dont care': GL_DONT_CARE,
    'nice': GL_NICEST,
    'fast': GL_FASTEST
  }

  var wrapModes = {
    'repeat': GL_REPEAT,
    'clamp': GL_CLAMP_TO_EDGE$1,
    'mirror': GL_MIRRORED_REPEAT
  }

  var magFilters = {
    'nearest': GL_NEAREST$1,
    'linear': GL_LINEAR
  }

  var minFilters = extend({
    'mipmap': GL_LINEAR_MIPMAP_LINEAR$1,
    'nearest mipmap nearest': GL_NEAREST_MIPMAP_NEAREST$1,
    'linear mipmap nearest': GL_LINEAR_MIPMAP_NEAREST$1,
    'nearest mipmap linear': GL_NEAREST_MIPMAP_LINEAR$1,
    'linear mipmap linear': GL_LINEAR_MIPMAP_LINEAR$1
  }, magFilters)

  var colorSpace = {
    'none': 0,
    'browser': GL_BROWSER_DEFAULT_WEBGL
  }

  var textureTypes = {
    'uint8': GL_UNSIGNED_BYTE$5,
    'rgba4': GL_UNSIGNED_SHORT_4_4_4_4$1,
    'rgb565': GL_UNSIGNED_SHORT_5_6_5$1,
    'rgb5 a1': GL_UNSIGNED_SHORT_5_5_5_1$1
  }

  var textureFormats = {
    'alpha': GL_ALPHA,
    'luminance': GL_LUMINANCE,
    'luminance alpha': GL_LUMINANCE_ALPHA,
    'rgb': GL_RGB,
    'rgba': GL_RGBA$1,
    'rgba4': GL_RGBA4,
    'rgb5 a1': GL_RGB5_A1,
    'rgb565': GL_RGB565
  }

  var compressedTextureFormats = {}

  if (extensions.ext_srgb) {
    textureFormats.srgb = GL_SRGB_EXT
    textureFormats.srgba = GL_SRGB_ALPHA_EXT
  }

  if (extensions.oes_texture_float) {
    textureTypes.float32 = textureTypes.float = GL_FLOAT$4
  }

  if (extensions.oes_texture_half_float) {
    textureTypes['float16'] = textureTypes['half float'] = GL_HALF_FLOAT_OES$1
  }

  if (extensions.webgl_depth_texture) {
    extend(textureFormats, {
      'depth': GL_DEPTH_COMPONENT,
      'depth stencil': GL_DEPTH_STENCIL
    })

    extend(textureTypes, {
      'uint16': GL_UNSIGNED_SHORT$3,
      'uint32': GL_UNSIGNED_INT$3,
      'depth stencil': GL_UNSIGNED_INT_24_8_WEBGL$1
    })
  }

  if (extensions.webgl_compressed_texture_s3tc) {
    extend(compressedTextureFormats, {
      'rgb s3tc dxt1': GL_COMPRESSED_RGB_S3TC_DXT1_EXT,
      'rgba s3tc dxt1': GL_COMPRESSED_RGBA_S3TC_DXT1_EXT,
      'rgba s3tc dxt3': GL_COMPRESSED_RGBA_S3TC_DXT3_EXT,
      'rgba s3tc dxt5': GL_COMPRESSED_RGBA_S3TC_DXT5_EXT
    })
  }

  if (extensions.webgl_compressed_texture_atc) {
    extend(compressedTextureFormats, {
      'rgb atc': GL_COMPRESSED_RGB_ATC_WEBGL,
      'rgba atc explicit alpha': GL_COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL,
      'rgba atc interpolated alpha': GL_COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL
    })
  }

  if (extensions.webgl_compressed_texture_pvrtc) {
    extend(compressedTextureFormats, {
      'rgb pvrtc 4bppv1': GL_COMPRESSED_RGB_PVRTC_4BPPV1_IMG,
      'rgb pvrtc 2bppv1': GL_COMPRESSED_RGB_PVRTC_2BPPV1_IMG,
      'rgba pvrtc 4bppv1': GL_COMPRESSED_RGBA_PVRTC_4BPPV1_IMG,
      'rgba pvrtc 2bppv1': GL_COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
    })
  }

  if (extensions.webgl_compressed_texture_etc1) {
    compressedTextureFormats['rgb etc1'] = GL_COMPRESSED_RGB_ETC1_WEBGL
  }

  // Copy over all texture formats
  var supportedCompressedFormats = Array.prototype.slice.call(
    gl.getParameter(GL_COMPRESSED_TEXTURE_FORMATS))
  Object.keys(compressedTextureFormats).forEach(function (name) {
    var format = compressedTextureFormats[name]
    if (supportedCompressedFormats.indexOf(format) >= 0) {
      textureFormats[name] = format
    }
  })

  var supportedFormats = Object.keys(textureFormats)
  limits.textureFormats = supportedFormats

  // associate with every format string its
  // corresponding GL-value.
  var textureFormatsInvert = []
  Object.keys(textureFormats).forEach(function (key) {
    var val = textureFormats[key]
    textureFormatsInvert[val] = key
  })

  // associate with every type string its
  // corresponding GL-value.
  var textureTypesInvert = []
  Object.keys(textureTypes).forEach(function (key) {
    var val = textureTypes[key]
    textureTypesInvert[val] = key
  })

  var magFiltersInvert = []
  Object.keys(magFilters).forEach(function (key) {
    var val = magFilters[key]
    magFiltersInvert[val] = key
  })

  var minFiltersInvert = []
  Object.keys(minFilters).forEach(function (key) {
    var val = minFilters[key]
    minFiltersInvert[val] = key
  })

  var wrapModesInvert = []
  Object.keys(wrapModes).forEach(function (key) {
    var val = wrapModes[key]
    wrapModesInvert[val] = key
  })

  // colorFormats[] gives the format (channels) associated to an
  // internalformat
  var colorFormats = supportedFormats.reduce(function (color, key) {
    var glenum = textureFormats[key]
    if (glenum === GL_LUMINANCE ||
        glenum === GL_ALPHA ||
        glenum === GL_LUMINANCE ||
        glenum === GL_LUMINANCE_ALPHA ||
        glenum === GL_DEPTH_COMPONENT ||
        glenum === GL_DEPTH_STENCIL ||
        (extensions.ext_srgb &&
                (glenum === GL_SRGB_EXT ||
                 glenum === GL_SRGB_ALPHA_EXT))) {
      color[glenum] = glenum
    } else if (glenum === GL_RGB5_A1 || key.indexOf('rgba') >= 0) {
      color[glenum] = GL_RGBA$1
    } else {
      color[glenum] = GL_RGB
    }
    return color
  }, {})

  function TexFlags () {
    // format info
    this.internalformat = GL_RGBA$1
    this.format = GL_RGBA$1
    this.type = GL_UNSIGNED_BYTE$5
    this.compressed = false

    // pixel storage
    this.premultiplyAlpha = false
    this.flipY = false
    this.unpackAlignment = 1
    this.colorSpace = GL_BROWSER_DEFAULT_WEBGL

    // shape info
    this.width = 0
    this.height = 0
    this.channels = 0
  }

  function copyFlags (result, other) {
    result.internalformat = other.internalformat
    result.format = other.format
    result.type = other.type
    result.compressed = other.compressed

    result.premultiplyAlpha = other.premultiplyAlpha
    result.flipY = other.flipY
    result.unpackAlignment = other.unpackAlignment
    result.colorSpace = other.colorSpace

    result.width = other.width
    result.height = other.height
    result.channels = other.channels
  }

  function parseFlags (flags, options) {
    if (typeof options !== 'object' || !options) {
      return
    }

    if ('premultiplyAlpha' in options) {
      check$1.type(options.premultiplyAlpha, 'boolean',
        'invalid premultiplyAlpha')
      flags.premultiplyAlpha = options.premultiplyAlpha
    }

    if ('flipY' in options) {
      check$1.type(options.flipY, 'boolean',
        'invalid texture flip')
      flags.flipY = options.flipY
    }

    if ('alignment' in options) {
      check$1.oneOf(options.alignment, [1, 2, 4, 8],
        'invalid texture unpack alignment')
      flags.unpackAlignment = options.alignment
    }

    if ('colorSpace' in options) {
      check$1.parameter(options.colorSpace, colorSpace,
        'invalid colorSpace')
      flags.colorSpace = colorSpace[options.colorSpace]
    }

    if ('type' in options) {
      var type = options.type
      check$1(extensions.oes_texture_float ||
        !(type === 'float' || type === 'float32'),
      'you must enable the OES_texture_float extension in order to use floating point textures.')
      check$1(extensions.oes_texture_half_float ||
        !(type === 'half float' || type === 'float16'),
      'you must enable the OES_texture_half_float extension in order to use 16-bit floating point textures.')
      check$1(extensions.webgl_depth_texture ||
        !(type === 'uint16' || type === 'uint32' || type === 'depth stencil'),
      'you must enable the WEBGL_depth_texture extension in order to use depth/stencil textures.')
      check$1.parameter(type, textureTypes,
        'invalid texture type')
      flags.type = textureTypes[type]
    }

    var w = flags.width
    var h = flags.height
    var c = flags.channels
    var hasChannels = false
    if ('shape' in options) {
      check$1(Array.isArray(options.shape) && options.shape.length >= 2,
        'shape must be an array')
      w = options.shape[0]
      h = options.shape[1]
      if (options.shape.length === 3) {
        c = options.shape[2]
        check$1(c > 0 && c <= 4, 'invalid number of channels')
        hasChannels = true
      }
      check$1(w >= 0 && w <= limits.maxTextureSize, 'invalid width')
      check$1(h >= 0 && h <= limits.maxTextureSize, 'invalid height')
    } else {
      if ('radius' in options) {
        w = h = options.radius
        check$1(w >= 0 && w <= limits.maxTextureSize, 'invalid radius')
      }
      if ('width' in options) {
        w = options.width
        check$1(w >= 0 && w <= limits.maxTextureSize, 'invalid width')
      }
      if ('height' in options) {
        h = options.height
        check$1(h >= 0 && h <= limits.maxTextureSize, 'invalid height')
      }
      if ('channels' in options) {
        c = options.channels
        check$1(c > 0 && c <= 4, 'invalid number of channels')
        hasChannels = true
      }
    }
    flags.width = w | 0
    flags.height = h | 0
    flags.channels = c | 0

    var hasFormat = false
    if ('format' in options) {
      var formatStr = options.format
      check$1(extensions.webgl_depth_texture ||
        !(formatStr === 'depth' || formatStr === 'depth stencil'),
      'you must enable the WEBGL_depth_texture extension in order to use depth/stencil textures.')
      check$1.parameter(formatStr, textureFormats,
        'invalid texture format')
      var internalformat = flags.internalformat = textureFormats[formatStr]
      flags.format = colorFormats[internalformat]
      if (formatStr in textureTypes) {
        if (!('type' in options)) {
          flags.type = textureTypes[formatStr]
        }
      }
      if (formatStr in compressedTextureFormats) {
        flags.compressed = true
      }
      hasFormat = true
    }

    // Reconcile channels and format
    if (!hasChannels && hasFormat) {
      flags.channels = FORMAT_CHANNELS[flags.format]
    } else if (hasChannels && !hasFormat) {
      if (flags.channels !== CHANNELS_FORMAT[flags.format]) {
        flags.format = flags.internalformat = CHANNELS_FORMAT[flags.channels]
      }
    } else if (hasFormat && hasChannels) {
      check$1(
        flags.channels === FORMAT_CHANNELS[flags.format],
        'number of channels inconsistent with specified format')
    }
  }

  function setFlags (flags) {
    gl.pixelStorei(GL_UNPACK_FLIP_Y_WEBGL, flags.flipY)
    gl.pixelStorei(GL_UNPACK_PREMULTIPLY_ALPHA_WEBGL, flags.premultiplyAlpha)
    gl.pixelStorei(GL_UNPACK_COLORSPACE_CONVERSION_WEBGL, flags.colorSpace)
    gl.pixelStorei(GL_UNPACK_ALIGNMENT, flags.unpackAlignment)
  }

  // -------------------------------------------------------
  // Tex image data
  // -------------------------------------------------------
  function TexImage () {
    TexFlags.call(this)

    this.xOffset = 0
    this.yOffset = 0

    // data
    this.data = null
    this.needsFree = false

    // html element
    this.element = null

    // copyTexImage info
    this.needsCopy = false
  }

  function parseImage (image, options) {
    var data = null
    if (isPixelData(options)) {
      data = options
    } else if (options) {
      check$1.type(options, 'object', 'invalid pixel data type')
      parseFlags(image, options)
      if ('x' in options) {
        image.xOffset = options.x | 0
      }
      if ('y' in options) {
        image.yOffset = options.y | 0
      }
      if (isPixelData(options.data)) {
        data = options.data
      }
    }

    check$1(
      !image.compressed ||
      data instanceof Uint8Array,
      'compressed texture data must be stored in a uint8array')

    if (options.copy) {
      check$1(!data, 'can not specify copy and data field for the same texture')
      var viewW = contextState.viewportWidth
      var viewH = contextState.viewportHeight
      image.width = image.width || (viewW - image.xOffset)
      image.height = image.height || (viewH - image.yOffset)
      image.needsCopy = true
      check$1(image.xOffset >= 0 && image.xOffset < viewW &&
            image.yOffset >= 0 && image.yOffset < viewH &&
            image.width > 0 && image.width <= viewW &&
            image.height > 0 && image.height <= viewH,
      'copy texture read out of bounds')
    } else if (!data) {
      image.width = image.width || 1
      image.height = image.height || 1
      image.channels = image.channels || 4
    } else if (isTypedArray(data)) {
      image.channels = image.channels || 4
      image.data = data
      if (!('type' in options) && image.type === GL_UNSIGNED_BYTE$5) {
        image.type = typedArrayCode$1(data)
      }
    } else if (isNumericArray(data)) {
      image.channels = image.channels || 4
      convertData(image, data)
      image.alignment = 1
      image.needsFree = true
    } else if (isNDArrayLike(data)) {
      var array = data.data
      if (!Array.isArray(array) && image.type === GL_UNSIGNED_BYTE$5) {
        image.type = typedArrayCode$1(array)
      }
      var shape = data.shape
      var stride = data.stride
      var shapeX, shapeY, shapeC, strideX, strideY, strideC
      if (shape.length === 3) {
        shapeC = shape[2]
        strideC = stride[2]
      } else {
        check$1(shape.length === 2, 'invalid ndarray pixel data, must be 2 or 3D')
        shapeC = 1
        strideC = 1
      }
      shapeX = shape[0]
      shapeY = shape[1]
      strideX = stride[0]
      strideY = stride[1]
      image.alignment = 1
      image.width = shapeX
      image.height = shapeY
      image.channels = shapeC
      image.format = image.internalformat = CHANNELS_FORMAT[shapeC]
      image.needsFree = true
      transposeData(image, array, strideX, strideY, strideC, data.offset)
    } else if (isCanvasElement(data) || isOffscreenCanvas(data) || isContext2D(data)) {
      if (isCanvasElement(data) || isOffscreenCanvas(data)) {
        image.element = data
      } else {
        image.element = data.canvas
      }
      image.width = image.element.width
      image.height = image.element.height
      image.channels = 4
    } else if (isBitmap(data)) {
      image.element = data
      image.width = data.width
      image.height = data.height
      image.channels = 4
    } else if (isImageElement(data)) {
      image.element = data
      image.width = data.naturalWidth
      image.height = data.naturalHeight
      image.channels = 4
    } else if (isVideoElement(data)) {
      image.element = data
      image.width = data.videoWidth
      image.height = data.videoHeight
      image.channels = 4
    } else if (isRectArray(data)) {
      var w = image.width || data[0].length
      var h = image.height || data.length
      var c = image.channels
      if (isArrayLike(data[0][0])) {
        c = c || data[0][0].length
      } else {
        c = c || 1
      }
      var arrayShape = flattenUtils.shape(data)
      var n = 1
      for (var dd = 0; dd < arrayShape.length; ++dd) {
        n *= arrayShape[dd]
      }
      var allocData = preConvert(image, n)
      flattenUtils.flatten(data, arrayShape, '', allocData)
      postConvert(image, allocData)
      image.alignment = 1
      image.width = w
      image.height = h
      image.channels = c
      image.format = image.internalformat = CHANNELS_FORMAT[c]
      image.needsFree = true
    }

    if (image.type === GL_FLOAT$4) {
      check$1(limits.extensions.indexOf('oes_texture_float') >= 0,
        'oes_texture_float extension not enabled')
    } else if (image.type === GL_HALF_FLOAT_OES$1) {
      check$1(limits.extensions.indexOf('oes_texture_half_float') >= 0,
        'oes_texture_half_float extension not enabled')
    }

    // do compressed texture  validation here.
  }

  function setImage (info, target, miplevel) {
    var element = info.element
    var data = info.data
    var internalformat = info.internalformat
    var format = info.format
    var type = info.type
    var width = info.width
    var height = info.height

    setFlags(info)

    if (element) {
      gl.texImage2D(target, miplevel, format, format, type, element)
    } else if (info.compressed) {
      gl.compressedTexImage2D(target, miplevel, internalformat, width, height, 0, data)
    } else if (info.needsCopy) {
      reglPoll()
      gl.copyTexImage2D(
        target, miplevel, format, info.xOffset, info.yOffset, width, height, 0)
    } else {
      gl.texImage2D(target, miplevel, format, width, height, 0, format, type, data || null)
    }
  }

  function setSubImage (info, target, x, y, miplevel) {
    var element = info.element
    var data = info.data
    var internalformat = info.internalformat
    var format = info.format
    var type = info.type
    var width = info.width
    var height = info.height

    setFlags(info)

    if (element) {
      gl.texSubImage2D(
        target, miplevel, x, y, format, type, element)
    } else if (info.compressed) {
      gl.compressedTexSubImage2D(
        target, miplevel, x, y, internalformat, width, height, data)
    } else if (info.needsCopy) {
      reglPoll()
      gl.copyTexSubImage2D(
        target, miplevel, x, y, info.xOffset, info.yOffset, width, height)
    } else {
      gl.texSubImage2D(
        target, miplevel, x, y, width, height, format, type, data)
    }
  }

  // texImage pool
  var imagePool = []

  function allocImage () {
    return imagePool.pop() || new TexImage()
  }

  function freeImage (image) {
    if (image.needsFree) {
      pool.freeType(image.data)
    }
    TexImage.call(image)
    imagePool.push(image)
  }

  // -------------------------------------------------------
  // Mip map
  // -------------------------------------------------------
  function MipMap () {
    TexFlags.call(this)

    this.genMipmaps = false
    this.mipmapHint = GL_DONT_CARE
    this.mipmask = 0
    this.images = Array(16)
  }

  function parseMipMapFromShape (mipmap, width, height) {
    var img = mipmap.images[0] = allocImage()
    mipmap.mipmask = 1
    img.width = mipmap.width = width
    img.height = mipmap.height = height
    img.channels = mipmap.channels = 4
  }

  function parseMipMapFromObject (mipmap, options) {
    var imgData = null
    if (isPixelData(options)) {
      imgData = mipmap.images[0] = allocImage()
      copyFlags(imgData, mipmap)
      parseImage(imgData, options)
      mipmap.mipmask = 1
    } else {
      parseFlags(mipmap, options)
      if (Array.isArray(options.mipmap)) {
        var mipData = options.mipmap
        for (var i = 0; i < mipData.length; ++i) {
          imgData = mipmap.images[i] = allocImage()
          copyFlags(imgData, mipmap)
          imgData.width >>= i
          imgData.height >>= i
          parseImage(imgData, mipData[i])
          mipmap.mipmask |= (1 << i)
        }
      } else {
        imgData = mipmap.images[0] = allocImage()
        copyFlags(imgData, mipmap)
        parseImage(imgData, options)
        mipmap.mipmask = 1
      }
    }
    copyFlags(mipmap, mipmap.images[0])

    // For textures of the compressed format WEBGL_compressed_texture_s3tc
    // we must have that
    //
    // "When level equals zero width and height must be a multiple of 4.
    // When level is greater than 0 width and height must be 0, 1, 2 or a multiple of 4. "
    //
    // but we do not yet support having multiple mipmap levels for compressed textures,
    // so we only test for level zero.

    if (
      mipmap.compressed &&
      (
        mipmap.internalformat === GL_COMPRESSED_RGB_S3TC_DXT1_EXT ||
        mipmap.internalformat === GL_COMPRESSED_RGBA_S3TC_DXT1_EXT ||
        mipmap.internalformat === GL_COMPRESSED_RGBA_S3TC_DXT3_EXT ||
        mipmap.internalformat === GL_COMPRESSED_RGBA_S3TC_DXT5_EXT
      )
    ) {
      check$1(mipmap.width % 4 === 0 && mipmap.height % 4 === 0,
        'for compressed texture formats, mipmap level 0 must have width and height that are a multiple of 4')
    }
  }

  function setMipMap (mipmap, target) {
    var images = mipmap.images
    for (var i = 0; i < images.length; ++i) {
      if (!images[i]) {
        return
      }
      setImage(images[i], target, i)
    }
  }

  var mipPool = []

  function allocMipMap () {
    var result = mipPool.pop() || new MipMap()
    TexFlags.call(result)
    result.mipmask = 0
    for (var i = 0; i < 16; ++i) {
      result.images[i] = null
    }
    return result
  }

  function freeMipMap (mipmap) {
    var images = mipmap.images
    for (var i = 0; i < images.length; ++i) {
      if (images[i]) {
        freeImage(images[i])
      }
      images[i] = null
    }
    mipPool.push(mipmap)
  }

  // -------------------------------------------------------
  // Tex info
  // -------------------------------------------------------
  function TexInfo () {
    this.minFilter = GL_NEAREST$1
    this.magFilter = GL_NEAREST$1

    this.wrapS = GL_CLAMP_TO_EDGE$1
    this.wrapT = GL_CLAMP_TO_EDGE$1

    this.anisotropic = 1

    this.genMipmaps = false
    this.mipmapHint = GL_DONT_CARE
  }

  function parseTexInfo (info, options) {
    if ('min' in options) {
      var minFilter = options.min
      check$1.parameter(minFilter, minFilters)
      info.minFilter = minFilters[minFilter]
      if (MIPMAP_FILTERS.indexOf(info.minFilter) >= 0 && !('faces' in options)) {
        info.genMipmaps = true
      }
    }

    if ('mag' in options) {
      var magFilter = options.mag
      check$1.parameter(magFilter, magFilters)
      info.magFilter = magFilters[magFilter]
    }

    var wrapS = info.wrapS
    var wrapT = info.wrapT
    if ('wrap' in options) {
      var wrap = options.wrap
      if (typeof wrap === 'string') {
        check$1.parameter(wrap, wrapModes)
        wrapS = wrapT = wrapModes[wrap]
      } else if (Array.isArray(wrap)) {
        check$1.parameter(wrap[0], wrapModes)
        check$1.parameter(wrap[1], wrapModes)
        wrapS = wrapModes[wrap[0]]
        wrapT = wrapModes[wrap[1]]
      }
    } else {
      if ('wrapS' in options) {
        var optWrapS = options.wrapS
        check$1.parameter(optWrapS, wrapModes)
        wrapS = wrapModes[optWrapS]
      }
      if ('wrapT' in options) {
        var optWrapT = options.wrapT
        check$1.parameter(optWrapT, wrapModes)
        wrapT = wrapModes[optWrapT]
      }
    }
    info.wrapS = wrapS
    info.wrapT = wrapT

    if ('anisotropic' in options) {
      var anisotropic = options.anisotropic
      check$1(typeof anisotropic === 'number' &&
         anisotropic >= 1 && anisotropic <= limits.maxAnisotropic,
      'aniso samples must be between 1 and ')
      info.anisotropic = options.anisotropic
    }

    if ('mipmap' in options) {
      var hasMipMap = false
      switch (typeof options.mipmap) {
        case 'string':
          check$1.parameter(options.mipmap, mipmapHint,
            'invalid mipmap hint')
          info.mipmapHint = mipmapHint[options.mipmap]
          info.genMipmaps = true
          hasMipMap = true
          break

        case 'boolean':
          hasMipMap = info.genMipmaps = options.mipmap
          break

        case 'object':
          check$1(Array.isArray(options.mipmap), 'invalid mipmap type')
          info.genMipmaps = false
          hasMipMap = true
          break

        default:
          check$1.raise('invalid mipmap type')
      }
      if (hasMipMap && !('min' in options)) {
        info.minFilter = GL_NEAREST_MIPMAP_NEAREST$1
      }
    }
  }

  function setTexInfo (info, target) {
    gl.texParameteri(target, GL_TEXTURE_MIN_FILTER, info.minFilter)
    gl.texParameteri(target, GL_TEXTURE_MAG_FILTER, info.magFilter)
    gl.texParameteri(target, GL_TEXTURE_WRAP_S, info.wrapS)
    gl.texParameteri(target, GL_TEXTURE_WRAP_T, info.wrapT)
    if (extensions.ext_texture_filter_anisotropic) {
      gl.texParameteri(target, GL_TEXTURE_MAX_ANISOTROPY_EXT, info.anisotropic)
    }
    if (info.genMipmaps) {
      gl.hint(GL_GENERATE_MIPMAP_HINT, info.mipmapHint)
      gl.generateMipmap(target)
    }
  }

  // -------------------------------------------------------
  // Full texture object
  // -------------------------------------------------------
  var textureCount = 0
  var textureSet = {}
  var numTexUnits = limits.maxTextureUnits
  var textureUnits = Array(numTexUnits).map(function () {
    return null
  })

  function REGLTexture (target) {
    TexFlags.call(this)
    this.mipmask = 0
    this.internalformat = GL_RGBA$1

    this.id = textureCount++

    this.refCount = 1

    this.target = target
    this.texture = gl.createTexture()

    this.unit = -1
    this.bindCount = 0

    this.texInfo = new TexInfo()

    if (config.profile) {
      this.stats = { size: 0 }
    }
  }

  function tempBind (texture) {
    gl.activeTexture(GL_TEXTURE0$1)
    gl.bindTexture(texture.target, texture.texture)
  }

  function tempRestore () {
    var prev = textureUnits[0]
    if (prev) {
      gl.bindTexture(prev.target, prev.texture)
    } else {
      gl.bindTexture(GL_TEXTURE_2D$1, null)
    }
  }

  function destroy (texture) {
    var handle = texture.texture
    check$1(handle, 'must not double destroy texture')
    var unit = texture.unit
    var target = texture.target
    if (unit >= 0) {
      gl.activeTexture(GL_TEXTURE0$1 + unit)
      gl.bindTexture(target, null)
      textureUnits[unit] = null
    }
    gl.deleteTexture(handle)
    texture.texture = null
    texture.params = null
    texture.pixels = null
    texture.refCount = 0
    delete textureSet[texture.id]
    stats.textureCount--
  }

  extend(REGLTexture.prototype, {
    bind: function () {
      var texture = this
      texture.bindCount += 1
      var unit = texture.unit
      if (unit < 0) {
        for (var i = 0; i < numTexUnits; ++i) {
          var other = textureUnits[i]
          if (other) {
            if (other.bindCount > 0) {
              continue
            }
            other.unit = -1
          }
          textureUnits[i] = texture
          unit = i
          break
        }
        if (unit >= numTexUnits) {
          check$1.raise('insufficient number of texture units')
        }
        if (config.profile && stats.maxTextureUnits < (unit + 1)) {
          stats.maxTextureUnits = unit + 1 // +1, since the units are zero-based
        }
        texture.unit = unit
        gl.activeTexture(GL_TEXTURE0$1 + unit)
        gl.bindTexture(texture.target, texture.texture)
      }
      return unit
    },

    unbind: function () {
      this.bindCount -= 1
    },

    decRef: function () {
      if (--this.refCount <= 0) {
        destroy(this)
      }
    }
  })

  function createTexture2D (a, b) {
    var texture = new REGLTexture(GL_TEXTURE_2D$1)
    textureSet[texture.id] = texture
    stats.textureCount++

    function reglTexture2D (a, b) {
      var texInfo = texture.texInfo
      TexInfo.call(texInfo)
      var mipData = allocMipMap()

      if (typeof a === 'number') {
        if (typeof b === 'number') {
          parseMipMapFromShape(mipData, a | 0, b | 0)
        } else {
          parseMipMapFromShape(mipData, a | 0, a | 0)
        }
      } else if (a) {
        check$1.type(a, 'object', 'invalid arguments to regl.texture')
        parseTexInfo(texInfo, a)
        parseMipMapFromObject(mipData, a)
      } else {
        // empty textures get assigned a default shape of 1x1
        parseMipMapFromShape(mipData, 1, 1)
      }

      if (texInfo.genMipmaps) {
        mipData.mipmask = (mipData.width << 1) - 1
      }
      texture.mipmask = mipData.mipmask

      copyFlags(texture, mipData)

      check$1.texture2D(texInfo, mipData, limits)
      texture.internalformat = mipData.internalformat

      reglTexture2D.width = mipData.width
      reglTexture2D.height = mipData.height

      tempBind(texture)
      setMipMap(mipData, GL_TEXTURE_2D$1)
      setTexInfo(texInfo, GL_TEXTURE_2D$1)
      tempRestore()

      freeMipMap(mipData)

      if (config.profile) {
        texture.stats.size = getTextureSize(
          texture.internalformat,
          texture.type,
          mipData.width,
          mipData.height,
          texInfo.genMipmaps,
          false)
      }
      reglTexture2D.format = textureFormatsInvert[texture.internalformat]
      reglTexture2D.type = textureTypesInvert[texture.type]

      reglTexture2D.mag = magFiltersInvert[texInfo.magFilter]
      reglTexture2D.min = minFiltersInvert[texInfo.minFilter]

      reglTexture2D.wrapS = wrapModesInvert[texInfo.wrapS]
      reglTexture2D.wrapT = wrapModesInvert[texInfo.wrapT]

      return reglTexture2D
    }

    function subimage (image, x_, y_, level_) {
      check$1(!!image, 'must specify image data')

      var x = x_ | 0
      var y = y_ | 0
      var level = level_ | 0

      var imageData = allocImage()
      copyFlags(imageData, texture)
      imageData.width = 0
      imageData.height = 0
      parseImage(imageData, image)
      imageData.width = imageData.width || ((texture.width >> level) - x)
      imageData.height = imageData.height || ((texture.height >> level) - y)

      check$1(
        texture.type === imageData.type &&
        texture.format === imageData.format &&
        texture.internalformat === imageData.internalformat,
        'incompatible format for texture.subimage')
      check$1(
        x >= 0 && y >= 0 &&
        x + imageData.width <= texture.width &&
        y + imageData.height <= texture.height,
        'texture.subimage write out of bounds')
      check$1(
        texture.mipmask & (1 << level),
        'missing mipmap data')
      check$1(
        imageData.data || imageData.element || imageData.needsCopy,
        'missing image data')

      tempBind(texture)
      setSubImage(imageData, GL_TEXTURE_2D$1, x, y, level)
      tempRestore()

      freeImage(imageData)

      return reglTexture2D
    }

    function resize (w_, h_) {
      var w = w_ | 0
      var h = (h_ | 0) || w
      if (w === texture.width && h === texture.height) {
        return reglTexture2D
      }

      reglTexture2D.width = texture.width = w
      reglTexture2D.height = texture.height = h

      tempBind(texture)

      for (var i = 0; texture.mipmask >> i; ++i) {
        var _w = w >> i
        var _h = h >> i
        if (!_w || !_h) break
        gl.texImage2D(
          GL_TEXTURE_2D$1,
          i,
          texture.format,
          _w,
          _h,
          0,
          texture.format,
          texture.type,
          null)
      }
      tempRestore()

      // also, recompute the texture size.
      if (config.profile) {
        texture.stats.size = getTextureSize(
          texture.internalformat,
          texture.type,
          w,
          h,
          false,
          false)
      }

      return reglTexture2D
    }

    reglTexture2D(a, b)

    reglTexture2D.subimage = subimage
    reglTexture2D.resize = resize
    reglTexture2D._reglType = 'texture2d'
    reglTexture2D._texture = texture
    if (config.profile) {
      reglTexture2D.stats = texture.stats
    }
    reglTexture2D.destroy = function () {
      texture.decRef()
    }

    return reglTexture2D
  }

  function createTextureCube (a0, a1, a2, a3, a4, a5) {
    var texture = new REGLTexture(GL_TEXTURE_CUBE_MAP$1)
    textureSet[texture.id] = texture
    stats.cubeCount++

    var faces = new Array(6)

    function reglTextureCube (a0, a1, a2, a3, a4, a5) {
      var i
      var texInfo = texture.texInfo
      TexInfo.call(texInfo)
      for (i = 0; i < 6; ++i) {
        faces[i] = allocMipMap()
      }

      if (typeof a0 === 'number' || !a0) {
        var s = (a0 | 0) || 1
        for (i = 0; i < 6; ++i) {
          parseMipMapFromShape(faces[i], s, s)
        }
      } else if (typeof a0 === 'object') {
        if (a1) {
          parseMipMapFromObject(faces[0], a0)
          parseMipMapFromObject(faces[1], a1)
          parseMipMapFromObject(faces[2], a2)
          parseMipMapFromObject(faces[3], a3)
          parseMipMapFromObject(faces[4], a4)
          parseMipMapFromObject(faces[5], a5)
        } else {
          parseTexInfo(texInfo, a0)
          parseFlags(texture, a0)
          if ('faces' in a0) {
            var faceInput = a0.faces
            check$1(Array.isArray(faceInput) && faceInput.length === 6,
              'cube faces must be a length 6 array')
            for (i = 0; i < 6; ++i) {
              check$1(typeof faceInput[i] === 'object' && !!faceInput[i],
                'invalid input for cube map face')
              copyFlags(faces[i], texture)
              parseMipMapFromObject(faces[i], faceInput[i])
            }
          } else {
            for (i = 0; i < 6; ++i) {
              parseMipMapFromObject(faces[i], a0)
            }
          }
        }
      } else {
        check$1.raise('invalid arguments to cube map')
      }

      copyFlags(texture, faces[0])

      if (!limits.npotTextureCube) {
        check$1(isPow2$1(texture.width) && isPow2$1(texture.height), 'your browser does not support non power or two texture dimensions')
      }

      if (texInfo.genMipmaps) {
        texture.mipmask = (faces[0].width << 1) - 1
      } else {
        texture.mipmask = faces[0].mipmask
      }

      check$1.textureCube(texture, texInfo, faces, limits)
      texture.internalformat = faces[0].internalformat

      reglTextureCube.width = faces[0].width
      reglTextureCube.height = faces[0].height

      tempBind(texture)
      for (i = 0; i < 6; ++i) {
        setMipMap(faces[i], GL_TEXTURE_CUBE_MAP_POSITIVE_X$1 + i)
      }
      setTexInfo(texInfo, GL_TEXTURE_CUBE_MAP$1)
      tempRestore()

      if (config.profile) {
        texture.stats.size = getTextureSize(
          texture.internalformat,
          texture.type,
          reglTextureCube.width,
          reglTextureCube.height,
          texInfo.genMipmaps,
          true)
      }

      reglTextureCube.format = textureFormatsInvert[texture.internalformat]
      reglTextureCube.type = textureTypesInvert[texture.type]

      reglTextureCube.mag = magFiltersInvert[texInfo.magFilter]
      reglTextureCube.min = minFiltersInvert[texInfo.minFilter]

      reglTextureCube.wrapS = wrapModesInvert[texInfo.wrapS]
      reglTextureCube.wrapT = wrapModesInvert[texInfo.wrapT]

      for (i = 0; i < 6; ++i) {
        freeMipMap(faces[i])
      }

      return reglTextureCube
    }

    function subimage (face, image, x_, y_, level_) {
      check$1(!!image, 'must specify image data')
      check$1(typeof face === 'number' && face === (face | 0) &&
        face >= 0 && face < 6, 'invalid face')

      var x = x_ | 0
      var y = y_ | 0
      var level = level_ | 0

      var imageData = allocImage()
      copyFlags(imageData, texture)
      imageData.width = 0
      imageData.height = 0
      parseImage(imageData, image)
      imageData.width = imageData.width || ((texture.width >> level) - x)
      imageData.height = imageData.height || ((texture.height >> level) - y)

      check$1(
        texture.type === imageData.type &&
        texture.format === imageData.format &&
        texture.internalformat === imageData.internalformat,
        'incompatible format for texture.subimage')
      check$1(
        x >= 0 && y >= 0 &&
        x + imageData.width <= texture.width &&
        y + imageData.height <= texture.height,
        'texture.subimage write out of bounds')
      check$1(
        texture.mipmask & (1 << level),
        'missing mipmap data')
      check$1(
        imageData.data || imageData.element || imageData.needsCopy,
        'missing image data')

      tempBind(texture)
      setSubImage(imageData, GL_TEXTURE_CUBE_MAP_POSITIVE_X$1 + face, x, y, level)
      tempRestore()

      freeImage(imageData)

      return reglTextureCube
    }

    function resize (radius_) {
      var radius = radius_ | 0
      if (radius === texture.width) {
        return
      }

      reglTextureCube.width = texture.width = radius
      reglTextureCube.height = texture.height = radius

      tempBind(texture)
      for (var i = 0; i < 6; ++i) {
        for (var j = 0; texture.mipmask >> j; ++j) {
          gl.texImage2D(
            GL_TEXTURE_CUBE_MAP_POSITIVE_X$1 + i,
            j,
            texture.format,
            radius >> j,
            radius >> j,
            0,
            texture.format,
            texture.type,
            null)
        }
      }
      tempRestore()

      if (config.profile) {
        texture.stats.size = getTextureSize(
          texture.internalformat,
          texture.type,
          reglTextureCube.width,
          reglTextureCube.height,
          false,
          true)
      }

      return reglTextureCube
    }

    reglTextureCube(a0, a1, a2, a3, a4, a5)

    reglTextureCube.subimage = subimage
    reglTextureCube.resize = resize
    reglTextureCube._reglType = 'textureCube'
    reglTextureCube._texture = texture
    if (config.profile) {
      reglTextureCube.stats = texture.stats
    }
    reglTextureCube.destroy = function () {
      texture.decRef()
    }

    return reglTextureCube
  }

  // Called when regl is destroyed
  function destroyTextures () {
    for (var i = 0; i < numTexUnits; ++i) {
      gl.activeTexture(GL_TEXTURE0$1 + i)
      gl.bindTexture(GL_TEXTURE_2D$1, null)
      textureUnits[i] = null
    }
    values(textureSet).forEach(destroy)

    stats.cubeCount = 0
    stats.textureCount = 0
  }

  if (config.profile) {
    stats.getTotalTextureSize = function () {
      var total = 0
      Object.keys(textureSet).forEach(function (key) {
        total += textureSet[key].stats.size
      })
      return total
    }
  }

  function restoreTextures () {
    for (var i = 0; i < numTexUnits; ++i) {
      var tex = textureUnits[i]
      if (tex) {
        tex.bindCount = 0
        tex.unit = -1
        textureUnits[i] = null
      }
    }

    values(textureSet).forEach(function (texture) {
      texture.texture = gl.createTexture()
      gl.bindTexture(texture.target, texture.texture)
      for (var i = 0; i < 32; ++i) {
        if ((texture.mipmask & (1 << i)) === 0) {
          continue
        }
        if (texture.target === GL_TEXTURE_2D$1) {
          gl.texImage2D(GL_TEXTURE_2D$1,
            i,
            texture.internalformat,
            texture.width >> i,
            texture.height >> i,
            0,
            texture.internalformat,
            texture.type,
            null)
        } else {
          for (var j = 0; j < 6; ++j) {
            gl.texImage2D(GL_TEXTURE_CUBE_MAP_POSITIVE_X$1 + j,
              i,
              texture.internalformat,
              texture.width >> i,
              texture.height >> i,
              0,
              texture.internalformat,
              texture.type,
              null)
          }
        }
      }
      setTexInfo(texture.texInfo, texture.target)
    })
  }

  function refreshTextures () {
    for (var i = 0; i < numTexUnits; ++i) {
      var tex = textureUnits[i]
      if (tex) {
        tex.bindCount = 0
        tex.unit = -1
        textureUnits[i] = null
      }
      gl.activeTexture(GL_TEXTURE0$1 + i)
      gl.bindTexture(GL_TEXTURE_2D$1, null)
      gl.bindTexture(GL_TEXTURE_CUBE_MAP$1, null)
    }
  }

  return {
    create2D: createTexture2D,
    createCube: createTextureCube,
    clear: destroyTextures,
    getTexture: function (wrapper) {
      return null
    },
    restore: restoreTextures,
    refresh: refreshTextures
  }
}

var GL_RENDERBUFFER = 0x8D41

var GL_RGBA4$1 = 0x8056
var GL_RGB5_A1$1 = 0x8057
var GL_RGB565$1 = 0x8D62
var GL_DEPTH_COMPONENT16 = 0x81A5
var GL_STENCIL_INDEX8 = 0x8D48
var GL_DEPTH_STENCIL$1 = 0x84F9

var GL_SRGB8_ALPHA8_EXT = 0x8C43

var GL_RGBA32F_EXT = 0x8814

var GL_RGBA16F_EXT = 0x881A
var GL_RGB16F_EXT = 0x881B

var FORMAT_SIZES = []

FORMAT_SIZES[GL_RGBA4$1] = 2
FORMAT_SIZES[GL_RGB5_A1$1] = 2
FORMAT_SIZES[GL_RGB565$1] = 2

FORMAT_SIZES[GL_DEPTH_COMPONENT16] = 2
FORMAT_SIZES[GL_STENCIL_INDEX8] = 1
FORMAT_SIZES[GL_DEPTH_STENCIL$1] = 4

FORMAT_SIZES[GL_SRGB8_ALPHA8_EXT] = 4
FORMAT_SIZES[GL_RGBA32F_EXT] = 16
FORMAT_SIZES[GL_RGBA16F_EXT] = 8
FORMAT_SIZES[GL_RGB16F_EXT] = 6

function getRenderbufferSize (format, width, height) {
  return FORMAT_SIZES[format] * width * height
}

var wrapRenderbuffers = function (gl, extensions, limits, stats, config) {
  var formatTypes = {
    'rgba4': GL_RGBA4$1,
    'rgb565': GL_RGB565$1,
    'rgb5 a1': GL_RGB5_A1$1,
    'depth': GL_DEPTH_COMPONENT16,
    'stencil': GL_STENCIL_INDEX8,
    'depth stencil': GL_DEPTH_STENCIL$1
  }

  if (extensions.ext_srgb) {
    formatTypes['srgba'] = GL_SRGB8_ALPHA8_EXT
  }

  if (extensions.ext_color_buffer_half_float) {
    formatTypes['rgba16f'] = GL_RGBA16F_EXT
    formatTypes['rgb16f'] = GL_RGB16F_EXT
  }

  if (extensions.webgl_color_buffer_float) {
    formatTypes['rgba32f'] = GL_RGBA32F_EXT
  }

  var formatTypesInvert = []
  Object.keys(formatTypes).forEach(function (key) {
    var val = formatTypes[key]
    formatTypesInvert[val] = key
  })

  var renderbufferCount = 0
  var renderbufferSet = {}

  function REGLRenderbuffer (renderbuffer) {
    this.id = renderbufferCount++
    this.refCount = 1

    this.renderbuffer = renderbuffer

    this.format = GL_RGBA4$1
    this.width = 0
    this.height = 0

    if (config.profile) {
      this.stats = { size: 0 }
    }
  }

  REGLRenderbuffer.prototype.decRef = function () {
    if (--this.refCount <= 0) {
      destroy(this)
    }
  }

  function destroy (rb) {
    var handle = rb.renderbuffer
    check$1(handle, 'must not double destroy renderbuffer')
    gl.bindRenderbuffer(GL_RENDERBUFFER, null)
    gl.deleteRenderbuffer(handle)
    rb.renderbuffer = null
    rb.refCount = 0
    delete renderbufferSet[rb.id]
    stats.renderbufferCount--
  }

  function createRenderbuffer (a, b) {
    var renderbuffer = new REGLRenderbuffer(gl.createRenderbuffer())
    renderbufferSet[renderbuffer.id] = renderbuffer
    stats.renderbufferCount++

    function reglRenderbuffer (a, b) {
      var w = 0
      var h = 0
      var format = GL_RGBA4$1

      if (typeof a === 'object' && a) {
        var options = a
        if ('shape' in options) {
          var shape = options.shape
          check$1(Array.isArray(shape) && shape.length >= 2,
            'invalid renderbuffer shape')
          w = shape[0] | 0
          h = shape[1] | 0
        } else {
          if ('radius' in options) {
            w = h = options.radius | 0
          }
          if ('width' in options) {
            w = options.width | 0
          }
          if ('height' in options) {
            h = options.height | 0
          }
        }
        if ('format' in options) {
          check$1.parameter(options.format, formatTypes,
            'invalid renderbuffer format')
          format = formatTypes[options.format]
        }
      } else if (typeof a === 'number') {
        w = a | 0
        if (typeof b === 'number') {
          h = b | 0
        } else {
          h = w
        }
      } else if (!a) {
        w = h = 1
      } else {
        check$1.raise('invalid arguments to renderbuffer constructor')
      }

      // check shape
      check$1(
        w > 0 && h > 0 &&
        w <= limits.maxRenderbufferSize && h <= limits.maxRenderbufferSize,
        'invalid renderbuffer size')

      if (w === renderbuffer.width &&
          h === renderbuffer.height &&
          format === renderbuffer.format) {
        return
      }

      reglRenderbuffer.width = renderbuffer.width = w
      reglRenderbuffer.height = renderbuffer.height = h
      renderbuffer.format = format

      gl.bindRenderbuffer(GL_RENDERBUFFER, renderbuffer.renderbuffer)
      gl.renderbufferStorage(GL_RENDERBUFFER, format, w, h)

      check$1(
        gl.getError() === 0,
        'invalid render buffer format')

      if (config.profile) {
        renderbuffer.stats.size = getRenderbufferSize(renderbuffer.format, renderbuffer.width, renderbuffer.height)
      }
      reglRenderbuffer.format = formatTypesInvert[renderbuffer.format]

      return reglRenderbuffer
    }

    function resize (w_, h_) {
      var w = w_ | 0
      var h = (h_ | 0) || w

      if (w === renderbuffer.width && h === renderbuffer.height) {
        return reglRenderbuffer
      }

      // check shape
      check$1(
        w > 0 && h > 0 &&
        w <= limits.maxRenderbufferSize && h <= limits.maxRenderbufferSize,
        'invalid renderbuffer size')

      reglRenderbuffer.width = renderbuffer.width = w
      reglRenderbuffer.height = renderbuffer.height = h

      gl.bindRenderbuffer(GL_RENDERBUFFER, renderbuffer.renderbuffer)
      gl.renderbufferStorage(GL_RENDERBUFFER, renderbuffer.format, w, h)

      check$1(
        gl.getError() === 0,
        'invalid render buffer format')

      // also, recompute size.
      if (config.profile) {
        renderbuffer.stats.size = getRenderbufferSize(
          renderbuffer.format, renderbuffer.width, renderbuffer.height)
      }

      return reglRenderbuffer
    }

    reglRenderbuffer(a, b)

    reglRenderbuffer.resize = resize
    reglRenderbuffer._reglType = 'renderbuffer'
    reglRenderbuffer._renderbuffer = renderbuffer
    if (config.profile) {
      reglRenderbuffer.stats = renderbuffer.stats
    }
    reglRenderbuffer.destroy = function () {
      renderbuffer.decRef()
    }

    return reglRenderbuffer
  }

  if (config.profile) {
    stats.getTotalRenderbufferSize = function () {
      var total = 0
      Object.keys(renderbufferSet).forEach(function (key) {
        total += renderbufferSet[key].stats.size
      })
      return total
    }
  }

  function restoreRenderbuffers () {
    values(renderbufferSet).forEach(function (rb) {
      rb.renderbuffer = gl.createRenderbuffer()
      gl.bindRenderbuffer(GL_RENDERBUFFER, rb.renderbuffer)
      gl.renderbufferStorage(GL_RENDERBUFFER, rb.format, rb.width, rb.height)
    })
    gl.bindRenderbuffer(GL_RENDERBUFFER, null)
  }

  return {
    create: createRenderbuffer,
    clear: function () {
      values(renderbufferSet).forEach(destroy)
    },
    restore: restoreRenderbuffers
  }
}

// We store these constants so that the minifier can inline them
var GL_FRAMEBUFFER$1 = 0x8D40
var GL_RENDERBUFFER$1 = 0x8D41

var GL_TEXTURE_2D$2 = 0x0DE1
var GL_TEXTURE_CUBE_MAP_POSITIVE_X$2 = 0x8515

var GL_COLOR_ATTACHMENT0$1 = 0x8CE0
var GL_DEPTH_ATTACHMENT = 0x8D00
var GL_STENCIL_ATTACHMENT = 0x8D20
var GL_DEPTH_STENCIL_ATTACHMENT = 0x821A

var GL_FRAMEBUFFER_COMPLETE$1 = 0x8CD5
var GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT = 0x8CD6
var GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT = 0x8CD7
var GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS = 0x8CD9
var GL_FRAMEBUFFER_UNSUPPORTED = 0x8CDD

var GL_HALF_FLOAT_OES$2 = 0x8D61
var GL_UNSIGNED_BYTE$6 = 0x1401
var GL_FLOAT$5 = 0x1406

var GL_RGB$1 = 0x1907
var GL_RGBA$2 = 0x1908

var GL_DEPTH_COMPONENT$1 = 0x1902

var colorTextureFormatEnums = [
  GL_RGB$1,
  GL_RGBA$2
]

// for every texture format, store
// the number of channels
var textureFormatChannels = []
textureFormatChannels[GL_RGBA$2] = 4
textureFormatChannels[GL_RGB$1] = 3

// for every texture type, store
// the size in bytes.
var textureTypeSizes = []
textureTypeSizes[GL_UNSIGNED_BYTE$6] = 1
textureTypeSizes[GL_FLOAT$5] = 4
textureTypeSizes[GL_HALF_FLOAT_OES$2] = 2

var GL_RGBA4$2 = 0x8056
var GL_RGB5_A1$2 = 0x8057
var GL_RGB565$2 = 0x8D62
var GL_DEPTH_COMPONENT16$1 = 0x81A5
var GL_STENCIL_INDEX8$1 = 0x8D48
var GL_DEPTH_STENCIL$2 = 0x84F9

var GL_SRGB8_ALPHA8_EXT$1 = 0x8C43

var GL_RGBA32F_EXT$1 = 0x8814

var GL_RGBA16F_EXT$1 = 0x881A
var GL_RGB16F_EXT$1 = 0x881B

var colorRenderbufferFormatEnums = [
  GL_RGBA4$2,
  GL_RGB5_A1$2,
  GL_RGB565$2,
  GL_SRGB8_ALPHA8_EXT$1,
  GL_RGBA16F_EXT$1,
  GL_RGB16F_EXT$1,
  GL_RGBA32F_EXT$1
]

var statusCode = {}
statusCode[GL_FRAMEBUFFER_COMPLETE$1] = 'complete'
statusCode[GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT] = 'incomplete attachment'
statusCode[GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS] = 'incomplete dimensions'
statusCode[GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT] = 'incomplete, missing attachment'
statusCode[GL_FRAMEBUFFER_UNSUPPORTED] = 'unsupported'

function wrapFBOState (
  gl,
  extensions,
  limits,
  textureState,
  renderbufferState,
  stats) {
  var framebufferState = {
    cur: null,
    next: null,
    dirty: false,
    setFBO: null
  }

  var colorTextureFormats = ['rgba']
  var colorRenderbufferFormats = ['rgba4', 'rgb565', 'rgb5 a1']

  if (extensions.ext_srgb) {
    colorRenderbufferFormats.push('srgba')
  }

  if (extensions.ext_color_buffer_half_float) {
    colorRenderbufferFormats.push('rgba16f', 'rgb16f')
  }

  if (extensions.webgl_color_buffer_float) {
    colorRenderbufferFormats.push('rgba32f')
  }

  var colorTypes = ['uint8']
  if (extensions.oes_texture_half_float) {
    colorTypes.push('half float', 'float16')
  }
  if (extensions.oes_texture_float) {
    colorTypes.push('float', 'float32')
  }

  function FramebufferAttachment (target, texture, renderbuffer) {
    this.target = target
    this.texture = texture
    this.renderbuffer = renderbuffer

    var w = 0
    var h = 0
    if (texture) {
      w = texture.width
      h = texture.height
    } else if (renderbuffer) {
      w = renderbuffer.width
      h = renderbuffer.height
    }
    this.width = w
    this.height = h
  }

  function decRef (attachment) {
    if (attachment) {
      if (attachment.texture) {
        attachment.texture._texture.decRef()
      }
      if (attachment.renderbuffer) {
        attachment.renderbuffer._renderbuffer.decRef()
      }
    }
  }

  function incRefAndCheckShape (attachment, width, height) {
    if (!attachment) {
      return
    }
    if (attachment.texture) {
      var texture = attachment.texture._texture
      var tw = Math.max(1, texture.width)
      var th = Math.max(1, texture.height)
      check$1(tw === width && th === height,
        'inconsistent width/height for supplied texture')
      texture.refCount += 1
    } else {
      var renderbuffer = attachment.renderbuffer._renderbuffer
      check$1(
        renderbuffer.width === width && renderbuffer.height === height,
        'inconsistent width/height for renderbuffer')
      renderbuffer.refCount += 1
    }
  }

  function attach (location, attachment) {
    if (attachment) {
      if (attachment.texture) {
        gl.framebufferTexture2D(
          GL_FRAMEBUFFER$1,
          location,
          attachment.target,
          attachment.texture._texture.texture,
          0)
      } else {
        gl.framebufferRenderbuffer(
          GL_FRAMEBUFFER$1,
          location,
          GL_RENDERBUFFER$1,
          attachment.renderbuffer._renderbuffer.renderbuffer)
      }
    }
  }

  function parseAttachment (attachment) {
    var target = GL_TEXTURE_2D$2
    var texture = null
    var renderbuffer = null

    var data = attachment
    if (typeof attachment === 'object') {
      data = attachment.data
      if ('target' in attachment) {
        target = attachment.target | 0
      }
    }

    check$1.type(data, 'function', 'invalid attachment data')

    var type = data._reglType
    if (type === 'texture2d') {
      texture = data
      check$1(target === GL_TEXTURE_2D$2)
    } else if (type === 'textureCube') {
      texture = data
      check$1(
        target >= GL_TEXTURE_CUBE_MAP_POSITIVE_X$2 &&
        target < GL_TEXTURE_CUBE_MAP_POSITIVE_X$2 + 6,
        'invalid cube map target')
    } else if (type === 'renderbuffer') {
      renderbuffer = data
      target = GL_RENDERBUFFER$1
    } else {
      check$1.raise('invalid regl object for attachment')
    }

    return new FramebufferAttachment(target, texture, renderbuffer)
  }

  function allocAttachment (
    width,
    height,
    isTexture,
    format,
    type) {
    if (isTexture) {
      var texture = textureState.create2D({
        width: width,
        height: height,
        format: format,
        type: type
      })
      texture._texture.refCount = 0
      return new FramebufferAttachment(GL_TEXTURE_2D$2, texture, null)
    } else {
      var rb = renderbufferState.create({
        width: width,
        height: height,
        format: format
      })
      rb._renderbuffer.refCount = 0
      return new FramebufferAttachment(GL_RENDERBUFFER$1, null, rb)
    }
  }

  function unwrapAttachment (attachment) {
    return attachment && (attachment.texture || attachment.renderbuffer)
  }

  function resizeAttachment (attachment, w, h) {
    if (attachment) {
      if (attachment.texture) {
        attachment.texture.resize(w, h)
      } else if (attachment.renderbuffer) {
        attachment.renderbuffer.resize(w, h)
      }
      attachment.width = w
      attachment.height = h
    }
  }

  var framebufferCount = 0
  var framebufferSet = {}

  function REGLFramebuffer () {
    this.id = framebufferCount++
    framebufferSet[this.id] = this

    this.framebuffer = gl.createFramebuffer()
    this.width = 0
    this.height = 0

    this.colorAttachments = []
    this.depthAttachment = null
    this.stencilAttachment = null
    this.depthStencilAttachment = null
  }

  function decFBORefs (framebuffer) {
    framebuffer.colorAttachments.forEach(decRef)
    decRef(framebuffer.depthAttachment)
    decRef(framebuffer.stencilAttachment)
    decRef(framebuffer.depthStencilAttachment)
  }

  function destroy (framebuffer) {
    var handle = framebuffer.framebuffer
    check$1(handle, 'must not double destroy framebuffer')
    gl.deleteFramebuffer(handle)
    framebuffer.framebuffer = null
    stats.framebufferCount--
    delete framebufferSet[framebuffer.id]
  }

  function updateFramebuffer (framebuffer) {
    var i

    gl.bindFramebuffer(GL_FRAMEBUFFER$1, framebuffer.framebuffer)
    var colorAttachments = framebuffer.colorAttachments
    for (i = 0; i < colorAttachments.length; ++i) {
      attach(GL_COLOR_ATTACHMENT0$1 + i, colorAttachments[i])
    }
    for (i = colorAttachments.length; i < limits.maxColorAttachments; ++i) {
      gl.framebufferTexture2D(
        GL_FRAMEBUFFER$1,
        GL_COLOR_ATTACHMENT0$1 + i,
        GL_TEXTURE_2D$2,
        null,
        0)
    }

    gl.framebufferTexture2D(
      GL_FRAMEBUFFER$1,
      GL_DEPTH_STENCIL_ATTACHMENT,
      GL_TEXTURE_2D$2,
      null,
      0)
    gl.framebufferTexture2D(
      GL_FRAMEBUFFER$1,
      GL_DEPTH_ATTACHMENT,
      GL_TEXTURE_2D$2,
      null,
      0)
    gl.framebufferTexture2D(
      GL_FRAMEBUFFER$1,
      GL_STENCIL_ATTACHMENT,
      GL_TEXTURE_2D$2,
      null,
      0)

    attach(GL_DEPTH_ATTACHMENT, framebuffer.depthAttachment)
    attach(GL_STENCIL_ATTACHMENT, framebuffer.stencilAttachment)
    attach(GL_DEPTH_STENCIL_ATTACHMENT, framebuffer.depthStencilAttachment)

    // Check status code
    var status = gl.checkFramebufferStatus(GL_FRAMEBUFFER$1)
    if (!gl.isContextLost() && status !== GL_FRAMEBUFFER_COMPLETE$1) {
      check$1.raise('framebuffer configuration not supported, status = ' +
        statusCode[status])
    }

    gl.bindFramebuffer(GL_FRAMEBUFFER$1, framebufferState.next ? framebufferState.next.framebuffer : null)
    framebufferState.cur = framebufferState.next

    // FIXME: Clear error code here.  This is a work around for a bug in
    // headless-gl
    gl.getError()
  }

  function createFBO (a0, a1) {
    var framebuffer = new REGLFramebuffer()
    stats.framebufferCount++

    function reglFramebuffer (a, b) {
      var i

      check$1(framebufferState.next !== framebuffer,
        'can not update framebuffer which is currently in use')

      var width = 0
      var height = 0

      var needsDepth = true
      var needsStencil = true

      var colorBuffer = null
      var colorTexture = true
      var colorFormat = 'rgba'
      var colorType = 'uint8'
      var colorCount = 1

      var depthBuffer = null
      var stencilBuffer = null
      var depthStencilBuffer = null
      var depthStencilTexture = false

      if (typeof a === 'number') {
        width = a | 0
        height = (b | 0) || width
      } else if (!a) {
        width = height = 1
      } else {
        check$1.type(a, 'object', 'invalid arguments for framebuffer')
        var options = a

        if ('shape' in options) {
          var shape = options.shape
          check$1(Array.isArray(shape) && shape.length >= 2,
            'invalid shape for framebuffer')
          width = shape[0]
          height = shape[1]
        } else {
          if ('radius' in options) {
            width = height = options.radius
          }
          if ('width' in options) {
            width = options.width
          }
          if ('height' in options) {
            height = options.height
          }
        }

        if ('color' in options ||
            'colors' in options) {
          colorBuffer =
            options.color ||
            options.colors
          if (Array.isArray(colorBuffer)) {
            check$1(
              colorBuffer.length === 1 || extensions.webgl_draw_buffers,
              'multiple render targets not supported')
          }
        }

        if (!colorBuffer) {
          if ('colorCount' in options) {
            colorCount = options.colorCount | 0
            check$1(colorCount > 0, 'invalid color buffer count')
          }

          if ('colorTexture' in options) {
            colorTexture = !!options.colorTexture
            colorFormat = 'rgba4'
          }

          if ('colorType' in options) {
            colorType = options.colorType
            if (!colorTexture) {
              if (colorType === 'half float' || colorType === 'float16') {
                check$1(extensions.ext_color_buffer_half_float,
                  'you must enable EXT_color_buffer_half_float to use 16-bit render buffers')
                colorFormat = 'rgba16f'
              } else if (colorType === 'float' || colorType === 'float32') {
                check$1(extensions.webgl_color_buffer_float,
                  'you must enable WEBGL_color_buffer_float in order to use 32-bit floating point renderbuffers')
                colorFormat = 'rgba32f'
              }
            } else {
              check$1(extensions.oes_texture_float ||
                !(colorType === 'float' || colorType === 'float32'),
              'you must enable OES_texture_float in order to use floating point framebuffer objects')
              check$1(extensions.oes_texture_half_float ||
                !(colorType === 'half float' || colorType === 'float16'),
              'you must enable OES_texture_half_float in order to use 16-bit floating point framebuffer objects')
            }
            check$1.oneOf(colorType, colorTypes, 'invalid color type')
          }

          if ('colorFormat' in options) {
            colorFormat = options.colorFormat
            if (colorTextureFormats.indexOf(colorFormat) >= 0) {
              colorTexture = true
            } else if (colorRenderbufferFormats.indexOf(colorFormat) >= 0) {
              colorTexture = false
            } else {
              if (colorTexture) {
                check$1.oneOf(
                  options.colorFormat, colorTextureFormats,
                  'invalid color format for texture')
              } else {
                check$1.oneOf(
                  options.colorFormat, colorRenderbufferFormats,
                  'invalid color format for renderbuffer')
              }
            }
          }
        }

        if ('depthTexture' in options || 'depthStencilTexture' in options) {
          depthStencilTexture = !!(options.depthTexture ||
            options.depthStencilTexture)
          check$1(!depthStencilTexture || extensions.webgl_depth_texture,
            'webgl_depth_texture extension not supported')
        }

        if ('depth' in options) {
          if (typeof options.depth === 'boolean') {
            needsDepth = options.depth
          } else {
            depthBuffer = options.depth
            needsStencil = false
          }
        }

        if ('stencil' in options) {
          if (typeof options.stencil === 'boolean') {
            needsStencil = options.stencil
          } else {
            stencilBuffer = options.stencil
            needsDepth = false
          }
        }

        if ('depthStencil' in options) {
          if (typeof options.depthStencil === 'boolean') {
            needsDepth = needsStencil = options.depthStencil
          } else {
            depthStencilBuffer = options.depthStencil
            needsDepth = false
            needsStencil = false
          }
        }
      }

      // parse attachments
      var colorAttachments = null
      var depthAttachment = null
      var stencilAttachment = null
      var depthStencilAttachment = null

      // Set up color attachments
      if (Array.isArray(colorBuffer)) {
        colorAttachments = colorBuffer.map(parseAttachment)
      } else if (colorBuffer) {
        colorAttachments = [parseAttachment(colorBuffer)]
      } else {
        colorAttachments = new Array(colorCount)
        for (i = 0; i < colorCount; ++i) {
          colorAttachments[i] = allocAttachment(
            width,
            height,
            colorTexture,
            colorFormat,
            colorType)
        }
      }

      check$1(extensions.webgl_draw_buffers || colorAttachments.length <= 1,
        'you must enable the WEBGL_draw_buffers extension in order to use multiple color buffers.')
      check$1(colorAttachments.length <= limits.maxColorAttachments,
        'too many color attachments, not supported')

      width = width || colorAttachments[0].width
      height = height || colorAttachments[0].height

      if (depthBuffer) {
        depthAttachment = parseAttachment(depthBuffer)
      } else if (needsDepth && !needsStencil) {
        depthAttachment = allocAttachment(
          width,
          height,
          depthStencilTexture,
          'depth',
          'uint32')
      }

      if (stencilBuffer) {
        stencilAttachment = parseAttachment(stencilBuffer)
      } else if (needsStencil && !needsDepth) {
        stencilAttachment = allocAttachment(
          width,
          height,
          false,
          'stencil',
          'uint8')
      }

      if (depthStencilBuffer) {
        depthStencilAttachment = parseAttachment(depthStencilBuffer)
      } else if (!depthBuffer && !stencilBuffer && needsStencil && needsDepth) {
        depthStencilAttachment = allocAttachment(
          width,
          height,
          depthStencilTexture,
          'depth stencil',
          'depth stencil')
      }

      check$1(
        (!!depthBuffer) + (!!stencilBuffer) + (!!depthStencilBuffer) <= 1,
        'invalid framebuffer configuration, can specify exactly one depth/stencil attachment')

      var commonColorAttachmentSize = null

      for (i = 0; i < colorAttachments.length; ++i) {
        incRefAndCheckShape(colorAttachments[i], width, height)
        check$1(!colorAttachments[i] ||
          (colorAttachments[i].texture &&
            colorTextureFormatEnums.indexOf(colorAttachments[i].texture._texture.format) >= 0) ||
          (colorAttachments[i].renderbuffer &&
            colorRenderbufferFormatEnums.indexOf(colorAttachments[i].renderbuffer._renderbuffer.format) >= 0),
        'framebuffer color attachment ' + i + ' is invalid')

        if (colorAttachments[i] && colorAttachments[i].texture) {
          var colorAttachmentSize =
              textureFormatChannels[colorAttachments[i].texture._texture.format] *
              textureTypeSizes[colorAttachments[i].texture._texture.type]

          if (commonColorAttachmentSize === null) {
            commonColorAttachmentSize = colorAttachmentSize
          } else {
            // We need to make sure that all color attachments have the same number of bitplanes
            // (that is, the same numer of bits per pixel)
            // This is required by the GLES2.0 standard. See the beginning of Chapter 4 in that document.
            check$1(commonColorAttachmentSize === colorAttachmentSize,
              'all color attachments much have the same number of bits per pixel.')
          }
        }
      }
      incRefAndCheckShape(depthAttachment, width, height)
      check$1(!depthAttachment ||
        (depthAttachment.texture &&
          depthAttachment.texture._texture.format === GL_DEPTH_COMPONENT$1) ||
        (depthAttachment.renderbuffer &&
          depthAttachment.renderbuffer._renderbuffer.format === GL_DEPTH_COMPONENT16$1),
      'invalid depth attachment for framebuffer object')
      incRefAndCheckShape(stencilAttachment, width, height)
      check$1(!stencilAttachment ||
        (stencilAttachment.renderbuffer &&
          stencilAttachment.renderbuffer._renderbuffer.format === GL_STENCIL_INDEX8$1),
      'invalid stencil attachment for framebuffer object')
      incRefAndCheckShape(depthStencilAttachment, width, height)
      check$1(!depthStencilAttachment ||
        (depthStencilAttachment.texture &&
          depthStencilAttachment.texture._texture.format === GL_DEPTH_STENCIL$2) ||
        (depthStencilAttachment.renderbuffer &&
          depthStencilAttachment.renderbuffer._renderbuffer.format === GL_DEPTH_STENCIL$2),
      'invalid depth-stencil attachment for framebuffer object')

      // decrement references
      decFBORefs(framebuffer)

      framebuffer.width = width
      framebuffer.height = height

      framebuffer.colorAttachments = colorAttachments
      framebuffer.depthAttachment = depthAttachment
      framebuffer.stencilAttachment = stencilAttachment
      framebuffer.depthStencilAttachment = depthStencilAttachment

      reglFramebuffer.color = colorAttachments.map(unwrapAttachment)
      reglFramebuffer.depth = unwrapAttachment(depthAttachment)
      reglFramebuffer.stencil = unwrapAttachment(stencilAttachment)
      reglFramebuffer.depthStencil = unwrapAttachment(depthStencilAttachment)

      reglFramebuffer.width = framebuffer.width
      reglFramebuffer.height = framebuffer.height

      updateFramebuffer(framebuffer)

      return reglFramebuffer
    }

    function resize (w_, h_) {
      check$1(framebufferState.next !== framebuffer,
        'can not resize a framebuffer which is currently in use')

      var w = Math.max(w_ | 0, 1)
      var h = Math.max((h_ | 0) || w, 1)
      if (w === framebuffer.width && h === framebuffer.height) {
        return reglFramebuffer
      }

      // resize all buffers
      var colorAttachments = framebuffer.colorAttachments
      for (var i = 0; i < colorAttachments.length; ++i) {
        resizeAttachment(colorAttachments[i], w, h)
      }
      resizeAttachment(framebuffer.depthAttachment, w, h)
      resizeAttachment(framebuffer.stencilAttachment, w, h)
      resizeAttachment(framebuffer.depthStencilAttachment, w, h)

      framebuffer.width = reglFramebuffer.width = w
      framebuffer.height = reglFramebuffer.height = h

      updateFramebuffer(framebuffer)

      return reglFramebuffer
    }

    reglFramebuffer(a0, a1)

    return extend(reglFramebuffer, {
      resize: resize,
      _reglType: 'framebuffer',
      _framebuffer: framebuffer,
      destroy: function () {
        destroy(framebuffer)
        decFBORefs(framebuffer)
      },
      use: function (block) {
        framebufferState.setFBO({
          framebuffer: reglFramebuffer
        }, block)
      }
    })
  }

  function createCubeFBO (options) {
    var faces = Array(6)

    function reglFramebufferCube (a) {
      var i

      check$1(faces.indexOf(framebufferState.next) < 0,
        'can not update framebuffer which is currently in use')

      var params = {
        color: null
      }

      var radius = 0

      var colorBuffer = null
      var colorFormat = 'rgba'
      var colorType = 'uint8'
      var colorCount = 1

      if (typeof a === 'number') {
        radius = a | 0
      } else if (!a) {
        radius = 1
      } else {
        check$1.type(a, 'object', 'invalid arguments for framebuffer')
        var options = a

        if ('shape' in options) {
          var shape = options.shape
          check$1(
            Array.isArray(shape) && shape.length >= 2,
            'invalid shape for framebuffer')
          check$1(
            shape[0] === shape[1],
            'cube framebuffer must be square')
          radius = shape[0]
        } else {
          if ('radius' in options) {
            radius = options.radius | 0
          }
          if ('width' in options) {
            radius = options.width | 0
            if ('height' in options) {
              check$1(options.height === radius, 'must be square')
            }
          } else if ('height' in options) {
            radius = options.height | 0
          }
        }

        if ('color' in options ||
            'colors' in options) {
          colorBuffer =
            options.color ||
            options.colors
          if (Array.isArray(colorBuffer)) {
            check$1(
              colorBuffer.length === 1 || extensions.webgl_draw_buffers,
              'multiple render targets not supported')
          }
        }

        if (!colorBuffer) {
          if ('colorCount' in options) {
            colorCount = options.colorCount | 0
            check$1(colorCount > 0, 'invalid color buffer count')
          }

          if ('colorType' in options) {
            check$1.oneOf(
              options.colorType, colorTypes,
              'invalid color type')
            colorType = options.colorType
          }

          if ('colorFormat' in options) {
            colorFormat = options.colorFormat
            check$1.oneOf(
              options.colorFormat, colorTextureFormats,
              'invalid color format for texture')
          }
        }

        if ('depth' in options) {
          params.depth = options.depth
        }

        if ('stencil' in options) {
          params.stencil = options.stencil
        }

        if ('depthStencil' in options) {
          params.depthStencil = options.depthStencil
        }
      }

      var colorCubes
      if (colorBuffer) {
        if (Array.isArray(colorBuffer)) {
          colorCubes = []
          for (i = 0; i < colorBuffer.length; ++i) {
            colorCubes[i] = colorBuffer[i]
          }
        } else {
          colorCubes = [ colorBuffer ]
        }
      } else {
        colorCubes = Array(colorCount)
        var cubeMapParams = {
          radius: radius,
          format: colorFormat,
          type: colorType
        }
        for (i = 0; i < colorCount; ++i) {
          colorCubes[i] = textureState.createCube(cubeMapParams)
        }
      }

      // Check color cubes
      params.color = Array(colorCubes.length)
      for (i = 0; i < colorCubes.length; ++i) {
        var cube = colorCubes[i]
        check$1(
          typeof cube === 'function' && cube._reglType === 'textureCube',
          'invalid cube map')
        radius = radius || cube.width
        check$1(
          cube.width === radius && cube.height === radius,
          'invalid cube map shape')
        params.color[i] = {
          target: GL_TEXTURE_CUBE_MAP_POSITIVE_X$2,
          data: colorCubes[i]
        }
      }

      for (i = 0; i < 6; ++i) {
        for (var j = 0; j < colorCubes.length; ++j) {
          params.color[j].target = GL_TEXTURE_CUBE_MAP_POSITIVE_X$2 + i
        }
        // reuse depth-stencil attachments across all cube maps
        if (i > 0) {
          params.depth = faces[0].depth
          params.stencil = faces[0].stencil
          params.depthStencil = faces[0].depthStencil
        }
        if (faces[i]) {
          (faces[i])(params)
        } else {
          faces[i] = createFBO(params)
        }
      }

      return extend(reglFramebufferCube, {
        width: radius,
        height: radius,
        color: colorCubes
      })
    }

    function resize (radius_) {
      var i
      var radius = radius_ | 0
      check$1(radius > 0 && radius <= limits.maxCubeMapSize,
        'invalid radius for cube fbo')

      if (radius === reglFramebufferCube.width) {
        return reglFramebufferCube
      }

      var colors = reglFramebufferCube.color
      for (i = 0; i < colors.length; ++i) {
        colors[i].resize(radius)
      }

      for (i = 0; i < 6; ++i) {
        faces[i].resize(radius)
      }

      reglFramebufferCube.width = reglFramebufferCube.height = radius

      return reglFramebufferCube
    }

    reglFramebufferCube(options)

    return extend(reglFramebufferCube, {
      faces: faces,
      resize: resize,
      _reglType: 'framebufferCube',
      destroy: function () {
        faces.forEach(function (f) {
          f.destroy()
        })
      }
    })
  }

  function restoreFramebuffers () {
    framebufferState.cur = null
    framebufferState.next = null
    framebufferState.dirty = true
    values(framebufferSet).forEach(function (fb) {
      fb.framebuffer = gl.createFramebuffer()
      updateFramebuffer(fb)
    })
  }

  return extend(framebufferState, {
    getFramebuffer: function (object) {
      if (typeof object === 'function' && object._reglType === 'framebuffer') {
        var fbo = object._framebuffer
        if (fbo instanceof REGLFramebuffer) {
          return fbo
        }
      }
      return null
    },
    create: createFBO,
    createCube: createCubeFBO,
    clear: function () {
      values(framebufferSet).forEach(destroy)
    },
    restore: restoreFramebuffers
  })
}

var GL_FLOAT$6 = 5126
var GL_ARRAY_BUFFER$1 = 34962

function AttributeRecord () {
  this.state = 0

  this.x = 0.0
  this.y = 0.0
  this.z = 0.0
  this.w = 0.0

  this.buffer = null
  this.size = 0
  this.normalized = false
  this.type = GL_FLOAT$6
  this.offset = 0
  this.stride = 0
  this.divisor = 0
}

function wrapAttributeState (
  gl,
  extensions,
  limits,
  stats,
  bufferState) {
  var NUM_ATTRIBUTES = limits.maxAttributes
  var attributeBindings = new Array(NUM_ATTRIBUTES)
  for (var i = 0; i < NUM_ATTRIBUTES; ++i) {
    attributeBindings[i] = new AttributeRecord()
  }
  var vaoCount = 0
  var vaoSet = {}

  var state = {
    Record: AttributeRecord,
    scope: {},
    state: attributeBindings,
    currentVAO: null,
    targetVAO: null,
    restore: extVAO() ? restoreVAO : function () {},
    createVAO: createVAO,
    getVAO: getVAO,
    destroyBuffer: destroyBuffer,
    setVAO: extVAO() ? setVAOEXT : setVAOEmulated,
    clear: extVAO() ? destroyVAOEXT : function () {}
  }

  function destroyBuffer (buffer) {
    for (var i = 0; i < attributeBindings.length; ++i) {
      var record = attributeBindings[i]
      if (record.buffer === buffer) {
        gl.disableVertexAttribArray(i)
        record.buffer = null
      }
    }
  }

  function extVAO () {
    return extensions.oes_vertex_array_object
  }

  function extInstanced () {
    return extensions.angle_instanced_arrays
  }

  function getVAO (vao) {
    if (typeof vao === 'function' && vao._vao) {
      return vao._vao
    }
    return null
  }

  function setVAOEXT (vao) {
    if (vao === state.currentVAO) {
      return
    }
    var ext = extVAO()
    if (vao) {
      ext.bindVertexArrayOES(vao.vao)
    } else {
      ext.bindVertexArrayOES(null)
    }
    state.currentVAO = vao
  }

  function setVAOEmulated (vao) {
    if (vao === state.currentVAO) {
      return
    }
    if (vao) {
      vao.bindAttrs()
    } else {
      var exti = extInstanced()
      for (var i = 0; i < attributeBindings.length; ++i) {
        var binding = attributeBindings[i]
        if (binding.buffer) {
          gl.enableVertexAttribArray(i)
          gl.vertexAttribPointer(i, binding.size, binding.type, binding.normalized, binding.stride, binding.offfset)
          if (exti && binding.divisor) {
            exti.vertexAttribDivisorANGLE(i, binding.divisor)
          }
        } else {
          gl.disableVertexAttribArray(i)
          gl.vertexAttrib4f(i, binding.x, binding.y, binding.z, binding.w)
        }
      }
    }
    state.currentVAO = vao
  }

  function destroyVAOEXT () {
    values(vaoSet).forEach(function (vao) {
      vao.destroy()
    })
  }

  function REGLVAO () {
    this.id = ++vaoCount
    this.attributes = []
    var extension = extVAO()
    if (extension) {
      this.vao = extension.createVertexArrayOES()
    } else {
      this.vao = null
    }
    vaoSet[this.id] = this
    this.buffers = []
  }

  REGLVAO.prototype.bindAttrs = function () {
    var exti = extInstanced()
    var attributes = this.attributes
    for (var i = 0; i < attributes.length; ++i) {
      var attr = attributes[i]
      if (attr.buffer) {
        gl.enableVertexAttribArray(i)
        gl.bindBuffer(GL_ARRAY_BUFFER$1, attr.buffer.buffer)
        gl.vertexAttribPointer(i, attr.size, attr.type, attr.normalized, attr.stride, attr.offset)
        if (exti && attr.divisor) {
          exti.vertexAttribDivisorANGLE(i, attr.divisor)
        }
      } else {
        gl.disableVertexAttribArray(i)
        gl.vertexAttrib4f(i, attr.x, attr.y, attr.z, attr.w)
      }
    }
    for (var j = attributes.length; j < NUM_ATTRIBUTES; ++j) {
      gl.disableVertexAttribArray(j)
    }
  }

  REGLVAO.prototype.refresh = function () {
    var ext = extVAO()
    if (ext) {
      ext.bindVertexArrayOES(this.vao)
      this.bindAttrs()
      state.currentVAO = this
    }
  }

  REGLVAO.prototype.destroy = function () {
    if (this.vao) {
      var extension = extVAO()
      if (this === state.currentVAO) {
        state.currentVAO = null
        extension.bindVertexArrayOES(null)
      }
      extension.deleteVertexArrayOES(this.vao)
      this.vao = null
    }
    if (vaoSet[this.id]) {
      delete vaoSet[this.id]
      stats.vaoCount -= 1
    }
  }

  function restoreVAO () {
    var ext = extVAO()
    if (ext) {
      values(vaoSet).forEach(function (vao) {
        vao.refresh()
      })
    }
  }

  function createVAO (_attr) {
    var vao = new REGLVAO()
    stats.vaoCount += 1

    function updateVAO (attributes) {
      check$1(Array.isArray(attributes), 'arguments to vertex array constructor must be an array')
      check$1(attributes.length < NUM_ATTRIBUTES, 'too many attributes')
      check$1(attributes.length > 0, 'must specify at least one attribute')

      var bufUpdated = {}
      var nattributes = vao.attributes
      nattributes.length = attributes.length
      for (var i = 0; i < attributes.length; ++i) {
        var spec = attributes[i]
        var rec = nattributes[i] = new AttributeRecord()
        var data = spec.data || spec
        if (Array.isArray(data) || isTypedArray(data) || isNDArrayLike(data)) {
          var buf
          if (vao.buffers[i]) {
            buf = vao.buffers[i]
            if (isTypedArray(data) && buf._buffer.byteLength >= data.byteLength) {
              buf.subdata(data)
            } else {
              buf.destroy()
              vao.buffers[i] = null
            }
          }
          if (!vao.buffers[i]) {
            buf = vao.buffers[i] = bufferState.create(spec, GL_ARRAY_BUFFER$1, false, true)
          }
          rec.buffer = bufferState.getBuffer(buf)
          rec.size = rec.buffer.dimension | 0
          rec.normalized = false
          rec.type = rec.buffer.dtype
          rec.offset = 0
          rec.stride = 0
          rec.divisor = 0
          rec.state = 1
          bufUpdated[i] = 1
        } else if (bufferState.getBuffer(spec)) {
          rec.buffer = bufferState.getBuffer(spec)
          rec.size = rec.buffer.dimension | 0
          rec.normalized = false
          rec.type = rec.buffer.dtype
          rec.offset = 0
          rec.stride = 0
          rec.divisor = 0
          rec.state = 1
        } else if (bufferState.getBuffer(spec.buffer)) {
          rec.buffer = bufferState.getBuffer(spec.buffer)
          rec.size = ((+spec.size) || rec.buffer.dimension) | 0
          rec.normalized = !!spec.normalized || false
          if ('type' in spec) {
            check$1.parameter(spec.type, glTypes, 'invalid buffer type')
            rec.type = glTypes[spec.type]
          } else {
            rec.type = rec.buffer.dtype
          }
          rec.offset = (spec.offset || 0) | 0
          rec.stride = (spec.stride || 0) | 0
          rec.divisor = (spec.divisor || 0) | 0
          rec.state = 1

          check$1(rec.size >= 1 && rec.size <= 4, 'size must be between 1 and 4')
          check$1(rec.offset >= 0, 'invalid offset')
          check$1(rec.stride >= 0 && rec.stride <= 255, 'stride must be between 0 and 255')
          check$1(rec.divisor >= 0, 'divisor must be positive')
          check$1(!rec.divisor || !!extensions.angle_instanced_arrays, 'ANGLE_instanced_arrays must be enabled to use divisor')
        } else if ('x' in spec) {
          check$1(i > 0, 'first attribute must not be a constant')
          rec.x = +spec.x || 0
          rec.y = +spec.y || 0
          rec.z = +spec.z || 0
          rec.w = +spec.w || 0
          rec.state = 2
        } else {
          check$1(false, 'invalid attribute spec for location ' + i)
        }
      }

      // retire unused buffers
      for (var j = 0; j < vao.buffers.length; ++j) {
        if (!bufUpdated[j] && vao.buffers[j]) {
          vao.buffers[j].destroy()
          vao.buffers[j] = null
        }
      }

      vao.refresh()
      return updateVAO
    }

    updateVAO.destroy = function () {
      for (var j = 0; j < vao.buffers.length; ++j) {
        if (vao.buffers[j]) {
          vao.buffers[j].destroy()
        }
      }
      vao.buffers.length = 0
      vao.destroy()
    }

    updateVAO._vao = vao
    updateVAO._reglType = 'vao'

    return updateVAO(_attr)
  }

  return state
}

var GL_FRAGMENT_SHADER = 35632
var GL_VERTEX_SHADER = 35633

var GL_ACTIVE_UNIFORMS = 0x8B86
var GL_ACTIVE_ATTRIBUTES = 0x8B89

function wrapShaderState (gl, stringStore, stats, config) {
  // ===================================================
  // glsl compilation and linking
  // ===================================================
  var fragShaders = {}
  var vertShaders = {}

  function ActiveInfo (name, id, location, info) {
    this.name = name
    this.id = id
    this.location = location
    this.info = info
  }

  function insertActiveInfo (list, info) {
    for (var i = 0; i < list.length; ++i) {
      if (list[i].id === info.id) {
        list[i].location = info.location
        return
      }
    }
    list.push(info)
  }

  function getShader (type, id, command) {
    var cache = type === GL_FRAGMENT_SHADER ? fragShaders : vertShaders
    var shader = cache[id]

    if (!shader) {
      var source = stringStore.str(id)
      shader = gl.createShader(type)
      gl.shaderSource(shader, source)
      gl.compileShader(shader)
      check$1.shaderError(gl, shader, source, type, command)
      cache[id] = shader
    }

    return shader
  }

  // ===================================================
  // program linking
  // ===================================================
  var programCache = {}
  var programList = []

  var PROGRAM_COUNTER = 0

  function REGLProgram (fragId, vertId) {
    this.id = PROGRAM_COUNTER++
    this.fragId = fragId
    this.vertId = vertId
    this.program = null
    this.uniforms = []
    this.attributes = []
    this.refCount = 1

    if (config.profile) {
      this.stats = {
        uniformsCount: 0,
        attributesCount: 0
      }
    }
  }

  function linkProgram (desc, command, attributeLocations) {
    var i, info

    // -------------------------------
    // compile & link
    // -------------------------------
    var fragShader = getShader(GL_FRAGMENT_SHADER, desc.fragId)
    var vertShader = getShader(GL_VERTEX_SHADER, desc.vertId)

    var program = desc.program = gl.createProgram()
    gl.attachShader(program, fragShader)
    gl.attachShader(program, vertShader)
    if (attributeLocations) {
      for (i = 0; i < attributeLocations.length; ++i) {
        var binding = attributeLocations[i]
        gl.bindAttribLocation(program, binding[0], binding[1])
      }
    }

    gl.linkProgram(program)
    check$1.linkError(
      gl,
      program,
      stringStore.str(desc.fragId),
      stringStore.str(desc.vertId),
      command)

    // -------------------------------
    // grab uniforms
    // -------------------------------
    var numUniforms = gl.getProgramParameter(program, GL_ACTIVE_UNIFORMS)
    if (config.profile) {
      desc.stats.uniformsCount = numUniforms
    }
    var uniforms = desc.uniforms
    for (i = 0; i < numUniforms; ++i) {
      info = gl.getActiveUniform(program, i)
      if (info) {
        if (info.size > 1) {
          for (var j = 0; j < info.size; ++j) {
            var name = info.name.replace('[0]', '[' + j + ']')
            insertActiveInfo(uniforms, new ActiveInfo(
              name,
              stringStore.id(name),
              gl.getUniformLocation(program, name),
              info))
          }
        } else {
          insertActiveInfo(uniforms, new ActiveInfo(
            info.name,
            stringStore.id(info.name),
            gl.getUniformLocation(program, info.name),
            info))
        }
      }
    }

    // -------------------------------
    // grab attributes
    // -------------------------------
    var numAttributes = gl.getProgramParameter(program, GL_ACTIVE_ATTRIBUTES)
    if (config.profile) {
      desc.stats.attributesCount = numAttributes
    }

    var attributes = desc.attributes
    for (i = 0; i < numAttributes; ++i) {
      info = gl.getActiveAttrib(program, i)
      if (info) {
        insertActiveInfo(attributes, new ActiveInfo(
          info.name,
          stringStore.id(info.name),
          gl.getAttribLocation(program, info.name),
          info))
      }
    }
  }

  if (config.profile) {
    stats.getMaxUniformsCount = function () {
      var m = 0
      programList.forEach(function (desc) {
        if (desc.stats.uniformsCount > m) {
          m = desc.stats.uniformsCount
        }
      })
      return m
    }

    stats.getMaxAttributesCount = function () {
      var m = 0
      programList.forEach(function (desc) {
        if (desc.stats.attributesCount > m) {
          m = desc.stats.attributesCount
        }
      })
      return m
    }
  }

  function restoreShaders () {
    fragShaders = {}
    vertShaders = {}
    for (var i = 0; i < programList.length; ++i) {
      linkProgram(programList[i], null, programList[i].attributes.map(function (info) {
        return [info.location, info.name]
      }))
    }
  }

  return {
    clear: function () {
      var deleteShader = gl.deleteShader.bind(gl)
      values(fragShaders).forEach(deleteShader)
      fragShaders = {}
      values(vertShaders).forEach(deleteShader)
      vertShaders = {}

      programList.forEach(function (desc) {
        gl.deleteProgram(desc.program)
      })
      programList.length = 0
      programCache = {}

      stats.shaderCount = 0
    },

    program: function (vertId, fragId, command, attribLocations) {
      check$1.command(vertId >= 0, 'missing vertex shader', command)
      check$1.command(fragId >= 0, 'missing fragment shader', command)

      var cache = programCache[fragId]
      if (!cache) {
        cache = programCache[fragId] = {}
      }
      var prevProgram = cache[vertId]
      if (prevProgram) {
        prevProgram.refCount++
        if (!attribLocations) {
          return prevProgram
        }
      }
      var program = new REGLProgram(fragId, vertId)
      stats.shaderCount++
      linkProgram(program, command, attribLocations)
      if (!prevProgram) {
        cache[vertId] = program
      }
      programList.push(program)
      return extend(program, {
        destroy: function () {
          program.refCount--
          if (program.refCount <= 0) {
            gl.deleteProgram(program.program)
            var idx = programList.indexOf(program)
            programList.splice(idx, 1)
            stats.shaderCount--
          }
          // no program is linked to this vert anymore
          if (cache[program.vertId].refCount <= 0) {
            gl.deleteShader(vertShaders[program.vertId])
            delete vertShaders[program.vertId]
            delete programCache[program.fragId][program.vertId]
          }
          // no program is linked to this frag anymore
          if (!Object.keys(programCache[program.fragId]).length) {
            gl.deleteShader(fragShaders[program.fragId])
            delete fragShaders[program.fragId]
            delete programCache[program.fragId]
          }
        }
      })
    },

    restore: restoreShaders,

    shader: getShader,

    frag: -1,
    vert: -1
  }
}

var GL_RGBA$3 = 6408
var GL_UNSIGNED_BYTE$7 = 5121
var GL_PACK_ALIGNMENT = 0x0D05
var GL_FLOAT$7 = 0x1406 // 5126

function wrapReadPixels (
  gl,
  framebufferState,
  reglPoll,
  context,
  glAttributes,
  extensions,
  limits) {
  function readPixelsImpl (input) {
    var type
    if (framebufferState.next === null) {
      check$1(
        glAttributes.preserveDrawingBuffer,
        'you must create a webgl context with "preserveDrawingBuffer":true in order to read pixels from the drawing buffer')
      type = GL_UNSIGNED_BYTE$7
    } else {
      check$1(
        framebufferState.next.colorAttachments[0].texture !== null,
        'You cannot read from a renderbuffer')
      type = framebufferState.next.colorAttachments[0].texture._texture.type

      if (extensions.oes_texture_float) {
        check$1(
          type === GL_UNSIGNED_BYTE$7 || type === GL_FLOAT$7,
          'Reading from a framebuffer is only allowed for the types \'uint8\' and \'float\'')

        if (type === GL_FLOAT$7) {
          check$1(limits.readFloat, 'Reading \'float\' values is not permitted in your browser. For a fallback, please see: https://www.npmjs.com/package/glsl-read-float')
        }
      } else {
        check$1(
          type === GL_UNSIGNED_BYTE$7,
          'Reading from a framebuffer is only allowed for the type \'uint8\'')
      }
    }

    var x = 0
    var y = 0
    var width = context.framebufferWidth
    var height = context.framebufferHeight
    var data = null

    if (isTypedArray(input)) {
      data = input
    } else if (input) {
      check$1.type(input, 'object', 'invalid arguments to regl.read()')
      x = input.x | 0
      y = input.y | 0
      check$1(
        x >= 0 && x < context.framebufferWidth,
        'invalid x offset for regl.read')
      check$1(
        y >= 0 && y < context.framebufferHeight,
        'invalid y offset for regl.read')
      width = (input.width || (context.framebufferWidth - x)) | 0
      height = (input.height || (context.framebufferHeight - y)) | 0
      data = input.data || null
    }

    // sanity check input.data
    if (data) {
      if (type === GL_UNSIGNED_BYTE$7) {
        check$1(
          data instanceof Uint8Array,
          'buffer must be \'Uint8Array\' when reading from a framebuffer of type \'uint8\'')
      } else if (type === GL_FLOAT$7) {
        check$1(
          data instanceof Float32Array,
          'buffer must be \'Float32Array\' when reading from a framebuffer of type \'float\'')
      }
    }

    check$1(
      width > 0 && width + x <= context.framebufferWidth,
      'invalid width for read pixels')
    check$1(
      height > 0 && height + y <= context.framebufferHeight,
      'invalid height for read pixels')

    // Update WebGL state
    reglPoll()

    // Compute size
    var size = width * height * 4

    // Allocate data
    if (!data) {
      if (type === GL_UNSIGNED_BYTE$7) {
        data = new Uint8Array(size)
      } else if (type === GL_FLOAT$7) {
        data = data || new Float32Array(size)
      }
    }

    // Type check
    check$1.isTypedArray(data, 'data buffer for regl.read() must be a typedarray')
    check$1(data.byteLength >= size, 'data buffer for regl.read() too small')

    // Run read pixels
    gl.pixelStorei(GL_PACK_ALIGNMENT, 4)
    gl.readPixels(x, y, width, height, GL_RGBA$3,
      type,
      data)

    return data
  }

  function readPixelsFBO (options) {
    var result
    framebufferState.setFBO({
      framebuffer: options.framebuffer
    }, function () {
      result = readPixelsImpl(options)
    })
    return result
  }

  function readPixels (options) {
    if (!options || !('framebuffer' in options)) {
      return readPixelsImpl(options)
    } else {
      return readPixelsFBO(options)
    }
  }

  return readPixels
}

function slice (x) {
  return Array.prototype.slice.call(x)
}

function join (x) {
  return slice(x).join('')
}

function createEnvironment () {
  // Unique variable id counter
  var varCounter = 0

  // Linked values are passed from this scope into the generated code block
  // Calling link() passes a value into the generated scope and returns
  // the variable name which it is bound to
  var linkedNames = []
  var linkedValues = []
  function link (value) {
    for (var i = 0; i < linkedValues.length; ++i) {
      if (linkedValues[i] === value) {
        return linkedNames[i]
      }
    }

    var name = 'g' + (varCounter++)
    linkedNames.push(name)
    linkedValues.push(value)
    return name
  }

  // create a code block
  function block () {
    var code = []
    function push () {
      code.push.apply(code, slice(arguments))
    }

    var vars = []
    function def () {
      var name = 'v' + (varCounter++)
      vars.push(name)

      if (arguments.length > 0) {
        code.push(name, '=')
        code.push.apply(code, slice(arguments))
        code.push(';')
      }

      return name
    }

    return extend(push, {
      def: def,
      toString: function () {
        return join([
          (vars.length > 0 ? 'var ' + vars.join(',') + ';' : ''),
          join(code)
        ])
      }
    })
  }

  function scope () {
    var entry = block()
    var exit = block()

    var entryToString = entry.toString
    var exitToString = exit.toString

    function save (object, prop) {
      exit(object, prop, '=', entry.def(object, prop), ';')
    }

    return extend(function () {
      entry.apply(entry, slice(arguments))
    }, {
      def: entry.def,
      entry: entry,
      exit: exit,
      save: save,
      set: function (object, prop, value) {
        save(object, prop)
        entry(object, prop, '=', value, ';')
      },
      toString: function () {
        return entryToString() + exitToString()
      }
    })
  }

  function conditional () {
    var pred = join(arguments)
    var thenBlock = scope()
    var elseBlock = scope()

    var thenToString = thenBlock.toString
    var elseToString = elseBlock.toString

    return extend(thenBlock, {
      then: function () {
        thenBlock.apply(thenBlock, slice(arguments))
        return this
      },
      else: function () {
        elseBlock.apply(elseBlock, slice(arguments))
        return this
      },
      toString: function () {
        var elseClause = elseToString()
        if (elseClause) {
          elseClause = 'else{' + elseClause + '}'
        }
        return join([
          'if(', pred, '){',
          thenToString(),
          '}', elseClause
        ])
      }
    })
  }

  // procedure list
  var globalBlock = block()
  var procedures = {}
  function proc (name, count) {
    var args = []
    function arg () {
      var name = 'a' + args.length
      args.push(name)
      return name
    }

    count = count || 0
    for (var i = 0; i < count; ++i) {
      arg()
    }

    var body = scope()
    var bodyToString = body.toString

    var result = procedures[name] = extend(body, {
      arg: arg,
      toString: function () {
        return join([
          'function(', args.join(), '){',
          bodyToString(),
          '}'
        ])
      }
    })

    return result
  }

  function compile () {
    var code = ['"use strict";',
      globalBlock,
      'return {']
    Object.keys(procedures).forEach(function (name) {
      code.push('"', name, '":', procedures[name].toString(), ',')
    })
    code.push('}')
    var src = join(code)
      .replace(/;/g, ';\n')
      .replace(/}/g, '}\n')
      .replace(/{/g, '{\n')
    var proc = Function.apply(null, linkedNames.concat(src))
    return proc.apply(null, linkedValues)
  }

  return {
    global: globalBlock,
    link: link,
    block: block,
    proc: proc,
    scope: scope,
    cond: conditional,
    compile: compile
  }
}

// "cute" names for vector components
var CUTE_COMPONENTS = 'xyzw'.split('')

var GL_UNSIGNED_BYTE$8 = 5121

var ATTRIB_STATE_POINTER = 1
var ATTRIB_STATE_CONSTANT = 2

var DYN_FUNC$1 = 0
var DYN_PROP$1 = 1
var DYN_CONTEXT$1 = 2
var DYN_STATE$1 = 3
var DYN_THUNK = 4
var DYN_CONSTANT$1 = 5
var DYN_ARRAY$1 = 6

var S_DITHER = 'dither'
var S_BLEND_ENABLE = 'blend.enable'
var S_BLEND_COLOR = 'blend.color'
var S_BLEND_EQUATION = 'blend.equation'
var S_BLEND_FUNC = 'blend.func'
var S_DEPTH_ENABLE = 'depth.enable'
var S_DEPTH_FUNC = 'depth.func'
var S_DEPTH_RANGE = 'depth.range'
var S_DEPTH_MASK = 'depth.mask'
var S_COLOR_MASK = 'colorMask'
var S_CULL_ENABLE = 'cull.enable'
var S_CULL_FACE = 'cull.face'
var S_FRONT_FACE = 'frontFace'
var S_LINE_WIDTH = 'lineWidth'
var S_POLYGON_OFFSET_ENABLE = 'polygonOffset.enable'
var S_POLYGON_OFFSET_OFFSET = 'polygonOffset.offset'
var S_SAMPLE_ALPHA = 'sample.alpha'
var S_SAMPLE_ENABLE = 'sample.enable'
var S_SAMPLE_COVERAGE = 'sample.coverage'
var S_STENCIL_ENABLE = 'stencil.enable'
var S_STENCIL_MASK = 'stencil.mask'
var S_STENCIL_FUNC = 'stencil.func'
var S_STENCIL_OPFRONT = 'stencil.opFront'
var S_STENCIL_OPBACK = 'stencil.opBack'
var S_SCISSOR_ENABLE = 'scissor.enable'
var S_SCISSOR_BOX = 'scissor.box'
var S_VIEWPORT = 'viewport'

var S_PROFILE = 'profile'

var S_FRAMEBUFFER = 'framebuffer'
var S_VERT = 'vert'
var S_FRAG = 'frag'
var S_ELEMENTS = 'elements'
var S_PRIMITIVE = 'primitive'
var S_COUNT = 'count'
var S_OFFSET = 'offset'
var S_INSTANCES = 'instances'
var S_VAO = 'vao'

var SUFFIX_WIDTH = 'Width'
var SUFFIX_HEIGHT = 'Height'

var S_FRAMEBUFFER_WIDTH = S_FRAMEBUFFER + SUFFIX_WIDTH
var S_FRAMEBUFFER_HEIGHT = S_FRAMEBUFFER + SUFFIX_HEIGHT
var S_VIEWPORT_WIDTH = S_VIEWPORT + SUFFIX_WIDTH
var S_VIEWPORT_HEIGHT = S_VIEWPORT + SUFFIX_HEIGHT
var S_DRAWINGBUFFER = 'drawingBuffer'
var S_DRAWINGBUFFER_WIDTH = S_DRAWINGBUFFER + SUFFIX_WIDTH
var S_DRAWINGBUFFER_HEIGHT = S_DRAWINGBUFFER + SUFFIX_HEIGHT

var NESTED_OPTIONS = [
  S_BLEND_FUNC,
  S_BLEND_EQUATION,
  S_STENCIL_FUNC,
  S_STENCIL_OPFRONT,
  S_STENCIL_OPBACK,
  S_SAMPLE_COVERAGE,
  S_VIEWPORT,
  S_SCISSOR_BOX,
  S_POLYGON_OFFSET_OFFSET
]

var GL_ARRAY_BUFFER$2 = 34962
var GL_ELEMENT_ARRAY_BUFFER$1 = 34963

var GL_FRAGMENT_SHADER$1 = 35632
var GL_VERTEX_SHADER$1 = 35633

var GL_TEXTURE_2D$3 = 0x0DE1
var GL_TEXTURE_CUBE_MAP$2 = 0x8513

var GL_CULL_FACE = 0x0B44
var GL_BLEND = 0x0BE2
var GL_DITHER = 0x0BD0
var GL_STENCIL_TEST = 0x0B90
var GL_DEPTH_TEST = 0x0B71
var GL_SCISSOR_TEST = 0x0C11
var GL_POLYGON_OFFSET_FILL = 0x8037
var GL_SAMPLE_ALPHA_TO_COVERAGE = 0x809E
var GL_SAMPLE_COVERAGE = 0x80A0

var GL_FLOAT$8 = 5126
var GL_FLOAT_VEC2 = 35664
var GL_FLOAT_VEC3 = 35665
var GL_FLOAT_VEC4 = 35666
var GL_INT$3 = 5124
var GL_INT_VEC2 = 35667
var GL_INT_VEC3 = 35668
var GL_INT_VEC4 = 35669
var GL_BOOL = 35670
var GL_BOOL_VEC2 = 35671
var GL_BOOL_VEC3 = 35672
var GL_BOOL_VEC4 = 35673
var GL_FLOAT_MAT2 = 35674
var GL_FLOAT_MAT3 = 35675
var GL_FLOAT_MAT4 = 35676
var GL_SAMPLER_2D = 35678
var GL_SAMPLER_CUBE = 35680

var GL_TRIANGLES$1 = 4

var GL_FRONT = 1028
var GL_BACK = 1029
var GL_CW = 0x0900
var GL_CCW = 0x0901
var GL_MIN_EXT = 0x8007
var GL_MAX_EXT = 0x8008
var GL_ALWAYS = 519
var GL_KEEP = 7680
var GL_ZERO = 0
var GL_ONE = 1
var GL_FUNC_ADD = 0x8006
var GL_LESS = 513

var GL_FRAMEBUFFER$2 = 0x8D40
var GL_COLOR_ATTACHMENT0$2 = 0x8CE0

var blendFuncs = {
  '0': 0,
  '1': 1,
  'zero': 0,
  'one': 1,
  'src color': 768,
  'one minus src color': 769,
  'src alpha': 770,
  'one minus src alpha': 771,
  'dst color': 774,
  'one minus dst color': 775,
  'dst alpha': 772,
  'one minus dst alpha': 773,
  'constant color': 32769,
  'one minus constant color': 32770,
  'constant alpha': 32771,
  'one minus constant alpha': 32772,
  'src alpha saturate': 776
}

// There are invalid values for srcRGB and dstRGB. See:
// https://www.khronos.org/registry/webgl/specs/1.0/#6.13
// https://github.com/KhronosGroup/WebGL/blob/0d3201f5f7ec3c0060bc1f04077461541f1987b9/conformance-suites/1.0.3/conformance/misc/webgl-specific.html#L56
var invalidBlendCombinations = [
  'constant color, constant alpha',
  'one minus constant color, constant alpha',
  'constant color, one minus constant alpha',
  'one minus constant color, one minus constant alpha',
  'constant alpha, constant color',
  'constant alpha, one minus constant color',
  'one minus constant alpha, constant color',
  'one minus constant alpha, one minus constant color'
]

var compareFuncs = {
  'never': 512,
  'less': 513,
  '<': 513,
  'equal': 514,
  '=': 514,
  '==': 514,
  '===': 514,
  'lequal': 515,
  '<=': 515,
  'greater': 516,
  '>': 516,
  'notequal': 517,
  '!=': 517,
  '!==': 517,
  'gequal': 518,
  '>=': 518,
  'always': 519
}

var stencilOps = {
  '0': 0,
  'zero': 0,
  'keep': 7680,
  'replace': 7681,
  'increment': 7682,
  'decrement': 7683,
  'increment wrap': 34055,
  'decrement wrap': 34056,
  'invert': 5386
}

var shaderType = {
  'frag': GL_FRAGMENT_SHADER$1,
  'vert': GL_VERTEX_SHADER$1
}

var orientationType = {
  'cw': GL_CW,
  'ccw': GL_CCW
}

function isBufferArgs (x) {
  return Array.isArray(x) ||
    isTypedArray(x) ||
    isNDArrayLike(x)
}

// Make sure viewport is processed first
function sortState (state) {
  return state.sort(function (a, b) {
    if (a === S_VIEWPORT) {
      return -1
    } else if (b === S_VIEWPORT) {
      return 1
    }
    return (a < b) ? -1 : 1
  })
}

function Declaration (thisDep, contextDep, propDep, append) {
  this.thisDep = thisDep
  this.contextDep = contextDep
  this.propDep = propDep
  this.append = append
}

function isStatic (decl) {
  return decl && !(decl.thisDep || decl.contextDep || decl.propDep)
}

function createStaticDecl (append) {
  return new Declaration(false, false, false, append)
}

function createDynamicDecl (dyn, append) {
  var type = dyn.type
  if (type === DYN_FUNC$1) {
    var numArgs = dyn.data.length
    return new Declaration(
      true,
      numArgs >= 1,
      numArgs >= 2,
      append)
  } else if (type === DYN_THUNK) {
    var data = dyn.data
    return new Declaration(
      data.thisDep,
      data.contextDep,
      data.propDep,
      append)
  } else if (type === DYN_CONSTANT$1) {
    return new Declaration(
      false,
      false,
      false,
      append)
  } else if (type === DYN_ARRAY$1) {
    var thisDep = false
    var contextDep = false
    var propDep = false
    for (var i = 0; i < dyn.data.length; ++i) {
      var subDyn = dyn.data[i]
      if (subDyn.type === DYN_PROP$1) {
        propDep = true
      } else if (subDyn.type === DYN_CONTEXT$1) {
        contextDep = true
      } else if (subDyn.type === DYN_STATE$1) {
        thisDep = true
      } else if (subDyn.type === DYN_FUNC$1) {
        thisDep = true
        var subArgs = subDyn.data
        if (subArgs >= 1) {
          contextDep = true
        }
        if (subArgs >= 2) {
          propDep = true
        }
      } else if (subDyn.type === DYN_THUNK) {
        thisDep = thisDep || subDyn.data.thisDep
        contextDep = contextDep || subDyn.data.contextDep
        propDep = propDep || subDyn.data.propDep
      }
    }
    return new Declaration(
      thisDep,
      contextDep,
      propDep,
      append)
  } else {
    return new Declaration(
      type === DYN_STATE$1,
      type === DYN_CONTEXT$1,
      type === DYN_PROP$1,
      append)
  }
}

var SCOPE_DECL = new Declaration(false, false, false, function () {})

function reglCore (
  gl,
  stringStore,
  extensions,
  limits,
  bufferState,
  elementState,
  textureState,
  framebufferState,
  uniformState,
  attributeState,
  shaderState,
  drawState,
  contextState,
  timer,
  config) {
  var AttributeRecord = attributeState.Record

  var blendEquations = {
    'add': 32774,
    'subtract': 32778,
    'reverse subtract': 32779
  }
  if (extensions.ext_blend_minmax) {
    blendEquations.min = GL_MIN_EXT
    blendEquations.max = GL_MAX_EXT
  }

  var extInstancing = extensions.angle_instanced_arrays
  var extDrawBuffers = extensions.webgl_draw_buffers

  // ===================================================
  // ===================================================
  // WEBGL STATE
  // ===================================================
  // ===================================================
  var currentState = {
    dirty: true,
    profile: config.profile
  }
  var nextState = {}
  var GL_STATE_NAMES = []
  var GL_FLAGS = {}
  var GL_VARIABLES = {}

  function propName (name) {
    return name.replace('.', '_')
  }

  function stateFlag (sname, cap, init) {
    var name = propName(sname)
    GL_STATE_NAMES.push(sname)
    nextState[name] = currentState[name] = !!init
    GL_FLAGS[name] = cap
  }

  function stateVariable (sname, func, init) {
    var name = propName(sname)
    GL_STATE_NAMES.push(sname)
    if (Array.isArray(init)) {
      currentState[name] = init.slice()
      nextState[name] = init.slice()
    } else {
      currentState[name] = nextState[name] = init
    }
    GL_VARIABLES[name] = func
  }

  // Dithering
  stateFlag(S_DITHER, GL_DITHER)

  // Blending
  stateFlag(S_BLEND_ENABLE, GL_BLEND)
  stateVariable(S_BLEND_COLOR, 'blendColor', [0, 0, 0, 0])
  stateVariable(S_BLEND_EQUATION, 'blendEquationSeparate',
    [GL_FUNC_ADD, GL_FUNC_ADD])
  stateVariable(S_BLEND_FUNC, 'blendFuncSeparate',
    [GL_ONE, GL_ZERO, GL_ONE, GL_ZERO])

  // Depth
  stateFlag(S_DEPTH_ENABLE, GL_DEPTH_TEST, true)
  stateVariable(S_DEPTH_FUNC, 'depthFunc', GL_LESS)
  stateVariable(S_DEPTH_RANGE, 'depthRange', [0, 1])
  stateVariable(S_DEPTH_MASK, 'depthMask', true)

  // Color mask
  stateVariable(S_COLOR_MASK, S_COLOR_MASK, [true, true, true, true])

  // Face culling
  stateFlag(S_CULL_ENABLE, GL_CULL_FACE)
  stateVariable(S_CULL_FACE, 'cullFace', GL_BACK)

  // Front face orientation
  stateVariable(S_FRONT_FACE, S_FRONT_FACE, GL_CCW)

  // Line width
  stateVariable(S_LINE_WIDTH, S_LINE_WIDTH, 1)

  // Polygon offset
  stateFlag(S_POLYGON_OFFSET_ENABLE, GL_POLYGON_OFFSET_FILL)
  stateVariable(S_POLYGON_OFFSET_OFFSET, 'polygonOffset', [0, 0])

  // Sample coverage
  stateFlag(S_SAMPLE_ALPHA, GL_SAMPLE_ALPHA_TO_COVERAGE)
  stateFlag(S_SAMPLE_ENABLE, GL_SAMPLE_COVERAGE)
  stateVariable(S_SAMPLE_COVERAGE, 'sampleCoverage', [1, false])

  // Stencil
  stateFlag(S_STENCIL_ENABLE, GL_STENCIL_TEST)
  stateVariable(S_STENCIL_MASK, 'stencilMask', -1)
  stateVariable(S_STENCIL_FUNC, 'stencilFunc', [GL_ALWAYS, 0, -1])
  stateVariable(S_STENCIL_OPFRONT, 'stencilOpSeparate',
    [GL_FRONT, GL_KEEP, GL_KEEP, GL_KEEP])
  stateVariable(S_STENCIL_OPBACK, 'stencilOpSeparate',
    [GL_BACK, GL_KEEP, GL_KEEP, GL_KEEP])

  // Scissor
  stateFlag(S_SCISSOR_ENABLE, GL_SCISSOR_TEST)
  stateVariable(S_SCISSOR_BOX, 'scissor',
    [0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight])

  // Viewport
  stateVariable(S_VIEWPORT, S_VIEWPORT,
    [0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight])

  // ===================================================
  // ===================================================
  // ENVIRONMENT
  // ===================================================
  // ===================================================
  var sharedState = {
    gl: gl,
    context: contextState,
    strings: stringStore,
    next: nextState,
    current: currentState,
    draw: drawState,
    elements: elementState,
    buffer: bufferState,
    shader: shaderState,
    attributes: attributeState.state,
    vao: attributeState,
    uniforms: uniformState,
    framebuffer: framebufferState,
    extensions: extensions,

    timer: timer,
    isBufferArgs: isBufferArgs
  }

  var sharedConstants = {
    primTypes: primTypes,
    compareFuncs: compareFuncs,
    blendFuncs: blendFuncs,
    blendEquations: blendEquations,
    stencilOps: stencilOps,
    glTypes: glTypes,
    orientationType: orientationType
  }

  check$1.optional(function () {
    sharedState.isArrayLike = isArrayLike
  })

  if (extDrawBuffers) {
    sharedConstants.backBuffer = [GL_BACK]
    sharedConstants.drawBuffer = loop(limits.maxDrawbuffers, function (i) {
      if (i === 0) {
        return [0]
      }
      return loop(i, function (j) {
        return GL_COLOR_ATTACHMENT0$2 + j
      })
    })
  }

  var drawCallCounter = 0
  function createREGLEnvironment () {
    var env = createEnvironment()
    var link = env.link
    var global = env.global
    env.id = drawCallCounter++

    env.batchId = '0'

    // link shared state
    var SHARED = link(sharedState)
    var shared = env.shared = {
      props: 'a0'
    }
    Object.keys(sharedState).forEach(function (prop) {
      shared[prop] = global.def(SHARED, '.', prop)
    })

    // Inject runtime assertion stuff for debug builds
    check$1.optional(function () {
      env.CHECK = link(check$1)
      env.commandStr = check$1.guessCommand()
      env.command = link(env.commandStr)
      env.assert = function (block, pred, message) {
        block(
          'if(!(', pred, '))',
          this.CHECK, '.commandRaise(', link(message), ',', this.command, ');')
      }

      sharedConstants.invalidBlendCombinations = invalidBlendCombinations
    })

    // Copy GL state variables over
    var nextVars = env.next = {}
    var currentVars = env.current = {}
    Object.keys(GL_VARIABLES).forEach(function (variable) {
      if (Array.isArray(currentState[variable])) {
        nextVars[variable] = global.def(shared.next, '.', variable)
        currentVars[variable] = global.def(shared.current, '.', variable)
      }
    })

    // Initialize shared constants
    var constants = env.constants = {}
    Object.keys(sharedConstants).forEach(function (name) {
      constants[name] = global.def(JSON.stringify(sharedConstants[name]))
    })

    // Helper function for calling a block
    env.invoke = function (block, x) {
      switch (x.type) {
        case DYN_FUNC$1:
          var argList = [
            'this',
            shared.context,
            shared.props,
            env.batchId
          ]
          return block.def(
            link(x.data), '.call(',
            argList.slice(0, Math.max(x.data.length + 1, 4)),
            ')')
        case DYN_PROP$1:
          return block.def(shared.props, x.data)
        case DYN_CONTEXT$1:
          return block.def(shared.context, x.data)
        case DYN_STATE$1:
          return block.def('this', x.data)
        case DYN_THUNK:
          x.data.append(env, block)
          return x.data.ref
        case DYN_CONSTANT$1:
          return x.data.toString()
        case DYN_ARRAY$1:
          return x.data.map(function (y) {
            return env.invoke(block, y)
          })
      }
    }

    env.attribCache = {}

    var scopeAttribs = {}
    env.scopeAttrib = function (name) {
      var id = stringStore.id(name)
      if (id in scopeAttribs) {
        return scopeAttribs[id]
      }
      var binding = attributeState.scope[id]
      if (!binding) {
        binding = attributeState.scope[id] = new AttributeRecord()
      }
      var result = scopeAttribs[id] = link(binding)
      return result
    }

    return env
  }

  // ===================================================
  // ===================================================
  // PARSING
  // ===================================================
  // ===================================================
  function parseProfile (options) {
    var staticOptions = options.static
    var dynamicOptions = options.dynamic

    var profileEnable
    if (S_PROFILE in staticOptions) {
      var value = !!staticOptions[S_PROFILE]
      profileEnable = createStaticDecl(function (env, scope) {
        return value
      })
      profileEnable.enable = value
    } else if (S_PROFILE in dynamicOptions) {
      var dyn = dynamicOptions[S_PROFILE]
      profileEnable = createDynamicDecl(dyn, function (env, scope) {
        return env.invoke(scope, dyn)
      })
    }

    return profileEnable
  }

  function parseFramebuffer (options, env) {
    var staticOptions = options.static
    var dynamicOptions = options.dynamic

    if (S_FRAMEBUFFER in staticOptions) {
      var framebuffer = staticOptions[S_FRAMEBUFFER]
      if (framebuffer) {
        framebuffer = framebufferState.getFramebuffer(framebuffer)
        check$1.command(framebuffer, 'invalid framebuffer object')
        return createStaticDecl(function (env, block) {
          var FRAMEBUFFER = env.link(framebuffer)
          var shared = env.shared
          block.set(
            shared.framebuffer,
            '.next',
            FRAMEBUFFER)
          var CONTEXT = shared.context
          block.set(
            CONTEXT,
            '.' + S_FRAMEBUFFER_WIDTH,
            FRAMEBUFFER + '.width')
          block.set(
            CONTEXT,
            '.' + S_FRAMEBUFFER_HEIGHT,
            FRAMEBUFFER + '.height')
          return FRAMEBUFFER
        })
      } else {
        return createStaticDecl(function (env, scope) {
          var shared = env.shared
          scope.set(
            shared.framebuffer,
            '.next',
            'null')
          var CONTEXT = shared.context
          scope.set(
            CONTEXT,
            '.' + S_FRAMEBUFFER_WIDTH,
            CONTEXT + '.' + S_DRAWINGBUFFER_WIDTH)
          scope.set(
            CONTEXT,
            '.' + S_FRAMEBUFFER_HEIGHT,
            CONTEXT + '.' + S_DRAWINGBUFFER_HEIGHT)
          return 'null'
        })
      }
    } else if (S_FRAMEBUFFER in dynamicOptions) {
      var dyn = dynamicOptions[S_FRAMEBUFFER]
      return createDynamicDecl(dyn, function (env, scope) {
        var FRAMEBUFFER_FUNC = env.invoke(scope, dyn)
        var shared = env.shared
        var FRAMEBUFFER_STATE = shared.framebuffer
        var FRAMEBUFFER = scope.def(
          FRAMEBUFFER_STATE, '.getFramebuffer(', FRAMEBUFFER_FUNC, ')')

        check$1.optional(function () {
          env.assert(scope,
            '!' + FRAMEBUFFER_FUNC + '||' + FRAMEBUFFER,
            'invalid framebuffer object')
        })

        scope.set(
          FRAMEBUFFER_STATE,
          '.next',
          FRAMEBUFFER)
        var CONTEXT = shared.context
        scope.set(
          CONTEXT,
          '.' + S_FRAMEBUFFER_WIDTH,
          FRAMEBUFFER + '?' + FRAMEBUFFER + '.width:' +
          CONTEXT + '.' + S_DRAWINGBUFFER_WIDTH)
        scope.set(
          CONTEXT,
          '.' + S_FRAMEBUFFER_HEIGHT,
          FRAMEBUFFER +
          '?' + FRAMEBUFFER + '.height:' +
          CONTEXT + '.' + S_DRAWINGBUFFER_HEIGHT)
        return FRAMEBUFFER
      })
    } else {
      return null
    }
  }

  function parseViewportScissor (options, framebuffer, env) {
    var staticOptions = options.static
    var dynamicOptions = options.dynamic

    function parseBox (param) {
      if (param in staticOptions) {
        var box = staticOptions[param]
        check$1.commandType(box, 'object', 'invalid ' + param, env.commandStr)

        var isStatic = true
        var x = box.x | 0
        var y = box.y | 0
        var w, h
        if ('width' in box) {
          w = box.width | 0
          check$1.command(w >= 0, 'invalid ' + param, env.commandStr)
        } else {
          isStatic = false
        }
        if ('height' in box) {
          h = box.height | 0
          check$1.command(h >= 0, 'invalid ' + param, env.commandStr)
        } else {
          isStatic = false
        }

        return new Declaration(
          !isStatic && framebuffer && framebuffer.thisDep,
          !isStatic && framebuffer && framebuffer.contextDep,
          !isStatic && framebuffer && framebuffer.propDep,
          function (env, scope) {
            var CONTEXT = env.shared.context
            var BOX_W = w
            if (!('width' in box)) {
              BOX_W = scope.def(CONTEXT, '.', S_FRAMEBUFFER_WIDTH, '-', x)
            }
            var BOX_H = h
            if (!('height' in box)) {
              BOX_H = scope.def(CONTEXT, '.', S_FRAMEBUFFER_HEIGHT, '-', y)
            }
            return [x, y, BOX_W, BOX_H]
          })
      } else if (param in dynamicOptions) {
        var dynBox = dynamicOptions[param]
        var result = createDynamicDecl(dynBox, function (env, scope) {
          var BOX = env.invoke(scope, dynBox)

          check$1.optional(function () {
            env.assert(scope,
              BOX + '&&typeof ' + BOX + '==="object"',
              'invalid ' + param)
          })

          var CONTEXT = env.shared.context
          var BOX_X = scope.def(BOX, '.x|0')
          var BOX_Y = scope.def(BOX, '.y|0')
          var BOX_W = scope.def(
            '"width" in ', BOX, '?', BOX, '.width|0:',
            '(', CONTEXT, '.', S_FRAMEBUFFER_WIDTH, '-', BOX_X, ')')
          var BOX_H = scope.def(
            '"height" in ', BOX, '?', BOX, '.height|0:',
            '(', CONTEXT, '.', S_FRAMEBUFFER_HEIGHT, '-', BOX_Y, ')')

          check$1.optional(function () {
            env.assert(scope,
              BOX_W + '>=0&&' +
              BOX_H + '>=0',
              'invalid ' + param)
          })

          return [BOX_X, BOX_Y, BOX_W, BOX_H]
        })
        if (framebuffer) {
          result.thisDep = result.thisDep || framebuffer.thisDep
          result.contextDep = result.contextDep || framebuffer.contextDep
          result.propDep = result.propDep || framebuffer.propDep
        }
        return result
      } else if (framebuffer) {
        return new Declaration(
          framebuffer.thisDep,
          framebuffer.contextDep,
          framebuffer.propDep,
          function (env, scope) {
            var CONTEXT = env.shared.context
            return [
              0, 0,
              scope.def(CONTEXT, '.', S_FRAMEBUFFER_WIDTH),
              scope.def(CONTEXT, '.', S_FRAMEBUFFER_HEIGHT)]
          })
      } else {
        return null
      }
    }

    var viewport = parseBox(S_VIEWPORT)

    if (viewport) {
      var prevViewport = viewport
      viewport = new Declaration(
        viewport.thisDep,
        viewport.contextDep,
        viewport.propDep,
        function (env, scope) {
          var VIEWPORT = prevViewport.append(env, scope)
          var CONTEXT = env.shared.context
          scope.set(
            CONTEXT,
            '.' + S_VIEWPORT_WIDTH,
            VIEWPORT[2])
          scope.set(
            CONTEXT,
            '.' + S_VIEWPORT_HEIGHT,
            VIEWPORT[3])
          return VIEWPORT
        })
    }

    return {
      viewport: viewport,
      scissor_box: parseBox(S_SCISSOR_BOX)
    }
  }

  function parseAttribLocations (options, attributes) {
    var staticOptions = options.static
    var staticProgram =
      typeof staticOptions[S_FRAG] === 'string' &&
      typeof staticOptions[S_VERT] === 'string'
    if (staticProgram) {
      if (Object.keys(attributes.dynamic).length > 0) {
        return null
      }
      var staticAttributes = attributes.static
      var sAttributes = Object.keys(staticAttributes)
      if (sAttributes.length > 0 && typeof staticAttributes[sAttributes[0]] === 'number') {
        var bindings = []
        for (var i = 0; i < sAttributes.length; ++i) {
          check$1(typeof staticAttributes[sAttributes[i]] === 'number', 'must specify all vertex attribute locations when using vaos')
          bindings.push([staticAttributes[sAttributes[i]] | 0, sAttributes[i]])
        }
        return bindings
      }
    }
    return null
  }

  function parseProgram (options, env, attribLocations) {
    var staticOptions = options.static
    var dynamicOptions = options.dynamic

    function parseShader (name) {
      if (name in staticOptions) {
        var id = stringStore.id(staticOptions[name])
        check$1.optional(function () {
          shaderState.shader(shaderType[name], id, check$1.guessCommand())
        })
        var result = createStaticDecl(function () {
          return id
        })
        result.id = id
        return result
      } else if (name in dynamicOptions) {
        var dyn = dynamicOptions[name]
        return createDynamicDecl(dyn, function (env, scope) {
          var str = env.invoke(scope, dyn)
          var id = scope.def(env.shared.strings, '.id(', str, ')')
          check$1.optional(function () {
            scope(
              env.shared.shader, '.shader(',
              shaderType[name], ',',
              id, ',',
              env.command, ');')
          })
          return id
        })
      }
      return null
    }

    var frag = parseShader(S_FRAG)
    var vert = parseShader(S_VERT)

    var program = null
    var progVar
    if (isStatic(frag) && isStatic(vert)) {
      program = shaderState.program(vert.id, frag.id, null, attribLocations)
      progVar = createStaticDecl(function (env, scope) {
        return env.link(program)
      })
    } else {
      progVar = new Declaration(
        (frag && frag.thisDep) || (vert && vert.thisDep),
        (frag && frag.contextDep) || (vert && vert.contextDep),
        (frag && frag.propDep) || (vert && vert.propDep),
        function (env, scope) {
          var SHADER_STATE = env.shared.shader
          var fragId
          if (frag) {
            fragId = frag.append(env, scope)
          } else {
            fragId = scope.def(SHADER_STATE, '.', S_FRAG)
          }
          var vertId
          if (vert) {
            vertId = vert.append(env, scope)
          } else {
            vertId = scope.def(SHADER_STATE, '.', S_VERT)
          }
          var progDef = SHADER_STATE + '.program(' + vertId + ',' + fragId
          check$1.optional(function () {
            progDef += ',' + env.command
          })
          return scope.def(progDef + ')')
        })
    }

    return {
      frag: frag,
      vert: vert,
      progVar: progVar,
      program: program
    }
  }

  function parseDraw (options, env) {
    var staticOptions = options.static
    var dynamicOptions = options.dynamic

    function parseElements () {
      if (S_ELEMENTS in staticOptions) {
        var elements = staticOptions[S_ELEMENTS]
        if (isBufferArgs(elements)) {
          elements = elementState.getElements(elementState.create(elements, true))
        } else if (elements) {
          elements = elementState.getElements(elements)
          check$1.command(elements, 'invalid elements', env.commandStr)
        }
        var result = createStaticDecl(function (env, scope) {
          if (elements) {
            var result = env.link(elements)
            env.ELEMENTS = result
            return result
          }
          env.ELEMENTS = null
          return null
        })
        result.value = elements
        return result
      } else if (S_ELEMENTS in dynamicOptions) {
        var dyn = dynamicOptions[S_ELEMENTS]
        return createDynamicDecl(dyn, function (env, scope) {
          var shared = env.shared

          var IS_BUFFER_ARGS = shared.isBufferArgs
          var ELEMENT_STATE = shared.elements

          var elementDefn = env.invoke(scope, dyn)
          var elements = scope.def('null')
          var elementStream = scope.def(IS_BUFFER_ARGS, '(', elementDefn, ')')

          var ifte = env.cond(elementStream)
            .then(elements, '=', ELEMENT_STATE, '.createStream(', elementDefn, ');')
            .else(elements, '=', ELEMENT_STATE, '.getElements(', elementDefn, ');')

          check$1.optional(function () {
            env.assert(ifte.else,
              '!' + elementDefn + '||' + elements,
              'invalid elements')
          })

          scope.entry(ifte)
          scope.exit(
            env.cond(elementStream)
              .then(ELEMENT_STATE, '.destroyStream(', elements, ');'))

          env.ELEMENTS = elements

          return elements
        })
      }

      return null
    }

    var elements = parseElements()

    function parsePrimitive () {
      if (S_PRIMITIVE in staticOptions) {
        var primitive = staticOptions[S_PRIMITIVE]
        check$1.commandParameter(primitive, primTypes, 'invalid primitve', env.commandStr)
        return createStaticDecl(function (env, scope) {
          return primTypes[primitive]
        })
      } else if (S_PRIMITIVE in dynamicOptions) {
        var dynPrimitive = dynamicOptions[S_PRIMITIVE]
        return createDynamicDecl(dynPrimitive, function (env, scope) {
          var PRIM_TYPES = env.constants.primTypes
          var prim = env.invoke(scope, dynPrimitive)
          check$1.optional(function () {
            env.assert(scope,
              prim + ' in ' + PRIM_TYPES,
              'invalid primitive, must be one of ' + Object.keys(primTypes))
          })
          return scope.def(PRIM_TYPES, '[', prim, ']')
        })
      } else if (elements) {
        if (isStatic(elements)) {
          if (elements.value) {
            return createStaticDecl(function (env, scope) {
              return scope.def(env.ELEMENTS, '.primType')
            })
          } else {
            return createStaticDecl(function () {
              return GL_TRIANGLES$1
            })
          }
        } else {
          return new Declaration(
            elements.thisDep,
            elements.contextDep,
            elements.propDep,
            function (env, scope) {
              var elements = env.ELEMENTS
              return scope.def(elements, '?', elements, '.primType:', GL_TRIANGLES$1)
            })
        }
      }
      return null
    }

    function parseParam (param, isOffset) {
      if (param in staticOptions) {
        var value = staticOptions[param] | 0
        check$1.command(!isOffset || value >= 0, 'invalid ' + param, env.commandStr)
        return createStaticDecl(function (env, scope) {
          if (isOffset) {
            env.OFFSET = value
          }
          return value
        })
      } else if (param in dynamicOptions) {
        var dynValue = dynamicOptions[param]
        return createDynamicDecl(dynValue, function (env, scope) {
          var result = env.invoke(scope, dynValue)
          if (isOffset) {
            env.OFFSET = result
            check$1.optional(function () {
              env.assert(scope,
                result + '>=0',
                'invalid ' + param)
            })
          }
          return result
        })
      } else if (isOffset && elements) {
        return createStaticDecl(function (env, scope) {
          env.OFFSET = '0'
          return 0
        })
      }
      return null
    }

    var OFFSET = parseParam(S_OFFSET, true)

    function parseVertCount () {
      if (S_COUNT in staticOptions) {
        var count = staticOptions[S_COUNT] | 0
        check$1.command(
          typeof count === 'number' && count >= 0, 'invalid vertex count', env.commandStr)
        return createStaticDecl(function () {
          return count
        })
      } else if (S_COUNT in dynamicOptions) {
        var dynCount = dynamicOptions[S_COUNT]
        return createDynamicDecl(dynCount, function (env, scope) {
          var result = env.invoke(scope, dynCount)
          check$1.optional(function () {
            env.assert(scope,
              'typeof ' + result + '==="number"&&' +
              result + '>=0&&' +
              result + '===(' + result + '|0)',
              'invalid vertex count')
          })
          return result
        })
      } else if (elements) {
        if (isStatic(elements)) {
          if (elements) {
            if (OFFSET) {
              return new Declaration(
                OFFSET.thisDep,
                OFFSET.contextDep,
                OFFSET.propDep,
                function (env, scope) {
                  var result = scope.def(
                    env.ELEMENTS, '.vertCount-', env.OFFSET)

                  check$1.optional(function () {
                    env.assert(scope,
                      result + '>=0',
                      'invalid vertex offset/element buffer too small')
                  })

                  return result
                })
            } else {
              return createStaticDecl(function (env, scope) {
                return scope.def(env.ELEMENTS, '.vertCount')
              })
            }
          } else {
            var result = createStaticDecl(function () {
              return -1
            })
            check$1.optional(function () {
              result.MISSING = true
            })
            return result
          }
        } else {
          var variable = new Declaration(
            elements.thisDep || OFFSET.thisDep,
            elements.contextDep || OFFSET.contextDep,
            elements.propDep || OFFSET.propDep,
            function (env, scope) {
              var elements = env.ELEMENTS
              if (env.OFFSET) {
                return scope.def(elements, '?', elements, '.vertCount-',
                  env.OFFSET, ':-1')
              }
              return scope.def(elements, '?', elements, '.vertCount:-1')
            })
          check$1.optional(function () {
            variable.DYNAMIC = true
          })
          return variable
        }
      }
      return null
    }

    return {
      elements: elements,
      primitive: parsePrimitive(),
      count: parseVertCount(),
      instances: parseParam(S_INSTANCES, false),
      offset: OFFSET
    }
  }

  function parseGLState (options, env) {
    var staticOptions = options.static
    var dynamicOptions = options.dynamic

    var STATE = {}

    GL_STATE_NAMES.forEach(function (prop) {
      var param = propName(prop)

      function parseParam (parseStatic, parseDynamic) {
        if (prop in staticOptions) {
          var value = parseStatic(staticOptions[prop])
          STATE[param] = createStaticDecl(function () {
            return value
          })
        } else if (prop in dynamicOptions) {
          var dyn = dynamicOptions[prop]
          STATE[param] = createDynamicDecl(dyn, function (env, scope) {
            return parseDynamic(env, scope, env.invoke(scope, dyn))
          })
        }
      }

      switch (prop) {
        case S_CULL_ENABLE:
        case S_BLEND_ENABLE:
        case S_DITHER:
        case S_STENCIL_ENABLE:
        case S_DEPTH_ENABLE:
        case S_SCISSOR_ENABLE:
        case S_POLYGON_OFFSET_ENABLE:
        case S_SAMPLE_ALPHA:
        case S_SAMPLE_ENABLE:
        case S_DEPTH_MASK:
          return parseParam(
            function (value) {
              check$1.commandType(value, 'boolean', prop, env.commandStr)
              return value
            },
            function (env, scope, value) {
              check$1.optional(function () {
                env.assert(scope,
                  'typeof ' + value + '==="boolean"',
                  'invalid flag ' + prop, env.commandStr)
              })
              return value
            })

        case S_DEPTH_FUNC:
          return parseParam(
            function (value) {
              check$1.commandParameter(value, compareFuncs, 'invalid ' + prop, env.commandStr)
              return compareFuncs[value]
            },
            function (env, scope, value) {
              var COMPARE_FUNCS = env.constants.compareFuncs
              check$1.optional(function () {
                env.assert(scope,
                  value + ' in ' + COMPARE_FUNCS,
                  'invalid ' + prop + ', must be one of ' + Object.keys(compareFuncs))
              })
              return scope.def(COMPARE_FUNCS, '[', value, ']')
            })

        case S_DEPTH_RANGE:
          return parseParam(
            function (value) {
              check$1.command(
                isArrayLike(value) &&
                value.length === 2 &&
                typeof value[0] === 'number' &&
                typeof value[1] === 'number' &&
                value[0] <= value[1],
                'depth range is 2d array',
                env.commandStr)
              return value
            },
            function (env, scope, value) {
              check$1.optional(function () {
                env.assert(scope,
                  env.shared.isArrayLike + '(' + value + ')&&' +
                  value + '.length===2&&' +
                  'typeof ' + value + '[0]==="number"&&' +
                  'typeof ' + value + '[1]==="number"&&' +
                  value + '[0]<=' + value + '[1]',
                  'depth range must be a 2d array')
              })

              var Z_NEAR = scope.def('+', value, '[0]')
              var Z_FAR = scope.def('+', value, '[1]')
              return [Z_NEAR, Z_FAR]
            })

        case S_BLEND_FUNC:
          return parseParam(
            function (value) {
              check$1.commandType(value, 'object', 'blend.func', env.commandStr)
              var srcRGB = ('srcRGB' in value ? value.srcRGB : value.src)
              var srcAlpha = ('srcAlpha' in value ? value.srcAlpha : value.src)
              var dstRGB = ('dstRGB' in value ? value.dstRGB : value.dst)
              var dstAlpha = ('dstAlpha' in value ? value.dstAlpha : value.dst)
              check$1.commandParameter(srcRGB, blendFuncs, param + '.srcRGB', env.commandStr)
              check$1.commandParameter(srcAlpha, blendFuncs, param + '.srcAlpha', env.commandStr)
              check$1.commandParameter(dstRGB, blendFuncs, param + '.dstRGB', env.commandStr)
              check$1.commandParameter(dstAlpha, blendFuncs, param + '.dstAlpha', env.commandStr)

              check$1.command(
                (invalidBlendCombinations.indexOf(srcRGB + ', ' + dstRGB) === -1),
                'unallowed blending combination (srcRGB, dstRGB) = (' + srcRGB + ', ' + dstRGB + ')', env.commandStr)

              return [
                blendFuncs[srcRGB],
                blendFuncs[dstRGB],
                blendFuncs[srcAlpha],
                blendFuncs[dstAlpha]
              ]
            },
            function (env, scope, value) {
              var BLEND_FUNCS = env.constants.blendFuncs

              check$1.optional(function () {
                env.assert(scope,
                  value + '&&typeof ' + value + '==="object"',
                  'invalid blend func, must be an object')
              })

              function read (prefix, suffix) {
                var func = scope.def(
                  '"', prefix, suffix, '" in ', value,
                  '?', value, '.', prefix, suffix,
                  ':', value, '.', prefix)

                check$1.optional(function () {
                  env.assert(scope,
                    func + ' in ' + BLEND_FUNCS,
                    'invalid ' + prop + '.' + prefix + suffix + ', must be one of ' + Object.keys(blendFuncs))
                })

                return func
              }

              var srcRGB = read('src', 'RGB')
              var dstRGB = read('dst', 'RGB')

              check$1.optional(function () {
                var INVALID_BLEND_COMBINATIONS = env.constants.invalidBlendCombinations

                env.assert(scope,
                  INVALID_BLEND_COMBINATIONS +
                           '.indexOf(' + srcRGB + '+", "+' + dstRGB + ') === -1 ',
                  'unallowed blending combination for (srcRGB, dstRGB)'
                )
              })

              var SRC_RGB = scope.def(BLEND_FUNCS, '[', srcRGB, ']')
              var SRC_ALPHA = scope.def(BLEND_FUNCS, '[', read('src', 'Alpha'), ']')
              var DST_RGB = scope.def(BLEND_FUNCS, '[', dstRGB, ']')
              var DST_ALPHA = scope.def(BLEND_FUNCS, '[', read('dst', 'Alpha'), ']')

              return [SRC_RGB, DST_RGB, SRC_ALPHA, DST_ALPHA]
            })

        case S_BLEND_EQUATION:
          return parseParam(
            function (value) {
              if (typeof value === 'string') {
                check$1.commandParameter(value, blendEquations, 'invalid ' + prop, env.commandStr)
                return [
                  blendEquations[value],
                  blendEquations[value]
                ]
              } else if (typeof value === 'object') {
                check$1.commandParameter(
                  value.rgb, blendEquations, prop + '.rgb', env.commandStr)
                check$1.commandParameter(
                  value.alpha, blendEquations, prop + '.alpha', env.commandStr)
                return [
                  blendEquations[value.rgb],
                  blendEquations[value.alpha]
                ]
              } else {
                check$1.commandRaise('invalid blend.equation', env.commandStr)
              }
            },
            function (env, scope, value) {
              var BLEND_EQUATIONS = env.constants.blendEquations

              var RGB = scope.def()
              var ALPHA = scope.def()

              var ifte = env.cond('typeof ', value, '==="string"')

              check$1.optional(function () {
                function checkProp (block, name, value) {
                  env.assert(block,
                    value + ' in ' + BLEND_EQUATIONS,
                    'invalid ' + name + ', must be one of ' + Object.keys(blendEquations))
                }
                checkProp(ifte.then, prop, value)

                env.assert(ifte.else,
                  value + '&&typeof ' + value + '==="object"',
                  'invalid ' + prop)
                checkProp(ifte.else, prop + '.rgb', value + '.rgb')
                checkProp(ifte.else, prop + '.alpha', value + '.alpha')
              })

              ifte.then(
                RGB, '=', ALPHA, '=', BLEND_EQUATIONS, '[', value, '];')
              ifte.else(
                RGB, '=', BLEND_EQUATIONS, '[', value, '.rgb];',
                ALPHA, '=', BLEND_EQUATIONS, '[', value, '.alpha];')

              scope(ifte)

              return [RGB, ALPHA]
            })

        case S_BLEND_COLOR:
          return parseParam(
            function (value) {
              check$1.command(
                isArrayLike(value) &&
                value.length === 4,
                'blend.color must be a 4d array', env.commandStr)
              return loop(4, function (i) {
                return +value[i]
              })
            },
            function (env, scope, value) {
              check$1.optional(function () {
                env.assert(scope,
                  env.shared.isArrayLike + '(' + value + ')&&' +
                  value + '.length===4',
                  'blend.color must be a 4d array')
              })
              return loop(4, function (i) {
                return scope.def('+', value, '[', i, ']')
              })
            })

        case S_STENCIL_MASK:
          return parseParam(
            function (value) {
              check$1.commandType(value, 'number', param, env.commandStr)
              return value | 0
            },
            function (env, scope, value) {
              check$1.optional(function () {
                env.assert(scope,
                  'typeof ' + value + '==="number"',
                  'invalid stencil.mask')
              })
              return scope.def(value, '|0')
            })

        case S_STENCIL_FUNC:
          return parseParam(
            function (value) {
              check$1.commandType(value, 'object', param, env.commandStr)
              var cmp = value.cmp || 'keep'
              var ref = value.ref || 0
              var mask = 'mask' in value ? value.mask : -1
              check$1.commandParameter(cmp, compareFuncs, prop + '.cmp', env.commandStr)
              check$1.commandType(ref, 'number', prop + '.ref', env.commandStr)
              check$1.commandType(mask, 'number', prop + '.mask', env.commandStr)
              return [
                compareFuncs[cmp],
                ref,
                mask
              ]
            },
            function (env, scope, value) {
              var COMPARE_FUNCS = env.constants.compareFuncs
              check$1.optional(function () {
                function assert () {
                  env.assert(scope,
                    Array.prototype.join.call(arguments, ''),
                    'invalid stencil.func')
                }
                assert(value + '&&typeof ', value, '==="object"')
                assert('!("cmp" in ', value, ')||(',
                  value, '.cmp in ', COMPARE_FUNCS, ')')
              })
              var cmp = scope.def(
                '"cmp" in ', value,
                '?', COMPARE_FUNCS, '[', value, '.cmp]',
                ':', GL_KEEP)
              var ref = scope.def(value, '.ref|0')
              var mask = scope.def(
                '"mask" in ', value,
                '?', value, '.mask|0:-1')
              return [cmp, ref, mask]
            })

        case S_STENCIL_OPFRONT:
        case S_STENCIL_OPBACK:
          return parseParam(
            function (value) {
              check$1.commandType(value, 'object', param, env.commandStr)
              var fail = value.fail || 'keep'
              var zfail = value.zfail || 'keep'
              var zpass = value.zpass || 'keep'
              check$1.commandParameter(fail, stencilOps, prop + '.fail', env.commandStr)
              check$1.commandParameter(zfail, stencilOps, prop + '.zfail', env.commandStr)
              check$1.commandParameter(zpass, stencilOps, prop + '.zpass', env.commandStr)
              return [
                prop === S_STENCIL_OPBACK ? GL_BACK : GL_FRONT,
                stencilOps[fail],
                stencilOps[zfail],
                stencilOps[zpass]
              ]
            },
            function (env, scope, value) {
              var STENCIL_OPS = env.constants.stencilOps

              check$1.optional(function () {
                env.assert(scope,
                  value + '&&typeof ' + value + '==="object"',
                  'invalid ' + prop)
              })

              function read (name) {
                check$1.optional(function () {
                  env.assert(scope,
                    '!("' + name + '" in ' + value + ')||' +
                    '(' + value + '.' + name + ' in ' + STENCIL_OPS + ')',
                    'invalid ' + prop + '.' + name + ', must be one of ' + Object.keys(stencilOps))
                })

                return scope.def(
                  '"', name, '" in ', value,
                  '?', STENCIL_OPS, '[', value, '.', name, ']:',
                  GL_KEEP)
              }

              return [
                prop === S_STENCIL_OPBACK ? GL_BACK : GL_FRONT,
                read('fail'),
                read('zfail'),
                read('zpass')
              ]
            })

        case S_POLYGON_OFFSET_OFFSET:
          return parseParam(
            function (value) {
              check$1.commandType(value, 'object', param, env.commandStr)
              var factor = value.factor | 0
              var units = value.units | 0
              check$1.commandType(factor, 'number', param + '.factor', env.commandStr)
              check$1.commandType(units, 'number', param + '.units', env.commandStr)
              return [factor, units]
            },
            function (env, scope, value) {
              check$1.optional(function () {
                env.assert(scope,
                  value + '&&typeof ' + value + '==="object"',
                  'invalid ' + prop)
              })

              var FACTOR = scope.def(value, '.factor|0')
              var UNITS = scope.def(value, '.units|0')

              return [FACTOR, UNITS]
            })

        case S_CULL_FACE:
          return parseParam(
            function (value) {
              var face = 0
              if (value === 'front') {
                face = GL_FRONT
              } else if (value === 'back') {
                face = GL_BACK
              }
              check$1.command(!!face, param, env.commandStr)
              return face
            },
            function (env, scope, value) {
              check$1.optional(function () {
                env.assert(scope,
                  value + '==="front"||' +
                  value + '==="back"',
                  'invalid cull.face')
              })
              return scope.def(value, '==="front"?', GL_FRONT, ':', GL_BACK)
            })

        case S_LINE_WIDTH:
          return parseParam(
            function (value) {
              check$1.command(
                typeof value === 'number' &&
                value >= limits.lineWidthDims[0] &&
                value <= limits.lineWidthDims[1],
                'invalid line width, must be a positive number between ' +
                limits.lineWidthDims[0] + ' and ' + limits.lineWidthDims[1], env.commandStr)
              return value
            },
            function (env, scope, value) {
              check$1.optional(function () {
                env.assert(scope,
                  'typeof ' + value + '==="number"&&' +
                  value + '>=' + limits.lineWidthDims[0] + '&&' +
                  value + '<=' + limits.lineWidthDims[1],
                  'invalid line width')
              })

              return value
            })

        case S_FRONT_FACE:
          return parseParam(
            function (value) {
              check$1.commandParameter(value, orientationType, param, env.commandStr)
              return orientationType[value]
            },
            function (env, scope, value) {
              check$1.optional(function () {
                env.assert(scope,
                  value + '==="cw"||' +
                  value + '==="ccw"',
                  'invalid frontFace, must be one of cw,ccw')
              })
              return scope.def(value + '==="cw"?' + GL_CW + ':' + GL_CCW)
            })

        case S_COLOR_MASK:
          return parseParam(
            function (value) {
              check$1.command(
                isArrayLike(value) && value.length === 4,
                'color.mask must be length 4 array', env.commandStr)
              return value.map(function (v) { return !!v })
            },
            function (env, scope, value) {
              check$1.optional(function () {
                env.assert(scope,
                  env.shared.isArrayLike + '(' + value + ')&&' +
                  value + '.length===4',
                  'invalid color.mask')
              })
              return loop(4, function (i) {
                return '!!' + value + '[' + i + ']'
              })
            })

        case S_SAMPLE_COVERAGE:
          return parseParam(
            function (value) {
              check$1.command(typeof value === 'object' && value, param, env.commandStr)
              var sampleValue = 'value' in value ? value.value : 1
              var sampleInvert = !!value.invert
              check$1.command(
                typeof sampleValue === 'number' &&
                sampleValue >= 0 && sampleValue <= 1,
                'sample.coverage.value must be a number between 0 and 1', env.commandStr)
              return [sampleValue, sampleInvert]
            },
            function (env, scope, value) {
              check$1.optional(function () {
                env.assert(scope,
                  value + '&&typeof ' + value + '==="object"',
                  'invalid sample.coverage')
              })
              var VALUE = scope.def(
                '"value" in ', value, '?+', value, '.value:1')
              var INVERT = scope.def('!!', value, '.invert')
              return [VALUE, INVERT]
            })
      }
    })

    return STATE
  }

  function parseUniforms (uniforms, env) {
    var staticUniforms = uniforms.static
    var dynamicUniforms = uniforms.dynamic

    var UNIFORMS = {}

    Object.keys(staticUniforms).forEach(function (name) {
      var value = staticUniforms[name]
      var result
      if (typeof value === 'number' ||
          typeof value === 'boolean') {
        result = createStaticDecl(function () {
          return value
        })
      } else if (typeof value === 'function') {
        var reglType = value._reglType
        if (reglType === 'texture2d' ||
            reglType === 'textureCube') {
          result = createStaticDecl(function (env) {
            return env.link(value)
          })
        } else if (reglType === 'framebuffer' ||
                   reglType === 'framebufferCube') {
          check$1.command(value.color.length > 0,
            'missing color attachment for framebuffer sent to uniform "' + name + '"', env.commandStr)
          result = createStaticDecl(function (env) {
            return env.link(value.color[0])
          })
        } else {
          check$1.commandRaise('invalid data for uniform "' + name + '"', env.commandStr)
        }
      } else if (isArrayLike(value)) {
        result = createStaticDecl(function (env) {
          var ITEM = env.global.def('[',
            loop(value.length, function (i) {
              check$1.command(
                typeof value[i] === 'number' ||
                typeof value[i] === 'boolean',
                'invalid uniform ' + name, env.commandStr)
              return value[i]
            }), ']')
          return ITEM
        })
      } else {
        check$1.commandRaise('invalid or missing data for uniform "' + name + '"', env.commandStr)
      }
      result.value = value
      UNIFORMS[name] = result
    })

    Object.keys(dynamicUniforms).forEach(function (key) {
      var dyn = dynamicUniforms[key]
      UNIFORMS[key] = createDynamicDecl(dyn, function (env, scope) {
        return env.invoke(scope, dyn)
      })
    })

    return UNIFORMS
  }

  function parseAttributes (attributes, env) {
    var staticAttributes = attributes.static
    var dynamicAttributes = attributes.dynamic

    var attributeDefs = {}

    Object.keys(staticAttributes).forEach(function (attribute) {
      var value = staticAttributes[attribute]
      var id = stringStore.id(attribute)

      var record = new AttributeRecord()
      if (isBufferArgs(value)) {
        record.state = ATTRIB_STATE_POINTER
        record.buffer = bufferState.getBuffer(
          bufferState.create(value, GL_ARRAY_BUFFER$2, false, true))
        record.type = 0
      } else {
        var buffer = bufferState.getBuffer(value)
        if (buffer) {
          record.state = ATTRIB_STATE_POINTER
          record.buffer = buffer
          record.type = 0
        } else {
          check$1.command(typeof value === 'object' && value,
            'invalid data for attribute ' + attribute, env.commandStr)
          if ('constant' in value) {
            var constant = value.constant
            record.buffer = 'null'
            record.state = ATTRIB_STATE_CONSTANT
            if (typeof constant === 'number') {
              record.x = constant
            } else {
              check$1.command(
                isArrayLike(constant) &&
                constant.length > 0 &&
                constant.length <= 4,
                'invalid constant for attribute ' + attribute, env.commandStr)
              CUTE_COMPONENTS.forEach(function (c, i) {
                if (i < constant.length) {
                  record[c] = constant[i]
                }
              })
            }
          } else {
            if (isBufferArgs(value.buffer)) {
              buffer = bufferState.getBuffer(
                bufferState.create(value.buffer, GL_ARRAY_BUFFER$2, false, true))
            } else {
              buffer = bufferState.getBuffer(value.buffer)
            }
            check$1.command(!!buffer, 'missing buffer for attribute "' + attribute + '"', env.commandStr)

            var offset = value.offset | 0
            check$1.command(offset >= 0,
              'invalid offset for attribute "' + attribute + '"', env.commandStr)

            var stride = value.stride | 0
            check$1.command(stride >= 0 && stride < 256,
              'invalid stride for attribute "' + attribute + '", must be integer betweeen [0, 255]', env.commandStr)

            var size = value.size | 0
            check$1.command(!('size' in value) || (size > 0 && size <= 4),
              'invalid size for attribute "' + attribute + '", must be 1,2,3,4', env.commandStr)

            var normalized = !!value.normalized

            var type = 0
            if ('type' in value) {
              check$1.commandParameter(
                value.type, glTypes,
                'invalid type for attribute ' + attribute, env.commandStr)
              type = glTypes[value.type]
            }

            var divisor = value.divisor | 0
            if ('divisor' in value) {
              check$1.command(divisor === 0 || extInstancing,
                'cannot specify divisor for attribute "' + attribute + '", instancing not supported', env.commandStr)
              check$1.command(divisor >= 0,
                'invalid divisor for attribute "' + attribute + '"', env.commandStr)
            }

            check$1.optional(function () {
              var command = env.commandStr

              var VALID_KEYS = [
                'buffer',
                'offset',
                'divisor',
                'normalized',
                'type',
                'size',
                'stride'
              ]

              Object.keys(value).forEach(function (prop) {
                check$1.command(
                  VALID_KEYS.indexOf(prop) >= 0,
                  'unknown parameter "' + prop + '" for attribute pointer "' + attribute + '" (valid parameters are ' + VALID_KEYS + ')',
                  command)
              })
            })

            record.buffer = buffer
            record.state = ATTRIB_STATE_POINTER
            record.size = size
            record.normalized = normalized
            record.type = type || buffer.dtype
            record.offset = offset
            record.stride = stride
            record.divisor = divisor
          }
        }
      }

      attributeDefs[attribute] = createStaticDecl(function (env, scope) {
        var cache = env.attribCache
        if (id in cache) {
          return cache[id]
        }
        var result = {
          isStream: false
        }
        Object.keys(record).forEach(function (key) {
          result[key] = record[key]
        })
        if (record.buffer) {
          result.buffer = env.link(record.buffer)
          result.type = result.type || (result.buffer + '.dtype')
        }
        cache[id] = result
        return result
      })
    })

    Object.keys(dynamicAttributes).forEach(function (attribute) {
      var dyn = dynamicAttributes[attribute]

      function appendAttributeCode (env, block) {
        var VALUE = env.invoke(block, dyn)

        var shared = env.shared
        var constants = env.constants

        var IS_BUFFER_ARGS = shared.isBufferArgs
        var BUFFER_STATE = shared.buffer

        // Perform validation on attribute
        check$1.optional(function () {
          env.assert(block,
            VALUE + '&&(typeof ' + VALUE + '==="object"||typeof ' +
            VALUE + '==="function")&&(' +
            IS_BUFFER_ARGS + '(' + VALUE + ')||' +
            BUFFER_STATE + '.getBuffer(' + VALUE + ')||' +
            BUFFER_STATE + '.getBuffer(' + VALUE + '.buffer)||' +
            IS_BUFFER_ARGS + '(' + VALUE + '.buffer)||' +
            '("constant" in ' + VALUE +
            '&&(typeof ' + VALUE + '.constant==="number"||' +
            shared.isArrayLike + '(' + VALUE + '.constant))))',
            'invalid dynamic attribute "' + attribute + '"')
        })

        // allocate names for result
        var result = {
          isStream: block.def(false)
        }
        var defaultRecord = new AttributeRecord()
        defaultRecord.state = ATTRIB_STATE_POINTER
        Object.keys(defaultRecord).forEach(function (key) {
          result[key] = block.def('' + defaultRecord[key])
        })

        var BUFFER = result.buffer
        var TYPE = result.type
        block(
          'if(', IS_BUFFER_ARGS, '(', VALUE, ')){',
          result.isStream, '=true;',
          BUFFER, '=', BUFFER_STATE, '.createStream(', GL_ARRAY_BUFFER$2, ',', VALUE, ');',
          TYPE, '=', BUFFER, '.dtype;',
          '}else{',
          BUFFER, '=', BUFFER_STATE, '.getBuffer(', VALUE, ');',
          'if(', BUFFER, '){',
          TYPE, '=', BUFFER, '.dtype;',
          '}else if("constant" in ', VALUE, '){',
          result.state, '=', ATTRIB_STATE_CONSTANT, ';',
          'if(typeof ' + VALUE + '.constant === "number"){',
          result[CUTE_COMPONENTS[0]], '=', VALUE, '.constant;',
          CUTE_COMPONENTS.slice(1).map(function (n) {
            return result[n]
          }).join('='), '=0;',
          '}else{',
          CUTE_COMPONENTS.map(function (name, i) {
            return (
              result[name] + '=' + VALUE + '.constant.length>' + i +
              '?' + VALUE + '.constant[' + i + ']:0;'
            )
          }).join(''),
          '}}else{',
          'if(', IS_BUFFER_ARGS, '(', VALUE, '.buffer)){',
          BUFFER, '=', BUFFER_STATE, '.createStream(', GL_ARRAY_BUFFER$2, ',', VALUE, '.buffer);',
          '}else{',
          BUFFER, '=', BUFFER_STATE, '.getBuffer(', VALUE, '.buffer);',
          '}',
          TYPE, '="type" in ', VALUE, '?',
          constants.glTypes, '[', VALUE, '.type]:', BUFFER, '.dtype;',
          result.normalized, '=!!', VALUE, '.normalized;')
        function emitReadRecord (name) {
          block(result[name], '=', VALUE, '.', name, '|0;')
        }
        emitReadRecord('size')
        emitReadRecord('offset')
        emitReadRecord('stride')
        emitReadRecord('divisor')

        block('}}')

        block.exit(
          'if(', result.isStream, '){',
          BUFFER_STATE, '.destroyStream(', BUFFER, ');',
          '}')

        return result
      }

      attributeDefs[attribute] = createDynamicDecl(dyn, appendAttributeCode)
    })

    return attributeDefs
  }

  function parseVAO (options, env) {
    var staticOptions = options.static
    var dynamicOptions = options.dynamic
    if (S_VAO in staticOptions) {
      var vao = staticOptions[S_VAO]
      if (vao !== null && attributeState.getVAO(vao) === null) {
        vao = attributeState.createVAO(vao)
      }
      return createStaticDecl(function (env) {
        return env.link(attributeState.getVAO(vao))
      })
    } else if (S_VAO in dynamicOptions) {
      var dyn = dynamicOptions[S_VAO]
      return createDynamicDecl(dyn, function (env, scope) {
        var vaoRef = env.invoke(scope, dyn)
        return scope.def(env.shared.vao + '.getVAO(' + vaoRef + ')')
      })
    }
    return null
  }

  function parseContext (context) {
    var staticContext = context.static
    var dynamicContext = context.dynamic
    var result = {}

    Object.keys(staticContext).forEach(function (name) {
      var value = staticContext[name]
      result[name] = createStaticDecl(function (env, scope) {
        if (typeof value === 'number' || typeof value === 'boolean') {
          return '' + value
        } else {
          return env.link(value)
        }
      })
    })

    Object.keys(dynamicContext).forEach(function (name) {
      var dyn = dynamicContext[name]
      result[name] = createDynamicDecl(dyn, function (env, scope) {
        return env.invoke(scope, dyn)
      })
    })

    return result
  }

  function parseArguments (options, attributes, uniforms, context, env) {
    var staticOptions = options.static
    var dynamicOptions = options.dynamic

    check$1.optional(function () {
      var KEY_NAMES = [
        S_FRAMEBUFFER,
        S_VERT,
        S_FRAG,
        S_ELEMENTS,
        S_PRIMITIVE,
        S_OFFSET,
        S_COUNT,
        S_INSTANCES,
        S_PROFILE,
        S_VAO
      ].concat(GL_STATE_NAMES)

      function checkKeys (dict) {
        Object.keys(dict).forEach(function (key) {
          check$1.command(
            KEY_NAMES.indexOf(key) >= 0,
            'unknown parameter "' + key + '"',
            env.commandStr)
        })
      }

      checkKeys(staticOptions)
      checkKeys(dynamicOptions)
    })

    var attribLocations = parseAttribLocations(options, attributes)

    var framebuffer = parseFramebuffer(options, env)
    var viewportAndScissor = parseViewportScissor(options, framebuffer, env)
    var draw = parseDraw(options, env)
    var state = parseGLState(options, env)
    var shader = parseProgram(options, env, attribLocations)

    function copyBox (name) {
      var defn = viewportAndScissor[name]
      if (defn) {
        state[name] = defn
      }
    }
    copyBox(S_VIEWPORT)
    copyBox(propName(S_SCISSOR_BOX))

    var dirty = Object.keys(state).length > 0

    var result = {
      framebuffer: framebuffer,
      draw: draw,
      shader: shader,
      state: state,
      dirty: dirty,
      scopeVAO: null,
      drawVAO: null,
      useVAO: false,
      attributes: {}
    }

    result.profile = parseProfile(options, env)
    result.uniforms = parseUniforms(uniforms, env)
    result.drawVAO = result.scopeVAO = parseVAO(options, env)
    // special case: check if we can statically allocate a vertex array object for this program
    if (!result.drawVAO && shader.program && !attribLocations && extensions.angle_instanced_arrays) {
      var useVAO = true
      var staticBindings = shader.program.attributes.map(function (attr) {
        var binding = attributes.static[attr]
        useVAO = useVAO && !!binding
        return binding
      })
      if (useVAO && staticBindings.length > 0) {
        var vao = attributeState.getVAO(attributeState.createVAO(staticBindings))
        result.drawVAO = new Declaration(null, null, null, function (env, scope) {
          return env.link(vao)
        })
        result.useVAO = true
      }
    }
    if (attribLocations) {
      result.useVAO = true
    } else {
      result.attributes = parseAttributes(attributes, env)
    }
    result.context = parseContext(context, env)
    return result
  }

  // ===================================================
  // ===================================================
  // COMMON UPDATE FUNCTIONS
  // ===================================================
  // ===================================================
  function emitContext (env, scope, context) {
    var shared = env.shared
    var CONTEXT = shared.context

    var contextEnter = env.scope()

    Object.keys(context).forEach(function (name) {
      scope.save(CONTEXT, '.' + name)
      var defn = context[name]
      var value = defn.append(env, scope)
      if (Array.isArray(value)) {
        contextEnter(CONTEXT, '.', name, '=[', value.join(), '];')
      } else {
        contextEnter(CONTEXT, '.', name, '=', value, ';')
      }
    })

    scope(contextEnter)
  }

  // ===================================================
  // ===================================================
  // COMMON DRAWING FUNCTIONS
  // ===================================================
  // ===================================================
  function emitPollFramebuffer (env, scope, framebuffer, skipCheck) {
    var shared = env.shared

    var GL = shared.gl
    var FRAMEBUFFER_STATE = shared.framebuffer
    var EXT_DRAW_BUFFERS
    if (extDrawBuffers) {
      EXT_DRAW_BUFFERS = scope.def(shared.extensions, '.webgl_draw_buffers')
    }

    var constants = env.constants

    var DRAW_BUFFERS = constants.drawBuffer
    var BACK_BUFFER = constants.backBuffer

    var NEXT
    if (framebuffer) {
      NEXT = framebuffer.append(env, scope)
    } else {
      NEXT = scope.def(FRAMEBUFFER_STATE, '.next')
    }

    if (!skipCheck) {
      scope('if(', NEXT, '!==', FRAMEBUFFER_STATE, '.cur){')
    }
    scope(
      'if(', NEXT, '){',
      GL, '.bindFramebuffer(', GL_FRAMEBUFFER$2, ',', NEXT, '.framebuffer);')
    if (extDrawBuffers) {
      scope(EXT_DRAW_BUFFERS, '.drawBuffersWEBGL(',
        DRAW_BUFFERS, '[', NEXT, '.colorAttachments.length]);')
    }
    scope('}else{',
      GL, '.bindFramebuffer(', GL_FRAMEBUFFER$2, ',null);')
    if (extDrawBuffers) {
      scope(EXT_DRAW_BUFFERS, '.drawBuffersWEBGL(', BACK_BUFFER, ');')
    }
    scope(
      '}',
      FRAMEBUFFER_STATE, '.cur=', NEXT, ';')
    if (!skipCheck) {
      scope('}')
    }
  }

  function emitPollState (env, scope, args) {
    var shared = env.shared

    var GL = shared.gl

    var CURRENT_VARS = env.current
    var NEXT_VARS = env.next
    var CURRENT_STATE = shared.current
    var NEXT_STATE = shared.next

    var block = env.cond(CURRENT_STATE, '.dirty')

    GL_STATE_NAMES.forEach(function (prop) {
      var param = propName(prop)
      if (param in args.state) {
        return
      }

      var NEXT, CURRENT
      if (param in NEXT_VARS) {
        NEXT = NEXT_VARS[param]
        CURRENT = CURRENT_VARS[param]
        var parts = loop(currentState[param].length, function (i) {
          return block.def(NEXT, '[', i, ']')
        })
        block(env.cond(parts.map(function (p, i) {
          return p + '!==' + CURRENT + '[' + i + ']'
        }).join('||'))
          .then(
            GL, '.', GL_VARIABLES[param], '(', parts, ');',
            parts.map(function (p, i) {
              return CURRENT + '[' + i + ']=' + p
            }).join(';'), ';'))
      } else {
        NEXT = block.def(NEXT_STATE, '.', param)
        var ifte = env.cond(NEXT, '!==', CURRENT_STATE, '.', param)
        block(ifte)
        if (param in GL_FLAGS) {
          ifte(
            env.cond(NEXT)
              .then(GL, '.enable(', GL_FLAGS[param], ');')
              .else(GL, '.disable(', GL_FLAGS[param], ');'),
            CURRENT_STATE, '.', param, '=', NEXT, ';')
        } else {
          ifte(
            GL, '.', GL_VARIABLES[param], '(', NEXT, ');',
            CURRENT_STATE, '.', param, '=', NEXT, ';')
        }
      }
    })
    if (Object.keys(args.state).length === 0) {
      block(CURRENT_STATE, '.dirty=false;')
    }
    scope(block)
  }

  function emitSetOptions (env, scope, options, filter) {
    var shared = env.shared
    var CURRENT_VARS = env.current
    var CURRENT_STATE = shared.current
    var GL = shared.gl
    sortState(Object.keys(options)).forEach(function (param) {
      var defn = options[param]
      if (filter && !filter(defn)) {
        return
      }
      var variable = defn.append(env, scope)
      if (GL_FLAGS[param]) {
        var flag = GL_FLAGS[param]
        if (isStatic(defn)) {
          if (variable) {
            scope(GL, '.enable(', flag, ');')
          } else {
            scope(GL, '.disable(', flag, ');')
          }
        } else {
          scope(env.cond(variable)
            .then(GL, '.enable(', flag, ');')
            .else(GL, '.disable(', flag, ');'))
        }
        scope(CURRENT_STATE, '.', param, '=', variable, ';')
      } else if (isArrayLike(variable)) {
        var CURRENT = CURRENT_VARS[param]
        scope(
          GL, '.', GL_VARIABLES[param], '(', variable, ');',
          variable.map(function (v, i) {
            return CURRENT + '[' + i + ']=' + v
          }).join(';'), ';')
      } else {
        scope(
          GL, '.', GL_VARIABLES[param], '(', variable, ');',
          CURRENT_STATE, '.', param, '=', variable, ';')
      }
    })
  }

  function injectExtensions (env, scope) {
    if (extInstancing) {
      env.instancing = scope.def(
        env.shared.extensions, '.angle_instanced_arrays')
    }
  }

  function emitProfile (env, scope, args, useScope, incrementCounter) {
    var shared = env.shared
    var STATS = env.stats
    var CURRENT_STATE = shared.current
    var TIMER = shared.timer
    var profileArg = args.profile

    function perfCounter () {
      if (typeof performance === 'undefined') {
        return 'Date.now()'
      } else {
        return 'performance.now()'
      }
    }

    var CPU_START, QUERY_COUNTER
    function emitProfileStart (block) {
      CPU_START = scope.def()
      block(CPU_START, '=', perfCounter(), ';')
      if (typeof incrementCounter === 'string') {
        block(STATS, '.count+=', incrementCounter, ';')
      } else {
        block(STATS, '.count++;')
      }
      if (timer) {
        if (useScope) {
          QUERY_COUNTER = scope.def()
          block(QUERY_COUNTER, '=', TIMER, '.getNumPendingQueries();')
        } else {
          block(TIMER, '.beginQuery(', STATS, ');')
        }
      }
    }

    function emitProfileEnd (block) {
      block(STATS, '.cpuTime+=', perfCounter(), '-', CPU_START, ';')
      if (timer) {
        if (useScope) {
          block(TIMER, '.pushScopeStats(',
            QUERY_COUNTER, ',',
            TIMER, '.getNumPendingQueries(),',
            STATS, ');')
        } else {
          block(TIMER, '.endQuery();')
        }
      }
    }

    function scopeProfile (value) {
      var prev = scope.def(CURRENT_STATE, '.profile')
      scope(CURRENT_STATE, '.profile=', value, ';')
      scope.exit(CURRENT_STATE, '.profile=', prev, ';')
    }

    var USE_PROFILE
    if (profileArg) {
      if (isStatic(profileArg)) {
        if (profileArg.enable) {
          emitProfileStart(scope)
          emitProfileEnd(scope.exit)
          scopeProfile('true')
        } else {
          scopeProfile('false')
        }
        return
      }
      USE_PROFILE = profileArg.append(env, scope)
      scopeProfile(USE_PROFILE)
    } else {
      USE_PROFILE = scope.def(CURRENT_STATE, '.profile')
    }

    var start = env.block()
    emitProfileStart(start)
    scope('if(', USE_PROFILE, '){', start, '}')
    var end = env.block()
    emitProfileEnd(end)
    scope.exit('if(', USE_PROFILE, '){', end, '}')
  }

  function emitAttributes (env, scope, args, attributes, filter) {
    var shared = env.shared

    function typeLength (x) {
      switch (x) {
        case GL_FLOAT_VEC2:
        case GL_INT_VEC2:
        case GL_BOOL_VEC2:
          return 2
        case GL_FLOAT_VEC3:
        case GL_INT_VEC3:
        case GL_BOOL_VEC3:
          return 3
        case GL_FLOAT_VEC4:
        case GL_INT_VEC4:
        case GL_BOOL_VEC4:
          return 4
        default:
          return 1
      }
    }

    function emitBindAttribute (ATTRIBUTE, size, record) {
      var GL = shared.gl

      var LOCATION = scope.def(ATTRIBUTE, '.location')
      var BINDING = scope.def(shared.attributes, '[', LOCATION, ']')

      var STATE = record.state
      var BUFFER = record.buffer
      var CONST_COMPONENTS = [
        record.x,
        record.y,
        record.z,
        record.w
      ]

      var COMMON_KEYS = [
        'buffer',
        'normalized',
        'offset',
        'stride'
      ]

      function emitBuffer () {
        scope(
          'if(!', BINDING, '.buffer){',
          GL, '.enableVertexAttribArray(', LOCATION, ');}')

        var TYPE = record.type
        var SIZE
        if (!record.size) {
          SIZE = size
        } else {
          SIZE = scope.def(record.size, '||', size)
        }

        scope('if(',
          BINDING, '.type!==', TYPE, '||',
          BINDING, '.size!==', SIZE, '||',
          COMMON_KEYS.map(function (key) {
            return BINDING + '.' + key + '!==' + record[key]
          }).join('||'),
          '){',
          GL, '.bindBuffer(', GL_ARRAY_BUFFER$2, ',', BUFFER, '.buffer);',
          GL, '.vertexAttribPointer(', [
            LOCATION,
            SIZE,
            TYPE,
            record.normalized,
            record.stride,
            record.offset
          ], ');',
          BINDING, '.type=', TYPE, ';',
          BINDING, '.size=', SIZE, ';',
          COMMON_KEYS.map(function (key) {
            return BINDING + '.' + key + '=' + record[key] + ';'
          }).join(''),
          '}')

        if (extInstancing) {
          var DIVISOR = record.divisor
          scope(
            'if(', BINDING, '.divisor!==', DIVISOR, '){',
            env.instancing, '.vertexAttribDivisorANGLE(', [LOCATION, DIVISOR], ');',
            BINDING, '.divisor=', DIVISOR, ';}')
        }
      }

      function emitConstant () {
        scope(
          'if(', BINDING, '.buffer){',
          GL, '.disableVertexAttribArray(', LOCATION, ');',
          BINDING, '.buffer=null;',
          '}if(', CUTE_COMPONENTS.map(function (c, i) {
            return BINDING + '.' + c + '!==' + CONST_COMPONENTS[i]
          }).join('||'), '){',
          GL, '.vertexAttrib4f(', LOCATION, ',', CONST_COMPONENTS, ');',
          CUTE_COMPONENTS.map(function (c, i) {
            return BINDING + '.' + c + '=' + CONST_COMPONENTS[i] + ';'
          }).join(''),
          '}')
      }

      if (STATE === ATTRIB_STATE_POINTER) {
        emitBuffer()
      } else if (STATE === ATTRIB_STATE_CONSTANT) {
        emitConstant()
      } else {
        scope('if(', STATE, '===', ATTRIB_STATE_POINTER, '){')
        emitBuffer()
        scope('}else{')
        emitConstant()
        scope('}')
      }
    }

    attributes.forEach(function (attribute) {
      var name = attribute.name
      var arg = args.attributes[name]
      var record
      if (arg) {
        if (!filter(arg)) {
          return
        }
        record = arg.append(env, scope)
      } else {
        if (!filter(SCOPE_DECL)) {
          return
        }
        var scopeAttrib = env.scopeAttrib(name)
        check$1.optional(function () {
          env.assert(scope,
            scopeAttrib + '.state',
            'missing attribute ' + name)
        })
        record = {}
        Object.keys(new AttributeRecord()).forEach(function (key) {
          record[key] = scope.def(scopeAttrib, '.', key)
        })
      }
      emitBindAttribute(
        env.link(attribute), typeLength(attribute.info.type), record)
    })
  }

  function emitUniforms (env, scope, args, uniforms, filter) {
    var shared = env.shared
    var GL = shared.gl

    var infix
    for (var i = 0; i < uniforms.length; ++i) {
      var uniform = uniforms[i]
      var name = uniform.name
      var type = uniform.info.type
      var arg = args.uniforms[name]
      var UNIFORM = env.link(uniform)
      var LOCATION = UNIFORM + '.location'

      var VALUE
      if (arg) {
        if (!filter(arg)) {
          continue
        }
        if (isStatic(arg)) {
          var value = arg.value
          check$1.command(
            value !== null && typeof value !== 'undefined',
            'missing uniform "' + name + '"', env.commandStr)
          if (type === GL_SAMPLER_2D || type === GL_SAMPLER_CUBE) {
            check$1.command(
              typeof value === 'function' &&
              ((type === GL_SAMPLER_2D &&
                (value._reglType === 'texture2d' ||
                value._reglType === 'framebuffer')) ||
              (type === GL_SAMPLER_CUBE &&
                (value._reglType === 'textureCube' ||
                value._reglType === 'framebufferCube'))),
              'invalid texture for uniform ' + name, env.commandStr)
            var TEX_VALUE = env.link(value._texture || value.color[0]._texture)
            scope(GL, '.uniform1i(', LOCATION, ',', TEX_VALUE + '.bind());')
            scope.exit(TEX_VALUE, '.unbind();')
          } else if (
            type === GL_FLOAT_MAT2 ||
            type === GL_FLOAT_MAT3 ||
            type === GL_FLOAT_MAT4) {
            check$1.optional(function () {
              check$1.command(isArrayLike(value),
                'invalid matrix for uniform ' + name, env.commandStr)
              check$1.command(
                (type === GL_FLOAT_MAT2 && value.length === 4) ||
                (type === GL_FLOAT_MAT3 && value.length === 9) ||
                (type === GL_FLOAT_MAT4 && value.length === 16),
                'invalid length for matrix uniform ' + name, env.commandStr)
            })
            var MAT_VALUE = env.global.def('new Float32Array([' +
              Array.prototype.slice.call(value) + '])')
            var dim = 2
            if (type === GL_FLOAT_MAT3) {
              dim = 3
            } else if (type === GL_FLOAT_MAT4) {
              dim = 4
            }
            scope(
              GL, '.uniformMatrix', dim, 'fv(',
              LOCATION, ',false,', MAT_VALUE, ');')
          } else {
            switch (type) {
              case GL_FLOAT$8:
                check$1.commandType(value, 'number', 'uniform ' + name, env.commandStr)
                infix = '1f'
                break
              case GL_FLOAT_VEC2:
                check$1.command(
                  isArrayLike(value) && value.length === 2,
                  'uniform ' + name, env.commandStr)
                infix = '2f'
                break
              case GL_FLOAT_VEC3:
                check$1.command(
                  isArrayLike(value) && value.length === 3,
                  'uniform ' + name, env.commandStr)
                infix = '3f'
                break
              case GL_FLOAT_VEC4:
                check$1.command(
                  isArrayLike(value) && value.length === 4,
                  'uniform ' + name, env.commandStr)
                infix = '4f'
                break
              case GL_BOOL:
                check$1.commandType(value, 'boolean', 'uniform ' + name, env.commandStr)
                infix = '1i'
                break
              case GL_INT$3:
                check$1.commandType(value, 'number', 'uniform ' + name, env.commandStr)
                infix = '1i'
                break
              case GL_BOOL_VEC2:
                check$1.command(
                  isArrayLike(value) && value.length === 2,
                  'uniform ' + name, env.commandStr)
                infix = '2i'
                break
              case GL_INT_VEC2:
                check$1.command(
                  isArrayLike(value) && value.length === 2,
                  'uniform ' + name, env.commandStr)
                infix = '2i'
                break
              case GL_BOOL_VEC3:
                check$1.command(
                  isArrayLike(value) && value.length === 3,
                  'uniform ' + name, env.commandStr)
                infix = '3i'
                break
              case GL_INT_VEC3:
                check$1.command(
                  isArrayLike(value) && value.length === 3,
                  'uniform ' + name, env.commandStr)
                infix = '3i'
                break
              case GL_BOOL_VEC4:
                check$1.command(
                  isArrayLike(value) && value.length === 4,
                  'uniform ' + name, env.commandStr)
                infix = '4i'
                break
              case GL_INT_VEC4:
                check$1.command(
                  isArrayLike(value) && value.length === 4,
                  'uniform ' + name, env.commandStr)
                infix = '4i'
                break
            }
            scope(GL, '.uniform', infix, '(', LOCATION, ',',
              isArrayLike(value) ? Array.prototype.slice.call(value) : value,
              ');')
          }
          continue
        } else {
          VALUE = arg.append(env, scope)
        }
      } else {
        if (!filter(SCOPE_DECL)) {
          continue
        }
        VALUE = scope.def(shared.uniforms, '[', stringStore.id(name), ']')
      }

      if (type === GL_SAMPLER_2D) {
        check$1(!Array.isArray(VALUE), 'must specify a scalar prop for textures')
        scope(
          'if(', VALUE, '&&', VALUE, '._reglType==="framebuffer"){',
          VALUE, '=', VALUE, '.color[0];',
          '}')
      } else if (type === GL_SAMPLER_CUBE) {
        check$1(!Array.isArray(VALUE), 'must specify a scalar prop for cube maps')
        scope(
          'if(', VALUE, '&&', VALUE, '._reglType==="framebufferCube"){',
          VALUE, '=', VALUE, '.color[0];',
          '}')
      }

      // perform type validation
      check$1.optional(function () {
        function emitCheck (pred, message) {
          env.assert(scope, pred,
            'bad data or missing for uniform "' + name + '".  ' + message)
        }

        function checkType (type) {
          check$1(!Array.isArray(VALUE), 'must not specify an array type for uniform')
          emitCheck(
            'typeof ' + VALUE + '==="' + type + '"',
            'invalid type, expected ' + type)
        }

        function checkVector (n, type) {
          if (Array.isArray(VALUE)) {
            check$1(VALUE.length === n, 'must have length ' + n)
          } else {
            emitCheck(
              shared.isArrayLike + '(' + VALUE + ')&&' + VALUE + '.length===' + n,
              'invalid vector, should have length ' + n, env.commandStr)
          }
        }

        function checkTexture (target) {
          check$1(!Array.isArray(VALUE), 'must not specify a value type')
          emitCheck(
            'typeof ' + VALUE + '==="function"&&' +
            VALUE + '._reglType==="texture' +
            (target === GL_TEXTURE_2D$3 ? '2d' : 'Cube') + '"',
            'invalid texture type', env.commandStr)
        }

        switch (type) {
          case GL_INT$3:
            checkType('number')
            break
          case GL_INT_VEC2:
            checkVector(2, 'number')
            break
          case GL_INT_VEC3:
            checkVector(3, 'number')
            break
          case GL_INT_VEC4:
            checkVector(4, 'number')
            break
          case GL_FLOAT$8:
            checkType('number')
            break
          case GL_FLOAT_VEC2:
            checkVector(2, 'number')
            break
          case GL_FLOAT_VEC3:
            checkVector(3, 'number')
            break
          case GL_FLOAT_VEC4:
            checkVector(4, 'number')
            break
          case GL_BOOL:
            checkType('boolean')
            break
          case GL_BOOL_VEC2:
            checkVector(2, 'boolean')
            break
          case GL_BOOL_VEC3:
            checkVector(3, 'boolean')
            break
          case GL_BOOL_VEC4:
            checkVector(4, 'boolean')
            break
          case GL_FLOAT_MAT2:
            checkVector(4, 'number')
            break
          case GL_FLOAT_MAT3:
            checkVector(9, 'number')
            break
          case GL_FLOAT_MAT4:
            checkVector(16, 'number')
            break
          case GL_SAMPLER_2D:
            checkTexture(GL_TEXTURE_2D$3)
            break
          case GL_SAMPLER_CUBE:
            checkTexture(GL_TEXTURE_CUBE_MAP$2)
            break
        }
      })

      var unroll = 1
      switch (type) {
        case GL_SAMPLER_2D:
        case GL_SAMPLER_CUBE:
          var TEX = scope.def(VALUE, '._texture')
          scope(GL, '.uniform1i(', LOCATION, ',', TEX, '.bind());')
          scope.exit(TEX, '.unbind();')
          continue

        case GL_INT$3:
        case GL_BOOL:
          infix = '1i'
          break

        case GL_INT_VEC2:
        case GL_BOOL_VEC2:
          infix = '2i'
          unroll = 2
          break

        case GL_INT_VEC3:
        case GL_BOOL_VEC3:
          infix = '3i'
          unroll = 3
          break

        case GL_INT_VEC4:
        case GL_BOOL_VEC4:
          infix = '4i'
          unroll = 4
          break

        case GL_FLOAT$8:
          infix = '1f'
          break

        case GL_FLOAT_VEC2:
          infix = '2f'
          unroll = 2
          break

        case GL_FLOAT_VEC3:
          infix = '3f'
          unroll = 3
          break

        case GL_FLOAT_VEC4:
          infix = '4f'
          unroll = 4
          break

        case GL_FLOAT_MAT2:
          infix = 'Matrix2fv'
          break

        case GL_FLOAT_MAT3:
          infix = 'Matrix3fv'
          break

        case GL_FLOAT_MAT4:
          infix = 'Matrix4fv'
          break
      }

      scope(GL, '.uniform', infix, '(', LOCATION, ',')
      if (infix.charAt(0) === 'M') {
        var matSize = Math.pow(type - GL_FLOAT_MAT2 + 2, 2)
        var STORAGE = env.global.def('new Float32Array(', matSize, ')')
        if (Array.isArray(VALUE)) {
          scope(
            'false,(',
            loop(matSize, function (i) {
              return STORAGE + '[' + i + ']=' + VALUE[i]
            }), ',', STORAGE, ')')
        } else {
          scope(
            'false,(Array.isArray(', VALUE, ')||', VALUE, ' instanceof Float32Array)?', VALUE, ':(',
            loop(matSize, function (i) {
              return STORAGE + '[' + i + ']=' + VALUE + '[' + i + ']'
            }), ',', STORAGE, ')')
        }
      } else if (unroll > 1) {
        scope(loop(unroll, function (i) {
          return Array.isArray(VALUE) ? VALUE[i] : VALUE + '[' + i + ']'
        }))
      } else {
        check$1(!Array.isArray(VALUE), 'uniform value must not be an array')
        scope(VALUE)
      }
      scope(');')
    }
  }

  function emitDraw (env, outer, inner, args) {
    var shared = env.shared
    var GL = shared.gl
    var DRAW_STATE = shared.draw

    var drawOptions = args.draw

    function emitElements () {
      var defn = drawOptions.elements
      var ELEMENTS
      var scope = outer
      if (defn) {
        if ((defn.contextDep && args.contextDynamic) || defn.propDep) {
          scope = inner
        }
        ELEMENTS = defn.append(env, scope)
      } else {
        ELEMENTS = scope.def(DRAW_STATE, '.', S_ELEMENTS)
      }
      if (ELEMENTS) {
        scope(
          'if(' + ELEMENTS + ')' +
          GL + '.bindBuffer(' + GL_ELEMENT_ARRAY_BUFFER$1 + ',' + ELEMENTS + '.buffer.buffer);')
      }
      return ELEMENTS
    }

    function emitCount () {
      var defn = drawOptions.count
      var COUNT
      var scope = outer
      if (defn) {
        if ((defn.contextDep && args.contextDynamic) || defn.propDep) {
          scope = inner
        }
        COUNT = defn.append(env, scope)
        check$1.optional(function () {
          if (defn.MISSING) {
            env.assert(outer, 'false', 'missing vertex count')
          }
          if (defn.DYNAMIC) {
            env.assert(scope, COUNT + '>=0', 'missing vertex count')
          }
        })
      } else {
        COUNT = scope.def(DRAW_STATE, '.', S_COUNT)
        check$1.optional(function () {
          env.assert(scope, COUNT + '>=0', 'missing vertex count')
        })
      }
      return COUNT
    }

    var ELEMENTS = emitElements()
    function emitValue (name) {
      var defn = drawOptions[name]
      if (defn) {
        if ((defn.contextDep && args.contextDynamic) || defn.propDep) {
          return defn.append(env, inner)
        } else {
          return defn.append(env, outer)
        }
      } else {
        return outer.def(DRAW_STATE, '.', name)
      }
    }

    var PRIMITIVE = emitValue(S_PRIMITIVE)
    var OFFSET = emitValue(S_OFFSET)

    var COUNT = emitCount()
    if (typeof COUNT === 'number') {
      if (COUNT === 0) {
        return
      }
    } else {
      inner('if(', COUNT, '){')
      inner.exit('}')
    }

    var INSTANCES, EXT_INSTANCING
    if (extInstancing) {
      INSTANCES = emitValue(S_INSTANCES)
      EXT_INSTANCING = env.instancing
    }

    var ELEMENT_TYPE = ELEMENTS + '.type'

    var elementsStatic = drawOptions.elements && isStatic(drawOptions.elements)

    function emitInstancing () {
      function drawElements () {
        inner(EXT_INSTANCING, '.drawElementsInstancedANGLE(', [
          PRIMITIVE,
          COUNT,
          ELEMENT_TYPE,
          OFFSET + '<<((' + ELEMENT_TYPE + '-' + GL_UNSIGNED_BYTE$8 + ')>>1)',
          INSTANCES
        ], ');')
      }

      function drawArrays () {
        inner(EXT_INSTANCING, '.drawArraysInstancedANGLE(',
          [PRIMITIVE, OFFSET, COUNT, INSTANCES], ');')
      }

      if (ELEMENTS) {
        if (!elementsStatic) {
          inner('if(', ELEMENTS, '){')
          drawElements()
          inner('}else{')
          drawArrays()
          inner('}')
        } else {
          drawElements()
        }
      } else {
        drawArrays()
      }
    }

    function emitRegular () {
      function drawElements () {
        inner(GL + '.drawElements(' + [
          PRIMITIVE,
          COUNT,
          ELEMENT_TYPE,
          OFFSET + '<<((' + ELEMENT_TYPE + '-' + GL_UNSIGNED_BYTE$8 + ')>>1)'
        ] + ');')
      }

      function drawArrays () {
        inner(GL + '.drawArrays(' + [PRIMITIVE, OFFSET, COUNT] + ');')
      }

      if (ELEMENTS) {
        if (!elementsStatic) {
          inner('if(', ELEMENTS, '){')
          drawElements()
          inner('}else{')
          drawArrays()
          inner('}')
        } else {
          drawElements()
        }
      } else {
        drawArrays()
      }
    }

    if (extInstancing && (typeof INSTANCES !== 'number' || INSTANCES >= 0)) {
      if (typeof INSTANCES === 'string') {
        inner('if(', INSTANCES, '>0){')
        emitInstancing()
        inner('}else if(', INSTANCES, '<0){')
        emitRegular()
        inner('}')
      } else {
        emitInstancing()
      }
    } else {
      emitRegular()
    }
  }

  function createBody (emitBody, parentEnv, args, program, count) {
    var env = createREGLEnvironment()
    var scope = env.proc('body', count)
    check$1.optional(function () {
      env.commandStr = parentEnv.commandStr
      env.command = env.link(parentEnv.commandStr)
    })
    if (extInstancing) {
      env.instancing = scope.def(
        env.shared.extensions, '.angle_instanced_arrays')
    }
    emitBody(env, scope, args, program)
    return env.compile().body
  }

  // ===================================================
  // ===================================================
  // DRAW PROC
  // ===================================================
  // ===================================================
  function emitDrawBody (env, draw, args, program) {
    injectExtensions(env, draw)
    if (args.useVAO) {
      if (args.drawVAO) {
        draw(env.shared.vao, '.setVAO(', args.drawVAO.append(env, draw), ');')
      } else {
        draw(env.shared.vao, '.setVAO(', env.shared.vao, '.targetVAO);')
      }
    } else {
      draw(env.shared.vao, '.setVAO(null);')
      emitAttributes(env, draw, args, program.attributes, function () {
        return true
      })
    }
    emitUniforms(env, draw, args, program.uniforms, function () {
      return true
    })
    emitDraw(env, draw, draw, args)
  }

  function emitDrawProc (env, args) {
    var draw = env.proc('draw', 1)

    injectExtensions(env, draw)

    emitContext(env, draw, args.context)
    emitPollFramebuffer(env, draw, args.framebuffer)

    emitPollState(env, draw, args)
    emitSetOptions(env, draw, args.state)

    emitProfile(env, draw, args, false, true)

    var program = args.shader.progVar.append(env, draw)
    draw(env.shared.gl, '.useProgram(', program, '.program);')

    if (args.shader.program) {
      emitDrawBody(env, draw, args, args.shader.program)
    } else {
      draw(env.shared.vao, '.setVAO(null);')
      var drawCache = env.global.def('{}')
      var PROG_ID = draw.def(program, '.id')
      var CACHED_PROC = draw.def(drawCache, '[', PROG_ID, ']')
      draw(
        env.cond(CACHED_PROC)
          .then(CACHED_PROC, '.call(this,a0);')
          .else(
            CACHED_PROC, '=', drawCache, '[', PROG_ID, ']=',
            env.link(function (program) {
              return createBody(emitDrawBody, env, args, program, 1)
            }), '(', program, ');',
            CACHED_PROC, '.call(this,a0);'))
    }

    if (Object.keys(args.state).length > 0) {
      draw(env.shared.current, '.dirty=true;')
    }
  }

  // ===================================================
  // ===================================================
  // BATCH PROC
  // ===================================================
  // ===================================================

  function emitBatchDynamicShaderBody (env, scope, args, program) {
    env.batchId = 'a1'

    injectExtensions(env, scope)

    function all () {
      return true
    }

    emitAttributes(env, scope, args, program.attributes, all)
    emitUniforms(env, scope, args, program.uniforms, all)
    emitDraw(env, scope, scope, args)
  }

  function emitBatchBody (env, scope, args, program) {
    injectExtensions(env, scope)

    var contextDynamic = args.contextDep

    var BATCH_ID = scope.def()
    var PROP_LIST = 'a0'
    var NUM_PROPS = 'a1'
    var PROPS = scope.def()
    env.shared.props = PROPS
    env.batchId = BATCH_ID

    var outer = env.scope()
    var inner = env.scope()

    scope(
      outer.entry,
      'for(', BATCH_ID, '=0;', BATCH_ID, '<', NUM_PROPS, ';++', BATCH_ID, '){',
      PROPS, '=', PROP_LIST, '[', BATCH_ID, '];',
      inner,
      '}',
      outer.exit)

    function isInnerDefn (defn) {
      return ((defn.contextDep && contextDynamic) || defn.propDep)
    }

    function isOuterDefn (defn) {
      return !isInnerDefn(defn)
    }

    if (args.needsContext) {
      emitContext(env, inner, args.context)
    }
    if (args.needsFramebuffer) {
      emitPollFramebuffer(env, inner, args.framebuffer)
    }
    emitSetOptions(env, inner, args.state, isInnerDefn)

    if (args.profile && isInnerDefn(args.profile)) {
      emitProfile(env, inner, args, false, true)
    }

    if (!program) {
      var progCache = env.global.def('{}')
      var PROGRAM = args.shader.progVar.append(env, inner)
      var PROG_ID = inner.def(PROGRAM, '.id')
      var CACHED_PROC = inner.def(progCache, '[', PROG_ID, ']')
      inner(
        env.shared.gl, '.useProgram(', PROGRAM, '.program);',
        'if(!', CACHED_PROC, '){',
        CACHED_PROC, '=', progCache, '[', PROG_ID, ']=',
        env.link(function (program) {
          return createBody(
            emitBatchDynamicShaderBody, env, args, program, 2)
        }), '(', PROGRAM, ');}',
        CACHED_PROC, '.call(this,a0[', BATCH_ID, '],', BATCH_ID, ');')
    } else {
      if (args.useVAO) {
        if (args.drawVAO) {
          if (isInnerDefn(args.drawVAO)) {
            // vao is a prop
            inner(env.shared.vao, '.setVAO(', args.drawVAO.append(env, inner), ');')
          } else {
            // vao is invariant
            outer(env.shared.vao, '.setVAO(', args.drawVAO.append(env, outer), ');')
          }
        } else {
          // scoped vao binding
          outer(env.shared.vao, '.setVAO(', env.shared.vao, '.targetVAO);')
        }
      } else {
        outer(env.shared.vao, '.setVAO(null);')
        emitAttributes(env, outer, args, program.attributes, isOuterDefn)
        emitAttributes(env, inner, args, program.attributes, isInnerDefn)
      }
      emitUniforms(env, outer, args, program.uniforms, isOuterDefn)
      emitUniforms(env, inner, args, program.uniforms, isInnerDefn)
      emitDraw(env, outer, inner, args)
    }
  }

  function emitBatchProc (env, args) {
    var batch = env.proc('batch', 2)
    env.batchId = '0'

    injectExtensions(env, batch)

    // Check if any context variables depend on props
    var contextDynamic = false
    var needsContext = true
    Object.keys(args.context).forEach(function (name) {
      contextDynamic = contextDynamic || args.context[name].propDep
    })
    if (!contextDynamic) {
      emitContext(env, batch, args.context)
      needsContext = false
    }

    // framebuffer state affects framebufferWidth/height context vars
    var framebuffer = args.framebuffer
    var needsFramebuffer = false
    if (framebuffer) {
      if (framebuffer.propDep) {
        contextDynamic = needsFramebuffer = true
      } else if (framebuffer.contextDep && contextDynamic) {
        needsFramebuffer = true
      }
      if (!needsFramebuffer) {
        emitPollFramebuffer(env, batch, framebuffer)
      }
    } else {
      emitPollFramebuffer(env, batch, null)
    }

    // viewport is weird because it can affect context vars
    if (args.state.viewport && args.state.viewport.propDep) {
      contextDynamic = true
    }

    function isInnerDefn (defn) {
      return (defn.contextDep && contextDynamic) || defn.propDep
    }

    // set webgl options
    emitPollState(env, batch, args)
    emitSetOptions(env, batch, args.state, function (defn) {
      return !isInnerDefn(defn)
    })

    if (!args.profile || !isInnerDefn(args.profile)) {
      emitProfile(env, batch, args, false, 'a1')
    }

    // Save these values to args so that the batch body routine can use them
    args.contextDep = contextDynamic
    args.needsContext = needsContext
    args.needsFramebuffer = needsFramebuffer

    // determine if shader is dynamic
    var progDefn = args.shader.progVar
    if ((progDefn.contextDep && contextDynamic) || progDefn.propDep) {
      emitBatchBody(
        env,
        batch,
        args,
        null)
    } else {
      var PROGRAM = progDefn.append(env, batch)
      batch(env.shared.gl, '.useProgram(', PROGRAM, '.program);')
      if (args.shader.program) {
        emitBatchBody(
          env,
          batch,
          args,
          args.shader.program)
      } else {
        batch(env.shared.vao, '.setVAO(null);')
        var batchCache = env.global.def('{}')
        var PROG_ID = batch.def(PROGRAM, '.id')
        var CACHED_PROC = batch.def(batchCache, '[', PROG_ID, ']')
        batch(
          env.cond(CACHED_PROC)
            .then(CACHED_PROC, '.call(this,a0,a1);')
            .else(
              CACHED_PROC, '=', batchCache, '[', PROG_ID, ']=',
              env.link(function (program) {
                return createBody(emitBatchBody, env, args, program, 2)
              }), '(', PROGRAM, ');',
              CACHED_PROC, '.call(this,a0,a1);'))
      }
    }

    if (Object.keys(args.state).length > 0) {
      batch(env.shared.current, '.dirty=true;')
    }
  }

  // ===================================================
  // ===================================================
  // SCOPE COMMAND
  // ===================================================
  // ===================================================
  function emitScopeProc (env, args) {
    var scope = env.proc('scope', 3)
    env.batchId = 'a2'

    var shared = env.shared
    var CURRENT_STATE = shared.current

    emitContext(env, scope, args.context)

    if (args.framebuffer) {
      args.framebuffer.append(env, scope)
    }

    sortState(Object.keys(args.state)).forEach(function (name) {
      var defn = args.state[name]
      var value = defn.append(env, scope)
      if (isArrayLike(value)) {
        value.forEach(function (v, i) {
          scope.set(env.next[name], '[' + i + ']', v)
        })
      } else {
        scope.set(shared.next, '.' + name, value)
      }
    })

    emitProfile(env, scope, args, true, true)

    ;[S_ELEMENTS, S_OFFSET, S_COUNT, S_INSTANCES, S_PRIMITIVE].forEach(
      function (opt) {
        var variable = args.draw[opt]
        if (!variable) {
          return
        }
        scope.set(shared.draw, '.' + opt, '' + variable.append(env, scope))
      })

    Object.keys(args.uniforms).forEach(function (opt) {
      var value = args.uniforms[opt].append(env, scope)
      if (Array.isArray(value)) {
        value = '[' + value.join() + ']'
      }
      scope.set(
        shared.uniforms,
        '[' + stringStore.id(opt) + ']',
        value)
    })

    Object.keys(args.attributes).forEach(function (name) {
      var record = args.attributes[name].append(env, scope)
      var scopeAttrib = env.scopeAttrib(name)
      Object.keys(new AttributeRecord()).forEach(function (prop) {
        scope.set(scopeAttrib, '.' + prop, record[prop])
      })
    })

    if (args.scopeVAO) {
      scope.set(shared.vao, '.targetVAO', args.scopeVAO.append(env, scope))
    }

    function saveShader (name) {
      var shader = args.shader[name]
      if (shader) {
        scope.set(shared.shader, '.' + name, shader.append(env, scope))
      }
    }
    saveShader(S_VERT)
    saveShader(S_FRAG)

    if (Object.keys(args.state).length > 0) {
      scope(CURRENT_STATE, '.dirty=true;')
      scope.exit(CURRENT_STATE, '.dirty=true;')
    }

    scope('a1(', env.shared.context, ',a0,', env.batchId, ');')
  }

  function isDynamicObject (object) {
    if (typeof object !== 'object' || isArrayLike(object)) {
      return
    }
    var props = Object.keys(object)
    for (var i = 0; i < props.length; ++i) {
      if (dynamic.isDynamic(object[props[i]])) {
        return true
      }
    }
    return false
  }

  function splatObject (env, options, name) {
    var object = options.static[name]
    if (!object || !isDynamicObject(object)) {
      return
    }

    var globals = env.global
    var keys = Object.keys(object)
    var thisDep = false
    var contextDep = false
    var propDep = false
    var objectRef = env.global.def('{}')
    keys.forEach(function (key) {
      var value = object[key]
      if (dynamic.isDynamic(value)) {
        if (typeof value === 'function') {
          value = object[key] = dynamic.unbox(value)
        }
        var deps = createDynamicDecl(value, null)
        thisDep = thisDep || deps.thisDep
        propDep = propDep || deps.propDep
        contextDep = contextDep || deps.contextDep
      } else {
        globals(objectRef, '.', key, '=')
        switch (typeof value) {
          case 'number':
            globals(value)
            break
          case 'string':
            globals('"', value, '"')
            break
          case 'object':
            if (Array.isArray(value)) {
              globals('[', value.join(), ']')
            }
            break
          default:
            globals(env.link(value))
            break
        }
        globals(';')
      }
    })

    function appendBlock (env, block) {
      keys.forEach(function (key) {
        var value = object[key]
        if (!dynamic.isDynamic(value)) {
          return
        }
        var ref = env.invoke(block, value)
        block(objectRef, '.', key, '=', ref, ';')
      })
    }

    options.dynamic[name] = new dynamic.DynamicVariable(DYN_THUNK, {
      thisDep: thisDep,
      contextDep: contextDep,
      propDep: propDep,
      ref: objectRef,
      append: appendBlock
    })
    delete options.static[name]
  }

  // ===========================================================================
  // ===========================================================================
  // MAIN DRAW COMMAND
  // ===========================================================================
  // ===========================================================================
  function compileCommand (options, attributes, uniforms, context, stats) {
    var env = createREGLEnvironment()

    // link stats, so that we can easily access it in the program.
    env.stats = env.link(stats)

    // splat options and attributes to allow for dynamic nested properties
    Object.keys(attributes.static).forEach(function (key) {
      splatObject(env, attributes, key)
    })
    NESTED_OPTIONS.forEach(function (name) {
      splatObject(env, options, name)
    })

    var args = parseArguments(options, attributes, uniforms, context, env)

    emitDrawProc(env, args)
    emitScopeProc(env, args)
    emitBatchProc(env, args)

    return extend(env.compile(), {
      destroy: function () {
        args.shader.program.destroy()
      }
    })
  }

  // ===========================================================================
  // ===========================================================================
  // POLL / REFRESH
  // ===========================================================================
  // ===========================================================================
  return {
    next: nextState,
    current: currentState,
    procs: (function () {
      var env = createREGLEnvironment()
      var poll = env.proc('poll')
      var refresh = env.proc('refresh')
      var common = env.block()
      poll(common)
      refresh(common)

      var shared = env.shared
      var GL = shared.gl
      var NEXT_STATE = shared.next
      var CURRENT_STATE = shared.current

      common(CURRENT_STATE, '.dirty=false;')

      emitPollFramebuffer(env, poll)
      emitPollFramebuffer(env, refresh, null, true)

      // Refresh updates all attribute state changes
      var INSTANCING
      if (extInstancing) {
        INSTANCING = env.link(extInstancing)
      }

      // update vertex array bindings
      if (extensions.oes_vertex_array_object) {
        refresh(env.link(extensions.oes_vertex_array_object), '.bindVertexArrayOES(null);')
      }
      for (var i = 0; i < limits.maxAttributes; ++i) {
        var BINDING = refresh.def(shared.attributes, '[', i, ']')
        var ifte = env.cond(BINDING, '.buffer')
        ifte.then(
          GL, '.enableVertexAttribArray(', i, ');',
          GL, '.bindBuffer(',
          GL_ARRAY_BUFFER$2, ',',
          BINDING, '.buffer.buffer);',
          GL, '.vertexAttribPointer(',
          i, ',',
          BINDING, '.size,',
          BINDING, '.type,',
          BINDING, '.normalized,',
          BINDING, '.stride,',
          BINDING, '.offset);'
        ).else(
          GL, '.disableVertexAttribArray(', i, ');',
          GL, '.vertexAttrib4f(',
          i, ',',
          BINDING, '.x,',
          BINDING, '.y,',
          BINDING, '.z,',
          BINDING, '.w);',
          BINDING, '.buffer=null;')
        refresh(ifte)
        if (extInstancing) {
          refresh(
            INSTANCING, '.vertexAttribDivisorANGLE(',
            i, ',',
            BINDING, '.divisor);')
        }
      }
      refresh(
        env.shared.vao, '.currentVAO=null;',
        env.shared.vao, '.setVAO(', env.shared.vao, '.targetVAO);')

      Object.keys(GL_FLAGS).forEach(function (flag) {
        var cap = GL_FLAGS[flag]
        var NEXT = common.def(NEXT_STATE, '.', flag)
        var block = env.block()
        block('if(', NEXT, '){',
          GL, '.enable(', cap, ')}else{',
          GL, '.disable(', cap, ')}',
          CURRENT_STATE, '.', flag, '=', NEXT, ';')
        refresh(block)
        poll(
          'if(', NEXT, '!==', CURRENT_STATE, '.', flag, '){',
          block,
          '}')
      })

      Object.keys(GL_VARIABLES).forEach(function (name) {
        var func = GL_VARIABLES[name]
        var init = currentState[name]
        var NEXT, CURRENT
        var block = env.block()
        block(GL, '.', func, '(')
        if (isArrayLike(init)) {
          var n = init.length
          NEXT = env.global.def(NEXT_STATE, '.', name)
          CURRENT = env.global.def(CURRENT_STATE, '.', name)
          block(
            loop(n, function (i) {
              return NEXT + '[' + i + ']'
            }), ');',
            loop(n, function (i) {
              return CURRENT + '[' + i + ']=' + NEXT + '[' + i + '];'
            }).join(''))
          poll(
            'if(', loop(n, function (i) {
              return NEXT + '[' + i + ']!==' + CURRENT + '[' + i + ']'
            }).join('||'), '){',
            block,
            '}')
        } else {
          NEXT = common.def(NEXT_STATE, '.', name)
          CURRENT = common.def(CURRENT_STATE, '.', name)
          block(
            NEXT, ');',
            CURRENT_STATE, '.', name, '=', NEXT, ';')
          poll(
            'if(', NEXT, '!==', CURRENT, '){',
            block,
            '}')
        }
        refresh(block)
      })

      return env.compile()
    })(),
    compile: compileCommand
  }
}

function stats () {
  return {
    vaoCount: 0,
    bufferCount: 0,
    elementsCount: 0,
    framebufferCount: 0,
    shaderCount: 0,
    textureCount: 0,
    cubeCount: 0,
    renderbufferCount: 0,
    maxTextureUnits: 0
  }
}

var GL_QUERY_RESULT_EXT = 0x8866
var GL_QUERY_RESULT_AVAILABLE_EXT = 0x8867
var GL_TIME_ELAPSED_EXT = 0x88BF

var createTimer = function (gl, extensions) {
  if (!extensions.ext_disjoint_timer_query) {
    return null
  }

  // QUERY POOL BEGIN
  var queryPool = []
  function allocQuery () {
    return queryPool.pop() || extensions.ext_disjoint_timer_query.createQueryEXT()
  }
  function freeQuery (query) {
    queryPool.push(query)
  }
  // QUERY POOL END

  var pendingQueries = []
  function beginQuery (stats) {
    var query = allocQuery()
    extensions.ext_disjoint_timer_query.beginQueryEXT(GL_TIME_ELAPSED_EXT, query)
    pendingQueries.push(query)
    pushScopeStats(pendingQueries.length - 1, pendingQueries.length, stats)
  }

  function endQuery () {
    extensions.ext_disjoint_timer_query.endQueryEXT(GL_TIME_ELAPSED_EXT)
  }

  //
  // Pending stats pool.
  //
  function PendingStats () {
    this.startQueryIndex = -1
    this.endQueryIndex = -1
    this.sum = 0
    this.stats = null
  }
  var pendingStatsPool = []
  function allocPendingStats () {
    return pendingStatsPool.pop() || new PendingStats()
  }
  function freePendingStats (pendingStats) {
    pendingStatsPool.push(pendingStats)
  }
  // Pending stats pool end

  var pendingStats = []
  function pushScopeStats (start, end, stats) {
    var ps = allocPendingStats()
    ps.startQueryIndex = start
    ps.endQueryIndex = end
    ps.sum = 0
    ps.stats = stats
    pendingStats.push(ps)
  }

  // we should call this at the beginning of the frame,
  // in order to update gpuTime
  var timeSum = []
  var queryPtr = []
  function update () {
    var ptr, i

    var n = pendingQueries.length
    if (n === 0) {
      return
    }

    // Reserve space
    queryPtr.length = Math.max(queryPtr.length, n + 1)
    timeSum.length = Math.max(timeSum.length, n + 1)
    timeSum[0] = 0
    queryPtr[0] = 0

    // Update all pending timer queries
    var queryTime = 0
    ptr = 0
    for (i = 0; i < pendingQueries.length; ++i) {
      var query = pendingQueries[i]
      if (extensions.ext_disjoint_timer_query.getQueryObjectEXT(query, GL_QUERY_RESULT_AVAILABLE_EXT)) {
        queryTime += extensions.ext_disjoint_timer_query.getQueryObjectEXT(query, GL_QUERY_RESULT_EXT)
        freeQuery(query)
      } else {
        pendingQueries[ptr++] = query
      }
      timeSum[i + 1] = queryTime
      queryPtr[i + 1] = ptr
    }
    pendingQueries.length = ptr

    // Update all pending stat queries
    ptr = 0
    for (i = 0; i < pendingStats.length; ++i) {
      var stats = pendingStats[i]
      var start = stats.startQueryIndex
      var end = stats.endQueryIndex
      stats.sum += timeSum[end] - timeSum[start]
      var startPtr = queryPtr[start]
      var endPtr = queryPtr[end]
      if (endPtr === startPtr) {
        stats.stats.gpuTime += stats.sum / 1e6
        freePendingStats(stats)
      } else {
        stats.startQueryIndex = startPtr
        stats.endQueryIndex = endPtr
        pendingStats[ptr++] = stats
      }
    }
    pendingStats.length = ptr
  }

  return {
    beginQuery: beginQuery,
    endQuery: endQuery,
    pushScopeStats: pushScopeStats,
    update: update,
    getNumPendingQueries: function () {
      return pendingQueries.length
    },
    clear: function () {
      queryPool.push.apply(queryPool, pendingQueries)
      for (var i = 0; i < queryPool.length; i++) {
        extensions.ext_disjoint_timer_query.deleteQueryEXT(queryPool[i])
      }
      pendingQueries.length = 0
      queryPool.length = 0
    },
    restore: function () {
      pendingQueries.length = 0
      queryPool.length = 0
    }
  }
}

var GL_COLOR_BUFFER_BIT = 16384
var GL_DEPTH_BUFFER_BIT = 256
var GL_STENCIL_BUFFER_BIT = 1024

var GL_ARRAY_BUFFER = 34962

var CONTEXT_LOST_EVENT = 'webglcontextlost'
var CONTEXT_RESTORED_EVENT = 'webglcontextrestored'

var DYN_PROP = 1
var DYN_CONTEXT = 2
var DYN_STATE = 3

function find (haystack, needle) {
  for (var i = 0; i < haystack.length; ++i) {
    if (haystack[i] === needle) {
      return i
    }
  }
  return -1
}

function wrapREGL (args) {
  var config = parseArgs(args)
  if (!config) {
    return null
  }

  var gl = config.gl
  var glAttributes = gl.getContextAttributes()
  var contextLost = gl.isContextLost()

  var extensionState = createExtensionCache(gl, config)
  if (!extensionState) {
    return null
  }

  var stringStore = createStringStore()
  var stats$$1 = stats()
  var extensions = extensionState.extensions
  var timer = createTimer(gl, extensions)

  var START_TIME = clock()
  var WIDTH = gl.drawingBufferWidth
  var HEIGHT = gl.drawingBufferHeight

  var contextState = {
    tick: 0,
    time: 0,
    viewportWidth: WIDTH,
    viewportHeight: HEIGHT,
    framebufferWidth: WIDTH,
    framebufferHeight: HEIGHT,
    drawingBufferWidth: WIDTH,
    drawingBufferHeight: HEIGHT,
    pixelRatio: config.pixelRatio
  }
  var uniformState = {}
  var drawState = {
    elements: null,
    primitive: 4, // GL_TRIANGLES
    count: -1,
    offset: 0,
    instances: -1
  }

  var limits = wrapLimits(gl, extensions)
  var bufferState = wrapBufferState(
    gl,
    stats$$1,
    config,
    destroyBuffer)
  var attributeState = wrapAttributeState(
    gl,
    extensions,
    limits,
    stats$$1,
    bufferState)
  function destroyBuffer (buffer) {
    return attributeState.destroyBuffer(buffer)
  }
  var elementState = wrapElementsState(gl, extensions, bufferState, stats$$1)
  var shaderState = wrapShaderState(gl, stringStore, stats$$1, config)
  var textureState = createTextureSet(
    gl,
    extensions,
    limits,
    function () { core.procs.poll() },
    contextState,
    stats$$1,
    config)
  var renderbufferState = wrapRenderbuffers(gl, extensions, limits, stats$$1, config)
  var framebufferState = wrapFBOState(
    gl,
    extensions,
    limits,
    textureState,
    renderbufferState,
    stats$$1)
  var core = reglCore(
    gl,
    stringStore,
    extensions,
    limits,
    bufferState,
    elementState,
    textureState,
    framebufferState,
    uniformState,
    attributeState,
    shaderState,
    drawState,
    contextState,
    timer,
    config)
  var readPixels = wrapReadPixels(
    gl,
    framebufferState,
    core.procs.poll,
    contextState,
    glAttributes, extensions, limits)

  var nextState = core.next
  var canvas = gl.canvas

  var rafCallbacks = []
  var lossCallbacks = []
  var restoreCallbacks = []
  var destroyCallbacks = [config.onDestroy]

  var activeRAF = null
  function handleRAF () {
    if (rafCallbacks.length === 0) {
      if (timer) {
        timer.update()
      }
      activeRAF = null
      return
    }

    // schedule next animation frame
    activeRAF = raf.next(handleRAF)

    // poll for changes
    poll()

    // fire a callback for all pending rafs
    for (var i = rafCallbacks.length - 1; i >= 0; --i) {
      var cb = rafCallbacks[i]
      if (cb) {
        cb(contextState, null, 0)
      }
    }

    // flush all pending webgl calls
    gl.flush()

    // poll GPU timers *after* gl.flush so we don't delay command dispatch
    if (timer) {
      timer.update()
    }
  }

  function startRAF () {
    if (!activeRAF && rafCallbacks.length > 0) {
      activeRAF = raf.next(handleRAF)
    }
  }

  function stopRAF () {
    if (activeRAF) {
      raf.cancel(handleRAF)
      activeRAF = null
    }
  }

  function handleContextLoss (event) {
    event.preventDefault()

    // set context lost flag
    contextLost = true

    // pause request animation frame
    stopRAF()

    // lose context
    lossCallbacks.forEach(function (cb) {
      cb()
    })
  }

  function handleContextRestored (event) {
    // clear error code
    gl.getError()

    // clear context lost flag
    contextLost = false

    // refresh state
    extensionState.restore()
    shaderState.restore()
    bufferState.restore()
    textureState.restore()
    renderbufferState.restore()
    framebufferState.restore()
    attributeState.restore()
    if (timer) {
      timer.restore()
    }

    // refresh state
    core.procs.refresh()

    // restart RAF
    startRAF()

    // restore context
    restoreCallbacks.forEach(function (cb) {
      cb()
    })
  }

  if (canvas) {
    canvas.addEventListener(CONTEXT_LOST_EVENT, handleContextLoss, false)
    canvas.addEventListener(CONTEXT_RESTORED_EVENT, handleContextRestored, false)
  }

  function destroy () {
    rafCallbacks.length = 0
    stopRAF()

    if (canvas) {
      canvas.removeEventListener(CONTEXT_LOST_EVENT, handleContextLoss)
      canvas.removeEventListener(CONTEXT_RESTORED_EVENT, handleContextRestored)
    }

    shaderState.clear()
    framebufferState.clear()
    renderbufferState.clear()
    textureState.clear()
    elementState.clear()
    bufferState.clear()
    attributeState.clear()

    if (timer) {
      timer.clear()
    }

    destroyCallbacks.forEach(function (cb) {
      cb()
    })
  }

  function compileProcedure (options) {
    check$1(!!options, 'invalid args to regl({...})')
    check$1.type(options, 'object', 'invalid args to regl({...})')

    function flattenNestedOptions (options) {
      var result = extend({}, options)
      delete result.uniforms
      delete result.attributes
      delete result.context
      delete result.vao

      if ('stencil' in result && result.stencil.op) {
        result.stencil.opBack = result.stencil.opFront = result.stencil.op
        delete result.stencil.op
      }

      function merge (name) {
        if (name in result) {
          var child = result[name]
          delete result[name]
          Object.keys(child).forEach(function (prop) {
            result[name + '.' + prop] = child[prop]
          })
        }
      }
      merge('blend')
      merge('depth')
      merge('cull')
      merge('stencil')
      merge('polygonOffset')
      merge('scissor')
      merge('sample')

      if ('vao' in options) {
        result.vao = options.vao
      }

      return result
    }

    function separateDynamic (object, useArrays) {
      var staticItems = {}
      var dynamicItems = {}
      Object.keys(object).forEach(function (option) {
        var value = object[option]
        if (dynamic.isDynamic(value)) {
          dynamicItems[option] = dynamic.unbox(value, option)
          return
        } else if (useArrays && Array.isArray(value)) {
          for (var i = 0; i < value.length; ++i) {
            if (dynamic.isDynamic(value[i])) {
              dynamicItems[option] = dynamic.unbox(value, option)
              return
            }
          }
        }
        staticItems[option] = value
      })
      return {
        dynamic: dynamicItems,
        static: staticItems
      }
    }

    // Treat context variables separate from other dynamic variables
    var context = separateDynamic(options.context || {}, true)
    var uniforms = separateDynamic(options.uniforms || {}, true)
    var attributes = separateDynamic(options.attributes || {}, false)
    var opts = separateDynamic(flattenNestedOptions(options), false)

    var stats$$1 = {
      gpuTime: 0.0,
      cpuTime: 0.0,
      count: 0
    }

    var compiled = core.compile(opts, attributes, uniforms, context, stats$$1)

    var draw = compiled.draw
    var batch = compiled.batch
    var scope = compiled.scope

    // FIXME: we should modify code generation for batch commands so this
    // isn't necessary
    var EMPTY_ARRAY = []
    function reserve (count) {
      while (EMPTY_ARRAY.length < count) {
        EMPTY_ARRAY.push(null)
      }
      return EMPTY_ARRAY
    }

    function REGLCommand (args, body) {
      var i
      if (contextLost) {
        check$1.raise('context lost')
      }
      if (typeof args === 'function') {
        return scope.call(this, null, args, 0)
      } else if (typeof body === 'function') {
        if (typeof args === 'number') {
          for (i = 0; i < args; ++i) {
            scope.call(this, null, body, i)
          }
        } else if (Array.isArray(args)) {
          for (i = 0; i < args.length; ++i) {
            scope.call(this, args[i], body, i)
          }
        } else {
          return scope.call(this, args, body, 0)
        }
      } else if (typeof args === 'number') {
        if (args > 0) {
          return batch.call(this, reserve(args | 0), args | 0)
        }
      } else if (Array.isArray(args)) {
        if (args.length) {
          return batch.call(this, args, args.length)
        }
      } else {
        return draw.call(this, args)
      }
    }

    return extend(REGLCommand, {
      stats: stats$$1,
      destroy: function () {
        compiled.destroy()
      }
    })
  }

  var setFBO = framebufferState.setFBO = compileProcedure({
    framebuffer: dynamic.define.call(null, DYN_PROP, 'framebuffer')
  })

  function clearImpl (_, options) {
    var clearFlags = 0
    core.procs.poll()

    var c = options.color
    if (c) {
      gl.clearColor(+c[0] || 0, +c[1] || 0, +c[2] || 0, +c[3] || 0)
      clearFlags |= GL_COLOR_BUFFER_BIT
    }
    if ('depth' in options) {
      gl.clearDepth(+options.depth)
      clearFlags |= GL_DEPTH_BUFFER_BIT
    }
    if ('stencil' in options) {
      gl.clearStencil(options.stencil | 0)
      clearFlags |= GL_STENCIL_BUFFER_BIT
    }

    check$1(!!clearFlags, 'called regl.clear with no buffer specified')
    gl.clear(clearFlags)
  }

  function clear (options) {
    check$1(
      typeof options === 'object' && options,
      'regl.clear() takes an object as input')
    if ('framebuffer' in options) {
      if (options.framebuffer &&
          options.framebuffer_reglType === 'framebufferCube') {
        for (var i = 0; i < 6; ++i) {
          setFBO(extend({
            framebuffer: options.framebuffer.faces[i]
          }, options), clearImpl)
        }
      } else {
        setFBO(options, clearImpl)
      }
    } else {
      clearImpl(null, options)
    }
  }

  function frame (cb) {
    check$1.type(cb, 'function', 'regl.frame() callback must be a function')
    rafCallbacks.push(cb)

    function cancel () {
      // FIXME:  should we check something other than equals cb here?
      // what if a user calls frame twice with the same callback...
      //
      var i = find(rafCallbacks, cb)
      check$1(i >= 0, 'cannot cancel a frame twice')
      function pendingCancel () {
        var index = find(rafCallbacks, pendingCancel)
        rafCallbacks[index] = rafCallbacks[rafCallbacks.length - 1]
        rafCallbacks.length -= 1
        if (rafCallbacks.length <= 0) {
          stopRAF()
        }
      }
      rafCallbacks[i] = pendingCancel
    }

    startRAF()

    return {
      cancel: cancel
    }
  }

  // poll viewport
  function pollViewport () {
    var viewport = nextState.viewport
    var scissorBox = nextState.scissor_box
    viewport[0] = viewport[1] = scissorBox[0] = scissorBox[1] = 0
    contextState.viewportWidth =
      contextState.framebufferWidth =
      contextState.drawingBufferWidth =
      viewport[2] =
      scissorBox[2] = gl.drawingBufferWidth
    contextState.viewportHeight =
      contextState.framebufferHeight =
      contextState.drawingBufferHeight =
      viewport[3] =
      scissorBox[3] = gl.drawingBufferHeight
  }

  function poll () {
    contextState.tick += 1
    contextState.time = now()
    pollViewport()
    core.procs.poll()
  }

  function refresh () {
    textureState.refresh()
    pollViewport()
    core.procs.refresh()
    if (timer) {
      timer.update()
    }
  }

  function now () {
    return (clock() - START_TIME) / 1000.0
  }

  refresh()

  function addListener (event, callback) {
    check$1.type(callback, 'function', 'listener callback must be a function')

    var callbacks
    switch (event) {
      case 'frame':
        return frame(callback)
      case 'lost':
        callbacks = lossCallbacks
        break
      case 'restore':
        callbacks = restoreCallbacks
        break
      case 'destroy':
        callbacks = destroyCallbacks
        break
      default:
        check$1.raise('invalid event, must be one of frame,lost,restore,destroy')
    }

    callbacks.push(callback)
    return {
      cancel: function () {
        for (var i = 0; i < callbacks.length; ++i) {
          if (callbacks[i] === callback) {
            callbacks[i] = callbacks[callbacks.length - 1]
            callbacks.pop()
            return
          }
        }
      }
    }
  }

  var regl = extend(compileProcedure, {
    // Clear current FBO
    clear: clear,

    // Short cuts for dynamic variables
    prop: dynamic.define.bind(null, DYN_PROP),
    context: dynamic.define.bind(null, DYN_CONTEXT),
    this: dynamic.define.bind(null, DYN_STATE),

    // executes an empty draw command
    draw: compileProcedure({}),

    // Resources
    buffer: function (options) {
      return bufferState.create(options, GL_ARRAY_BUFFER, false, false)
    },
    elements: function (options) {
      return elementState.create(options, false)
    },
    texture: textureState.create2D,
    cube: textureState.createCube,
    renderbuffer: renderbufferState.create,
    framebuffer: framebufferState.create,
    framebufferCube: framebufferState.createCube,
    vao: attributeState.createVAO,

    // Expose context attributes
    attributes: glAttributes,

    // Frame rendering
    frame: frame,
    on: addListener,

    // System limits
    limits: limits,
    hasExtension: function (name) {
      return limits.extensions.indexOf(name.toLowerCase()) >= 0
    },

    // Read pixels
    read: readPixels,

    // Destroy regl and all associated resources
    destroy: destroy,

    // Direct GL state manipulation
    _gl: gl,
    _refresh: refresh,

    poll: function () {
      poll()
      if (timer) {
        timer.update()
      }
    },

    // Current time
    now: now,

    // regl Statistics Information
    stats: stats$$1
  })

  config.onDone(null, regl)

  return regl
}

return wrapREGL;

})));


},{}],103:[function(require,module,exports){
(function (global){(function (){
module.exports =
  global.performance &&
  global.performance.now ? function now() {
    return performance.now()
  } : Date.now || function now() {
    return +new Date
  }

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],104:[function(require,module,exports){
"use strict"

var twoProduct = require("two-product")
var robustSum = require("robust-sum")
var robustDiff = require("robust-subtract")
var robustScale = require("robust-scale")

var NUM_EXPAND = 6

function orientation(n) {
  var fn =
    n === 3 ? inSphere3 :
    n === 4 ? inSphere4 :
    n === 5 ? inSphere5 : inSphere6;

  return fn(robustSum, robustDiff, twoProduct, robustScale)
}

function inSphere0() { return 0 }
function inSphere1() { return 0 }
function inSphere2() { return 0 }

function inSphere3(sum, diff, prod, scale) {
  function exactInSphere3(m0, m1, m2) {
    var w0 = prod(m0[0], m0[0])
    var w0m1 = scale(w0, m1[0])
    var w0m2 = scale(w0, m2[0])
    var w1 = prod(m1[0], m1[0])
    var w1m0 = scale(w1, m0[0])
    var w1m2 = scale(w1, m2[0])
    var w2 = prod(m2[0], m2[0])
    var w2m0 = scale(w2, m0[0])
    var w2m1 = scale(w2, m1[0])
    var p = sum(diff(w2m1, w1m2), diff(w1m0, w0m1))
    var n = diff(w2m0, w0m2)
    var d = diff(p, n)
    return d[d.length - 1]
  }
  return exactInSphere3
}

function inSphere4(sum, diff, prod, scale) {
  function exactInSphere4(m0, m1, m2, m3) {
    var w0 = sum(prod(m0[0], m0[0]), prod(m0[1], m0[1]))
    var w0m1 = scale(w0, m1[0])
    var w0m2 = scale(w0, m2[0])
    var w0m3 = scale(w0, m3[0])
    var w1 = sum(prod(m1[0], m1[0]), prod(m1[1], m1[1]))
    var w1m0 = scale(w1, m0[0])
    var w1m2 = scale(w1, m2[0])
    var w1m3 = scale(w1, m3[0])
    var w2 = sum(prod(m2[0], m2[0]), prod(m2[1], m2[1]))
    var w2m0 = scale(w2, m0[0])
    var w2m1 = scale(w2, m1[0])
    var w2m3 = scale(w2, m3[0])
    var w3 = sum(prod(m3[0], m3[0]), prod(m3[1], m3[1]))
    var w3m0 = scale(w3, m0[0])
    var w3m1 = scale(w3, m1[0])
    var w3m2 = scale(w3, m2[0])
    var p = sum(sum(scale(diff(w3m2, w2m3), m1[1]), sum(scale(diff(w3m1, w1m3), -m2[1]), scale(diff(w2m1, w1m2), m3[1]))), sum(scale(diff(w3m1, w1m3), m0[1]), sum(scale(diff(w3m0, w0m3), -m1[1]), scale(diff(w1m0, w0m1), m3[1]))))
    var n = sum(sum(scale(diff(w3m2, w2m3), m0[1]), sum(scale(diff(w3m0, w0m3), -m2[1]), scale(diff(w2m0, w0m2), m3[1]))), sum(scale(diff(w2m1, w1m2), m0[1]), sum(scale(diff(w2m0, w0m2), -m1[1]), scale(diff(w1m0, w0m1), m2[1]))))
    var d = diff(p, n)
    return d[d.length - 1]
  }
  return exactInSphere4
}


function inSphere5(sum, diff, prod, scale) {
  function exactInSphere5(m0, m1, m2, m3, m4) {
    var w0 = sum(prod(m0[0], m0[0]), sum(prod(m0[1], m0[1]), prod(m0[2], m0[2])))
    var w0m1 = scale(w0, m1[0])
    var w0m2 = scale(w0, m2[0])
    var w0m3 = scale(w0, m3[0])
    var w0m4 = scale(w0, m4[0])
    var w1 = sum(prod(m1[0], m1[0]), sum(prod(m1[1], m1[1]), prod(m1[2], m1[2])))
    var w1m0 = scale(w1, m0[0])
    var w1m2 = scale(w1, m2[0])
    var w1m3 = scale(w1, m3[0])
    var w1m4 = scale(w1, m4[0])
    var w2 = sum(prod(m2[0], m2[0]), sum(prod(m2[1], m2[1]), prod(m2[2], m2[2])))
    var w2m0 = scale(w2, m0[0])
    var w2m1 = scale(w2, m1[0])
    var w2m3 = scale(w2, m3[0])
    var w2m4 = scale(w2, m4[0])
    var w3 = sum(prod(m3[0], m3[0]), sum(prod(m3[1], m3[1]), prod(m3[2], m3[2])))
    var w3m0 = scale(w3, m0[0])
    var w3m1 = scale(w3, m1[0])
    var w3m2 = scale(w3, m2[0])
    var w3m4 = scale(w3, m4[0])
    var w4 = sum(prod(m4[0], m4[0]), sum(prod(m4[1], m4[1]), prod(m4[2], m4[2])))
    var w4m0 = scale(w4, m0[0])
    var w4m1 = scale(w4, m1[0])
    var w4m2 = scale(w4, m2[0])
    var w4m3 = scale(w4, m3[0])
    var p = sum(sum(sum(scale(sum(scale(diff(w4m3, w3m4), m2[1]), sum(scale(diff(w4m2, w2m4), -m3[1]), scale(diff(w3m2, w2m3), m4[1]))), m1[2]), sum(scale(sum(scale(diff(w4m3, w3m4), m1[1]), sum(scale(diff(w4m1, w1m4), -m3[1]), scale(diff(w3m1, w1m3), m4[1]))), -m2[2]), scale(sum(scale(diff(w4m2, w2m4), m1[1]), sum(scale(diff(w4m1, w1m4), -m2[1]), scale(diff(w2m1, w1m2), m4[1]))), m3[2]))), sum(scale(sum(scale(diff(w3m2, w2m3), m1[1]), sum(scale(diff(w3m1, w1m3), -m2[1]), scale(diff(w2m1, w1m2), m3[1]))), -m4[2]), sum(scale(sum(scale(diff(w4m3, w3m4), m1[1]), sum(scale(diff(w4m1, w1m4), -m3[1]), scale(diff(w3m1, w1m3), m4[1]))), m0[2]), scale(sum(scale(diff(w4m3, w3m4), m0[1]), sum(scale(diff(w4m0, w0m4), -m3[1]), scale(diff(w3m0, w0m3), m4[1]))), -m1[2])))), sum(sum(scale(sum(scale(diff(w4m1, w1m4), m0[1]), sum(scale(diff(w4m0, w0m4), -m1[1]), scale(diff(w1m0, w0m1), m4[1]))), m3[2]), sum(scale(sum(scale(diff(w3m1, w1m3), m0[1]), sum(scale(diff(w3m0, w0m3), -m1[1]), scale(diff(w1m0, w0m1), m3[1]))), -m4[2]), scale(sum(scale(diff(w3m2, w2m3), m1[1]), sum(scale(diff(w3m1, w1m3), -m2[1]), scale(diff(w2m1, w1m2), m3[1]))), m0[2]))), sum(scale(sum(scale(diff(w3m2, w2m3), m0[1]), sum(scale(diff(w3m0, w0m3), -m2[1]), scale(diff(w2m0, w0m2), m3[1]))), -m1[2]), sum(scale(sum(scale(diff(w3m1, w1m3), m0[1]), sum(scale(diff(w3m0, w0m3), -m1[1]), scale(diff(w1m0, w0m1), m3[1]))), m2[2]), scale(sum(scale(diff(w2m1, w1m2), m0[1]), sum(scale(diff(w2m0, w0m2), -m1[1]), scale(diff(w1m0, w0m1), m2[1]))), -m3[2])))))
    var n = sum(sum(sum(scale(sum(scale(diff(w4m3, w3m4), m2[1]), sum(scale(diff(w4m2, w2m4), -m3[1]), scale(diff(w3m2, w2m3), m4[1]))), m0[2]), scale(sum(scale(diff(w4m3, w3m4), m0[1]), sum(scale(diff(w4m0, w0m4), -m3[1]), scale(diff(w3m0, w0m3), m4[1]))), -m2[2])), sum(scale(sum(scale(diff(w4m2, w2m4), m0[1]), sum(scale(diff(w4m0, w0m4), -m2[1]), scale(diff(w2m0, w0m2), m4[1]))), m3[2]), scale(sum(scale(diff(w3m2, w2m3), m0[1]), sum(scale(diff(w3m0, w0m3), -m2[1]), scale(diff(w2m0, w0m2), m3[1]))), -m4[2]))), sum(sum(scale(sum(scale(diff(w4m2, w2m4), m1[1]), sum(scale(diff(w4m1, w1m4), -m2[1]), scale(diff(w2m1, w1m2), m4[1]))), m0[2]), scale(sum(scale(diff(w4m2, w2m4), m0[1]), sum(scale(diff(w4m0, w0m4), -m2[1]), scale(diff(w2m0, w0m2), m4[1]))), -m1[2])), sum(scale(sum(scale(diff(w4m1, w1m4), m0[1]), sum(scale(diff(w4m0, w0m4), -m1[1]), scale(diff(w1m0, w0m1), m4[1]))), m2[2]), scale(sum(scale(diff(w2m1, w1m2), m0[1]), sum(scale(diff(w2m0, w0m2), -m1[1]), scale(diff(w1m0, w0m1), m2[1]))), -m4[2]))))
    var d = diff(p, n)
    return d[d.length - 1]
  }

    return exactInSphere5
}

function inSphere6(sum, diff, prod, scale) {
  function exactInSphere6(m0, m1, m2, m3, m4, m5) {
    var w0 = sum(sum(prod(m0[0], m0[0]), prod(m0[1], m0[1])), sum(prod(m0[2], m0[2]), prod(m0[3], m0[3])))
    var w0m1 = scale(w0, m1[0])
    var w0m2 = scale(w0, m2[0])
    var w0m3 = scale(w0, m3[0])
    var w0m4 = scale(w0, m4[0])
    var w0m5 = scale(w0, m5[0])
    var w1 = sum(sum(prod(m1[0], m1[0]), prod(m1[1], m1[1])), sum(prod(m1[2], m1[2]), prod(m1[3], m1[3])))
    var w1m0 = scale(w1, m0[0])
    var w1m2 = scale(w1, m2[0])
    var w1m3 = scale(w1, m3[0])
    var w1m4 = scale(w1, m4[0])
    var w1m5 = scale(w1, m5[0])
    var w2 = sum(sum(prod(m2[0], m2[0]), prod(m2[1], m2[1])), sum(prod(m2[2], m2[2]), prod(m2[3], m2[3])))
    var w2m0 = scale(w2, m0[0])
    var w2m1 = scale(w2, m1[0])
    var w2m3 = scale(w2, m3[0])
    var w2m4 = scale(w2, m4[0])
    var w2m5 = scale(w2, m5[0])
    var w3 = sum(sum(prod(m3[0], m3[0]), prod(m3[1], m3[1])), sum(prod(m3[2], m3[2]), prod(m3[3], m3[3])))
    var w3m0 = scale(w3, m0[0])
    var w3m1 = scale(w3, m1[0])
    var w3m2 = scale(w3, m2[0])
    var w3m4 = scale(w3, m4[0])
    var w3m5 = scale(w3, m5[0])
    var w4 = sum(sum(prod(m4[0], m4[0]), prod(m4[1], m4[1])), sum(prod(m4[2], m4[2]), prod(m4[3], m4[3])))
    var w4m0 = scale(w4, m0[0])
    var w4m1 = scale(w4, m1[0])
    var w4m2 = scale(w4, m2[0])
    var w4m3 = scale(w4, m3[0])
    var w4m5 = scale(w4, m5[0])
    var w5 = sum(sum(prod(m5[0], m5[0]), prod(m5[1], m5[1])), sum(prod(m5[2], m5[2]), prod(m5[3], m5[3])))
    var w5m0 = scale(w5, m0[0])
    var w5m1 = scale(w5, m1[0])
    var w5m2 = scale(w5, m2[0])
    var w5m3 = scale(w5, m3[0])
    var w5m4 = scale(w5, m4[0])
    var p = sum(sum(sum(scale(sum(sum(scale(sum(scale(diff(w5m4, w4m5), m3[1]), sum(scale(diff(w5m3, w3m5), -m4[1]), scale(diff(w4m3, w3m4), m5[1]))), m2[2]), scale(sum(scale(diff(w5m4, w4m5), m2[1]), sum(scale(diff(w5m2, w2m5), -m4[1]), scale(diff(w4m2, w2m4), m5[1]))), -m3[2])), sum(scale(sum(scale(diff(w5m3, w3m5), m2[1]), sum(scale(diff(w5m2, w2m5), -m3[1]), scale(diff(w3m2, w2m3), m5[1]))), m4[2]), scale(sum(scale(diff(w4m3, w3m4), m2[1]), sum(scale(diff(w4m2, w2m4), -m3[1]), scale(diff(w3m2, w2m3), m4[1]))), -m5[2]))), m1[3]), sum(scale(sum(sum(scale(sum(scale(diff(w5m4, w4m5), m3[1]), sum(scale(diff(w5m3, w3m5), -m4[1]), scale(diff(w4m3, w3m4), m5[1]))), m1[2]), scale(sum(scale(diff(w5m4, w4m5), m1[1]), sum(scale(diff(w5m1, w1m5), -m4[1]), scale(diff(w4m1, w1m4), m5[1]))), -m3[2])), sum(scale(sum(scale(diff(w5m3, w3m5), m1[1]), sum(scale(diff(w5m1, w1m5), -m3[1]), scale(diff(w3m1, w1m3), m5[1]))), m4[2]), scale(sum(scale(diff(w4m3, w3m4), m1[1]), sum(scale(diff(w4m1, w1m4), -m3[1]), scale(diff(w3m1, w1m3), m4[1]))), -m5[2]))), -m2[3]), scale(sum(sum(scale(sum(scale(diff(w5m4, w4m5), m2[1]), sum(scale(diff(w5m2, w2m5), -m4[1]), scale(diff(w4m2, w2m4), m5[1]))), m1[2]), scale(sum(scale(diff(w5m4, w4m5), m1[1]), sum(scale(diff(w5m1, w1m5), -m4[1]), scale(diff(w4m1, w1m4), m5[1]))), -m2[2])), sum(scale(sum(scale(diff(w5m2, w2m5), m1[1]), sum(scale(diff(w5m1, w1m5), -m2[1]), scale(diff(w2m1, w1m2), m5[1]))), m4[2]), scale(sum(scale(diff(w4m2, w2m4), m1[1]), sum(scale(diff(w4m1, w1m4), -m2[1]), scale(diff(w2m1, w1m2), m4[1]))), -m5[2]))), m3[3]))), sum(sum(scale(sum(sum(scale(sum(scale(diff(w5m3, w3m5), m2[1]), sum(scale(diff(w5m2, w2m5), -m3[1]), scale(diff(w3m2, w2m3), m5[1]))), m1[2]), scale(sum(scale(diff(w5m3, w3m5), m1[1]), sum(scale(diff(w5m1, w1m5), -m3[1]), scale(diff(w3m1, w1m3), m5[1]))), -m2[2])), sum(scale(sum(scale(diff(w5m2, w2m5), m1[1]), sum(scale(diff(w5m1, w1m5), -m2[1]), scale(diff(w2m1, w1m2), m5[1]))), m3[2]), scale(sum(scale(diff(w3m2, w2m3), m1[1]), sum(scale(diff(w3m1, w1m3), -m2[1]), scale(diff(w2m1, w1m2), m3[1]))), -m5[2]))), -m4[3]), scale(sum(sum(scale(sum(scale(diff(w4m3, w3m4), m2[1]), sum(scale(diff(w4m2, w2m4), -m3[1]), scale(diff(w3m2, w2m3), m4[1]))), m1[2]), scale(sum(scale(diff(w4m3, w3m4), m1[1]), sum(scale(diff(w4m1, w1m4), -m3[1]), scale(diff(w3m1, w1m3), m4[1]))), -m2[2])), sum(scale(sum(scale(diff(w4m2, w2m4), m1[1]), sum(scale(diff(w4m1, w1m4), -m2[1]), scale(diff(w2m1, w1m2), m4[1]))), m3[2]), scale(sum(scale(diff(w3m2, w2m3), m1[1]), sum(scale(diff(w3m1, w1m3), -m2[1]), scale(diff(w2m1, w1m2), m3[1]))), -m4[2]))), m5[3])), sum(scale(sum(sum(scale(sum(scale(diff(w5m4, w4m5), m3[1]), sum(scale(diff(w5m3, w3m5), -m4[1]), scale(diff(w4m3, w3m4), m5[1]))), m1[2]), scale(sum(scale(diff(w5m4, w4m5), m1[1]), sum(scale(diff(w5m1, w1m5), -m4[1]), scale(diff(w4m1, w1m4), m5[1]))), -m3[2])), sum(scale(sum(scale(diff(w5m3, w3m5), m1[1]), sum(scale(diff(w5m1, w1m5), -m3[1]), scale(diff(w3m1, w1m3), m5[1]))), m4[2]), scale(sum(scale(diff(w4m3, w3m4), m1[1]), sum(scale(diff(w4m1, w1m4), -m3[1]), scale(diff(w3m1, w1m3), m4[1]))), -m5[2]))), m0[3]), scale(sum(sum(scale(sum(scale(diff(w5m4, w4m5), m3[1]), sum(scale(diff(w5m3, w3m5), -m4[1]), scale(diff(w4m3, w3m4), m5[1]))), m0[2]), scale(sum(scale(diff(w5m4, w4m5), m0[1]), sum(scale(diff(w5m0, w0m5), -m4[1]), scale(diff(w4m0, w0m4), m5[1]))), -m3[2])), sum(scale(sum(scale(diff(w5m3, w3m5), m0[1]), sum(scale(diff(w5m0, w0m5), -m3[1]), scale(diff(w3m0, w0m3), m5[1]))), m4[2]), scale(sum(scale(diff(w4m3, w3m4), m0[1]), sum(scale(diff(w4m0, w0m4), -m3[1]), scale(diff(w3m0, w0m3), m4[1]))), -m5[2]))), -m1[3])))), sum(sum(sum(scale(sum(sum(scale(sum(scale(diff(w5m4, w4m5), m1[1]), sum(scale(diff(w5m1, w1m5), -m4[1]), scale(diff(w4m1, w1m4), m5[1]))), m0[2]), scale(sum(scale(diff(w5m4, w4m5), m0[1]), sum(scale(diff(w5m0, w0m5), -m4[1]), scale(diff(w4m0, w0m4), m5[1]))), -m1[2])), sum(scale(sum(scale(diff(w5m1, w1m5), m0[1]), sum(scale(diff(w5m0, w0m5), -m1[1]), scale(diff(w1m0, w0m1), m5[1]))), m4[2]), scale(sum(scale(diff(w4m1, w1m4), m0[1]), sum(scale(diff(w4m0, w0m4), -m1[1]), scale(diff(w1m0, w0m1), m4[1]))), -m5[2]))), m3[3]), scale(sum(sum(scale(sum(scale(diff(w5m3, w3m5), m1[1]), sum(scale(diff(w5m1, w1m5), -m3[1]), scale(diff(w3m1, w1m3), m5[1]))), m0[2]), scale(sum(scale(diff(w5m3, w3m5), m0[1]), sum(scale(diff(w5m0, w0m5), -m3[1]), scale(diff(w3m0, w0m3), m5[1]))), -m1[2])), sum(scale(sum(scale(diff(w5m1, w1m5), m0[1]), sum(scale(diff(w5m0, w0m5), -m1[1]), scale(diff(w1m0, w0m1), m5[1]))), m3[2]), scale(sum(scale(diff(w3m1, w1m3), m0[1]), sum(scale(diff(w3m0, w0m3), -m1[1]), scale(diff(w1m0, w0m1), m3[1]))), -m5[2]))), -m4[3])), sum(scale(sum(sum(scale(sum(scale(diff(w4m3, w3m4), m1[1]), sum(scale(diff(w4m1, w1m4), -m3[1]), scale(diff(w3m1, w1m3), m4[1]))), m0[2]), scale(sum(scale(diff(w4m3, w3m4), m0[1]), sum(scale(diff(w4m0, w0m4), -m3[1]), scale(diff(w3m0, w0m3), m4[1]))), -m1[2])), sum(scale(sum(scale(diff(w4m1, w1m4), m0[1]), sum(scale(diff(w4m0, w0m4), -m1[1]), scale(diff(w1m0, w0m1), m4[1]))), m3[2]), scale(sum(scale(diff(w3m1, w1m3), m0[1]), sum(scale(diff(w3m0, w0m3), -m1[1]), scale(diff(w1m0, w0m1), m3[1]))), -m4[2]))), m5[3]), scale(sum(sum(scale(sum(scale(diff(w5m3, w3m5), m2[1]), sum(scale(diff(w5m2, w2m5), -m3[1]), scale(diff(w3m2, w2m3), m5[1]))), m1[2]), scale(sum(scale(diff(w5m3, w3m5), m1[1]), sum(scale(diff(w5m1, w1m5), -m3[1]), scale(diff(w3m1, w1m3), m5[1]))), -m2[2])), sum(scale(sum(scale(diff(w5m2, w2m5), m1[1]), sum(scale(diff(w5m1, w1m5), -m2[1]), scale(diff(w2m1, w1m2), m5[1]))), m3[2]), scale(sum(scale(diff(w3m2, w2m3), m1[1]), sum(scale(diff(w3m1, w1m3), -m2[1]), scale(diff(w2m1, w1m2), m3[1]))), -m5[2]))), m0[3]))), sum(sum(scale(sum(sum(scale(sum(scale(diff(w5m3, w3m5), m2[1]), sum(scale(diff(w5m2, w2m5), -m3[1]), scale(diff(w3m2, w2m3), m5[1]))), m0[2]), scale(sum(scale(diff(w5m3, w3m5), m0[1]), sum(scale(diff(w5m0, w0m5), -m3[1]), scale(diff(w3m0, w0m3), m5[1]))), -m2[2])), sum(scale(sum(scale(diff(w5m2, w2m5), m0[1]), sum(scale(diff(w5m0, w0m5), -m2[1]), scale(diff(w2m0, w0m2), m5[1]))), m3[2]), scale(sum(scale(diff(w3m2, w2m3), m0[1]), sum(scale(diff(w3m0, w0m3), -m2[1]), scale(diff(w2m0, w0m2), m3[1]))), -m5[2]))), -m1[3]), scale(sum(sum(scale(sum(scale(diff(w5m3, w3m5), m1[1]), sum(scale(diff(w5m1, w1m5), -m3[1]), scale(diff(w3m1, w1m3), m5[1]))), m0[2]), scale(sum(scale(diff(w5m3, w3m5), m0[1]), sum(scale(diff(w5m0, w0m5), -m3[1]), scale(diff(w3m0, w0m3), m5[1]))), -m1[2])), sum(scale(sum(scale(diff(w5m1, w1m5), m0[1]), sum(scale(diff(w5m0, w0m5), -m1[1]), scale(diff(w1m0, w0m1), m5[1]))), m3[2]), scale(sum(scale(diff(w3m1, w1m3), m0[1]), sum(scale(diff(w3m0, w0m3), -m1[1]), scale(diff(w1m0, w0m1), m3[1]))), -m5[2]))), m2[3])), sum(scale(sum(sum(scale(sum(scale(diff(w5m2, w2m5), m1[1]), sum(scale(diff(w5m1, w1m5), -m2[1]), scale(diff(w2m1, w1m2), m5[1]))), m0[2]), scale(sum(scale(diff(w5m2, w2m5), m0[1]), sum(scale(diff(w5m0, w0m5), -m2[1]), scale(diff(w2m0, w0m2), m5[1]))), -m1[2])), sum(scale(sum(scale(diff(w5m1, w1m5), m0[1]), sum(scale(diff(w5m0, w0m5), -m1[1]), scale(diff(w1m0, w0m1), m5[1]))), m2[2]), scale(sum(scale(diff(w2m1, w1m2), m0[1]), sum(scale(diff(w2m0, w0m2), -m1[1]), scale(diff(w1m0, w0m1), m2[1]))), -m5[2]))), -m3[3]), scale(sum(sum(scale(sum(scale(diff(w3m2, w2m3), m1[1]), sum(scale(diff(w3m1, w1m3), -m2[1]), scale(diff(w2m1, w1m2), m3[1]))), m0[2]), scale(sum(scale(diff(w3m2, w2m3), m0[1]), sum(scale(diff(w3m0, w0m3), -m2[1]), scale(diff(w2m0, w0m2), m3[1]))), -m1[2])), sum(scale(sum(scale(diff(w3m1, w1m3), m0[1]), sum(scale(diff(w3m0, w0m3), -m1[1]), scale(diff(w1m0, w0m1), m3[1]))), m2[2]), scale(sum(scale(diff(w2m1, w1m2), m0[1]), sum(scale(diff(w2m0, w0m2), -m1[1]), scale(diff(w1m0, w0m1), m2[1]))), -m3[2]))), m5[3])))))
    var n = sum(sum(sum(scale(sum(sum(scale(sum(scale(diff(w5m4, w4m5), m3[1]), sum(scale(diff(w5m3, w3m5), -m4[1]), scale(diff(w4m3, w3m4), m5[1]))), m2[2]), scale(sum(scale(diff(w5m4, w4m5), m2[1]), sum(scale(diff(w5m2, w2m5), -m4[1]), scale(diff(w4m2, w2m4), m5[1]))), -m3[2])), sum(scale(sum(scale(diff(w5m3, w3m5), m2[1]), sum(scale(diff(w5m2, w2m5), -m3[1]), scale(diff(w3m2, w2m3), m5[1]))), m4[2]), scale(sum(scale(diff(w4m3, w3m4), m2[1]), sum(scale(diff(w4m2, w2m4), -m3[1]), scale(diff(w3m2, w2m3), m4[1]))), -m5[2]))), m0[3]), sum(scale(sum(sum(scale(sum(scale(diff(w5m4, w4m5), m3[1]), sum(scale(diff(w5m3, w3m5), -m4[1]), scale(diff(w4m3, w3m4), m5[1]))), m0[2]), scale(sum(scale(diff(w5m4, w4m5), m0[1]), sum(scale(diff(w5m0, w0m5), -m4[1]), scale(diff(w4m0, w0m4), m5[1]))), -m3[2])), sum(scale(sum(scale(diff(w5m3, w3m5), m0[1]), sum(scale(diff(w5m0, w0m5), -m3[1]), scale(diff(w3m0, w0m3), m5[1]))), m4[2]), scale(sum(scale(diff(w4m3, w3m4), m0[1]), sum(scale(diff(w4m0, w0m4), -m3[1]), scale(diff(w3m0, w0m3), m4[1]))), -m5[2]))), -m2[3]), scale(sum(sum(scale(sum(scale(diff(w5m4, w4m5), m2[1]), sum(scale(diff(w5m2, w2m5), -m4[1]), scale(diff(w4m2, w2m4), m5[1]))), m0[2]), scale(sum(scale(diff(w5m4, w4m5), m0[1]), sum(scale(diff(w5m0, w0m5), -m4[1]), scale(diff(w4m0, w0m4), m5[1]))), -m2[2])), sum(scale(sum(scale(diff(w5m2, w2m5), m0[1]), sum(scale(diff(w5m0, w0m5), -m2[1]), scale(diff(w2m0, w0m2), m5[1]))), m4[2]), scale(sum(scale(diff(w4m2, w2m4), m0[1]), sum(scale(diff(w4m0, w0m4), -m2[1]), scale(diff(w2m0, w0m2), m4[1]))), -m5[2]))), m3[3]))), sum(sum(scale(sum(sum(scale(sum(scale(diff(w5m3, w3m5), m2[1]), sum(scale(diff(w5m2, w2m5), -m3[1]), scale(diff(w3m2, w2m3), m5[1]))), m0[2]), scale(sum(scale(diff(w5m3, w3m5), m0[1]), sum(scale(diff(w5m0, w0m5), -m3[1]), scale(diff(w3m0, w0m3), m5[1]))), -m2[2])), sum(scale(sum(scale(diff(w5m2, w2m5), m0[1]), sum(scale(diff(w5m0, w0m5), -m2[1]), scale(diff(w2m0, w0m2), m5[1]))), m3[2]), scale(sum(scale(diff(w3m2, w2m3), m0[1]), sum(scale(diff(w3m0, w0m3), -m2[1]), scale(diff(w2m0, w0m2), m3[1]))), -m5[2]))), -m4[3]), scale(sum(sum(scale(sum(scale(diff(w4m3, w3m4), m2[1]), sum(scale(diff(w4m2, w2m4), -m3[1]), scale(diff(w3m2, w2m3), m4[1]))), m0[2]), scale(sum(scale(diff(w4m3, w3m4), m0[1]), sum(scale(diff(w4m0, w0m4), -m3[1]), scale(diff(w3m0, w0m3), m4[1]))), -m2[2])), sum(scale(sum(scale(diff(w4m2, w2m4), m0[1]), sum(scale(diff(w4m0, w0m4), -m2[1]), scale(diff(w2m0, w0m2), m4[1]))), m3[2]), scale(sum(scale(diff(w3m2, w2m3), m0[1]), sum(scale(diff(w3m0, w0m3), -m2[1]), scale(diff(w2m0, w0m2), m3[1]))), -m4[2]))), m5[3])), sum(scale(sum(sum(scale(sum(scale(diff(w5m4, w4m5), m2[1]), sum(scale(diff(w5m2, w2m5), -m4[1]), scale(diff(w4m2, w2m4), m5[1]))), m1[2]), scale(sum(scale(diff(w5m4, w4m5), m1[1]), sum(scale(diff(w5m1, w1m5), -m4[1]), scale(diff(w4m1, w1m4), m5[1]))), -m2[2])), sum(scale(sum(scale(diff(w5m2, w2m5), m1[1]), sum(scale(diff(w5m1, w1m5), -m2[1]), scale(diff(w2m1, w1m2), m5[1]))), m4[2]), scale(sum(scale(diff(w4m2, w2m4), m1[1]), sum(scale(diff(w4m1, w1m4), -m2[1]), scale(diff(w2m1, w1m2), m4[1]))), -m5[2]))), m0[3]), scale(sum(sum(scale(sum(scale(diff(w5m4, w4m5), m2[1]), sum(scale(diff(w5m2, w2m5), -m4[1]), scale(diff(w4m2, w2m4), m5[1]))), m0[2]), scale(sum(scale(diff(w5m4, w4m5), m0[1]), sum(scale(diff(w5m0, w0m5), -m4[1]), scale(diff(w4m0, w0m4), m5[1]))), -m2[2])), sum(scale(sum(scale(diff(w5m2, w2m5), m0[1]), sum(scale(diff(w5m0, w0m5), -m2[1]), scale(diff(w2m0, w0m2), m5[1]))), m4[2]), scale(sum(scale(diff(w4m2, w2m4), m0[1]), sum(scale(diff(w4m0, w0m4), -m2[1]), scale(diff(w2m0, w0m2), m4[1]))), -m5[2]))), -m1[3])))), sum(sum(sum(scale(sum(sum(scale(sum(scale(diff(w5m4, w4m5), m1[1]), sum(scale(diff(w5m1, w1m5), -m4[1]), scale(diff(w4m1, w1m4), m5[1]))), m0[2]), scale(sum(scale(diff(w5m4, w4m5), m0[1]), sum(scale(diff(w5m0, w0m5), -m4[1]), scale(diff(w4m0, w0m4), m5[1]))), -m1[2])), sum(scale(sum(scale(diff(w5m1, w1m5), m0[1]), sum(scale(diff(w5m0, w0m5), -m1[1]), scale(diff(w1m0, w0m1), m5[1]))), m4[2]), scale(sum(scale(diff(w4m1, w1m4), m0[1]), sum(scale(diff(w4m0, w0m4), -m1[1]), scale(diff(w1m0, w0m1), m4[1]))), -m5[2]))), m2[3]), scale(sum(sum(scale(sum(scale(diff(w5m2, w2m5), m1[1]), sum(scale(diff(w5m1, w1m5), -m2[1]), scale(diff(w2m1, w1m2), m5[1]))), m0[2]), scale(sum(scale(diff(w5m2, w2m5), m0[1]), sum(scale(diff(w5m0, w0m5), -m2[1]), scale(diff(w2m0, w0m2), m5[1]))), -m1[2])), sum(scale(sum(scale(diff(w5m1, w1m5), m0[1]), sum(scale(diff(w5m0, w0m5), -m1[1]), scale(diff(w1m0, w0m1), m5[1]))), m2[2]), scale(sum(scale(diff(w2m1, w1m2), m0[1]), sum(scale(diff(w2m0, w0m2), -m1[1]), scale(diff(w1m0, w0m1), m2[1]))), -m5[2]))), -m4[3])), sum(scale(sum(sum(scale(sum(scale(diff(w4m2, w2m4), m1[1]), sum(scale(diff(w4m1, w1m4), -m2[1]), scale(diff(w2m1, w1m2), m4[1]))), m0[2]), scale(sum(scale(diff(w4m2, w2m4), m0[1]), sum(scale(diff(w4m0, w0m4), -m2[1]), scale(diff(w2m0, w0m2), m4[1]))), -m1[2])), sum(scale(sum(scale(diff(w4m1, w1m4), m0[1]), sum(scale(diff(w4m0, w0m4), -m1[1]), scale(diff(w1m0, w0m1), m4[1]))), m2[2]), scale(sum(scale(diff(w2m1, w1m2), m0[1]), sum(scale(diff(w2m0, w0m2), -m1[1]), scale(diff(w1m0, w0m1), m2[1]))), -m4[2]))), m5[3]), scale(sum(sum(scale(sum(scale(diff(w4m3, w3m4), m2[1]), sum(scale(diff(w4m2, w2m4), -m3[1]), scale(diff(w3m2, w2m3), m4[1]))), m1[2]), scale(sum(scale(diff(w4m3, w3m4), m1[1]), sum(scale(diff(w4m1, w1m4), -m3[1]), scale(diff(w3m1, w1m3), m4[1]))), -m2[2])), sum(scale(sum(scale(diff(w4m2, w2m4), m1[1]), sum(scale(diff(w4m1, w1m4), -m2[1]), scale(diff(w2m1, w1m2), m4[1]))), m3[2]), scale(sum(scale(diff(w3m2, w2m3), m1[1]), sum(scale(diff(w3m1, w1m3), -m2[1]), scale(diff(w2m1, w1m2), m3[1]))), -m4[2]))), m0[3]))), sum(sum(scale(sum(sum(scale(sum(scale(diff(w4m3, w3m4), m2[1]), sum(scale(diff(w4m2, w2m4), -m3[1]), scale(diff(w3m2, w2m3), m4[1]))), m0[2]), scale(sum(scale(diff(w4m3, w3m4), m0[1]), sum(scale(diff(w4m0, w0m4), -m3[1]), scale(diff(w3m0, w0m3), m4[1]))), -m2[2])), sum(scale(sum(scale(diff(w4m2, w2m4), m0[1]), sum(scale(diff(w4m0, w0m4), -m2[1]), scale(diff(w2m0, w0m2), m4[1]))), m3[2]), scale(sum(scale(diff(w3m2, w2m3), m0[1]), sum(scale(diff(w3m0, w0m3), -m2[1]), scale(diff(w2m0, w0m2), m3[1]))), -m4[2]))), -m1[3]), scale(sum(sum(scale(sum(scale(diff(w4m3, w3m4), m1[1]), sum(scale(diff(w4m1, w1m4), -m3[1]), scale(diff(w3m1, w1m3), m4[1]))), m0[2]), scale(sum(scale(diff(w4m3, w3m4), m0[1]), sum(scale(diff(w4m0, w0m4), -m3[1]), scale(diff(w3m0, w0m3), m4[1]))), -m1[2])), sum(scale(sum(scale(diff(w4m1, w1m4), m0[1]), sum(scale(diff(w4m0, w0m4), -m1[1]), scale(diff(w1m0, w0m1), m4[1]))), m3[2]), scale(sum(scale(diff(w3m1, w1m3), m0[1]), sum(scale(diff(w3m0, w0m3), -m1[1]), scale(diff(w1m0, w0m1), m3[1]))), -m4[2]))), m2[3])), sum(scale(sum(sum(scale(sum(scale(diff(w4m2, w2m4), m1[1]), sum(scale(diff(w4m1, w1m4), -m2[1]), scale(diff(w2m1, w1m2), m4[1]))), m0[2]), scale(sum(scale(diff(w4m2, w2m4), m0[1]), sum(scale(diff(w4m0, w0m4), -m2[1]), scale(diff(w2m0, w0m2), m4[1]))), -m1[2])), sum(scale(sum(scale(diff(w4m1, w1m4), m0[1]), sum(scale(diff(w4m0, w0m4), -m1[1]), scale(diff(w1m0, w0m1), m4[1]))), m2[2]), scale(sum(scale(diff(w2m1, w1m2), m0[1]), sum(scale(diff(w2m0, w0m2), -m1[1]), scale(diff(w1m0, w0m1), m2[1]))), -m4[2]))), -m3[3]), scale(sum(sum(scale(sum(scale(diff(w3m2, w2m3), m1[1]), sum(scale(diff(w3m1, w1m3), -m2[1]), scale(diff(w2m1, w1m2), m3[1]))), m0[2]), scale(sum(scale(diff(w3m2, w2m3), m0[1]), sum(scale(diff(w3m0, w0m3), -m2[1]), scale(diff(w2m0, w0m2), m3[1]))), -m1[2])), sum(scale(sum(scale(diff(w3m1, w1m3), m0[1]), sum(scale(diff(w3m0, w0m3), -m1[1]), scale(diff(w1m0, w0m1), m3[1]))), m2[2]), scale(sum(scale(diff(w2m1, w1m2), m0[1]), sum(scale(diff(w2m0, w0m2), -m1[1]), scale(diff(w1m0, w0m1), m2[1]))), -m3[2]))), m4[3])))))
    var d = diff(p, n)
    return d[d.length - 1]
  }
  return exactInSphere6
}

var CACHED = [
  inSphere0,
  inSphere1,
  inSphere2
]

function slowInSphere(args) {
  var proc = CACHED[args.length]
  if(!proc) {
    proc = CACHED[args.length] = orientation(args.length)
  }
  return proc.apply(undefined, args)
}

function proc(slow, o0, o1, o2, o3, o4, o5, o6) {
  function testInSphere(a0, a1, a2, a3, a4, a5) {
    switch (arguments.length) {
      case 0:
      case 1:
        return 0;
      case 2:
        return o2(a0, a1)
      case 3:
        return o3(a0, a1, a2)
      case 4:
        return o4(a0, a1, a2, a3)
      case 5:
        return o5(a0, a1, a2, a3, a4)
      case 6:
        return o6(a0, a1, a2, a3, a4, a5)
    }

    var s = new Array(arguments.length)
    for (var i = 0; i < arguments.length; ++i) {
      s[i] = arguments[i]
    }
    return slow(s)
  }
  return testInSphere
}

function generateInSphereTest() {
  while(CACHED.length <= NUM_EXPAND) {
    CACHED.push(orientation(CACHED.length))
  }

  module.exports = proc.apply(undefined, [slowInSphere].concat(CACHED))
  for(var i=0; i<=NUM_EXPAND; ++i) {
    module.exports[i] = CACHED[i]
  }
}

generateInSphereTest()
},{"robust-scale":107,"robust-subtract":109,"robust-sum":110,"two-product":178}],105:[function(require,module,exports){
"use strict"

var twoProduct = require("two-product")
var robustSum = require("robust-sum")
var robustScale = require("robust-scale")
var robustSubtract = require("robust-subtract")

var NUM_EXPAND = 5

var EPSILON     = 1.1102230246251565e-16
var ERRBOUND3   = (3.0 + 16.0 * EPSILON) * EPSILON
var ERRBOUND4   = (7.0 + 56.0 * EPSILON) * EPSILON

function orientation_3(sum, prod, scale, sub) {
  return function orientation3Exact(m0, m1, m2) {
    var p = sum(sum(prod(m1[1], m2[0]), prod(-m2[1], m1[0])), sum(prod(m0[1], m1[0]), prod(-m1[1], m0[0])))
    var n = sum(prod(m0[1], m2[0]), prod(-m2[1], m0[0]))
    var d = sub(p, n)
    return d[d.length - 1]
  }
}

function orientation_4(sum, prod, scale, sub) {
  return function orientation4Exact(m0, m1, m2, m3) {
    var p = sum(sum(scale(sum(prod(m2[1], m3[0]), prod(-m3[1], m2[0])), m1[2]), sum(scale(sum(prod(m1[1], m3[0]), prod(-m3[1], m1[0])), -m2[2]), scale(sum(prod(m1[1], m2[0]), prod(-m2[1], m1[0])), m3[2]))), sum(scale(sum(prod(m1[1], m3[0]), prod(-m3[1], m1[0])), m0[2]), sum(scale(sum(prod(m0[1], m3[0]), prod(-m3[1], m0[0])), -m1[2]), scale(sum(prod(m0[1], m1[0]), prod(-m1[1], m0[0])), m3[2]))))
    var n = sum(sum(scale(sum(prod(m2[1], m3[0]), prod(-m3[1], m2[0])), m0[2]), sum(scale(sum(prod(m0[1], m3[0]), prod(-m3[1], m0[0])), -m2[2]), scale(sum(prod(m0[1], m2[0]), prod(-m2[1], m0[0])), m3[2]))), sum(scale(sum(prod(m1[1], m2[0]), prod(-m2[1], m1[0])), m0[2]), sum(scale(sum(prod(m0[1], m2[0]), prod(-m2[1], m0[0])), -m1[2]), scale(sum(prod(m0[1], m1[0]), prod(-m1[1], m0[0])), m2[2]))))
    var d = sub(p, n)
    return d[d.length - 1]
  }
}

function orientation_5(sum, prod, scale, sub) {
  return function orientation5Exact(m0, m1, m2, m3, m4) {
    var p = sum(sum(sum(scale(sum(scale(sum(prod(m3[1], m4[0]), prod(-m4[1], m3[0])), m2[2]), sum(scale(sum(prod(m2[1], m4[0]), prod(-m4[1], m2[0])), -m3[2]), scale(sum(prod(m2[1], m3[0]), prod(-m3[1], m2[0])), m4[2]))), m1[3]), sum(scale(sum(scale(sum(prod(m3[1], m4[0]), prod(-m4[1], m3[0])), m1[2]), sum(scale(sum(prod(m1[1], m4[0]), prod(-m4[1], m1[0])), -m3[2]), scale(sum(prod(m1[1], m3[0]), prod(-m3[1], m1[0])), m4[2]))), -m2[3]), scale(sum(scale(sum(prod(m2[1], m4[0]), prod(-m4[1], m2[0])), m1[2]), sum(scale(sum(prod(m1[1], m4[0]), prod(-m4[1], m1[0])), -m2[2]), scale(sum(prod(m1[1], m2[0]), prod(-m2[1], m1[0])), m4[2]))), m3[3]))), sum(scale(sum(scale(sum(prod(m2[1], m3[0]), prod(-m3[1], m2[0])), m1[2]), sum(scale(sum(prod(m1[1], m3[0]), prod(-m3[1], m1[0])), -m2[2]), scale(sum(prod(m1[1], m2[0]), prod(-m2[1], m1[0])), m3[2]))), -m4[3]), sum(scale(sum(scale(sum(prod(m3[1], m4[0]), prod(-m4[1], m3[0])), m1[2]), sum(scale(sum(prod(m1[1], m4[0]), prod(-m4[1], m1[0])), -m3[2]), scale(sum(prod(m1[1], m3[0]), prod(-m3[1], m1[0])), m4[2]))), m0[3]), scale(sum(scale(sum(prod(m3[1], m4[0]), prod(-m4[1], m3[0])), m0[2]), sum(scale(sum(prod(m0[1], m4[0]), prod(-m4[1], m0[0])), -m3[2]), scale(sum(prod(m0[1], m3[0]), prod(-m3[1], m0[0])), m4[2]))), -m1[3])))), sum(sum(scale(sum(scale(sum(prod(m1[1], m4[0]), prod(-m4[1], m1[0])), m0[2]), sum(scale(sum(prod(m0[1], m4[0]), prod(-m4[1], m0[0])), -m1[2]), scale(sum(prod(m0[1], m1[0]), prod(-m1[1], m0[0])), m4[2]))), m3[3]), sum(scale(sum(scale(sum(prod(m1[1], m3[0]), prod(-m3[1], m1[0])), m0[2]), sum(scale(sum(prod(m0[1], m3[0]), prod(-m3[1], m0[0])), -m1[2]), scale(sum(prod(m0[1], m1[0]), prod(-m1[1], m0[0])), m3[2]))), -m4[3]), scale(sum(scale(sum(prod(m2[1], m3[0]), prod(-m3[1], m2[0])), m1[2]), sum(scale(sum(prod(m1[1], m3[0]), prod(-m3[1], m1[0])), -m2[2]), scale(sum(prod(m1[1], m2[0]), prod(-m2[1], m1[0])), m3[2]))), m0[3]))), sum(scale(sum(scale(sum(prod(m2[1], m3[0]), prod(-m3[1], m2[0])), m0[2]), sum(scale(sum(prod(m0[1], m3[0]), prod(-m3[1], m0[0])), -m2[2]), scale(sum(prod(m0[1], m2[0]), prod(-m2[1], m0[0])), m3[2]))), -m1[3]), sum(scale(sum(scale(sum(prod(m1[1], m3[0]), prod(-m3[1], m1[0])), m0[2]), sum(scale(sum(prod(m0[1], m3[0]), prod(-m3[1], m0[0])), -m1[2]), scale(sum(prod(m0[1], m1[0]), prod(-m1[1], m0[0])), m3[2]))), m2[3]), scale(sum(scale(sum(prod(m1[1], m2[0]), prod(-m2[1], m1[0])), m0[2]), sum(scale(sum(prod(m0[1], m2[0]), prod(-m2[1], m0[0])), -m1[2]), scale(sum(prod(m0[1], m1[0]), prod(-m1[1], m0[0])), m2[2]))), -m3[3])))))
    var n = sum(sum(sum(scale(sum(scale(sum(prod(m3[1], m4[0]), prod(-m4[1], m3[0])), m2[2]), sum(scale(sum(prod(m2[1], m4[0]), prod(-m4[1], m2[0])), -m3[2]), scale(sum(prod(m2[1], m3[0]), prod(-m3[1], m2[0])), m4[2]))), m0[3]), scale(sum(scale(sum(prod(m3[1], m4[0]), prod(-m4[1], m3[0])), m0[2]), sum(scale(sum(prod(m0[1], m4[0]), prod(-m4[1], m0[0])), -m3[2]), scale(sum(prod(m0[1], m3[0]), prod(-m3[1], m0[0])), m4[2]))), -m2[3])), sum(scale(sum(scale(sum(prod(m2[1], m4[0]), prod(-m4[1], m2[0])), m0[2]), sum(scale(sum(prod(m0[1], m4[0]), prod(-m4[1], m0[0])), -m2[2]), scale(sum(prod(m0[1], m2[0]), prod(-m2[1], m0[0])), m4[2]))), m3[3]), scale(sum(scale(sum(prod(m2[1], m3[0]), prod(-m3[1], m2[0])), m0[2]), sum(scale(sum(prod(m0[1], m3[0]), prod(-m3[1], m0[0])), -m2[2]), scale(sum(prod(m0[1], m2[0]), prod(-m2[1], m0[0])), m3[2]))), -m4[3]))), sum(sum(scale(sum(scale(sum(prod(m2[1], m4[0]), prod(-m4[1], m2[0])), m1[2]), sum(scale(sum(prod(m1[1], m4[0]), prod(-m4[1], m1[0])), -m2[2]), scale(sum(prod(m1[1], m2[0]), prod(-m2[1], m1[0])), m4[2]))), m0[3]), scale(sum(scale(sum(prod(m2[1], m4[0]), prod(-m4[1], m2[0])), m0[2]), sum(scale(sum(prod(m0[1], m4[0]), prod(-m4[1], m0[0])), -m2[2]), scale(sum(prod(m0[1], m2[0]), prod(-m2[1], m0[0])), m4[2]))), -m1[3])), sum(scale(sum(scale(sum(prod(m1[1], m4[0]), prod(-m4[1], m1[0])), m0[2]), sum(scale(sum(prod(m0[1], m4[0]), prod(-m4[1], m0[0])), -m1[2]), scale(sum(prod(m0[1], m1[0]), prod(-m1[1], m0[0])), m4[2]))), m2[3]), scale(sum(scale(sum(prod(m1[1], m2[0]), prod(-m2[1], m1[0])), m0[2]), sum(scale(sum(prod(m0[1], m2[0]), prod(-m2[1], m0[0])), -m1[2]), scale(sum(prod(m0[1], m1[0]), prod(-m1[1], m0[0])), m2[2]))), -m4[3]))))
    var d = sub(p, n)
    return d[d.length - 1]
  }
}

function orientation(n) {
  var fn =
    n === 3 ? orientation_3 :
    n === 4 ? orientation_4 : orientation_5

  return fn(robustSum, twoProduct, robustScale, robustSubtract)
}

var orientation3Exact = orientation(3)
var orientation4Exact = orientation(4)

var CACHED = [
  function orientation0() { return 0 },
  function orientation1() { return 0 },
  function orientation2(a, b) {
    return b[0] - a[0]
  },
  function orientation3(a, b, c) {
    var l = (a[1] - c[1]) * (b[0] - c[0])
    var r = (a[0] - c[0]) * (b[1] - c[1])
    var det = l - r
    var s
    if(l > 0) {
      if(r <= 0) {
        return det
      } else {
        s = l + r
      }
    } else if(l < 0) {
      if(r >= 0) {
        return det
      } else {
        s = -(l + r)
      }
    } else {
      return det
    }
    var tol = ERRBOUND3 * s
    if(det >= tol || det <= -tol) {
      return det
    }
    return orientation3Exact(a, b, c)
  },
  function orientation4(a,b,c,d) {
    var adx = a[0] - d[0]
    var bdx = b[0] - d[0]
    var cdx = c[0] - d[0]
    var ady = a[1] - d[1]
    var bdy = b[1] - d[1]
    var cdy = c[1] - d[1]
    var adz = a[2] - d[2]
    var bdz = b[2] - d[2]
    var cdz = c[2] - d[2]
    var bdxcdy = bdx * cdy
    var cdxbdy = cdx * bdy
    var cdxady = cdx * ady
    var adxcdy = adx * cdy
    var adxbdy = adx * bdy
    var bdxady = bdx * ady
    var det = adz * (bdxcdy - cdxbdy)
            + bdz * (cdxady - adxcdy)
            + cdz * (adxbdy - bdxady)
    var permanent = (Math.abs(bdxcdy) + Math.abs(cdxbdy)) * Math.abs(adz)
                  + (Math.abs(cdxady) + Math.abs(adxcdy)) * Math.abs(bdz)
                  + (Math.abs(adxbdy) + Math.abs(bdxady)) * Math.abs(cdz)
    var tol = ERRBOUND4 * permanent
    if ((det > tol) || (-det > tol)) {
      return det
    }
    return orientation4Exact(a,b,c,d)
  }
]

function slowOrient(args) {
  var proc = CACHED[args.length]
  if(!proc) {
    proc = CACHED[args.length] = orientation(args.length)
  }
  return proc.apply(undefined, args)
}

function proc (slow, o0, o1, o2, o3, o4, o5) {
  return function getOrientation(a0, a1, a2, a3, a4) {
    switch (arguments.length) {
      case 0:
      case 1:
        return 0;
      case 2:
        return o2(a0, a1)
      case 3:
        return o3(a0, a1, a2)
      case 4:
        return o4(a0, a1, a2, a3)
      case 5:
        return o5(a0, a1, a2, a3, a4)
    }

    var s = new Array(arguments.length)
    for (var i = 0; i < arguments.length; ++i) {
      s[i] = arguments[i]
    }
    return slow(s)
  }
}

function generateOrientationProc() {
  while(CACHED.length <= NUM_EXPAND) {
    CACHED.push(orientation(CACHED.length))
  }
  module.exports = proc.apply(undefined, [slowOrient].concat(CACHED))
  for(var i=0; i<=NUM_EXPAND; ++i) {
    module.exports[i] = CACHED[i]
  }
}

generateOrientationProc()
},{"robust-scale":107,"robust-subtract":109,"robust-sum":110,"two-product":178}],106:[function(require,module,exports){
"use strict"

var robustSum = require("robust-sum")
var robustScale = require("robust-scale")

module.exports = robustProduct

function robustProduct(a, b) {
  if(a.length === 1) {
    return robustScale(b, a[0])
  }
  if(b.length === 1) {
    return robustScale(a, b[0])
  }
  if(a.length === 0 || b.length === 0) {
    return [0]
  }
  var r = [0]
  if(a.length < b.length) {
    for(var i=0; i<a.length; ++i) {
      r = robustSum(r, robustScale(b, a[i]))
    }
  } else {
    for(var i=0; i<b.length; ++i) {
      r = robustSum(r, robustScale(a, b[i]))
    }    
  }
  return r
}
},{"robust-scale":107,"robust-sum":110}],107:[function(require,module,exports){
"use strict"

var twoProduct = require("two-product")
var twoSum = require("two-sum")

module.exports = scaleLinearExpansion

function scaleLinearExpansion(e, scale) {
  var n = e.length
  if(n === 1) {
    var ts = twoProduct(e[0], scale)
    if(ts[0]) {
      return ts
    }
    return [ ts[1] ]
  }
  var g = new Array(2 * n)
  var q = [0.1, 0.1]
  var t = [0.1, 0.1]
  var count = 0
  twoProduct(e[0], scale, q)
  if(q[0]) {
    g[count++] = q[0]
  }
  for(var i=1; i<n; ++i) {
    twoProduct(e[i], scale, t)
    var pq = q[1]
    twoSum(pq, t[0], q)
    if(q[0]) {
      g[count++] = q[0]
    }
    var a = t[1]
    var b = q[1]
    var x = a + b
    var bv = x - a
    var y = b - bv
    q[1] = x
    if(y) {
      g[count++] = y
    }
  }
  if(q[1]) {
    g[count++] = q[1]
  }
  if(count === 0) {
    g[count++] = 0.0
  }
  g.length = count
  return g
}
},{"two-product":178,"two-sum":179}],108:[function(require,module,exports){
"use strict"

module.exports = segmentsIntersect

var orient = require("robust-orientation")[3]

function checkCollinear(a0, a1, b0, b1) {

  for(var d=0; d<2; ++d) {
    var x0 = a0[d]
    var y0 = a1[d]
    var l0 = Math.min(x0, y0)
    var h0 = Math.max(x0, y0)    

    var x1 = b0[d]
    var y1 = b1[d]
    var l1 = Math.min(x1, y1)
    var h1 = Math.max(x1, y1)    

    if(h1 < l0 || h0 < l1) {
      return false
    }
  }

  return true
}

function segmentsIntersect(a0, a1, b0, b1) {
  var x0 = orient(a0, b0, b1)
  var y0 = orient(a1, b0, b1)
  if((x0 > 0 && y0 > 0) || (x0 < 0 && y0 < 0)) {
    return false
  }

  var x1 = orient(b0, a0, a1)
  var y1 = orient(b1, a0, a1)
  if((x1 > 0 && y1 > 0) || (x1 < 0 && y1 < 0)) {
    return false
  }

  //Check for degenerate collinear case
  if(x0 === 0 && y0 === 0 && x1 === 0 && y1 === 0) {
    return checkCollinear(a0, a1, b0, b1)
  }

  return true
}
},{"robust-orientation":105}],109:[function(require,module,exports){
"use strict"

module.exports = robustSubtract

//Easy case: Add two scalars
function scalarScalar(a, b) {
  var x = a + b
  var bv = x - a
  var av = x - bv
  var br = b - bv
  var ar = a - av
  var y = ar + br
  if(y) {
    return [y, x]
  }
  return [x]
}

function robustSubtract(e, f) {
  var ne = e.length|0
  var nf = f.length|0
  if(ne === 1 && nf === 1) {
    return scalarScalar(e[0], -f[0])
  }
  var n = ne + nf
  var g = new Array(n)
  var count = 0
  var eptr = 0
  var fptr = 0
  var abs = Math.abs
  var ei = e[eptr]
  var ea = abs(ei)
  var fi = -f[fptr]
  var fa = abs(fi)
  var a, b
  if(ea < fa) {
    b = ei
    eptr += 1
    if(eptr < ne) {
      ei = e[eptr]
      ea = abs(ei)
    }
  } else {
    b = fi
    fptr += 1
    if(fptr < nf) {
      fi = -f[fptr]
      fa = abs(fi)
    }
  }
  if((eptr < ne && ea < fa) || (fptr >= nf)) {
    a = ei
    eptr += 1
    if(eptr < ne) {
      ei = e[eptr]
      ea = abs(ei)
    }
  } else {
    a = fi
    fptr += 1
    if(fptr < nf) {
      fi = -f[fptr]
      fa = abs(fi)
    }
  }
  var x = a + b
  var bv = x - a
  var y = b - bv
  var q0 = y
  var q1 = x
  var _x, _bv, _av, _br, _ar
  while(eptr < ne && fptr < nf) {
    if(ea < fa) {
      a = ei
      eptr += 1
      if(eptr < ne) {
        ei = e[eptr]
        ea = abs(ei)
      }
    } else {
      a = fi
      fptr += 1
      if(fptr < nf) {
        fi = -f[fptr]
        fa = abs(fi)
      }
    }
    b = q0
    x = a + b
    bv = x - a
    y = b - bv
    if(y) {
      g[count++] = y
    }
    _x = q1 + x
    _bv = _x - q1
    _av = _x - _bv
    _br = x - _bv
    _ar = q1 - _av
    q0 = _ar + _br
    q1 = _x
  }
  while(eptr < ne) {
    a = ei
    b = q0
    x = a + b
    bv = x - a
    y = b - bv
    if(y) {
      g[count++] = y
    }
    _x = q1 + x
    _bv = _x - q1
    _av = _x - _bv
    _br = x - _bv
    _ar = q1 - _av
    q0 = _ar + _br
    q1 = _x
    eptr += 1
    if(eptr < ne) {
      ei = e[eptr]
    }
  }
  while(fptr < nf) {
    a = fi
    b = q0
    x = a + b
    bv = x - a
    y = b - bv
    if(y) {
      g[count++] = y
    } 
    _x = q1 + x
    _bv = _x - q1
    _av = _x - _bv
    _br = x - _bv
    _ar = q1 - _av
    q0 = _ar + _br
    q1 = _x
    fptr += 1
    if(fptr < nf) {
      fi = -f[fptr]
    }
  }
  if(q0) {
    g[count++] = q0
  }
  if(q1) {
    g[count++] = q1
  }
  if(!count) {
    g[count++] = 0.0  
  }
  g.length = count
  return g
}
},{}],110:[function(require,module,exports){
"use strict"

module.exports = linearExpansionSum

//Easy case: Add two scalars
function scalarScalar(a, b) {
  var x = a + b
  var bv = x - a
  var av = x - bv
  var br = b - bv
  var ar = a - av
  var y = ar + br
  if(y) {
    return [y, x]
  }
  return [x]
}

function linearExpansionSum(e, f) {
  var ne = e.length|0
  var nf = f.length|0
  if(ne === 1 && nf === 1) {
    return scalarScalar(e[0], f[0])
  }
  var n = ne + nf
  var g = new Array(n)
  var count = 0
  var eptr = 0
  var fptr = 0
  var abs = Math.abs
  var ei = e[eptr]
  var ea = abs(ei)
  var fi = f[fptr]
  var fa = abs(fi)
  var a, b
  if(ea < fa) {
    b = ei
    eptr += 1
    if(eptr < ne) {
      ei = e[eptr]
      ea = abs(ei)
    }
  } else {
    b = fi
    fptr += 1
    if(fptr < nf) {
      fi = f[fptr]
      fa = abs(fi)
    }
  }
  if((eptr < ne && ea < fa) || (fptr >= nf)) {
    a = ei
    eptr += 1
    if(eptr < ne) {
      ei = e[eptr]
      ea = abs(ei)
    }
  } else {
    a = fi
    fptr += 1
    if(fptr < nf) {
      fi = f[fptr]
      fa = abs(fi)
    }
  }
  var x = a + b
  var bv = x - a
  var y = b - bv
  var q0 = y
  var q1 = x
  var _x, _bv, _av, _br, _ar
  while(eptr < ne && fptr < nf) {
    if(ea < fa) {
      a = ei
      eptr += 1
      if(eptr < ne) {
        ei = e[eptr]
        ea = abs(ei)
      }
    } else {
      a = fi
      fptr += 1
      if(fptr < nf) {
        fi = f[fptr]
        fa = abs(fi)
      }
    }
    b = q0
    x = a + b
    bv = x - a
    y = b - bv
    if(y) {
      g[count++] = y
    }
    _x = q1 + x
    _bv = _x - q1
    _av = _x - _bv
    _br = x - _bv
    _ar = q1 - _av
    q0 = _ar + _br
    q1 = _x
  }
  while(eptr < ne) {
    a = ei
    b = q0
    x = a + b
    bv = x - a
    y = b - bv
    if(y) {
      g[count++] = y
    }
    _x = q1 + x
    _bv = _x - q1
    _av = _x - _bv
    _br = x - _bv
    _ar = q1 - _av
    q0 = _ar + _br
    q1 = _x
    eptr += 1
    if(eptr < ne) {
      ei = e[eptr]
    }
  }
  while(fptr < nf) {
    a = fi
    b = q0
    x = a + b
    bv = x - a
    y = b - bv
    if(y) {
      g[count++] = y
    } 
    _x = q1 + x
    _bv = _x - q1
    _av = _x - _bv
    _br = x - _bv
    _ar = q1 - _av
    q0 = _ar + _br
    q1 = _x
    fptr += 1
    if(fptr < nf) {
      fi = f[fptr]
    }
  }
  if(q0) {
    g[count++] = q0
  }
  if(q1) {
    g[count++] = q1
  }
  if(!count) {
    g[count++] = 0.0  
  }
  g.length = count
  return g
}
},{}],111:[function(require,module,exports){
"use strict"

module.exports = function signum(x) {
  if(x < 0) { return -1 }
  if(x > 0) { return 1 }
  return 0.0
}
},{}],112:[function(require,module,exports){
arguments[4][20][0].apply(exports,arguments)
},{"dup":20}],113:[function(require,module,exports){
"use strict"; "use restrict";

module.exports = UnionFind;

function UnionFind(count) {
  this.roots = new Array(count);
  this.ranks = new Array(count);
  
  for(var i=0; i<count; ++i) {
    this.roots[i] = i;
    this.ranks[i] = 0;
  }
}

UnionFind.prototype.length = function() {
  return this.roots.length;
}

UnionFind.prototype.makeSet = function() {
  var n = this.roots.length;
  this.roots.push(n);
  this.ranks.push(0);
  return n;
}

UnionFind.prototype.find = function(x) {
  var roots = this.roots;
  while(roots[x] !== x) {
    var y = roots[x];
    roots[x] = roots[y];
    x = y;
  }
  return x;
}

UnionFind.prototype.link = function(x, y) {
  var xr = this.find(x)
    , yr = this.find(y);
  if(xr === yr) {
    return;
  }
  var ranks = this.ranks
    , roots = this.roots
    , xd    = ranks[xr]
    , yd    = ranks[yr];
  if(xd < yd) {
    roots[xr] = yr;
  } else if(yd < xd) {
    roots[yr] = xr;
  } else {
    roots[yr] = xr;
    ++ranks[xr];
  }
}


},{}],114:[function(require,module,exports){
"use strict"; "use restrict";

var bits      = require("bit-twiddle")
  , UnionFind = require("union-find")

//Returns the dimension of a cell complex
function dimension(cells) {
  var d = 0
    , max = Math.max
  for(var i=0, il=cells.length; i<il; ++i) {
    d = max(d, cells[i].length)
  }
  return d-1
}
exports.dimension = dimension

//Counts the number of vertices in faces
function countVertices(cells) {
  var vc = -1
    , max = Math.max
  for(var i=0, il=cells.length; i<il; ++i) {
    var c = cells[i]
    for(var j=0, jl=c.length; j<jl; ++j) {
      vc = max(vc, c[j])
    }
  }
  return vc+1
}
exports.countVertices = countVertices

//Returns a deep copy of cells
function cloneCells(cells) {
  var ncells = new Array(cells.length)
  for(var i=0, il=cells.length; i<il; ++i) {
    ncells[i] = cells[i].slice(0)
  }
  return ncells
}
exports.cloneCells = cloneCells

//Ranks a pair of cells up to permutation
function compareCells(a, b) {
  var n = a.length
    , t = a.length - b.length
    , min = Math.min
  if(t) {
    return t
  }
  switch(n) {
    case 0:
      return 0;
    case 1:
      return a[0] - b[0];
    case 2:
      var d = a[0]+a[1]-b[0]-b[1]
      if(d) {
        return d
      }
      return min(a[0],a[1]) - min(b[0],b[1])
    case 3:
      var l1 = a[0]+a[1]
        , m1 = b[0]+b[1]
      d = l1+a[2] - (m1+b[2])
      if(d) {
        return d
      }
      var l0 = min(a[0], a[1])
        , m0 = min(b[0], b[1])
        , d  = min(l0, a[2]) - min(m0, b[2])
      if(d) {
        return d
      }
      return min(l0+a[2], l1) - min(m0+b[2], m1)
    
    //TODO: Maybe optimize n=4 as well?
    
    default:
      var as = a.slice(0)
      as.sort()
      var bs = b.slice(0)
      bs.sort()
      for(var i=0; i<n; ++i) {
        t = as[i] - bs[i]
        if(t) {
          return t
        }
      }
      return 0
  }
}
exports.compareCells = compareCells

function compareZipped(a, b) {
  return compareCells(a[0], b[0])
}

//Puts a cell complex into normal order for the purposes of findCell queries
function normalize(cells, attr) {
  if(attr) {
    var len = cells.length
    var zipped = new Array(len)
    for(var i=0; i<len; ++i) {
      zipped[i] = [cells[i], attr[i]]
    }
    zipped.sort(compareZipped)
    for(var i=0; i<len; ++i) {
      cells[i] = zipped[i][0]
      attr[i] = zipped[i][1]
    }
    return cells
  } else {
    cells.sort(compareCells)
    return cells
  }
}
exports.normalize = normalize

//Removes all duplicate cells in the complex
function unique(cells) {
  if(cells.length === 0) {
    return []
  }
  var ptr = 1
    , len = cells.length
  for(var i=1; i<len; ++i) {
    var a = cells[i]
    if(compareCells(a, cells[i-1])) {
      if(i === ptr) {
        ptr++
        continue
      }
      cells[ptr++] = a
    }
  }
  cells.length = ptr
  return cells
}
exports.unique = unique;

//Finds a cell in a normalized cell complex
function findCell(cells, c) {
  var lo = 0
    , hi = cells.length-1
    , r  = -1
  while (lo <= hi) {
    var mid = (lo + hi) >> 1
      , s   = compareCells(cells[mid], c)
    if(s <= 0) {
      if(s === 0) {
        r = mid
      }
      lo = mid + 1
    } else if(s > 0) {
      hi = mid - 1
    }
  }
  return r
}
exports.findCell = findCell;

//Builds an index for an n-cell.  This is more general than dual, but less efficient
function incidence(from_cells, to_cells) {
  var index = new Array(from_cells.length)
  for(var i=0, il=index.length; i<il; ++i) {
    index[i] = []
  }
  var b = []
  for(var i=0, n=to_cells.length; i<n; ++i) {
    var c = to_cells[i]
    var cl = c.length
    for(var k=1, kn=(1<<cl); k<kn; ++k) {
      b.length = bits.popCount(k)
      var l = 0
      for(var j=0; j<cl; ++j) {
        if(k & (1<<j)) {
          b[l++] = c[j]
        }
      }
      var idx=findCell(from_cells, b)
      if(idx < 0) {
        continue
      }
      while(true) {
        index[idx++].push(i)
        if(idx >= from_cells.length || compareCells(from_cells[idx], b) !== 0) {
          break
        }
      }
    }
  }
  return index
}
exports.incidence = incidence

//Computes the dual of the mesh.  This is basically an optimized version of buildIndex for the situation where from_cells is just the list of vertices
function dual(cells, vertex_count) {
  if(!vertex_count) {
    return incidence(unique(skeleton(cells, 0)), cells, 0)
  }
  var res = new Array(vertex_count)
  for(var i=0; i<vertex_count; ++i) {
    res[i] = []
  }
  for(var i=0, len=cells.length; i<len; ++i) {
    var c = cells[i]
    for(var j=0, cl=c.length; j<cl; ++j) {
      res[c[j]].push(i)
    }
  }
  return res
}
exports.dual = dual

//Enumerates all cells in the complex
function explode(cells) {
  var result = []
  for(var i=0, il=cells.length; i<il; ++i) {
    var c = cells[i]
      , cl = c.length|0
    for(var j=1, jl=(1<<cl); j<jl; ++j) {
      var b = []
      for(var k=0; k<cl; ++k) {
        if((j >>> k) & 1) {
          b.push(c[k])
        }
      }
      result.push(b)
    }
  }
  return normalize(result)
}
exports.explode = explode

//Enumerates all of the n-cells of a cell complex
function skeleton(cells, n) {
  if(n < 0) {
    return []
  }
  var result = []
    , k0     = (1<<(n+1))-1
  for(var i=0; i<cells.length; ++i) {
    var c = cells[i]
    for(var k=k0; k<(1<<c.length); k=bits.nextCombination(k)) {
      var b = new Array(n+1)
        , l = 0
      for(var j=0; j<c.length; ++j) {
        if(k & (1<<j)) {
          b[l++] = c[j]
        }
      }
      result.push(b)
    }
  }
  return normalize(result)
}
exports.skeleton = skeleton;

//Computes the boundary of all cells, does not remove duplicates
function boundary(cells) {
  var res = []
  for(var i=0,il=cells.length; i<il; ++i) {
    var c = cells[i]
    for(var j=0,cl=c.length; j<cl; ++j) {
      var b = new Array(c.length-1)
      for(var k=0, l=0; k<cl; ++k) {
        if(k !== j) {
          b[l++] = c[k]
        }
      }
      res.push(b)
    }
  }
  return normalize(res)
}
exports.boundary = boundary;

//Computes connected components for a dense cell complex
function connectedComponents_dense(cells, vertex_count) {
  var labels = new UnionFind(vertex_count)
  for(var i=0; i<cells.length; ++i) {
    var c = cells[i]
    for(var j=0; j<c.length; ++j) {
      for(var k=j+1; k<c.length; ++k) {
        labels.link(c[j], c[k])
      }
    }
  }
  var components = []
    , component_labels = labels.ranks
  for(var i=0; i<component_labels.length; ++i) {
    component_labels[i] = -1
  }
  for(var i=0; i<cells.length; ++i) {
    var l = labels.find(cells[i][0])
    if(component_labels[l] < 0) {
      component_labels[l] = components.length
      components.push([cells[i].slice(0)])
    } else {
      components[component_labels[l]].push(cells[i].slice(0))
    }
  }
  return components
}

//Computes connected components for a sparse graph
function connectedComponents_sparse(cells) {
  var vertices  = unique(normalize(skeleton(cells, 0)))
    , labels    = new UnionFind(vertices.length)
  for(var i=0; i<cells.length; ++i) {
    var c = cells[i]
    for(var j=0; j<c.length; ++j) {
      var vj = findCell(vertices, [c[j]])
      for(var k=j+1; k<c.length; ++k) {
        labels.link(vj, findCell(vertices, [c[k]]))
      }
    }
  }
  var components        = []
    , component_labels  = labels.ranks
  for(var i=0; i<component_labels.length; ++i) {
    component_labels[i] = -1
  }
  for(var i=0; i<cells.length; ++i) {
    var l = labels.find(findCell(vertices, [cells[i][0]]));
    if(component_labels[l] < 0) {
      component_labels[l] = components.length
      components.push([cells[i].slice(0)])
    } else {
      components[component_labels[l]].push(cells[i].slice(0))
    }
  }
  return components
}

//Computes connected components for a cell complex
function connectedComponents(cells, vertex_count) {
  if(vertex_count) {
    return connectedComponents_dense(cells, vertex_count)
  }
  return connectedComponents_sparse(cells)
}
exports.connectedComponents = connectedComponents

},{"bit-twiddle":112,"union-find":113}],115:[function(require,module,exports){
"use strict"

module.exports = simplifyPolygon

var orient = require("robust-orientation")
var sc = require("simplicial-complex")

function errorWeight(base, a, b) {
  var area = Math.abs(orient(base, a, b))
  var perim = Math.sqrt(Math.pow(a[0] - b[0], 2) + Math.pow(a[1]-b[1], 2))
  return area / perim
}

function simplifyPolygon(cells, positions, minArea) {

  var n = positions.length
  var nc = cells.length
  var inv = new Array(n)
  var outv = new Array(n)
  var weights = new Array(n)
  var dead = new Array(n)
  
  //Initialize tables
  for(var i=0; i<n; ++i) {
    inv[i] = outv[i] = -1
    weights[i] = Infinity
    dead[i] = false
  }

  //Compute neighbors
  for(var i=0; i<nc; ++i) {
    var c = cells[i]
    if(c.length !== 2) {
      throw new Error("Input must be a graph")
    }
    var s = c[1]
    var t = c[0]
    if(outv[t] !== -1) {
      outv[t] = -2
    } else {
      outv[t] = s
    }
    if(inv[s] !== -1) {
      inv[s] = -2
    } else {
      inv[s] = t
    }
  }

  //Updates the weight for vertex i
  function computeWeight(i) {
    if(dead[i]) {
      return Infinity
    }
    //TODO: Check that the line segment doesn't cross once simplified
    var s = inv[i]
    var t = outv[i]
    if((s<0) || (t<0)) {
      return Infinity
    } else {
      return errorWeight(positions[i], positions[s], positions[t])
    }
  }

  //Swaps two nodes on the heap (i,j) are the index of the nodes
  function heapSwap(i,j) {
    var a = heap[i]
    var b = heap[j]
    heap[i] = b
    heap[j] = a
    index[a] = j
    index[b] = i
  }

  //Returns the weight of node i on the heap
  function heapWeight(i) {
    return weights[heap[i]]
  }

  function heapParent(i) {
    if(i & 1) {
      return (i - 1) >> 1
    }
    return (i >> 1) - 1
  }

  //Bubble element i down the heap
  function heapDown(i) {
    var w = heapWeight(i)
    while(true) {
      var tw = w
      var left  = 2*i + 1
      var right = 2*(i + 1)
      var next = i
      if(left < heapCount) {
        var lw = heapWeight(left)
        if(lw < tw) {
          next = left
          tw = lw
        }
      }
      if(right < heapCount) {
        var rw = heapWeight(right)
        if(rw < tw) {
          next = right
        }
      }
      if(next === i) {
        return i
      }
      heapSwap(i, next)
      i = next      
    }
  }

  //Bubbles element i up the heap
  function heapUp(i) {
    var w = heapWeight(i)
    while(i > 0) {
      var parent = heapParent(i)
      if(parent >= 0) {
        var pw = heapWeight(parent)
        if(w < pw) {
          heapSwap(i, parent)
          i = parent
          continue
        }
      }
      return i
    }
  }

  //Pop minimum element
  function heapPop() {
    if(heapCount > 0) {
      var head = heap[0]
      heapSwap(0, heapCount-1)
      heapCount -= 1
      heapDown(0)
      return head
    }
    return -1
  }

  //Update heap item i
  function heapUpdate(i, w) {
    var a = heap[i]
    if(weights[a] === w) {
      return i
    }
    weights[a] = -Infinity
    heapUp(i)
    heapPop()
    weights[a] = w
    heapCount += 1
    return heapUp(heapCount-1)
  }

  //Kills a vertex (assume vertex already removed from heap)
  function kill(i) {
    if(dead[i]) {
      return
    }
    //Kill vertex
    dead[i] = true
    //Fixup topology
    var s = inv[i]
    var t = outv[i]
    if(inv[t] >= 0) {
      inv[t] = s
    }
    if(outv[s] >= 0) {
      outv[s] = t
    }

    //Update weights on s and t
    if(index[s] >= 0) {
      heapUpdate(index[s], computeWeight(s))
    }
    if(index[t] >= 0) {
      heapUpdate(index[t], computeWeight(t))
    }
  }

  //Initialize weights and heap
  var heap = []
  var index = new Array(n)
  for(var i=0; i<n; ++i) {
    var w = weights[i] = computeWeight(i)
    if(w < Infinity) {
      index[i] = heap.length
      heap.push(i)
    } else {
      index[i] = -1
    }
  }
  var heapCount = heap.length
  for(var i=heapCount>>1; i>=0; --i) {
    heapDown(i)
  }
  
  //Kill vertices
  while(true) {
    var hmin = heapPop()
    if((hmin < 0) || (weights[hmin] > minArea)) {
      break
    }
    kill(hmin)
  }

  //Build collapsed vertex table
  var npositions = []
  for(var i=0; i<n; ++i) {
    if(!dead[i]) {
      index[i] = npositions.length
      npositions.push(positions[i].slice())
    }
  }
  var nv = npositions.length

  function tortoiseHare(seq, start) {
    if(seq[start] < 0) {
      return start
    }
    var t = start
    var h = start
    do {
      //Walk two steps with h
      var nh = seq[h]
      if(!dead[h] || nh < 0 || nh === h) {
        break
      }
      h = nh
      nh = seq[h]
      if(!dead[h] || nh < 0 || nh === h) {
        break
      }
      h = nh

      //Walk one step with t
      t = seq[t]
    } while(t !== h)
    //Compress cycles
    for(var v=start; v!==h; v = seq[v]) {
      seq[v] = h
    }
    return h
  }

  var ncells = []
  cells.forEach(function(c) {
    var tin = tortoiseHare(inv, c[0])
    var tout = tortoiseHare(outv, c[1])
    if(tin >= 0 && tout >= 0 && tin !== tout) {
      var cin = index[tin]
      var cout = index[tout]
      if(cin !== cout) {
        ncells.push([ cin, cout ])
      }
    }
  })

  //Normalize result
  sc.unique(sc.normalize(ncells))

  //Return final list of cells
  return {
    positions: npositions,
    edges: ncells
  }
}
},{"robust-orientation":105,"simplicial-complex":114}],116:[function(require,module,exports){
"use strict"

module.exports = orderSegments

var orient = require("robust-orientation")

function horizontalOrder(a, b) {
  var bl, br
  if(b[0][0] < b[1][0]) {
    bl = b[0]
    br = b[1]
  } else if(b[0][0] > b[1][0]) {
    bl = b[1]
    br = b[0]
  } else {
    var alo = Math.min(a[0][1], a[1][1])
    var ahi = Math.max(a[0][1], a[1][1])
    var blo = Math.min(b[0][1], b[1][1])
    var bhi = Math.max(b[0][1], b[1][1])
    if(ahi < blo) {
      return ahi - blo
    }
    if(alo > bhi) {
      return alo - bhi
    }
    return ahi - bhi
  }
  var al, ar
  if(a[0][1] < a[1][1]) {
    al = a[0]
    ar = a[1]
  } else {
    al = a[1]
    ar = a[0]
  }
  var d = orient(br, bl, al)
  if(d) {
    return d
  }
  d = orient(br, bl, ar)
  if(d) {
    return d
  }
  return ar - br
}

function orderSegments(b, a) {
  var al, ar
  if(a[0][0] < a[1][0]) {
    al = a[0]
    ar = a[1]
  } else if(a[0][0] > a[1][0]) {
    al = a[1]
    ar = a[0]
  } else {
    return horizontalOrder(a, b)
  }
  var bl, br
  if(b[0][0] < b[1][0]) {
    bl = b[0]
    br = b[1]
  } else if(b[0][0] > b[1][0]) {
    bl = b[1]
    br = b[0]
  } else {
    return -horizontalOrder(b, a)
  }
  var d1 = orient(al, ar, br)
  var d2 = orient(al, ar, bl)
  if(d1 < 0) {
    if(d2 <= 0) {
      return d1
    }
  } else if(d1 > 0) {
    if(d2 >= 0) {
      return d1
    }
  } else if(d2) {
    return d2
  }
  d1 = orient(br, bl, ar)
  d2 = orient(br, bl, al)
  if(d1 < 0) {
    if(d2 <= 0) {
      return d1
    }
  } else if(d1 > 0) {
    if(d2 >= 0) {
      return d1
    }
  } else if(d2) {
    return d2
  }
  return ar[0] - br[0]
}
},{"robust-orientation":105}],117:[function(require,module,exports){
"use strict"

module.exports = createSlabDecomposition

var bounds = require("binary-search-bounds")
var createRBTree = require("functional-red-black-tree")
var orient = require("robust-orientation")
var orderSegments = require("./lib/order-segments")

function SlabDecomposition(slabs, coordinates, horizontal) {
  this.slabs = slabs
  this.coordinates = coordinates
  this.horizontal = horizontal
}

var proto = SlabDecomposition.prototype

function compareHorizontal(e, y) {
  return e.y - y
}

function searchBucket(root, p) {
  var lastNode = null
  while(root) {
    var seg = root.key
    var l, r
    if(seg[0][0] < seg[1][0]) {
      l = seg[0]
      r = seg[1]
    } else {
      l = seg[1]
      r = seg[0]
    }
    var o = orient(l, r, p)
    if(o < 0) {
      root = root.left
    } else if(o > 0) {
      if(p[0] !== seg[1][0]) {
        lastNode = root
        root = root.right
      } else {
        var val = searchBucket(root.right, p)
        if(val) {
          return val
        }
        root = root.left
      }
    } else {
      if(p[0] !== seg[1][0]) {
        return root
      } else {
        var val = searchBucket(root.right, p)
        if(val) {
          return val
        }
        root = root.left
      }
    }
  }
  return lastNode
}

proto.castUp = function(p) {
  var bucket = bounds.le(this.coordinates, p[0])
  if(bucket < 0) {
    return -1
  }
  var root = this.slabs[bucket]
  var hitNode = searchBucket(this.slabs[bucket], p)
  var lastHit = -1
  if(hitNode) {
    lastHit = hitNode.value
  }
  //Edge case: need to handle horizontal segments (sucks)
  if(this.coordinates[bucket] === p[0]) {
    var lastSegment = null
    if(hitNode) {
      lastSegment = hitNode.key
    }
    if(bucket > 0) {
      var otherHitNode = searchBucket(this.slabs[bucket-1], p)
      if(otherHitNode) {
        if(lastSegment) {
          if(orderSegments(otherHitNode.key, lastSegment) > 0) {
            lastSegment = otherHitNode.key
            lastHit = otherHitNode.value
          }
        } else {
          lastHit = otherHitNode.value
          lastSegment = otherHitNode.key
        }
      }
    }
    var horiz = this.horizontal[bucket]
    if(horiz.length > 0) {
      var hbucket = bounds.ge(horiz, p[1], compareHorizontal)
      if(hbucket < horiz.length) {
        var e = horiz[hbucket]
        if(p[1] === e.y) {
          if(e.closed) {
            return e.index
          } else {
            while(hbucket < horiz.length-1 && horiz[hbucket+1].y === p[1]) {
              hbucket = hbucket+1
              e = horiz[hbucket]
              if(e.closed) {
                return e.index
              }
            }
            if(e.y === p[1] && !e.start) {
              hbucket = hbucket+1
              if(hbucket >= horiz.length) {
                return lastHit
              }
              e = horiz[hbucket]
            }
          }
        }
        //Check if e is above/below last segment
        if(e.start) {
          if(lastSegment) {
            var o = orient(lastSegment[0], lastSegment[1], [p[0], e.y])
            if(lastSegment[0][0] > lastSegment[1][0]) {
              o = -o
            }
            if(o > 0) {
              lastHit = e.index
            }
          } else {
            lastHit = e.index
          }
        } else if(e.y !== p[1]) {
          lastHit = e.index
        }
      }
    }
  }
  return lastHit
}

function IntervalSegment(y, index, start, closed) {
  this.y = y
  this.index = index
  this.start = start
  this.closed = closed
}

function Event(x, segment, create, index) {
  this.x = x
  this.segment = segment
  this.create = create
  this.index = index
}


function createSlabDecomposition(segments) {
  var numSegments = segments.length
  var numEvents = 2 * numSegments
  var events = new Array(numEvents)
  for(var i=0; i<numSegments; ++i) {
    var s = segments[i]
    var f = s[0][0] < s[1][0]
    events[2*i] = new Event(s[0][0], s, f, i)
    events[2*i+1] = new Event(s[1][0], s, !f, i)
  }
  events.sort(function(a,b) {
    var d = a.x - b.x
    if(d) {
      return d
    }
    d = a.create - b.create
    if(d) {
      return d
    }
    return Math.min(a.segment[0][1], a.segment[1][1]) - Math.min(b.segment[0][1], b.segment[1][1])
  })
  var tree = createRBTree(orderSegments)
  var slabs = []
  var lines = []
  var horizontal = []
  var lastX = -Infinity
  for(var i=0; i<numEvents; ) {
    var x = events[i].x
    var horiz = []
    while(i < numEvents) {
      var e = events[i]
      if(e.x !== x) {
        break
      }
      i += 1
      if(e.segment[0][0] === e.x && e.segment[1][0] === e.x) {
        if(e.create) {
          if(e.segment[0][1] < e.segment[1][1]) {
            horiz.push(new IntervalSegment(
                e.segment[0][1],
                e.index,
                true,
                true))
            horiz.push(new IntervalSegment(
                e.segment[1][1],
                e.index,
                false,
                false))
          } else {
            horiz.push(new IntervalSegment(
                e.segment[1][1],
                e.index,
                true,
                false))
            horiz.push(new IntervalSegment(
                e.segment[0][1],
                e.index,
                false,
                true))
          }
        }
      } else {
        if(e.create) {
          tree = tree.insert(e.segment, e.index)
        } else {
          tree = tree.remove(e.segment)
        }
      }
    }
    slabs.push(tree.root)
    lines.push(x)
    horizontal.push(horiz)
  }
  return new SlabDecomposition(slabs, lines, horizontal)
}
},{"./lib/order-segments":116,"binary-search-bounds":19,"functional-red-black-tree":45,"robust-orientation":105}],118:[function(require,module,exports){
"use strict"

module.exports = surfaceNets

var generateContourExtractor = require("ndarray-extract-contour")
var triangulateCube = require("triangulate-hypercube")
var zeroCrossings = require("zero-crossings")

function buildSurfaceNets(order, dtype) {
  var dimension = order.length
  var code = ["'use strict';"]
  var funcName = "surfaceNets" + order.join("_") + "d" + dtype

  //Contour extraction function
  code.push(
    "var contour=genContour({",
      "order:[", order.join(), "],",
      "scalarArguments: 3,",
      "phase:function phaseFunc(p,a,b,c) { return (p > c)|0 },")
  if(dtype === "generic") {
    code.push("getters:[0],")
  }

  //Generate vertex function
  var cubeArgs = []
  var extraArgs = []
  for(var i=0; i<dimension; ++i) {
    cubeArgs.push("d" + i)
    extraArgs.push("d" + i)
  }
  for(var i=0; i<(1<<dimension); ++i) {
    cubeArgs.push("v" + i)
    extraArgs.push("v" + i)
  }
  for(var i=0; i<(1<<dimension); ++i) {
    cubeArgs.push("p" + i)
    extraArgs.push("p" + i)
  }
  cubeArgs.push("a", "b", "c")
  extraArgs.push("a", "c")
  code.push("vertex:function vertexFunc(", cubeArgs.join(), "){")
  //Mask args together
  var maskStr = []
  for(var i=0; i<(1<<dimension); ++i) {
    maskStr.push("(p" + i + "<<" + i + ")")
  }
  //Generate variables and giganto switch statement
  code.push("var m=(", maskStr.join("+"), ")|0;if(m===0||m===", (1<<(1<<dimension))-1, "){return}")
  var extraFuncs = []
  var currentFunc = []
  if(1<<(1<<dimension) <= 128) {
    code.push("switch(m){")
    currentFunc = code
  } else {
    code.push("switch(m>>>7){")
  }
  for(var i=0; i<1<<(1<<dimension); ++i) {
    if(1<<(1<<dimension) > 128) {
      if((i%128)===0) {
        if(extraFuncs.length > 0) {
          currentFunc.push("}}")
        }
        var efName = "vExtra" + extraFuncs.length
        code.push("case ", (i>>>7), ":", efName, "(m&0x7f,", extraArgs.join(), ");break;")
        currentFunc = [
          "function ", efName, "(m,", extraArgs.join(), "){switch(m){"
        ]
        extraFuncs.push(currentFunc)
      }  
    }
    currentFunc.push("case ", (i&0x7f), ":")
    var crossings = new Array(dimension)
    var denoms = new Array(dimension)
    var crossingCount = new Array(dimension)
    var bias = new Array(dimension)
    var totalCrossings = 0
    for(var j=0; j<dimension; ++j) {
      crossings[j] = []
      denoms[j] = []
      crossingCount[j] = 0
      bias[j] = 0
    }
    for(var j=0; j<(1<<dimension); ++j) {
      for(var k=0; k<dimension; ++k) {
        var u = j ^ (1<<k)
        if(u > j) {
          continue
        }
        if(!(i&(1<<u)) !== !(i&(1<<j))) {
          var sign = 1
          if(i&(1<<u)) {
            denoms[k].push("v" + u + "-v" + j)
          } else {
            denoms[k].push("v" + j + "-v" + u)
            sign = -sign
          }
          if(sign < 0) {
            crossings[k].push("-v" + j + "-v" + u)
            crossingCount[k] += 2
          } else {
            crossings[k].push("v" + j + "+v" + u)
            crossingCount[k] -= 2            
          }
          totalCrossings += 1
          for(var l=0; l<dimension; ++l) {
            if(l === k) {
              continue
            }
            if(u&(1<<l)) {
              bias[l] += 1
            } else {
              bias[l] -= 1
            }
          }
        }
      }
    }
    var vertexStr = []
    for(var k=0; k<dimension; ++k) {
      if(crossings[k].length === 0) {
        vertexStr.push("d" + k + "-0.5")
      } else {
        var cStr = ""
        if(crossingCount[k] < 0) {
          cStr = crossingCount[k] + "*c"
        } else if(crossingCount[k] > 0) {
          cStr = "+" + crossingCount[k] + "*c"
        }
        var weight = 0.5 * (crossings[k].length / totalCrossings)
        var shift = 0.5 + 0.5 * (bias[k] / totalCrossings)
        vertexStr.push("d" + k + "-" + shift + "-" + weight + "*(" + crossings[k].join("+") + cStr + ")/(" + denoms[k].join("+") + ")")
        
      }
    }
    currentFunc.push("a.push([", vertexStr.join(), "]);",
      "break;")
  }
  code.push("}},")
  if(extraFuncs.length > 0) {
    currentFunc.push("}}")
  }

  //Create face function
  var faceArgs = []
  for(var i=0; i<(1<<(dimension-1)); ++i) {
    faceArgs.push("v" + i)
  }
  faceArgs.push("c0", "c1", "p0", "p1", "a", "b", "c")
  code.push("cell:function cellFunc(", faceArgs.join(), "){")

  var facets = triangulateCube(dimension-1)
  code.push("if(p0){b.push(",
    facets.map(function(f) {
      return "[" + f.map(function(v) {
        return "v" + v
      }) + "]"
    }).join(), ")}else{b.push(",
    facets.map(function(f) {
      var e = f.slice()
      e.reverse()
      return "[" + e.map(function(v) {
        return "v" + v
      }) + "]"
    }).join(),
    ")}}});function ", funcName, "(array,level){var verts=[],cells=[];contour(array,verts,cells,level);return {positions:verts,cells:cells};} return ", funcName, ";")

  for(var i=0; i<extraFuncs.length; ++i) {
    code.push(extraFuncs[i].join(""))
  }

  //Compile and link
  var proc = new Function("genContour", code.join(""))
  return proc(generateContourExtractor)
}

//1D case: Need to handle specially
function mesh1D(array, level) {
  var zc = zeroCrossings(array, level)
  var n = zc.length
  var npos = new Array(n)
  var ncel = new Array(n)
  for(var i=0; i<n; ++i) {
    npos[i] = [ zc[i] ]
    ncel[i] = [ i ]
  }
  return {
    positions: npos,
    cells: ncel
  }
}

var CACHE = {}

function surfaceNets(array,level) {
  if(array.dimension <= 0) {
    return { positions: [], cells: [] }
  } else if(array.dimension === 1) {
    return mesh1D(array, level)
  }
  var typesig = array.order.join() + "-" + array.dtype
  var proc = CACHE[typesig]
  var level = (+level) || 0.0
  if(!proc) {
    proc = CACHE[typesig] = buildSurfaceNets(array.order, array.dtype)
  }
  return proc(array,level)
}
},{"ndarray-extract-contour":85,"triangulate-hypercube":177,"zero-crossings":186}],119:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.NotEqualCompare = exports.NormalBlending = exports.NormalAnimationBlendMode = exports.NoToneMapping = exports.NoColorSpace = exports.NoBlending = exports.NeverStencilFunc = exports.NeverDepth = exports.NeverCompare = exports.NearestMipmapNearestFilter = exports.NearestMipmapLinearFilter = exports.NearestMipMapNearestFilter = exports.NearestMipMapLinearFilter = exports.NearestFilter = exports.MultiplyOperation = exports.MultiplyBlending = exports.MixOperation = exports.MirroredRepeatWrapping = exports.MinEquation = exports.MaxEquation = exports.MOUSE = exports.LuminanceFormat = exports.LuminanceAlphaFormat = exports.LoopRepeat = exports.LoopPingPong = exports.LoopOnce = exports.LinearToneMapping = exports.LinearSRGBColorSpace = exports.LinearMipmapNearestFilter = exports.LinearMipmapLinearFilter = exports.LinearMipMapNearestFilter = exports.LinearMipMapLinearFilter = exports.LinearFilter = exports.LinearEncoding = exports.LinearDisplayP3ColorSpace = exports.LessStencilFunc = exports.LessEqualStencilFunc = exports.LessEqualDepth = exports.LessEqualCompare = exports.LessDepth = exports.LessCompare = exports.KeepStencilOp = exports.InvertStencilOp = exports.InterpolateSmooth = exports.InterpolateLinear = exports.InterpolateDiscrete = exports.IntType = exports.IncrementWrapStencilOp = exports.IncrementStencilOp = exports.HalfFloatType = exports.GreaterStencilFunc = exports.GreaterEqualStencilFunc = exports.GreaterEqualDepth = exports.GreaterEqualCompare = exports.GreaterDepth = exports.GreaterCompare = exports.GLSL3 = exports.GLSL1 = exports.FrontSide = exports.FloatType = exports.EquirectangularRefractionMapping = exports.EquirectangularReflectionMapping = exports.EqualStencilFunc = exports.EqualDepth = exports.EqualCompare = exports.DynamicReadUsage = exports.DynamicDrawUsage = exports.DynamicCopyUsage = exports.DstColorFactor = exports.DstAlphaFactor = exports.DoubleSide = exports.DisplayP3ColorSpace = exports.DepthStencilFormat = exports.DepthFormat = exports.DecrementWrapStencilOp = exports.DecrementStencilOp = exports.CustomToneMapping = exports.CustomBlending = exports.CullFaceNone = exports.CullFaceFrontBack = exports.CullFaceFront = exports.CullFaceBack = exports.CubeUVReflectionMapping = exports.CubeRefractionMapping = exports.CubeReflectionMapping = exports.ClampToEdgeWrapping = exports.CineonToneMapping = exports.ByteType = exports.BasicShadowMap = exports.BasicDepthPacking = exports.BackSide = exports.AlwaysStencilFunc = exports.AlwaysDepth = exports.AlwaysCompare = exports.AlphaFormat = exports.AdditiveBlending = exports.AdditiveAnimationBlendMode = exports.AddOperation = exports.AddEquation = exports.ACESFilmicToneMapping = void 0;
exports.sRGBEncoding = exports._SRGBAFormat = exports.ZeroStencilOp = exports.ZeroSlopeEnding = exports.ZeroFactor = exports.ZeroCurvatureEnding = exports.WrapAroundEnding = exports.WebGPUCoordinateSystem = exports.WebGLCoordinateSystem = exports.VSMShadowMap = exports.UnsignedShortType = exports.UnsignedShort5551Type = exports.UnsignedShort4444Type = exports.UnsignedIntType = exports.UnsignedInt248Type = exports.UnsignedByteType = exports.UVMapping = exports.TwoPassDoubleSide = exports.TrianglesDrawMode = exports.TriangleStripDrawMode = exports.TriangleFanDrawMode = exports.TangentSpaceNormalMap = exports.TOUCH = exports.SubtractiveBlending = exports.SubtractEquation = exports.StreamReadUsage = exports.StreamDrawUsage = exports.StreamCopyUsage = exports.StaticReadUsage = exports.StaticDrawUsage = exports.StaticCopyUsage = exports.SrcColorFactor = exports.SrcAlphaSaturateFactor = exports.SrcAlphaFactor = exports.ShortType = exports.SRGBColorSpace = exports.SIGNED_RED_RGTC1_Format = exports.SIGNED_RED_GREEN_RGTC2_Format = exports.ReverseSubtractEquation = exports.ReplaceStencilOp = exports.RepeatWrapping = exports.ReinhardToneMapping = exports.RedIntegerFormat = exports.RedFormat = exports.RGIntegerFormat = exports.RGFormat = exports.RGB_S3TC_DXT1_Format = exports.RGB_PVRTC_4BPPV1_Format = exports.RGB_PVRTC_2BPPV1_Format = exports.RGB_ETC2_Format = exports.RGB_ETC1_Format = exports.RGB_BPTC_UNSIGNED_Format = exports.RGB_BPTC_SIGNED_Format = exports.RGBA_S3TC_DXT5_Format = exports.RGBA_S3TC_DXT3_Format = exports.RGBA_S3TC_DXT1_Format = exports.RGBA_PVRTC_4BPPV1_Format = exports.RGBA_PVRTC_2BPPV1_Format = exports.RGBA_ETC2_EAC_Format = exports.RGBA_BPTC_Format = exports.RGBA_ASTC_8x8_Format = exports.RGBA_ASTC_8x6_Format = exports.RGBA_ASTC_8x5_Format = exports.RGBA_ASTC_6x6_Format = exports.RGBA_ASTC_6x5_Format = exports.RGBA_ASTC_5x5_Format = exports.RGBA_ASTC_5x4_Format = exports.RGBA_ASTC_4x4_Format = exports.RGBA_ASTC_12x12_Format = exports.RGBA_ASTC_12x10_Format = exports.RGBA_ASTC_10x8_Format = exports.RGBA_ASTC_10x6_Format = exports.RGBA_ASTC_10x5_Format = exports.RGBA_ASTC_10x10_Format = exports.RGBAIntegerFormat = exports.RGBAFormat = exports.RGBADepthPacking = exports.REVISION = exports.RED_RGTC1_Format = exports.RED_GREEN_RGTC2_Format = exports.PCFSoftShadowMap = exports.PCFShadowMap = exports.OneMinusSrcColorFactor = exports.OneMinusSrcAlphaFactor = exports.OneMinusDstColorFactor = exports.OneMinusDstAlphaFactor = exports.OneFactor = exports.ObjectSpaceNormalMap = exports.NotEqualStencilFunc = exports.NotEqualDepth = void 0;
const REVISION = '156';
exports.REVISION = REVISION;
const MOUSE = {
  LEFT: 0,
  MIDDLE: 1,
  RIGHT: 2,
  ROTATE: 0,
  DOLLY: 1,
  PAN: 2
};
exports.MOUSE = MOUSE;
const TOUCH = {
  ROTATE: 0,
  PAN: 1,
  DOLLY_PAN: 2,
  DOLLY_ROTATE: 3
};
exports.TOUCH = TOUCH;
const CullFaceNone = 0;
exports.CullFaceNone = CullFaceNone;
const CullFaceBack = 1;
exports.CullFaceBack = CullFaceBack;
const CullFaceFront = 2;
exports.CullFaceFront = CullFaceFront;
const CullFaceFrontBack = 3;
exports.CullFaceFrontBack = CullFaceFrontBack;
const BasicShadowMap = 0;
exports.BasicShadowMap = BasicShadowMap;
const PCFShadowMap = 1;
exports.PCFShadowMap = PCFShadowMap;
const PCFSoftShadowMap = 2;
exports.PCFSoftShadowMap = PCFSoftShadowMap;
const VSMShadowMap = 3;
exports.VSMShadowMap = VSMShadowMap;
const FrontSide = 0;
exports.FrontSide = FrontSide;
const BackSide = 1;
exports.BackSide = BackSide;
const DoubleSide = 2;
exports.DoubleSide = DoubleSide;
const TwoPassDoubleSide = 2; // r149

exports.TwoPassDoubleSide = TwoPassDoubleSide;
const NoBlending = 0;
exports.NoBlending = NoBlending;
const NormalBlending = 1;
exports.NormalBlending = NormalBlending;
const AdditiveBlending = 2;
exports.AdditiveBlending = AdditiveBlending;
const SubtractiveBlending = 3;
exports.SubtractiveBlending = SubtractiveBlending;
const MultiplyBlending = 4;
exports.MultiplyBlending = MultiplyBlending;
const CustomBlending = 5;
exports.CustomBlending = CustomBlending;
const AddEquation = 100;
exports.AddEquation = AddEquation;
const SubtractEquation = 101;
exports.SubtractEquation = SubtractEquation;
const ReverseSubtractEquation = 102;
exports.ReverseSubtractEquation = ReverseSubtractEquation;
const MinEquation = 103;
exports.MinEquation = MinEquation;
const MaxEquation = 104;
exports.MaxEquation = MaxEquation;
const ZeroFactor = 200;
exports.ZeroFactor = ZeroFactor;
const OneFactor = 201;
exports.OneFactor = OneFactor;
const SrcColorFactor = 202;
exports.SrcColorFactor = SrcColorFactor;
const OneMinusSrcColorFactor = 203;
exports.OneMinusSrcColorFactor = OneMinusSrcColorFactor;
const SrcAlphaFactor = 204;
exports.SrcAlphaFactor = SrcAlphaFactor;
const OneMinusSrcAlphaFactor = 205;
exports.OneMinusSrcAlphaFactor = OneMinusSrcAlphaFactor;
const DstAlphaFactor = 206;
exports.DstAlphaFactor = DstAlphaFactor;
const OneMinusDstAlphaFactor = 207;
exports.OneMinusDstAlphaFactor = OneMinusDstAlphaFactor;
const DstColorFactor = 208;
exports.DstColorFactor = DstColorFactor;
const OneMinusDstColorFactor = 209;
exports.OneMinusDstColorFactor = OneMinusDstColorFactor;
const SrcAlphaSaturateFactor = 210;
exports.SrcAlphaSaturateFactor = SrcAlphaSaturateFactor;
const NeverDepth = 0;
exports.NeverDepth = NeverDepth;
const AlwaysDepth = 1;
exports.AlwaysDepth = AlwaysDepth;
const LessDepth = 2;
exports.LessDepth = LessDepth;
const LessEqualDepth = 3;
exports.LessEqualDepth = LessEqualDepth;
const EqualDepth = 4;
exports.EqualDepth = EqualDepth;
const GreaterEqualDepth = 5;
exports.GreaterEqualDepth = GreaterEqualDepth;
const GreaterDepth = 6;
exports.GreaterDepth = GreaterDepth;
const NotEqualDepth = 7;
exports.NotEqualDepth = NotEqualDepth;
const MultiplyOperation = 0;
exports.MultiplyOperation = MultiplyOperation;
const MixOperation = 1;
exports.MixOperation = MixOperation;
const AddOperation = 2;
exports.AddOperation = AddOperation;
const NoToneMapping = 0;
exports.NoToneMapping = NoToneMapping;
const LinearToneMapping = 1;
exports.LinearToneMapping = LinearToneMapping;
const ReinhardToneMapping = 2;
exports.ReinhardToneMapping = ReinhardToneMapping;
const CineonToneMapping = 3;
exports.CineonToneMapping = CineonToneMapping;
const ACESFilmicToneMapping = 4;
exports.ACESFilmicToneMapping = ACESFilmicToneMapping;
const CustomToneMapping = 5;
exports.CustomToneMapping = CustomToneMapping;
const UVMapping = 300;
exports.UVMapping = UVMapping;
const CubeReflectionMapping = 301;
exports.CubeReflectionMapping = CubeReflectionMapping;
const CubeRefractionMapping = 302;
exports.CubeRefractionMapping = CubeRefractionMapping;
const EquirectangularReflectionMapping = 303;
exports.EquirectangularReflectionMapping = EquirectangularReflectionMapping;
const EquirectangularRefractionMapping = 304;
exports.EquirectangularRefractionMapping = EquirectangularRefractionMapping;
const CubeUVReflectionMapping = 306;
exports.CubeUVReflectionMapping = CubeUVReflectionMapping;
const RepeatWrapping = 1000;
exports.RepeatWrapping = RepeatWrapping;
const ClampToEdgeWrapping = 1001;
exports.ClampToEdgeWrapping = ClampToEdgeWrapping;
const MirroredRepeatWrapping = 1002;
exports.MirroredRepeatWrapping = MirroredRepeatWrapping;
const NearestFilter = 1003;
exports.NearestFilter = NearestFilter;
const NearestMipmapNearestFilter = 1004;
exports.NearestMipmapNearestFilter = NearestMipmapNearestFilter;
const NearestMipMapNearestFilter = 1004;
exports.NearestMipMapNearestFilter = NearestMipMapNearestFilter;
const NearestMipmapLinearFilter = 1005;
exports.NearestMipmapLinearFilter = NearestMipmapLinearFilter;
const NearestMipMapLinearFilter = 1005;
exports.NearestMipMapLinearFilter = NearestMipMapLinearFilter;
const LinearFilter = 1006;
exports.LinearFilter = LinearFilter;
const LinearMipmapNearestFilter = 1007;
exports.LinearMipmapNearestFilter = LinearMipmapNearestFilter;
const LinearMipMapNearestFilter = 1007;
exports.LinearMipMapNearestFilter = LinearMipMapNearestFilter;
const LinearMipmapLinearFilter = 1008;
exports.LinearMipmapLinearFilter = LinearMipmapLinearFilter;
const LinearMipMapLinearFilter = 1008;
exports.LinearMipMapLinearFilter = LinearMipMapLinearFilter;
const UnsignedByteType = 1009;
exports.UnsignedByteType = UnsignedByteType;
const ByteType = 1010;
exports.ByteType = ByteType;
const ShortType = 1011;
exports.ShortType = ShortType;
const UnsignedShortType = 1012;
exports.UnsignedShortType = UnsignedShortType;
const IntType = 1013;
exports.IntType = IntType;
const UnsignedIntType = 1014;
exports.UnsignedIntType = UnsignedIntType;
const FloatType = 1015;
exports.FloatType = FloatType;
const HalfFloatType = 1016;
exports.HalfFloatType = HalfFloatType;
const UnsignedShort4444Type = 1017;
exports.UnsignedShort4444Type = UnsignedShort4444Type;
const UnsignedShort5551Type = 1018;
exports.UnsignedShort5551Type = UnsignedShort5551Type;
const UnsignedInt248Type = 1020;
exports.UnsignedInt248Type = UnsignedInt248Type;
const AlphaFormat = 1021;
exports.AlphaFormat = AlphaFormat;
const RGBAFormat = 1023;
exports.RGBAFormat = RGBAFormat;
const LuminanceFormat = 1024;
exports.LuminanceFormat = LuminanceFormat;
const LuminanceAlphaFormat = 1025;
exports.LuminanceAlphaFormat = LuminanceAlphaFormat;
const DepthFormat = 1026;
exports.DepthFormat = DepthFormat;
const DepthStencilFormat = 1027;
exports.DepthStencilFormat = DepthStencilFormat;
const RedFormat = 1028;
exports.RedFormat = RedFormat;
const RedIntegerFormat = 1029;
exports.RedIntegerFormat = RedIntegerFormat;
const RGFormat = 1030;
exports.RGFormat = RGFormat;
const RGIntegerFormat = 1031;
exports.RGIntegerFormat = RGIntegerFormat;
const RGBAIntegerFormat = 1033;
exports.RGBAIntegerFormat = RGBAIntegerFormat;
const RGB_S3TC_DXT1_Format = 33776;
exports.RGB_S3TC_DXT1_Format = RGB_S3TC_DXT1_Format;
const RGBA_S3TC_DXT1_Format = 33777;
exports.RGBA_S3TC_DXT1_Format = RGBA_S3TC_DXT1_Format;
const RGBA_S3TC_DXT3_Format = 33778;
exports.RGBA_S3TC_DXT3_Format = RGBA_S3TC_DXT3_Format;
const RGBA_S3TC_DXT5_Format = 33779;
exports.RGBA_S3TC_DXT5_Format = RGBA_S3TC_DXT5_Format;
const RGB_PVRTC_4BPPV1_Format = 35840;
exports.RGB_PVRTC_4BPPV1_Format = RGB_PVRTC_4BPPV1_Format;
const RGB_PVRTC_2BPPV1_Format = 35841;
exports.RGB_PVRTC_2BPPV1_Format = RGB_PVRTC_2BPPV1_Format;
const RGBA_PVRTC_4BPPV1_Format = 35842;
exports.RGBA_PVRTC_4BPPV1_Format = RGBA_PVRTC_4BPPV1_Format;
const RGBA_PVRTC_2BPPV1_Format = 35843;
exports.RGBA_PVRTC_2BPPV1_Format = RGBA_PVRTC_2BPPV1_Format;
const RGB_ETC1_Format = 36196;
exports.RGB_ETC1_Format = RGB_ETC1_Format;
const RGB_ETC2_Format = 37492;
exports.RGB_ETC2_Format = RGB_ETC2_Format;
const RGBA_ETC2_EAC_Format = 37496;
exports.RGBA_ETC2_EAC_Format = RGBA_ETC2_EAC_Format;
const RGBA_ASTC_4x4_Format = 37808;
exports.RGBA_ASTC_4x4_Format = RGBA_ASTC_4x4_Format;
const RGBA_ASTC_5x4_Format = 37809;
exports.RGBA_ASTC_5x4_Format = RGBA_ASTC_5x4_Format;
const RGBA_ASTC_5x5_Format = 37810;
exports.RGBA_ASTC_5x5_Format = RGBA_ASTC_5x5_Format;
const RGBA_ASTC_6x5_Format = 37811;
exports.RGBA_ASTC_6x5_Format = RGBA_ASTC_6x5_Format;
const RGBA_ASTC_6x6_Format = 37812;
exports.RGBA_ASTC_6x6_Format = RGBA_ASTC_6x6_Format;
const RGBA_ASTC_8x5_Format = 37813;
exports.RGBA_ASTC_8x5_Format = RGBA_ASTC_8x5_Format;
const RGBA_ASTC_8x6_Format = 37814;
exports.RGBA_ASTC_8x6_Format = RGBA_ASTC_8x6_Format;
const RGBA_ASTC_8x8_Format = 37815;
exports.RGBA_ASTC_8x8_Format = RGBA_ASTC_8x8_Format;
const RGBA_ASTC_10x5_Format = 37816;
exports.RGBA_ASTC_10x5_Format = RGBA_ASTC_10x5_Format;
const RGBA_ASTC_10x6_Format = 37817;
exports.RGBA_ASTC_10x6_Format = RGBA_ASTC_10x6_Format;
const RGBA_ASTC_10x8_Format = 37818;
exports.RGBA_ASTC_10x8_Format = RGBA_ASTC_10x8_Format;
const RGBA_ASTC_10x10_Format = 37819;
exports.RGBA_ASTC_10x10_Format = RGBA_ASTC_10x10_Format;
const RGBA_ASTC_12x10_Format = 37820;
exports.RGBA_ASTC_12x10_Format = RGBA_ASTC_12x10_Format;
const RGBA_ASTC_12x12_Format = 37821;
exports.RGBA_ASTC_12x12_Format = RGBA_ASTC_12x12_Format;
const RGBA_BPTC_Format = 36492;
exports.RGBA_BPTC_Format = RGBA_BPTC_Format;
const RGB_BPTC_SIGNED_Format = 36494;
exports.RGB_BPTC_SIGNED_Format = RGB_BPTC_SIGNED_Format;
const RGB_BPTC_UNSIGNED_Format = 36495;
exports.RGB_BPTC_UNSIGNED_Format = RGB_BPTC_UNSIGNED_Format;
const RED_RGTC1_Format = 36283;
exports.RED_RGTC1_Format = RED_RGTC1_Format;
const SIGNED_RED_RGTC1_Format = 36284;
exports.SIGNED_RED_RGTC1_Format = SIGNED_RED_RGTC1_Format;
const RED_GREEN_RGTC2_Format = 36285;
exports.RED_GREEN_RGTC2_Format = RED_GREEN_RGTC2_Format;
const SIGNED_RED_GREEN_RGTC2_Format = 36286;
exports.SIGNED_RED_GREEN_RGTC2_Format = SIGNED_RED_GREEN_RGTC2_Format;
const LoopOnce = 2200;
exports.LoopOnce = LoopOnce;
const LoopRepeat = 2201;
exports.LoopRepeat = LoopRepeat;
const LoopPingPong = 2202;
exports.LoopPingPong = LoopPingPong;
const InterpolateDiscrete = 2300;
exports.InterpolateDiscrete = InterpolateDiscrete;
const InterpolateLinear = 2301;
exports.InterpolateLinear = InterpolateLinear;
const InterpolateSmooth = 2302;
exports.InterpolateSmooth = InterpolateSmooth;
const ZeroCurvatureEnding = 2400;
exports.ZeroCurvatureEnding = ZeroCurvatureEnding;
const ZeroSlopeEnding = 2401;
exports.ZeroSlopeEnding = ZeroSlopeEnding;
const WrapAroundEnding = 2402;
exports.WrapAroundEnding = WrapAroundEnding;
const NormalAnimationBlendMode = 2500;
exports.NormalAnimationBlendMode = NormalAnimationBlendMode;
const AdditiveAnimationBlendMode = 2501;
exports.AdditiveAnimationBlendMode = AdditiveAnimationBlendMode;
const TrianglesDrawMode = 0;
exports.TrianglesDrawMode = TrianglesDrawMode;
const TriangleStripDrawMode = 1;
exports.TriangleStripDrawMode = TriangleStripDrawMode;
const TriangleFanDrawMode = 2;
/** @deprecated Use LinearSRGBColorSpace or NoColorSpace in three.js r152+. */

exports.TriangleFanDrawMode = TriangleFanDrawMode;
const LinearEncoding = 3000;
/** @deprecated Use SRGBColorSpace in three.js r152+. */

exports.LinearEncoding = LinearEncoding;
const sRGBEncoding = 3001;
exports.sRGBEncoding = sRGBEncoding;
const BasicDepthPacking = 3200;
exports.BasicDepthPacking = BasicDepthPacking;
const RGBADepthPacking = 3201;
exports.RGBADepthPacking = RGBADepthPacking;
const TangentSpaceNormalMap = 0;
exports.TangentSpaceNormalMap = TangentSpaceNormalMap;
const ObjectSpaceNormalMap = 1; // Color space string identifiers, matching CSS Color Module Level 4 and WebGPU names where available.

exports.ObjectSpaceNormalMap = ObjectSpaceNormalMap;
const NoColorSpace = '';
exports.NoColorSpace = NoColorSpace;
const SRGBColorSpace = 'srgb';
exports.SRGBColorSpace = SRGBColorSpace;
const LinearSRGBColorSpace = 'srgb-linear';
exports.LinearSRGBColorSpace = LinearSRGBColorSpace;
const DisplayP3ColorSpace = 'display-p3';
exports.DisplayP3ColorSpace = DisplayP3ColorSpace;
const LinearDisplayP3ColorSpace = 'display-p3-linear';
exports.LinearDisplayP3ColorSpace = LinearDisplayP3ColorSpace;
const ZeroStencilOp = 0;
exports.ZeroStencilOp = ZeroStencilOp;
const KeepStencilOp = 7680;
exports.KeepStencilOp = KeepStencilOp;
const ReplaceStencilOp = 7681;
exports.ReplaceStencilOp = ReplaceStencilOp;
const IncrementStencilOp = 7682;
exports.IncrementStencilOp = IncrementStencilOp;
const DecrementStencilOp = 7683;
exports.DecrementStencilOp = DecrementStencilOp;
const IncrementWrapStencilOp = 34055;
exports.IncrementWrapStencilOp = IncrementWrapStencilOp;
const DecrementWrapStencilOp = 34056;
exports.DecrementWrapStencilOp = DecrementWrapStencilOp;
const InvertStencilOp = 5386;
exports.InvertStencilOp = InvertStencilOp;
const NeverStencilFunc = 512;
exports.NeverStencilFunc = NeverStencilFunc;
const LessStencilFunc = 513;
exports.LessStencilFunc = LessStencilFunc;
const EqualStencilFunc = 514;
exports.EqualStencilFunc = EqualStencilFunc;
const LessEqualStencilFunc = 515;
exports.LessEqualStencilFunc = LessEqualStencilFunc;
const GreaterStencilFunc = 516;
exports.GreaterStencilFunc = GreaterStencilFunc;
const NotEqualStencilFunc = 517;
exports.NotEqualStencilFunc = NotEqualStencilFunc;
const GreaterEqualStencilFunc = 518;
exports.GreaterEqualStencilFunc = GreaterEqualStencilFunc;
const AlwaysStencilFunc = 519;
exports.AlwaysStencilFunc = AlwaysStencilFunc;
const NeverCompare = 512;
exports.NeverCompare = NeverCompare;
const LessCompare = 513;
exports.LessCompare = LessCompare;
const EqualCompare = 514;
exports.EqualCompare = EqualCompare;
const LessEqualCompare = 515;
exports.LessEqualCompare = LessEqualCompare;
const GreaterCompare = 516;
exports.GreaterCompare = GreaterCompare;
const NotEqualCompare = 517;
exports.NotEqualCompare = NotEqualCompare;
const GreaterEqualCompare = 518;
exports.GreaterEqualCompare = GreaterEqualCompare;
const AlwaysCompare = 519;
exports.AlwaysCompare = AlwaysCompare;
const StaticDrawUsage = 35044;
exports.StaticDrawUsage = StaticDrawUsage;
const DynamicDrawUsage = 35048;
exports.DynamicDrawUsage = DynamicDrawUsage;
const StreamDrawUsage = 35040;
exports.StreamDrawUsage = StreamDrawUsage;
const StaticReadUsage = 35045;
exports.StaticReadUsage = StaticReadUsage;
const DynamicReadUsage = 35049;
exports.DynamicReadUsage = DynamicReadUsage;
const StreamReadUsage = 35041;
exports.StreamReadUsage = StreamReadUsage;
const StaticCopyUsage = 35046;
exports.StaticCopyUsage = StaticCopyUsage;
const DynamicCopyUsage = 35050;
exports.DynamicCopyUsage = DynamicCopyUsage;
const StreamCopyUsage = 35042;
exports.StreamCopyUsage = StreamCopyUsage;
const GLSL1 = '100';
exports.GLSL1 = GLSL1;
const GLSL3 = '300 es';
exports.GLSL3 = GLSL3;
const _SRGBAFormat = 1035; // fallback for WebGL 1

exports._SRGBAFormat = _SRGBAFormat;
const WebGLCoordinateSystem = 2000;
exports.WebGLCoordinateSystem = WebGLCoordinateSystem;
const WebGPUCoordinateSystem = 2001;
exports.WebGPUCoordinateSystem = WebGPUCoordinateSystem;

},{}],120:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Uint8ClampedBufferAttribute = exports.Uint8BufferAttribute = exports.Uint32BufferAttribute = exports.Uint16BufferAttribute = exports.Int8BufferAttribute = exports.Int32BufferAttribute = exports.Int16BufferAttribute = exports.Float64BufferAttribute = exports.Float32BufferAttribute = exports.Float16BufferAttribute = exports.BufferAttribute = void 0;

var _Vector = require("../math/Vector3.js");

var _Vector2 = require("../math/Vector2.js");

var _MathUtils = require("../math/MathUtils.js");

var _constants = require("../constants.js");

var _DataUtils = require("../extras/DataUtils.js");

const _vector = /*@__PURE__*/new _Vector.Vector3();

const _vector2 = /*@__PURE__*/new _Vector2.Vector2();

class BufferAttribute {
  constructor(array, itemSize, normalized = false) {
    if (Array.isArray(array)) {
      throw new TypeError('THREE.BufferAttribute: array should be a Typed Array.');
    }

    this.isBufferAttribute = true;
    this.name = '';
    this.array = array;
    this.itemSize = itemSize;
    this.count = array !== undefined ? array.length / itemSize : 0;
    this.normalized = normalized;
    this.usage = _constants.StaticDrawUsage;
    this.updateRange = {
      offset: 0,
      count: -1
    };
    this.gpuType = _constants.FloatType;
    this.version = 0;
  }

  onUploadCallback() {}

  set needsUpdate(value) {
    if (value === true) this.version++;
  }

  setUsage(value) {
    this.usage = value;
    return this;
  }

  copy(source) {
    this.name = source.name;
    this.array = new source.array.constructor(source.array);
    this.itemSize = source.itemSize;
    this.count = source.count;
    this.normalized = source.normalized;
    this.usage = source.usage;
    this.gpuType = source.gpuType;
    return this;
  }

  copyAt(index1, attribute, index2) {
    index1 *= this.itemSize;
    index2 *= attribute.itemSize;

    for (let i = 0, l = this.itemSize; i < l; i++) {
      this.array[index1 + i] = attribute.array[index2 + i];
    }

    return this;
  }

  copyArray(array) {
    this.array.set(array);
    return this;
  }

  applyMatrix3(m) {
    if (this.itemSize === 2) {
      for (let i = 0, l = this.count; i < l; i++) {
        _vector2.fromBufferAttribute(this, i);

        _vector2.applyMatrix3(m);

        this.setXY(i, _vector2.x, _vector2.y);
      }
    } else if (this.itemSize === 3) {
      for (let i = 0, l = this.count; i < l; i++) {
        _vector.fromBufferAttribute(this, i);

        _vector.applyMatrix3(m);

        this.setXYZ(i, _vector.x, _vector.y, _vector.z);
      }
    }

    return this;
  }

  applyMatrix4(m) {
    for (let i = 0, l = this.count; i < l; i++) {
      _vector.fromBufferAttribute(this, i);

      _vector.applyMatrix4(m);

      this.setXYZ(i, _vector.x, _vector.y, _vector.z);
    }

    return this;
  }

  applyNormalMatrix(m) {
    for (let i = 0, l = this.count; i < l; i++) {
      _vector.fromBufferAttribute(this, i);

      _vector.applyNormalMatrix(m);

      this.setXYZ(i, _vector.x, _vector.y, _vector.z);
    }

    return this;
  }

  transformDirection(m) {
    for (let i = 0, l = this.count; i < l; i++) {
      _vector.fromBufferAttribute(this, i);

      _vector.transformDirection(m);

      this.setXYZ(i, _vector.x, _vector.y, _vector.z);
    }

    return this;
  }

  set(value, offset = 0) {
    // Matching BufferAttribute constructor, do not normalize the array.
    this.array.set(value, offset);
    return this;
  }

  getComponent(index, component) {
    let value = this.array[index * this.itemSize + component];
    if (this.normalized) value = (0, _MathUtils.denormalize)(value, this.array);
    return value;
  }

  setComponent(index, component, value) {
    if (this.normalized) value = (0, _MathUtils.normalize)(value, this.array);
    this.array[index * this.itemSize + component] = value;
    return this;
  }

  getX(index) {
    let x = this.array[index * this.itemSize];
    if (this.normalized) x = (0, _MathUtils.denormalize)(x, this.array);
    return x;
  }

  setX(index, x) {
    if (this.normalized) x = (0, _MathUtils.normalize)(x, this.array);
    this.array[index * this.itemSize] = x;
    return this;
  }

  getY(index) {
    let y = this.array[index * this.itemSize + 1];
    if (this.normalized) y = (0, _MathUtils.denormalize)(y, this.array);
    return y;
  }

  setY(index, y) {
    if (this.normalized) y = (0, _MathUtils.normalize)(y, this.array);
    this.array[index * this.itemSize + 1] = y;
    return this;
  }

  getZ(index) {
    let z = this.array[index * this.itemSize + 2];
    if (this.normalized) z = (0, _MathUtils.denormalize)(z, this.array);
    return z;
  }

  setZ(index, z) {
    if (this.normalized) z = (0, _MathUtils.normalize)(z, this.array);
    this.array[index * this.itemSize + 2] = z;
    return this;
  }

  getW(index) {
    let w = this.array[index * this.itemSize + 3];
    if (this.normalized) w = (0, _MathUtils.denormalize)(w, this.array);
    return w;
  }

  setW(index, w) {
    if (this.normalized) w = (0, _MathUtils.normalize)(w, this.array);
    this.array[index * this.itemSize + 3] = w;
    return this;
  }

  setXY(index, x, y) {
    index *= this.itemSize;

    if (this.normalized) {
      x = (0, _MathUtils.normalize)(x, this.array);
      y = (0, _MathUtils.normalize)(y, this.array);
    }

    this.array[index + 0] = x;
    this.array[index + 1] = y;
    return this;
  }

  setXYZ(index, x, y, z) {
    index *= this.itemSize;

    if (this.normalized) {
      x = (0, _MathUtils.normalize)(x, this.array);
      y = (0, _MathUtils.normalize)(y, this.array);
      z = (0, _MathUtils.normalize)(z, this.array);
    }

    this.array[index + 0] = x;
    this.array[index + 1] = y;
    this.array[index + 2] = z;
    return this;
  }

  setXYZW(index, x, y, z, w) {
    index *= this.itemSize;

    if (this.normalized) {
      x = (0, _MathUtils.normalize)(x, this.array);
      y = (0, _MathUtils.normalize)(y, this.array);
      z = (0, _MathUtils.normalize)(z, this.array);
      w = (0, _MathUtils.normalize)(w, this.array);
    }

    this.array[index + 0] = x;
    this.array[index + 1] = y;
    this.array[index + 2] = z;
    this.array[index + 3] = w;
    return this;
  }

  onUpload(callback) {
    this.onUploadCallback = callback;
    return this;
  }

  clone() {
    return new this.constructor(this.array, this.itemSize).copy(this);
  }

  toJSON() {
    const data = {
      itemSize: this.itemSize,
      type: this.array.constructor.name,
      array: Array.from(this.array),
      normalized: this.normalized
    };
    if (this.name !== '') data.name = this.name;
    if (this.usage !== _constants.StaticDrawUsage) data.usage = this.usage;
    if (this.updateRange.offset !== 0 || this.updateRange.count !== -1) data.updateRange = this.updateRange;
    return data;
  }

} //


exports.BufferAttribute = BufferAttribute;

class Int8BufferAttribute extends BufferAttribute {
  constructor(array, itemSize, normalized) {
    super(new Int8Array(array), itemSize, normalized);
  }

}

exports.Int8BufferAttribute = Int8BufferAttribute;

class Uint8BufferAttribute extends BufferAttribute {
  constructor(array, itemSize, normalized) {
    super(new Uint8Array(array), itemSize, normalized);
  }

}

exports.Uint8BufferAttribute = Uint8BufferAttribute;

class Uint8ClampedBufferAttribute extends BufferAttribute {
  constructor(array, itemSize, normalized) {
    super(new Uint8ClampedArray(array), itemSize, normalized);
  }

}

exports.Uint8ClampedBufferAttribute = Uint8ClampedBufferAttribute;

class Int16BufferAttribute extends BufferAttribute {
  constructor(array, itemSize, normalized) {
    super(new Int16Array(array), itemSize, normalized);
  }

}

exports.Int16BufferAttribute = Int16BufferAttribute;

class Uint16BufferAttribute extends BufferAttribute {
  constructor(array, itemSize, normalized) {
    super(new Uint16Array(array), itemSize, normalized);
  }

}

exports.Uint16BufferAttribute = Uint16BufferAttribute;

class Int32BufferAttribute extends BufferAttribute {
  constructor(array, itemSize, normalized) {
    super(new Int32Array(array), itemSize, normalized);
  }

}

exports.Int32BufferAttribute = Int32BufferAttribute;

class Uint32BufferAttribute extends BufferAttribute {
  constructor(array, itemSize, normalized) {
    super(new Uint32Array(array), itemSize, normalized);
  }

}

exports.Uint32BufferAttribute = Uint32BufferAttribute;

class Float16BufferAttribute extends BufferAttribute {
  constructor(array, itemSize, normalized) {
    super(new Uint16Array(array), itemSize, normalized);
    this.isFloat16BufferAttribute = true;
  }

  getX(index) {
    let x = (0, _DataUtils.fromHalfFloat)(this.array[index * this.itemSize]);
    if (this.normalized) x = (0, _MathUtils.denormalize)(x, this.array);
    return x;
  }

  setX(index, x) {
    if (this.normalized) x = (0, _MathUtils.normalize)(x, this.array);
    this.array[index * this.itemSize] = (0, _DataUtils.toHalfFloat)(x);
    return this;
  }

  getY(index) {
    let y = (0, _DataUtils.fromHalfFloat)(this.array[index * this.itemSize + 1]);
    if (this.normalized) y = (0, _MathUtils.denormalize)(y, this.array);
    return y;
  }

  setY(index, y) {
    if (this.normalized) y = (0, _MathUtils.normalize)(y, this.array);
    this.array[index * this.itemSize + 1] = (0, _DataUtils.toHalfFloat)(y);
    return this;
  }

  getZ(index) {
    let z = (0, _DataUtils.fromHalfFloat)(this.array[index * this.itemSize + 2]);
    if (this.normalized) z = (0, _MathUtils.denormalize)(z, this.array);
    return z;
  }

  setZ(index, z) {
    if (this.normalized) z = (0, _MathUtils.normalize)(z, this.array);
    this.array[index * this.itemSize + 2] = (0, _DataUtils.toHalfFloat)(z);
    return this;
  }

  getW(index) {
    let w = (0, _DataUtils.fromHalfFloat)(this.array[index * this.itemSize + 3]);
    if (this.normalized) w = (0, _MathUtils.denormalize)(w, this.array);
    return w;
  }

  setW(index, w) {
    if (this.normalized) w = (0, _MathUtils.normalize)(w, this.array);
    this.array[index * this.itemSize + 3] = (0, _DataUtils.toHalfFloat)(w);
    return this;
  }

  setXY(index, x, y) {
    index *= this.itemSize;

    if (this.normalized) {
      x = (0, _MathUtils.normalize)(x, this.array);
      y = (0, _MathUtils.normalize)(y, this.array);
    }

    this.array[index + 0] = (0, _DataUtils.toHalfFloat)(x);
    this.array[index + 1] = (0, _DataUtils.toHalfFloat)(y);
    return this;
  }

  setXYZ(index, x, y, z) {
    index *= this.itemSize;

    if (this.normalized) {
      x = (0, _MathUtils.normalize)(x, this.array);
      y = (0, _MathUtils.normalize)(y, this.array);
      z = (0, _MathUtils.normalize)(z, this.array);
    }

    this.array[index + 0] = (0, _DataUtils.toHalfFloat)(x);
    this.array[index + 1] = (0, _DataUtils.toHalfFloat)(y);
    this.array[index + 2] = (0, _DataUtils.toHalfFloat)(z);
    return this;
  }

  setXYZW(index, x, y, z, w) {
    index *= this.itemSize;

    if (this.normalized) {
      x = (0, _MathUtils.normalize)(x, this.array);
      y = (0, _MathUtils.normalize)(y, this.array);
      z = (0, _MathUtils.normalize)(z, this.array);
      w = (0, _MathUtils.normalize)(w, this.array);
    }

    this.array[index + 0] = (0, _DataUtils.toHalfFloat)(x);
    this.array[index + 1] = (0, _DataUtils.toHalfFloat)(y);
    this.array[index + 2] = (0, _DataUtils.toHalfFloat)(z);
    this.array[index + 3] = (0, _DataUtils.toHalfFloat)(w);
    return this;
  }

}

exports.Float16BufferAttribute = Float16BufferAttribute;

class Float32BufferAttribute extends BufferAttribute {
  constructor(array, itemSize, normalized) {
    super(new Float32Array(array), itemSize, normalized);
  }

}

exports.Float32BufferAttribute = Float32BufferAttribute;

class Float64BufferAttribute extends BufferAttribute {
  constructor(array, itemSize, normalized) {
    super(new Float64Array(array), itemSize, normalized);
  }

} //


exports.Float64BufferAttribute = Float64BufferAttribute;

},{"../constants.js":119,"../extras/DataUtils.js":125,"../math/MathUtils.js":168,"../math/Vector2.js":174,"../math/Vector3.js":175}],121:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BufferGeometry = void 0;

var _Vector = require("../math/Vector3.js");

var _Vector2 = require("../math/Vector2.js");

var _Box = require("../math/Box3.js");

var _EventDispatcher = require("./EventDispatcher.js");

var _BufferAttribute = require("./BufferAttribute.js");

var _Sphere = require("../math/Sphere.js");

var _Object3D = require("./Object3D.js");

var _Matrix = require("../math/Matrix4.js");

var _Matrix2 = require("../math/Matrix3.js");

var MathUtils = _interopRequireWildcard(require("../math/MathUtils.js"));

var _utils = require("../utils.js");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

let _id = 0;

const _m1 = /*@__PURE__*/new _Matrix.Matrix4();

const _obj = /*@__PURE__*/new _Object3D.Object3D();

const _offset = /*@__PURE__*/new _Vector.Vector3();

const _box = /*@__PURE__*/new _Box.Box3();

const _boxMorphTargets = /*@__PURE__*/new _Box.Box3();

const _vector = /*@__PURE__*/new _Vector.Vector3();

class BufferGeometry extends _EventDispatcher.EventDispatcher {
  constructor() {
    super();
    this.isBufferGeometry = true;
    Object.defineProperty(this, 'id', {
      value: _id++
    });
    this.uuid = MathUtils.generateUUID();
    this.name = '';
    this.type = 'BufferGeometry';
    this.index = null;
    this.attributes = {};
    this.morphAttributes = {};
    this.morphTargetsRelative = false;
    this.groups = [];
    this.boundingBox = null;
    this.boundingSphere = null;
    this.drawRange = {
      start: 0,
      count: Infinity
    };
    this.userData = {};
  }

  getIndex() {
    return this.index;
  }

  setIndex(index) {
    if (Array.isArray(index)) {
      this.index = new ((0, _utils.arrayNeedsUint32)(index) ? _BufferAttribute.Uint32BufferAttribute : _BufferAttribute.Uint16BufferAttribute)(index, 1);
    } else {
      this.index = index;
    }

    return this;
  }

  getAttribute(name) {
    return this.attributes[name];
  }

  setAttribute(name, attribute) {
    this.attributes[name] = attribute;
    return this;
  }

  deleteAttribute(name) {
    delete this.attributes[name];
    return this;
  }

  hasAttribute(name) {
    return this.attributes[name] !== undefined;
  }

  addGroup(start, count, materialIndex = 0) {
    this.groups.push({
      start: start,
      count: count,
      materialIndex: materialIndex
    });
  }

  clearGroups() {
    this.groups = [];
  }

  setDrawRange(start, count) {
    this.drawRange.start = start;
    this.drawRange.count = count;
  }

  applyMatrix4(matrix) {
    const position = this.attributes.position;

    if (position !== undefined) {
      position.applyMatrix4(matrix);
      position.needsUpdate = true;
    }

    const normal = this.attributes.normal;

    if (normal !== undefined) {
      const normalMatrix = new _Matrix2.Matrix3().getNormalMatrix(matrix);
      normal.applyNormalMatrix(normalMatrix);
      normal.needsUpdate = true;
    }

    const tangent = this.attributes.tangent;

    if (tangent !== undefined) {
      tangent.transformDirection(matrix);
      tangent.needsUpdate = true;
    }

    if (this.boundingBox !== null) {
      this.computeBoundingBox();
    }

    if (this.boundingSphere !== null) {
      this.computeBoundingSphere();
    }

    return this;
  }

  applyQuaternion(q) {
    _m1.makeRotationFromQuaternion(q);

    this.applyMatrix4(_m1);
    return this;
  }

  rotateX(angle) {
    // rotate geometry around world x-axis
    _m1.makeRotationX(angle);

    this.applyMatrix4(_m1);
    return this;
  }

  rotateY(angle) {
    // rotate geometry around world y-axis
    _m1.makeRotationY(angle);

    this.applyMatrix4(_m1);
    return this;
  }

  rotateZ(angle) {
    // rotate geometry around world z-axis
    _m1.makeRotationZ(angle);

    this.applyMatrix4(_m1);
    return this;
  }

  translate(x, y, z) {
    // translate geometry
    _m1.makeTranslation(x, y, z);

    this.applyMatrix4(_m1);
    return this;
  }

  scale(x, y, z) {
    // scale geometry
    _m1.makeScale(x, y, z);

    this.applyMatrix4(_m1);
    return this;
  }

  lookAt(vector) {
    _obj.lookAt(vector);

    _obj.updateMatrix();

    this.applyMatrix4(_obj.matrix);
    return this;
  }

  center() {
    this.computeBoundingBox();
    this.boundingBox.getCenter(_offset).negate();
    this.translate(_offset.x, _offset.y, _offset.z);
    return this;
  }

  setFromPoints(points) {
    const position = [];

    for (let i = 0, l = points.length; i < l; i++) {
      const point = points[i];
      position.push(point.x, point.y, point.z || 0);
    }

    this.setAttribute('position', new _BufferAttribute.Float32BufferAttribute(position, 3));
    return this;
  }

  computeBoundingBox() {
    if (this.boundingBox === null) {
      this.boundingBox = new _Box.Box3();
    }

    const position = this.attributes.position;
    const morphAttributesPosition = this.morphAttributes.position;

    if (position && position.isGLBufferAttribute) {
      console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this);
      this.boundingBox.set(new _Vector.Vector3(-Infinity, -Infinity, -Infinity), new _Vector.Vector3(+Infinity, +Infinity, +Infinity));
      return;
    }

    if (position !== undefined) {
      this.boundingBox.setFromBufferAttribute(position); // process morph attributes if present

      if (morphAttributesPosition) {
        for (let i = 0, il = morphAttributesPosition.length; i < il; i++) {
          const morphAttribute = morphAttributesPosition[i];

          _box.setFromBufferAttribute(morphAttribute);

          if (this.morphTargetsRelative) {
            _vector.addVectors(this.boundingBox.min, _box.min);

            this.boundingBox.expandByPoint(_vector);

            _vector.addVectors(this.boundingBox.max, _box.max);

            this.boundingBox.expandByPoint(_vector);
          } else {
            this.boundingBox.expandByPoint(_box.min);
            this.boundingBox.expandByPoint(_box.max);
          }
        }
      }
    } else {
      this.boundingBox.makeEmpty();
    }

    if (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) {
      console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
    }
  }

  computeBoundingSphere() {
    if (this.boundingSphere === null) {
      this.boundingSphere = new _Sphere.Sphere();
    }

    const position = this.attributes.position;
    const morphAttributesPosition = this.morphAttributes.position;

    if (position && position.isGLBufferAttribute) {
      console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this);
      this.boundingSphere.set(new _Vector.Vector3(), Infinity);
      return;
    }

    if (position) {
      // first, find the center of the bounding sphere
      const center = this.boundingSphere.center;

      _box.setFromBufferAttribute(position); // process morph attributes if present


      if (morphAttributesPosition) {
        for (let i = 0, il = morphAttributesPosition.length; i < il; i++) {
          const morphAttribute = morphAttributesPosition[i];

          _boxMorphTargets.setFromBufferAttribute(morphAttribute);

          if (this.morphTargetsRelative) {
            _vector.addVectors(_box.min, _boxMorphTargets.min);

            _box.expandByPoint(_vector);

            _vector.addVectors(_box.max, _boxMorphTargets.max);

            _box.expandByPoint(_vector);
          } else {
            _box.expandByPoint(_boxMorphTargets.min);

            _box.expandByPoint(_boxMorphTargets.max);
          }
        }
      }

      _box.getCenter(center); // second, try to find a boundingSphere with a radius smaller than the
      // boundingSphere of the boundingBox: sqrt(3) smaller in the best case


      let maxRadiusSq = 0;

      for (let i = 0, il = position.count; i < il; i++) {
        _vector.fromBufferAttribute(position, i);

        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector));
      } // process morph attributes if present


      if (morphAttributesPosition) {
        for (let i = 0, il = morphAttributesPosition.length; i < il; i++) {
          const morphAttribute = morphAttributesPosition[i];
          const morphTargetsRelative = this.morphTargetsRelative;

          for (let j = 0, jl = morphAttribute.count; j < jl; j++) {
            _vector.fromBufferAttribute(morphAttribute, j);

            if (morphTargetsRelative) {
              _offset.fromBufferAttribute(position, j);

              _vector.add(_offset);
            }

            maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector));
          }
        }
      }

      this.boundingSphere.radius = Math.sqrt(maxRadiusSq);

      if (isNaN(this.boundingSphere.radius)) {
        console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
      }
    }
  }

  computeTangents() {
    const index = this.index;
    const attributes = this.attributes; // based on http://www.terathon.com/code/tangent.html
    // (per vertex tangents)

    if (index === null || attributes.position === undefined || attributes.normal === undefined || attributes.uv === undefined) {
      console.error('THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)');
      return;
    }

    const indices = index.array;
    const positions = attributes.position.array;
    const normals = attributes.normal.array;
    const uvs = attributes.uv.array;
    const nVertices = positions.length / 3;

    if (this.hasAttribute('tangent') === false) {
      this.setAttribute('tangent', new _BufferAttribute.BufferAttribute(new Float32Array(4 * nVertices), 4));
    }

    const tangents = this.getAttribute('tangent').array;
    const tan1 = [],
          tan2 = [];

    for (let i = 0; i < nVertices; i++) {
      tan1[i] = new _Vector.Vector3();
      tan2[i] = new _Vector.Vector3();
    }

    const vA = new _Vector.Vector3(),
          vB = new _Vector.Vector3(),
          vC = new _Vector.Vector3(),
          uvA = new _Vector2.Vector2(),
          uvB = new _Vector2.Vector2(),
          uvC = new _Vector2.Vector2(),
          sdir = new _Vector.Vector3(),
          tdir = new _Vector.Vector3();

    function handleTriangle(a, b, c) {
      vA.fromArray(positions, a * 3);
      vB.fromArray(positions, b * 3);
      vC.fromArray(positions, c * 3);
      uvA.fromArray(uvs, a * 2);
      uvB.fromArray(uvs, b * 2);
      uvC.fromArray(uvs, c * 2);
      vB.sub(vA);
      vC.sub(vA);
      uvB.sub(uvA);
      uvC.sub(uvA);
      const r = 1.0 / (uvB.x * uvC.y - uvC.x * uvB.y); // silently ignore degenerate uv triangles having coincident or colinear vertices

      if (!isFinite(r)) return;
      sdir.copy(vB).multiplyScalar(uvC.y).addScaledVector(vC, -uvB.y).multiplyScalar(r);
      tdir.copy(vC).multiplyScalar(uvB.x).addScaledVector(vB, -uvC.x).multiplyScalar(r);
      tan1[a].add(sdir);
      tan1[b].add(sdir);
      tan1[c].add(sdir);
      tan2[a].add(tdir);
      tan2[b].add(tdir);
      tan2[c].add(tdir);
    }

    let groups = this.groups;

    if (groups.length === 0) {
      groups = [{
        start: 0,
        count: indices.length
      }];
    }

    for (let i = 0, il = groups.length; i < il; ++i) {
      const group = groups[i];
      const start = group.start;
      const count = group.count;

      for (let j = start, jl = start + count; j < jl; j += 3) {
        handleTriangle(indices[j + 0], indices[j + 1], indices[j + 2]);
      }
    }

    const tmp = new _Vector.Vector3(),
          tmp2 = new _Vector.Vector3();
    const n = new _Vector.Vector3(),
          n2 = new _Vector.Vector3();

    function handleVertex(v) {
      n.fromArray(normals, v * 3);
      n2.copy(n);
      const t = tan1[v]; // Gram-Schmidt orthogonalize

      tmp.copy(t);
      tmp.sub(n.multiplyScalar(n.dot(t))).normalize(); // Calculate handedness

      tmp2.crossVectors(n2, t);
      const test = tmp2.dot(tan2[v]);
      const w = test < 0.0 ? -1.0 : 1.0;
      tangents[v * 4] = tmp.x;
      tangents[v * 4 + 1] = tmp.y;
      tangents[v * 4 + 2] = tmp.z;
      tangents[v * 4 + 3] = w;
    }

    for (let i = 0, il = groups.length; i < il; ++i) {
      const group = groups[i];
      const start = group.start;
      const count = group.count;

      for (let j = start, jl = start + count; j < jl; j += 3) {
        handleVertex(indices[j + 0]);
        handleVertex(indices[j + 1]);
        handleVertex(indices[j + 2]);
      }
    }
  }

  computeVertexNormals() {
    const index = this.index;
    const positionAttribute = this.getAttribute('position');

    if (positionAttribute !== undefined) {
      let normalAttribute = this.getAttribute('normal');

      if (normalAttribute === undefined) {
        normalAttribute = new _BufferAttribute.BufferAttribute(new Float32Array(positionAttribute.count * 3), 3);
        this.setAttribute('normal', normalAttribute);
      } else {
        // reset existing normals to zero
        for (let i = 0, il = normalAttribute.count; i < il; i++) {
          normalAttribute.setXYZ(i, 0, 0, 0);
        }
      }

      const pA = new _Vector.Vector3(),
            pB = new _Vector.Vector3(),
            pC = new _Vector.Vector3();
      const nA = new _Vector.Vector3(),
            nB = new _Vector.Vector3(),
            nC = new _Vector.Vector3();
      const cb = new _Vector.Vector3(),
            ab = new _Vector.Vector3(); // indexed elements

      if (index) {
        for (let i = 0, il = index.count; i < il; i += 3) {
          const vA = index.getX(i + 0);
          const vB = index.getX(i + 1);
          const vC = index.getX(i + 2);
          pA.fromBufferAttribute(positionAttribute, vA);
          pB.fromBufferAttribute(positionAttribute, vB);
          pC.fromBufferAttribute(positionAttribute, vC);
          cb.subVectors(pC, pB);
          ab.subVectors(pA, pB);
          cb.cross(ab);
          nA.fromBufferAttribute(normalAttribute, vA);
          nB.fromBufferAttribute(normalAttribute, vB);
          nC.fromBufferAttribute(normalAttribute, vC);
          nA.add(cb);
          nB.add(cb);
          nC.add(cb);
          normalAttribute.setXYZ(vA, nA.x, nA.y, nA.z);
          normalAttribute.setXYZ(vB, nB.x, nB.y, nB.z);
          normalAttribute.setXYZ(vC, nC.x, nC.y, nC.z);
        }
      } else {
        // non-indexed elements (unconnected triangle soup)
        for (let i = 0, il = positionAttribute.count; i < il; i += 3) {
          pA.fromBufferAttribute(positionAttribute, i + 0);
          pB.fromBufferAttribute(positionAttribute, i + 1);
          pC.fromBufferAttribute(positionAttribute, i + 2);
          cb.subVectors(pC, pB);
          ab.subVectors(pA, pB);
          cb.cross(ab);
          normalAttribute.setXYZ(i + 0, cb.x, cb.y, cb.z);
          normalAttribute.setXYZ(i + 1, cb.x, cb.y, cb.z);
          normalAttribute.setXYZ(i + 2, cb.x, cb.y, cb.z);
        }
      }

      this.normalizeNormals();
      normalAttribute.needsUpdate = true;
    }
  }

  normalizeNormals() {
    const normals = this.attributes.normal;

    for (let i = 0, il = normals.count; i < il; i++) {
      _vector.fromBufferAttribute(normals, i);

      _vector.normalize();

      normals.setXYZ(i, _vector.x, _vector.y, _vector.z);
    }
  }

  toNonIndexed() {
    function convertBufferAttribute(attribute, indices) {
      const array = attribute.array;
      const itemSize = attribute.itemSize;
      const normalized = attribute.normalized;
      const array2 = new array.constructor(indices.length * itemSize);
      let index = 0,
          index2 = 0;

      for (let i = 0, l = indices.length; i < l; i++) {
        if (attribute.isInterleavedBufferAttribute) {
          index = indices[i] * attribute.data.stride + attribute.offset;
        } else {
          index = indices[i] * itemSize;
        }

        for (let j = 0; j < itemSize; j++) {
          array2[index2++] = array[index++];
        }
      }

      return new _BufferAttribute.BufferAttribute(array2, itemSize, normalized);
    } //


    if (this.index === null) {
      console.warn('THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.');
      return this;
    }

    const geometry2 = new BufferGeometry();
    const indices = this.index.array;
    const attributes = this.attributes; // attributes

    for (const name in attributes) {
      const attribute = attributes[name];
      const newAttribute = convertBufferAttribute(attribute, indices);
      geometry2.setAttribute(name, newAttribute);
    } // morph attributes


    const morphAttributes = this.morphAttributes;

    for (const name in morphAttributes) {
      const morphArray = [];
      const morphAttribute = morphAttributes[name]; // morphAttribute: array of Float32BufferAttributes

      for (let i = 0, il = morphAttribute.length; i < il; i++) {
        const attribute = morphAttribute[i];
        const newAttribute = convertBufferAttribute(attribute, indices);
        morphArray.push(newAttribute);
      }

      geometry2.morphAttributes[name] = morphArray;
    }

    geometry2.morphTargetsRelative = this.morphTargetsRelative; // groups

    const groups = this.groups;

    for (let i = 0, l = groups.length; i < l; i++) {
      const group = groups[i];
      geometry2.addGroup(group.start, group.count, group.materialIndex);
    }

    return geometry2;
  }

  toJSON() {
    const data = {
      metadata: {
        version: 4.6,
        type: 'BufferGeometry',
        generator: 'BufferGeometry.toJSON'
      }
    }; // standard BufferGeometry serialization

    data.uuid = this.uuid;
    data.type = this.type;
    if (this.name !== '') data.name = this.name;
    if (Object.keys(this.userData).length > 0) data.userData = this.userData;

    if (this.parameters !== undefined) {
      const parameters = this.parameters;

      for (const key in parameters) {
        if (parameters[key] !== undefined) data[key] = parameters[key];
      }

      return data;
    } // for simplicity the code assumes attributes are not shared across geometries, see #15811


    data.data = {
      attributes: {}
    };
    const index = this.index;

    if (index !== null) {
      data.data.index = {
        type: index.array.constructor.name,
        array: Array.prototype.slice.call(index.array)
      };
    }

    const attributes = this.attributes;

    for (const key in attributes) {
      const attribute = attributes[key];
      data.data.attributes[key] = attribute.toJSON(data.data);
    }

    const morphAttributes = {};
    let hasMorphAttributes = false;

    for (const key in this.morphAttributes) {
      const attributeArray = this.morphAttributes[key];
      const array = [];

      for (let i = 0, il = attributeArray.length; i < il; i++) {
        const attribute = attributeArray[i];
        array.push(attribute.toJSON(data.data));
      }

      if (array.length > 0) {
        morphAttributes[key] = array;
        hasMorphAttributes = true;
      }
    }

    if (hasMorphAttributes) {
      data.data.morphAttributes = morphAttributes;
      data.data.morphTargetsRelative = this.morphTargetsRelative;
    }

    const groups = this.groups;

    if (groups.length > 0) {
      data.data.groups = JSON.parse(JSON.stringify(groups));
    }

    const boundingSphere = this.boundingSphere;

    if (boundingSphere !== null) {
      data.data.boundingSphere = {
        center: boundingSphere.center.toArray(),
        radius: boundingSphere.radius
      };
    }

    return data;
  }

  clone() {
    return new this.constructor().copy(this);
  }

  copy(source) {
    // reset
    this.index = null;
    this.attributes = {};
    this.morphAttributes = {};
    this.groups = [];
    this.boundingBox = null;
    this.boundingSphere = null; // used for storing cloned, shared data

    const data = {}; // name

    this.name = source.name; // index

    const index = source.index;

    if (index !== null) {
      this.setIndex(index.clone(data));
    } // attributes


    const attributes = source.attributes;

    for (const name in attributes) {
      const attribute = attributes[name];
      this.setAttribute(name, attribute.clone(data));
    } // morph attributes


    const morphAttributes = source.morphAttributes;

    for (const name in morphAttributes) {
      const array = [];
      const morphAttribute = morphAttributes[name]; // morphAttribute: array of Float32BufferAttributes

      for (let i = 0, l = morphAttribute.length; i < l; i++) {
        array.push(morphAttribute[i].clone(data));
      }

      this.morphAttributes[name] = array;
    }

    this.morphTargetsRelative = source.morphTargetsRelative; // groups

    const groups = source.groups;

    for (let i = 0, l = groups.length; i < l; i++) {
      const group = groups[i];
      this.addGroup(group.start, group.count, group.materialIndex);
    } // bounding box


    const boundingBox = source.boundingBox;

    if (boundingBox !== null) {
      this.boundingBox = boundingBox.clone();
    } // bounding sphere


    const boundingSphere = source.boundingSphere;

    if (boundingSphere !== null) {
      this.boundingSphere = boundingSphere.clone();
    } // draw range


    this.drawRange.start = source.drawRange.start;
    this.drawRange.count = source.drawRange.count; // user data

    this.userData = source.userData;
    return this;
  }

  dispose() {
    this.dispatchEvent({
      type: 'dispose'
    });
  }

}

exports.BufferGeometry = BufferGeometry;

},{"../math/Box3.js":166,"../math/MathUtils.js":168,"../math/Matrix3.js":169,"../math/Matrix4.js":170,"../math/Sphere.js":172,"../math/Vector2.js":174,"../math/Vector3.js":175,"../utils.js":176,"./BufferAttribute.js":120,"./EventDispatcher.js":122,"./Object3D.js":124}],122:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.EventDispatcher = void 0;

/**
 * https://github.com/mrdoob/eventdispatcher.js/
 */
class EventDispatcher {
  addEventListener(type, listener) {
    if (this._listeners === undefined) this._listeners = {};
    const listeners = this._listeners;

    if (listeners[type] === undefined) {
      listeners[type] = [];
    }

    if (listeners[type].indexOf(listener) === -1) {
      listeners[type].push(listener);
    }
  }

  hasEventListener(type, listener) {
    if (this._listeners === undefined) return false;
    const listeners = this._listeners;
    return listeners[type] !== undefined && listeners[type].indexOf(listener) !== -1;
  }

  removeEventListener(type, listener) {
    if (this._listeners === undefined) return;
    const listeners = this._listeners;
    const listenerArray = listeners[type];

    if (listenerArray !== undefined) {
      const index = listenerArray.indexOf(listener);

      if (index !== -1) {
        listenerArray.splice(index, 1);
      }
    }
  }

  dispatchEvent(event) {
    if (this._listeners === undefined) return;
    const listeners = this._listeners;
    const listenerArray = listeners[event.type];

    if (listenerArray !== undefined) {
      event.target = this; // Make a copy, in case listeners are removed while iterating.

      const array = listenerArray.slice(0);

      for (let i = 0, l = array.length; i < l; i++) {
        array[i].call(this, event);
      }

      event.target = null;
    }
  }

}

exports.EventDispatcher = EventDispatcher;

},{}],123:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Layers = void 0;

class Layers {
  constructor() {
    this.mask = 1 | 0;
  }

  set(channel) {
    this.mask = (1 << channel | 0) >>> 0;
  }

  enable(channel) {
    this.mask |= 1 << channel | 0;
  }

  enableAll() {
    this.mask = 0xffffffff | 0;
  }

  toggle(channel) {
    this.mask ^= 1 << channel | 0;
  }

  disable(channel) {
    this.mask &= ~(1 << channel | 0);
  }

  disableAll() {
    this.mask = 0;
  }

  test(layers) {
    return (this.mask & layers.mask) !== 0;
  }

  isEnabled(channel) {
    return (this.mask & (1 << channel | 0)) !== 0;
  }

}

exports.Layers = Layers;

},{}],124:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Object3D = void 0;

var _Quaternion = require("../math/Quaternion.js");

var _Vector = require("../math/Vector3.js");

var _Matrix = require("../math/Matrix4.js");

var _EventDispatcher = require("./EventDispatcher.js");

var _Euler = require("../math/Euler.js");

var _Layers = require("./Layers.js");

var _Matrix2 = require("../math/Matrix3.js");

var MathUtils = _interopRequireWildcard(require("../math/MathUtils.js"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

let _object3DId = 0;

const _v1 = /*@__PURE__*/new _Vector.Vector3();

const _q1 = /*@__PURE__*/new _Quaternion.Quaternion();

const _m1 = /*@__PURE__*/new _Matrix.Matrix4();

const _target = /*@__PURE__*/new _Vector.Vector3();

const _position = /*@__PURE__*/new _Vector.Vector3();

const _scale = /*@__PURE__*/new _Vector.Vector3();

const _quaternion = /*@__PURE__*/new _Quaternion.Quaternion();

const _xAxis = /*@__PURE__*/new _Vector.Vector3(1, 0, 0);

const _yAxis = /*@__PURE__*/new _Vector.Vector3(0, 1, 0);

const _zAxis = /*@__PURE__*/new _Vector.Vector3(0, 0, 1);

const _addedEvent = {
  type: 'added'
};
const _removedEvent = {
  type: 'removed'
};

class Object3D extends _EventDispatcher.EventDispatcher {
  constructor() {
    super();
    this.isObject3D = true;
    Object.defineProperty(this, 'id', {
      value: _object3DId++
    });
    this.uuid = MathUtils.generateUUID();
    this.name = '';
    this.type = 'Object3D';
    this.parent = null;
    this.children = [];
    this.up = Object3D.DEFAULT_UP.clone();
    const position = new _Vector.Vector3();
    const rotation = new _Euler.Euler();
    const quaternion = new _Quaternion.Quaternion();
    const scale = new _Vector.Vector3(1, 1, 1);

    function onRotationChange() {
      quaternion.setFromEuler(rotation, false);
    }

    function onQuaternionChange() {
      rotation.setFromQuaternion(quaternion, undefined, false);
    }

    rotation._onChange(onRotationChange);

    quaternion._onChange(onQuaternionChange);

    Object.defineProperties(this, {
      position: {
        configurable: true,
        enumerable: true,
        value: position
      },
      rotation: {
        configurable: true,
        enumerable: true,
        value: rotation
      },
      quaternion: {
        configurable: true,
        enumerable: true,
        value: quaternion
      },
      scale: {
        configurable: true,
        enumerable: true,
        value: scale
      },
      modelViewMatrix: {
        value: new _Matrix.Matrix4()
      },
      normalMatrix: {
        value: new _Matrix2.Matrix3()
      }
    });
    this.matrix = new _Matrix.Matrix4();
    this.matrixWorld = new _Matrix.Matrix4();
    this.matrixAutoUpdate = Object3D.DEFAULT_MATRIX_AUTO_UPDATE;
    this.matrixWorldNeedsUpdate = false;
    this.matrixWorldAutoUpdate = Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE; // checked by the renderer

    this.layers = new _Layers.Layers();
    this.visible = true;
    this.castShadow = false;
    this.receiveShadow = false;
    this.frustumCulled = true;
    this.renderOrder = 0;
    this.animations = [];
    this.userData = {};
  }

  onBeforeRender() {}

  onAfterRender() {}

  applyMatrix4(matrix) {
    if (this.matrixAutoUpdate) this.updateMatrix();
    this.matrix.premultiply(matrix);
    this.matrix.decompose(this.position, this.quaternion, this.scale);
  }

  applyQuaternion(q) {
    this.quaternion.premultiply(q);
    return this;
  }

  setRotationFromAxisAngle(axis, angle) {
    // assumes axis is normalized
    this.quaternion.setFromAxisAngle(axis, angle);
  }

  setRotationFromEuler(euler) {
    this.quaternion.setFromEuler(euler, true);
  }

  setRotationFromMatrix(m) {
    // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
    this.quaternion.setFromRotationMatrix(m);
  }

  setRotationFromQuaternion(q) {
    // assumes q is normalized
    this.quaternion.copy(q);
  }

  rotateOnAxis(axis, angle) {
    // rotate object on axis in object space
    // axis is assumed to be normalized
    _q1.setFromAxisAngle(axis, angle);

    this.quaternion.multiply(_q1);
    return this;
  }

  rotateOnWorldAxis(axis, angle) {
    // rotate object on axis in world space
    // axis is assumed to be normalized
    // method assumes no rotated parent
    _q1.setFromAxisAngle(axis, angle);

    this.quaternion.premultiply(_q1);
    return this;
  }

  rotateX(angle) {
    return this.rotateOnAxis(_xAxis, angle);
  }

  rotateY(angle) {
    return this.rotateOnAxis(_yAxis, angle);
  }

  rotateZ(angle) {
    return this.rotateOnAxis(_zAxis, angle);
  }

  translateOnAxis(axis, distance) {
    // translate object by distance along axis in object space
    // axis is assumed to be normalized
    _v1.copy(axis).applyQuaternion(this.quaternion);

    this.position.add(_v1.multiplyScalar(distance));
    return this;
  }

  translateX(distance) {
    return this.translateOnAxis(_xAxis, distance);
  }

  translateY(distance) {
    return this.translateOnAxis(_yAxis, distance);
  }

  translateZ(distance) {
    return this.translateOnAxis(_zAxis, distance);
  }

  localToWorld(vector) {
    this.updateWorldMatrix(true, false);
    return vector.applyMatrix4(this.matrixWorld);
  }

  worldToLocal(vector) {
    this.updateWorldMatrix(true, false);
    return vector.applyMatrix4(_m1.copy(this.matrixWorld).invert());
  }

  lookAt(x, y, z) {
    // This method does not support objects having non-uniformly-scaled parent(s)
    if (x.isVector3) {
      _target.copy(x);
    } else {
      _target.set(x, y, z);
    }

    const parent = this.parent;
    this.updateWorldMatrix(true, false);

    _position.setFromMatrixPosition(this.matrixWorld);

    if (this.isCamera || this.isLight) {
      _m1.lookAt(_position, _target, this.up);
    } else {
      _m1.lookAt(_target, _position, this.up);
    }

    this.quaternion.setFromRotationMatrix(_m1);

    if (parent) {
      _m1.extractRotation(parent.matrixWorld);

      _q1.setFromRotationMatrix(_m1);

      this.quaternion.premultiply(_q1.invert());
    }
  }

  add(object) {
    if (arguments.length > 1) {
      for (let i = 0; i < arguments.length; i++) {
        this.add(arguments[i]);
      }

      return this;
    }

    if (object === this) {
      console.error('THREE.Object3D.add: object can\'t be added as a child of itself.', object);
      return this;
    }

    if (object && object.isObject3D) {
      if (object.parent !== null) {
        object.parent.remove(object);
      }

      object.parent = this;
      this.children.push(object);
      object.dispatchEvent(_addedEvent);
    } else {
      console.error('THREE.Object3D.add: object not an instance of THREE.Object3D.', object);
    }

    return this;
  }

  remove(object) {
    if (arguments.length > 1) {
      for (let i = 0; i < arguments.length; i++) {
        this.remove(arguments[i]);
      }

      return this;
    }

    const index = this.children.indexOf(object);

    if (index !== -1) {
      object.parent = null;
      this.children.splice(index, 1);
      object.dispatchEvent(_removedEvent);
    }

    return this;
  }

  removeFromParent() {
    const parent = this.parent;

    if (parent !== null) {
      parent.remove(this);
    }

    return this;
  }

  clear() {
    return this.remove(...this.children);
  }

  attach(object) {
    // adds object as a child of this, while maintaining the object's world transform
    // Note: This method does not support scene graphs having non-uniformly-scaled nodes(s)
    this.updateWorldMatrix(true, false);

    _m1.copy(this.matrixWorld).invert();

    if (object.parent !== null) {
      object.parent.updateWorldMatrix(true, false);

      _m1.multiply(object.parent.matrixWorld);
    }

    object.applyMatrix4(_m1);
    this.add(object);
    object.updateWorldMatrix(false, true);
    return this;
  }

  getObjectById(id) {
    return this.getObjectByProperty('id', id);
  }

  getObjectByName(name) {
    return this.getObjectByProperty('name', name);
  }

  getObjectByProperty(name, value) {
    if (this[name] === value) return this;

    for (let i = 0, l = this.children.length; i < l; i++) {
      const child = this.children[i];
      const object = child.getObjectByProperty(name, value);

      if (object !== undefined) {
        return object;
      }
    }

    return undefined;
  }

  getObjectsByProperty(name, value) {
    let result = [];
    if (this[name] === value) result.push(this);

    for (let i = 0, l = this.children.length; i < l; i++) {
      const childResult = this.children[i].getObjectsByProperty(name, value);

      if (childResult.length > 0) {
        result = result.concat(childResult);
      }
    }

    return result;
  }

  getWorldPosition(target) {
    this.updateWorldMatrix(true, false);
    return target.setFromMatrixPosition(this.matrixWorld);
  }

  getWorldQuaternion(target) {
    this.updateWorldMatrix(true, false);
    this.matrixWorld.decompose(_position, target, _scale);
    return target;
  }

  getWorldScale(target) {
    this.updateWorldMatrix(true, false);
    this.matrixWorld.decompose(_position, _quaternion, target);
    return target;
  }

  getWorldDirection(target) {
    this.updateWorldMatrix(true, false);
    const e = this.matrixWorld.elements;
    return target.set(e[8], e[9], e[10]).normalize();
  }

  raycast() {}

  traverse(callback) {
    callback(this);
    const children = this.children;

    for (let i = 0, l = children.length; i < l; i++) {
      children[i].traverse(callback);
    }
  }

  traverseVisible(callback) {
    if (this.visible === false) return;
    callback(this);
    const children = this.children;

    for (let i = 0, l = children.length; i < l; i++) {
      children[i].traverseVisible(callback);
    }
  }

  traverseAncestors(callback) {
    const parent = this.parent;

    if (parent !== null) {
      callback(parent);
      parent.traverseAncestors(callback);
    }
  }

  updateMatrix() {
    this.matrix.compose(this.position, this.quaternion, this.scale);
    this.matrixWorldNeedsUpdate = true;
  }

  updateMatrixWorld(force) {
    if (this.matrixAutoUpdate) this.updateMatrix();

    if (this.matrixWorldNeedsUpdate || force) {
      if (this.parent === null) {
        this.matrixWorld.copy(this.matrix);
      } else {
        this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
      }

      this.matrixWorldNeedsUpdate = false;
      force = true;
    } // update children


    const children = this.children;

    for (let i = 0, l = children.length; i < l; i++) {
      const child = children[i];

      if (child.matrixWorldAutoUpdate === true || force === true) {
        child.updateMatrixWorld(force);
      }
    }
  }

  updateWorldMatrix(updateParents, updateChildren) {
    const parent = this.parent;

    if (updateParents === true && parent !== null && parent.matrixWorldAutoUpdate === true) {
      parent.updateWorldMatrix(true, false);
    }

    if (this.matrixAutoUpdate) this.updateMatrix();

    if (this.parent === null) {
      this.matrixWorld.copy(this.matrix);
    } else {
      this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
    } // update children


    if (updateChildren === true) {
      const children = this.children;

      for (let i = 0, l = children.length; i < l; i++) {
        const child = children[i];

        if (child.matrixWorldAutoUpdate === true) {
          child.updateWorldMatrix(false, true);
        }
      }
    }
  }

  toJSON(meta) {
    // meta is a string when called from JSON.stringify
    const isRootObject = meta === undefined || typeof meta === 'string';
    const output = {}; // meta is a hash used to collect geometries, materials.
    // not providing it implies that this is the root object
    // being serialized.

    if (isRootObject) {
      // initialize meta obj
      meta = {
        geometries: {},
        materials: {},
        textures: {},
        images: {},
        shapes: {},
        skeletons: {},
        animations: {},
        nodes: {}
      };
      output.metadata = {
        version: 4.6,
        type: 'Object',
        generator: 'Object3D.toJSON'
      };
    } // standard Object3D serialization


    const object = {};
    object.uuid = this.uuid;
    object.type = this.type;
    if (this.name !== '') object.name = this.name;
    if (this.castShadow === true) object.castShadow = true;
    if (this.receiveShadow === true) object.receiveShadow = true;
    if (this.visible === false) object.visible = false;
    if (this.frustumCulled === false) object.frustumCulled = false;
    if (this.renderOrder !== 0) object.renderOrder = this.renderOrder;
    if (Object.keys(this.userData).length > 0) object.userData = this.userData;
    object.layers = this.layers.mask;
    object.matrix = this.matrix.toArray();
    object.up = this.up.toArray();
    if (this.matrixAutoUpdate === false) object.matrixAutoUpdate = false; // object specific properties

    if (this.isInstancedMesh) {
      object.type = 'InstancedMesh';
      object.count = this.count;
      object.instanceMatrix = this.instanceMatrix.toJSON();
      if (this.instanceColor !== null) object.instanceColor = this.instanceColor.toJSON();
    } //


    function serialize(library, element) {
      if (library[element.uuid] === undefined) {
        library[element.uuid] = element.toJSON(meta);
      }

      return element.uuid;
    }

    if (this.isScene) {
      if (this.background) {
        if (this.background.isColor) {
          object.background = this.background.toJSON();
        } else if (this.background.isTexture) {
          object.background = this.background.toJSON(meta).uuid;
        }
      }

      if (this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== true) {
        object.environment = this.environment.toJSON(meta).uuid;
      }
    } else if (this.isMesh || this.isLine || this.isPoints) {
      object.geometry = serialize(meta.geometries, this.geometry);
      const parameters = this.geometry.parameters;

      if (parameters !== undefined && parameters.shapes !== undefined) {
        const shapes = parameters.shapes;

        if (Array.isArray(shapes)) {
          for (let i = 0, l = shapes.length; i < l; i++) {
            const shape = shapes[i];
            serialize(meta.shapes, shape);
          }
        } else {
          serialize(meta.shapes, shapes);
        }
      }
    }

    if (this.isSkinnedMesh) {
      object.bindMode = this.bindMode;
      object.bindMatrix = this.bindMatrix.toArray();

      if (this.skeleton !== undefined) {
        serialize(meta.skeletons, this.skeleton);
        object.skeleton = this.skeleton.uuid;
      }
    }

    if (this.material !== undefined) {
      if (Array.isArray(this.material)) {
        const uuids = [];

        for (let i = 0, l = this.material.length; i < l; i++) {
          uuids.push(serialize(meta.materials, this.material[i]));
        }

        object.material = uuids;
      } else {
        object.material = serialize(meta.materials, this.material);
      }
    } //


    if (this.children.length > 0) {
      object.children = [];

      for (let i = 0; i < this.children.length; i++) {
        object.children.push(this.children[i].toJSON(meta).object);
      }
    } //


    if (this.animations.length > 0) {
      object.animations = [];

      for (let i = 0; i < this.animations.length; i++) {
        const animation = this.animations[i];
        object.animations.push(serialize(meta.animations, animation));
      }
    }

    if (isRootObject) {
      const geometries = extractFromCache(meta.geometries);
      const materials = extractFromCache(meta.materials);
      const textures = extractFromCache(meta.textures);
      const images = extractFromCache(meta.images);
      const shapes = extractFromCache(meta.shapes);
      const skeletons = extractFromCache(meta.skeletons);
      const animations = extractFromCache(meta.animations);
      const nodes = extractFromCache(meta.nodes);
      if (geometries.length > 0) output.geometries = geometries;
      if (materials.length > 0) output.materials = materials;
      if (textures.length > 0) output.textures = textures;
      if (images.length > 0) output.images = images;
      if (shapes.length > 0) output.shapes = shapes;
      if (skeletons.length > 0) output.skeletons = skeletons;
      if (animations.length > 0) output.animations = animations;
      if (nodes.length > 0) output.nodes = nodes;
    }

    output.object = object;
    return output; // extract data from the cache hash
    // remove metadata on each item
    // and return as array

    function extractFromCache(cache) {
      const values = [];

      for (const key in cache) {
        const data = cache[key];
        delete data.metadata;
        values.push(data);
      }

      return values;
    }
  }

  clone(recursive) {
    return new this.constructor().copy(this, recursive);
  }

  copy(source, recursive = true) {
    this.name = source.name;
    this.up.copy(source.up);
    this.position.copy(source.position);
    this.rotation.order = source.rotation.order;
    this.quaternion.copy(source.quaternion);
    this.scale.copy(source.scale);
    this.matrix.copy(source.matrix);
    this.matrixWorld.copy(source.matrixWorld);
    this.matrixAutoUpdate = source.matrixAutoUpdate;
    this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;
    this.matrixWorldAutoUpdate = source.matrixWorldAutoUpdate;
    this.layers.mask = source.layers.mask;
    this.visible = source.visible;
    this.castShadow = source.castShadow;
    this.receiveShadow = source.receiveShadow;
    this.frustumCulled = source.frustumCulled;
    this.renderOrder = source.renderOrder;
    this.animations = source.animations.slice();
    this.userData = JSON.parse(JSON.stringify(source.userData));

    if (recursive === true) {
      for (let i = 0; i < source.children.length; i++) {
        const child = source.children[i];
        this.add(child.clone());
      }
    }

    return this;
  }

}

exports.Object3D = Object3D;
Object3D.DEFAULT_UP = /*@__PURE__*/new _Vector.Vector3(0, 1, 0);
Object3D.DEFAULT_MATRIX_AUTO_UPDATE = true;
Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = true;

},{"../math/Euler.js":167,"../math/MathUtils.js":168,"../math/Matrix3.js":169,"../math/Matrix4.js":170,"../math/Quaternion.js":171,"../math/Vector3.js":175,"./EventDispatcher.js":122,"./Layers.js":123}],125:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DataUtils = void 0;
exports.fromHalfFloat = fromHalfFloat;
exports.toHalfFloat = toHalfFloat;

var _MathUtils = require("../math/MathUtils.js");

// Fast Half Float Conversions, http://www.fox-toolkit.org/ftp/fasthalffloatconversion.pdf
const _tables = /*@__PURE__*/_generateTables();

function _generateTables() {
  // float32 to float16 helpers
  const buffer = new ArrayBuffer(4);
  const floatView = new Float32Array(buffer);
  const uint32View = new Uint32Array(buffer);
  const baseTable = new Uint32Array(512);
  const shiftTable = new Uint32Array(512);

  for (let i = 0; i < 256; ++i) {
    const e = i - 127; // very small number (0, -0)

    if (e < -27) {
      baseTable[i] = 0x0000;
      baseTable[i | 0x100] = 0x8000;
      shiftTable[i] = 24;
      shiftTable[i | 0x100] = 24; // small number (denorm)
    } else if (e < -14) {
      baseTable[i] = 0x0400 >> -e - 14;
      baseTable[i | 0x100] = 0x0400 >> -e - 14 | 0x8000;
      shiftTable[i] = -e - 1;
      shiftTable[i | 0x100] = -e - 1; // normal number
    } else if (e <= 15) {
      baseTable[i] = e + 15 << 10;
      baseTable[i | 0x100] = e + 15 << 10 | 0x8000;
      shiftTable[i] = 13;
      shiftTable[i | 0x100] = 13; // large number (Infinity, -Infinity)
    } else if (e < 128) {
      baseTable[i] = 0x7c00;
      baseTable[i | 0x100] = 0xfc00;
      shiftTable[i] = 24;
      shiftTable[i | 0x100] = 24; // stay (NaN, Infinity, -Infinity)
    } else {
      baseTable[i] = 0x7c00;
      baseTable[i | 0x100] = 0xfc00;
      shiftTable[i] = 13;
      shiftTable[i | 0x100] = 13;
    }
  } // float16 to float32 helpers


  const mantissaTable = new Uint32Array(2048);
  const exponentTable = new Uint32Array(64);
  const offsetTable = new Uint32Array(64);

  for (let i = 1; i < 1024; ++i) {
    let m = i << 13; // zero pad mantissa bits

    let e = 0; // zero exponent
    // normalized

    while ((m & 0x00800000) === 0) {
      m <<= 1;
      e -= 0x00800000; // decrement exponent
    }

    m &= ~0x00800000; // clear leading 1 bit

    e += 0x38800000; // adjust bias

    mantissaTable[i] = m | e;
  }

  for (let i = 1024; i < 2048; ++i) {
    mantissaTable[i] = 0x38000000 + (i - 1024 << 13);
  }

  for (let i = 1; i < 31; ++i) {
    exponentTable[i] = i << 23;
  }

  exponentTable[31] = 0x47800000;
  exponentTable[32] = 0x80000000;

  for (let i = 33; i < 63; ++i) {
    exponentTable[i] = 0x80000000 + (i - 32 << 23);
  }

  exponentTable[63] = 0xc7800000;

  for (let i = 1; i < 64; ++i) {
    if (i !== 32) {
      offsetTable[i] = 1024;
    }
  }

  return {
    floatView: floatView,
    uint32View: uint32View,
    baseTable: baseTable,
    shiftTable: shiftTable,
    mantissaTable: mantissaTable,
    exponentTable: exponentTable,
    offsetTable: offsetTable
  };
} // float32 to float16


function toHalfFloat(val) {
  if (Math.abs(val) > 65504) console.warn('THREE.DataUtils.toHalfFloat(): Value out of range.');
  val = (0, _MathUtils.clamp)(val, -65504, 65504);
  _tables.floatView[0] = val;
  const f = _tables.uint32View[0];
  const e = f >> 23 & 0x1ff;
  return _tables.baseTable[e] + ((f & 0x007fffff) >> _tables.shiftTable[e]);
} // float16 to float32


function fromHalfFloat(val) {
  const m = val >> 10;
  _tables.uint32View[0] = _tables.mantissaTable[_tables.offsetTable[m] + (val & 0x3ff)] + _tables.exponentTable[m];
  return _tables.floatView[0];
}

const DataUtils = {
  toHalfFloat: toHalfFloat,
  fromHalfFloat: fromHalfFloat
};
exports.DataUtils = DataUtils;

},{"../math/MathUtils.js":168}],126:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Earcut = void 0;

/**
 * Port from https://github.com/mapbox/earcut (v2.2.4)
 */
const Earcut = {
  triangulate: function (data, holeIndices, dim = 2) {
    const hasHoles = holeIndices && holeIndices.length;
    const outerLen = hasHoles ? holeIndices[0] * dim : data.length;
    let outerNode = linkedList(data, 0, outerLen, dim, true);
    const triangles = [];
    if (!outerNode || outerNode.next === outerNode.prev) return triangles;
    let minX, minY, maxX, maxY, x, y, invSize;
    if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim); // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox

    if (data.length > 80 * dim) {
      minX = maxX = data[0];
      minY = maxY = data[1];

      for (let i = dim; i < outerLen; i += dim) {
        x = data[i];
        y = data[i + 1];
        if (x < minX) minX = x;
        if (y < minY) minY = y;
        if (x > maxX) maxX = x;
        if (y > maxY) maxY = y;
      } // minX, minY and invSize are later used to transform coords into integers for z-order calculation


      invSize = Math.max(maxX - minX, maxY - minY);
      invSize = invSize !== 0 ? 32767 / invSize : 0;
    }

    earcutLinked(outerNode, triangles, dim, minX, minY, invSize, 0);
    return triangles;
  }
}; // create a circular doubly linked list from polygon points in the specified winding order

exports.Earcut = Earcut;

function linkedList(data, start, end, dim, clockwise) {
  let i, last;

  if (clockwise === signedArea(data, start, end, dim) > 0) {
    for (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last);
  } else {
    for (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last);
  }

  if (last && equals(last, last.next)) {
    removeNode(last);
    last = last.next;
  }

  return last;
} // eliminate colinear or duplicate points


function filterPoints(start, end) {
  if (!start) return start;
  if (!end) end = start;
  let p = start,
      again;

  do {
    again = false;

    if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
      removeNode(p);
      p = end = p.prev;
      if (p === p.next) break;
      again = true;
    } else {
      p = p.next;
    }
  } while (again || p !== end);

  return end;
} // main ear slicing loop which triangulates a polygon (given as a linked list)


function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
  if (!ear) return; // interlink polygon nodes in z-order

  if (!pass && invSize) indexCurve(ear, minX, minY, invSize);
  let stop = ear,
      prev,
      next; // iterate through ears, slicing them one by one

  while (ear.prev !== ear.next) {
    prev = ear.prev;
    next = ear.next;

    if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
      // cut off the triangle
      triangles.push(prev.i / dim | 0);
      triangles.push(ear.i / dim | 0);
      triangles.push(next.i / dim | 0);
      removeNode(ear); // skipping the next vertex leads to less sliver triangles

      ear = next.next;
      stop = next.next;
      continue;
    }

    ear = next; // if we looped through the whole remaining polygon and can't find any more ears

    if (ear === stop) {
      // try filtering points and slicing again
      if (!pass) {
        earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1); // if this didn't work, try curing all small self-intersections locally
      } else if (pass === 1) {
        ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
        earcutLinked(ear, triangles, dim, minX, minY, invSize, 2); // as a last resort, try splitting the remaining polygon into two
      } else if (pass === 2) {
        splitEarcut(ear, triangles, dim, minX, minY, invSize);
      }

      break;
    }
  }
} // check whether a polygon node forms a valid ear with adjacent nodes


function isEar(ear) {
  const a = ear.prev,
        b = ear,
        c = ear.next;
  if (area(a, b, c) >= 0) return false; // reflex, can't be an ear
  // now make sure we don't have other points inside the potential ear

  const ax = a.x,
        bx = b.x,
        cx = c.x,
        ay = a.y,
        by = b.y,
        cy = c.y; // triangle bbox; min & max are calculated like this for speed

  const x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx,
        y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy,
        x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx,
        y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;
  let p = c.next;

  while (p !== a) {
    if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
    p = p.next;
  }

  return true;
}

function isEarHashed(ear, minX, minY, invSize) {
  const a = ear.prev,
        b = ear,
        c = ear.next;
  if (area(a, b, c) >= 0) return false; // reflex, can't be an ear

  const ax = a.x,
        bx = b.x,
        cx = c.x,
        ay = a.y,
        by = b.y,
        cy = c.y; // triangle bbox; min & max are calculated like this for speed

  const x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx,
        y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy,
        x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx,
        y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy; // z-order range for the current triangle bbox;

  const minZ = zOrder(x0, y0, minX, minY, invSize),
        maxZ = zOrder(x1, y1, minX, minY, invSize);
  let p = ear.prevZ,
      n = ear.nextZ; // look for points inside the triangle in both directions

  while (p && p.z >= minZ && n && n.z <= maxZ) {
    if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
    p = p.prevZ;
    if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c && pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
    n = n.nextZ;
  } // look for remaining points in decreasing z-order


  while (p && p.z >= minZ) {
    if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
    p = p.prevZ;
  } // look for remaining points in increasing z-order


  while (n && n.z <= maxZ) {
    if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c && pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
    n = n.nextZ;
  }

  return true;
} // go through all polygon nodes and cure small local self-intersections


function cureLocalIntersections(start, triangles, dim) {
  let p = start;

  do {
    const a = p.prev,
          b = p.next.next;

    if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {
      triangles.push(a.i / dim | 0);
      triangles.push(p.i / dim | 0);
      triangles.push(b.i / dim | 0); // remove two nodes involved

      removeNode(p);
      removeNode(p.next);
      p = start = b;
    }

    p = p.next;
  } while (p !== start);

  return filterPoints(p);
} // try splitting polygon into two and triangulate them independently


function splitEarcut(start, triangles, dim, minX, minY, invSize) {
  // look for a valid diagonal that divides the polygon into two
  let a = start;

  do {
    let b = a.next.next;

    while (b !== a.prev) {
      if (a.i !== b.i && isValidDiagonal(a, b)) {
        // split the polygon in two by the diagonal
        let c = splitPolygon(a, b); // filter colinear points around the cuts

        a = filterPoints(a, a.next);
        c = filterPoints(c, c.next); // run earcut on each half

        earcutLinked(a, triangles, dim, minX, minY, invSize, 0);
        earcutLinked(c, triangles, dim, minX, minY, invSize, 0);
        return;
      }

      b = b.next;
    }

    a = a.next;
  } while (a !== start);
} // link every hole into the outer loop, producing a single-ring polygon without holes


function eliminateHoles(data, holeIndices, outerNode, dim) {
  const queue = [];
  let i, len, start, end, list;

  for (i = 0, len = holeIndices.length; i < len; i++) {
    start = holeIndices[i] * dim;
    end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
    list = linkedList(data, start, end, dim, false);
    if (list === list.next) list.steiner = true;
    queue.push(getLeftmost(list));
  }

  queue.sort(compareX); // process holes from left to right

  for (i = 0; i < queue.length; i++) {
    outerNode = eliminateHole(queue[i], outerNode);
  }

  return outerNode;
}

function compareX(a, b) {
  return a.x - b.x;
} // find a bridge between vertices that connects hole with an outer ring and link it


function eliminateHole(hole, outerNode) {
  const bridge = findHoleBridge(hole, outerNode);

  if (!bridge) {
    return outerNode;
  }

  const bridgeReverse = splitPolygon(bridge, hole); // filter collinear points around the cuts

  filterPoints(bridgeReverse, bridgeReverse.next);
  return filterPoints(bridge, bridge.next);
} // David Eberly's algorithm for finding a bridge between hole and outer polygon


function findHoleBridge(hole, outerNode) {
  let p = outerNode,
      qx = -Infinity,
      m;
  const hx = hole.x,
        hy = hole.y; // find a segment intersected by a ray from the hole's leftmost point to the left;
  // segment's endpoint with lesser x will be potential connection point

  do {
    if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
      const x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);

      if (x <= hx && x > qx) {
        qx = x;
        m = p.x < p.next.x ? p : p.next;
        if (x === hx) return m; // hole touches outer segment; pick leftmost endpoint
      }
    }

    p = p.next;
  } while (p !== outerNode);

  if (!m) return null; // look for points inside the triangle of hole point, segment intersection and endpoint;
  // if there are no points found, we have a valid connection;
  // otherwise choose the point of the minimum angle with the ray as connection point

  const stop = m,
        mx = m.x,
        my = m.y;
  let tanMin = Infinity,
      tan;
  p = m;

  do {
    if (hx >= p.x && p.x >= mx && hx !== p.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
      tan = Math.abs(hy - p.y) / (hx - p.x); // tangential

      if (locallyInside(p, hole) && (tan < tanMin || tan === tanMin && (p.x > m.x || p.x === m.x && sectorContainsSector(m, p)))) {
        m = p;
        tanMin = tan;
      }
    }

    p = p.next;
  } while (p !== stop);

  return m;
} // whether sector in vertex m contains sector in vertex p in the same coordinates


function sectorContainsSector(m, p) {
  return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;
} // interlink polygon nodes in z-order


function indexCurve(start, minX, minY, invSize) {
  let p = start;

  do {
    if (p.z === 0) p.z = zOrder(p.x, p.y, minX, minY, invSize);
    p.prevZ = p.prev;
    p.nextZ = p.next;
    p = p.next;
  } while (p !== start);

  p.prevZ.nextZ = null;
  p.prevZ = null;
  sortLinked(p);
} // Simon Tatham's linked list merge sort algorithm
// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html


function sortLinked(list) {
  let i,
      p,
      q,
      e,
      tail,
      numMerges,
      pSize,
      qSize,
      inSize = 1;

  do {
    p = list;
    list = null;
    tail = null;
    numMerges = 0;

    while (p) {
      numMerges++;
      q = p;
      pSize = 0;

      for (i = 0; i < inSize; i++) {
        pSize++;
        q = q.nextZ;
        if (!q) break;
      }

      qSize = inSize;

      while (pSize > 0 || qSize > 0 && q) {
        if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
          e = p;
          p = p.nextZ;
          pSize--;
        } else {
          e = q;
          q = q.nextZ;
          qSize--;
        }

        if (tail) tail.nextZ = e;else list = e;
        e.prevZ = tail;
        tail = e;
      }

      p = q;
    }

    tail.nextZ = null;
    inSize *= 2;
  } while (numMerges > 1);

  return list;
} // z-order of a point given coords and inverse of the longer side of data bbox


function zOrder(x, y, minX, minY, invSize) {
  // coords are transformed into non-negative 15-bit integer range
  x = (x - minX) * invSize | 0;
  y = (y - minY) * invSize | 0;
  x = (x | x << 8) & 0x00FF00FF;
  x = (x | x << 4) & 0x0F0F0F0F;
  x = (x | x << 2) & 0x33333333;
  x = (x | x << 1) & 0x55555555;
  y = (y | y << 8) & 0x00FF00FF;
  y = (y | y << 4) & 0x0F0F0F0F;
  y = (y | y << 2) & 0x33333333;
  y = (y | y << 1) & 0x55555555;
  return x | y << 1;
} // find the leftmost node of a polygon ring


function getLeftmost(start) {
  let p = start,
      leftmost = start;

  do {
    if (p.x < leftmost.x || p.x === leftmost.x && p.y < leftmost.y) leftmost = p;
    p = p.next;
  } while (p !== start);

  return leftmost;
} // check if a point lies within a convex triangle


function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
  return (cx - px) * (ay - py) >= (ax - px) * (cy - py) && (ax - px) * (by - py) >= (bx - px) * (ay - py) && (bx - px) * (cy - py) >= (cx - px) * (by - py);
} // check if a diagonal between two polygon nodes is valid (lies in polygon interior)


function isValidDiagonal(a, b) {
  return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && ( // dones't intersect other edges
  locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && ( // locally visible
  area(a.prev, a, b.prev) || area(a, b.prev, b)) || // does not create opposite-facing sectors
  equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0); // special zero-length case
} // signed area of a triangle


function area(p, q, r) {
  return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
} // check if two points are equal


function equals(p1, p2) {
  return p1.x === p2.x && p1.y === p2.y;
} // check if two segments intersect


function intersects(p1, q1, p2, q2) {
  const o1 = sign(area(p1, q1, p2));
  const o2 = sign(area(p1, q1, q2));
  const o3 = sign(area(p2, q2, p1));
  const o4 = sign(area(p2, q2, q1));
  if (o1 !== o2 && o3 !== o4) return true; // general case

  if (o1 === 0 && onSegment(p1, p2, q1)) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1

  if (o2 === 0 && onSegment(p1, q2, q1)) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1

  if (o3 === 0 && onSegment(p2, p1, q2)) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2

  if (o4 === 0 && onSegment(p2, q1, q2)) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2

  return false;
} // for collinear points p, q, r, check if point q lies on segment pr


function onSegment(p, q, r) {
  return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);
}

function sign(num) {
  return num > 0 ? 1 : num < 0 ? -1 : 0;
} // check if a polygon diagonal intersects any polygon segments


function intersectsPolygon(a, b) {
  let p = a;

  do {
    if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && intersects(p, p.next, a, b)) return true;
    p = p.next;
  } while (p !== a);

  return false;
} // check if a polygon diagonal is locally inside the polygon


function locallyInside(a, b) {
  return area(a.prev, a, a.next) < 0 ? area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 : area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
} // check if the middle point of a polygon diagonal is inside the polygon


function middleInside(a, b) {
  let p = a,
      inside = false;
  const px = (a.x + b.x) / 2,
        py = (a.y + b.y) / 2;

  do {
    if (p.y > py !== p.next.y > py && p.next.y !== p.y && px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x) inside = !inside;
    p = p.next;
  } while (p !== a);

  return inside;
} // link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
// if one belongs to the outer ring and another to a hole, it merges it into a single ring


function splitPolygon(a, b) {
  const a2 = new Node(a.i, a.x, a.y),
        b2 = new Node(b.i, b.x, b.y),
        an = a.next,
        bp = b.prev;
  a.next = b;
  b.prev = a;
  a2.next = an;
  an.prev = a2;
  b2.next = a2;
  a2.prev = b2;
  bp.next = b2;
  b2.prev = bp;
  return b2;
} // create a node and optionally link it with previous one (in a circular doubly linked list)


function insertNode(i, x, y, last) {
  const p = new Node(i, x, y);

  if (!last) {
    p.prev = p;
    p.next = p;
  } else {
    p.next = last.next;
    p.prev = last;
    last.next.prev = p;
    last.next = p;
  }

  return p;
}

function removeNode(p) {
  p.next.prev = p.prev;
  p.prev.next = p.next;
  if (p.prevZ) p.prevZ.nextZ = p.nextZ;
  if (p.nextZ) p.nextZ.prevZ = p.prevZ;
}

function Node(i, x, y) {
  // vertex index in coordinates array
  this.i = i; // vertex coordinates

  this.x = x;
  this.y = y; // previous and next vertex nodes in a polygon ring

  this.prev = null;
  this.next = null; // z-order curve value

  this.z = 0; // previous and next nodes in z-order

  this.prevZ = null;
  this.nextZ = null; // indicates whether this is a steiner point

  this.steiner = false;
}

function signedArea(data, start, end, dim) {
  let sum = 0;

  for (let i = start, j = end - dim; i < end; i += dim) {
    sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
    j = i;
  }

  return sum;
}

},{}],127:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ShapeUtils = void 0;

var _Earcut = require("./Earcut.js");

class ShapeUtils {
  // calculate area of the contour polygon
  static area(contour) {
    const n = contour.length;
    let a = 0.0;

    for (let p = n - 1, q = 0; q < n; p = q++) {
      a += contour[p].x * contour[q].y - contour[q].x * contour[p].y;
    }

    return a * 0.5;
  }

  static isClockWise(pts) {
    return ShapeUtils.area(pts) < 0;
  }

  static triangulateShape(contour, holes) {
    const vertices = []; // flat array of vertices like [ x0,y0, x1,y1, x2,y2, ... ]

    const holeIndices = []; // array of hole indices

    const faces = []; // final array of vertex indices like [ [ a,b,d ], [ b,c,d ] ]

    removeDupEndPts(contour);
    addContour(vertices, contour); //

    let holeIndex = contour.length;
    holes.forEach(removeDupEndPts);

    for (let i = 0; i < holes.length; i++) {
      holeIndices.push(holeIndex);
      holeIndex += holes[i].length;
      addContour(vertices, holes[i]);
    } //


    const triangles = _Earcut.Earcut.triangulate(vertices, holeIndices); //


    for (let i = 0; i < triangles.length; i += 3) {
      faces.push(triangles.slice(i, i + 3));
    }

    return faces;
  }

}

exports.ShapeUtils = ShapeUtils;

function removeDupEndPts(points) {
  const l = points.length;

  if (l > 2 && points[l - 1].equals(points[0])) {
    points.pop();
  }
}

function addContour(vertices, contour) {
  for (let i = 0; i < contour.length; i++) {
    vertices.push(contour[i].x);
    vertices.push(contour[i].y);
  }
}

},{"./Earcut.js":126}],128:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Curve = void 0;

var MathUtils = _interopRequireWildcard(require("../../math/MathUtils.js"));

var _Vector = require("../../math/Vector2.js");

var _Vector2 = require("../../math/Vector3.js");

var _Matrix = require("../../math/Matrix4.js");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * Extensible curve object.
 *
 * Some common of curve methods:
 * .getPoint( t, optionalTarget ), .getTangent( t, optionalTarget )
 * .getPointAt( u, optionalTarget ), .getTangentAt( u, optionalTarget )
 * .getPoints(), .getSpacedPoints()
 * .getLength()
 * .updateArcLengths()
 *
 * This following curves inherit from THREE.Curve:
 *
 * -- 2D curves --
 * THREE.ArcCurve
 * THREE.CubicBezierCurve
 * THREE.EllipseCurve
 * THREE.LineCurve
 * THREE.QuadraticBezierCurve
 * THREE.SplineCurve
 *
 * -- 3D curves --
 * THREE.CatmullRomCurve3
 * THREE.CubicBezierCurve3
 * THREE.LineCurve3
 * THREE.QuadraticBezierCurve3
 *
 * A series of curves can be represented as a THREE.CurvePath.
 *
 **/
class Curve {
  constructor() {
    this.type = 'Curve';
    this.arcLengthDivisions = 200;
  } // Virtual base class method to overwrite and implement in subclasses
  //	- t [0 .. 1]


  getPoint() {
    console.warn('THREE.Curve: .getPoint() not implemented.');
    return null;
  } // Get point at relative position in curve according to arc length
  // - u [0 .. 1]


  getPointAt(u, optionalTarget) {
    const t = this.getUtoTmapping(u);
    return this.getPoint(t, optionalTarget);
  } // Get sequence of points using getPoint( t )


  getPoints(divisions = 5) {
    const points = [];

    for (let d = 0; d <= divisions; d++) {
      points.push(this.getPoint(d / divisions));
    }

    return points;
  } // Get sequence of points using getPointAt( u )


  getSpacedPoints(divisions = 5) {
    const points = [];

    for (let d = 0; d <= divisions; d++) {
      points.push(this.getPointAt(d / divisions));
    }

    return points;
  } // Get total curve arc length


  getLength() {
    const lengths = this.getLengths();
    return lengths[lengths.length - 1];
  } // Get list of cumulative segment lengths


  getLengths(divisions = this.arcLengthDivisions) {
    if (this.cacheArcLengths && this.cacheArcLengths.length === divisions + 1 && !this.needsUpdate) {
      return this.cacheArcLengths;
    }

    this.needsUpdate = false;
    const cache = [];
    let current,
        last = this.getPoint(0);
    let sum = 0;
    cache.push(0);

    for (let p = 1; p <= divisions; p++) {
      current = this.getPoint(p / divisions);
      sum += current.distanceTo(last);
      cache.push(sum);
      last = current;
    }

    this.cacheArcLengths = cache;
    return cache; // { sums: cache, sum: sum }; Sum is in the last element.
  }

  updateArcLengths() {
    this.needsUpdate = true;
    this.getLengths();
  } // Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant


  getUtoTmapping(u, distance) {
    const arcLengths = this.getLengths();
    let i = 0;
    const il = arcLengths.length;
    let targetArcLength; // The targeted u distance value to get

    if (distance) {
      targetArcLength = distance;
    } else {
      targetArcLength = u * arcLengths[il - 1];
    } // binary search for the index with largest value smaller than target u distance


    let low = 0,
        high = il - 1,
        comparison;

    while (low <= high) {
      i = Math.floor(low + (high - low) / 2); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats

      comparison = arcLengths[i] - targetArcLength;

      if (comparison < 0) {
        low = i + 1;
      } else if (comparison > 0) {
        high = i - 1;
      } else {
        high = i;
        break; // DONE
      }
    }

    i = high;

    if (arcLengths[i] === targetArcLength) {
      return i / (il - 1);
    } // we could get finer grain at lengths, or use simple interpolation between two points


    const lengthBefore = arcLengths[i];
    const lengthAfter = arcLengths[i + 1];
    const segmentLength = lengthAfter - lengthBefore; // determine where we are between the 'before' and 'after' points

    const segmentFraction = (targetArcLength - lengthBefore) / segmentLength; // add that fractional amount to t

    const t = (i + segmentFraction) / (il - 1);
    return t;
  } // Returns a unit vector tangent at t
  // In case any sub curve does not implement its tangent derivation,
  // 2 points a small delta apart will be used to find its gradient
  // which seems to give a reasonable approximation


  getTangent(t, optionalTarget) {
    const delta = 0.0001;
    let t1 = t - delta;
    let t2 = t + delta; // Capping in case of danger

    if (t1 < 0) t1 = 0;
    if (t2 > 1) t2 = 1;
    const pt1 = this.getPoint(t1);
    const pt2 = this.getPoint(t2);
    const tangent = optionalTarget || (pt1.isVector2 ? new _Vector.Vector2() : new _Vector2.Vector3());
    tangent.copy(pt2).sub(pt1).normalize();
    return tangent;
  }

  getTangentAt(u, optionalTarget) {
    const t = this.getUtoTmapping(u);
    return this.getTangent(t, optionalTarget);
  }

  computeFrenetFrames(segments, closed) {
    // see http://www.cs.indiana.edu/pub/techreports/TR425.pdf
    const normal = new _Vector2.Vector3();
    const tangents = [];
    const normals = [];
    const binormals = [];
    const vec = new _Vector2.Vector3();
    const mat = new _Matrix.Matrix4(); // compute the tangent vectors for each segment on the curve

    for (let i = 0; i <= segments; i++) {
      const u = i / segments;
      tangents[i] = this.getTangentAt(u, new _Vector2.Vector3());
    } // select an initial normal vector perpendicular to the first tangent vector,
    // and in the direction of the minimum tangent xyz component


    normals[0] = new _Vector2.Vector3();
    binormals[0] = new _Vector2.Vector3();
    let min = Number.MAX_VALUE;
    const tx = Math.abs(tangents[0].x);
    const ty = Math.abs(tangents[0].y);
    const tz = Math.abs(tangents[0].z);

    if (tx <= min) {
      min = tx;
      normal.set(1, 0, 0);
    }

    if (ty <= min) {
      min = ty;
      normal.set(0, 1, 0);
    }

    if (tz <= min) {
      normal.set(0, 0, 1);
    }

    vec.crossVectors(tangents[0], normal).normalize();
    normals[0].crossVectors(tangents[0], vec);
    binormals[0].crossVectors(tangents[0], normals[0]); // compute the slowly-varying normal and binormal vectors for each segment on the curve

    for (let i = 1; i <= segments; i++) {
      normals[i] = normals[i - 1].clone();
      binormals[i] = binormals[i - 1].clone();
      vec.crossVectors(tangents[i - 1], tangents[i]);

      if (vec.length() > Number.EPSILON) {
        vec.normalize();
        const theta = Math.acos(MathUtils.clamp(tangents[i - 1].dot(tangents[i]), -1, 1)); // clamp for floating pt errors

        normals[i].applyMatrix4(mat.makeRotationAxis(vec, theta));
      }

      binormals[i].crossVectors(tangents[i], normals[i]);
    } // if the curve is closed, postprocess the vectors so the first and last normal vectors are the same


    if (closed === true) {
      let theta = Math.acos(MathUtils.clamp(normals[0].dot(normals[segments]), -1, 1));
      theta /= segments;

      if (tangents[0].dot(vec.crossVectors(normals[0], normals[segments])) > 0) {
        theta = -theta;
      }

      for (let i = 1; i <= segments; i++) {
        // twist a little...
        normals[i].applyMatrix4(mat.makeRotationAxis(tangents[i], theta * i));
        binormals[i].crossVectors(tangents[i], normals[i]);
      }
    }

    return {
      tangents: tangents,
      normals: normals,
      binormals: binormals
    };
  }

  clone() {
    return new this.constructor().copy(this);
  }

  copy(source) {
    this.arcLengthDivisions = source.arcLengthDivisions;
    return this;
  }

  toJSON() {
    const data = {
      metadata: {
        version: 4.6,
        type: 'Curve',
        generator: 'Curve.toJSON'
      }
    };
    data.arcLengthDivisions = this.arcLengthDivisions;
    data.type = this.type;
    return data;
  }

  fromJSON(json) {
    this.arcLengthDivisions = json.arcLengthDivisions;
    return this;
  }

}

exports.Curve = Curve;

},{"../../math/MathUtils.js":168,"../../math/Matrix4.js":170,"../../math/Vector2.js":174,"../../math/Vector3.js":175}],129:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CurvePath = void 0;

var _Curve = require("./Curve.js");

var Curves = _interopRequireWildcard(require("../curves/Curves.js"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**************************************************************
 *	Curved Path - a curve path is simply a array of connected
 *  curves, but retains the api of a curve
 **************************************************************/
class CurvePath extends _Curve.Curve {
  constructor() {
    super();
    this.type = 'CurvePath';
    this.curves = [];
    this.autoClose = false; // Automatically closes the path
  }

  add(curve) {
    this.curves.push(curve);
  }

  closePath() {
    // Add a line curve if start and end of lines are not connected
    const startPoint = this.curves[0].getPoint(0);
    const endPoint = this.curves[this.curves.length - 1].getPoint(1);

    if (!startPoint.equals(endPoint)) {
      this.curves.push(new Curves['LineCurve'](endPoint, startPoint));
    }
  } // To get accurate point with reference to
  // entire path distance at time t,
  // following has to be done:
  // 1. Length of each sub path have to be known
  // 2. Locate and identify type of curve
  // 3. Get t for the curve
  // 4. Return curve.getPointAt(t')


  getPoint(t, optionalTarget) {
    const d = t * this.getLength();
    const curveLengths = this.getCurveLengths();
    let i = 0; // To think about boundaries points.

    while (i < curveLengths.length) {
      if (curveLengths[i] >= d) {
        const diff = curveLengths[i] - d;
        const curve = this.curves[i];
        const segmentLength = curve.getLength();
        const u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;
        return curve.getPointAt(u, optionalTarget);
      }

      i++;
    }

    return null; // loop where sum != 0, sum > d , sum+1 <d
  } // We cannot use the default THREE.Curve getPoint() with getLength() because in
  // THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
  // getPoint() depends on getLength


  getLength() {
    const lens = this.getCurveLengths();
    return lens[lens.length - 1];
  } // cacheLengths must be recalculated.


  updateArcLengths() {
    this.needsUpdate = true;
    this.cacheLengths = null;
    this.getCurveLengths();
  } // Compute lengths and cache them
  // We cannot overwrite getLengths() because UtoT mapping uses it.


  getCurveLengths() {
    // We use cache values if curves and cache array are same length
    if (this.cacheLengths && this.cacheLengths.length === this.curves.length) {
      return this.cacheLengths;
    } // Get length of sub-curve
    // Push sums into cached array


    const lengths = [];
    let sums = 0;

    for (let i = 0, l = this.curves.length; i < l; i++) {
      sums += this.curves[i].getLength();
      lengths.push(sums);
    }

    this.cacheLengths = lengths;
    return lengths;
  }

  getSpacedPoints(divisions = 40) {
    const points = [];

    for (let i = 0; i <= divisions; i++) {
      points.push(this.getPoint(i / divisions));
    }

    if (this.autoClose) {
      points.push(points[0]);
    }

    return points;
  }

  getPoints(divisions = 12) {
    const points = [];
    let last;

    for (let i = 0, curves = this.curves; i < curves.length; i++) {
      const curve = curves[i];
      const resolution = curve.isEllipseCurve ? divisions * 2 : curve.isLineCurve || curve.isLineCurve3 ? 1 : curve.isSplineCurve ? divisions * curve.points.length : divisions;
      const pts = curve.getPoints(resolution);

      for (let j = 0; j < pts.length; j++) {
        const point = pts[j];
        if (last && last.equals(point)) continue; // ensures no consecutive points are duplicates

        points.push(point);
        last = point;
      }
    }

    if (this.autoClose && points.length > 1 && !points[points.length - 1].equals(points[0])) {
      points.push(points[0]);
    }

    return points;
  }

  copy(source) {
    super.copy(source);
    this.curves = [];

    for (let i = 0, l = source.curves.length; i < l; i++) {
      const curve = source.curves[i];
      this.curves.push(curve.clone());
    }

    this.autoClose = source.autoClose;
    return this;
  }

  toJSON() {
    const data = super.toJSON();
    data.autoClose = this.autoClose;
    data.curves = [];

    for (let i = 0, l = this.curves.length; i < l; i++) {
      const curve = this.curves[i];
      data.curves.push(curve.toJSON());
    }

    return data;
  }

  fromJSON(json) {
    super.fromJSON(json);
    this.autoClose = json.autoClose;
    this.curves = [];

    for (let i = 0, l = json.curves.length; i < l; i++) {
      const curve = json.curves[i];
      this.curves.push(new Curves[curve.type]().fromJSON(curve));
    }

    return this;
  }

}

exports.CurvePath = CurvePath;

},{"../curves/Curves.js":137,"./Curve.js":128}],130:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CatmullRom = CatmullRom;
exports.CubicBezier = CubicBezier;
exports.QuadraticBezier = QuadraticBezier;

/**
 * Bezier Curves formulas obtained from
 * https://en.wikipedia.org/wiki/B%C3%A9zier_curve
 */
function CatmullRom(t, p0, p1, p2, p3) {
  const v0 = (p2 - p0) * 0.5;
  const v1 = (p3 - p1) * 0.5;
  const t2 = t * t;
  const t3 = t * t2;
  return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;
} //


function QuadraticBezierP0(t, p) {
  const k = 1 - t;
  return k * k * p;
}

function QuadraticBezierP1(t, p) {
  return 2 * (1 - t) * t * p;
}

function QuadraticBezierP2(t, p) {
  return t * t * p;
}

function QuadraticBezier(t, p0, p1, p2) {
  return QuadraticBezierP0(t, p0) + QuadraticBezierP1(t, p1) + QuadraticBezierP2(t, p2);
} //


function CubicBezierP0(t, p) {
  const k = 1 - t;
  return k * k * k * p;
}

function CubicBezierP1(t, p) {
  const k = 1 - t;
  return 3 * k * k * t * p;
}

function CubicBezierP2(t, p) {
  return 3 * (1 - t) * t * t * p;
}

function CubicBezierP3(t, p) {
  return t * t * t * p;
}

function CubicBezier(t, p0, p1, p2, p3) {
  return CubicBezierP0(t, p0) + CubicBezierP1(t, p1) + CubicBezierP2(t, p2) + CubicBezierP3(t, p3);
}

},{}],131:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Path = void 0;

var _Vector = require("../../math/Vector2.js");

var _CurvePath = require("./CurvePath.js");

var _EllipseCurve = require("../curves/EllipseCurve.js");

var _SplineCurve = require("../curves/SplineCurve.js");

var _CubicBezierCurve = require("../curves/CubicBezierCurve.js");

var _QuadraticBezierCurve = require("../curves/QuadraticBezierCurve.js");

var _LineCurve = require("../curves/LineCurve.js");

class Path extends _CurvePath.CurvePath {
  constructor(points) {
    super();
    this.type = 'Path';
    this.currentPoint = new _Vector.Vector2();

    if (points) {
      this.setFromPoints(points);
    }
  }

  setFromPoints(points) {
    this.moveTo(points[0].x, points[0].y);

    for (let i = 1, l = points.length; i < l; i++) {
      this.lineTo(points[i].x, points[i].y);
    }

    return this;
  }

  moveTo(x, y) {
    this.currentPoint.set(x, y); // TODO consider referencing vectors instead of copying?

    return this;
  }

  lineTo(x, y) {
    const curve = new _LineCurve.LineCurve(this.currentPoint.clone(), new _Vector.Vector2(x, y));
    this.curves.push(curve);
    this.currentPoint.set(x, y);
    return this;
  }

  quadraticCurveTo(aCPx, aCPy, aX, aY) {
    const curve = new _QuadraticBezierCurve.QuadraticBezierCurve(this.currentPoint.clone(), new _Vector.Vector2(aCPx, aCPy), new _Vector.Vector2(aX, aY));
    this.curves.push(curve);
    this.currentPoint.set(aX, aY);
    return this;
  }

  bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
    const curve = new _CubicBezierCurve.CubicBezierCurve(this.currentPoint.clone(), new _Vector.Vector2(aCP1x, aCP1y), new _Vector.Vector2(aCP2x, aCP2y), new _Vector.Vector2(aX, aY));
    this.curves.push(curve);
    this.currentPoint.set(aX, aY);
    return this;
  }

  splineThru(pts
  /*Array of Vector*/
  ) {
    const npts = [this.currentPoint.clone()].concat(pts);
    const curve = new _SplineCurve.SplineCurve(npts);
    this.curves.push(curve);
    this.currentPoint.copy(pts[pts.length - 1]);
    return this;
  }

  arc(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
    const x0 = this.currentPoint.x;
    const y0 = this.currentPoint.y;
    this.absarc(aX + x0, aY + y0, aRadius, aStartAngle, aEndAngle, aClockwise);
    return this;
  }

  absarc(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
    this.absellipse(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
    return this;
  }

  ellipse(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
    const x0 = this.currentPoint.x;
    const y0 = this.currentPoint.y;
    this.absellipse(aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
    return this;
  }

  absellipse(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
    const curve = new _EllipseCurve.EllipseCurve(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);

    if (this.curves.length > 0) {
      // if a previous curve is present, attempt to join
      const firstPoint = curve.getPoint(0);

      if (!firstPoint.equals(this.currentPoint)) {
        this.lineTo(firstPoint.x, firstPoint.y);
      }
    }

    this.curves.push(curve);
    const lastPoint = curve.getPoint(1);
    this.currentPoint.copy(lastPoint);
    return this;
  }

  copy(source) {
    super.copy(source);
    this.currentPoint.copy(source.currentPoint);
    return this;
  }

  toJSON() {
    const data = super.toJSON();
    data.currentPoint = this.currentPoint.toArray();
    return data;
  }

  fromJSON(json) {
    super.fromJSON(json);
    this.currentPoint.fromArray(json.currentPoint);
    return this;
  }

}

exports.Path = Path;

},{"../../math/Vector2.js":174,"../curves/CubicBezierCurve.js":135,"../curves/EllipseCurve.js":138,"../curves/LineCurve.js":139,"../curves/QuadraticBezierCurve.js":141,"../curves/SplineCurve.js":143,"./CurvePath.js":129}],132:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Shape = void 0;

var _Path = require("./Path.js");

var MathUtils = _interopRequireWildcard(require("../../math/MathUtils.js"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

class Shape extends _Path.Path {
  constructor(points) {
    super(points);
    this.uuid = MathUtils.generateUUID();
    this.type = 'Shape';
    this.holes = [];
  }

  getPointsHoles(divisions) {
    const holesPts = [];

    for (let i = 0, l = this.holes.length; i < l; i++) {
      holesPts[i] = this.holes[i].getPoints(divisions);
    }

    return holesPts;
  } // get points of shape and holes (keypoints based on segments parameter)


  extractPoints(divisions) {
    return {
      shape: this.getPoints(divisions),
      holes: this.getPointsHoles(divisions)
    };
  }

  copy(source) {
    super.copy(source);
    this.holes = [];

    for (let i = 0, l = source.holes.length; i < l; i++) {
      const hole = source.holes[i];
      this.holes.push(hole.clone());
    }

    return this;
  }

  toJSON() {
    const data = super.toJSON();
    data.uuid = this.uuid;
    data.holes = [];

    for (let i = 0, l = this.holes.length; i < l; i++) {
      const hole = this.holes[i];
      data.holes.push(hole.toJSON());
    }

    return data;
  }

  fromJSON(json) {
    super.fromJSON(json);
    this.uuid = json.uuid;
    this.holes = [];

    for (let i = 0, l = json.holes.length; i < l; i++) {
      const hole = json.holes[i];
      this.holes.push(new _Path.Path().fromJSON(hole));
    }

    return this;
  }

}

exports.Shape = Shape;

},{"../../math/MathUtils.js":168,"./Path.js":131}],133:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ArcCurve = void 0;

var _EllipseCurve = require("./EllipseCurve.js");

class ArcCurve extends _EllipseCurve.EllipseCurve {
  constructor(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
    super(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
    this.isArcCurve = true;
    this.type = 'ArcCurve';
  }

}

exports.ArcCurve = ArcCurve;

},{"./EllipseCurve.js":138}],134:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CatmullRomCurve3 = void 0;

var _Vector = require("../../math/Vector3.js");

var _Curve = require("../core/Curve.js");

/**
 * Centripetal CatmullRom Curve - which is useful for avoiding
 * cusps and self-intersections in non-uniform catmull rom curves.
 * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf
 *
 * curve.type accepts centripetal(default), chordal and catmullrom
 * curve.tension is used for catmullrom which defaults to 0.5
 */

/*
Based on an optimized c++ solution in
 - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/
 - http://ideone.com/NoEbVM

This CubicPoly class could be used for reusing some variables and calculations,
but for three.js curve use, it could be possible inlined and flatten into a single function call
which can be placed in CurveUtils.
*/
function CubicPoly() {
  let c0 = 0,
      c1 = 0,
      c2 = 0,
      c3 = 0;
  /*
   * Compute coefficients for a cubic polynomial
   *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3
   * such that
   *   p(0) = x0, p(1) = x1
   *  and
   *   p'(0) = t0, p'(1) = t1.
   */

  function init(x0, x1, t0, t1) {
    c0 = x0;
    c1 = t0;
    c2 = -3 * x0 + 3 * x1 - 2 * t0 - t1;
    c3 = 2 * x0 - 2 * x1 + t0 + t1;
  }

  return {
    initCatmullRom: function (x0, x1, x2, x3, tension) {
      init(x1, x2, tension * (x2 - x0), tension * (x3 - x1));
    },
    initNonuniformCatmullRom: function (x0, x1, x2, x3, dt0, dt1, dt2) {
      // compute tangents when parameterized in [t1,t2]
      let t1 = (x1 - x0) / dt0 - (x2 - x0) / (dt0 + dt1) + (x2 - x1) / dt1;
      let t2 = (x2 - x1) / dt1 - (x3 - x1) / (dt1 + dt2) + (x3 - x2) / dt2; // rescale tangents for parametrization in [0,1]

      t1 *= dt1;
      t2 *= dt1;
      init(x1, x2, t1, t2);
    },
    calc: function (t) {
      const t2 = t * t;
      const t3 = t2 * t;
      return c0 + c1 * t + c2 * t2 + c3 * t3;
    }
  };
} //


const tmp = /*@__PURE__*/new _Vector.Vector3();
const px = /*@__PURE__*/new CubicPoly();
const py = /*@__PURE__*/new CubicPoly();
const pz = /*@__PURE__*/new CubicPoly();

class CatmullRomCurve3 extends _Curve.Curve {
  constructor(points = [], closed = false, curveType = 'centripetal', tension = 0.5) {
    super();
    this.isCatmullRomCurve3 = true;
    this.type = 'CatmullRomCurve3';
    this.points = points;
    this.closed = closed;
    this.curveType = curveType;
    this.tension = tension;
  }

  getPoint(t, optionalTarget = new _Vector.Vector3()) {
    const point = optionalTarget;
    const points = this.points;
    const l = points.length;
    const p = (l - (this.closed ? 0 : 1)) * t;
    let intPoint = Math.floor(p);
    let weight = p - intPoint;

    if (this.closed) {
      intPoint += intPoint > 0 ? 0 : (Math.floor(Math.abs(intPoint) / l) + 1) * l;
    } else if (weight === 0 && intPoint === l - 1) {
      intPoint = l - 2;
      weight = 1;
    }

    let p0, p3; // 4 points (p1 & p2 defined below)

    if (this.closed || intPoint > 0) {
      p0 = points[(intPoint - 1) % l];
    } else {
      // extrapolate first point
      tmp.subVectors(points[0], points[1]).add(points[0]);
      p0 = tmp;
    }

    const p1 = points[intPoint % l];
    const p2 = points[(intPoint + 1) % l];

    if (this.closed || intPoint + 2 < l) {
      p3 = points[(intPoint + 2) % l];
    } else {
      // extrapolate last point
      tmp.subVectors(points[l - 1], points[l - 2]).add(points[l - 1]);
      p3 = tmp;
    }

    if (this.curveType === 'centripetal' || this.curveType === 'chordal') {
      // init Centripetal / Chordal Catmull-Rom
      const pow = this.curveType === 'chordal' ? 0.5 : 0.25;
      let dt0 = Math.pow(p0.distanceToSquared(p1), pow);
      let dt1 = Math.pow(p1.distanceToSquared(p2), pow);
      let dt2 = Math.pow(p2.distanceToSquared(p3), pow); // safety check for repeated points

      if (dt1 < 1e-4) dt1 = 1.0;
      if (dt0 < 1e-4) dt0 = dt1;
      if (dt2 < 1e-4) dt2 = dt1;
      px.initNonuniformCatmullRom(p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2);
      py.initNonuniformCatmullRom(p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2);
      pz.initNonuniformCatmullRom(p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2);
    } else if (this.curveType === 'catmullrom') {
      px.initCatmullRom(p0.x, p1.x, p2.x, p3.x, this.tension);
      py.initCatmullRom(p0.y, p1.y, p2.y, p3.y, this.tension);
      pz.initCatmullRom(p0.z, p1.z, p2.z, p3.z, this.tension);
    }

    point.set(px.calc(weight), py.calc(weight), pz.calc(weight));
    return point;
  }

  copy(source) {
    super.copy(source);
    this.points = [];

    for (let i = 0, l = source.points.length; i < l; i++) {
      const point = source.points[i];
      this.points.push(point.clone());
    }

    this.closed = source.closed;
    this.curveType = source.curveType;
    this.tension = source.tension;
    return this;
  }

  toJSON() {
    const data = super.toJSON();
    data.points = [];

    for (let i = 0, l = this.points.length; i < l; i++) {
      const point = this.points[i];
      data.points.push(point.toArray());
    }

    data.closed = this.closed;
    data.curveType = this.curveType;
    data.tension = this.tension;
    return data;
  }

  fromJSON(json) {
    super.fromJSON(json);
    this.points = [];

    for (let i = 0, l = json.points.length; i < l; i++) {
      const point = json.points[i];
      this.points.push(new _Vector.Vector3().fromArray(point));
    }

    this.closed = json.closed;
    this.curveType = json.curveType;
    this.tension = json.tension;
    return this;
  }

}

exports.CatmullRomCurve3 = CatmullRomCurve3;

},{"../../math/Vector3.js":175,"../core/Curve.js":128}],135:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CubicBezierCurve = void 0;

var _Curve = require("../core/Curve.js");

var _Interpolations = require("../core/Interpolations.js");

var _Vector = require("../../math/Vector2.js");

class CubicBezierCurve extends _Curve.Curve {
  constructor(v0 = new _Vector.Vector2(), v1 = new _Vector.Vector2(), v2 = new _Vector.Vector2(), v3 = new _Vector.Vector2()) {
    super();
    this.isCubicBezierCurve = true;
    this.type = 'CubicBezierCurve';
    this.v0 = v0;
    this.v1 = v1;
    this.v2 = v2;
    this.v3 = v3;
  }

  getPoint(t, optionalTarget = new _Vector.Vector2()) {
    const point = optionalTarget;
    const v0 = this.v0,
          v1 = this.v1,
          v2 = this.v2,
          v3 = this.v3;
    point.set((0, _Interpolations.CubicBezier)(t, v0.x, v1.x, v2.x, v3.x), (0, _Interpolations.CubicBezier)(t, v0.y, v1.y, v2.y, v3.y));
    return point;
  }

  copy(source) {
    super.copy(source);
    this.v0.copy(source.v0);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    this.v3.copy(source.v3);
    return this;
  }

  toJSON() {
    const data = super.toJSON();
    data.v0 = this.v0.toArray();
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    data.v3 = this.v3.toArray();
    return data;
  }

  fromJSON(json) {
    super.fromJSON(json);
    this.v0.fromArray(json.v0);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    this.v3.fromArray(json.v3);
    return this;
  }

}

exports.CubicBezierCurve = CubicBezierCurve;

},{"../../math/Vector2.js":174,"../core/Curve.js":128,"../core/Interpolations.js":130}],136:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CubicBezierCurve3 = void 0;

var _Curve = require("../core/Curve.js");

var _Interpolations = require("../core/Interpolations.js");

var _Vector = require("../../math/Vector3.js");

class CubicBezierCurve3 extends _Curve.Curve {
  constructor(v0 = new _Vector.Vector3(), v1 = new _Vector.Vector3(), v2 = new _Vector.Vector3(), v3 = new _Vector.Vector3()) {
    super();
    this.isCubicBezierCurve3 = true;
    this.type = 'CubicBezierCurve3';
    this.v0 = v0;
    this.v1 = v1;
    this.v2 = v2;
    this.v3 = v3;
  }

  getPoint(t, optionalTarget = new _Vector.Vector3()) {
    const point = optionalTarget;
    const v0 = this.v0,
          v1 = this.v1,
          v2 = this.v2,
          v3 = this.v3;
    point.set((0, _Interpolations.CubicBezier)(t, v0.x, v1.x, v2.x, v3.x), (0, _Interpolations.CubicBezier)(t, v0.y, v1.y, v2.y, v3.y), (0, _Interpolations.CubicBezier)(t, v0.z, v1.z, v2.z, v3.z));
    return point;
  }

  copy(source) {
    super.copy(source);
    this.v0.copy(source.v0);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    this.v3.copy(source.v3);
    return this;
  }

  toJSON() {
    const data = super.toJSON();
    data.v0 = this.v0.toArray();
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    data.v3 = this.v3.toArray();
    return data;
  }

  fromJSON(json) {
    super.fromJSON(json);
    this.v0.fromArray(json.v0);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    this.v3.fromArray(json.v3);
    return this;
  }

}

exports.CubicBezierCurve3 = CubicBezierCurve3;

},{"../../math/Vector3.js":175,"../core/Curve.js":128,"../core/Interpolations.js":130}],137:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "ArcCurve", {
  enumerable: true,
  get: function () {
    return _ArcCurve.ArcCurve;
  }
});
Object.defineProperty(exports, "CatmullRomCurve3", {
  enumerable: true,
  get: function () {
    return _CatmullRomCurve.CatmullRomCurve3;
  }
});
Object.defineProperty(exports, "CubicBezierCurve", {
  enumerable: true,
  get: function () {
    return _CubicBezierCurve.CubicBezierCurve;
  }
});
Object.defineProperty(exports, "CubicBezierCurve3", {
  enumerable: true,
  get: function () {
    return _CubicBezierCurve2.CubicBezierCurve3;
  }
});
Object.defineProperty(exports, "EllipseCurve", {
  enumerable: true,
  get: function () {
    return _EllipseCurve.EllipseCurve;
  }
});
Object.defineProperty(exports, "LineCurve", {
  enumerable: true,
  get: function () {
    return _LineCurve.LineCurve;
  }
});
Object.defineProperty(exports, "LineCurve3", {
  enumerable: true,
  get: function () {
    return _LineCurve2.LineCurve3;
  }
});
Object.defineProperty(exports, "QuadraticBezierCurve", {
  enumerable: true,
  get: function () {
    return _QuadraticBezierCurve.QuadraticBezierCurve;
  }
});
Object.defineProperty(exports, "QuadraticBezierCurve3", {
  enumerable: true,
  get: function () {
    return _QuadraticBezierCurve2.QuadraticBezierCurve3;
  }
});
Object.defineProperty(exports, "SplineCurve", {
  enumerable: true,
  get: function () {
    return _SplineCurve.SplineCurve;
  }
});

var _ArcCurve = require("./ArcCurve.js");

var _CatmullRomCurve = require("./CatmullRomCurve3.js");

var _CubicBezierCurve = require("./CubicBezierCurve.js");

var _CubicBezierCurve2 = require("./CubicBezierCurve3.js");

var _EllipseCurve = require("./EllipseCurve.js");

var _LineCurve = require("./LineCurve.js");

var _LineCurve2 = require("./LineCurve3.js");

var _QuadraticBezierCurve = require("./QuadraticBezierCurve.js");

var _QuadraticBezierCurve2 = require("./QuadraticBezierCurve3.js");

var _SplineCurve = require("./SplineCurve.js");

},{"./ArcCurve.js":133,"./CatmullRomCurve3.js":134,"./CubicBezierCurve.js":135,"./CubicBezierCurve3.js":136,"./EllipseCurve.js":138,"./LineCurve.js":139,"./LineCurve3.js":140,"./QuadraticBezierCurve.js":141,"./QuadraticBezierCurve3.js":142,"./SplineCurve.js":143}],138:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.EllipseCurve = void 0;

var _Curve = require("../core/Curve.js");

var _Vector = require("../../math/Vector2.js");

class EllipseCurve extends _Curve.Curve {
  constructor(aX = 0, aY = 0, xRadius = 1, yRadius = 1, aStartAngle = 0, aEndAngle = Math.PI * 2, aClockwise = false, aRotation = 0) {
    super();
    this.isEllipseCurve = true;
    this.type = 'EllipseCurve';
    this.aX = aX;
    this.aY = aY;
    this.xRadius = xRadius;
    this.yRadius = yRadius;
    this.aStartAngle = aStartAngle;
    this.aEndAngle = aEndAngle;
    this.aClockwise = aClockwise;
    this.aRotation = aRotation;
  }

  getPoint(t, optionalTarget) {
    const point = optionalTarget || new _Vector.Vector2();
    const twoPi = Math.PI * 2;
    let deltaAngle = this.aEndAngle - this.aStartAngle;
    const samePoints = Math.abs(deltaAngle) < Number.EPSILON; // ensures that deltaAngle is 0 .. 2 PI

    while (deltaAngle < 0) deltaAngle += twoPi;

    while (deltaAngle > twoPi) deltaAngle -= twoPi;

    if (deltaAngle < Number.EPSILON) {
      if (samePoints) {
        deltaAngle = 0;
      } else {
        deltaAngle = twoPi;
      }
    }

    if (this.aClockwise === true && !samePoints) {
      if (deltaAngle === twoPi) {
        deltaAngle = -twoPi;
      } else {
        deltaAngle = deltaAngle - twoPi;
      }
    }

    const angle = this.aStartAngle + t * deltaAngle;
    let x = this.aX + this.xRadius * Math.cos(angle);
    let y = this.aY + this.yRadius * Math.sin(angle);

    if (this.aRotation !== 0) {
      const cos = Math.cos(this.aRotation);
      const sin = Math.sin(this.aRotation);
      const tx = x - this.aX;
      const ty = y - this.aY; // Rotate the point about the center of the ellipse.

      x = tx * cos - ty * sin + this.aX;
      y = tx * sin + ty * cos + this.aY;
    }

    return point.set(x, y);
  }

  copy(source) {
    super.copy(source);
    this.aX = source.aX;
    this.aY = source.aY;
    this.xRadius = source.xRadius;
    this.yRadius = source.yRadius;
    this.aStartAngle = source.aStartAngle;
    this.aEndAngle = source.aEndAngle;
    this.aClockwise = source.aClockwise;
    this.aRotation = source.aRotation;
    return this;
  }

  toJSON() {
    const data = super.toJSON();
    data.aX = this.aX;
    data.aY = this.aY;
    data.xRadius = this.xRadius;
    data.yRadius = this.yRadius;
    data.aStartAngle = this.aStartAngle;
    data.aEndAngle = this.aEndAngle;
    data.aClockwise = this.aClockwise;
    data.aRotation = this.aRotation;
    return data;
  }

  fromJSON(json) {
    super.fromJSON(json);
    this.aX = json.aX;
    this.aY = json.aY;
    this.xRadius = json.xRadius;
    this.yRadius = json.yRadius;
    this.aStartAngle = json.aStartAngle;
    this.aEndAngle = json.aEndAngle;
    this.aClockwise = json.aClockwise;
    this.aRotation = json.aRotation;
    return this;
  }

}

exports.EllipseCurve = EllipseCurve;

},{"../../math/Vector2.js":174,"../core/Curve.js":128}],139:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.LineCurve = void 0;

var _Vector = require("../../math/Vector2.js");

var _Curve = require("../core/Curve.js");

class LineCurve extends _Curve.Curve {
  constructor(v1 = new _Vector.Vector2(), v2 = new _Vector.Vector2()) {
    super();
    this.isLineCurve = true;
    this.type = 'LineCurve';
    this.v1 = v1;
    this.v2 = v2;
  }

  getPoint(t, optionalTarget = new _Vector.Vector2()) {
    const point = optionalTarget;

    if (t === 1) {
      point.copy(this.v2);
    } else {
      point.copy(this.v2).sub(this.v1);
      point.multiplyScalar(t).add(this.v1);
    }

    return point;
  } // Line curve is linear, so we can overwrite default getPointAt


  getPointAt(u, optionalTarget) {
    return this.getPoint(u, optionalTarget);
  }

  getTangent(t, optionalTarget = new _Vector.Vector2()) {
    return optionalTarget.subVectors(this.v2, this.v1).normalize();
  }

  getTangentAt(u, optionalTarget) {
    return this.getTangent(u, optionalTarget);
  }

  copy(source) {
    super.copy(source);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    return this;
  }

  toJSON() {
    const data = super.toJSON();
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    return data;
  }

  fromJSON(json) {
    super.fromJSON(json);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    return this;
  }

}

exports.LineCurve = LineCurve;

},{"../../math/Vector2.js":174,"../core/Curve.js":128}],140:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.LineCurve3 = void 0;

var _Vector = require("../../math/Vector3.js");

var _Curve = require("../core/Curve.js");

class LineCurve3 extends _Curve.Curve {
  constructor(v1 = new _Vector.Vector3(), v2 = new _Vector.Vector3()) {
    super();
    this.isLineCurve3 = true;
    this.type = 'LineCurve3';
    this.v1 = v1;
    this.v2 = v2;
  }

  getPoint(t, optionalTarget = new _Vector.Vector3()) {
    const point = optionalTarget;

    if (t === 1) {
      point.copy(this.v2);
    } else {
      point.copy(this.v2).sub(this.v1);
      point.multiplyScalar(t).add(this.v1);
    }

    return point;
  } // Line curve is linear, so we can overwrite default getPointAt


  getPointAt(u, optionalTarget) {
    return this.getPoint(u, optionalTarget);
  }

  getTangent(t, optionalTarget = new _Vector.Vector3()) {
    return optionalTarget.subVectors(this.v2, this.v1).normalize();
  }

  getTangentAt(u, optionalTarget) {
    return this.getTangent(u, optionalTarget);
  }

  copy(source) {
    super.copy(source);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    return this;
  }

  toJSON() {
    const data = super.toJSON();
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    return data;
  }

  fromJSON(json) {
    super.fromJSON(json);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    return this;
  }

}

exports.LineCurve3 = LineCurve3;

},{"../../math/Vector3.js":175,"../core/Curve.js":128}],141:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.QuadraticBezierCurve = void 0;

var _Curve = require("../core/Curve.js");

var _Interpolations = require("../core/Interpolations.js");

var _Vector = require("../../math/Vector2.js");

class QuadraticBezierCurve extends _Curve.Curve {
  constructor(v0 = new _Vector.Vector2(), v1 = new _Vector.Vector2(), v2 = new _Vector.Vector2()) {
    super();
    this.isQuadraticBezierCurve = true;
    this.type = 'QuadraticBezierCurve';
    this.v0 = v0;
    this.v1 = v1;
    this.v2 = v2;
  }

  getPoint(t, optionalTarget = new _Vector.Vector2()) {
    const point = optionalTarget;
    const v0 = this.v0,
          v1 = this.v1,
          v2 = this.v2;
    point.set((0, _Interpolations.QuadraticBezier)(t, v0.x, v1.x, v2.x), (0, _Interpolations.QuadraticBezier)(t, v0.y, v1.y, v2.y));
    return point;
  }

  copy(source) {
    super.copy(source);
    this.v0.copy(source.v0);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    return this;
  }

  toJSON() {
    const data = super.toJSON();
    data.v0 = this.v0.toArray();
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    return data;
  }

  fromJSON(json) {
    super.fromJSON(json);
    this.v0.fromArray(json.v0);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    return this;
  }

}

exports.QuadraticBezierCurve = QuadraticBezierCurve;

},{"../../math/Vector2.js":174,"../core/Curve.js":128,"../core/Interpolations.js":130}],142:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.QuadraticBezierCurve3 = void 0;

var _Curve = require("../core/Curve.js");

var _Interpolations = require("../core/Interpolations.js");

var _Vector = require("../../math/Vector3.js");

class QuadraticBezierCurve3 extends _Curve.Curve {
  constructor(v0 = new _Vector.Vector3(), v1 = new _Vector.Vector3(), v2 = new _Vector.Vector3()) {
    super();
    this.isQuadraticBezierCurve3 = true;
    this.type = 'QuadraticBezierCurve3';
    this.v0 = v0;
    this.v1 = v1;
    this.v2 = v2;
  }

  getPoint(t, optionalTarget = new _Vector.Vector3()) {
    const point = optionalTarget;
    const v0 = this.v0,
          v1 = this.v1,
          v2 = this.v2;
    point.set((0, _Interpolations.QuadraticBezier)(t, v0.x, v1.x, v2.x), (0, _Interpolations.QuadraticBezier)(t, v0.y, v1.y, v2.y), (0, _Interpolations.QuadraticBezier)(t, v0.z, v1.z, v2.z));
    return point;
  }

  copy(source) {
    super.copy(source);
    this.v0.copy(source.v0);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    return this;
  }

  toJSON() {
    const data = super.toJSON();
    data.v0 = this.v0.toArray();
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    return data;
  }

  fromJSON(json) {
    super.fromJSON(json);
    this.v0.fromArray(json.v0);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    return this;
  }

}

exports.QuadraticBezierCurve3 = QuadraticBezierCurve3;

},{"../../math/Vector3.js":175,"../core/Curve.js":128,"../core/Interpolations.js":130}],143:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SplineCurve = void 0;

var _Curve = require("../core/Curve.js");

var _Interpolations = require("../core/Interpolations.js");

var _Vector = require("../../math/Vector2.js");

class SplineCurve extends _Curve.Curve {
  constructor(points = []) {
    super();
    this.isSplineCurve = true;
    this.type = 'SplineCurve';
    this.points = points;
  }

  getPoint(t, optionalTarget = new _Vector.Vector2()) {
    const point = optionalTarget;
    const points = this.points;
    const p = (points.length - 1) * t;
    const intPoint = Math.floor(p);
    const weight = p - intPoint;
    const p0 = points[intPoint === 0 ? intPoint : intPoint - 1];
    const p1 = points[intPoint];
    const p2 = points[intPoint > points.length - 2 ? points.length - 1 : intPoint + 1];
    const p3 = points[intPoint > points.length - 3 ? points.length - 1 : intPoint + 2];
    point.set((0, _Interpolations.CatmullRom)(weight, p0.x, p1.x, p2.x, p3.x), (0, _Interpolations.CatmullRom)(weight, p0.y, p1.y, p2.y, p3.y));
    return point;
  }

  copy(source) {
    super.copy(source);
    this.points = [];

    for (let i = 0, l = source.points.length; i < l; i++) {
      const point = source.points[i];
      this.points.push(point.clone());
    }

    return this;
  }

  toJSON() {
    const data = super.toJSON();
    data.points = [];

    for (let i = 0, l = this.points.length; i < l; i++) {
      const point = this.points[i];
      data.points.push(point.toArray());
    }

    return data;
  }

  fromJSON(json) {
    super.fromJSON(json);
    this.points = [];

    for (let i = 0, l = json.points.length; i < l; i++) {
      const point = json.points[i];
      this.points.push(new _Vector.Vector2().fromArray(point));
    }

    return this;
  }

}

exports.SplineCurve = SplineCurve;

},{"../../math/Vector2.js":174,"../core/Curve.js":128,"../core/Interpolations.js":130}],144:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BoxGeometry = void 0;

var _BufferGeometry = require("../core/BufferGeometry.js");

var _BufferAttribute = require("../core/BufferAttribute.js");

var _Vector = require("../math/Vector3.js");

class BoxGeometry extends _BufferGeometry.BufferGeometry {
  constructor(width = 1, height = 1, depth = 1, widthSegments = 1, heightSegments = 1, depthSegments = 1) {
    super();
    this.type = 'BoxGeometry';
    this.parameters = {
      width: width,
      height: height,
      depth: depth,
      widthSegments: widthSegments,
      heightSegments: heightSegments,
      depthSegments: depthSegments
    };
    const scope = this; // segments

    widthSegments = Math.floor(widthSegments);
    heightSegments = Math.floor(heightSegments);
    depthSegments = Math.floor(depthSegments); // buffers

    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = []; // helper variables

    let numberOfVertices = 0;
    let groupStart = 0; // build each side of the box geometry

    buildPlane('z', 'y', 'x', -1, -1, depth, height, width, depthSegments, heightSegments, 0); // px

    buildPlane('z', 'y', 'x', 1, -1, depth, height, -width, depthSegments, heightSegments, 1); // nx

    buildPlane('x', 'z', 'y', 1, 1, width, depth, height, widthSegments, depthSegments, 2); // py

    buildPlane('x', 'z', 'y', 1, -1, width, depth, -height, widthSegments, depthSegments, 3); // ny

    buildPlane('x', 'y', 'z', 1, -1, width, height, depth, widthSegments, heightSegments, 4); // pz

    buildPlane('x', 'y', 'z', -1, -1, width, height, -depth, widthSegments, heightSegments, 5); // nz
    // build geometry

    this.setIndex(indices);
    this.setAttribute('position', new _BufferAttribute.Float32BufferAttribute(vertices, 3));
    this.setAttribute('normal', new _BufferAttribute.Float32BufferAttribute(normals, 3));
    this.setAttribute('uv', new _BufferAttribute.Float32BufferAttribute(uvs, 2));

    function buildPlane(u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex) {
      const segmentWidth = width / gridX;
      const segmentHeight = height / gridY;
      const widthHalf = width / 2;
      const heightHalf = height / 2;
      const depthHalf = depth / 2;
      const gridX1 = gridX + 1;
      const gridY1 = gridY + 1;
      let vertexCounter = 0;
      let groupCount = 0;
      const vector = new _Vector.Vector3(); // generate vertices, normals and uvs

      for (let iy = 0; iy < gridY1; iy++) {
        const y = iy * segmentHeight - heightHalf;

        for (let ix = 0; ix < gridX1; ix++) {
          const x = ix * segmentWidth - widthHalf; // set values to correct vector component

          vector[u] = x * udir;
          vector[v] = y * vdir;
          vector[w] = depthHalf; // now apply vector to vertex buffer

          vertices.push(vector.x, vector.y, vector.z); // set values to correct vector component

          vector[u] = 0;
          vector[v] = 0;
          vector[w] = depth > 0 ? 1 : -1; // now apply vector to normal buffer

          normals.push(vector.x, vector.y, vector.z); // uvs

          uvs.push(ix / gridX);
          uvs.push(1 - iy / gridY); // counters

          vertexCounter += 1;
        }
      } // indices
      // 1. you need three indices to draw a single face
      // 2. a single segment consists of two faces
      // 3. so we need to generate six (2*3) indices per segment


      for (let iy = 0; iy < gridY; iy++) {
        for (let ix = 0; ix < gridX; ix++) {
          const a = numberOfVertices + ix + gridX1 * iy;
          const b = numberOfVertices + ix + gridX1 * (iy + 1);
          const c = numberOfVertices + (ix + 1) + gridX1 * (iy + 1);
          const d = numberOfVertices + (ix + 1) + gridX1 * iy; // faces

          indices.push(a, b, d);
          indices.push(b, c, d); // increase counter

          groupCount += 6;
        }
      } // add a group to the geometry. this will ensure multi material support


      scope.addGroup(groupStart, groupCount, materialIndex); // calculate new start value for groups

      groupStart += groupCount; // update total number of vertices

      numberOfVertices += vertexCounter;
    }
  }

  copy(source) {
    super.copy(source);
    this.parameters = Object.assign({}, source.parameters);
    return this;
  }

  static fromJSON(data) {
    return new BoxGeometry(data.width, data.height, data.depth, data.widthSegments, data.heightSegments, data.depthSegments);
  }

}

exports.BoxGeometry = BoxGeometry;

},{"../core/BufferAttribute.js":120,"../core/BufferGeometry.js":121,"../math/Vector3.js":175}],145:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CapsuleGeometry = void 0;

var _Path = require("../extras/core/Path.js");

var _LatheGeometry = require("./LatheGeometry.js");

class CapsuleGeometry extends _LatheGeometry.LatheGeometry {
  constructor(radius = 1, length = 1, capSegments = 4, radialSegments = 8) {
    const path = new _Path.Path();
    path.absarc(0, -length / 2, radius, Math.PI * 1.5, 0);
    path.absarc(0, length / 2, radius, 0, Math.PI * 0.5);
    super(path.getPoints(capSegments), radialSegments);
    this.type = 'CapsuleGeometry';
    this.parameters = {
      radius: radius,
      length: length,
      capSegments: capSegments,
      radialSegments: radialSegments
    };
  }

  static fromJSON(data) {
    return new CapsuleGeometry(data.radius, data.length, data.capSegments, data.radialSegments);
  }

}

exports.CapsuleGeometry = CapsuleGeometry;

},{"../extras/core/Path.js":131,"./LatheGeometry.js":154}],146:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CircleGeometry = void 0;

var _BufferGeometry = require("../core/BufferGeometry.js");

var _BufferAttribute = require("../core/BufferAttribute.js");

var _Vector = require("../math/Vector3.js");

var _Vector2 = require("../math/Vector2.js");

class CircleGeometry extends _BufferGeometry.BufferGeometry {
  constructor(radius = 1, segments = 32, thetaStart = 0, thetaLength = Math.PI * 2) {
    super();
    this.type = 'CircleGeometry';
    this.parameters = {
      radius: radius,
      segments: segments,
      thetaStart: thetaStart,
      thetaLength: thetaLength
    };
    segments = Math.max(3, segments); // buffers

    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = []; // helper variables

    const vertex = new _Vector.Vector3();
    const uv = new _Vector2.Vector2(); // center point

    vertices.push(0, 0, 0);
    normals.push(0, 0, 1);
    uvs.push(0.5, 0.5);

    for (let s = 0, i = 3; s <= segments; s++, i += 3) {
      const segment = thetaStart + s / segments * thetaLength; // vertex

      vertex.x = radius * Math.cos(segment);
      vertex.y = radius * Math.sin(segment);
      vertices.push(vertex.x, vertex.y, vertex.z); // normal

      normals.push(0, 0, 1); // uvs

      uv.x = (vertices[i] / radius + 1) / 2;
      uv.y = (vertices[i + 1] / radius + 1) / 2;
      uvs.push(uv.x, uv.y);
    } // indices


    for (let i = 1; i <= segments; i++) {
      indices.push(i, i + 1, 0);
    } // build geometry


    this.setIndex(indices);
    this.setAttribute('position', new _BufferAttribute.Float32BufferAttribute(vertices, 3));
    this.setAttribute('normal', new _BufferAttribute.Float32BufferAttribute(normals, 3));
    this.setAttribute('uv', new _BufferAttribute.Float32BufferAttribute(uvs, 2));
  }

  copy(source) {
    super.copy(source);
    this.parameters = Object.assign({}, source.parameters);
    return this;
  }

  static fromJSON(data) {
    return new CircleGeometry(data.radius, data.segments, data.thetaStart, data.thetaLength);
  }

}

exports.CircleGeometry = CircleGeometry;

},{"../core/BufferAttribute.js":120,"../core/BufferGeometry.js":121,"../math/Vector2.js":174,"../math/Vector3.js":175}],147:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ConeGeometry = void 0;

var _CylinderGeometry = require("./CylinderGeometry.js");

class ConeGeometry extends _CylinderGeometry.CylinderGeometry {
  constructor(radius = 1, height = 1, radialSegments = 32, heightSegments = 1, openEnded = false, thetaStart = 0, thetaLength = Math.PI * 2) {
    super(0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength);
    this.type = 'ConeGeometry';
    this.parameters = {
      radius: radius,
      height: height,
      radialSegments: radialSegments,
      heightSegments: heightSegments,
      openEnded: openEnded,
      thetaStart: thetaStart,
      thetaLength: thetaLength
    };
  }

  static fromJSON(data) {
    return new ConeGeometry(data.radius, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);
  }

}

exports.ConeGeometry = ConeGeometry;

},{"./CylinderGeometry.js":148}],148:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CylinderGeometry = void 0;

var _BufferGeometry = require("../core/BufferGeometry.js");

var _BufferAttribute = require("../core/BufferAttribute.js");

var _Vector = require("../math/Vector3.js");

var _Vector2 = require("../math/Vector2.js");

class CylinderGeometry extends _BufferGeometry.BufferGeometry {
  constructor(radiusTop = 1, radiusBottom = 1, height = 1, radialSegments = 32, heightSegments = 1, openEnded = false, thetaStart = 0, thetaLength = Math.PI * 2) {
    super();
    this.type = 'CylinderGeometry';
    this.parameters = {
      radiusTop: radiusTop,
      radiusBottom: radiusBottom,
      height: height,
      radialSegments: radialSegments,
      heightSegments: heightSegments,
      openEnded: openEnded,
      thetaStart: thetaStart,
      thetaLength: thetaLength
    };
    const scope = this;
    radialSegments = Math.floor(radialSegments);
    heightSegments = Math.floor(heightSegments); // buffers

    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = []; // helper variables

    let index = 0;
    const indexArray = [];
    const halfHeight = height / 2;
    let groupStart = 0; // generate geometry

    generateTorso();

    if (openEnded === false) {
      if (radiusTop > 0) generateCap(true);
      if (radiusBottom > 0) generateCap(false);
    } // build geometry


    this.setIndex(indices);
    this.setAttribute('position', new _BufferAttribute.Float32BufferAttribute(vertices, 3));
    this.setAttribute('normal', new _BufferAttribute.Float32BufferAttribute(normals, 3));
    this.setAttribute('uv', new _BufferAttribute.Float32BufferAttribute(uvs, 2));

    function generateTorso() {
      const normal = new _Vector.Vector3();
      const vertex = new _Vector.Vector3();
      let groupCount = 0; // this will be used to calculate the normal

      const slope = (radiusBottom - radiusTop) / height; // generate vertices, normals and uvs

      for (let y = 0; y <= heightSegments; y++) {
        const indexRow = [];
        const v = y / heightSegments; // calculate the radius of the current row

        const radius = v * (radiusBottom - radiusTop) + radiusTop;

        for (let x = 0; x <= radialSegments; x++) {
          const u = x / radialSegments;
          const theta = u * thetaLength + thetaStart;
          const sinTheta = Math.sin(theta);
          const cosTheta = Math.cos(theta); // vertex

          vertex.x = radius * sinTheta;
          vertex.y = -v * height + halfHeight;
          vertex.z = radius * cosTheta;
          vertices.push(vertex.x, vertex.y, vertex.z); // normal

          normal.set(sinTheta, slope, cosTheta).normalize();
          normals.push(normal.x, normal.y, normal.z); // uv

          uvs.push(u, 1 - v); // save index of vertex in respective row

          indexRow.push(index++);
        } // now save vertices of the row in our index array


        indexArray.push(indexRow);
      } // generate indices


      for (let x = 0; x < radialSegments; x++) {
        for (let y = 0; y < heightSegments; y++) {
          // we use the index array to access the correct indices
          const a = indexArray[y][x];
          const b = indexArray[y + 1][x];
          const c = indexArray[y + 1][x + 1];
          const d = indexArray[y][x + 1]; // faces

          indices.push(a, b, d);
          indices.push(b, c, d); // update group counter

          groupCount += 6;
        }
      } // add a group to the geometry. this will ensure multi material support


      scope.addGroup(groupStart, groupCount, 0); // calculate new start value for groups

      groupStart += groupCount;
    }

    function generateCap(top) {
      // save the index of the first center vertex
      const centerIndexStart = index;
      const uv = new _Vector2.Vector2();
      const vertex = new _Vector.Vector3();
      let groupCount = 0;
      const radius = top === true ? radiusTop : radiusBottom;
      const sign = top === true ? 1 : -1; // first we generate the center vertex data of the cap.
      // because the geometry needs one set of uvs per face,
      // we must generate a center vertex per face/segment

      for (let x = 1; x <= radialSegments; x++) {
        // vertex
        vertices.push(0, halfHeight * sign, 0); // normal

        normals.push(0, sign, 0); // uv

        uvs.push(0.5, 0.5); // increase index

        index++;
      } // save the index of the last center vertex


      const centerIndexEnd = index; // now we generate the surrounding vertices, normals and uvs

      for (let x = 0; x <= radialSegments; x++) {
        const u = x / radialSegments;
        const theta = u * thetaLength + thetaStart;
        const cosTheta = Math.cos(theta);
        const sinTheta = Math.sin(theta); // vertex

        vertex.x = radius * sinTheta;
        vertex.y = halfHeight * sign;
        vertex.z = radius * cosTheta;
        vertices.push(vertex.x, vertex.y, vertex.z); // normal

        normals.push(0, sign, 0); // uv

        uv.x = cosTheta * 0.5 + 0.5;
        uv.y = sinTheta * 0.5 * sign + 0.5;
        uvs.push(uv.x, uv.y); // increase index

        index++;
      } // generate indices


      for (let x = 0; x < radialSegments; x++) {
        const c = centerIndexStart + x;
        const i = centerIndexEnd + x;

        if (top === true) {
          // face top
          indices.push(i, i + 1, c);
        } else {
          // face bottom
          indices.push(i + 1, i, c);
        }

        groupCount += 3;
      } // add a group to the geometry. this will ensure multi material support


      scope.addGroup(groupStart, groupCount, top === true ? 1 : 2); // calculate new start value for groups

      groupStart += groupCount;
    }
  }

  copy(source) {
    super.copy(source);
    this.parameters = Object.assign({}, source.parameters);
    return this;
  }

  static fromJSON(data) {
    return new CylinderGeometry(data.radiusTop, data.radiusBottom, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);
  }

}

exports.CylinderGeometry = CylinderGeometry;

},{"../core/BufferAttribute.js":120,"../core/BufferGeometry.js":121,"../math/Vector2.js":174,"../math/Vector3.js":175}],149:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DodecahedronGeometry = void 0;

var _PolyhedronGeometry = require("./PolyhedronGeometry.js");

class DodecahedronGeometry extends _PolyhedronGeometry.PolyhedronGeometry {
  constructor(radius = 1, detail = 0) {
    const t = (1 + Math.sqrt(5)) / 2;
    const r = 1 / t;
    const vertices = [// (±1, ±1, ±1)
    -1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, // (0, ±1/φ, ±φ)
    0, -r, -t, 0, -r, t, 0, r, -t, 0, r, t, // (±1/φ, ±φ, 0)
    -r, -t, 0, -r, t, 0, r, -t, 0, r, t, 0, // (±φ, 0, ±1/φ)
    -t, 0, -r, t, 0, -r, -t, 0, r, t, 0, r];
    const indices = [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9];
    super(vertices, indices, radius, detail);
    this.type = 'DodecahedronGeometry';
    this.parameters = {
      radius: radius,
      detail: detail
    };
  }

  static fromJSON(data) {
    return new DodecahedronGeometry(data.radius, data.detail);
  }

}

exports.DodecahedronGeometry = DodecahedronGeometry;

},{"./PolyhedronGeometry.js":157}],150:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.EdgesGeometry = void 0;

var _BufferGeometry = require("../core/BufferGeometry.js");

var _BufferAttribute = require("../core/BufferAttribute.js");

var MathUtils = _interopRequireWildcard(require("../math/MathUtils.js"));

var _Triangle = require("../math/Triangle.js");

var _Vector = require("../math/Vector3.js");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const _v0 = /*@__PURE__*/new _Vector.Vector3();

const _v1 = /*@__PURE__*/new _Vector.Vector3();

const _normal = /*@__PURE__*/new _Vector.Vector3();

const _triangle = /*@__PURE__*/new _Triangle.Triangle();

class EdgesGeometry extends _BufferGeometry.BufferGeometry {
  constructor(geometry = null, thresholdAngle = 1) {
    super();
    this.type = 'EdgesGeometry';
    this.parameters = {
      geometry: geometry,
      thresholdAngle: thresholdAngle
    };

    if (geometry !== null) {
      const precisionPoints = 4;
      const precision = Math.pow(10, precisionPoints);
      const thresholdDot = Math.cos(MathUtils.DEG2RAD * thresholdAngle);
      const indexAttr = geometry.getIndex();
      const positionAttr = geometry.getAttribute('position');
      const indexCount = indexAttr ? indexAttr.count : positionAttr.count;
      const indexArr = [0, 0, 0];
      const vertKeys = ['a', 'b', 'c'];
      const hashes = new Array(3);
      const edgeData = {};
      const vertices = [];

      for (let i = 0; i < indexCount; i += 3) {
        if (indexAttr) {
          indexArr[0] = indexAttr.getX(i);
          indexArr[1] = indexAttr.getX(i + 1);
          indexArr[2] = indexAttr.getX(i + 2);
        } else {
          indexArr[0] = i;
          indexArr[1] = i + 1;
          indexArr[2] = i + 2;
        }

        const {
          a,
          b,
          c
        } = _triangle;
        a.fromBufferAttribute(positionAttr, indexArr[0]);
        b.fromBufferAttribute(positionAttr, indexArr[1]);
        c.fromBufferAttribute(positionAttr, indexArr[2]);

        _triangle.getNormal(_normal); // create hashes for the edge from the vertices


        hashes[0] = `${Math.round(a.x * precision)},${Math.round(a.y * precision)},${Math.round(a.z * precision)}`;
        hashes[1] = `${Math.round(b.x * precision)},${Math.round(b.y * precision)},${Math.round(b.z * precision)}`;
        hashes[2] = `${Math.round(c.x * precision)},${Math.round(c.y * precision)},${Math.round(c.z * precision)}`; // skip degenerate triangles

        if (hashes[0] === hashes[1] || hashes[1] === hashes[2] || hashes[2] === hashes[0]) {
          continue;
        } // iterate over every edge


        for (let j = 0; j < 3; j++) {
          // get the first and next vertex making up the edge
          const jNext = (j + 1) % 3;
          const vecHash0 = hashes[j];
          const vecHash1 = hashes[jNext];
          const v0 = _triangle[vertKeys[j]];
          const v1 = _triangle[vertKeys[jNext]];
          const hash = `${vecHash0}_${vecHash1}`;
          const reverseHash = `${vecHash1}_${vecHash0}`;

          if (reverseHash in edgeData && edgeData[reverseHash]) {
            // if we found a sibling edge add it into the vertex array if
            // it meets the angle threshold and delete the edge from the map.
            if (_normal.dot(edgeData[reverseHash].normal) <= thresholdDot) {
              vertices.push(v0.x, v0.y, v0.z);
              vertices.push(v1.x, v1.y, v1.z);
            }

            edgeData[reverseHash] = null;
          } else if (!(hash in edgeData)) {
            // if we've already got an edge here then skip adding a new one
            edgeData[hash] = {
              index0: indexArr[j],
              index1: indexArr[jNext],
              normal: _normal.clone()
            };
          }
        }
      } // iterate over all remaining, unmatched edges and add them to the vertex array


      for (const key in edgeData) {
        if (edgeData[key]) {
          const {
            index0,
            index1
          } = edgeData[key];

          _v0.fromBufferAttribute(positionAttr, index0);

          _v1.fromBufferAttribute(positionAttr, index1);

          vertices.push(_v0.x, _v0.y, _v0.z);
          vertices.push(_v1.x, _v1.y, _v1.z);
        }
      }

      this.setAttribute('position', new _BufferAttribute.Float32BufferAttribute(vertices, 3));
    }
  }

  copy(source) {
    super.copy(source);
    this.parameters = Object.assign({}, source.parameters);
    return this;
  }

}

exports.EdgesGeometry = EdgesGeometry;

},{"../core/BufferAttribute.js":120,"../core/BufferGeometry.js":121,"../math/MathUtils.js":168,"../math/Triangle.js":173,"../math/Vector3.js":175}],151:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ExtrudeGeometry = void 0;

var _BufferGeometry = require("../core/BufferGeometry.js");

var _BufferAttribute = require("../core/BufferAttribute.js");

var Curves = _interopRequireWildcard(require("../extras/curves/Curves.js"));

var _Vector = require("../math/Vector2.js");

var _Vector2 = require("../math/Vector3.js");

var _Shape = require("../extras/core/Shape.js");

var _ShapeUtils = require("../extras/ShapeUtils.js");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * Creates extruded geometry from a path shape.
 *
 * parameters = {
 *
 *  curveSegments: <int>, // number of points on the curves
 *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too
 *  depth: <float>, // Depth to extrude the shape
 *
 *  bevelEnabled: <bool>, // turn on bevel
 *  bevelThickness: <float>, // how deep into the original shape bevel goes
 *  bevelSize: <float>, // how far from shape outline (including bevelOffset) is bevel
 *  bevelOffset: <float>, // how far from shape outline does bevel start
 *  bevelSegments: <int>, // number of bevel layers
 *
 *  extrudePath: <THREE.Curve> // curve to extrude shape along
 *
 *  UVGenerator: <Object> // object that provides UV generator functions
 *
 * }
 */
class ExtrudeGeometry extends _BufferGeometry.BufferGeometry {
  constructor(shapes = new _Shape.Shape([new _Vector.Vector2(0.5, 0.5), new _Vector.Vector2(-0.5, 0.5), new _Vector.Vector2(-0.5, -0.5), new _Vector.Vector2(0.5, -0.5)]), options = {}) {
    super();
    this.type = 'ExtrudeGeometry';
    this.parameters = {
      shapes: shapes,
      options: options
    };
    shapes = Array.isArray(shapes) ? shapes : [shapes];
    const scope = this;
    const verticesArray = [];
    const uvArray = [];

    for (let i = 0, l = shapes.length; i < l; i++) {
      const shape = shapes[i];
      addShape(shape);
    } // build geometry


    this.setAttribute('position', new _BufferAttribute.Float32BufferAttribute(verticesArray, 3));
    this.setAttribute('uv', new _BufferAttribute.Float32BufferAttribute(uvArray, 2));
    this.computeVertexNormals(); // functions

    function addShape(shape) {
      const placeholder = []; // options

      const curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;
      const steps = options.steps !== undefined ? options.steps : 1;
      const depth = options.depth !== undefined ? options.depth : 1;
      let bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true;
      let bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 0.2;
      let bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 0.1;
      let bevelOffset = options.bevelOffset !== undefined ? options.bevelOffset : 0;
      let bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;
      const extrudePath = options.extrudePath;
      const uvgen = options.UVGenerator !== undefined ? options.UVGenerator : WorldUVGenerator; //

      let extrudePts,
          extrudeByPath = false;
      let splineTube, binormal, normal, position2;

      if (extrudePath) {
        extrudePts = extrudePath.getSpacedPoints(steps);
        extrudeByPath = true;
        bevelEnabled = false; // bevels not supported for path extrusion
        // SETUP TNB variables
        // TODO1 - have a .isClosed in spline?

        splineTube = extrudePath.computeFrenetFrames(steps, false); // console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);

        binormal = new _Vector2.Vector3();
        normal = new _Vector2.Vector3();
        position2 = new _Vector2.Vector3();
      } // Safeguards if bevels are not enabled


      if (!bevelEnabled) {
        bevelSegments = 0;
        bevelThickness = 0;
        bevelSize = 0;
        bevelOffset = 0;
      } // Variables initialization


      const shapePoints = shape.extractPoints(curveSegments);
      let vertices = shapePoints.shape;
      const holes = shapePoints.holes;
      const reverse = !_ShapeUtils.ShapeUtils.isClockWise(vertices);

      if (reverse) {
        vertices = vertices.reverse(); // Maybe we should also check if holes are in the opposite direction, just to be safe ...

        for (let h = 0, hl = holes.length; h < hl; h++) {
          const ahole = holes[h];

          if (_ShapeUtils.ShapeUtils.isClockWise(ahole)) {
            holes[h] = ahole.reverse();
          }
        }
      }

      const faces = _ShapeUtils.ShapeUtils.triangulateShape(vertices, holes);
      /* Vertices */


      const contour = vertices; // vertices has all points but contour has only points of circumference

      for (let h = 0, hl = holes.length; h < hl; h++) {
        const ahole = holes[h];
        vertices = vertices.concat(ahole);
      }

      function scalePt2(pt, vec, size) {
        if (!vec) console.error('THREE.ExtrudeGeometry: vec does not exist');
        return pt.clone().addScaledVector(vec, size);
      }

      const vlen = vertices.length,
            flen = faces.length; // Find directions for point movement

      function getBevelVec(inPt, inPrev, inNext) {
        // computes for inPt the corresponding point inPt' on a new contour
        //   shifted by 1 unit (length of normalized vector) to the left
        // if we walk along contour clockwise, this new contour is outside the old one
        //
        // inPt' is the intersection of the two lines parallel to the two
        //  adjacent edges of inPt at a distance of 1 unit on the left side.
        let v_trans_x, v_trans_y, shrink_by; // resulting translation vector for inPt
        // good reading for geometry algorithms (here: line-line intersection)
        // http://geomalgorithms.com/a05-_intersect-1.html

        const v_prev_x = inPt.x - inPrev.x,
              v_prev_y = inPt.y - inPrev.y;
        const v_next_x = inNext.x - inPt.x,
              v_next_y = inNext.y - inPt.y;
        const v_prev_lensq = v_prev_x * v_prev_x + v_prev_y * v_prev_y; // check for collinear edges

        const collinear0 = v_prev_x * v_next_y - v_prev_y * v_next_x;

        if (Math.abs(collinear0) > Number.EPSILON) {
          // not collinear
          // length of vectors for normalizing
          const v_prev_len = Math.sqrt(v_prev_lensq);
          const v_next_len = Math.sqrt(v_next_x * v_next_x + v_next_y * v_next_y); // shift adjacent points by unit vectors to the left

          const ptPrevShift_x = inPrev.x - v_prev_y / v_prev_len;
          const ptPrevShift_y = inPrev.y + v_prev_x / v_prev_len;
          const ptNextShift_x = inNext.x - v_next_y / v_next_len;
          const ptNextShift_y = inNext.y + v_next_x / v_next_len; // scaling factor for v_prev to intersection point

          const sf = ((ptNextShift_x - ptPrevShift_x) * v_next_y - (ptNextShift_y - ptPrevShift_y) * v_next_x) / (v_prev_x * v_next_y - v_prev_y * v_next_x); // vector from inPt to intersection point

          v_trans_x = ptPrevShift_x + v_prev_x * sf - inPt.x;
          v_trans_y = ptPrevShift_y + v_prev_y * sf - inPt.y; // Don't normalize!, otherwise sharp corners become ugly
          //  but prevent crazy spikes

          const v_trans_lensq = v_trans_x * v_trans_x + v_trans_y * v_trans_y;

          if (v_trans_lensq <= 2) {
            return new _Vector.Vector2(v_trans_x, v_trans_y);
          } else {
            shrink_by = Math.sqrt(v_trans_lensq / 2);
          }
        } else {
          // handle special case of collinear edges
          let direction_eq = false; // assumes: opposite

          if (v_prev_x > Number.EPSILON) {
            if (v_next_x > Number.EPSILON) {
              direction_eq = true;
            }
          } else {
            if (v_prev_x < -Number.EPSILON) {
              if (v_next_x < -Number.EPSILON) {
                direction_eq = true;
              }
            } else {
              if (Math.sign(v_prev_y) === Math.sign(v_next_y)) {
                direction_eq = true;
              }
            }
          }

          if (direction_eq) {
            // console.log("Warning: lines are a straight sequence");
            v_trans_x = -v_prev_y;
            v_trans_y = v_prev_x;
            shrink_by = Math.sqrt(v_prev_lensq);
          } else {
            // console.log("Warning: lines are a straight spike");
            v_trans_x = v_prev_x;
            v_trans_y = v_prev_y;
            shrink_by = Math.sqrt(v_prev_lensq / 2);
          }
        }

        return new _Vector.Vector2(v_trans_x / shrink_by, v_trans_y / shrink_by);
      }

      const contourMovements = [];

      for (let i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i++, j++, k++) {
        if (j === il) j = 0;
        if (k === il) k = 0; //  (j)---(i)---(k)
        // console.log('i,j,k', i, j , k)

        contourMovements[i] = getBevelVec(contour[i], contour[j], contour[k]);
      }

      const holesMovements = [];
      let oneHoleMovements,
          verticesMovements = contourMovements.concat();

      for (let h = 0, hl = holes.length; h < hl; h++) {
        const ahole = holes[h];
        oneHoleMovements = [];

        for (let i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i++, j++, k++) {
          if (j === il) j = 0;
          if (k === il) k = 0; //  (j)---(i)---(k)

          oneHoleMovements[i] = getBevelVec(ahole[i], ahole[j], ahole[k]);
        }

        holesMovements.push(oneHoleMovements);
        verticesMovements = verticesMovements.concat(oneHoleMovements);
      } // Loop bevelSegments, 1 for the front, 1 for the back


      for (let b = 0; b < bevelSegments; b++) {
        //for ( b = bevelSegments; b > 0; b -- ) {
        const t = b / bevelSegments;
        const z = bevelThickness * Math.cos(t * Math.PI / 2);
        const bs = bevelSize * Math.sin(t * Math.PI / 2) + bevelOffset; // contract shape

        for (let i = 0, il = contour.length; i < il; i++) {
          const vert = scalePt2(contour[i], contourMovements[i], bs);
          v(vert.x, vert.y, -z);
        } // expand holes


        for (let h = 0, hl = holes.length; h < hl; h++) {
          const ahole = holes[h];
          oneHoleMovements = holesMovements[h];

          for (let i = 0, il = ahole.length; i < il; i++) {
            const vert = scalePt2(ahole[i], oneHoleMovements[i], bs);
            v(vert.x, vert.y, -z);
          }
        }
      }

      const bs = bevelSize + bevelOffset; // Back facing vertices

      for (let i = 0; i < vlen; i++) {
        const vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i];

        if (!extrudeByPath) {
          v(vert.x, vert.y, 0);
        } else {
          // v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );
          normal.copy(splineTube.normals[0]).multiplyScalar(vert.x);
          binormal.copy(splineTube.binormals[0]).multiplyScalar(vert.y);
          position2.copy(extrudePts[0]).add(normal).add(binormal);
          v(position2.x, position2.y, position2.z);
        }
      } // Add stepped vertices...
      // Including front facing vertices


      for (let s = 1; s <= steps; s++) {
        for (let i = 0; i < vlen; i++) {
          const vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i];

          if (!extrudeByPath) {
            v(vert.x, vert.y, depth / steps * s);
          } else {
            // v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );
            normal.copy(splineTube.normals[s]).multiplyScalar(vert.x);
            binormal.copy(splineTube.binormals[s]).multiplyScalar(vert.y);
            position2.copy(extrudePts[s]).add(normal).add(binormal);
            v(position2.x, position2.y, position2.z);
          }
        }
      } // Add bevel segments planes
      //for ( b = 1; b <= bevelSegments; b ++ ) {


      for (let b = bevelSegments - 1; b >= 0; b--) {
        const t = b / bevelSegments;
        const z = bevelThickness * Math.cos(t * Math.PI / 2);
        const bs = bevelSize * Math.sin(t * Math.PI / 2) + bevelOffset; // contract shape

        for (let i = 0, il = contour.length; i < il; i++) {
          const vert = scalePt2(contour[i], contourMovements[i], bs);
          v(vert.x, vert.y, depth + z);
        } // expand holes


        for (let h = 0, hl = holes.length; h < hl; h++) {
          const ahole = holes[h];
          oneHoleMovements = holesMovements[h];

          for (let i = 0, il = ahole.length; i < il; i++) {
            const vert = scalePt2(ahole[i], oneHoleMovements[i], bs);

            if (!extrudeByPath) {
              v(vert.x, vert.y, depth + z);
            } else {
              v(vert.x, vert.y + extrudePts[steps - 1].y, extrudePts[steps - 1].x + z);
            }
          }
        }
      }
      /* Faces */
      // Top and bottom faces


      buildLidFaces(); // Sides faces

      buildSideFaces(); /////  Internal functions

      function buildLidFaces() {
        const start = verticesArray.length / 3;

        if (bevelEnabled) {
          let layer = 0; // steps + 1

          let offset = vlen * layer; // Bottom faces

          for (let i = 0; i < flen; i++) {
            const face = faces[i];
            f3(face[2] + offset, face[1] + offset, face[0] + offset);
          }

          layer = steps + bevelSegments * 2;
          offset = vlen * layer; // Top faces

          for (let i = 0; i < flen; i++) {
            const face = faces[i];
            f3(face[0] + offset, face[1] + offset, face[2] + offset);
          }
        } else {
          // Bottom faces
          for (let i = 0; i < flen; i++) {
            const face = faces[i];
            f3(face[2], face[1], face[0]);
          } // Top faces


          for (let i = 0; i < flen; i++) {
            const face = faces[i];
            f3(face[0] + vlen * steps, face[1] + vlen * steps, face[2] + vlen * steps);
          }
        }

        scope.addGroup(start, verticesArray.length / 3 - start, 0);
      } // Create faces for the z-sides of the shape


      function buildSideFaces() {
        const start = verticesArray.length / 3;
        let layeroffset = 0;
        sidewalls(contour, layeroffset);
        layeroffset += contour.length;

        for (let h = 0, hl = holes.length; h < hl; h++) {
          const ahole = holes[h];
          sidewalls(ahole, layeroffset); //, true

          layeroffset += ahole.length;
        }

        scope.addGroup(start, verticesArray.length / 3 - start, 1);
      }

      function sidewalls(contour, layeroffset) {
        let i = contour.length;

        while (--i >= 0) {
          const j = i;
          let k = i - 1;
          if (k < 0) k = contour.length - 1; //console.log('b', i,j, i-1, k,vertices.length);

          for (let s = 0, sl = steps + bevelSegments * 2; s < sl; s++) {
            const slen1 = vlen * s;
            const slen2 = vlen * (s + 1);
            const a = layeroffset + j + slen1,
                  b = layeroffset + k + slen1,
                  c = layeroffset + k + slen2,
                  d = layeroffset + j + slen2;
            f4(a, b, c, d);
          }
        }
      }

      function v(x, y, z) {
        placeholder.push(x);
        placeholder.push(y);
        placeholder.push(z);
      }

      function f3(a, b, c) {
        addVertex(a);
        addVertex(b);
        addVertex(c);
        const nextIndex = verticesArray.length / 3;
        const uvs = uvgen.generateTopUV(scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1);
        addUV(uvs[0]);
        addUV(uvs[1]);
        addUV(uvs[2]);
      }

      function f4(a, b, c, d) {
        addVertex(a);
        addVertex(b);
        addVertex(d);
        addVertex(b);
        addVertex(c);
        addVertex(d);
        const nextIndex = verticesArray.length / 3;
        const uvs = uvgen.generateSideWallUV(scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1);
        addUV(uvs[0]);
        addUV(uvs[1]);
        addUV(uvs[3]);
        addUV(uvs[1]);
        addUV(uvs[2]);
        addUV(uvs[3]);
      }

      function addVertex(index) {
        verticesArray.push(placeholder[index * 3 + 0]);
        verticesArray.push(placeholder[index * 3 + 1]);
        verticesArray.push(placeholder[index * 3 + 2]);
      }

      function addUV(vector2) {
        uvArray.push(vector2.x);
        uvArray.push(vector2.y);
      }
    }
  }

  copy(source) {
    super.copy(source);
    this.parameters = Object.assign({}, source.parameters);
    return this;
  }

  toJSON() {
    const data = super.toJSON();
    const shapes = this.parameters.shapes;
    const options = this.parameters.options;
    return toJSON(shapes, options, data);
  }

  static fromJSON(data, shapes) {
    const geometryShapes = [];

    for (let j = 0, jl = data.shapes.length; j < jl; j++) {
      const shape = shapes[data.shapes[j]];
      geometryShapes.push(shape);
    }

    const extrudePath = data.options.extrudePath;

    if (extrudePath !== undefined) {
      data.options.extrudePath = new Curves[extrudePath.type]().fromJSON(extrudePath);
    }

    return new ExtrudeGeometry(geometryShapes, data.options);
  }

}

exports.ExtrudeGeometry = ExtrudeGeometry;
const WorldUVGenerator = {
  generateTopUV: function (geometry, vertices, indexA, indexB, indexC) {
    const a_x = vertices[indexA * 3];
    const a_y = vertices[indexA * 3 + 1];
    const b_x = vertices[indexB * 3];
    const b_y = vertices[indexB * 3 + 1];
    const c_x = vertices[indexC * 3];
    const c_y = vertices[indexC * 3 + 1];
    return [new _Vector.Vector2(a_x, a_y), new _Vector.Vector2(b_x, b_y), new _Vector.Vector2(c_x, c_y)];
  },
  generateSideWallUV: function (geometry, vertices, indexA, indexB, indexC, indexD) {
    const a_x = vertices[indexA * 3];
    const a_y = vertices[indexA * 3 + 1];
    const a_z = vertices[indexA * 3 + 2];
    const b_x = vertices[indexB * 3];
    const b_y = vertices[indexB * 3 + 1];
    const b_z = vertices[indexB * 3 + 2];
    const c_x = vertices[indexC * 3];
    const c_y = vertices[indexC * 3 + 1];
    const c_z = vertices[indexC * 3 + 2];
    const d_x = vertices[indexD * 3];
    const d_y = vertices[indexD * 3 + 1];
    const d_z = vertices[indexD * 3 + 2];

    if (Math.abs(a_y - b_y) < Math.abs(a_x - b_x)) {
      return [new _Vector.Vector2(a_x, 1 - a_z), new _Vector.Vector2(b_x, 1 - b_z), new _Vector.Vector2(c_x, 1 - c_z), new _Vector.Vector2(d_x, 1 - d_z)];
    } else {
      return [new _Vector.Vector2(a_y, 1 - a_z), new _Vector.Vector2(b_y, 1 - b_z), new _Vector.Vector2(c_y, 1 - c_z), new _Vector.Vector2(d_y, 1 - d_z)];
    }
  }
};

function toJSON(shapes, options, data) {
  data.shapes = [];

  if (Array.isArray(shapes)) {
    for (let i = 0, l = shapes.length; i < l; i++) {
      const shape = shapes[i];
      data.shapes.push(shape.uuid);
    }
  } else {
    data.shapes.push(shapes.uuid);
  }

  data.options = Object.assign({}, options);
  if (options.extrudePath !== undefined) data.options.extrudePath = options.extrudePath.toJSON();
  return data;
}

},{"../core/BufferAttribute.js":120,"../core/BufferGeometry.js":121,"../extras/ShapeUtils.js":127,"../extras/core/Shape.js":132,"../extras/curves/Curves.js":137,"../math/Vector2.js":174,"../math/Vector3.js":175}],152:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _BoxGeometry = require("./BoxGeometry.js");

Object.keys(_BoxGeometry).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _BoxGeometry[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _BoxGeometry[key];
    }
  });
});

var _CapsuleGeometry = require("./CapsuleGeometry.js");

Object.keys(_CapsuleGeometry).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _CapsuleGeometry[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _CapsuleGeometry[key];
    }
  });
});

var _CircleGeometry = require("./CircleGeometry.js");

Object.keys(_CircleGeometry).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _CircleGeometry[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _CircleGeometry[key];
    }
  });
});

var _ConeGeometry = require("./ConeGeometry.js");

Object.keys(_ConeGeometry).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _ConeGeometry[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _ConeGeometry[key];
    }
  });
});

var _CylinderGeometry = require("./CylinderGeometry.js");

Object.keys(_CylinderGeometry).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _CylinderGeometry[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _CylinderGeometry[key];
    }
  });
});

var _DodecahedronGeometry = require("./DodecahedronGeometry.js");

Object.keys(_DodecahedronGeometry).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _DodecahedronGeometry[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _DodecahedronGeometry[key];
    }
  });
});

var _EdgesGeometry = require("./EdgesGeometry.js");

Object.keys(_EdgesGeometry).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _EdgesGeometry[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _EdgesGeometry[key];
    }
  });
});

var _ExtrudeGeometry = require("./ExtrudeGeometry.js");

Object.keys(_ExtrudeGeometry).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _ExtrudeGeometry[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _ExtrudeGeometry[key];
    }
  });
});

var _IcosahedronGeometry = require("./IcosahedronGeometry.js");

Object.keys(_IcosahedronGeometry).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _IcosahedronGeometry[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _IcosahedronGeometry[key];
    }
  });
});

var _LatheGeometry = require("./LatheGeometry.js");

Object.keys(_LatheGeometry).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _LatheGeometry[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _LatheGeometry[key];
    }
  });
});

var _OctahedronGeometry = require("./OctahedronGeometry.js");

Object.keys(_OctahedronGeometry).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _OctahedronGeometry[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _OctahedronGeometry[key];
    }
  });
});

var _PlaneGeometry = require("./PlaneGeometry.js");

Object.keys(_PlaneGeometry).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _PlaneGeometry[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _PlaneGeometry[key];
    }
  });
});

var _PolyhedronGeometry = require("./PolyhedronGeometry.js");

Object.keys(_PolyhedronGeometry).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _PolyhedronGeometry[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _PolyhedronGeometry[key];
    }
  });
});

var _RingGeometry = require("./RingGeometry.js");

Object.keys(_RingGeometry).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _RingGeometry[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _RingGeometry[key];
    }
  });
});

var _ShapeGeometry = require("./ShapeGeometry.js");

Object.keys(_ShapeGeometry).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _ShapeGeometry[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _ShapeGeometry[key];
    }
  });
});

var _SphereGeometry = require("./SphereGeometry.js");

Object.keys(_SphereGeometry).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _SphereGeometry[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _SphereGeometry[key];
    }
  });
});

var _TetrahedronGeometry = require("./TetrahedronGeometry.js");

Object.keys(_TetrahedronGeometry).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _TetrahedronGeometry[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _TetrahedronGeometry[key];
    }
  });
});

var _TorusGeometry = require("./TorusGeometry.js");

Object.keys(_TorusGeometry).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _TorusGeometry[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _TorusGeometry[key];
    }
  });
});

var _TorusKnotGeometry = require("./TorusKnotGeometry.js");

Object.keys(_TorusKnotGeometry).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _TorusKnotGeometry[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _TorusKnotGeometry[key];
    }
  });
});

var _TubeGeometry = require("./TubeGeometry.js");

Object.keys(_TubeGeometry).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _TubeGeometry[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _TubeGeometry[key];
    }
  });
});

var _WireframeGeometry = require("./WireframeGeometry.js");

Object.keys(_WireframeGeometry).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _WireframeGeometry[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _WireframeGeometry[key];
    }
  });
});

},{"./BoxGeometry.js":144,"./CapsuleGeometry.js":145,"./CircleGeometry.js":146,"./ConeGeometry.js":147,"./CylinderGeometry.js":148,"./DodecahedronGeometry.js":149,"./EdgesGeometry.js":150,"./ExtrudeGeometry.js":151,"./IcosahedronGeometry.js":153,"./LatheGeometry.js":154,"./OctahedronGeometry.js":155,"./PlaneGeometry.js":156,"./PolyhedronGeometry.js":157,"./RingGeometry.js":158,"./ShapeGeometry.js":159,"./SphereGeometry.js":160,"./TetrahedronGeometry.js":161,"./TorusGeometry.js":162,"./TorusKnotGeometry.js":163,"./TubeGeometry.js":164,"./WireframeGeometry.js":165}],153:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.IcosahedronGeometry = void 0;

var _PolyhedronGeometry = require("./PolyhedronGeometry.js");

class IcosahedronGeometry extends _PolyhedronGeometry.PolyhedronGeometry {
  constructor(radius = 1, detail = 0) {
    const t = (1 + Math.sqrt(5)) / 2;
    const vertices = [-1, t, 0, 1, t, 0, -1, -t, 0, 1, -t, 0, 0, -1, t, 0, 1, t, 0, -1, -t, 0, 1, -t, t, 0, -1, t, 0, 1, -t, 0, -1, -t, 0, 1];
    const indices = [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1];
    super(vertices, indices, radius, detail);
    this.type = 'IcosahedronGeometry';
    this.parameters = {
      radius: radius,
      detail: detail
    };
  }

  static fromJSON(data) {
    return new IcosahedronGeometry(data.radius, data.detail);
  }

}

exports.IcosahedronGeometry = IcosahedronGeometry;

},{"./PolyhedronGeometry.js":157}],154:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.LatheGeometry = void 0;

var _BufferAttribute = require("../core/BufferAttribute.js");

var _BufferGeometry = require("../core/BufferGeometry.js");

var _Vector = require("../math/Vector3.js");

var _Vector2 = require("../math/Vector2.js");

var MathUtils = _interopRequireWildcard(require("../math/MathUtils.js"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

class LatheGeometry extends _BufferGeometry.BufferGeometry {
  constructor(points = [new _Vector2.Vector2(0, -0.5), new _Vector2.Vector2(0.5, 0), new _Vector2.Vector2(0, 0.5)], segments = 12, phiStart = 0, phiLength = Math.PI * 2) {
    super();
    this.type = 'LatheGeometry';
    this.parameters = {
      points: points,
      segments: segments,
      phiStart: phiStart,
      phiLength: phiLength
    };
    segments = Math.floor(segments); // clamp phiLength so it's in range of [ 0, 2PI ]

    phiLength = MathUtils.clamp(phiLength, 0, Math.PI * 2); // buffers

    const indices = [];
    const vertices = [];
    const uvs = [];
    const initNormals = [];
    const normals = []; // helper variables

    const inverseSegments = 1.0 / segments;
    const vertex = new _Vector.Vector3();
    const uv = new _Vector2.Vector2();
    const normal = new _Vector.Vector3();
    const curNormal = new _Vector.Vector3();
    const prevNormal = new _Vector.Vector3();
    let dx = 0;
    let dy = 0; // pre-compute normals for initial "meridian"

    for (let j = 0; j <= points.length - 1; j++) {
      switch (j) {
        case 0:
          // special handling for 1st vertex on path
          dx = points[j + 1].x - points[j].x;
          dy = points[j + 1].y - points[j].y;
          normal.x = dy * 1.0;
          normal.y = -dx;
          normal.z = dy * 0.0;
          prevNormal.copy(normal);
          normal.normalize();
          initNormals.push(normal.x, normal.y, normal.z);
          break;

        case points.length - 1:
          // special handling for last Vertex on path
          initNormals.push(prevNormal.x, prevNormal.y, prevNormal.z);
          break;

        default:
          // default handling for all vertices in between
          dx = points[j + 1].x - points[j].x;
          dy = points[j + 1].y - points[j].y;
          normal.x = dy * 1.0;
          normal.y = -dx;
          normal.z = dy * 0.0;
          curNormal.copy(normal);
          normal.x += prevNormal.x;
          normal.y += prevNormal.y;
          normal.z += prevNormal.z;
          normal.normalize();
          initNormals.push(normal.x, normal.y, normal.z);
          prevNormal.copy(curNormal);
      }
    } // generate vertices, uvs and normals


    for (let i = 0; i <= segments; i++) {
      const phi = phiStart + i * inverseSegments * phiLength;
      const sin = Math.sin(phi);
      const cos = Math.cos(phi);

      for (let j = 0; j <= points.length - 1; j++) {
        // vertex
        vertex.x = points[j].x * sin;
        vertex.y = points[j].y;
        vertex.z = points[j].x * cos;
        vertices.push(vertex.x, vertex.y, vertex.z); // uv

        uv.x = i / segments;
        uv.y = j / (points.length - 1);
        uvs.push(uv.x, uv.y); // normal

        const x = initNormals[3 * j + 0] * sin;
        const y = initNormals[3 * j + 1];
        const z = initNormals[3 * j + 0] * cos;
        normals.push(x, y, z);
      }
    } // indices


    for (let i = 0; i < segments; i++) {
      for (let j = 0; j < points.length - 1; j++) {
        const base = j + i * points.length;
        const a = base;
        const b = base + points.length;
        const c = base + points.length + 1;
        const d = base + 1; // faces

        indices.push(a, b, d);
        indices.push(c, d, b);
      }
    } // build geometry


    this.setIndex(indices);
    this.setAttribute('position', new _BufferAttribute.Float32BufferAttribute(vertices, 3));
    this.setAttribute('uv', new _BufferAttribute.Float32BufferAttribute(uvs, 2));
    this.setAttribute('normal', new _BufferAttribute.Float32BufferAttribute(normals, 3));
  }

  copy(source) {
    super.copy(source);
    this.parameters = Object.assign({}, source.parameters);
    return this;
  }

  static fromJSON(data) {
    return new LatheGeometry(data.points, data.segments, data.phiStart, data.phiLength);
  }

}

exports.LatheGeometry = LatheGeometry;

},{"../core/BufferAttribute.js":120,"../core/BufferGeometry.js":121,"../math/MathUtils.js":168,"../math/Vector2.js":174,"../math/Vector3.js":175}],155:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.OctahedronGeometry = void 0;

var _PolyhedronGeometry = require("./PolyhedronGeometry.js");

class OctahedronGeometry extends _PolyhedronGeometry.PolyhedronGeometry {
  constructor(radius = 1, detail = 0) {
    const vertices = [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1];
    const indices = [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2];
    super(vertices, indices, radius, detail);
    this.type = 'OctahedronGeometry';
    this.parameters = {
      radius: radius,
      detail: detail
    };
  }

  static fromJSON(data) {
    return new OctahedronGeometry(data.radius, data.detail);
  }

}

exports.OctahedronGeometry = OctahedronGeometry;

},{"./PolyhedronGeometry.js":157}],156:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PlaneGeometry = void 0;

var _BufferGeometry = require("../core/BufferGeometry.js");

var _BufferAttribute = require("../core/BufferAttribute.js");

class PlaneGeometry extends _BufferGeometry.BufferGeometry {
  constructor(width = 1, height = 1, widthSegments = 1, heightSegments = 1) {
    super();
    this.type = 'PlaneGeometry';
    this.parameters = {
      width: width,
      height: height,
      widthSegments: widthSegments,
      heightSegments: heightSegments
    };
    const width_half = width / 2;
    const height_half = height / 2;
    const gridX = Math.floor(widthSegments);
    const gridY = Math.floor(heightSegments);
    const gridX1 = gridX + 1;
    const gridY1 = gridY + 1;
    const segment_width = width / gridX;
    const segment_height = height / gridY; //

    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];

    for (let iy = 0; iy < gridY1; iy++) {
      const y = iy * segment_height - height_half;

      for (let ix = 0; ix < gridX1; ix++) {
        const x = ix * segment_width - width_half;
        vertices.push(x, -y, 0);
        normals.push(0, 0, 1);
        uvs.push(ix / gridX);
        uvs.push(1 - iy / gridY);
      }
    }

    for (let iy = 0; iy < gridY; iy++) {
      for (let ix = 0; ix < gridX; ix++) {
        const a = ix + gridX1 * iy;
        const b = ix + gridX1 * (iy + 1);
        const c = ix + 1 + gridX1 * (iy + 1);
        const d = ix + 1 + gridX1 * iy;
        indices.push(a, b, d);
        indices.push(b, c, d);
      }
    }

    this.setIndex(indices);
    this.setAttribute('position', new _BufferAttribute.Float32BufferAttribute(vertices, 3));
    this.setAttribute('normal', new _BufferAttribute.Float32BufferAttribute(normals, 3));
    this.setAttribute('uv', new _BufferAttribute.Float32BufferAttribute(uvs, 2));
  }

  copy(source) {
    super.copy(source);
    this.parameters = Object.assign({}, source.parameters);
    return this;
  }

  static fromJSON(data) {
    return new PlaneGeometry(data.width, data.height, data.widthSegments, data.heightSegments);
  }

}

exports.PlaneGeometry = PlaneGeometry;

},{"../core/BufferAttribute.js":120,"../core/BufferGeometry.js":121}],157:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PolyhedronGeometry = void 0;

var _BufferGeometry = require("../core/BufferGeometry.js");

var _BufferAttribute = require("../core/BufferAttribute.js");

var _Vector = require("../math/Vector3.js");

var _Vector2 = require("../math/Vector2.js");

class PolyhedronGeometry extends _BufferGeometry.BufferGeometry {
  constructor(vertices = [], indices = [], radius = 1, detail = 0) {
    super();
    this.type = 'PolyhedronGeometry';
    this.parameters = {
      vertices: vertices,
      indices: indices,
      radius: radius,
      detail: detail
    }; // default buffer data

    const vertexBuffer = [];
    const uvBuffer = []; // the subdivision creates the vertex buffer data

    subdivide(detail); // all vertices should lie on a conceptual sphere with a given radius

    applyRadius(radius); // finally, create the uv data

    generateUVs(); // build non-indexed geometry

    this.setAttribute('position', new _BufferAttribute.Float32BufferAttribute(vertexBuffer, 3));
    this.setAttribute('normal', new _BufferAttribute.Float32BufferAttribute(vertexBuffer.slice(), 3));
    this.setAttribute('uv', new _BufferAttribute.Float32BufferAttribute(uvBuffer, 2));

    if (detail === 0) {
      this.computeVertexNormals(); // flat normals
    } else {
      this.normalizeNormals(); // smooth normals
    } // helper functions


    function subdivide(detail) {
      const a = new _Vector.Vector3();
      const b = new _Vector.Vector3();
      const c = new _Vector.Vector3(); // iterate over all faces and apply a subdivision with the given detail value

      for (let i = 0; i < indices.length; i += 3) {
        // get the vertices of the face
        getVertexByIndex(indices[i + 0], a);
        getVertexByIndex(indices[i + 1], b);
        getVertexByIndex(indices[i + 2], c); // perform subdivision

        subdivideFace(a, b, c, detail);
      }
    }

    function subdivideFace(a, b, c, detail) {
      const cols = detail + 1; // we use this multidimensional array as a data structure for creating the subdivision

      const v = []; // construct all of the vertices for this subdivision

      for (let i = 0; i <= cols; i++) {
        v[i] = [];
        const aj = a.clone().lerp(c, i / cols);
        const bj = b.clone().lerp(c, i / cols);
        const rows = cols - i;

        for (let j = 0; j <= rows; j++) {
          if (j === 0 && i === cols) {
            v[i][j] = aj;
          } else {
            v[i][j] = aj.clone().lerp(bj, j / rows);
          }
        }
      } // construct all of the faces


      for (let i = 0; i < cols; i++) {
        for (let j = 0; j < 2 * (cols - i) - 1; j++) {
          const k = Math.floor(j / 2);

          if (j % 2 === 0) {
            pushVertex(v[i][k + 1]);
            pushVertex(v[i + 1][k]);
            pushVertex(v[i][k]);
          } else {
            pushVertex(v[i][k + 1]);
            pushVertex(v[i + 1][k + 1]);
            pushVertex(v[i + 1][k]);
          }
        }
      }
    }

    function applyRadius(radius) {
      const vertex = new _Vector.Vector3(); // iterate over the entire buffer and apply the radius to each vertex

      for (let i = 0; i < vertexBuffer.length; i += 3) {
        vertex.x = vertexBuffer[i + 0];
        vertex.y = vertexBuffer[i + 1];
        vertex.z = vertexBuffer[i + 2];
        vertex.normalize().multiplyScalar(radius);
        vertexBuffer[i + 0] = vertex.x;
        vertexBuffer[i + 1] = vertex.y;
        vertexBuffer[i + 2] = vertex.z;
      }
    }

    function generateUVs() {
      const vertex = new _Vector.Vector3();

      for (let i = 0; i < vertexBuffer.length; i += 3) {
        vertex.x = vertexBuffer[i + 0];
        vertex.y = vertexBuffer[i + 1];
        vertex.z = vertexBuffer[i + 2];
        const u = azimuth(vertex) / 2 / Math.PI + 0.5;
        const v = inclination(vertex) / Math.PI + 0.5;
        uvBuffer.push(u, 1 - v);
      }

      correctUVs();
      correctSeam();
    }

    function correctSeam() {
      // handle case when face straddles the seam, see #3269
      for (let i = 0; i < uvBuffer.length; i += 6) {
        // uv data of a single face
        const x0 = uvBuffer[i + 0];
        const x1 = uvBuffer[i + 2];
        const x2 = uvBuffer[i + 4];
        const max = Math.max(x0, x1, x2);
        const min = Math.min(x0, x1, x2); // 0.9 is somewhat arbitrary

        if (max > 0.9 && min < 0.1) {
          if (x0 < 0.2) uvBuffer[i + 0] += 1;
          if (x1 < 0.2) uvBuffer[i + 2] += 1;
          if (x2 < 0.2) uvBuffer[i + 4] += 1;
        }
      }
    }

    function pushVertex(vertex) {
      vertexBuffer.push(vertex.x, vertex.y, vertex.z);
    }

    function getVertexByIndex(index, vertex) {
      const stride = index * 3;
      vertex.x = vertices[stride + 0];
      vertex.y = vertices[stride + 1];
      vertex.z = vertices[stride + 2];
    }

    function correctUVs() {
      const a = new _Vector.Vector3();
      const b = new _Vector.Vector3();
      const c = new _Vector.Vector3();
      const centroid = new _Vector.Vector3();
      const uvA = new _Vector2.Vector2();
      const uvB = new _Vector2.Vector2();
      const uvC = new _Vector2.Vector2();

      for (let i = 0, j = 0; i < vertexBuffer.length; i += 9, j += 6) {
        a.set(vertexBuffer[i + 0], vertexBuffer[i + 1], vertexBuffer[i + 2]);
        b.set(vertexBuffer[i + 3], vertexBuffer[i + 4], vertexBuffer[i + 5]);
        c.set(vertexBuffer[i + 6], vertexBuffer[i + 7], vertexBuffer[i + 8]);
        uvA.set(uvBuffer[j + 0], uvBuffer[j + 1]);
        uvB.set(uvBuffer[j + 2], uvBuffer[j + 3]);
        uvC.set(uvBuffer[j + 4], uvBuffer[j + 5]);
        centroid.copy(a).add(b).add(c).divideScalar(3);
        const azi = azimuth(centroid);
        correctUV(uvA, j + 0, a, azi);
        correctUV(uvB, j + 2, b, azi);
        correctUV(uvC, j + 4, c, azi);
      }
    }

    function correctUV(uv, stride, vector, azimuth) {
      if (azimuth < 0 && uv.x === 1) {
        uvBuffer[stride] = uv.x - 1;
      }

      if (vector.x === 0 && vector.z === 0) {
        uvBuffer[stride] = azimuth / 2 / Math.PI + 0.5;
      }
    } // Angle around the Y axis, counter-clockwise when looking from above.


    function azimuth(vector) {
      return Math.atan2(vector.z, -vector.x);
    } // Angle above the XZ plane.


    function inclination(vector) {
      return Math.atan2(-vector.y, Math.sqrt(vector.x * vector.x + vector.z * vector.z));
    }
  }

  copy(source) {
    super.copy(source);
    this.parameters = Object.assign({}, source.parameters);
    return this;
  }

  static fromJSON(data) {
    return new PolyhedronGeometry(data.vertices, data.indices, data.radius, data.details);
  }

}

exports.PolyhedronGeometry = PolyhedronGeometry;

},{"../core/BufferAttribute.js":120,"../core/BufferGeometry.js":121,"../math/Vector2.js":174,"../math/Vector3.js":175}],158:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RingGeometry = void 0;

var _BufferGeometry = require("../core/BufferGeometry.js");

var _BufferAttribute = require("../core/BufferAttribute.js");

var _Vector = require("../math/Vector2.js");

var _Vector2 = require("../math/Vector3.js");

class RingGeometry extends _BufferGeometry.BufferGeometry {
  constructor(innerRadius = 0.5, outerRadius = 1, thetaSegments = 32, phiSegments = 1, thetaStart = 0, thetaLength = Math.PI * 2) {
    super();
    this.type = 'RingGeometry';
    this.parameters = {
      innerRadius: innerRadius,
      outerRadius: outerRadius,
      thetaSegments: thetaSegments,
      phiSegments: phiSegments,
      thetaStart: thetaStart,
      thetaLength: thetaLength
    };
    thetaSegments = Math.max(3, thetaSegments);
    phiSegments = Math.max(1, phiSegments); // buffers

    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = []; // some helper variables

    let radius = innerRadius;
    const radiusStep = (outerRadius - innerRadius) / phiSegments;
    const vertex = new _Vector2.Vector3();
    const uv = new _Vector.Vector2(); // generate vertices, normals and uvs

    for (let j = 0; j <= phiSegments; j++) {
      for (let i = 0; i <= thetaSegments; i++) {
        // values are generate from the inside of the ring to the outside
        const segment = thetaStart + i / thetaSegments * thetaLength; // vertex

        vertex.x = radius * Math.cos(segment);
        vertex.y = radius * Math.sin(segment);
        vertices.push(vertex.x, vertex.y, vertex.z); // normal

        normals.push(0, 0, 1); // uv

        uv.x = (vertex.x / outerRadius + 1) / 2;
        uv.y = (vertex.y / outerRadius + 1) / 2;
        uvs.push(uv.x, uv.y);
      } // increase the radius for next row of vertices


      radius += radiusStep;
    } // indices


    for (let j = 0; j < phiSegments; j++) {
      const thetaSegmentLevel = j * (thetaSegments + 1);

      for (let i = 0; i < thetaSegments; i++) {
        const segment = i + thetaSegmentLevel;
        const a = segment;
        const b = segment + thetaSegments + 1;
        const c = segment + thetaSegments + 2;
        const d = segment + 1; // faces

        indices.push(a, b, d);
        indices.push(b, c, d);
      }
    } // build geometry


    this.setIndex(indices);
    this.setAttribute('position', new _BufferAttribute.Float32BufferAttribute(vertices, 3));
    this.setAttribute('normal', new _BufferAttribute.Float32BufferAttribute(normals, 3));
    this.setAttribute('uv', new _BufferAttribute.Float32BufferAttribute(uvs, 2));
  }

  copy(source) {
    super.copy(source);
    this.parameters = Object.assign({}, source.parameters);
    return this;
  }

  static fromJSON(data) {
    return new RingGeometry(data.innerRadius, data.outerRadius, data.thetaSegments, data.phiSegments, data.thetaStart, data.thetaLength);
  }

}

exports.RingGeometry = RingGeometry;

},{"../core/BufferAttribute.js":120,"../core/BufferGeometry.js":121,"../math/Vector2.js":174,"../math/Vector3.js":175}],159:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ShapeGeometry = void 0;

var _BufferGeometry = require("../core/BufferGeometry.js");

var _BufferAttribute = require("../core/BufferAttribute.js");

var _Shape = require("../extras/core/Shape.js");

var _ShapeUtils = require("../extras/ShapeUtils.js");

var _Vector = require("../math/Vector2.js");

class ShapeGeometry extends _BufferGeometry.BufferGeometry {
  constructor(shapes = new _Shape.Shape([new _Vector.Vector2(0, 0.5), new _Vector.Vector2(-0.5, -0.5), new _Vector.Vector2(0.5, -0.5)]), curveSegments = 12) {
    super();
    this.type = 'ShapeGeometry';
    this.parameters = {
      shapes: shapes,
      curveSegments: curveSegments
    }; // buffers

    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = []; // helper variables

    let groupStart = 0;
    let groupCount = 0; // allow single and array values for "shapes" parameter

    if (Array.isArray(shapes) === false) {
      addShape(shapes);
    } else {
      for (let i = 0; i < shapes.length; i++) {
        addShape(shapes[i]);
        this.addGroup(groupStart, groupCount, i); // enables MultiMaterial support

        groupStart += groupCount;
        groupCount = 0;
      }
    } // build geometry


    this.setIndex(indices);
    this.setAttribute('position', new _BufferAttribute.Float32BufferAttribute(vertices, 3));
    this.setAttribute('normal', new _BufferAttribute.Float32BufferAttribute(normals, 3));
    this.setAttribute('uv', new _BufferAttribute.Float32BufferAttribute(uvs, 2)); // helper functions

    function addShape(shape) {
      const indexOffset = vertices.length / 3;
      const points = shape.extractPoints(curveSegments);
      let shapeVertices = points.shape;
      const shapeHoles = points.holes; // check direction of vertices

      if (_ShapeUtils.ShapeUtils.isClockWise(shapeVertices) === false) {
        shapeVertices = shapeVertices.reverse();
      }

      for (let i = 0, l = shapeHoles.length; i < l; i++) {
        const shapeHole = shapeHoles[i];

        if (_ShapeUtils.ShapeUtils.isClockWise(shapeHole) === true) {
          shapeHoles[i] = shapeHole.reverse();
        }
      }

      const faces = _ShapeUtils.ShapeUtils.triangulateShape(shapeVertices, shapeHoles); // join vertices of inner and outer paths to a single array


      for (let i = 0, l = shapeHoles.length; i < l; i++) {
        const shapeHole = shapeHoles[i];
        shapeVertices = shapeVertices.concat(shapeHole);
      } // vertices, normals, uvs


      for (let i = 0, l = shapeVertices.length; i < l; i++) {
        const vertex = shapeVertices[i];
        vertices.push(vertex.x, vertex.y, 0);
        normals.push(0, 0, 1);
        uvs.push(vertex.x, vertex.y); // world uvs
      } // indices


      for (let i = 0, l = faces.length; i < l; i++) {
        const face = faces[i];
        const a = face[0] + indexOffset;
        const b = face[1] + indexOffset;
        const c = face[2] + indexOffset;
        indices.push(a, b, c);
        groupCount += 3;
      }
    }
  }

  copy(source) {
    super.copy(source);
    this.parameters = Object.assign({}, source.parameters);
    return this;
  }

  toJSON() {
    const data = super.toJSON();
    const shapes = this.parameters.shapes;
    return toJSON(shapes, data);
  }

  static fromJSON(data, shapes) {
    const geometryShapes = [];

    for (let j = 0, jl = data.shapes.length; j < jl; j++) {
      const shape = shapes[data.shapes[j]];
      geometryShapes.push(shape);
    }

    return new ShapeGeometry(geometryShapes, data.curveSegments);
  }

}

exports.ShapeGeometry = ShapeGeometry;

function toJSON(shapes, data) {
  data.shapes = [];

  if (Array.isArray(shapes)) {
    for (let i = 0, l = shapes.length; i < l; i++) {
      const shape = shapes[i];
      data.shapes.push(shape.uuid);
    }
  } else {
    data.shapes.push(shapes.uuid);
  }

  return data;
}

},{"../core/BufferAttribute.js":120,"../core/BufferGeometry.js":121,"../extras/ShapeUtils.js":127,"../extras/core/Shape.js":132,"../math/Vector2.js":174}],160:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SphereGeometry = void 0;

var _BufferGeometry = require("../core/BufferGeometry.js");

var _BufferAttribute = require("../core/BufferAttribute.js");

var _Vector = require("../math/Vector3.js");

class SphereGeometry extends _BufferGeometry.BufferGeometry {
  constructor(radius = 1, widthSegments = 32, heightSegments = 16, phiStart = 0, phiLength = Math.PI * 2, thetaStart = 0, thetaLength = Math.PI) {
    super();
    this.type = 'SphereGeometry';
    this.parameters = {
      radius: radius,
      widthSegments: widthSegments,
      heightSegments: heightSegments,
      phiStart: phiStart,
      phiLength: phiLength,
      thetaStart: thetaStart,
      thetaLength: thetaLength
    };
    widthSegments = Math.max(3, Math.floor(widthSegments));
    heightSegments = Math.max(2, Math.floor(heightSegments));
    const thetaEnd = Math.min(thetaStart + thetaLength, Math.PI);
    let index = 0;
    const grid = [];
    const vertex = new _Vector.Vector3();
    const normal = new _Vector.Vector3(); // buffers

    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = []; // generate vertices, normals and uvs

    for (let iy = 0; iy <= heightSegments; iy++) {
      const verticesRow = [];
      const v = iy / heightSegments; // special case for the poles

      let uOffset = 0;

      if (iy === 0 && thetaStart === 0) {
        uOffset = 0.5 / widthSegments;
      } else if (iy === heightSegments && thetaEnd === Math.PI) {
        uOffset = -0.5 / widthSegments;
      }

      for (let ix = 0; ix <= widthSegments; ix++) {
        const u = ix / widthSegments; // vertex

        vertex.x = -radius * Math.cos(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
        vertex.y = radius * Math.cos(thetaStart + v * thetaLength);
        vertex.z = radius * Math.sin(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
        vertices.push(vertex.x, vertex.y, vertex.z); // normal

        normal.copy(vertex).normalize();
        normals.push(normal.x, normal.y, normal.z); // uv

        uvs.push(u + uOffset, 1 - v);
        verticesRow.push(index++);
      }

      grid.push(verticesRow);
    } // indices


    for (let iy = 0; iy < heightSegments; iy++) {
      for (let ix = 0; ix < widthSegments; ix++) {
        const a = grid[iy][ix + 1];
        const b = grid[iy][ix];
        const c = grid[iy + 1][ix];
        const d = grid[iy + 1][ix + 1];
        if (iy !== 0 || thetaStart > 0) indices.push(a, b, d);
        if (iy !== heightSegments - 1 || thetaEnd < Math.PI) indices.push(b, c, d);
      }
    } // build geometry


    this.setIndex(indices);
    this.setAttribute('position', new _BufferAttribute.Float32BufferAttribute(vertices, 3));
    this.setAttribute('normal', new _BufferAttribute.Float32BufferAttribute(normals, 3));
    this.setAttribute('uv', new _BufferAttribute.Float32BufferAttribute(uvs, 2));
  }

  copy(source) {
    super.copy(source);
    this.parameters = Object.assign({}, source.parameters);
    return this;
  }

  static fromJSON(data) {
    return new SphereGeometry(data.radius, data.widthSegments, data.heightSegments, data.phiStart, data.phiLength, data.thetaStart, data.thetaLength);
  }

}

exports.SphereGeometry = SphereGeometry;

},{"../core/BufferAttribute.js":120,"../core/BufferGeometry.js":121,"../math/Vector3.js":175}],161:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TetrahedronGeometry = void 0;

var _PolyhedronGeometry = require("./PolyhedronGeometry.js");

class TetrahedronGeometry extends _PolyhedronGeometry.PolyhedronGeometry {
  constructor(radius = 1, detail = 0) {
    const vertices = [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1];
    const indices = [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1];
    super(vertices, indices, radius, detail);
    this.type = 'TetrahedronGeometry';
    this.parameters = {
      radius: radius,
      detail: detail
    };
  }

  static fromJSON(data) {
    return new TetrahedronGeometry(data.radius, data.detail);
  }

}

exports.TetrahedronGeometry = TetrahedronGeometry;

},{"./PolyhedronGeometry.js":157}],162:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TorusGeometry = void 0;

var _BufferGeometry = require("../core/BufferGeometry.js");

var _BufferAttribute = require("../core/BufferAttribute.js");

var _Vector = require("../math/Vector3.js");

class TorusGeometry extends _BufferGeometry.BufferGeometry {
  constructor(radius = 1, tube = 0.4, radialSegments = 12, tubularSegments = 48, arc = Math.PI * 2) {
    super();
    this.type = 'TorusGeometry';
    this.parameters = {
      radius: radius,
      tube: tube,
      radialSegments: radialSegments,
      tubularSegments: tubularSegments,
      arc: arc
    };
    radialSegments = Math.floor(radialSegments);
    tubularSegments = Math.floor(tubularSegments); // buffers

    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = []; // helper variables

    const center = new _Vector.Vector3();
    const vertex = new _Vector.Vector3();
    const normal = new _Vector.Vector3(); // generate vertices, normals and uvs

    for (let j = 0; j <= radialSegments; j++) {
      for (let i = 0; i <= tubularSegments; i++) {
        const u = i / tubularSegments * arc;
        const v = j / radialSegments * Math.PI * 2; // vertex

        vertex.x = (radius + tube * Math.cos(v)) * Math.cos(u);
        vertex.y = (radius + tube * Math.cos(v)) * Math.sin(u);
        vertex.z = tube * Math.sin(v);
        vertices.push(vertex.x, vertex.y, vertex.z); // normal

        center.x = radius * Math.cos(u);
        center.y = radius * Math.sin(u);
        normal.subVectors(vertex, center).normalize();
        normals.push(normal.x, normal.y, normal.z); // uv

        uvs.push(i / tubularSegments);
        uvs.push(j / radialSegments);
      }
    } // generate indices


    for (let j = 1; j <= radialSegments; j++) {
      for (let i = 1; i <= tubularSegments; i++) {
        // indices
        const a = (tubularSegments + 1) * j + i - 1;
        const b = (tubularSegments + 1) * (j - 1) + i - 1;
        const c = (tubularSegments + 1) * (j - 1) + i;
        const d = (tubularSegments + 1) * j + i; // faces

        indices.push(a, b, d);
        indices.push(b, c, d);
      }
    } // build geometry


    this.setIndex(indices);
    this.setAttribute('position', new _BufferAttribute.Float32BufferAttribute(vertices, 3));
    this.setAttribute('normal', new _BufferAttribute.Float32BufferAttribute(normals, 3));
    this.setAttribute('uv', new _BufferAttribute.Float32BufferAttribute(uvs, 2));
  }

  copy(source) {
    super.copy(source);
    this.parameters = Object.assign({}, source.parameters);
    return this;
  }

  static fromJSON(data) {
    return new TorusGeometry(data.radius, data.tube, data.radialSegments, data.tubularSegments, data.arc);
  }

}

exports.TorusGeometry = TorusGeometry;

},{"../core/BufferAttribute.js":120,"../core/BufferGeometry.js":121,"../math/Vector3.js":175}],163:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TorusKnotGeometry = void 0;

var _BufferGeometry = require("../core/BufferGeometry.js");

var _BufferAttribute = require("../core/BufferAttribute.js");

var _Vector = require("../math/Vector3.js");

class TorusKnotGeometry extends _BufferGeometry.BufferGeometry {
  constructor(radius = 1, tube = 0.4, tubularSegments = 64, radialSegments = 8, p = 2, q = 3) {
    super();
    this.type = 'TorusKnotGeometry';
    this.parameters = {
      radius: radius,
      tube: tube,
      tubularSegments: tubularSegments,
      radialSegments: radialSegments,
      p: p,
      q: q
    };
    tubularSegments = Math.floor(tubularSegments);
    radialSegments = Math.floor(radialSegments); // buffers

    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = []; // helper variables

    const vertex = new _Vector.Vector3();
    const normal = new _Vector.Vector3();
    const P1 = new _Vector.Vector3();
    const P2 = new _Vector.Vector3();
    const B = new _Vector.Vector3();
    const T = new _Vector.Vector3();
    const N = new _Vector.Vector3(); // generate vertices, normals and uvs

    for (let i = 0; i <= tubularSegments; ++i) {
      // the radian "u" is used to calculate the position on the torus curve of the current tubular segment
      const u = i / tubularSegments * p * Math.PI * 2; // now we calculate two points. P1 is our current position on the curve, P2 is a little farther ahead.
      // these points are used to create a special "coordinate space", which is necessary to calculate the correct vertex positions

      calculatePositionOnCurve(u, p, q, radius, P1);
      calculatePositionOnCurve(u + 0.01, p, q, radius, P2); // calculate orthonormal basis

      T.subVectors(P2, P1);
      N.addVectors(P2, P1);
      B.crossVectors(T, N);
      N.crossVectors(B, T); // normalize B, N. T can be ignored, we don't use it

      B.normalize();
      N.normalize();

      for (let j = 0; j <= radialSegments; ++j) {
        // now calculate the vertices. they are nothing more than an extrusion of the torus curve.
        // because we extrude a shape in the xy-plane, there is no need to calculate a z-value.
        const v = j / radialSegments * Math.PI * 2;
        const cx = -tube * Math.cos(v);
        const cy = tube * Math.sin(v); // now calculate the final vertex position.
        // first we orient the extrusion with our basis vectors, then we add it to the current position on the curve

        vertex.x = P1.x + (cx * N.x + cy * B.x);
        vertex.y = P1.y + (cx * N.y + cy * B.y);
        vertex.z = P1.z + (cx * N.z + cy * B.z);
        vertices.push(vertex.x, vertex.y, vertex.z); // normal (P1 is always the center/origin of the extrusion, thus we can use it to calculate the normal)

        normal.subVectors(vertex, P1).normalize();
        normals.push(normal.x, normal.y, normal.z); // uv

        uvs.push(i / tubularSegments);
        uvs.push(j / radialSegments);
      }
    } // generate indices


    for (let j = 1; j <= tubularSegments; j++) {
      for (let i = 1; i <= radialSegments; i++) {
        // indices
        const a = (radialSegments + 1) * (j - 1) + (i - 1);
        const b = (radialSegments + 1) * j + (i - 1);
        const c = (radialSegments + 1) * j + i;
        const d = (radialSegments + 1) * (j - 1) + i; // faces

        indices.push(a, b, d);
        indices.push(b, c, d);
      }
    } // build geometry


    this.setIndex(indices);
    this.setAttribute('position', new _BufferAttribute.Float32BufferAttribute(vertices, 3));
    this.setAttribute('normal', new _BufferAttribute.Float32BufferAttribute(normals, 3));
    this.setAttribute('uv', new _BufferAttribute.Float32BufferAttribute(uvs, 2)); // this function calculates the current position on the torus curve

    function calculatePositionOnCurve(u, p, q, radius, position) {
      const cu = Math.cos(u);
      const su = Math.sin(u);
      const quOverP = q / p * u;
      const cs = Math.cos(quOverP);
      position.x = radius * (2 + cs) * 0.5 * cu;
      position.y = radius * (2 + cs) * su * 0.5;
      position.z = radius * Math.sin(quOverP) * 0.5;
    }
  }

  copy(source) {
    super.copy(source);
    this.parameters = Object.assign({}, source.parameters);
    return this;
  }

  static fromJSON(data) {
    return new TorusKnotGeometry(data.radius, data.tube, data.tubularSegments, data.radialSegments, data.p, data.q);
  }

}

exports.TorusKnotGeometry = TorusKnotGeometry;

},{"../core/BufferAttribute.js":120,"../core/BufferGeometry.js":121,"../math/Vector3.js":175}],164:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TubeGeometry = void 0;

var _BufferGeometry = require("../core/BufferGeometry.js");

var _BufferAttribute = require("../core/BufferAttribute.js");

var Curves = _interopRequireWildcard(require("../extras/curves/Curves.js"));

var _Vector = require("../math/Vector2.js");

var _Vector2 = require("../math/Vector3.js");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

class TubeGeometry extends _BufferGeometry.BufferGeometry {
  constructor(path = new Curves['QuadraticBezierCurve3'](new _Vector2.Vector3(-1, -1, 0), new _Vector2.Vector3(-1, 1, 0), new _Vector2.Vector3(1, 1, 0)), tubularSegments = 64, radius = 1, radialSegments = 8, closed = false) {
    super();
    this.type = 'TubeGeometry';
    this.parameters = {
      path: path,
      tubularSegments: tubularSegments,
      radius: radius,
      radialSegments: radialSegments,
      closed: closed
    };
    const frames = path.computeFrenetFrames(tubularSegments, closed); // expose internals

    this.tangents = frames.tangents;
    this.normals = frames.normals;
    this.binormals = frames.binormals; // helper variables

    const vertex = new _Vector2.Vector3();
    const normal = new _Vector2.Vector3();
    const uv = new _Vector.Vector2();
    let P = new _Vector2.Vector3(); // buffer

    const vertices = [];
    const normals = [];
    const uvs = [];
    const indices = []; // create buffer data

    generateBufferData(); // build geometry

    this.setIndex(indices);
    this.setAttribute('position', new _BufferAttribute.Float32BufferAttribute(vertices, 3));
    this.setAttribute('normal', new _BufferAttribute.Float32BufferAttribute(normals, 3));
    this.setAttribute('uv', new _BufferAttribute.Float32BufferAttribute(uvs, 2)); // functions

    function generateBufferData() {
      for (let i = 0; i < tubularSegments; i++) {
        generateSegment(i);
      } // if the geometry is not closed, generate the last row of vertices and normals
      // at the regular position on the given path
      //
      // if the geometry is closed, duplicate the first row of vertices and normals (uvs will differ)


      generateSegment(closed === false ? tubularSegments : 0); // uvs are generated in a separate function.
      // this makes it easy compute correct values for closed geometries

      generateUVs(); // finally create faces

      generateIndices();
    }

    function generateSegment(i) {
      // we use getPointAt to sample evenly distributed points from the given path
      P = path.getPointAt(i / tubularSegments, P); // retrieve corresponding normal and binormal

      const N = frames.normals[i];
      const B = frames.binormals[i]; // generate normals and vertices for the current segment

      for (let j = 0; j <= radialSegments; j++) {
        const v = j / radialSegments * Math.PI * 2;
        const sin = Math.sin(v);
        const cos = -Math.cos(v); // normal

        normal.x = cos * N.x + sin * B.x;
        normal.y = cos * N.y + sin * B.y;
        normal.z = cos * N.z + sin * B.z;
        normal.normalize();
        normals.push(normal.x, normal.y, normal.z); // vertex

        vertex.x = P.x + radius * normal.x;
        vertex.y = P.y + radius * normal.y;
        vertex.z = P.z + radius * normal.z;
        vertices.push(vertex.x, vertex.y, vertex.z);
      }
    }

    function generateIndices() {
      for (let j = 1; j <= tubularSegments; j++) {
        for (let i = 1; i <= radialSegments; i++) {
          const a = (radialSegments + 1) * (j - 1) + (i - 1);
          const b = (radialSegments + 1) * j + (i - 1);
          const c = (radialSegments + 1) * j + i;
          const d = (radialSegments + 1) * (j - 1) + i; // faces

          indices.push(a, b, d);
          indices.push(b, c, d);
        }
      }
    }

    function generateUVs() {
      for (let i = 0; i <= tubularSegments; i++) {
        for (let j = 0; j <= radialSegments; j++) {
          uv.x = i / tubularSegments;
          uv.y = j / radialSegments;
          uvs.push(uv.x, uv.y);
        }
      }
    }
  }

  copy(source) {
    super.copy(source);
    this.parameters = Object.assign({}, source.parameters);
    return this;
  }

  toJSON() {
    const data = super.toJSON();
    data.path = this.parameters.path.toJSON();
    return data;
  }

  static fromJSON(data) {
    // This only works for built-in curves (e.g. CatmullRomCurve3).
    // User defined curves or instances of CurvePath will not be deserialized.
    return new TubeGeometry(new Curves[data.path.type]().fromJSON(data.path), data.tubularSegments, data.radius, data.radialSegments, data.closed);
  }

}

exports.TubeGeometry = TubeGeometry;

},{"../core/BufferAttribute.js":120,"../core/BufferGeometry.js":121,"../extras/curves/Curves.js":137,"../math/Vector2.js":174,"../math/Vector3.js":175}],165:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.WireframeGeometry = void 0;

var _BufferGeometry = require("../core/BufferGeometry.js");

var _BufferAttribute = require("../core/BufferAttribute.js");

var _Vector = require("../math/Vector3.js");

class WireframeGeometry extends _BufferGeometry.BufferGeometry {
  constructor(geometry = null) {
    super();
    this.type = 'WireframeGeometry';
    this.parameters = {
      geometry: geometry
    };

    if (geometry !== null) {
      // buffer
      const vertices = [];
      const edges = new Set(); // helper variables

      const start = new _Vector.Vector3();
      const end = new _Vector.Vector3();

      if (geometry.index !== null) {
        // indexed BufferGeometry
        const position = geometry.attributes.position;
        const indices = geometry.index;
        let groups = geometry.groups;

        if (groups.length === 0) {
          groups = [{
            start: 0,
            count: indices.count,
            materialIndex: 0
          }];
        } // create a data structure that contains all edges without duplicates


        for (let o = 0, ol = groups.length; o < ol; ++o) {
          const group = groups[o];
          const groupStart = group.start;
          const groupCount = group.count;

          for (let i = groupStart, l = groupStart + groupCount; i < l; i += 3) {
            for (let j = 0; j < 3; j++) {
              const index1 = indices.getX(i + j);
              const index2 = indices.getX(i + (j + 1) % 3);
              start.fromBufferAttribute(position, index1);
              end.fromBufferAttribute(position, index2);

              if (isUniqueEdge(start, end, edges) === true) {
                vertices.push(start.x, start.y, start.z);
                vertices.push(end.x, end.y, end.z);
              }
            }
          }
        }
      } else {
        // non-indexed BufferGeometry
        const position = geometry.attributes.position;

        for (let i = 0, l = position.count / 3; i < l; i++) {
          for (let j = 0; j < 3; j++) {
            // three edges per triangle, an edge is represented as (index1, index2)
            // e.g. the first triangle has the following edges: (0,1),(1,2),(2,0)
            const index1 = 3 * i + j;
            const index2 = 3 * i + (j + 1) % 3;
            start.fromBufferAttribute(position, index1);
            end.fromBufferAttribute(position, index2);

            if (isUniqueEdge(start, end, edges) === true) {
              vertices.push(start.x, start.y, start.z);
              vertices.push(end.x, end.y, end.z);
            }
          }
        }
      } // build geometry


      this.setAttribute('position', new _BufferAttribute.Float32BufferAttribute(vertices, 3));
    }
  }

  copy(source) {
    super.copy(source);
    this.parameters = Object.assign({}, source.parameters);
    return this;
  }

}

exports.WireframeGeometry = WireframeGeometry;

function isUniqueEdge(start, end, edges) {
  const hash1 = `${start.x},${start.y},${start.z}-${end.x},${end.y},${end.z}`;
  const hash2 = `${end.x},${end.y},${end.z}-${start.x},${start.y},${start.z}`; // coincident edge

  if (edges.has(hash1) === true || edges.has(hash2) === true) {
    return false;
  } else {
    edges.add(hash1);
    edges.add(hash2);
    return true;
  }
}

},{"../core/BufferAttribute.js":120,"../core/BufferGeometry.js":121,"../math/Vector3.js":175}],166:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Box3 = void 0;

var _Vector = require("./Vector3.js");

class Box3 {
  constructor(min = new _Vector.Vector3(+Infinity, +Infinity, +Infinity), max = new _Vector.Vector3(-Infinity, -Infinity, -Infinity)) {
    this.isBox3 = true;
    this.min = min;
    this.max = max;
  }

  set(min, max) {
    this.min.copy(min);
    this.max.copy(max);
    return this;
  }

  setFromArray(array) {
    this.makeEmpty();

    for (let i = 0, il = array.length; i < il; i += 3) {
      this.expandByPoint(_vector.fromArray(array, i));
    }

    return this;
  }

  setFromBufferAttribute(attribute) {
    this.makeEmpty();

    for (let i = 0, il = attribute.count; i < il; i++) {
      this.expandByPoint(_vector.fromBufferAttribute(attribute, i));
    }

    return this;
  }

  setFromPoints(points) {
    this.makeEmpty();

    for (let i = 0, il = points.length; i < il; i++) {
      this.expandByPoint(points[i]);
    }

    return this;
  }

  setFromCenterAndSize(center, size) {
    const halfSize = _vector.copy(size).multiplyScalar(0.5);

    this.min.copy(center).sub(halfSize);
    this.max.copy(center).add(halfSize);
    return this;
  }

  setFromObject(object, precise = false) {
    this.makeEmpty();
    return this.expandByObject(object, precise);
  }

  clone() {
    return new this.constructor().copy(this);
  }

  copy(box) {
    this.min.copy(box.min);
    this.max.copy(box.max);
    return this;
  }

  makeEmpty() {
    this.min.x = this.min.y = this.min.z = +Infinity;
    this.max.x = this.max.y = this.max.z = -Infinity;
    return this;
  }

  isEmpty() {
    // this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes
    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
  }

  getCenter(target) {
    return this.isEmpty() ? target.set(0, 0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
  }

  getSize(target) {
    return this.isEmpty() ? target.set(0, 0, 0) : target.subVectors(this.max, this.min);
  }

  expandByPoint(point) {
    this.min.min(point);
    this.max.max(point);
    return this;
  }

  expandByVector(vector) {
    this.min.sub(vector);
    this.max.add(vector);
    return this;
  }

  expandByScalar(scalar) {
    this.min.addScalar(-scalar);
    this.max.addScalar(scalar);
    return this;
  }

  expandByObject(object, precise = false) {
    // Computes the world-axis-aligned bounding box of an object (including its children),
    // accounting for both the object's, and children's, world transforms
    object.updateWorldMatrix(false, false);

    if (object.boundingBox !== undefined) {
      if (object.boundingBox === null) {
        object.computeBoundingBox();
      }

      _box.copy(object.boundingBox);

      _box.applyMatrix4(object.matrixWorld);

      this.union(_box);
    } else {
      const geometry = object.geometry;

      if (geometry !== undefined) {
        if (precise && geometry.attributes !== undefined && geometry.attributes.position !== undefined) {
          const position = geometry.attributes.position;

          for (let i = 0, l = position.count; i < l; i++) {
            _vector.fromBufferAttribute(position, i).applyMatrix4(object.matrixWorld);

            this.expandByPoint(_vector);
          }
        } else {
          if (geometry.boundingBox === null) {
            geometry.computeBoundingBox();
          }

          _box.copy(geometry.boundingBox);

          _box.applyMatrix4(object.matrixWorld);

          this.union(_box);
        }
      }
    }

    const children = object.children;

    for (let i = 0, l = children.length; i < l; i++) {
      this.expandByObject(children[i], precise);
    }

    return this;
  }

  containsPoint(point) {
    return point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y || point.z < this.min.z || point.z > this.max.z ? false : true;
  }

  containsBox(box) {
    return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y && this.min.z <= box.min.z && box.max.z <= this.max.z;
  }

  getParameter(point, target) {
    // This can potentially have a divide by zero if the box
    // has a size dimension of 0.
    return target.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y), (point.z - this.min.z) / (this.max.z - this.min.z));
  }

  intersectsBox(box) {
    // using 6 splitting planes to rule out intersections.
    return box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y || box.max.z < this.min.z || box.min.z > this.max.z ? false : true;
  }

  intersectsSphere(sphere) {
    // Find the point on the AABB closest to the sphere center.
    this.clampPoint(sphere.center, _vector); // If that point is inside the sphere, the AABB and sphere intersect.

    return _vector.distanceToSquared(sphere.center) <= sphere.radius * sphere.radius;
  }

  intersectsPlane(plane) {
    // We compute the minimum and maximum dot product values. If those values
    // are on the same side (back or front) of the plane, then there is no intersection.
    let min, max;

    if (plane.normal.x > 0) {
      min = plane.normal.x * this.min.x;
      max = plane.normal.x * this.max.x;
    } else {
      min = plane.normal.x * this.max.x;
      max = plane.normal.x * this.min.x;
    }

    if (plane.normal.y > 0) {
      min += plane.normal.y * this.min.y;
      max += plane.normal.y * this.max.y;
    } else {
      min += plane.normal.y * this.max.y;
      max += plane.normal.y * this.min.y;
    }

    if (plane.normal.z > 0) {
      min += plane.normal.z * this.min.z;
      max += plane.normal.z * this.max.z;
    } else {
      min += plane.normal.z * this.max.z;
      max += plane.normal.z * this.min.z;
    }

    return min <= -plane.constant && max >= -plane.constant;
  }

  intersectsTriangle(triangle) {
    if (this.isEmpty()) {
      return false;
    } // compute box center and extents


    this.getCenter(_center);

    _extents.subVectors(this.max, _center); // translate triangle to aabb origin


    _v0.subVectors(triangle.a, _center);

    _v1.subVectors(triangle.b, _center);

    _v2.subVectors(triangle.c, _center); // compute edge vectors for triangle


    _f0.subVectors(_v1, _v0);

    _f1.subVectors(_v2, _v1);

    _f2.subVectors(_v0, _v2); // test against axes that are given by cross product combinations of the edges of the triangle and the edges of the aabb
    // make an axis testing of each of the 3 sides of the aabb against each of the 3 sides of the triangle = 9 axis of separation
    // axis_ij = u_i x f_j (u0, u1, u2 = face normals of aabb = x,y,z axes vectors since aabb is axis aligned)


    let axes = [0, -_f0.z, _f0.y, 0, -_f1.z, _f1.y, 0, -_f2.z, _f2.y, _f0.z, 0, -_f0.x, _f1.z, 0, -_f1.x, _f2.z, 0, -_f2.x, -_f0.y, _f0.x, 0, -_f1.y, _f1.x, 0, -_f2.y, _f2.x, 0];

    if (!satForAxes(axes, _v0, _v1, _v2, _extents)) {
      return false;
    } // test 3 face normals from the aabb


    axes = [1, 0, 0, 0, 1, 0, 0, 0, 1];

    if (!satForAxes(axes, _v0, _v1, _v2, _extents)) {
      return false;
    } // finally testing the face normal of the triangle
    // use already existing triangle edge vectors here


    _triangleNormal.crossVectors(_f0, _f1);

    axes = [_triangleNormal.x, _triangleNormal.y, _triangleNormal.z];
    return satForAxes(axes, _v0, _v1, _v2, _extents);
  }

  clampPoint(point, target) {
    return target.copy(point).clamp(this.min, this.max);
  }

  distanceToPoint(point) {
    return this.clampPoint(point, _vector).distanceTo(point);
  }

  getBoundingSphere(target) {
    if (this.isEmpty()) {
      target.makeEmpty();
    } else {
      this.getCenter(target.center);
      target.radius = this.getSize(_vector).length() * 0.5;
    }

    return target;
  }

  intersect(box) {
    this.min.max(box.min);
    this.max.min(box.max); // ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.

    if (this.isEmpty()) this.makeEmpty();
    return this;
  }

  union(box) {
    this.min.min(box.min);
    this.max.max(box.max);
    return this;
  }

  applyMatrix4(matrix) {
    // transform of empty box is an empty box.
    if (this.isEmpty()) return this; // NOTE: I am using a binary pattern to specify all 2^3 combinations below

    _points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix); // 000


    _points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix); // 001


    _points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix); // 010


    _points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix); // 011


    _points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix); // 100


    _points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix); // 101


    _points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix); // 110


    _points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix); // 111


    this.setFromPoints(_points);
    return this;
  }

  translate(offset) {
    this.min.add(offset);
    this.max.add(offset);
    return this;
  }

  equals(box) {
    return box.min.equals(this.min) && box.max.equals(this.max);
  }

}

exports.Box3 = Box3;
const _points = [/*@__PURE__*/new _Vector.Vector3(), /*@__PURE__*/new _Vector.Vector3(), /*@__PURE__*/new _Vector.Vector3(), /*@__PURE__*/new _Vector.Vector3(), /*@__PURE__*/new _Vector.Vector3(), /*@__PURE__*/new _Vector.Vector3(), /*@__PURE__*/new _Vector.Vector3(), /*@__PURE__*/new _Vector.Vector3()];

const _vector = /*@__PURE__*/new _Vector.Vector3();

const _box = /*@__PURE__*/new Box3(); // triangle centered vertices


const _v0 = /*@__PURE__*/new _Vector.Vector3();

const _v1 = /*@__PURE__*/new _Vector.Vector3();

const _v2 = /*@__PURE__*/new _Vector.Vector3(); // triangle edge vectors


const _f0 = /*@__PURE__*/new _Vector.Vector3();

const _f1 = /*@__PURE__*/new _Vector.Vector3();

const _f2 = /*@__PURE__*/new _Vector.Vector3();

const _center = /*@__PURE__*/new _Vector.Vector3();

const _extents = /*@__PURE__*/new _Vector.Vector3();

const _triangleNormal = /*@__PURE__*/new _Vector.Vector3();

const _testAxis = /*@__PURE__*/new _Vector.Vector3();

function satForAxes(axes, v0, v1, v2, extents) {
  for (let i = 0, j = axes.length - 3; i <= j; i += 3) {
    _testAxis.fromArray(axes, i); // project the aabb onto the separating axis


    const r = extents.x * Math.abs(_testAxis.x) + extents.y * Math.abs(_testAxis.y) + extents.z * Math.abs(_testAxis.z); // project all 3 vertices of the triangle onto the separating axis

    const p0 = v0.dot(_testAxis);
    const p1 = v1.dot(_testAxis);
    const p2 = v2.dot(_testAxis); // actual test, basically see if either of the most extreme of the triangle points intersects r

    if (Math.max(-Math.max(p0, p1, p2), Math.min(p0, p1, p2)) > r) {
      // points of the projected triangle are outside the projected half-length of the aabb
      // the axis is separating and we can exit
      return false;
    }
  }

  return true;
}

},{"./Vector3.js":175}],167:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Euler = void 0;

var _Quaternion = require("./Quaternion.js");

var _Matrix = require("./Matrix4.js");

var _MathUtils = require("./MathUtils.js");

const _matrix = /*@__PURE__*/new _Matrix.Matrix4();

const _quaternion = /*@__PURE__*/new _Quaternion.Quaternion();

class Euler {
  constructor(x = 0, y = 0, z = 0, order = Euler.DEFAULT_ORDER) {
    this.isEuler = true;
    this._x = x;
    this._y = y;
    this._z = z;
    this._order = order;
  }

  get x() {
    return this._x;
  }

  set x(value) {
    this._x = value;

    this._onChangeCallback();
  }

  get y() {
    return this._y;
  }

  set y(value) {
    this._y = value;

    this._onChangeCallback();
  }

  get z() {
    return this._z;
  }

  set z(value) {
    this._z = value;

    this._onChangeCallback();
  }

  get order() {
    return this._order;
  }

  set order(value) {
    this._order = value;

    this._onChangeCallback();
  }

  set(x, y, z, order = this._order) {
    this._x = x;
    this._y = y;
    this._z = z;
    this._order = order;

    this._onChangeCallback();

    return this;
  }

  clone() {
    return new this.constructor(this._x, this._y, this._z, this._order);
  }

  copy(euler) {
    this._x = euler._x;
    this._y = euler._y;
    this._z = euler._z;
    this._order = euler._order;

    this._onChangeCallback();

    return this;
  }

  setFromRotationMatrix(m, order = this._order, update = true) {
    // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
    const te = m.elements;
    const m11 = te[0],
          m12 = te[4],
          m13 = te[8];
    const m21 = te[1],
          m22 = te[5],
          m23 = te[9];
    const m31 = te[2],
          m32 = te[6],
          m33 = te[10];

    switch (order) {
      case 'XYZ':
        this._y = Math.asin((0, _MathUtils.clamp)(m13, -1, 1));

        if (Math.abs(m13) < 0.9999999) {
          this._x = Math.atan2(-m23, m33);
          this._z = Math.atan2(-m12, m11);
        } else {
          this._x = Math.atan2(m32, m22);
          this._z = 0;
        }

        break;

      case 'YXZ':
        this._x = Math.asin(-(0, _MathUtils.clamp)(m23, -1, 1));

        if (Math.abs(m23) < 0.9999999) {
          this._y = Math.atan2(m13, m33);
          this._z = Math.atan2(m21, m22);
        } else {
          this._y = Math.atan2(-m31, m11);
          this._z = 0;
        }

        break;

      case 'ZXY':
        this._x = Math.asin((0, _MathUtils.clamp)(m32, -1, 1));

        if (Math.abs(m32) < 0.9999999) {
          this._y = Math.atan2(-m31, m33);
          this._z = Math.atan2(-m12, m22);
        } else {
          this._y = 0;
          this._z = Math.atan2(m21, m11);
        }

        break;

      case 'ZYX':
        this._y = Math.asin(-(0, _MathUtils.clamp)(m31, -1, 1));

        if (Math.abs(m31) < 0.9999999) {
          this._x = Math.atan2(m32, m33);
          this._z = Math.atan2(m21, m11);
        } else {
          this._x = 0;
          this._z = Math.atan2(-m12, m22);
        }

        break;

      case 'YZX':
        this._z = Math.asin((0, _MathUtils.clamp)(m21, -1, 1));

        if (Math.abs(m21) < 0.9999999) {
          this._x = Math.atan2(-m23, m22);
          this._y = Math.atan2(-m31, m11);
        } else {
          this._x = 0;
          this._y = Math.atan2(m13, m33);
        }

        break;

      case 'XZY':
        this._z = Math.asin(-(0, _MathUtils.clamp)(m12, -1, 1));

        if (Math.abs(m12) < 0.9999999) {
          this._x = Math.atan2(m32, m22);
          this._y = Math.atan2(m13, m11);
        } else {
          this._x = Math.atan2(-m23, m33);
          this._y = 0;
        }

        break;

      default:
        console.warn('THREE.Euler: .setFromRotationMatrix() encountered an unknown order: ' + order);
    }

    this._order = order;
    if (update === true) this._onChangeCallback();
    return this;
  }

  setFromQuaternion(q, order, update) {
    _matrix.makeRotationFromQuaternion(q);

    return this.setFromRotationMatrix(_matrix, order, update);
  }

  setFromVector3(v, order = this._order) {
    return this.set(v.x, v.y, v.z, order);
  }

  reorder(newOrder) {
    // WARNING: this discards revolution information -bhouston
    _quaternion.setFromEuler(this);

    return this.setFromQuaternion(_quaternion, newOrder);
  }

  equals(euler) {
    return euler._x === this._x && euler._y === this._y && euler._z === this._z && euler._order === this._order;
  }

  fromArray(array) {
    this._x = array[0];
    this._y = array[1];
    this._z = array[2];
    if (array[3] !== undefined) this._order = array[3];

    this._onChangeCallback();

    return this;
  }

  toArray(array = [], offset = 0) {
    array[offset] = this._x;
    array[offset + 1] = this._y;
    array[offset + 2] = this._z;
    array[offset + 3] = this._order;
    return array;
  }

  _onChange(callback) {
    this._onChangeCallback = callback;
    return this;
  }

  _onChangeCallback() {}

  *[Symbol.iterator]() {
    yield this._x;
    yield this._y;
    yield this._z;
    yield this._order;
  }

}

exports.Euler = Euler;
Euler.DEFAULT_ORDER = 'XYZ';

},{"./MathUtils.js":168,"./Matrix4.js":170,"./Quaternion.js":171}],168:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RAD2DEG = exports.MathUtils = exports.DEG2RAD = void 0;
exports.ceilPowerOfTwo = ceilPowerOfTwo;
exports.clamp = clamp;
exports.damp = damp;
exports.degToRad = degToRad;
exports.denormalize = denormalize;
exports.euclideanModulo = euclideanModulo;
exports.floorPowerOfTwo = floorPowerOfTwo;
exports.generateUUID = generateUUID;
exports.inverseLerp = inverseLerp;
exports.isPowerOfTwo = isPowerOfTwo;
exports.lerp = lerp;
exports.mapLinear = mapLinear;
exports.normalize = normalize;
exports.pingpong = pingpong;
exports.radToDeg = radToDeg;
exports.randFloat = randFloat;
exports.randFloatSpread = randFloatSpread;
exports.randInt = randInt;
exports.seededRandom = seededRandom;
exports.setQuaternionFromProperEuler = setQuaternionFromProperEuler;
exports.smootherstep = smootherstep;
exports.smoothstep = smoothstep;
const _lut = ['00', '01', '02', '03', '04', '05', '06', '07', '08', '09', '0a', '0b', '0c', '0d', '0e', '0f', '10', '11', '12', '13', '14', '15', '16', '17', '18', '19', '1a', '1b', '1c', '1d', '1e', '1f', '20', '21', '22', '23', '24', '25', '26', '27', '28', '29', '2a', '2b', '2c', '2d', '2e', '2f', '30', '31', '32', '33', '34', '35', '36', '37', '38', '39', '3a', '3b', '3c', '3d', '3e', '3f', '40', '41', '42', '43', '44', '45', '46', '47', '48', '49', '4a', '4b', '4c', '4d', '4e', '4f', '50', '51', '52', '53', '54', '55', '56', '57', '58', '59', '5a', '5b', '5c', '5d', '5e', '5f', '60', '61', '62', '63', '64', '65', '66', '67', '68', '69', '6a', '6b', '6c', '6d', '6e', '6f', '70', '71', '72', '73', '74', '75', '76', '77', '78', '79', '7a', '7b', '7c', '7d', '7e', '7f', '80', '81', '82', '83', '84', '85', '86', '87', '88', '89', '8a', '8b', '8c', '8d', '8e', '8f', '90', '91', '92', '93', '94', '95', '96', '97', '98', '99', '9a', '9b', '9c', '9d', '9e', '9f', 'a0', 'a1', 'a2', 'a3', 'a4', 'a5', 'a6', 'a7', 'a8', 'a9', 'aa', 'ab', 'ac', 'ad', 'ae', 'af', 'b0', 'b1', 'b2', 'b3', 'b4', 'b5', 'b6', 'b7', 'b8', 'b9', 'ba', 'bb', 'bc', 'bd', 'be', 'bf', 'c0', 'c1', 'c2', 'c3', 'c4', 'c5', 'c6', 'c7', 'c8', 'c9', 'ca', 'cb', 'cc', 'cd', 'ce', 'cf', 'd0', 'd1', 'd2', 'd3', 'd4', 'd5', 'd6', 'd7', 'd8', 'd9', 'da', 'db', 'dc', 'dd', 'de', 'df', 'e0', 'e1', 'e2', 'e3', 'e4', 'e5', 'e6', 'e7', 'e8', 'e9', 'ea', 'eb', 'ec', 'ed', 'ee', 'ef', 'f0', 'f1', 'f2', 'f3', 'f4', 'f5', 'f6', 'f7', 'f8', 'f9', 'fa', 'fb', 'fc', 'fd', 'fe', 'ff'];
let _seed = 1234567;
const DEG2RAD = Math.PI / 180;
exports.DEG2RAD = DEG2RAD;
const RAD2DEG = 180 / Math.PI; // http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136

exports.RAD2DEG = RAD2DEG;

function generateUUID() {
  const d0 = Math.random() * 0xffffffff | 0;
  const d1 = Math.random() * 0xffffffff | 0;
  const d2 = Math.random() * 0xffffffff | 0;
  const d3 = Math.random() * 0xffffffff | 0;
  const uuid = _lut[d0 & 0xff] + _lut[d0 >> 8 & 0xff] + _lut[d0 >> 16 & 0xff] + _lut[d0 >> 24 & 0xff] + '-' + _lut[d1 & 0xff] + _lut[d1 >> 8 & 0xff] + '-' + _lut[d1 >> 16 & 0x0f | 0x40] + _lut[d1 >> 24 & 0xff] + '-' + _lut[d2 & 0x3f | 0x80] + _lut[d2 >> 8 & 0xff] + '-' + _lut[d2 >> 16 & 0xff] + _lut[d2 >> 24 & 0xff] + _lut[d3 & 0xff] + _lut[d3 >> 8 & 0xff] + _lut[d3 >> 16 & 0xff] + _lut[d3 >> 24 & 0xff]; // .toLowerCase() here flattens concatenated strings to save heap memory space.

  return uuid.toLowerCase();
}

function clamp(value, min, max) {
  return Math.max(min, Math.min(max, value));
} // compute euclidean modulo of m % n
// https://en.wikipedia.org/wiki/Modulo_operation


function euclideanModulo(n, m) {
  return (n % m + m) % m;
} // Linear mapping from range <a1, a2> to range <b1, b2>


function mapLinear(x, a1, a2, b1, b2) {
  return b1 + (x - a1) * (b2 - b1) / (a2 - a1);
} // https://www.gamedev.net/tutorials/programming/general-and-gameplay-programming/inverse-lerp-a-super-useful-yet-often-overlooked-function-r5230/


function inverseLerp(x, y, value) {
  if (x !== y) {
    return (value - x) / (y - x);
  } else {
    return 0;
  }
} // https://en.wikipedia.org/wiki/Linear_interpolation


function lerp(x, y, t) {
  return (1 - t) * x + t * y;
} // http://www.rorydriscoll.com/2016/03/07/frame-rate-independent-damping-using-lerp/


function damp(x, y, lambda, dt) {
  return lerp(x, y, 1 - Math.exp(-lambda * dt));
} // https://www.desmos.com/calculator/vcsjnyz7x4


function pingpong(x, length = 1) {
  return length - Math.abs(euclideanModulo(x, length * 2) - length);
} // http://en.wikipedia.org/wiki/Smoothstep


function smoothstep(x, min, max) {
  if (x <= min) return 0;
  if (x >= max) return 1;
  x = (x - min) / (max - min);
  return x * x * (3 - 2 * x);
}

function smootherstep(x, min, max) {
  if (x <= min) return 0;
  if (x >= max) return 1;
  x = (x - min) / (max - min);
  return x * x * x * (x * (x * 6 - 15) + 10);
} // Random integer from <low, high> interval


function randInt(low, high) {
  return low + Math.floor(Math.random() * (high - low + 1));
} // Random float from <low, high> interval


function randFloat(low, high) {
  return low + Math.random() * (high - low);
} // Random float from <-range/2, range/2> interval


function randFloatSpread(range) {
  return range * (0.5 - Math.random());
} // Deterministic pseudo-random float in the interval [ 0, 1 ]


function seededRandom(s) {
  if (s !== undefined) _seed = s; // Mulberry32 generator

  let t = _seed += 0x6D2B79F5;
  t = Math.imul(t ^ t >>> 15, t | 1);
  t ^= t + Math.imul(t ^ t >>> 7, t | 61);
  return ((t ^ t >>> 14) >>> 0) / 4294967296;
}

function degToRad(degrees) {
  return degrees * DEG2RAD;
}

function radToDeg(radians) {
  return radians * RAD2DEG;
}

function isPowerOfTwo(value) {
  return (value & value - 1) === 0 && value !== 0;
}

function ceilPowerOfTwo(value) {
  return Math.pow(2, Math.ceil(Math.log(value) / Math.LN2));
}

function floorPowerOfTwo(value) {
  return Math.pow(2, Math.floor(Math.log(value) / Math.LN2));
}

function setQuaternionFromProperEuler(q, a, b, c, order) {
  // Intrinsic Proper Euler Angles - see https://en.wikipedia.org/wiki/Euler_angles
  // rotations are applied to the axes in the order specified by 'order'
  // rotation by angle 'a' is applied first, then by angle 'b', then by angle 'c'
  // angles are in radians
  const cos = Math.cos;
  const sin = Math.sin;
  const c2 = cos(b / 2);
  const s2 = sin(b / 2);
  const c13 = cos((a + c) / 2);
  const s13 = sin((a + c) / 2);
  const c1_3 = cos((a - c) / 2);
  const s1_3 = sin((a - c) / 2);
  const c3_1 = cos((c - a) / 2);
  const s3_1 = sin((c - a) / 2);

  switch (order) {
    case 'XYX':
      q.set(c2 * s13, s2 * c1_3, s2 * s1_3, c2 * c13);
      break;

    case 'YZY':
      q.set(s2 * s1_3, c2 * s13, s2 * c1_3, c2 * c13);
      break;

    case 'ZXZ':
      q.set(s2 * c1_3, s2 * s1_3, c2 * s13, c2 * c13);
      break;

    case 'XZX':
      q.set(c2 * s13, s2 * s3_1, s2 * c3_1, c2 * c13);
      break;

    case 'YXY':
      q.set(s2 * c3_1, c2 * s13, s2 * s3_1, c2 * c13);
      break;

    case 'ZYZ':
      q.set(s2 * s3_1, s2 * c3_1, c2 * s13, c2 * c13);
      break;

    default:
      console.warn('THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: ' + order);
  }
}

function denormalize(value, array) {
  switch (array.constructor) {
    case Float32Array:
      return value;

    case Uint32Array:
      return value / 4294967295.0;

    case Uint16Array:
      return value / 65535.0;

    case Uint8Array:
      return value / 255.0;

    case Int32Array:
      return Math.max(value / 2147483647.0, -1.0);

    case Int16Array:
      return Math.max(value / 32767.0, -1.0);

    case Int8Array:
      return Math.max(value / 127.0, -1.0);

    default:
      throw new Error('Invalid component type.');
  }
}

function normalize(value, array) {
  switch (array.constructor) {
    case Float32Array:
      return value;

    case Uint32Array:
      return Math.round(value * 4294967295.0);

    case Uint16Array:
      return Math.round(value * 65535.0);

    case Uint8Array:
      return Math.round(value * 255.0);

    case Int32Array:
      return Math.round(value * 2147483647.0);

    case Int16Array:
      return Math.round(value * 32767.0);

    case Int8Array:
      return Math.round(value * 127.0);

    default:
      throw new Error('Invalid component type.');
  }
}

const MathUtils = {
  DEG2RAD: DEG2RAD,
  RAD2DEG: RAD2DEG,
  generateUUID: generateUUID,
  clamp: clamp,
  euclideanModulo: euclideanModulo,
  mapLinear: mapLinear,
  inverseLerp: inverseLerp,
  lerp: lerp,
  damp: damp,
  pingpong: pingpong,
  smoothstep: smoothstep,
  smootherstep: smootherstep,
  randInt: randInt,
  randFloat: randFloat,
  randFloatSpread: randFloatSpread,
  seededRandom: seededRandom,
  degToRad: degToRad,
  radToDeg: radToDeg,
  isPowerOfTwo: isPowerOfTwo,
  ceilPowerOfTwo: ceilPowerOfTwo,
  floorPowerOfTwo: floorPowerOfTwo,
  setQuaternionFromProperEuler: setQuaternionFromProperEuler,
  normalize: normalize,
  denormalize: denormalize
};
exports.MathUtils = MathUtils;

},{}],169:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Matrix3 = void 0;

class Matrix3 {
  constructor(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
    Matrix3.prototype.isMatrix3 = true;
    this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1];

    if (n11 !== undefined) {
      this.set(n11, n12, n13, n21, n22, n23, n31, n32, n33);
    }
  }

  set(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
    const te = this.elements;
    te[0] = n11;
    te[1] = n21;
    te[2] = n31;
    te[3] = n12;
    te[4] = n22;
    te[5] = n32;
    te[6] = n13;
    te[7] = n23;
    te[8] = n33;
    return this;
  }

  identity() {
    this.set(1, 0, 0, 0, 1, 0, 0, 0, 1);
    return this;
  }

  copy(m) {
    const te = this.elements;
    const me = m.elements;
    te[0] = me[0];
    te[1] = me[1];
    te[2] = me[2];
    te[3] = me[3];
    te[4] = me[4];
    te[5] = me[5];
    te[6] = me[6];
    te[7] = me[7];
    te[8] = me[8];
    return this;
  }

  extractBasis(xAxis, yAxis, zAxis) {
    xAxis.setFromMatrix3Column(this, 0);
    yAxis.setFromMatrix3Column(this, 1);
    zAxis.setFromMatrix3Column(this, 2);
    return this;
  }

  setFromMatrix4(m) {
    const me = m.elements;
    this.set(me[0], me[4], me[8], me[1], me[5], me[9], me[2], me[6], me[10]);
    return this;
  }

  multiply(m) {
    return this.multiplyMatrices(this, m);
  }

  premultiply(m) {
    return this.multiplyMatrices(m, this);
  }

  multiplyMatrices(a, b) {
    const ae = a.elements;
    const be = b.elements;
    const te = this.elements;
    const a11 = ae[0],
          a12 = ae[3],
          a13 = ae[6];
    const a21 = ae[1],
          a22 = ae[4],
          a23 = ae[7];
    const a31 = ae[2],
          a32 = ae[5],
          a33 = ae[8];
    const b11 = be[0],
          b12 = be[3],
          b13 = be[6];
    const b21 = be[1],
          b22 = be[4],
          b23 = be[7];
    const b31 = be[2],
          b32 = be[5],
          b33 = be[8];
    te[0] = a11 * b11 + a12 * b21 + a13 * b31;
    te[3] = a11 * b12 + a12 * b22 + a13 * b32;
    te[6] = a11 * b13 + a12 * b23 + a13 * b33;
    te[1] = a21 * b11 + a22 * b21 + a23 * b31;
    te[4] = a21 * b12 + a22 * b22 + a23 * b32;
    te[7] = a21 * b13 + a22 * b23 + a23 * b33;
    te[2] = a31 * b11 + a32 * b21 + a33 * b31;
    te[5] = a31 * b12 + a32 * b22 + a33 * b32;
    te[8] = a31 * b13 + a32 * b23 + a33 * b33;
    return this;
  }

  multiplyScalar(s) {
    const te = this.elements;
    te[0] *= s;
    te[3] *= s;
    te[6] *= s;
    te[1] *= s;
    te[4] *= s;
    te[7] *= s;
    te[2] *= s;
    te[5] *= s;
    te[8] *= s;
    return this;
  }

  determinant() {
    const te = this.elements;
    const a = te[0],
          b = te[1],
          c = te[2],
          d = te[3],
          e = te[4],
          f = te[5],
          g = te[6],
          h = te[7],
          i = te[8];
    return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;
  }

  invert() {
    const te = this.elements,
          n11 = te[0],
          n21 = te[1],
          n31 = te[2],
          n12 = te[3],
          n22 = te[4],
          n32 = te[5],
          n13 = te[6],
          n23 = te[7],
          n33 = te[8],
          t11 = n33 * n22 - n32 * n23,
          t12 = n32 * n13 - n33 * n12,
          t13 = n23 * n12 - n22 * n13,
          det = n11 * t11 + n21 * t12 + n31 * t13;
    if (det === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    const detInv = 1 / det;
    te[0] = t11 * detInv;
    te[1] = (n31 * n23 - n33 * n21) * detInv;
    te[2] = (n32 * n21 - n31 * n22) * detInv;
    te[3] = t12 * detInv;
    te[4] = (n33 * n11 - n31 * n13) * detInv;
    te[5] = (n31 * n12 - n32 * n11) * detInv;
    te[6] = t13 * detInv;
    te[7] = (n21 * n13 - n23 * n11) * detInv;
    te[8] = (n22 * n11 - n21 * n12) * detInv;
    return this;
  }

  transpose() {
    let tmp;
    const m = this.elements;
    tmp = m[1];
    m[1] = m[3];
    m[3] = tmp;
    tmp = m[2];
    m[2] = m[6];
    m[6] = tmp;
    tmp = m[5];
    m[5] = m[7];
    m[7] = tmp;
    return this;
  }

  getNormalMatrix(matrix4) {
    return this.setFromMatrix4(matrix4).invert().transpose();
  }

  transposeIntoArray(r) {
    const m = this.elements;
    r[0] = m[0];
    r[1] = m[3];
    r[2] = m[6];
    r[3] = m[1];
    r[4] = m[4];
    r[5] = m[7];
    r[6] = m[2];
    r[7] = m[5];
    r[8] = m[8];
    return this;
  }

  setUvTransform(tx, ty, sx, sy, rotation, cx, cy) {
    const c = Math.cos(rotation);
    const s = Math.sin(rotation);
    this.set(sx * c, sx * s, -sx * (c * cx + s * cy) + cx + tx, -sy * s, sy * c, -sy * (-s * cx + c * cy) + cy + ty, 0, 0, 1);
    return this;
  } //


  scale(sx, sy) {
    this.premultiply(_m3.makeScale(sx, sy));
    return this;
  }

  rotate(theta) {
    this.premultiply(_m3.makeRotation(-theta));
    return this;
  }

  translate(tx, ty) {
    this.premultiply(_m3.makeTranslation(tx, ty));
    return this;
  } // for 2D Transforms


  makeTranslation(x, y) {
    if (x.isVector2) {
      this.set(1, 0, x.x, 0, 1, x.y, 0, 0, 1);
    } else {
      this.set(1, 0, x, 0, 1, y, 0, 0, 1);
    }

    return this;
  }

  makeRotation(theta) {
    // counterclockwise
    const c = Math.cos(theta);
    const s = Math.sin(theta);
    this.set(c, -s, 0, s, c, 0, 0, 0, 1);
    return this;
  }

  makeScale(x, y) {
    this.set(x, 0, 0, 0, y, 0, 0, 0, 1);
    return this;
  } //


  equals(matrix) {
    const te = this.elements;
    const me = matrix.elements;

    for (let i = 0; i < 9; i++) {
      if (te[i] !== me[i]) return false;
    }

    return true;
  }

  fromArray(array, offset = 0) {
    for (let i = 0; i < 9; i++) {
      this.elements[i] = array[i + offset];
    }

    return this;
  }

  toArray(array = [], offset = 0) {
    const te = this.elements;
    array[offset] = te[0];
    array[offset + 1] = te[1];
    array[offset + 2] = te[2];
    array[offset + 3] = te[3];
    array[offset + 4] = te[4];
    array[offset + 5] = te[5];
    array[offset + 6] = te[6];
    array[offset + 7] = te[7];
    array[offset + 8] = te[8];
    return array;
  }

  clone() {
    return new this.constructor().fromArray(this.elements);
  }

}

exports.Matrix3 = Matrix3;

const _m3 = /*@__PURE__*/new Matrix3();

},{}],170:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Matrix4 = void 0;

var _constants = require("../constants.js");

var _Vector = require("./Vector3.js");

class Matrix4 {
  constructor(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
    Matrix4.prototype.isMatrix4 = true;
    this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];

    if (n11 !== undefined) {
      this.set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44);
    }
  }

  set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
    const te = this.elements;
    te[0] = n11;
    te[4] = n12;
    te[8] = n13;
    te[12] = n14;
    te[1] = n21;
    te[5] = n22;
    te[9] = n23;
    te[13] = n24;
    te[2] = n31;
    te[6] = n32;
    te[10] = n33;
    te[14] = n34;
    te[3] = n41;
    te[7] = n42;
    te[11] = n43;
    te[15] = n44;
    return this;
  }

  identity() {
    this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
    return this;
  }

  clone() {
    return new Matrix4().fromArray(this.elements);
  }

  copy(m) {
    const te = this.elements;
    const me = m.elements;
    te[0] = me[0];
    te[1] = me[1];
    te[2] = me[2];
    te[3] = me[3];
    te[4] = me[4];
    te[5] = me[5];
    te[6] = me[6];
    te[7] = me[7];
    te[8] = me[8];
    te[9] = me[9];
    te[10] = me[10];
    te[11] = me[11];
    te[12] = me[12];
    te[13] = me[13];
    te[14] = me[14];
    te[15] = me[15];
    return this;
  }

  copyPosition(m) {
    const te = this.elements,
          me = m.elements;
    te[12] = me[12];
    te[13] = me[13];
    te[14] = me[14];
    return this;
  }

  setFromMatrix3(m) {
    const me = m.elements;
    this.set(me[0], me[3], me[6], 0, me[1], me[4], me[7], 0, me[2], me[5], me[8], 0, 0, 0, 0, 1);
    return this;
  }

  extractBasis(xAxis, yAxis, zAxis) {
    xAxis.setFromMatrixColumn(this, 0);
    yAxis.setFromMatrixColumn(this, 1);
    zAxis.setFromMatrixColumn(this, 2);
    return this;
  }

  makeBasis(xAxis, yAxis, zAxis) {
    this.set(xAxis.x, yAxis.x, zAxis.x, 0, xAxis.y, yAxis.y, zAxis.y, 0, xAxis.z, yAxis.z, zAxis.z, 0, 0, 0, 0, 1);
    return this;
  }

  extractRotation(m) {
    // this method does not support reflection matrices
    const te = this.elements;
    const me = m.elements;

    const scaleX = 1 / _v1.setFromMatrixColumn(m, 0).length();

    const scaleY = 1 / _v1.setFromMatrixColumn(m, 1).length();

    const scaleZ = 1 / _v1.setFromMatrixColumn(m, 2).length();

    te[0] = me[0] * scaleX;
    te[1] = me[1] * scaleX;
    te[2] = me[2] * scaleX;
    te[3] = 0;
    te[4] = me[4] * scaleY;
    te[5] = me[5] * scaleY;
    te[6] = me[6] * scaleY;
    te[7] = 0;
    te[8] = me[8] * scaleZ;
    te[9] = me[9] * scaleZ;
    te[10] = me[10] * scaleZ;
    te[11] = 0;
    te[12] = 0;
    te[13] = 0;
    te[14] = 0;
    te[15] = 1;
    return this;
  }

  makeRotationFromEuler(euler) {
    const te = this.elements;
    const x = euler.x,
          y = euler.y,
          z = euler.z;
    const a = Math.cos(x),
          b = Math.sin(x);
    const c = Math.cos(y),
          d = Math.sin(y);
    const e = Math.cos(z),
          f = Math.sin(z);

    if (euler.order === 'XYZ') {
      const ae = a * e,
            af = a * f,
            be = b * e,
            bf = b * f;
      te[0] = c * e;
      te[4] = -c * f;
      te[8] = d;
      te[1] = af + be * d;
      te[5] = ae - bf * d;
      te[9] = -b * c;
      te[2] = bf - ae * d;
      te[6] = be + af * d;
      te[10] = a * c;
    } else if (euler.order === 'YXZ') {
      const ce = c * e,
            cf = c * f,
            de = d * e,
            df = d * f;
      te[0] = ce + df * b;
      te[4] = de * b - cf;
      te[8] = a * d;
      te[1] = a * f;
      te[5] = a * e;
      te[9] = -b;
      te[2] = cf * b - de;
      te[6] = df + ce * b;
      te[10] = a * c;
    } else if (euler.order === 'ZXY') {
      const ce = c * e,
            cf = c * f,
            de = d * e,
            df = d * f;
      te[0] = ce - df * b;
      te[4] = -a * f;
      te[8] = de + cf * b;
      te[1] = cf + de * b;
      te[5] = a * e;
      te[9] = df - ce * b;
      te[2] = -a * d;
      te[6] = b;
      te[10] = a * c;
    } else if (euler.order === 'ZYX') {
      const ae = a * e,
            af = a * f,
            be = b * e,
            bf = b * f;
      te[0] = c * e;
      te[4] = be * d - af;
      te[8] = ae * d + bf;
      te[1] = c * f;
      te[5] = bf * d + ae;
      te[9] = af * d - be;
      te[2] = -d;
      te[6] = b * c;
      te[10] = a * c;
    } else if (euler.order === 'YZX') {
      const ac = a * c,
            ad = a * d,
            bc = b * c,
            bd = b * d;
      te[0] = c * e;
      te[4] = bd - ac * f;
      te[8] = bc * f + ad;
      te[1] = f;
      te[5] = a * e;
      te[9] = -b * e;
      te[2] = -d * e;
      te[6] = ad * f + bc;
      te[10] = ac - bd * f;
    } else if (euler.order === 'XZY') {
      const ac = a * c,
            ad = a * d,
            bc = b * c,
            bd = b * d;
      te[0] = c * e;
      te[4] = -f;
      te[8] = d * e;
      te[1] = ac * f + bd;
      te[5] = a * e;
      te[9] = ad * f - bc;
      te[2] = bc * f - ad;
      te[6] = b * e;
      te[10] = bd * f + ac;
    } // bottom row


    te[3] = 0;
    te[7] = 0;
    te[11] = 0; // last column

    te[12] = 0;
    te[13] = 0;
    te[14] = 0;
    te[15] = 1;
    return this;
  }

  makeRotationFromQuaternion(q) {
    return this.compose(_zero, q, _one);
  }

  lookAt(eye, target, up) {
    const te = this.elements;

    _z.subVectors(eye, target);

    if (_z.lengthSq() === 0) {
      // eye and target are in the same position
      _z.z = 1;
    }

    _z.normalize();

    _x.crossVectors(up, _z);

    if (_x.lengthSq() === 0) {
      // up and z are parallel
      if (Math.abs(up.z) === 1) {
        _z.x += 0.0001;
      } else {
        _z.z += 0.0001;
      }

      _z.normalize();

      _x.crossVectors(up, _z);
    }

    _x.normalize();

    _y.crossVectors(_z, _x);

    te[0] = _x.x;
    te[4] = _y.x;
    te[8] = _z.x;
    te[1] = _x.y;
    te[5] = _y.y;
    te[9] = _z.y;
    te[2] = _x.z;
    te[6] = _y.z;
    te[10] = _z.z;
    return this;
  }

  multiply(m) {
    return this.multiplyMatrices(this, m);
  }

  premultiply(m) {
    return this.multiplyMatrices(m, this);
  }

  multiplyMatrices(a, b) {
    const ae = a.elements;
    const be = b.elements;
    const te = this.elements;
    const a11 = ae[0],
          a12 = ae[4],
          a13 = ae[8],
          a14 = ae[12];
    const a21 = ae[1],
          a22 = ae[5],
          a23 = ae[9],
          a24 = ae[13];
    const a31 = ae[2],
          a32 = ae[6],
          a33 = ae[10],
          a34 = ae[14];
    const a41 = ae[3],
          a42 = ae[7],
          a43 = ae[11],
          a44 = ae[15];
    const b11 = be[0],
          b12 = be[4],
          b13 = be[8],
          b14 = be[12];
    const b21 = be[1],
          b22 = be[5],
          b23 = be[9],
          b24 = be[13];
    const b31 = be[2],
          b32 = be[6],
          b33 = be[10],
          b34 = be[14];
    const b41 = be[3],
          b42 = be[7],
          b43 = be[11],
          b44 = be[15];
    te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
    te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
    te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
    te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
    te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
    te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
    te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
    te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
    te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
    te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
    te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
    te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
    te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
    te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
    te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
    te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
    return this;
  }

  multiplyScalar(s) {
    const te = this.elements;
    te[0] *= s;
    te[4] *= s;
    te[8] *= s;
    te[12] *= s;
    te[1] *= s;
    te[5] *= s;
    te[9] *= s;
    te[13] *= s;
    te[2] *= s;
    te[6] *= s;
    te[10] *= s;
    te[14] *= s;
    te[3] *= s;
    te[7] *= s;
    te[11] *= s;
    te[15] *= s;
    return this;
  }

  determinant() {
    const te = this.elements;
    const n11 = te[0],
          n12 = te[4],
          n13 = te[8],
          n14 = te[12];
    const n21 = te[1],
          n22 = te[5],
          n23 = te[9],
          n24 = te[13];
    const n31 = te[2],
          n32 = te[6],
          n33 = te[10],
          n34 = te[14];
    const n41 = te[3],
          n42 = te[7],
          n43 = te[11],
          n44 = te[15]; //TODO: make this more efficient
    //( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )

    return n41 * (+n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34) + n42 * (+n11 * n23 * n34 - n11 * n24 * n33 + n14 * n21 * n33 - n13 * n21 * n34 + n13 * n24 * n31 - n14 * n23 * n31) + n43 * (+n11 * n24 * n32 - n11 * n22 * n34 - n14 * n21 * n32 + n12 * n21 * n34 + n14 * n22 * n31 - n12 * n24 * n31) + n44 * (-n13 * n22 * n31 - n11 * n23 * n32 + n11 * n22 * n33 + n13 * n21 * n32 - n12 * n21 * n33 + n12 * n23 * n31);
  }

  transpose() {
    const te = this.elements;
    let tmp;
    tmp = te[1];
    te[1] = te[4];
    te[4] = tmp;
    tmp = te[2];
    te[2] = te[8];
    te[8] = tmp;
    tmp = te[6];
    te[6] = te[9];
    te[9] = tmp;
    tmp = te[3];
    te[3] = te[12];
    te[12] = tmp;
    tmp = te[7];
    te[7] = te[13];
    te[13] = tmp;
    tmp = te[11];
    te[11] = te[14];
    te[14] = tmp;
    return this;
  }

  setPosition(x, y, z) {
    const te = this.elements;

    if (x.isVector3) {
      te[12] = x.x;
      te[13] = x.y;
      te[14] = x.z;
    } else {
      te[12] = x;
      te[13] = y;
      te[14] = z;
    }

    return this;
  }

  invert() {
    // based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
    const te = this.elements,
          n11 = te[0],
          n21 = te[1],
          n31 = te[2],
          n41 = te[3],
          n12 = te[4],
          n22 = te[5],
          n32 = te[6],
          n42 = te[7],
          n13 = te[8],
          n23 = te[9],
          n33 = te[10],
          n43 = te[11],
          n14 = te[12],
          n24 = te[13],
          n34 = te[14],
          n44 = te[15],
          t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,
          t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,
          t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,
          t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
    const det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;
    if (det === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const detInv = 1 / det;
    te[0] = t11 * detInv;
    te[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv;
    te[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv;
    te[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv;
    te[4] = t12 * detInv;
    te[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv;
    te[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv;
    te[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv;
    te[8] = t13 * detInv;
    te[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv;
    te[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv;
    te[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv;
    te[12] = t14 * detInv;
    te[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv;
    te[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv;
    te[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv;
    return this;
  }

  scale(v) {
    const te = this.elements;
    const x = v.x,
          y = v.y,
          z = v.z;
    te[0] *= x;
    te[4] *= y;
    te[8] *= z;
    te[1] *= x;
    te[5] *= y;
    te[9] *= z;
    te[2] *= x;
    te[6] *= y;
    te[10] *= z;
    te[3] *= x;
    te[7] *= y;
    te[11] *= z;
    return this;
  }

  getMaxScaleOnAxis() {
    const te = this.elements;
    const scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];
    const scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];
    const scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];
    return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));
  }

  makeTranslation(x, y, z) {
    if (x.isVector3) {
      this.set(1, 0, 0, x.x, 0, 1, 0, x.y, 0, 0, 1, x.z, 0, 0, 0, 1);
    } else {
      this.set(1, 0, 0, x, 0, 1, 0, y, 0, 0, 1, z, 0, 0, 0, 1);
    }

    return this;
  }

  makeRotationX(theta) {
    const c = Math.cos(theta),
          s = Math.sin(theta);
    this.set(1, 0, 0, 0, 0, c, -s, 0, 0, s, c, 0, 0, 0, 0, 1);
    return this;
  }

  makeRotationY(theta) {
    const c = Math.cos(theta),
          s = Math.sin(theta);
    this.set(c, 0, s, 0, 0, 1, 0, 0, -s, 0, c, 0, 0, 0, 0, 1);
    return this;
  }

  makeRotationZ(theta) {
    const c = Math.cos(theta),
          s = Math.sin(theta);
    this.set(c, -s, 0, 0, s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
    return this;
  }

  makeRotationAxis(axis, angle) {
    // Based on http://www.gamedev.net/reference/articles/article1199.asp
    const c = Math.cos(angle);
    const s = Math.sin(angle);
    const t = 1 - c;
    const x = axis.x,
          y = axis.y,
          z = axis.z;
    const tx = t * x,
          ty = t * y;
    this.set(tx * x + c, tx * y - s * z, tx * z + s * y, 0, tx * y + s * z, ty * y + c, ty * z - s * x, 0, tx * z - s * y, ty * z + s * x, t * z * z + c, 0, 0, 0, 0, 1);
    return this;
  }

  makeScale(x, y, z) {
    this.set(x, 0, 0, 0, 0, y, 0, 0, 0, 0, z, 0, 0, 0, 0, 1);
    return this;
  }

  makeShear(xy, xz, yx, yz, zx, zy) {
    this.set(1, yx, zx, 0, xy, 1, zy, 0, xz, yz, 1, 0, 0, 0, 0, 1);
    return this;
  }

  compose(position, quaternion, scale) {
    const te = this.elements;
    const x = quaternion._x,
          y = quaternion._y,
          z = quaternion._z,
          w = quaternion._w;
    const x2 = x + x,
          y2 = y + y,
          z2 = z + z;
    const xx = x * x2,
          xy = x * y2,
          xz = x * z2;
    const yy = y * y2,
          yz = y * z2,
          zz = z * z2;
    const wx = w * x2,
          wy = w * y2,
          wz = w * z2;
    const sx = scale.x,
          sy = scale.y,
          sz = scale.z;
    te[0] = (1 - (yy + zz)) * sx;
    te[1] = (xy + wz) * sx;
    te[2] = (xz - wy) * sx;
    te[3] = 0;
    te[4] = (xy - wz) * sy;
    te[5] = (1 - (xx + zz)) * sy;
    te[6] = (yz + wx) * sy;
    te[7] = 0;
    te[8] = (xz + wy) * sz;
    te[9] = (yz - wx) * sz;
    te[10] = (1 - (xx + yy)) * sz;
    te[11] = 0;
    te[12] = position.x;
    te[13] = position.y;
    te[14] = position.z;
    te[15] = 1;
    return this;
  }

  decompose(position, quaternion, scale) {
    const te = this.elements;

    let sx = _v1.set(te[0], te[1], te[2]).length();

    const sy = _v1.set(te[4], te[5], te[6]).length();

    const sz = _v1.set(te[8], te[9], te[10]).length(); // if determine is negative, we need to invert one scale


    const det = this.determinant();
    if (det < 0) sx = -sx;
    position.x = te[12];
    position.y = te[13];
    position.z = te[14]; // scale the rotation part

    _m1.copy(this);

    const invSX = 1 / sx;
    const invSY = 1 / sy;
    const invSZ = 1 / sz;
    _m1.elements[0] *= invSX;
    _m1.elements[1] *= invSX;
    _m1.elements[2] *= invSX;
    _m1.elements[4] *= invSY;
    _m1.elements[5] *= invSY;
    _m1.elements[6] *= invSY;
    _m1.elements[8] *= invSZ;
    _m1.elements[9] *= invSZ;
    _m1.elements[10] *= invSZ;
    quaternion.setFromRotationMatrix(_m1);
    scale.x = sx;
    scale.y = sy;
    scale.z = sz;
    return this;
  }

  makePerspective(left, right, top, bottom, near, far, coordinateSystem = _constants.WebGLCoordinateSystem) {
    const te = this.elements;
    const x = 2 * near / (right - left);
    const y = 2 * near / (top - bottom);
    const a = (right + left) / (right - left);
    const b = (top + bottom) / (top - bottom);
    let c, d;

    if (coordinateSystem === _constants.WebGLCoordinateSystem) {
      c = -(far + near) / (far - near);
      d = -2 * far * near / (far - near);
    } else if (coordinateSystem === _constants.WebGPUCoordinateSystem) {
      c = -far / (far - near);
      d = -far * near / (far - near);
    } else {
      throw new Error('THREE.Matrix4.makePerspective(): Invalid coordinate system: ' + coordinateSystem);
    }

    te[0] = x;
    te[4] = 0;
    te[8] = a;
    te[12] = 0;
    te[1] = 0;
    te[5] = y;
    te[9] = b;
    te[13] = 0;
    te[2] = 0;
    te[6] = 0;
    te[10] = c;
    te[14] = d;
    te[3] = 0;
    te[7] = 0;
    te[11] = -1;
    te[15] = 0;
    return this;
  }

  makeOrthographic(left, right, top, bottom, near, far, coordinateSystem = _constants.WebGLCoordinateSystem) {
    const te = this.elements;
    const w = 1.0 / (right - left);
    const h = 1.0 / (top - bottom);
    const p = 1.0 / (far - near);
    const x = (right + left) * w;
    const y = (top + bottom) * h;
    let z, zInv;

    if (coordinateSystem === _constants.WebGLCoordinateSystem) {
      z = (far + near) * p;
      zInv = -2 * p;
    } else if (coordinateSystem === _constants.WebGPUCoordinateSystem) {
      z = near * p;
      zInv = -1 * p;
    } else {
      throw new Error('THREE.Matrix4.makeOrthographic(): Invalid coordinate system: ' + coordinateSystem);
    }

    te[0] = 2 * w;
    te[4] = 0;
    te[8] = 0;
    te[12] = -x;
    te[1] = 0;
    te[5] = 2 * h;
    te[9] = 0;
    te[13] = -y;
    te[2] = 0;
    te[6] = 0;
    te[10] = zInv;
    te[14] = -z;
    te[3] = 0;
    te[7] = 0;
    te[11] = 0;
    te[15] = 1;
    return this;
  }

  equals(matrix) {
    const te = this.elements;
    const me = matrix.elements;

    for (let i = 0; i < 16; i++) {
      if (te[i] !== me[i]) return false;
    }

    return true;
  }

  fromArray(array, offset = 0) {
    for (let i = 0; i < 16; i++) {
      this.elements[i] = array[i + offset];
    }

    return this;
  }

  toArray(array = [], offset = 0) {
    const te = this.elements;
    array[offset] = te[0];
    array[offset + 1] = te[1];
    array[offset + 2] = te[2];
    array[offset + 3] = te[3];
    array[offset + 4] = te[4];
    array[offset + 5] = te[5];
    array[offset + 6] = te[6];
    array[offset + 7] = te[7];
    array[offset + 8] = te[8];
    array[offset + 9] = te[9];
    array[offset + 10] = te[10];
    array[offset + 11] = te[11];
    array[offset + 12] = te[12];
    array[offset + 13] = te[13];
    array[offset + 14] = te[14];
    array[offset + 15] = te[15];
    return array;
  }

}

exports.Matrix4 = Matrix4;

const _v1 = /*@__PURE__*/new _Vector.Vector3();

const _m1 = /*@__PURE__*/new Matrix4();

const _zero = /*@__PURE__*/new _Vector.Vector3(0, 0, 0);

const _one = /*@__PURE__*/new _Vector.Vector3(1, 1, 1);

const _x = /*@__PURE__*/new _Vector.Vector3();

const _y = /*@__PURE__*/new _Vector.Vector3();

const _z = /*@__PURE__*/new _Vector.Vector3();

},{"../constants.js":119,"./Vector3.js":175}],171:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Quaternion = void 0;

var MathUtils = _interopRequireWildcard(require("./MathUtils.js"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

class Quaternion {
  constructor(x = 0, y = 0, z = 0, w = 1) {
    this.isQuaternion = true;
    this._x = x;
    this._y = y;
    this._z = z;
    this._w = w;
  }

  static slerpFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t) {
    // fuzz-free, array-based Quaternion SLERP operation
    let x0 = src0[srcOffset0 + 0],
        y0 = src0[srcOffset0 + 1],
        z0 = src0[srcOffset0 + 2],
        w0 = src0[srcOffset0 + 3];
    const x1 = src1[srcOffset1 + 0],
          y1 = src1[srcOffset1 + 1],
          z1 = src1[srcOffset1 + 2],
          w1 = src1[srcOffset1 + 3];

    if (t === 0) {
      dst[dstOffset + 0] = x0;
      dst[dstOffset + 1] = y0;
      dst[dstOffset + 2] = z0;
      dst[dstOffset + 3] = w0;
      return;
    }

    if (t === 1) {
      dst[dstOffset + 0] = x1;
      dst[dstOffset + 1] = y1;
      dst[dstOffset + 2] = z1;
      dst[dstOffset + 3] = w1;
      return;
    }

    if (w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1) {
      let s = 1 - t;
      const cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,
            dir = cos >= 0 ? 1 : -1,
            sqrSin = 1 - cos * cos; // Skip the Slerp for tiny steps to avoid numeric problems:

      if (sqrSin > Number.EPSILON) {
        const sin = Math.sqrt(sqrSin),
              len = Math.atan2(sin, cos * dir);
        s = Math.sin(s * len) / sin;
        t = Math.sin(t * len) / sin;
      }

      const tDir = t * dir;
      x0 = x0 * s + x1 * tDir;
      y0 = y0 * s + y1 * tDir;
      z0 = z0 * s + z1 * tDir;
      w0 = w0 * s + w1 * tDir; // Normalize in case we just did a lerp:

      if (s === 1 - t) {
        const f = 1 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0);
        x0 *= f;
        y0 *= f;
        z0 *= f;
        w0 *= f;
      }
    }

    dst[dstOffset] = x0;
    dst[dstOffset + 1] = y0;
    dst[dstOffset + 2] = z0;
    dst[dstOffset + 3] = w0;
  }

  static multiplyQuaternionsFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1) {
    const x0 = src0[srcOffset0];
    const y0 = src0[srcOffset0 + 1];
    const z0 = src0[srcOffset0 + 2];
    const w0 = src0[srcOffset0 + 3];
    const x1 = src1[srcOffset1];
    const y1 = src1[srcOffset1 + 1];
    const z1 = src1[srcOffset1 + 2];
    const w1 = src1[srcOffset1 + 3];
    dst[dstOffset] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1;
    dst[dstOffset + 1] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1;
    dst[dstOffset + 2] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1;
    dst[dstOffset + 3] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1;
    return dst;
  }

  get x() {
    return this._x;
  }

  set x(value) {
    this._x = value;

    this._onChangeCallback();
  }

  get y() {
    return this._y;
  }

  set y(value) {
    this._y = value;

    this._onChangeCallback();
  }

  get z() {
    return this._z;
  }

  set z(value) {
    this._z = value;

    this._onChangeCallback();
  }

  get w() {
    return this._w;
  }

  set w(value) {
    this._w = value;

    this._onChangeCallback();
  }

  set(x, y, z, w) {
    this._x = x;
    this._y = y;
    this._z = z;
    this._w = w;

    this._onChangeCallback();

    return this;
  }

  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  }

  copy(quaternion) {
    this._x = quaternion.x;
    this._y = quaternion.y;
    this._z = quaternion.z;
    this._w = quaternion.w;

    this._onChangeCallback();

    return this;
  }

  setFromEuler(euler, update) {
    const x = euler._x,
          y = euler._y,
          z = euler._z,
          order = euler._order; // http://www.mathworks.com/matlabcentral/fileexchange/
    // 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
    //	content/SpinCalc.m

    const cos = Math.cos;
    const sin = Math.sin;
    const c1 = cos(x / 2);
    const c2 = cos(y / 2);
    const c3 = cos(z / 2);
    const s1 = sin(x / 2);
    const s2 = sin(y / 2);
    const s3 = sin(z / 2);

    switch (order) {
      case 'XYZ':
        this._x = s1 * c2 * c3 + c1 * s2 * s3;
        this._y = c1 * s2 * c3 - s1 * c2 * s3;
        this._z = c1 * c2 * s3 + s1 * s2 * c3;
        this._w = c1 * c2 * c3 - s1 * s2 * s3;
        break;

      case 'YXZ':
        this._x = s1 * c2 * c3 + c1 * s2 * s3;
        this._y = c1 * s2 * c3 - s1 * c2 * s3;
        this._z = c1 * c2 * s3 - s1 * s2 * c3;
        this._w = c1 * c2 * c3 + s1 * s2 * s3;
        break;

      case 'ZXY':
        this._x = s1 * c2 * c3 - c1 * s2 * s3;
        this._y = c1 * s2 * c3 + s1 * c2 * s3;
        this._z = c1 * c2 * s3 + s1 * s2 * c3;
        this._w = c1 * c2 * c3 - s1 * s2 * s3;
        break;

      case 'ZYX':
        this._x = s1 * c2 * c3 - c1 * s2 * s3;
        this._y = c1 * s2 * c3 + s1 * c2 * s3;
        this._z = c1 * c2 * s3 - s1 * s2 * c3;
        this._w = c1 * c2 * c3 + s1 * s2 * s3;
        break;

      case 'YZX':
        this._x = s1 * c2 * c3 + c1 * s2 * s3;
        this._y = c1 * s2 * c3 + s1 * c2 * s3;
        this._z = c1 * c2 * s3 - s1 * s2 * c3;
        this._w = c1 * c2 * c3 - s1 * s2 * s3;
        break;

      case 'XZY':
        this._x = s1 * c2 * c3 - c1 * s2 * s3;
        this._y = c1 * s2 * c3 - s1 * c2 * s3;
        this._z = c1 * c2 * s3 + s1 * s2 * c3;
        this._w = c1 * c2 * c3 + s1 * s2 * s3;
        break;

      default:
        console.warn('THREE.Quaternion: .setFromEuler() encountered an unknown order: ' + order);
    }

    if (update !== false) this._onChangeCallback();
    return this;
  }

  setFromAxisAngle(axis, angle) {
    // http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm
    // assumes axis is normalized
    const halfAngle = angle / 2,
          s = Math.sin(halfAngle);
    this._x = axis.x * s;
    this._y = axis.y * s;
    this._z = axis.z * s;
    this._w = Math.cos(halfAngle);

    this._onChangeCallback();

    return this;
  }

  setFromRotationMatrix(m) {
    // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm
    // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
    const te = m.elements,
          m11 = te[0],
          m12 = te[4],
          m13 = te[8],
          m21 = te[1],
          m22 = te[5],
          m23 = te[9],
          m31 = te[2],
          m32 = te[6],
          m33 = te[10],
          trace = m11 + m22 + m33;

    if (trace > 0) {
      const s = 0.5 / Math.sqrt(trace + 1.0);
      this._w = 0.25 / s;
      this._x = (m32 - m23) * s;
      this._y = (m13 - m31) * s;
      this._z = (m21 - m12) * s;
    } else if (m11 > m22 && m11 > m33) {
      const s = 2.0 * Math.sqrt(1.0 + m11 - m22 - m33);
      this._w = (m32 - m23) / s;
      this._x = 0.25 * s;
      this._y = (m12 + m21) / s;
      this._z = (m13 + m31) / s;
    } else if (m22 > m33) {
      const s = 2.0 * Math.sqrt(1.0 + m22 - m11 - m33);
      this._w = (m13 - m31) / s;
      this._x = (m12 + m21) / s;
      this._y = 0.25 * s;
      this._z = (m23 + m32) / s;
    } else {
      const s = 2.0 * Math.sqrt(1.0 + m33 - m11 - m22);
      this._w = (m21 - m12) / s;
      this._x = (m13 + m31) / s;
      this._y = (m23 + m32) / s;
      this._z = 0.25 * s;
    }

    this._onChangeCallback();

    return this;
  }

  setFromUnitVectors(vFrom, vTo) {
    // assumes direction vectors vFrom and vTo are normalized
    let r = vFrom.dot(vTo) + 1;

    if (r < Number.EPSILON) {
      // vFrom and vTo point in opposite directions
      r = 0;

      if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {
        this._x = -vFrom.y;
        this._y = vFrom.x;
        this._z = 0;
        this._w = r;
      } else {
        this._x = 0;
        this._y = -vFrom.z;
        this._z = vFrom.y;
        this._w = r;
      }
    } else {
      // crossVectors( vFrom, vTo ); // inlined to avoid cyclic dependency on Vector3
      this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;
      this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;
      this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;
      this._w = r;
    }

    return this.normalize();
  }

  angleTo(q) {
    return 2 * Math.acos(Math.abs(MathUtils.clamp(this.dot(q), -1, 1)));
  }

  rotateTowards(q, step) {
    const angle = this.angleTo(q);
    if (angle === 0) return this;
    const t = Math.min(1, step / angle);
    this.slerp(q, t);
    return this;
  }

  identity() {
    return this.set(0, 0, 0, 1);
  }

  invert() {
    // quaternion is assumed to have unit length
    return this.conjugate();
  }

  conjugate() {
    this._x *= -1;
    this._y *= -1;
    this._z *= -1;

    this._onChangeCallback();

    return this;
  }

  dot(v) {
    return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;
  }

  lengthSq() {
    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
  }

  length() {
    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
  }

  normalize() {
    let l = this.length();

    if (l === 0) {
      this._x = 0;
      this._y = 0;
      this._z = 0;
      this._w = 1;
    } else {
      l = 1 / l;
      this._x = this._x * l;
      this._y = this._y * l;
      this._z = this._z * l;
      this._w = this._w * l;
    }

    this._onChangeCallback();

    return this;
  }

  multiply(q) {
    return this.multiplyQuaternions(this, q);
  }

  premultiply(q) {
    return this.multiplyQuaternions(q, this);
  }

  multiplyQuaternions(a, b) {
    // from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm
    const qax = a._x,
          qay = a._y,
          qaz = a._z,
          qaw = a._w;
    const qbx = b._x,
          qby = b._y,
          qbz = b._z,
          qbw = b._w;
    this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
    this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
    this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
    this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;

    this._onChangeCallback();

    return this;
  }

  slerp(qb, t) {
    if (t === 0) return this;
    if (t === 1) return this.copy(qb);
    const x = this._x,
          y = this._y,
          z = this._z,
          w = this._w; // http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/

    let cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;

    if (cosHalfTheta < 0) {
      this._w = -qb._w;
      this._x = -qb._x;
      this._y = -qb._y;
      this._z = -qb._z;
      cosHalfTheta = -cosHalfTheta;
    } else {
      this.copy(qb);
    }

    if (cosHalfTheta >= 1.0) {
      this._w = w;
      this._x = x;
      this._y = y;
      this._z = z;
      return this;
    }

    const sqrSinHalfTheta = 1.0 - cosHalfTheta * cosHalfTheta;

    if (sqrSinHalfTheta <= Number.EPSILON) {
      const s = 1 - t;
      this._w = s * w + t * this._w;
      this._x = s * x + t * this._x;
      this._y = s * y + t * this._y;
      this._z = s * z + t * this._z;
      this.normalize();

      this._onChangeCallback();

      return this;
    }

    const sinHalfTheta = Math.sqrt(sqrSinHalfTheta);
    const halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);
    const ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta,
          ratioB = Math.sin(t * halfTheta) / sinHalfTheta;
    this._w = w * ratioA + this._w * ratioB;
    this._x = x * ratioA + this._x * ratioB;
    this._y = y * ratioA + this._y * ratioB;
    this._z = z * ratioA + this._z * ratioB;

    this._onChangeCallback();

    return this;
  }

  slerpQuaternions(qa, qb, t) {
    return this.copy(qa).slerp(qb, t);
  }

  random() {
    // Derived from http://planning.cs.uiuc.edu/node198.html
    // Note, this source uses w, x, y, z ordering,
    // so we swap the order below.
    const u1 = Math.random();
    const sqrt1u1 = Math.sqrt(1 - u1);
    const sqrtu1 = Math.sqrt(u1);
    const u2 = 2 * Math.PI * Math.random();
    const u3 = 2 * Math.PI * Math.random();
    return this.set(sqrt1u1 * Math.cos(u2), sqrtu1 * Math.sin(u3), sqrtu1 * Math.cos(u3), sqrt1u1 * Math.sin(u2));
  }

  equals(quaternion) {
    return quaternion._x === this._x && quaternion._y === this._y && quaternion._z === this._z && quaternion._w === this._w;
  }

  fromArray(array, offset = 0) {
    this._x = array[offset];
    this._y = array[offset + 1];
    this._z = array[offset + 2];
    this._w = array[offset + 3];

    this._onChangeCallback();

    return this;
  }

  toArray(array = [], offset = 0) {
    array[offset] = this._x;
    array[offset + 1] = this._y;
    array[offset + 2] = this._z;
    array[offset + 3] = this._w;
    return array;
  }

  fromBufferAttribute(attribute, index) {
    this._x = attribute.getX(index);
    this._y = attribute.getY(index);
    this._z = attribute.getZ(index);
    this._w = attribute.getW(index);
    return this;
  }

  toJSON() {
    return this.toArray();
  }

  _onChange(callback) {
    this._onChangeCallback = callback;
    return this;
  }

  _onChangeCallback() {}

  *[Symbol.iterator]() {
    yield this._x;
    yield this._y;
    yield this._z;
    yield this._w;
  }

}

exports.Quaternion = Quaternion;

},{"./MathUtils.js":168}],172:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Sphere = void 0;

var _Box = require("./Box3.js");

var _Vector = require("./Vector3.js");

const _box = /*@__PURE__*/new _Box.Box3();

const _v1 = /*@__PURE__*/new _Vector.Vector3();

const _v2 = /*@__PURE__*/new _Vector.Vector3();

class Sphere {
  constructor(center = new _Vector.Vector3(), radius = -1) {
    this.center = center;
    this.radius = radius;
  }

  set(center, radius) {
    this.center.copy(center);
    this.radius = radius;
    return this;
  }

  setFromPoints(points, optionalCenter) {
    const center = this.center;

    if (optionalCenter !== undefined) {
      center.copy(optionalCenter);
    } else {
      _box.setFromPoints(points).getCenter(center);
    }

    let maxRadiusSq = 0;

    for (let i = 0, il = points.length; i < il; i++) {
      maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[i]));
    }

    this.radius = Math.sqrt(maxRadiusSq);
    return this;
  }

  copy(sphere) {
    this.center.copy(sphere.center);
    this.radius = sphere.radius;
    return this;
  }

  isEmpty() {
    return this.radius < 0;
  }

  makeEmpty() {
    this.center.set(0, 0, 0);
    this.radius = -1;
    return this;
  }

  containsPoint(point) {
    return point.distanceToSquared(this.center) <= this.radius * this.radius;
  }

  distanceToPoint(point) {
    return point.distanceTo(this.center) - this.radius;
  }

  intersectsSphere(sphere) {
    const radiusSum = this.radius + sphere.radius;
    return sphere.center.distanceToSquared(this.center) <= radiusSum * radiusSum;
  }

  intersectsBox(box) {
    return box.intersectsSphere(this);
  }

  intersectsPlane(plane) {
    return Math.abs(plane.distanceToPoint(this.center)) <= this.radius;
  }

  clampPoint(point, target) {
    const deltaLengthSq = this.center.distanceToSquared(point);
    target.copy(point);

    if (deltaLengthSq > this.radius * this.radius) {
      target.sub(this.center).normalize();
      target.multiplyScalar(this.radius).add(this.center);
    }

    return target;
  }

  getBoundingBox(target) {
    if (this.isEmpty()) {
      // Empty sphere produces empty bounding box
      target.makeEmpty();
      return target;
    }

    target.set(this.center, this.center);
    target.expandByScalar(this.radius);
    return target;
  }

  applyMatrix4(matrix) {
    this.center.applyMatrix4(matrix);
    this.radius = this.radius * matrix.getMaxScaleOnAxis();
    return this;
  }

  translate(offset) {
    this.center.add(offset);
    return this;
  }

  expandByPoint(point) {
    if (this.isEmpty()) {
      this.center.copy(point);
      this.radius = 0;
      return this;
    }

    _v1.subVectors(point, this.center);

    const lengthSq = _v1.lengthSq();

    if (lengthSq > this.radius * this.radius) {
      // calculate the minimal sphere
      const length = Math.sqrt(lengthSq);
      const delta = (length - this.radius) * 0.5;
      this.center.addScaledVector(_v1, delta / length);
      this.radius += delta;
    }

    return this;
  }

  union(sphere) {
    if (sphere.isEmpty()) {
      return this;
    }

    if (this.isEmpty()) {
      this.copy(sphere);
      return this;
    }

    if (this.center.equals(sphere.center) === true) {
      this.radius = Math.max(this.radius, sphere.radius);
    } else {
      _v2.subVectors(sphere.center, this.center).setLength(sphere.radius);

      this.expandByPoint(_v1.copy(sphere.center).add(_v2));
      this.expandByPoint(_v1.copy(sphere.center).sub(_v2));
    }

    return this;
  }

  equals(sphere) {
    return sphere.center.equals(this.center) && sphere.radius === this.radius;
  }

  clone() {
    return new this.constructor().copy(this);
  }

}

exports.Sphere = Sphere;

},{"./Box3.js":166,"./Vector3.js":175}],173:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Triangle = void 0;

var _Vector = require("./Vector3.js");

const _v0 = /*@__PURE__*/new _Vector.Vector3();

const _v1 = /*@__PURE__*/new _Vector.Vector3();

const _v2 = /*@__PURE__*/new _Vector.Vector3();

const _v3 = /*@__PURE__*/new _Vector.Vector3();

const _vab = /*@__PURE__*/new _Vector.Vector3();

const _vac = /*@__PURE__*/new _Vector.Vector3();

const _vbc = /*@__PURE__*/new _Vector.Vector3();

const _vap = /*@__PURE__*/new _Vector.Vector3();

const _vbp = /*@__PURE__*/new _Vector.Vector3();

const _vcp = /*@__PURE__*/new _Vector.Vector3();

let warnedGetUV = false;

class Triangle {
  constructor(a = new _Vector.Vector3(), b = new _Vector.Vector3(), c = new _Vector.Vector3()) {
    this.a = a;
    this.b = b;
    this.c = c;
  }

  static getNormal(a, b, c, target) {
    target.subVectors(c, b);

    _v0.subVectors(a, b);

    target.cross(_v0);
    const targetLengthSq = target.lengthSq();

    if (targetLengthSq > 0) {
      return target.multiplyScalar(1 / Math.sqrt(targetLengthSq));
    }

    return target.set(0, 0, 0);
  } // static/instance method to calculate barycentric coordinates
  // based on: http://www.blackpawn.com/texts/pointinpoly/default.html


  static getBarycoord(point, a, b, c, target) {
    _v0.subVectors(c, a);

    _v1.subVectors(b, a);

    _v2.subVectors(point, a);

    const dot00 = _v0.dot(_v0);

    const dot01 = _v0.dot(_v1);

    const dot02 = _v0.dot(_v2);

    const dot11 = _v1.dot(_v1);

    const dot12 = _v1.dot(_v2);

    const denom = dot00 * dot11 - dot01 * dot01; // collinear or singular triangle

    if (denom === 0) {
      // arbitrary location outside of triangle?
      // not sure if this is the best idea, maybe should be returning undefined
      return target.set(-2, -1, -1);
    }

    const invDenom = 1 / denom;
    const u = (dot11 * dot02 - dot01 * dot12) * invDenom;
    const v = (dot00 * dot12 - dot01 * dot02) * invDenom; // barycentric coordinates must always sum to 1

    return target.set(1 - u - v, v, u);
  }

  static containsPoint(point, a, b, c) {
    this.getBarycoord(point, a, b, c, _v3);
    return _v3.x >= 0 && _v3.y >= 0 && _v3.x + _v3.y <= 1;
  }

  static getUV(point, p1, p2, p3, uv1, uv2, uv3, target) {
    // @deprecated, r151
    if (warnedGetUV === false) {
      console.warn('THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation().');
      warnedGetUV = true;
    }

    return this.getInterpolation(point, p1, p2, p3, uv1, uv2, uv3, target);
  }

  static getInterpolation(point, p1, p2, p3, v1, v2, v3, target) {
    this.getBarycoord(point, p1, p2, p3, _v3);
    target.setScalar(0);
    target.addScaledVector(v1, _v3.x);
    target.addScaledVector(v2, _v3.y);
    target.addScaledVector(v3, _v3.z);
    return target;
  }

  static isFrontFacing(a, b, c, direction) {
    _v0.subVectors(c, b);

    _v1.subVectors(a, b); // strictly front facing


    return _v0.cross(_v1).dot(direction) < 0 ? true : false;
  }

  set(a, b, c) {
    this.a.copy(a);
    this.b.copy(b);
    this.c.copy(c);
    return this;
  }

  setFromPointsAndIndices(points, i0, i1, i2) {
    this.a.copy(points[i0]);
    this.b.copy(points[i1]);
    this.c.copy(points[i2]);
    return this;
  }

  setFromAttributeAndIndices(attribute, i0, i1, i2) {
    this.a.fromBufferAttribute(attribute, i0);
    this.b.fromBufferAttribute(attribute, i1);
    this.c.fromBufferAttribute(attribute, i2);
    return this;
  }

  clone() {
    return new this.constructor().copy(this);
  }

  copy(triangle) {
    this.a.copy(triangle.a);
    this.b.copy(triangle.b);
    this.c.copy(triangle.c);
    return this;
  }

  getArea() {
    _v0.subVectors(this.c, this.b);

    _v1.subVectors(this.a, this.b);

    return _v0.cross(_v1).length() * 0.5;
  }

  getMidpoint(target) {
    return target.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
  }

  getNormal(target) {
    return Triangle.getNormal(this.a, this.b, this.c, target);
  }

  getPlane(target) {
    return target.setFromCoplanarPoints(this.a, this.b, this.c);
  }

  getBarycoord(point, target) {
    return Triangle.getBarycoord(point, this.a, this.b, this.c, target);
  }

  getUV(point, uv1, uv2, uv3, target) {
    // @deprecated, r151
    if (warnedGetUV === false) {
      console.warn('THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation().');
      warnedGetUV = true;
    }

    return Triangle.getInterpolation(point, this.a, this.b, this.c, uv1, uv2, uv3, target);
  }

  getInterpolation(point, v1, v2, v3, target) {
    return Triangle.getInterpolation(point, this.a, this.b, this.c, v1, v2, v3, target);
  }

  containsPoint(point) {
    return Triangle.containsPoint(point, this.a, this.b, this.c);
  }

  isFrontFacing(direction) {
    return Triangle.isFrontFacing(this.a, this.b, this.c, direction);
  }

  intersectsBox(box) {
    return box.intersectsTriangle(this);
  }

  closestPointToPoint(p, target) {
    const a = this.a,
          b = this.b,
          c = this.c;
    let v, w; // algorithm thanks to Real-Time Collision Detection by Christer Ericson,
    // published by Morgan Kaufmann Publishers, (c) 2005 Elsevier Inc.,
    // under the accompanying license; see chapter 5.1.5 for detailed explanation.
    // basically, we're distinguishing which of the voronoi regions of the triangle
    // the point lies in with the minimum amount of redundant computation.

    _vab.subVectors(b, a);

    _vac.subVectors(c, a);

    _vap.subVectors(p, a);

    const d1 = _vab.dot(_vap);

    const d2 = _vac.dot(_vap);

    if (d1 <= 0 && d2 <= 0) {
      // vertex region of A; barycentric coords (1, 0, 0)
      return target.copy(a);
    }

    _vbp.subVectors(p, b);

    const d3 = _vab.dot(_vbp);

    const d4 = _vac.dot(_vbp);

    if (d3 >= 0 && d4 <= d3) {
      // vertex region of B; barycentric coords (0, 1, 0)
      return target.copy(b);
    }

    const vc = d1 * d4 - d3 * d2;

    if (vc <= 0 && d1 >= 0 && d3 <= 0) {
      v = d1 / (d1 - d3); // edge region of AB; barycentric coords (1-v, v, 0)

      return target.copy(a).addScaledVector(_vab, v);
    }

    _vcp.subVectors(p, c);

    const d5 = _vab.dot(_vcp);

    const d6 = _vac.dot(_vcp);

    if (d6 >= 0 && d5 <= d6) {
      // vertex region of C; barycentric coords (0, 0, 1)
      return target.copy(c);
    }

    const vb = d5 * d2 - d1 * d6;

    if (vb <= 0 && d2 >= 0 && d6 <= 0) {
      w = d2 / (d2 - d6); // edge region of AC; barycentric coords (1-w, 0, w)

      return target.copy(a).addScaledVector(_vac, w);
    }

    const va = d3 * d6 - d5 * d4;

    if (va <= 0 && d4 - d3 >= 0 && d5 - d6 >= 0) {
      _vbc.subVectors(c, b);

      w = (d4 - d3) / (d4 - d3 + (d5 - d6)); // edge region of BC; barycentric coords (0, 1-w, w)

      return target.copy(b).addScaledVector(_vbc, w); // edge region of BC
    } // face region


    const denom = 1 / (va + vb + vc); // u = va * denom

    v = vb * denom;
    w = vc * denom;
    return target.copy(a).addScaledVector(_vab, v).addScaledVector(_vac, w);
  }

  equals(triangle) {
    return triangle.a.equals(this.a) && triangle.b.equals(this.b) && triangle.c.equals(this.c);
  }

}

exports.Triangle = Triangle;

},{"./Vector3.js":175}],174:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Vector2 = void 0;

var MathUtils = _interopRequireWildcard(require("./MathUtils.js"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

class Vector2 {
  constructor(x = 0, y = 0) {
    Vector2.prototype.isVector2 = true;
    this.x = x;
    this.y = y;
  }

  get width() {
    return this.x;
  }

  set width(value) {
    this.x = value;
  }

  get height() {
    return this.y;
  }

  set height(value) {
    this.y = value;
  }

  set(x, y) {
    this.x = x;
    this.y = y;
    return this;
  }

  setScalar(scalar) {
    this.x = scalar;
    this.y = scalar;
    return this;
  }

  setX(x) {
    this.x = x;
    return this;
  }

  setY(y) {
    this.y = y;
    return this;
  }

  setComponent(index, value) {
    switch (index) {
      case 0:
        this.x = value;
        break;

      case 1:
        this.y = value;
        break;

      default:
        throw new Error('index is out of range: ' + index);
    }

    return this;
  }

  getComponent(index) {
    switch (index) {
      case 0:
        return this.x;

      case 1:
        return this.y;

      default:
        throw new Error('index is out of range: ' + index);
    }
  }

  clone() {
    return new this.constructor(this.x, this.y);
  }

  copy(v) {
    this.x = v.x;
    this.y = v.y;
    return this;
  }

  add(v) {
    this.x += v.x;
    this.y += v.y;
    return this;
  }

  addScalar(s) {
    this.x += s;
    this.y += s;
    return this;
  }

  addVectors(a, b) {
    this.x = a.x + b.x;
    this.y = a.y + b.y;
    return this;
  }

  addScaledVector(v, s) {
    this.x += v.x * s;
    this.y += v.y * s;
    return this;
  }

  sub(v) {
    this.x -= v.x;
    this.y -= v.y;
    return this;
  }

  subScalar(s) {
    this.x -= s;
    this.y -= s;
    return this;
  }

  subVectors(a, b) {
    this.x = a.x - b.x;
    this.y = a.y - b.y;
    return this;
  }

  multiply(v) {
    this.x *= v.x;
    this.y *= v.y;
    return this;
  }

  multiplyScalar(scalar) {
    this.x *= scalar;
    this.y *= scalar;
    return this;
  }

  divide(v) {
    this.x /= v.x;
    this.y /= v.y;
    return this;
  }

  divideScalar(scalar) {
    return this.multiplyScalar(1 / scalar);
  }

  applyMatrix3(m) {
    const x = this.x,
          y = this.y;
    const e = m.elements;
    this.x = e[0] * x + e[3] * y + e[6];
    this.y = e[1] * x + e[4] * y + e[7];
    return this;
  }

  min(v) {
    this.x = Math.min(this.x, v.x);
    this.y = Math.min(this.y, v.y);
    return this;
  }

  max(v) {
    this.x = Math.max(this.x, v.x);
    this.y = Math.max(this.y, v.y);
    return this;
  }

  clamp(min, max) {
    // assumes min < max, componentwise
    this.x = Math.max(min.x, Math.min(max.x, this.x));
    this.y = Math.max(min.y, Math.min(max.y, this.y));
    return this;
  }

  clampScalar(minVal, maxVal) {
    this.x = Math.max(minVal, Math.min(maxVal, this.x));
    this.y = Math.max(minVal, Math.min(maxVal, this.y));
    return this;
  }

  clampLength(min, max) {
    const length = this.length();
    return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
  }

  floor() {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    return this;
  }

  ceil() {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    return this;
  }

  round() {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    return this;
  }

  roundToZero() {
    this.x = Math.trunc(this.x);
    this.y = Math.trunc(this.y);
    return this;
  }

  negate() {
    this.x = -this.x;
    this.y = -this.y;
    return this;
  }

  dot(v) {
    return this.x * v.x + this.y * v.y;
  }

  cross(v) {
    return this.x * v.y - this.y * v.x;
  }

  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }

  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }

  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y);
  }

  normalize() {
    return this.divideScalar(this.length() || 1);
  }

  angle() {
    // computes the angle in radians with respect to the positive x-axis
    const angle = Math.atan2(-this.y, -this.x) + Math.PI;
    return angle;
  }

  angleTo(v) {
    const denominator = Math.sqrt(this.lengthSq() * v.lengthSq());
    if (denominator === 0) return Math.PI / 2;
    const theta = this.dot(v) / denominator; // clamp, to handle numerical problems

    return Math.acos(MathUtils.clamp(theta, -1, 1));
  }

  distanceTo(v) {
    return Math.sqrt(this.distanceToSquared(v));
  }

  distanceToSquared(v) {
    const dx = this.x - v.x,
          dy = this.y - v.y;
    return dx * dx + dy * dy;
  }

  manhattanDistanceTo(v) {
    return Math.abs(this.x - v.x) + Math.abs(this.y - v.y);
  }

  setLength(length) {
    return this.normalize().multiplyScalar(length);
  }

  lerp(v, alpha) {
    this.x += (v.x - this.x) * alpha;
    this.y += (v.y - this.y) * alpha;
    return this;
  }

  lerpVectors(v1, v2, alpha) {
    this.x = v1.x + (v2.x - v1.x) * alpha;
    this.y = v1.y + (v2.y - v1.y) * alpha;
    return this;
  }

  equals(v) {
    return v.x === this.x && v.y === this.y;
  }

  fromArray(array, offset = 0) {
    this.x = array[offset];
    this.y = array[offset + 1];
    return this;
  }

  toArray(array = [], offset = 0) {
    array[offset] = this.x;
    array[offset + 1] = this.y;
    return array;
  }

  fromBufferAttribute(attribute, index) {
    this.x = attribute.getX(index);
    this.y = attribute.getY(index);
    return this;
  }

  rotateAround(center, angle) {
    const c = Math.cos(angle),
          s = Math.sin(angle);
    const x = this.x - center.x;
    const y = this.y - center.y;
    this.x = x * c - y * s + center.x;
    this.y = x * s + y * c + center.y;
    return this;
  }

  random() {
    this.x = Math.random();
    this.y = Math.random();
    return this;
  }

  *[Symbol.iterator]() {
    yield this.x;
    yield this.y;
  }

}

exports.Vector2 = Vector2;

},{"./MathUtils.js":168}],175:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Vector3 = void 0;

var MathUtils = _interopRequireWildcard(require("./MathUtils.js"));

var _Quaternion = require("./Quaternion.js");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

class Vector3 {
  constructor(x = 0, y = 0, z = 0) {
    Vector3.prototype.isVector3 = true;
    this.x = x;
    this.y = y;
    this.z = z;
  }

  set(x, y, z) {
    if (z === undefined) z = this.z; // sprite.scale.set(x,y)

    this.x = x;
    this.y = y;
    this.z = z;
    return this;
  }

  setScalar(scalar) {
    this.x = scalar;
    this.y = scalar;
    this.z = scalar;
    return this;
  }

  setX(x) {
    this.x = x;
    return this;
  }

  setY(y) {
    this.y = y;
    return this;
  }

  setZ(z) {
    this.z = z;
    return this;
  }

  setComponent(index, value) {
    switch (index) {
      case 0:
        this.x = value;
        break;

      case 1:
        this.y = value;
        break;

      case 2:
        this.z = value;
        break;

      default:
        throw new Error('index is out of range: ' + index);
    }

    return this;
  }

  getComponent(index) {
    switch (index) {
      case 0:
        return this.x;

      case 1:
        return this.y;

      case 2:
        return this.z;

      default:
        throw new Error('index is out of range: ' + index);
    }
  }

  clone() {
    return new this.constructor(this.x, this.y, this.z);
  }

  copy(v) {
    this.x = v.x;
    this.y = v.y;
    this.z = v.z;
    return this;
  }

  add(v) {
    this.x += v.x;
    this.y += v.y;
    this.z += v.z;
    return this;
  }

  addScalar(s) {
    this.x += s;
    this.y += s;
    this.z += s;
    return this;
  }

  addVectors(a, b) {
    this.x = a.x + b.x;
    this.y = a.y + b.y;
    this.z = a.z + b.z;
    return this;
  }

  addScaledVector(v, s) {
    this.x += v.x * s;
    this.y += v.y * s;
    this.z += v.z * s;
    return this;
  }

  sub(v) {
    this.x -= v.x;
    this.y -= v.y;
    this.z -= v.z;
    return this;
  }

  subScalar(s) {
    this.x -= s;
    this.y -= s;
    this.z -= s;
    return this;
  }

  subVectors(a, b) {
    this.x = a.x - b.x;
    this.y = a.y - b.y;
    this.z = a.z - b.z;
    return this;
  }

  multiply(v) {
    this.x *= v.x;
    this.y *= v.y;
    this.z *= v.z;
    return this;
  }

  multiplyScalar(scalar) {
    this.x *= scalar;
    this.y *= scalar;
    this.z *= scalar;
    return this;
  }

  multiplyVectors(a, b) {
    this.x = a.x * b.x;
    this.y = a.y * b.y;
    this.z = a.z * b.z;
    return this;
  }

  applyEuler(euler) {
    return this.applyQuaternion(_quaternion.setFromEuler(euler));
  }

  applyAxisAngle(axis, angle) {
    return this.applyQuaternion(_quaternion.setFromAxisAngle(axis, angle));
  }

  applyMatrix3(m) {
    const x = this.x,
          y = this.y,
          z = this.z;
    const e = m.elements;
    this.x = e[0] * x + e[3] * y + e[6] * z;
    this.y = e[1] * x + e[4] * y + e[7] * z;
    this.z = e[2] * x + e[5] * y + e[8] * z;
    return this;
  }

  applyNormalMatrix(m) {
    return this.applyMatrix3(m).normalize();
  }

  applyMatrix4(m) {
    const x = this.x,
          y = this.y,
          z = this.z;
    const e = m.elements;
    const w = 1 / (e[3] * x + e[7] * y + e[11] * z + e[15]);
    this.x = (e[0] * x + e[4] * y + e[8] * z + e[12]) * w;
    this.y = (e[1] * x + e[5] * y + e[9] * z + e[13]) * w;
    this.z = (e[2] * x + e[6] * y + e[10] * z + e[14]) * w;
    return this;
  }

  applyQuaternion(q) {
    const x = this.x,
          y = this.y,
          z = this.z;
    const qx = q.x,
          qy = q.y,
          qz = q.z,
          qw = q.w; // calculate quat * vector

    const ix = qw * x + qy * z - qz * y;
    const iy = qw * y + qz * x - qx * z;
    const iz = qw * z + qx * y - qy * x;
    const iw = -qx * x - qy * y - qz * z; // calculate result * inverse quat

    this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
    this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
    this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
    return this;
  }

  project(camera) {
    return this.applyMatrix4(camera.matrixWorldInverse).applyMatrix4(camera.projectionMatrix);
  }

  unproject(camera) {
    return this.applyMatrix4(camera.projectionMatrixInverse).applyMatrix4(camera.matrixWorld);
  }

  transformDirection(m) {
    // input: THREE.Matrix4 affine matrix
    // vector interpreted as a direction
    const x = this.x,
          y = this.y,
          z = this.z;
    const e = m.elements;
    this.x = e[0] * x + e[4] * y + e[8] * z;
    this.y = e[1] * x + e[5] * y + e[9] * z;
    this.z = e[2] * x + e[6] * y + e[10] * z;
    return this.normalize();
  }

  divide(v) {
    this.x /= v.x;
    this.y /= v.y;
    this.z /= v.z;
    return this;
  }

  divideScalar(scalar) {
    return this.multiplyScalar(1 / scalar);
  }

  min(v) {
    this.x = Math.min(this.x, v.x);
    this.y = Math.min(this.y, v.y);
    this.z = Math.min(this.z, v.z);
    return this;
  }

  max(v) {
    this.x = Math.max(this.x, v.x);
    this.y = Math.max(this.y, v.y);
    this.z = Math.max(this.z, v.z);
    return this;
  }

  clamp(min, max) {
    // assumes min < max, componentwise
    this.x = Math.max(min.x, Math.min(max.x, this.x));
    this.y = Math.max(min.y, Math.min(max.y, this.y));
    this.z = Math.max(min.z, Math.min(max.z, this.z));
    return this;
  }

  clampScalar(minVal, maxVal) {
    this.x = Math.max(minVal, Math.min(maxVal, this.x));
    this.y = Math.max(minVal, Math.min(maxVal, this.y));
    this.z = Math.max(minVal, Math.min(maxVal, this.z));
    return this;
  }

  clampLength(min, max) {
    const length = this.length();
    return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
  }

  floor() {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    this.z = Math.floor(this.z);
    return this;
  }

  ceil() {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    this.z = Math.ceil(this.z);
    return this;
  }

  round() {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    this.z = Math.round(this.z);
    return this;
  }

  roundToZero() {
    this.x = Math.trunc(this.x);
    this.y = Math.trunc(this.y);
    this.z = Math.trunc(this.z);
    return this;
  }

  negate() {
    this.x = -this.x;
    this.y = -this.y;
    this.z = -this.z;
    return this;
  }

  dot(v) {
    return this.x * v.x + this.y * v.y + this.z * v.z;
  } // TODO lengthSquared?


  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }

  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }

  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }

  normalize() {
    return this.divideScalar(this.length() || 1);
  }

  setLength(length) {
    return this.normalize().multiplyScalar(length);
  }

  lerp(v, alpha) {
    this.x += (v.x - this.x) * alpha;
    this.y += (v.y - this.y) * alpha;
    this.z += (v.z - this.z) * alpha;
    return this;
  }

  lerpVectors(v1, v2, alpha) {
    this.x = v1.x + (v2.x - v1.x) * alpha;
    this.y = v1.y + (v2.y - v1.y) * alpha;
    this.z = v1.z + (v2.z - v1.z) * alpha;
    return this;
  }

  cross(v) {
    return this.crossVectors(this, v);
  }

  crossVectors(a, b) {
    const ax = a.x,
          ay = a.y,
          az = a.z;
    const bx = b.x,
          by = b.y,
          bz = b.z;
    this.x = ay * bz - az * by;
    this.y = az * bx - ax * bz;
    this.z = ax * by - ay * bx;
    return this;
  }

  projectOnVector(v) {
    const denominator = v.lengthSq();
    if (denominator === 0) return this.set(0, 0, 0);
    const scalar = v.dot(this) / denominator;
    return this.copy(v).multiplyScalar(scalar);
  }

  projectOnPlane(planeNormal) {
    _vector.copy(this).projectOnVector(planeNormal);

    return this.sub(_vector);
  }

  reflect(normal) {
    // reflect incident vector off plane orthogonal to normal
    // normal is assumed to have unit length
    return this.sub(_vector.copy(normal).multiplyScalar(2 * this.dot(normal)));
  }

  angleTo(v) {
    const denominator = Math.sqrt(this.lengthSq() * v.lengthSq());
    if (denominator === 0) return Math.PI / 2;
    const theta = this.dot(v) / denominator; // clamp, to handle numerical problems

    return Math.acos(MathUtils.clamp(theta, -1, 1));
  }

  distanceTo(v) {
    return Math.sqrt(this.distanceToSquared(v));
  }

  distanceToSquared(v) {
    const dx = this.x - v.x,
          dy = this.y - v.y,
          dz = this.z - v.z;
    return dx * dx + dy * dy + dz * dz;
  }

  manhattanDistanceTo(v) {
    return Math.abs(this.x - v.x) + Math.abs(this.y - v.y) + Math.abs(this.z - v.z);
  }

  setFromSpherical(s) {
    return this.setFromSphericalCoords(s.radius, s.phi, s.theta);
  }

  setFromSphericalCoords(radius, phi, theta) {
    const sinPhiRadius = Math.sin(phi) * radius;
    this.x = sinPhiRadius * Math.sin(theta);
    this.y = Math.cos(phi) * radius;
    this.z = sinPhiRadius * Math.cos(theta);
    return this;
  }

  setFromCylindrical(c) {
    return this.setFromCylindricalCoords(c.radius, c.theta, c.y);
  }

  setFromCylindricalCoords(radius, theta, y) {
    this.x = radius * Math.sin(theta);
    this.y = y;
    this.z = radius * Math.cos(theta);
    return this;
  }

  setFromMatrixPosition(m) {
    const e = m.elements;
    this.x = e[12];
    this.y = e[13];
    this.z = e[14];
    return this;
  }

  setFromMatrixScale(m) {
    const sx = this.setFromMatrixColumn(m, 0).length();
    const sy = this.setFromMatrixColumn(m, 1).length();
    const sz = this.setFromMatrixColumn(m, 2).length();
    this.x = sx;
    this.y = sy;
    this.z = sz;
    return this;
  }

  setFromMatrixColumn(m, index) {
    return this.fromArray(m.elements, index * 4);
  }

  setFromMatrix3Column(m, index) {
    return this.fromArray(m.elements, index * 3);
  }

  setFromEuler(e) {
    this.x = e._x;
    this.y = e._y;
    this.z = e._z;
    return this;
  }

  setFromColor(c) {
    this.x = c.r;
    this.y = c.g;
    this.z = c.b;
    return this;
  }

  equals(v) {
    return v.x === this.x && v.y === this.y && v.z === this.z;
  }

  fromArray(array, offset = 0) {
    this.x = array[offset];
    this.y = array[offset + 1];
    this.z = array[offset + 2];
    return this;
  }

  toArray(array = [], offset = 0) {
    array[offset] = this.x;
    array[offset + 1] = this.y;
    array[offset + 2] = this.z;
    return array;
  }

  fromBufferAttribute(attribute, index) {
    this.x = attribute.getX(index);
    this.y = attribute.getY(index);
    this.z = attribute.getZ(index);
    return this;
  }

  random() {
    this.x = Math.random();
    this.y = Math.random();
    this.z = Math.random();
    return this;
  }

  randomDirection() {
    // Derived from https://mathworld.wolfram.com/SpherePointPicking.html
    const u = (Math.random() - 0.5) * 2;
    const t = Math.random() * Math.PI * 2;
    const f = Math.sqrt(1 - u ** 2);
    this.x = f * Math.cos(t);
    this.y = f * Math.sin(t);
    this.z = u;
    return this;
  }

  *[Symbol.iterator]() {
    yield this.x;
    yield this.y;
    yield this.z;
  }

}

exports.Vector3 = Vector3;

const _vector = /*@__PURE__*/new Vector3();

const _quaternion = /*@__PURE__*/new _Quaternion.Quaternion();

},{"./MathUtils.js":168,"./Quaternion.js":171}],176:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.arrayMax = arrayMax;
exports.arrayMin = arrayMin;
exports.arrayNeedsUint32 = arrayNeedsUint32;
exports.createCanvasElement = createCanvasElement;
exports.createElementNS = createElementNS;
exports.getTypedArray = getTypedArray;
exports.warnOnce = warnOnce;

function arrayMin(array) {
  if (array.length === 0) return Infinity;
  let min = array[0];

  for (let i = 1, l = array.length; i < l; ++i) {
    if (array[i] < min) min = array[i];
  }

  return min;
}

function arrayMax(array) {
  if (array.length === 0) return -Infinity;
  let max = array[0];

  for (let i = 1, l = array.length; i < l; ++i) {
    if (array[i] > max) max = array[i];
  }

  return max;
}

function arrayNeedsUint32(array) {
  // assumes larger values usually on last
  for (let i = array.length - 1; i >= 0; --i) {
    if (array[i] >= 65535) return true; // account for PRIMITIVE_RESTART_FIXED_INDEX, #24565
  }

  return false;
}

const TYPED_ARRAYS = {
  Int8Array: Int8Array,
  Uint8Array: Uint8Array,
  Uint8ClampedArray: Uint8ClampedArray,
  Int16Array: Int16Array,
  Uint16Array: Uint16Array,
  Int32Array: Int32Array,
  Uint32Array: Uint32Array,
  Float32Array: Float32Array,
  Float64Array: Float64Array
};

function getTypedArray(type, buffer) {
  return new TYPED_ARRAYS[type](buffer);
}

function createElementNS(name) {
  return document.createElementNS('http://www.w3.org/1999/xhtml', name);
}

function createCanvasElement() {
  const canvas = createElementNS('canvas');
  canvas.style.display = 'block';
  return canvas;
}

const _cache = {};

function warnOnce(message) {
  if (message in _cache) return;
  _cache[message] = true;
  console.warn(message);
}

},{}],177:[function(require,module,exports){
"use strict"

module.exports = triangulateCube

var perm = require("permutation-rank")
var sgn = require("permutation-parity")
var gamma = require("gamma")

function triangulateCube(dimension) {
  if(dimension < 0) {
    return [ ]
  }
  if(dimension === 0) {
    return [ [0] ]
  }
  var dfactorial = Math.round(gamma(dimension+1))|0
  var result = []
  for(var i=0; i<dfactorial; ++i) {
    var p = perm.unrank(dimension, i)
    var cell = [ 0 ]
    var v = 0
    for(var j=0; j<p.length; ++j) {
      v += (1<<p[j])
      cell.push(v)
    }
    if(sgn(p) < 1) {
      cell[0] = v
      cell[dimension] = 0
    }
    result.push(cell)
  }
  return result
}
},{"gamma":46,"permutation-parity":89,"permutation-rank":90}],178:[function(require,module,exports){
"use strict"

module.exports = twoProduct

var SPLITTER = +(Math.pow(2, 27) + 1.0)

function twoProduct(a, b, result) {
  var x = a * b

  var c = SPLITTER * a
  var abig = c - a
  var ahi = c - abig
  var alo = a - ahi

  var d = SPLITTER * b
  var bbig = d - b
  var bhi = d - bbig
  var blo = b - bhi

  var err1 = x - (ahi * bhi)
  var err2 = err1 - (alo * bhi)
  var err3 = err2 - (ahi * blo)

  var y = alo * blo - err3

  if(result) {
    result[0] = y
    result[1] = x
    return result
  }

  return [ y, x ]
}
},{}],179:[function(require,module,exports){
"use strict"

module.exports = fastTwoSum

function fastTwoSum(a, b, result) {
	var x = a + b
	var bv = x - a
	var av = x - bv
	var br = b - bv
	var ar = a - av
	if(result) {
		result[0] = ar + br
		result[1] = x
		return result
	}
	return [ar+br, x]
}
},{}],180:[function(require,module,exports){
(function (global){(function (){
'use strict'

var bits = require('bit-twiddle')
var dup = require('dup')
var Buffer = require('buffer').Buffer

//Legacy pool support
if(!global.__TYPEDARRAY_POOL) {
  global.__TYPEDARRAY_POOL = {
      UINT8     : dup([32, 0])
    , UINT16    : dup([32, 0])
    , UINT32    : dup([32, 0])
    , BIGUINT64 : dup([32, 0])
    , INT8      : dup([32, 0])
    , INT16     : dup([32, 0])
    , INT32     : dup([32, 0])
    , BIGINT64  : dup([32, 0])
    , FLOAT     : dup([32, 0])
    , DOUBLE    : dup([32, 0])
    , DATA      : dup([32, 0])
    , UINT8C    : dup([32, 0])
    , BUFFER    : dup([32, 0])
  }
}

var hasUint8C = (typeof Uint8ClampedArray) !== 'undefined'
var hasBigUint64 = (typeof BigUint64Array) !== 'undefined'
var hasBigInt64 = (typeof BigInt64Array) !== 'undefined'
var POOL = global.__TYPEDARRAY_POOL

//Upgrade pool
if(!POOL.UINT8C) {
  POOL.UINT8C = dup([32, 0])
}
if(!POOL.BIGUINT64) {
  POOL.BIGUINT64 = dup([32, 0])
}
if(!POOL.BIGINT64) {
  POOL.BIGINT64 = dup([32, 0])
}
if(!POOL.BUFFER) {
  POOL.BUFFER = dup([32, 0])
}

//New technique: Only allocate from ArrayBufferView and Buffer
var DATA    = POOL.DATA
  , BUFFER  = POOL.BUFFER

exports.free = function free(array) {
  if(Buffer.isBuffer(array)) {
    BUFFER[bits.log2(array.length)].push(array)
  } else {
    if(Object.prototype.toString.call(array) !== '[object ArrayBuffer]') {
      array = array.buffer
    }
    if(!array) {
      return
    }
    var n = array.length || array.byteLength
    var log_n = bits.log2(n)|0
    DATA[log_n].push(array)
  }
}

function freeArrayBuffer(buffer) {
  if(!buffer) {
    return
  }
  var n = buffer.length || buffer.byteLength
  var log_n = bits.log2(n)
  DATA[log_n].push(buffer)
}

function freeTypedArray(array) {
  freeArrayBuffer(array.buffer)
}

exports.freeUint8 =
exports.freeUint16 =
exports.freeUint32 =
exports.freeBigUint64 =
exports.freeInt8 =
exports.freeInt16 =
exports.freeInt32 =
exports.freeBigInt64 =
exports.freeFloat32 = 
exports.freeFloat =
exports.freeFloat64 = 
exports.freeDouble = 
exports.freeUint8Clamped = 
exports.freeDataView = freeTypedArray

exports.freeArrayBuffer = freeArrayBuffer

exports.freeBuffer = function freeBuffer(array) {
  BUFFER[bits.log2(array.length)].push(array)
}

exports.malloc = function malloc(n, dtype) {
  if(dtype === undefined || dtype === 'arraybuffer') {
    return mallocArrayBuffer(n)
  } else {
    switch(dtype) {
      case 'uint8':
        return mallocUint8(n)
      case 'uint16':
        return mallocUint16(n)
      case 'uint32':
        return mallocUint32(n)
      case 'int8':
        return mallocInt8(n)
      case 'int16':
        return mallocInt16(n)
      case 'int32':
        return mallocInt32(n)
      case 'float':
      case 'float32':
        return mallocFloat(n)
      case 'double':
      case 'float64':
        return mallocDouble(n)
      case 'uint8_clamped':
        return mallocUint8Clamped(n)
      case 'bigint64':
        return mallocBigInt64(n)
      case 'biguint64':
        return mallocBigUint64(n)
      case 'buffer':
        return mallocBuffer(n)
      case 'data':
      case 'dataview':
        return mallocDataView(n)

      default:
        return null
    }
  }
  return null
}

function mallocArrayBuffer(n) {
  var n = bits.nextPow2(n)
  var log_n = bits.log2(n)
  var d = DATA[log_n]
  if(d.length > 0) {
    return d.pop()
  }
  return new ArrayBuffer(n)
}
exports.mallocArrayBuffer = mallocArrayBuffer

function mallocUint8(n) {
  return new Uint8Array(mallocArrayBuffer(n), 0, n)
}
exports.mallocUint8 = mallocUint8

function mallocUint16(n) {
  return new Uint16Array(mallocArrayBuffer(2*n), 0, n)
}
exports.mallocUint16 = mallocUint16

function mallocUint32(n) {
  return new Uint32Array(mallocArrayBuffer(4*n), 0, n)
}
exports.mallocUint32 = mallocUint32

function mallocInt8(n) {
  return new Int8Array(mallocArrayBuffer(n), 0, n)
}
exports.mallocInt8 = mallocInt8

function mallocInt16(n) {
  return new Int16Array(mallocArrayBuffer(2*n), 0, n)
}
exports.mallocInt16 = mallocInt16

function mallocInt32(n) {
  return new Int32Array(mallocArrayBuffer(4*n), 0, n)
}
exports.mallocInt32 = mallocInt32

function mallocFloat(n) {
  return new Float32Array(mallocArrayBuffer(4*n), 0, n)
}
exports.mallocFloat32 = exports.mallocFloat = mallocFloat

function mallocDouble(n) {
  return new Float64Array(mallocArrayBuffer(8*n), 0, n)
}
exports.mallocFloat64 = exports.mallocDouble = mallocDouble

function mallocUint8Clamped(n) {
  if(hasUint8C) {
    return new Uint8ClampedArray(mallocArrayBuffer(n), 0, n)
  } else {
    return mallocUint8(n)
  }
}
exports.mallocUint8Clamped = mallocUint8Clamped

function mallocBigUint64(n) {
  if(hasBigUint64) {
    return new BigUint64Array(mallocArrayBuffer(8*n), 0, n)
  } else {
    return null;
  }
}
exports.mallocBigUint64 = mallocBigUint64

function mallocBigInt64(n) {
  if (hasBigInt64) {
    return new BigInt64Array(mallocArrayBuffer(8*n), 0, n)
  } else {
    return null;
  }
}
exports.mallocBigInt64 = mallocBigInt64

function mallocDataView(n) {
  return new DataView(mallocArrayBuffer(n), 0, n)
}
exports.mallocDataView = mallocDataView

function mallocBuffer(n) {
  n = bits.nextPow2(n)
  var log_n = bits.log2(n)
  var cache = BUFFER[log_n]
  if(cache.length > 0) {
    return cache.pop()
  }
  return new Buffer(n)
}
exports.mallocBuffer = mallocBuffer

exports.clearCache = function clearCache() {
  for(var i=0; i<32; ++i) {
    POOL.UINT8[i].length = 0
    POOL.UINT16[i].length = 0
    POOL.UINT32[i].length = 0
    POOL.INT8[i].length = 0
    POOL.INT16[i].length = 0
    POOL.INT32[i].length = 0
    POOL.FLOAT[i].length = 0
    POOL.DOUBLE[i].length = 0
    POOL.BIGUINT64[i].length = 0
    POOL.BIGINT64[i].length = 0
    POOL.UINT8C[i].length = 0
    DATA[i].length = 0
    BUFFER[i].length = 0
  }
}

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"bit-twiddle":20,"buffer":30,"dup":43}],181:[function(require,module,exports){
"use strict"; "use restrict";

module.exports = UnionFind;

function UnionFind(count) {
  this.roots = new Array(count);
  this.ranks = new Array(count);
  
  for(var i=0; i<count; ++i) {
    this.roots[i] = i;
    this.ranks[i] = 0;
  }
}

var proto = UnionFind.prototype

Object.defineProperty(proto, "length", {
  "get": function() {
    return this.roots.length
  }
})

proto.makeSet = function() {
  var n = this.roots.length;
  this.roots.push(n);
  this.ranks.push(0);
  return n;
}

proto.find = function(x) {
  var x0 = x
  var roots = this.roots;
  while(roots[x] !== x) {
    x = roots[x]
  }
  while(roots[x0] !== x) {
    var y = roots[x0]
    roots[x0] = x
    x0 = y
  }
  return x;
}

proto.link = function(x, y) {
  var xr = this.find(x)
    , yr = this.find(y);
  if(xr === yr) {
    return;
  }
  var ranks = this.ranks
    , roots = this.roots
    , xd    = ranks[xr]
    , yd    = ranks[yr];
  if(xd < yd) {
    roots[xr] = yr;
  } else if(yd < xd) {
    roots[yr] = xr;
  } else {
    roots[yr] = xr;
    ++ranks[xr];
  }
}
},{}],182:[function(require,module,exports){
"use strict"

function unique_pred(list, compare) {
  var ptr = 1
    , len = list.length
    , a=list[0], b=list[0]
  for(var i=1; i<len; ++i) {
    b = a
    a = list[i]
    if(compare(a, b)) {
      if(i === ptr) {
        ptr++
        continue
      }
      list[ptr++] = a
    }
  }
  list.length = ptr
  return list
}

function unique_eq(list) {
  var ptr = 1
    , len = list.length
    , a=list[0], b = list[0]
  for(var i=1; i<len; ++i, b=a) {
    b = a
    a = list[i]
    if(a !== b) {
      if(i === ptr) {
        ptr++
        continue
      }
      list[ptr++] = a
    }
  }
  list.length = ptr
  return list
}

function unique(list, compare, sorted) {
  if(list.length === 0) {
    return list
  }
  if(compare) {
    if(!sorted) {
      list.sort(compare)
    }
    return unique_pred(list, compare)
  }
  if(!sorted) {
    list.sort()
  }
  return unique_eq(list)
}

module.exports = unique

},{}],183:[function(require,module,exports){
"use strict"

module.exports = createText

var vectorizeText = require("./lib/vtext")
var defaultCanvas = null
var defaultContext = null

if(typeof document !== 'undefined') {
  defaultCanvas = document.createElement('canvas')
  defaultCanvas.width = 8192
  defaultCanvas.height = 1024
  defaultContext = defaultCanvas.getContext("2d")
}

function createText(str, options) {
  if((typeof options !== "object") || (options === null)) {
    options = {}
  }
  return vectorizeText(
    str,
    options.canvas || defaultCanvas,
    options.context || defaultContext,
    options)
}

},{"./lib/vtext":184}],184:[function(require,module,exports){
module.exports = vectorizeText
module.exports.processPixels = processPixels

var surfaceNets = require('surface-nets')
var ndarray = require('ndarray')
var simplify = require('simplify-planar-graph')
var cleanPSLG = require('clean-pslg')
var cdt2d = require('cdt2d')
var toPolygonCrappy = require('planar-graph-to-polyline')

var TAG_bold = "b"
var CHR_bold = 'b|'

var TAG_italic = "i"
var CHR_italic = 'i|'

var TAG_super = "sup"
var CHR_super0 = '+'
var CHR_super = '+1'

var TAG_sub = "sub"
var CHR_sub0 = '-'
var CHR_sub = '-1'

function parseTag(tag, TAG_CHR, str, map) {

  var opnTag =  "<"  + tag + ">"
  var clsTag =  "</" + tag + ">"

  var nOPN = opnTag.length
  var nCLS = clsTag.length

  var isRecursive = (TAG_CHR[0] === CHR_super0) ||
                    (TAG_CHR[0] === CHR_sub0);

  var a = 0
  var b = -nCLS
  while (a > -1) {
    a = str.indexOf(opnTag, a)
    if(a === -1) break

    b = str.indexOf(clsTag, a + nOPN)
    if(b === -1) break

    if(b <= a) break

    for(var i = a; i < b + nCLS; ++i){
      if((i < a + nOPN) || (i >= b)) {
        map[i] = null
        str = str.substr(0, i) + " " + str.substr(i + 1)
      } else {
        if(map[i] !== null) {
          var pos = map[i].indexOf(TAG_CHR[0])
          if(pos === -1) {
            map[i] += TAG_CHR
          } else { // i.e. to handle multiple sub/super-scripts
            if(isRecursive) {
              // i.e to increase the sub/sup number
              map[i] = map[i].substr(0, pos + 1) + (1 + parseInt(map[i][pos + 1])) + map[i].substr(pos + 2)
            }
          }
        }
      }
    }

    var start = a + nOPN
    var remainingStr = str.substr(start, b - start)

    var c = remainingStr.indexOf(opnTag)
    if(c !== -1) a = c
    else a = b + nCLS
  }

  return map
}

function transformPositions(positions, options, size) {
  var align = options.textAlign || "start"
  var baseline = options.textBaseline || "alphabetic"

  var lo = [1<<30, 1<<30]
  var hi = [0,0]
  var n = positions.length
  for(var i=0; i<n; ++i) {
    var p = positions[i]
    for(var j=0; j<2; ++j) {
      lo[j] = Math.min(lo[j], p[j])|0
      hi[j] = Math.max(hi[j], p[j])|0
    }
  }

  var xShift = 0
  switch(align) {
    case "center":
      xShift = -0.5 * (lo[0] + hi[0])
    break

    case "right":
    case "end":
      xShift = -hi[0]
    break

    case "left":
    case "start":
      xShift = -lo[0]
    break

    default:
      throw new Error("vectorize-text: Unrecognized textAlign: '" + align + "'")
  }

  var yShift = 0
  switch(baseline) {
    case "hanging":
    case "top":
      yShift = -lo[1]
    break

    case "middle":
      yShift = -0.5 * (lo[1] + hi[1])
    break

    case "alphabetic":
    case "ideographic":
      yShift = -3 * size
    break

    case "bottom":
      yShift = -hi[1]
    break

    default:
      throw new Error("vectorize-text: Unrecoginized textBaseline: '" + baseline + "'")
  }

  var scale = 1.0 / size
  if("lineHeight" in options) {
    scale *= +options.lineHeight
  } else if("width" in options) {
    scale = options.width / (hi[0] - lo[0])
  } else if("height" in options) {
    scale = options.height / (hi[1] - lo[1])
  }

  return positions.map(function(p) {
    return [ scale * (p[0] + xShift), scale * (p[1] + yShift) ]
  })
}

function getPixels(canvas, context, rawString, fontSize, lineSpacing, styletags) {

  rawString = rawString.replace(/\n/g, '') // don't accept \n in the input

  if(styletags.breaklines === true) {
    rawString = rawString.replace(/\<br\>/g, '\n') // replace <br> tags with \n in the string
  } else {
    rawString = rawString.replace(/\<br\>/g, ' ') // don't accept <br> tags in the input and replace with space in this case
  }

  var activeStyle = ""
  var map = []
  for(j = 0; j < rawString.length; ++j) {
    map[j] = activeStyle
  }

  if(styletags.bolds === true) map = parseTag(TAG_bold, CHR_bold, rawString, map)
  if(styletags.italics === true) map = parseTag(TAG_italic, CHR_italic, rawString, map)
  if(styletags.superscripts === true) map = parseTag(TAG_super, CHR_super, rawString, map)
  if(styletags.subscripts === true) map = parseTag(TAG_sub, CHR_sub, rawString, map)

  var allStyles = []
  var plainText = ""
  for(j = 0; j < rawString.length; ++j) {
    if(map[j] !== null) {
      plainText += rawString[j]
      allStyles.push(map[j])
    }
  }

  var allTexts = plainText.split('\n')

  var numberOfLines = allTexts.length
  var lineHeight = Math.round(lineSpacing * fontSize)
  var offsetX = fontSize
  var offsetY = fontSize * 2
  var maxWidth = 0
  var minHeight = numberOfLines * lineHeight + offsetY

  if(canvas.height < minHeight) {
    canvas.height = minHeight
  }

  context.fillStyle = "#000"
  context.fillRect(0, 0, canvas.width, canvas.height)

  context.fillStyle = "#fff"
  var i, j, xPos, yPos, zPos
  var nDone = 0

  var buffer = ""
  function writeBuffer() {
    if(buffer !== "") {
      var delta = context.measureText(buffer).width

      context.fillText(buffer, offsetX + xPos, offsetY + yPos)
      xPos += delta
    }
  }

  function getTextFontSize() {
    return "" + Math.round(zPos) + "px ";
  }

  function changeStyle(oldStyle, newStyle) {
    var ctxFont = "" + context.font;

    if(styletags.subscripts === true) {
      var oldIndex_Sub = oldStyle.indexOf(CHR_sub0);
      var newIndex_Sub = newStyle.indexOf(CHR_sub0);

      var oldSub = (oldIndex_Sub > -1) ? parseInt(oldStyle[1 + oldIndex_Sub]) : 0;
      var newSub = (newIndex_Sub > -1) ? parseInt(newStyle[1 + newIndex_Sub]) : 0;

      if(oldSub !== newSub) {
        ctxFont = ctxFont.replace(getTextFontSize(), "?px ")
        zPos *= Math.pow(0.75, (newSub - oldSub))
        ctxFont = ctxFont.replace("?px ", getTextFontSize())
      }
      yPos += 0.25 * lineHeight * (newSub - oldSub);
    }

    if(styletags.superscripts === true) {
      var oldIndex_Super = oldStyle.indexOf(CHR_super0);
      var newIndex_Super = newStyle.indexOf(CHR_super0);

      var oldSuper = (oldIndex_Super > -1) ? parseInt(oldStyle[1 + oldIndex_Super]) : 0;
      var newSuper = (newIndex_Super > -1) ? parseInt(newStyle[1 + newIndex_Super]) : 0;

      if(oldSuper !== newSuper) {
        ctxFont = ctxFont.replace(getTextFontSize(), "?px ")
        zPos *= Math.pow(0.75, (newSuper - oldSuper))
        ctxFont = ctxFont.replace("?px ", getTextFontSize())
      }
      yPos -= 0.25 * lineHeight * (newSuper - oldSuper);
    }

    if(styletags.bolds === true) {
      var wasBold = (oldStyle.indexOf(CHR_bold) > -1)
      var is_Bold = (newStyle.indexOf(CHR_bold) > -1)

      if(!wasBold && is_Bold) {
        if(wasItalic) {
          ctxFont = ctxFont.replace("italic ", "italic bold ")
        } else {
          ctxFont = "bold " + ctxFont
        }
      }
      if(wasBold && !is_Bold) {
        ctxFont = ctxFont.replace("bold ", '')
      }
    }

    if(styletags.italics === true) {
      var wasItalic = (oldStyle.indexOf(CHR_italic) > -1)
      var is_Italic = (newStyle.indexOf(CHR_italic) > -1)

      if(!wasItalic && is_Italic) {
        ctxFont = "italic " + ctxFont
      }
      if(wasItalic && !is_Italic) {
        ctxFont = ctxFont.replace("italic ", '')
      }
    }
    context.font = ctxFont
  }

  for(i = 0; i < numberOfLines; ++i) {
    var txt = allTexts[i] + '\n'
    xPos = 0
    yPos = i * lineHeight
    zPos = fontSize

    buffer = ""
    
    for(j = 0; j < txt.length; ++j) {
      var style = (j + nDone < allStyles.length) ? allStyles[j + nDone] : allStyles[allStyles.length - 1]
      if(activeStyle === style) {
        buffer += txt[j]
      } else {
        writeBuffer()
        buffer = txt[j]

        if(style !== undefined) {
          changeStyle(activeStyle, style)
          activeStyle = style
        }
      }
    }
    writeBuffer()

    nDone += txt.length

    var width = Math.round(xPos + 2 * offsetX) | 0
    if(maxWidth < width) maxWidth = width
  }

  //Cut pixels from image
  var xCut = maxWidth
  var yCut = offsetY + lineHeight * numberOfLines
  var pixels = ndarray(context.getImageData(0, 0, xCut, yCut).data, [yCut, xCut, 4])
  return pixels.pick(-1, -1, 0).transpose(1, 0)
}

function getContour(pixels, doSimplify) {
  var contour = surfaceNets(pixels, 128)
  if(doSimplify) {
    return simplify(contour.cells, contour.positions, 0.25)
  }
  return {
    edges: contour.cells,
    positions: contour.positions
  }
}

function processPixelsImpl(pixels, options, size, simplify) {
  //Extract contour
  var contour = getContour(pixels, simplify)

  //Apply warp to positions
  var positions = transformPositions(contour.positions, options, size)
  var edges     = contour.edges
  var flip = "ccw" === options.orientation

  //Clean up the PSLG, resolve self intersections, etc.
  cleanPSLG(positions, edges)

  //If triangulate flag passed, triangulate the result
  if(options.polygons || options.polygon || options.polyline) {
    var result = toPolygonCrappy(edges, positions)
    var nresult = new Array(result.length)
    for(var i=0; i<result.length; ++i) {
      var loops = result[i]
      var nloops = new Array(loops.length)
      for(var j=0; j<loops.length; ++j) {
        var loop = loops[j]
        var nloop = new Array(loop.length)
        for(var k=0; k<loop.length; ++k) {
          nloop[k] = positions[loop[k]].slice()
        }
        if(flip) {
          nloop.reverse()
        }
        nloops[j] = nloop
      }
      nresult[i] = nloops
    }
    return nresult
  } else if(options.triangles || options.triangulate || options.triangle) {
    return {
      cells: cdt2d(positions, edges, {
        delaunay: false,
        exterior: false,
        interior: true
      }),
      positions: positions
    }
  } else {
    return {
      edges:     edges,
      positions: positions
    }
  }
}

function processPixels(pixels, options, size) {
  try {
    return processPixelsImpl(pixels, options, size, true)
  } catch(e) {}
  try {
    return processPixelsImpl(pixels, options, size, false)
  } catch(e) {}
  if(options.polygons || options.polyline || options.polygon) {
    return []
  }
  if(options.triangles || options.triangulate || options.triangle) {
    return {
      cells: [],
      positions: []
    }
  }
  return {
    edges: [],
    positions: []
  }
}

function vectorizeText(str, canvas, context, options) {
  var size = 64
  var lineSpacing = 1.25
  var styletags = {
    breaklines: false,
    bolds: false,
    italics: false,
    subscripts: false,
    superscripts: false
  }

  if(options) {

    if(options.size &&
       options.size > 0) size =
       options.size

    if(options.lineSpacing &&
       options.lineSpacing > 0) lineSpacing =
       options.lineSpacing

    if(options.styletags &&
       options.styletags.breaklines) styletags.breaklines =
       options.styletags.breaklines ? true : false

    if(options.styletags &&
       options.styletags.bolds) styletags.bolds =
       options.styletags.bolds ? true : false

    if(options.styletags &&
       options.styletags.italics) styletags.italics =
       options.styletags.italics ? true : false

    if(options.styletags &&
       options.styletags.subscripts) styletags.subscripts =
       options.styletags.subscripts ? true : false

    if(options.styletags &&
       options.styletags.superscripts) styletags.superscripts =
       options.styletags.superscripts ? true : false
  }

  context.font = [
    options.fontStyle,
    options.fontVariant,
    options.fontWeight,
    size + "px",
    options.font
  ].filter(function(d) {return d}).join(" ")
  context.textAlign = "start"
  context.textBaseline = "alphabetic"
  context.direction = "ltr"

  var pixels = getPixels(canvas, context, str, size, lineSpacing, styletags)

  return processPixels(pixels, options, size)
}

},{"cdt2d":31,"clean-pslg":36,"ndarray":86,"planar-graph-to-polyline":93,"simplify-planar-graph":115,"surface-nets":118}],185:[function(require,module,exports){
module.exports = require('cwise-compiler')({
    args: ['array', {
        offset: [1],
        array: 0
    }, 'scalar', 'scalar', 'index'],
    pre: {
        "body": "{}",
        "args": [],
        "thisVars": [],
        "localVars": []
    },
    post: {
        "body": "{}",
        "args": [],
        "thisVars": [],
        "localVars": []
    },
    body: {
        "body": "{\n        var _inline_1_da = _inline_1_arg0_ - _inline_1_arg3_\n        var _inline_1_db = _inline_1_arg1_ - _inline_1_arg3_\n        if((_inline_1_da >= 0) !== (_inline_1_db >= 0)) {\n          _inline_1_arg2_.push(_inline_1_arg4_[0] + 0.5 + 0.5 * (_inline_1_da + _inline_1_db) / (_inline_1_da - _inline_1_db))\n        }\n      }",
        "args": [{
            "name": "_inline_1_arg0_",
            "lvalue": false,
            "rvalue": true,
            "count": 1
        }, {
            "name": "_inline_1_arg1_",
            "lvalue": false,
            "rvalue": true,
            "count": 1
        }, {
            "name": "_inline_1_arg2_",
            "lvalue": false,
            "rvalue": true,
            "count": 1
        }, {
            "name": "_inline_1_arg3_",
            "lvalue": false,
            "rvalue": true,
            "count": 2
        }, {
            "name": "_inline_1_arg4_",
            "lvalue": false,
            "rvalue": true,
            "count": 1
        }],
        "thisVars": [],
        "localVars": ["_inline_1_da", "_inline_1_db"]
    },
    funcName: 'zeroCrossings'
})

},{"cwise-compiler":39}],186:[function(require,module,exports){
"use strict"

module.exports = findZeroCrossings

var core = require("./lib/zc-core")

function findZeroCrossings(array, level) {
  var cross = []
  level = +level || 0.0
  core(array.hi(array.shape[0]-1), cross, level)
  return cross
}
},{"./lib/zc-core":185}],187:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _sandbox = _interopRequireDefault(require("./lib/sandbox.js"));

var _arrayUtils = _interopRequireDefault(require("./lib/array-utils.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// handles code evaluation and attaching relevant objects to global and evaluation contexts
class EvalSandbox {
  constructor(parent, makeGlobal, userProps = []) {
    this.makeGlobal = makeGlobal;
    this.sandbox = (0, _sandbox.default)(parent);
    this.parent = parent;
    var properties = Object.keys(parent);
    properties.forEach(property => this.add(property));
    this.userProps = userProps;
  }

  add(name) {
    if (this.makeGlobal) window[name] = this.parent[name]; // this.sandbox.addToContext(name, `parent.${name}`)
  } // sets on window as well as synth object if global (not needed for objects, which can be set directly)


  set(property, value) {
    if (this.makeGlobal) {
      window[property] = value;
    }

    this.parent[property] = value;
  }

  tick() {
    if (this.makeGlobal) {
      this.userProps.forEach(property => {
        this.parent[property] = window[property];
      }); //  this.parent.speed = window.speed
    } else {}
  }

  eval(code) {
    this.sandbox.eval(code);
  }

}

var _default = EvalSandbox;
exports.default = _default;

},{"./lib/array-utils.js":199,"./lib/sandbox.js":204}],188:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = formatArguments;

var _arrayUtils = _interopRequireDefault(require("./lib/array-utils.js"));

var _types = require("./types.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// [WIP] how to treat different dimensions (?)
const DEFAULT_CONVERSIONS = {
  float: {
    'vec4': {
      name: 'sum',
      args: [[1, 1, 1, 1]]
    },
    'vec2': {
      name: 'sum',
      args: [[1, 1]]
    }
  }
};

function fillArrayWithDefaults(arr, len) {
  // fill the array with default values if it's too short
  while (arr.length < len) {
    if (arr.length === 3) {
      // push a 1 as the default for .a in vec4
      arr.push(1.0);
    } else {
      arr.push(0.0);
    }
  }

  return arr.slice(0, len);
}

const ensure_decimal_dot = val => {
  val = val.toString();

  if (val.indexOf('.') < 0) {
    val += '.';
  }

  return val;
};

function formatArguments(transform, startIndex, synthContext) {
  const defaultArgs = transform.transform.inputs;
  const userArgs = transform.userArgs;
  const {
    generators
  } = transform.synth;
  const {
    src
  } = generators; // depends on synth having src() function

  return defaultArgs.map((input, index) => {
    const typedArg = {
      value: input.default,
      type: input.type,
      //
      isUniform: false,
      name: input.name,
      vecLen: 0 //  generateGlsl: null // function for creating glsl

    };
    if (typedArg.type === 'float') typedArg.value = ensure_decimal_dot(input.default);

    if (input.type.startsWith('vec')) {
      try {
        typedArg.vecLen = Number.parseInt(input.type.substr(3));
      } catch (e) {
        console.log(`Error determining length of vector input type ${input.type} (${input.name})`);
      }
    } // if user has input something for this argument


    if (userArgs.length > index) {
      typedArg.value = userArgs[index];

      if (typeof typedArg.value === 'function' && typedArg.value.name !== 'reglTexture2D' && typedArg.value.name !== 'reglFramebuffer') {
        typedArg.value = getFunctionValue(typedArg.value, input);
        typedArg.isUniform = true;
      } else if (typedArg.value.constructor === Array) {
        typedArg.value = getArrayValue(typedArg.value, input, typedArg.vecLen);
        typedArg.isUniform = true; // }
      }
    }

    if (startIndex < 0) {} else {
      if (typedArg.value && typedArg.value.transforms) {
        const final_transform = typedArg.value.transforms[typedArg.value.transforms.length - 1];

        if (final_transform.transform.glsl_return_type !== input.type) {
          const defaults = DEFAULT_CONVERSIONS[input.type];

          if (typeof defaults !== 'undefined') {
            const default_def = defaults[final_transform.transform.glsl_return_type];

            if (typeof default_def !== 'undefined') {
              const {
                name,
                args
              } = default_def;
              typedArg.value = typedArg.value[name](...args);
            }
          }
        }

        typedArg.isUniform = false;
      } else if (typedArg.type === 'float' && typeof typedArg.value === 'number') {
        typedArg.value = ensure_decimal_dot(typedArg.value);
      } else if (typedArg.type.startsWith('vec') && typeof typedArg.value !== 'function' && !typedArg.value.getTexture) {
        typedArg.isUniform = false;

        if (Array.isArray(typedArg.value) || typedArg.value instanceof Float32Array || typedArg.value instanceof Uint8Array) {
          // todo: accept smaller arrays?
          typedArg.value = `${typedArg.type}(${typedArg.value.map(ensure_decimal_dot).join(', ')})`;
        } else if (typeof typedArg.value === 'number') {
          const length = parseInt(typedArg.type.substr(-1));
          const arr = Array(length).fill(typedArg.value);
          typedArg.value = `${typedArg.type}(${arr.map(ensure_decimal_dot).join(', ')})`;
        }
      } else if (input.type === 'sampler2D') {
        // typedArg.tex = typedArg.value
        var x = typedArg.value;
        typedArg.value = x.getTexture ? () => x.getTexture() : x;
        typedArg.isUniform = true;
      } else {
        // if passing in a texture reference, when function asks for vec4, convert to vec4
        if (typedArg.value.getTexture || typedArg.value.name === 'reglTexture2D') {
          var x1 = typedArg.value;

          if (input.type === 'vec4') {
            typedArg.value = src(x1);
          } else {
            let getter = _types.getLookup[input.type];
            typedArg.value = src(x1)[getter];
          }

          typedArg.isUniform = false;
        }
      } // add tp uniform array if is a function that will pass in a different value on each render frame,
      // or a texture/ external source


      if (input.isUniform) typedArg.isUniform = input.isUniform;

      if (typedArg.isUniform) {
        typedArg.name += startIndex; //  shaderParams.uniforms.push(typedArg)
      }
    }

    return typedArg;
  });
}

function getFunctionValue(value, input) {
  // if (typedArg.vecLen > 0) { // expected input is a vector, not a scalar
  //    typedArg.value = (context, props, batchId) => (fillArrayWithDefaults(userArgs[index](props), typedArg.vecLen))
  // } else {
  return (context, props, batchId) => {
    try {
      const val = value(props);

      if (typeof val === 'number') {
        return val;
      } else {
        console.warn('function does not return a number', value);
      }

      return input.default;
    } catch (e) {
      console.warn('ERROR', e);
      return input.default;
    }
  }; //  }
}

function getArrayValue(value, input, vecLen = 0) {
  //   if (typedArg.vecLen > 0) { // expected input is a vector, not a scalar
  //     typedArg.isUniform = true
  //     typedArg.value = fillArrayWithDefaults(typedArg.value, typedArg.vecLen)
  //  } else {
  //  console.log("is Array")
  // filter out values that are not a number
  // const filteredArray = userArgs[index].filter((val) => typeof val === 'number')
  // typedArg.value = (context, props, batchId) => arrayUtils.getValue(filteredArray)(props)
  if (vecLen) {
    return (context, props, batchId) => {
      const values = Array(vecLen);

      for (let i = 0; i < vecLen; i++) {
        const v = value[i];
        const defaultValue = input.default ? input.default.constructor === Array ? input.default[i] : input.default : 0;

        if (typeof v === 'function') {
          values[i] = getFunctionValue(v, {
            default: defaultValue
          })(context, props, batchId);
        } else if (Array.isArray(v)) {
          values[i] = _arrayUtils.default.getValue(v)(props);
        } else if (typeof v !== 'undefined') {
          values[i] = v;
        } else {
          values[i] = defaultValue;
        }
      }

      return values;
    };
  } else {
    return (context, props, batchId) => _arrayUtils.default.getValue(value)(props);
  }
}

},{"./lib/array-utils.js":199,"./types.js":209}],189:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _formatArguments = _interopRequireDefault(require("./format-arguments.js"));

var _types = require("./types.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// converts a tree of javascript functions to a shader
function _default(source) {
  return generateParams(createParams(), source, source.transforms);
}

function createParams(options = {}) {
  return Object.assign({
    uniforms: [],
    // list of uniforms used in shader
    glslFunctions: [],
    // list of functions used in shader
    fragColor: '',
    position: ''
  }, options);
}

function generateParams(shaderParams, source, transforms) {
  if (!shaderParams.fragColor) {
    shaderParams.fragColor = generateGlsl(source, transforms, shaderParams)('st', 'vec4', 1.0);
  }

  if (!shaderParams.position && !shaderParams.combine) {
    shaderParams.position = generateGlsl(source, transforms.filter(tr => {
      return tr.transform.type !== 'combine' && tr.transform.type !== 'clear';
    }), shaderParams)('st', 'vec4', 1.0); // todo: should be vec3
  } // remove uniforms with duplicate names


  if (shaderParams.uniforms) {
    let uniforms = {};
    shaderParams.uniforms.forEach(uniform => uniforms[uniform.name] = uniform);
    shaderParams.uniforms = Object.values(uniforms);
  }

  return shaderParams;
} // recursive function for generating shader string from object containing functions and user arguments. Order of functions in string depends on type of function
// to do: improve variable names


function generateGlsl(source, transforms, shaderParams) {
  // transform function that outputs a shader string corresponding to gl_FragColor
  const empty = () => '';

  var fragColor = empty;
  transforms.map((transform, i) => {
    if (transform.transform.type === 'glsl') {
      fragColor = () => transform.userArgs[0];

      return;
    }

    if (transform.transform.type === 'vert' && !source.geometry) {
      source.setGeometry(transform.userArgs[0]);
      transform.userArgs = transform.userArgs.slice(1);
    }

    var inputs = (0, _formatArguments.default)(transform, shaderParams.uniforms.length);

    if (transform.transform.type === 'clear') {
      source.passes.unshift({
        clear: transform.transform.name,
        userArgs: inputs.map(i => i.value)
      });
      return;
    }

    inputs.forEach(input => {
      if (input.isUniform) shaderParams.uniforms.push(input);
    }); // add new glsl function to running list of functions

    if (!contains(transform, shaderParams.glslFunctions)) shaderParams.glslFunctions.push(transform); // current function for generating frag color shader code

    var f0 = fragColor;

    if (transform.transform.type === 'src' || transform.transform.type === 'vert') {
      fragColor = (uv, returnType, alpha) => `${shaderString(uv, transform, inputs, shaderParams, returnType, alpha)}`;
    } else if (transform.transform.type === 'coord') {
      fragColor = f0 === empty ? (uv, returnType, alpha) => `${shaderString(uv, transform, inputs, shaderParams, returnType, alpha)}` : (uv, returnType, alpha) => `${f0(`${shaderString(uv, transform, inputs, shaderParams, 'vec2')}`, returnType, alpha)}`;
    } else if (transform.transform.type === 'color') {
      fragColor = (uv, returnType, alpha) => `${shaderString(`${f0(uv, 'vec4')}`, transform, inputs, shaderParams, returnType, alpha)}`;
    } else if (transform.transform.type === 'combine') {
      // combining two generated shader strings (i.e. for blend, mult, add funtions)
      if (source.transforms[0].transform.vert || inputs[0].value && inputs[0].value.transforms && inputs[0].value.transforms[0].transform.vert) {
        const params = Object.assign({}, shaderParams, {
          fragColor: fragColor('st', 'vec4', 1.0) || 'vec4(0)'
        });
        Object.assign(shaderParams, createParams({
          glslFunctions: [transform],
          combine: true
        }));
        const trans = source.transforms.slice(0, source.transforms.indexOf(transform));
        source.passes.unshift(source.createPass(generateParams(params, source, trans), {
          framebuffer: source.output.temp[0]
        }));
        const temp0 = src(source.output.temp[0]);

        f0 = (uv, returnType, alpha) => `${generateGlsl(temp0, temp0.transforms, shaderParams)(uv, returnType, alpha)}`;
      }

      var f1;

      if (inputs[0].value && inputs[0].value.transforms) {
        if (inputs[0].value.transforms[0].transform.vert || source.transforms[0].transform.vert) {
          inputs[0].value.output = source.output;
          source.passes.unshift(...inputs[0].value.compile({
            framebuffer: source.output.temp[1]
          }));
          const temp1 = src(source.output.temp[1]);

          f1 = (uv, returnType, alpha) => `${generateGlsl(temp1, temp1.transforms, shaderParams)(uv, returnType, alpha)}`;
        } else {
          f1 = (uv, returnType, alpha) => `${generateGlsl(inputs[0].value, inputs[0].value.transforms, shaderParams)(uv, returnType, alpha)}`;
        }
      } else {
        f1 = inputs[0].isUniform ? () => inputs[0].name : () => inputs[0].value;
      }

      fragColor = (uv, returnType, alpha) => `${shaderString(`${f0(uv, 'vec4')}, ${f1(uv, 'vec4')}`, transform, inputs.slice(1), shaderParams, returnType, alpha)}`;
    } else if (transform.transform.type === 'combineCoord') {
      // combining two generated shader strings (i.e. for modulate functions)
      var f1 = inputs[0].value && inputs[0].value.transforms ? (uv, returnType, alpha) => `${generateGlsl(inputs[0].value, inputs[0].value.transforms, shaderParams)(uv, returnType, alpha)}` : inputs[0].isUniform ? () => inputs[0].name : () => inputs[0].value;

      fragColor = (uv, returnType, alpha) => `${f0(`${shaderString(`${uv}, ${f1(uv, 'vec4')}`, transform, inputs.slice(1), shaderParams, 'vec2')}`, returnType, alpha)}`;
    } else {
      console.warn('no support for type: ' + transform.transform.type);
    }
  });

  if (source.getter) {
    var f2 = fragColor;

    fragColor = (uv, returnType, alpha) => (0, _types.castType)(f2(uv, returnType, alpha) + `.${source.getter}`, _types.getTypeLookup[source.getter], returnType, 1.0);
  }

  return fragColor;
} // assembles a shader string containing the arguments and the function name, i.e. 'osc(uv, frequency)'


function shaderString(uv, transform, inputs, shaderParams, returnType, alpha = 0.0) {
  const str = inputs.map(input => {
    if (input.isUniform) {
      return input.name;
    } else if (input.value && input.value.transforms) {
      // this by definition needs to be a generator, hence we start with 'st' as the initial value for generating the glsl fragment
      if (!input.value.getter && _types.typeLookup[input.value.transforms[0].transform.type] !== input.type) {
        // todo: add getter only if input.type is larger
        input.value.getter = _types.getLookup[input.type];
      }

      return `${generateGlsl(input.value, input.value.transforms, shaderParams)('st', input.type)}`;
    }

    return input.value;
  }).reduce((p, c) => `${p}, ${c}`, '');
  var func = `${transform.transform.glslName}(${uv}${str})`;
  return (0, _types.castType)(func, _types.typeLookup[transform.transform.type].returnType, returnType, alpha);
} // check whether array


function contains(object, arr) {
  for (var i = 0; i < arr.length; i++) {
    if (object.name == arr[i].name) return true;
  }

  return false;
}

},{"./format-arguments.js":188,"./types.js":209}],190:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _glslSource = _interopRequireDefault(require("./glsl-source.js"));

var _glslFunctions = _interopRequireDefault(require("./glsl/glsl-functions.js"));

var _vertFunctions = _interopRequireDefault(require("./glsl/vert-functions.js"));

var _types = require("./types.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class GeneratorFactory {
  constructor({
    defaultUniforms,
    defaultOutput,
    extendTransforms = [],
    changeListener = () => {}
  } = {}) {
    this.defaultOutput = defaultOutput;
    this.defaultUniforms = defaultUniforms;
    this.changeListener = changeListener;
    this.extendTransforms = extendTransforms;
    this.generators = {};
    this.utils = {};
    this.init();
  }

  init() {
    const functions = (0, _glslFunctions.default)();
    this.glslTransforms = {};
    this.generators = Object.entries(this.generators).reduce((prev, [method, transform]) => {
      this.changeListener({
        type: 'remove',
        synth: this,
        method
      });
      return prev;
    }, {});

    this.sourceClass = (() => {
      return class extends _glslSource.default {};
    })(); // add user definied transforms


    if (Array.isArray(this.extendTransforms)) {
      functions.concat(this.extendTransforms);
    } else if (typeof this.extendTransforms === 'object' && this.extendTransforms.type) {
      functions.push(this.extendTransforms);
    }

    functions.map(transform => this.setFunction(transform));
    const functions2 = (0, _vertFunctions.default)(this.generators); // sandbox is not ready at this moment yet

    functions2.map(transform => this.setFunction(transform));
  }

  _addMethod(method, transform) {
    const self = this;
    this.glslTransforms[method] = transform;
    let retval = undefined;

    if (['src', 'coord', 'clear', 'vert', 'glsl'].indexOf(transform.type) > -1) {
      const func = (...args) => new this.sourceClass({
        name: method,
        transform: transform,
        userArgs: args,
        defaultOutput: this.defaultOutput,
        defaultUniforms: this.defaultUniforms,
        synth: self,
        utils: this.utils
      });

      this.generators[method] = func;
      this.changeListener({
        type: 'add',
        synth: this,
        method
      });
      retval = func;
    }

    this.sourceClass.prototype[method] = function (...args) {
      const prevTransform = this.transforms[this.transforms.length - 1].transform;

      if (prevTransform.type === 'clear' || transform.type !== 'src' && transform.type !== 'vert') {
        this.transforms.push({
          name: method,
          transform: transform,
          userArgs: args,
          synth: self
        });
      } else {
        console.error(`transform ${transform.name} not allowed after ${prevTransform.name}`);
      }

      return this;
    };

    return retval;
  }

  setFunction(obj) {
    // todo: remove utils and instead manage function dependencies
    if (obj.type === 'util') this.utils[obj.name] = obj;
    var processedGlsl = processFunction(obj);
    if (processedGlsl) this._addMethod(obj.name, processedGlsl);
  }

} // expects glsl of format
// {
//   name: 'osc', // name that will be used to access function as well as within glsl
//   type: 'src', // can be src: vec4(vec2 _st), coord: vec2(vec2 _st), color: vec4(vec4 _c0), combine: vec4(vec4 _c0, vec4 _c1), combineCoord: vec2(vec2 _st, vec4 _c0)
//   inputs: [
//     {
//       name: 'freq',
//       type: 'float', // 'float'   //, 'texture', 'vec4'
//       default: 0.2
//     },
//     {
//           name: 'sync',
//           type: 'float',
//           default: 0.1
//         },
//         {
//           name: 'offset',
//           type: 'float',
//           default: 0.0
//         }
//   ],
//  glsl: `
//    vec2 st = _st;
//    float r = sin((st.x-offset*2/freq+time*sync)*freq)*0.5  + 0.5;
//    float g = sin((st.x+time*sync)*freq)*0.5 + 0.5;
//    float b = sin((st.x+offset/freq+time*sync)*freq)*0.5  + 0.5;
//    return vec4(r, g, b, 1.0);
// `
// }
// // generates glsl function:
// `vec4 osc(vec2 _st, float freq, float sync, float offset){
//  vec2 st = _st;
//  float r = sin((st.x-offset*2/freq+time*sync)*freq)*0.5  + 0.5;
//  float g = sin((st.x+time*sync)*freq)*0.5 + 0.5;
//  float b = sin((st.x+offset/freq+time*sync)*freq)*0.5  + 0.5;
//  return vec4(r, g, b, 1.0);
// }`


function processFunction(obj) {
  obj.glslName || (obj.glslName = obj.name);
  if (obj.type === 'clear' || obj.type === 'glsl') return obj;else if (obj.type === 'util') {
    return processGlsl(obj, obj.returnType);
  }
  let t = _types.typeLookup[obj.type];

  if (t) {
    return processGlsl(obj, t.returnType, t.args);
  } else {
    console.warn(`type ${obj.type} not recognized`, obj);
  }
}

function processGlsl(obj, returnType, args = []) {
  let baseArgs = args.map(arg => arg).join(", ");
  let customArgs = (obj.inputs || (obj.inputs = [])).map(input => `${input.type} ${input.name}`).join(', ');
  let allArgs = `${baseArgs}${customArgs.length > 0 ? ', ' + customArgs : ''}`;
  const func = `${returnType || ''} ${obj.glslName}(${allArgs}`;

  const fixOrWrap = glsl => {
    if (glsl.indexOf(func) === -1) {
      if (glsl.indexOf(`${returnType} main(${allArgs}`) > -1) {
        return glsl.replace(`${returnType} main(${allArgs}`, func);
      } else {
        if (obj.primitive) {
          let primitiveFn = obj.primitive.split(" ").join("");

          if (glsl.indexOf(primitiveFn) > -1) {
            return glsl.replace(`${returnType} ${primitiveFn}(${allArgs}`, func);
          }
        }

        if (returnType) {
          return `
  ${func}) {
      ${glsl}
  }
`;
        }
      }
    }

    return glsl;
  };

  obj.glsl = fixOrWrap(obj.glsl);

  if (obj.vert) {
    obj.vert = fixOrWrap(obj.vert);
  } // add extra input to beginning for backward combatibility @todo update compiler so this is no longer necessary


  if (obj.type === 'combine' || obj.type === 'combineCoord') obj.inputs.unshift({
    name: 'color',
    type: 'vec4'
  });
  return Object.assign({}, obj, {
    returnType
  });
}

var _default = GeneratorFactory;
exports.default = _default;

},{"./glsl-source.js":191,"./glsl/glsl-functions.js":193,"./glsl/vert-functions.js":195,"./types.js":209}],191:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _generateGlsl = _interopRequireDefault(require("./generate-glsl.js"));

var _utilityFunctions = _interopRequireDefault(require("./glsl/utility-functions.js"));

var _vectorizeText = _interopRequireDefault(require("vectorize-text"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var GlslSource = function (obj) {
  this.transforms = [];
  this.transforms.push(obj);
  this.defaultOutput = obj.defaultOutput;
  this.output = null;
  this.synth = obj.synth;
  this.type = 'GlslSource';
  this.defaultUniforms = obj.defaultUniforms;
  this.utils = Object.assign({}, _utilityFunctions.default, obj.utils);
  this.blendMode = typeof obj.transform.blendMode !== 'undefined' ? obj.transform.blendMode : false;
  this.lineWidth = obj.transform.lineWidth || 1;
  this._viewport = {};
  return this;
};

GlslSource.prototype.addTransform = function (obj) {
  this.transforms.push(obj);
};

GlslSource.prototype.out = function (_output) {
  var output = _output || this.defaultOutput;
  this.output = output;
  var glsl = this.compile();
  this.synth.currentFunctions = [];
  if (output) try {
    output.render(glsl);
  } catch (error) {
    console.log('shader could not compile', error);
  }
  return this;
};

GlslSource.prototype.tex = function (_output, options = {}) {
  if (!this.output) {
    this.out(_output);
  }

  return this.output.renderTexture(options);
};

GlslSource.prototype.compile = function (options = {}) {
  this.passes = [];
  this.passes.push(this.createPass((0, _generateGlsl.default)(this), options));
  return this.passes;
};

GlslSource.prototype.getInfo = function () {
  if (this.transforms.length > 0) {
    var shaderInfo = (0, _generateGlsl.default)(this);
    var uniforms = {};
    shaderInfo.uniforms.forEach(uniform => {
      uniforms[uniform.name] = uniform.value;
    });
    return {
      shaderInfo,
      utilityGlsl: this.utils,
      // todo: differs from compile
      vert: this.transforms[0].transform.vert,
      // todo: differs from compile
      attributes: this.transforms[0].transform.attributes,
      // todo: differs from compile
      attributesCount: this.transforms[0].transform.attributesCount,
      primitive: this.transforms[0].transform.primitive,
      uniforms: Object.assign({}, this.defaultUniforms, uniforms)
    };
  }
};

GlslSource.prototype.createPass = function (shaderInfo, options = {}) {
  var uniforms = {};
  shaderInfo.uniforms.forEach(uniform => {
    uniforms[uniform.name] = uniform.value;
  });

  if (shaderInfo.combine) {
    return {
      vert: GlslSource.compileVert(this.defaultOutput.precision, false, {
        glslName: 'combine'
      }, shaderInfo),
      userArgs: this.transforms[0].userArgs,
      // todo: fix or delete
      // blendMode: this.blendMode,
      lineWidth: this.lineWidth,
      frag: GlslSource.compileFrag(this.defaultOutput.precision, shaderInfo, this.utils),
      uniforms: Object.assign({}, this.defaultUniforms, uniforms),
      viewport: this._viewport
    };
  }

  const vertTransform = this.transforms[0].transform.type === 'clear' ? this.transforms[1] : this.transforms[0];
  return Object.assign({
    vert: GlslSource.compileVert(this.defaultOutput.precision, true, vertTransform.transform, shaderInfo, this.utils),
    primitive: vertTransform.transform.primitive,
    userArgs: vertTransform.userArgs,
    geometry: this.geometry,
    blendMode: this.blendMode,
    lineWidth: this.lineWidth,
    frag: GlslSource.compileFrag(this.defaultOutput.precision, shaderInfo, this.utils),
    uniforms: Object.assign({}, this.defaultUniforms, uniforms),
    viewport: this._viewport
  }, options);
};

GlslSource.compileHeader = function (precision, uniforms = {}, utils = {}) {
  return `
  precision ${precision} float;
  ${Object.values(uniforms).map(uniform => {
    let type = uniform.type;

    switch (uniform.type) {
      case 'texture':
        type = 'sampler2D';
        break;
    }

    return `
      uniform ${type} ${uniform.name};`;
  }).join('')}
  uniform float time;
  uniform vec2 resolution;
  varying vec3 vposition;
  varying vec2 vuv;
  varying vec3 vnormal;
  uniform sampler2D prevBuffer;
  
  ${Object.values(utils).map(transform => {
    //  console.log(transform.glsl)
    return `
            ${transform.glsl}
          `;
  }).join('')}
  `;
};

GlslSource.compileFrag = function (precision, shaderInfo, utils) {
  const header = this.compileHeader(precision, shaderInfo.uniforms, utils);
  return header + `
  
  ${shaderInfo.glslFunctions.map(transform => {
    return `
            ${transform.transform.glsl}
          `;
  }).join('')}

  void main () {
    vec4 c = vec4(1, 0, 0, 1);
    //vec2 st = gl_FragCoord.xy/resolution.xy;
    vec2 st = vuv;
    gl_FragColor = ${shaderInfo.fragColor};
  }
  `;
};

GlslSource.compileVert = function (precision, useCamera, transform, shaderInfo, utils) {
  const useUV = typeof transform.useUV !== 'undefined' ? transform.useUV : !transform.primitive || ['points', 'lines', 'line strip', 'line loop'].indexOf(transform.primitive) === -1;
  const useNormal = typeof transform.useNormal !== 'undefined' ? transform.useNormal : transform.type === 'vert' && (!transform.primitive || ['points', 'lines', 'line strip', 'line loop'].indexOf(transform.primitive) === -1);
  let vertHeader = `
  precision ${precision} float;
  uniform mat4 projection, view;
  attribute vec3 position;
  ${useUV ? 'attribute vec2 uv;' : ''}
  ${useNormal ? 'attribute vec3 normal;' : ''}
  varying vec3 vposition;
  varying vec2 vuv;
  varying vec3 vnormal;
  `;
  let vertFn = `
  void ${transform.glslName}() {
    vposition = position;
    gl_Position = ${useCamera ? 'projection * view * ' : ''}vec4(position, 1.0);
  } 
  `;
  let vertCall = `${transform.glslName}();`;

  if (transform.vert) {
    vertHeader = this.compileHeader(precision, shaderInfo.uniforms, utils) + `
    uniform mat4 projection, view;
    attribute vec3 position;
    ${useUV ? 'attribute vec2 uv;' : ''}
    ${useNormal ? 'attribute vec3 normal;' : ''}
    
    ${shaderInfo.glslFunctions.map(trans => {
      if (trans.transform.name !== transform.name) {
        return `
            ${trans.transform.glsl}
          `;
      }
    }).join('')}
    `;
    vertFn = transform.vert;
    vertCall = `
    ${useUV ? 'vec2 st = uv;' : 'vec2 st = position.xy;'}
    vposition = ${shaderInfo.position}.xyz;
    gl_Position = projection * view * vec4(vposition, 1.0);
    `;
  }

  return vertHeader + `
    
  ${vertFn}

  void main () {
    ${useUV ? 'vuv = uv;' : ''}
    ${useNormal ? 'vnormal = normal;' : ''}
    ${vertCall}
  }`;
}; // todo: make hydra-synth function


GlslSource.prototype.setBlend = function (blendMode = true) {
  this.blendMode = blendMode;
  return this;
};

GlslSource.prototype.setLineWidth = function (lineWidth) {
  this.lineWidth = lineWidth;
  return this;
};

GlslSource.prototype.setGeometry = function (input) {
  const isGeometry = v => v.isBufferGeometry || v.positions && v.edges;

  const isClass = v => typeof v === 'function' && /^\s*class\s+/.test(v.toString());

  if (!input) input = [];

  if (!isGeometry(input)) {
    const vertTransform = this.transforms[0].transform.type === 'clear' ? this.transforms[1] : this.transforms[0];
    if (!Array.isArray(input)) input = [input];

    if (isClass(vertTransform.transform.geometry)) {
      if (vertTransform.transform.geometry === GridGeometry && vertTransform.transform.primitive && typeof input[0] !== 'string') {
        input.unshift(vertTransform.transform.primitive);
      }

      input = new vertTransform.transform.geometry(...input);
    } else {
      if (vertTransform.transform.geometry === _vectorizeText.default && input.length === 1) {
        input.push({
          textAlign: 'center',
          textBaseline: 'middle' // font: 'arial',
          // triangles: true, // todo: make it work

        });
      }

      input = vertTransform.transform.geometry(...input);
    }
  }

  this.geometry = input;
};

GlslSource.prototype.viewport = function (x, y, w, h) {
  this._viewport = {
    x,
    y,
    w,
    h
  };
  return this;
};

const glslProps = ['x', 'y', 'z', 'xy', 'xz', 'yx', 'yz', 'zx', 'zy', 'xyz', 'xyzw'];
glslProps.map(prop => {
  Object.defineProperty(GlslSource.prototype, prop, {
    get() {
      this.getter = prop;
      return this;
    }

  });
});
var _default = GlslSource;
exports.default = _default;

},{"./generate-glsl.js":189,"./glsl/utility-functions.js":194,"vectorize-text":183}],192:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.GridGeometry = void 0;

var _BufferGeometry = require("three/src/core/BufferGeometry");

var _BufferAttribute = require("three/src/core/BufferAttribute");

class GridGeometry extends _BufferGeometry.BufferGeometry {
  constructor(type, width, height, options) {
    super();
    this.type = 'GridGeometry';
    this.parameters = {
      primitive: type,
      width: width,
      height: height,
      options: options
    };
    let vertices;

    switch (type) {
      case 'points':
        {
          width || (width = 1);
          height || (height = 1);
          const count = width * height;
          vertices = Float32Array.from({
            length: count * 3
          }, (v, k) => {
            switch (k % 3) {
              case 0:
                return (k + 1) / 3 % width / width;

              case 1:
                return (Math.floor((k - 1) / 3 / width) + 0.5) / height;

              case 2:
                return 0;
            }
          });
          break;
        }

      case 'lines':
        {
          width || (width = 1);
          height || (height = 1);
          const count = 2 * (width + height);
          vertices = Float32Array.from({
            length: count * 3
          }, (v, k) => {
            if (k < width * 6) {
              switch (k % 6) {
                case 0:
                  return (k + 3) / 6 % width / width;

                case 1:
                  return 0.0001;

                case 2:
                case 5:
                  return 0;

                case 3:
                  return k / 6 % width / width;

                case 4:
                  return 0.9999;
              }
            } else {
              switch (k % 6) {
                case 0:
                  return 0.0001;

                case 1:
                  return (k + 2) / 6 % height / height;

                case 2:
                case 5:
                  return 0;

                case 3:
                  return 0.9999;

                case 4:
                  return (k - 1) / 6 % height / height;
              }
            }
          });
          break;
        }

      case 'line strip':
        {
          width || (width = 10);
          height || (height = 1);
          const count = width * height;
          const closed = typeof options === 'undefined' ? true : options;
          vertices = Float32Array.from({
            length: count * 3
          }, (v, k) => {
            // todo: will be NaN when points[0] == 1
            // todo: minimum 2 points?
            switch (k % 3) {
              case 0:
                return k / 3 % width / (width - closed);

              case 1:
                return Math.floor((k - 1) / 3 / width);

              case 2:
                return 0;
            }
          });
          break;
        }

      case 'line loop':
        {
          width || (width = 10);
          height || (height = 1);
          const count = width * height;
          vertices = Float32Array.from({
            length: count * 3
          }, (v, k) => {
            switch (k % 3) {
              case 0:
                return k / 3 % width / width;

              case 1:
                return Math.floor((k - 1) / 3 / width);

              case 2:
                return 0;
            }
          });
          break;
        }

      default:
        console.error(`invalid GridGeometry type: ${type}`);
        break;
    }

    this.setAttribute('position', new _BufferAttribute.Float32BufferAttribute(vertices, 3));
  }

}

exports.GridGeometry = GridGeometry;

},{"three/src/core/BufferAttribute":120,"three/src/core/BufferGeometry":121}],193:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/*
Format for adding functions to hydra. For each entry in this file, hydra automatically generates a glsl function and javascript function with the same name. You can also ass functions dynamically using setFunction(object).

{
  name: 'osc', // name that will be used to access function in js as well as in glsl
  type: 'src', // can be 'src', 'color', 'combine', 'combineCoords'. see below for more info
  inputs: [
    {
      name: 'freq',
      type: 'float',
      default: 0.2
    },
    {
      name: 'sync',
      type: 'float',
      default: 0.1
    },
    {
      name: 'offset',
      type: 'float',
      default: 0.0
    }
  ],
    glsl: `
      vec2 st = _st;
      float r = sin((st.x-offset*2/freq+time*sync)*freq)*0.5  + 0.5;
      float g = sin((st.x+time*sync)*freq)*0.5 + 0.5;
      float b = sin((st.x+offset/freq+time*sync)*freq)*0.5  + 0.5;
      return vec4(r, g, b, 1.0);
   `
}

// The above code generates the glsl function:
`vec4 osc(vec2 _st, float freq, float sync, float offset){
 vec2 st = _st;
 float r = sin((st.x-offset*2/freq+time*sync)*freq)*0.5  + 0.5;
 float g = sin((st.x+time*sync)*freq)*0.5 + 0.5;
 float b = sin((st.x+offset/freq+time*sync)*freq)*0.5  + 0.5;
 return vec4(r, g, b, 1.0);
}`


Types and default arguments for hydra functions.
The value in the 'type' field lets the parser know which type the function will be returned as well as default arguments.

const types = {
  'src': {
    returnType: 'vec4',
    args: ['vec2 _st']
  },
  'coord': {
    returnType: 'vec2',
    args: ['vec2 _st']
  },
  'color': {
    returnType: 'vec4',
    args: ['vec4 _c0']
  },
  'combine': {
    returnType: 'vec4',
    args: ['vec4 _c0', 'vec4 _c1']
  },
  'combineCoord': {
    returnType: 'vec2',
    args: ['vec2 _st', 'vec4 _c0']
  }
}

*/
var _default = () => [{
  name: 'noise',
  type: 'src',
  inputs: [{
    type: 'float',
    name: 'scale',
    default: 10
  }, {
    type: 'float',
    name: 'offset',
    default: 0.1
  }],
  glsl: `   return vec4(vec3(_noise(vec3(_st*scale, offset*time))), 1.0);`
}, {
  name: 'voronoi',
  type: 'src',
  inputs: [{
    type: 'float',
    name: 'scale',
    default: 5
  }, {
    type: 'float',
    name: 'speed',
    default: 0.3
  }, {
    type: 'float',
    name: 'blending',
    default: 0.3
  }],
  glsl: `   vec3 color = vec3(.0);
   // Scale
   _st *= scale;
   // Tile the space
   vec2 i_st = floor(_st);
   vec2 f_st = fract(_st);
   float m_dist = 10.;  // minimun distance
   vec2 m_point;        // minimum point
   for (int j=-1; j<=1; j++ ) {
   for (int i=-1; i<=1; i++ ) {
   vec2 neighbor = vec2(float(i),float(j));
   vec2 p = i_st + neighbor;
   vec2 point = fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);
   point = 0.5 + 0.5*sin(time*speed + 6.2831*point);
   vec2 diff = neighbor + point - f_st;
   float dist = length(diff);
   if( dist < m_dist ) {
   m_dist = dist;
   m_point = point;
   }
   }
   }
   // Assign a color using the closest point position
   color += dot(m_point,vec2(.3,.6));
   color *= 1.0 - blending*m_dist;
   return vec4(color, 1.0);`
}, {
  name: 'osc',
  type: 'src',
  inputs: [{
    type: 'float',
    name: 'frequency',
    default: 60
  }, {
    type: 'float',
    name: 'sync',
    default: 0.1
  }, {
    type: 'float',
    name: 'offset',
    default: 0
  }],
  glsl: `   vec2 st = _st;
   float r = sin((st.x-offset/frequency+time*sync)*frequency)*0.5  + 0.5;
   float g = sin((st.x+time*sync)*frequency)*0.5 + 0.5;
   float b = sin((st.x+offset/frequency+time*sync)*frequency)*0.5  + 0.5;
   return vec4(r, g, b, 1.0);`
}, {
  name: 'shape',
  type: 'src',
  inputs: [{
    type: 'float',
    name: 'sides',
    default: 3
  }, {
    type: 'float',
    name: 'radius',
    default: 0.3
  }, {
    type: 'float',
    name: 'smoothing',
    default: 0.01
  }],
  glsl: `   vec2 st = _st * 2. - 1.;
   // Angle and radius from the current pixel
   float a = atan(st.x,st.y)+3.1416;
   float r = (2.*3.1416)/sides;
   float d = cos(floor(.5+a/r)*r-a)*length(st);
   return vec4(vec3(1.0-smoothstep(radius,radius + smoothing + 0.0000001,d)), 1.0);`
}, {
  name: 'gradient',
  type: 'src',
  inputs: [{
    type: 'float',
    name: 'speed',
    default: 0
  }],
  glsl: `   return vec4(_st, sin(time*speed), 1.0);`
}, {
  name: 'src',
  type: 'src',
  inputs: [{
    type: 'sampler2D',
    name: 'tex',
    default: NaN
  }],
  glsl: `   //  vec2 uv = gl_FragCoord.xy/vec2(1280., 720.);
   return texture2D(tex, fract(_st));`
}, {
  name: 'solid',
  type: 'src',
  inputs: [{
    type: 'float',
    name: 'r',
    default: 0
  }, {
    type: 'float',
    name: 'g',
    default: 0
  }, {
    type: 'float',
    name: 'b',
    default: 0
  }, {
    type: 'float',
    name: 'a',
    default: 1
  }],
  glsl: `   return vec4(r, g, b, a);`
}, {
  name: 'rotate',
  type: 'coord',
  inputs: [{
    type: 'float',
    name: 'angle',
    default: 10
  }, {
    type: 'float',
    name: 'speed',
    default: 0
  }],
  glsl: `  vec2 xy = _st - vec2(0.5);
   // Convert degrees to radians
   float ang = angle * (3.141592653589793 / 180.0);
   ang = ang + speed *time;
   xy = mat2(cos(ang),-sin(ang), sin(ang),cos(ang))*xy;
   xy += 0.5;
   return xy;`
}, {
  name: 'scale',
  type: 'coord',
  inputs: [{
    type: 'float',
    name: 'amount',
    default: 1.5
  }, {
    type: 'float',
    name: 'xMult',
    default: 1
  }, {
    type: 'float',
    name: 'yMult',
    default: 1
  }, {
    type: 'float',
    name: 'offsetX',
    default: 0.5
  }, {
    type: 'float',
    name: 'offsetY',
    default: 0.5
  }],
  glsl: `   vec2 xy = _st - vec2(offsetX, offsetY);
   xy*=(1.0/vec2(amount*xMult, amount*yMult));
   xy+=vec2(offsetX, offsetY);
   return xy;
   `
}, {
  name: 'pixelate',
  type: 'coord',
  inputs: [{
    type: 'float',
    name: 'pixelX',
    default: 20
  }, {
    type: 'float',
    name: 'pixelY',
    default: 20
  }],
  glsl: `   vec2 xy = vec2(pixelX, pixelY);
   return (floor(_st * xy) + 0.5)/xy;`
}, {
  name: 'posterize',
  type: 'color',
  inputs: [{
    type: 'float',
    name: 'bins',
    default: 3
  }, {
    type: 'float',
    name: 'gamma',
    default: 0.6
  }],
  glsl: `   vec4 c2 = pow(_c0, vec4(gamma));
   c2 *= vec4(bins);
   c2 = floor(c2);
   c2/= vec4(bins);
   c2 = pow(c2, vec4(1.0/gamma));
   return vec4(c2.xyz, _c0.a);`
}, {
  name: 'shift',
  type: 'color',
  inputs: [{
    type: 'float',
    name: 'r',
    default: 0.5
  }, {
    type: 'float',
    name: 'g',
    default: 0
  }, {
    type: 'float',
    name: 'b',
    default: 0
  }, {
    type: 'float',
    name: 'a',
    default: 0
  }],
  glsl: `   vec4 c2 = vec4(_c0);
   c2.r = fract(c2.r + r);
   c2.g = fract(c2.g + g);
   c2.b = fract(c2.b + b);
   c2.a = fract(c2.a + a);
   return vec4(c2.rgba);`
}, {
  name: 'repeat',
  type: 'coord',
  inputs: [{
    type: 'float',
    name: 'repeatX',
    default: 3
  }, {
    type: 'float',
    name: 'repeatY',
    default: 3
  }, {
    type: 'float',
    name: 'offsetX',
    default: 0
  }, {
    type: 'float',
    name: 'offsetY',
    default: 0
  }],
  glsl: `   vec2 st = _st * vec2(repeatX, repeatY);
   st.x += step(1., mod(st.y,2.0)) * offsetX;
   st.y += step(1., mod(st.x,2.0)) * offsetY;
   return fract(st);`
}, {
  name: 'modulateRepeat',
  type: 'combineCoord',
  inputs: [{
    type: 'float',
    name: 'repeatX',
    default: 3
  }, {
    type: 'float',
    name: 'repeatY',
    default: 3
  }, {
    type: 'float',
    name: 'offsetX',
    default: 0.5
  }, {
    type: 'float',
    name: 'offsetY',
    default: 0.5
  }],
  glsl: `   vec2 st = _st * vec2(repeatX, repeatY);
   st.x += step(1., mod(st.y,2.0)) + _c0.r * offsetX;
   st.y += step(1., mod(st.x,2.0)) + _c0.g * offsetY;
   return fract(st);`
}, {
  name: 'repeatX',
  type: 'coord',
  inputs: [{
    type: 'float',
    name: 'reps',
    default: 3
  }, {
    type: 'float',
    name: 'offset',
    default: 0
  }],
  glsl: `   vec2 st = _st * vec2(reps, 1.0);
   //  float f =  mod(_st.y,2.0);
   st.y += step(1., mod(st.x,2.0))* offset;
   return fract(st);`
}, {
  name: 'modulateRepeatX',
  type: 'combineCoord',
  inputs: [{
    type: 'float',
    name: 'reps',
    default: 3
  }, {
    type: 'float',
    name: 'offset',
    default: 0.5
  }],
  glsl: `   vec2 st = _st * vec2(reps, 1.0);
   //  float f =  mod(_st.y,2.0);
   st.y += step(1., mod(st.x,2.0)) + _c0.r * offset;
   return fract(st);`
}, {
  name: 'repeatY',
  type: 'coord',
  inputs: [{
    type: 'float',
    name: 'reps',
    default: 3
  }, {
    type: 'float',
    name: 'offset',
    default: 0
  }],
  glsl: `   vec2 st = _st * vec2(1.0, reps);
   //  float f =  mod(_st.y,2.0);
   st.x += step(1., mod(st.y,2.0))* offset;
   return fract(st);`
}, {
  name: 'modulateRepeatY',
  type: 'combineCoord',
  inputs: [{
    type: 'float',
    name: 'reps',
    default: 3
  }, {
    type: 'float',
    name: 'offset',
    default: 0.5
  }],
  glsl: `   vec2 st = _st * vec2(reps, 1.0);
   //  float f =  mod(_st.y,2.0);
   st.x += step(1., mod(st.y,2.0)) + _c0.r * offset;
   return fract(st);`
}, {
  name: 'kaleid',
  type: 'coord',
  inputs: [{
    type: 'float',
    name: 'nSides',
    default: 4
  }],
  glsl: `   vec2 st = _st;
   st -= 0.5;
   float r = length(st);
   float a = atan(st.y, st.x);
   float pi = 2.*3.1416;
   a = mod(a,pi/nSides);
   a = abs(a-pi/nSides/2.);
   return r*vec2(cos(a), sin(a));`
}, {
  name: 'modulateKaleid',
  type: 'combineCoord',
  inputs: [{
    type: 'float',
    name: 'nSides',
    default: 4
  }],
  glsl: `   vec2 st = _st - 0.5;
   float r = length(st);
   float a = atan(st.y, st.x);
   float pi = 2.*3.1416;
   a = mod(a,pi/nSides);
   a = abs(a-pi/nSides/2.);
   return (_c0.r+r)*vec2(cos(a), sin(a));`
}, {
  name: 'scroll',
  type: 'coord',
  inputs: [{
    type: 'float',
    name: 'scrollX',
    default: 0.5
  }, {
    type: 'float',
    name: 'scrollY',
    default: 0.5
  }, {
    type: 'float',
    name: 'speedX',
    default: 0
  }, {
    type: 'float',
    name: 'speedY',
    default: 0
  }],
  glsl: `
   _st.x += scrollX + time*speedX;
   _st.y += scrollY + time*speedY;
   return fract(_st);`
}, {
  name: 'scrollX',
  type: 'coord',
  inputs: [{
    type: 'float',
    name: 'scrollX',
    default: 0.5
  }, {
    type: 'float',
    name: 'speed',
    default: 0
  }],
  glsl: `   _st.x += scrollX + time*speed;
   return fract(_st);`
}, {
  name: 'modulateScrollX',
  type: 'combineCoord',
  inputs: [{
    type: 'float',
    name: 'scrollX',
    default: 0.5
  }, {
    type: 'float',
    name: 'speed',
    default: 0
  }],
  glsl: `   _st.x += _c0.r*scrollX + time*speed;
   return fract(_st);`
}, {
  name: 'scrollY',
  type: 'coord',
  inputs: [{
    type: 'float',
    name: 'scrollY',
    default: 0.5
  }, {
    type: 'float',
    name: 'speed',
    default: 0
  }],
  glsl: `   _st.y += scrollY + time*speed;
   return fract(_st);`
}, {
  name: 'modulateScrollY',
  type: 'combineCoord',
  inputs: [{
    type: 'float',
    name: 'scrollY',
    default: 0.5
  }, {
    type: 'float',
    name: 'speed',
    default: 0
  }],
  glsl: `   _st.y += _c0.r*scrollY + time*speed;
   return fract(_st);`
}, {
  name: 'add',
  type: 'combine',
  inputs: [{
    type: 'float',
    name: 'amount',
    default: 1
  }],
  glsl: `   return (_c0+_c1)*amount + _c0*(1.0-amount);`
}, {
  name: 'sub',
  type: 'combine',
  inputs: [{
    type: 'float',
    name: 'amount',
    default: 1
  }],
  glsl: `   return (_c0-_c1)*amount + _c0*(1.0-amount);`
}, {
  name: 'layer',
  type: 'combine',
  inputs: [],
  glsl: `   return vec4(mix(_c0.rgb, _c1.rgb, _c1.a), clamp(_c0.a + _c1.a, 0.0, 1.0));`
}, {
  name: 'blend',
  type: 'combine',
  inputs: [{
    type: 'float',
    name: 'amount',
    default: 0.5
  }],
  glsl: `   return _c0*(1.0-amount)+_c1*amount;`
}, {
  name: 'mult',
  type: 'combine',
  inputs: [{
    type: 'float',
    name: 'amount',
    default: 1
  }],
  glsl: `   return _c0*(1.0-amount)+(_c0*_c1)*amount;`
}, {
  name: 'diff',
  type: 'combine',
  inputs: [],
  glsl: `   return vec4(abs(_c0.rgb-_c1.rgb), max(_c0.a, _c1.a));`
}, {
  name: 'modulate',
  type: 'combineCoord',
  inputs: [{
    type: 'float',
    name: 'amount',
    default: 0.1
  }],
  glsl: `   //  return fract(st+(_c0.xy-0.5)*amount);
   return _st + _c0.xy*amount;`
}, {
  name: 'modulateScale',
  type: 'combineCoord',
  inputs: [{
    type: 'float',
    name: 'multiple',
    default: 1
  }, {
    type: 'float',
    name: 'offset',
    default: 1
  }],
  glsl: `   vec2 xy = _st - vec2(0.5);
   xy*=(1.0/vec2(offset + multiple*_c0.r, offset + multiple*_c0.g));
   xy+=vec2(0.5);
   return xy;`
}, {
  name: 'modulatePixelate',
  type: 'combineCoord',
  inputs: [{
    type: 'float',
    name: 'multiple',
    default: 10
  }, {
    type: 'float',
    name: 'offset',
    default: 3
  }],
  glsl: `   vec2 xy = vec2(offset + _c0.x*multiple, offset + _c0.y*multiple);
   return (floor(_st * xy) + 0.5)/xy;`
}, {
  name: 'modulateRotate',
  type: 'combineCoord',
  inputs: [{
    type: 'float',
    name: 'multiple',
    default: 1
  }, {
    type: 'float',
    name: 'offset',
    default: 0
  }],
  glsl: `   vec2 xy = _st - vec2(0.5);
   float angle = offset + _c0.x * multiple;
   xy = mat2(cos(angle),-sin(angle), sin(angle),cos(angle))*xy;
   xy += 0.5;
   return xy;`
}, {
  name: 'modulateHue',
  type: 'combineCoord',
  inputs: [{
    type: 'float',
    name: 'amount',
    default: 1
  }],
  glsl: `   return _st + (vec2(_c0.g - _c0.r, _c0.b - _c0.g) * amount * 1.0/resolution);`
}, {
  name: 'invert',
  type: 'color',
  inputs: [{
    type: 'float',
    name: 'amount',
    default: 1
  }],
  glsl: `   return vec4((1.0-_c0.rgb)*amount + _c0.rgb*(1.0-amount), _c0.a);`
}, {
  name: 'contrast',
  type: 'color',
  inputs: [{
    type: 'float',
    name: 'amount',
    default: 1.6
  }],
  glsl: `   vec4 c = (_c0-vec4(0.5))*vec4(amount) + vec4(0.5);
   return vec4(c.rgb, _c0.a);`
}, {
  name: 'brightness',
  type: 'color',
  inputs: [{
    type: 'float',
    name: 'amount',
    default: 0.4
  }],
  glsl: `   return vec4(_c0.rgb + vec3(amount), _c0.a);`
}, {
  name: 'mask',
  type: 'combine',
  inputs: [],
  glsl: `   float a = _luminance(_c1.rgb);
  return vec4(_c0.rgb*a, a*_c0.a);`
}, {
  name: 'luma',
  type: 'color',
  inputs: [{
    type: 'float',
    name: 'threshold',
    default: 0.5
  }, {
    type: 'float',
    name: 'tolerance',
    default: 0.1
  }],
  glsl: `   float a = smoothstep(threshold-(tolerance+0.0000001), threshold+(tolerance+0.0000001), _luminance(_c0.rgb));
   return vec4(_c0.rgb*a, a);`
}, {
  name: 'thresh',
  type: 'color',
  inputs: [{
    type: 'float',
    name: 'threshold',
    default: 0.5
  }, {
    type: 'float',
    name: 'tolerance',
    default: 0.04
  }],
  glsl: `   return vec4(vec3(smoothstep(threshold-(tolerance+0.0000001), threshold+(tolerance+0.0000001), _luminance(_c0.rgb))), _c0.a);`
}, {
  name: 'color',
  type: 'color',
  inputs: [{
    type: 'float',
    name: 'r',
    default: 1
  }, {
    type: 'float',
    name: 'g',
    default: 1
  }, {
    type: 'float',
    name: 'b',
    default: 1
  }, {
    type: 'float',
    name: 'a',
    default: 1
  }],
  glsl: `   vec4 c = vec4(r, g, b, a);
   vec4 pos = step(0.0, c); // detect whether negative
   // if > 0, return r * _c0
   // if < 0 return (1.0-r) * _c0
   return vec4(mix((1.0-_c0)*abs(c), c*_c0, pos));`
}, {
  name: 'saturate',
  type: 'color',
  inputs: [{
    type: 'float',
    name: 'amount',
    default: 2
  }],
  glsl: `   const vec3 W = vec3(0.2125, 0.7154, 0.0721);
   vec3 intensity = vec3(dot(_c0.rgb, W));
   return vec4(mix(intensity, _c0.rgb, amount), _c0.a);`
}, {
  name: 'hue',
  type: 'color',
  inputs: [{
    type: 'float',
    name: 'hue',
    default: 0.4
  }],
  glsl: `   vec3 c = _rgbToHsv(_c0.rgb);
   c.r += hue;
   //  c.r = fract(c.r);
   return vec4(_hsvToRgb(c), _c0.a);`
}, {
  name: 'colorama',
  type: 'color',
  inputs: [{
    type: 'float',
    name: 'amount',
    default: 0.005
  }],
  glsl: `   vec3 c = _rgbToHsv(_c0.rgb);
   c += vec3(amount);
   c = _hsvToRgb(c);
   c = fract(c);
   return vec4(c, _c0.a);`
}, {
  name: 'prev',
  type: 'src',
  inputs: [],
  glsl: `   return texture2D(prevBuffer, fract(_st));`
}, {
  name: 'sum',
  type: 'color',
  inputs: [{
    type: 'vec4',
    name: 'scale',
    default: 1
  }],
  glsl: `   vec4 v = _c0 * s;
   return v.r + v.g + v.b + v.a;
   }
   float sum(vec2 _st, vec4 s) { // vec4 is not a typo, because argument type is not overloaded
   vec2 v = _st.xy * s.xy;
   return v.x + v.y;`
}, {
  name: 'r',
  type: 'color',
  inputs: [{
    type: 'float',
    name: 'scale',
    default: 1
  }, {
    type: 'float',
    name: 'offset',
    default: 0
  }],
  glsl: `   return vec4(_c0.r * scale + offset);`
}, {
  name: 'g',
  type: 'color',
  inputs: [{
    type: 'float',
    name: 'scale',
    default: 1
  }, {
    type: 'float',
    name: 'offset',
    default: 0
  }],
  glsl: `   return vec4(_c0.g * scale + offset);`
}, {
  name: 'b',
  type: 'color',
  inputs: [{
    type: 'float',
    name: 'scale',
    default: 1
  }, {
    type: 'float',
    name: 'offset',
    default: 0
  }],
  glsl: `   return vec4(_c0.b * scale + offset);`
}, {
  name: 'a',
  type: 'color',
  inputs: [{
    type: 'float',
    name: 'scale',
    default: 1
  }, {
    type: 'float',
    name: 'offset',
    default: 0
  }],
  glsl: `   return vec4(_c0.a * scale + offset);`
}, {
  name: 'map',
  type: 'color',
  inputs: [{
    name: 'start1',
    type: 'float',
    default: NaN
  }, {
    name: 'stop1',
    type: 'float',
    default: NaN
  }, {
    name: 'start2',
    type: 'float',
    default: 0
  }, {
    name: 'stop2',
    type: 'float',
    default: 1
  }],
  glsl: `return (_c0 - start1) / (stop1 - start1) * (stop2 - start2) + start2;`
}, {
  name: 'clear',
  type: 'clear',
  inputs: [],
  glsl: ``
}, {
  name: 'fade',
  type: 'clear',
  inputs: [{
    name: 'amount',
    type: 'float',
    default: '0.01'
  }, {
    name: 'camera',
    type: 'bool',
    default: false
  }],
  glsl: ``
}, {
  name: 'glsl',
  type: 'glsl',
  inputs: [],
  glsl: ``
}, // todo: make these type agnostic (new type: 'util'?)
{
  name: 'sin',
  glslName: '_sin',
  type: 'coord',
  inputs: [{
    name: 'freq',
    type: 'float',
    default: 1
  }, {
    name: 'amp',
    type: 'float',
    default: 0.5
  }],
  glsl: `return sin(_st * TWO_PI * freq) * amp;`
}, {
  name: 'cos',
  glslName: '_cos',
  type: 'coord',
  inputs: [{
    name: 'freq',
    type: 'float',
    default: 1
  }, {
    name: 'amp',
    type: 'float',
    default: 0.5
  }],
  glsl: `return cos(_st * TWO_PI * freq) * amp;`
}, {
  name: 'tan',
  glslName: '_tan',
  type: 'coord',
  inputs: [{
    name: 'freq',
    type: 'float',
    default: 1
  }, {
    name: 'amp',
    type: 'float',
    default: 0.5
  }],
  glsl: `return tan(_st * PI * freq) * amp;`
}, {
  name: 'atan',
  glslName: '_atan',
  type: 'coord',
  inputs: [{
    name: 'freq',
    type: 'float',
    default: 1
  }, {
    name: 'amp',
    type: 'float',
    default: 0.5
  }],
  glsl: `return atan(_st * PI * freq) * amp;`
}, {
  name: 'pow',
  glslName: '_pow',
  type: 'coord',
  inputs: [{
    name: 'power',
    type: 'vec2',
    default: 2
  }],
  glsl: `return pow(_st, power);`
}];

exports.default = _default;

},{}],194:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
// functions that are only used within other functions
var _default = {
  _pi: {
    type: 'util',
    glsl: `#define PI 3.1415926535897932384626433832795`
  },
  _twopi: {
    type: 'util',
    glsl: `#define TWO_PI 6.283185307179586`
  },
  _luminance: {
    type: 'util',
    glsl: `float _luminance(vec3 rgb){
      const vec3 W = vec3(0.2125, 0.7154, 0.0721);
      return dot(rgb, W);
    }`
  },
  _permute: {
    type: 'util',
    glsl: `vec4 _permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}`
  },
  _mod289: {
    type: 'util',
    glsl: `
vec3 _mod289(vec3 x)
{
  return x - floor(x * (1.0 / 289.0)) * 289.0;
}

vec4 _mod289(vec4 x)
{
  return x - floor(x * (1.0 / 289.0)) * 289.0;
}
`
  },
  _taylorInvSqrt: {
    type: 'util',
    glsl: `vec4 _taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}`
  },
  //	Simplex 3D Noise
  //	by Ian McEwan, Ashima Arts
  _noise: {
    type: 'util',
    glsl: `
  float _noise(vec3 v){
    const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;
    const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);

  // First corner
    vec3 i  = floor(v + dot(v, C.yyy) );
    vec3 x0 =   v - i + dot(i, C.xxx) ;

  // Other corners
    vec3 g = step(x0.yzx, x0.xyz);
    vec3 l = 1.0 - g;
    vec3 i1 = min( g.xyz, l.zxy );
    vec3 i2 = max( g.xyz, l.zxy );

    //  x0 = x0 - 0. + 0.0 * C
    vec3 x1 = x0 - i1 + 1.0 * C.xxx;
    vec3 x2 = x0 - i2 + 2.0 * C.xxx;
    vec3 x3 = x0 - 1. + 3.0 * C.xxx;

  // Permutations
    i = mod(i, 289.0 );
    vec4 p = _permute( _permute( _permute(
               i.z + vec4(0.0, i1.z, i2.z, 1.0 ))
             + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))
             + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));

  // Gradients
  // ( N*N points uniformly over a square, mapped onto an octahedron.)
    float n_ = 1.0/7.0; // N=7
    vec3  ns = n_ * D.wyz - D.xzx;

    vec4 j = p - 49.0 * floor(p * ns.z *ns.z);  //  mod(p,N*N)

    vec4 x_ = floor(j * ns.z);
    vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)

    vec4 x = x_ *ns.x + ns.yyyy;
    vec4 y = y_ *ns.x + ns.yyyy;
    vec4 h = 1.0 - abs(x) - abs(y);

    vec4 b0 = vec4( x.xy, y.xy );
    vec4 b1 = vec4( x.zw, y.zw );

    vec4 s0 = floor(b0)*2.0 + 1.0;
    vec4 s1 = floor(b1)*2.0 + 1.0;
    vec4 sh = -step(h, vec4(0.0));

    vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;
    vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;

    vec3 p0 = vec3(a0.xy,h.x);
    vec3 p1 = vec3(a0.zw,h.y);
    vec3 p2 = vec3(a1.xy,h.z);
    vec3 p3 = vec3(a1.zw,h.w);

  //Normalise gradients
    vec4 norm = _taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
    p0 *= norm.x;
    p1 *= norm.y;
    p2 *= norm.z;
    p3 *= norm.w;

  // Mix final noise value
    vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
    m = m * m;
    return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),
                                  dot(p2,x2), dot(p3,x3) ) );
  }
    `
  },
  _rgbToHsv: {
    type: 'util',
    glsl: `vec3 _rgbToHsv(vec3 c){
            vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
            vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));
            vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));

            float d = q.x - min(q.w, q.y);
            float e = 1.0e-10;
            return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
        }`
  },
  _hsvToRgb: {
    type: 'util',
    glsl: `vec3 _hsvToRgb(vec3 c){
        vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
        vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
        return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
    }`
  }
};
exports.default = _default;

},{}],195:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _GridGeometry = require("./geometries/GridGeometry.js");

var THREE = _interopRequireWildcard(require("three/src/geometries/Geometries.js"));

var _vectorizeText = _interopRequireDefault(require("vectorize-text"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const glsl = require("glslify");

const pointsVert = glsl(["#define GLSLIFY 1\nvarying vec3 vPos;\nvarying float vSize;\nvarying vec4 vColor;\n\n// note: pos.z does not change anything with GL_POINTS\nvec4 points(vec2 _st, vec3 pos, float size, vec4 color, float fade) {\n    vPos = pos;\n    vSize = size;\n    vColor = color;\n    gl_PointSize = vSize;\n    return vec4(vPos * 2.0 - 1.0, 1.0);\n}\n\n"]);
const linesVert = glsl(["#define GLSLIFY 1\nvarying vec3 vPos;\nvarying vec4 vColor;\n\n// note: pos.z does not change anything with GL_LINES\nvec4 lines(vec2 _st, vec3 pos, vec4 color) {\n    vPos = pos;\n    vColor = color;\n    return vec4(vPos * 2.0 - 1.0, 1.0);\n}\n\n"]);
const linestripVert = glsl(["#define GLSLIFY 1\nvarying vec3 vPos;\nvarying float vSize;\nvarying vec4 vColor;\n\nvec4 linestrip(vec2 _st, vec3 pos, vec4 color) {\n    vPos = pos;\n    vColor = color;\n    vColor.a = vColor.a * ceil(1.0 - _st.x);\n    vColor.a = vColor.a * ceil(_st.x);\n    return vec4(vPos * 2.0 - 1.0, 1.0);\n}\n\n"]);
const lineloopVert = glsl(["#define GLSLIFY 1\nvarying vec3 vPos;\nvarying float vSize;\nvarying vec4 vColor;\n\nvec4 lineloop(vec2 _st, vec3 pos, vec4 color) {\n    vPos = pos;\n    vColor = color;\n    vColor.a = vColor.a * ceil(1.0 - _st.x);\n    vColor.a = vColor.a * ceil(_st.x);\n    return vec4(vPos * 2.0 - 1.0, 1.0);\n}\n\n"]);
const pdotsFrag = glsl(["#define GLSLIFY 1\nvarying vec4 vColor;\n\nvec4 pdots(vec2 _st, vec3 pos, float size, vec4 color, float fade) {\n    vec4 outColor = vColor;\n    float dist = distance(gl_PointCoord, vec2(0.5));\n    float maxDist = 0.5;\n    outColor.a = (1.0 - smoothstep(maxDist - fade, maxDist, dist)) * outColor.a;\n    if (outColor.a <= 0.0 || dist >= maxDist) {\n        discard;\n    }\n    return outColor;\n}"]);
const psquaresFrag = glsl(["#define GLSLIFY 1\nvarying vec4 vColor;\n\nvec4 psquares(vec2 _st, vec3 pos, float size, vec4 color, float fade) {\n    vec4 outColor = vColor;\n    float dist = distance(gl_PointCoord, vec2(0.5));\n    float maxDist;\n    // todo: need to be based on angle\n    //maxDist = length(vec2(0.5, 0.5));\n    //outColor.a = 1.0 - smoothstep(maxDist - fade, maxDist, dist);\n    return outColor;\n}"]);
const plinesFrag = glsl(["#define GLSLIFY 1\nvarying vec4 vColor;\n\nvec4 plines(vec2 _st, vec3 pos, vec4 color) {\n    vec4 outColor = vColor;\n    return outColor;\n}"]);
const plinestripFrag = glsl(["#define GLSLIFY 1\nvarying vec4 vColor;\n\nvec4 linestrip(vec2 _st, vec3 pos, vec4 color) {\n    vec4 outColor = vColor;\n    if (outColor.a <= 0.0) {\n        discard;\n    }\n    return vec4(outColor.rgb, 1.0);\n}"]);
const plineloopFrag = glsl(["#define GLSLIFY 1\nvarying vec4 vColor;\n\nvec4 lineloop(vec2 _st, vec3 pos, vec4 color) {\n    vec4 outColor = vColor;\n    if (outColor.a <= 0.0) {\n        discard;\n    }\n    return vec4(outColor.rgb, 1.0);\n}"]);
const planeVert = glsl(["#define GLSLIFY 1\nvarying vec4 vColor;\n\nvec4 plane(vec2 _st, vec3 pos, vec4 color) {\n    vColor = color;\n    // todo: shouldn't it be multiplication?\n    return vec4((pos * 2.0 - 1.0) + position, 1.0);\n}\n\n"]);
const phongFrag = glsl(["#define GLSLIFY 1\nvec4 phong(vec4 _c0, float shininess, vec3 lightDirection, vec3 lightColor, vec3 ambientColor, vec3 specularColor) {\n    vec3 normal = normalize(vnormal);\n    vec3 lightDir = normalize(-lightDirection);\n    vec3 viewDir = normalize(-vposition);\n    vec3 reflectDir = reflect(-lightDir, normal);\n\n    // Ambient component\n    vec3 ambient = ambientColor * lightColor;\n\n    // Diffuse component\n    float diff = max(dot(normal, lightDir), 0.0);\n    vec3 diffuse = _c0.rgb * lightColor * diff;\n\n    // Specular component\n    float spec = pow(max(dot(viewDir, reflectDir), 0.0), shininess);\n    vec3 specular = specularColor * lightColor * spec;\n\n    return vec4(ambient + diffuse + specular, _c0.a);\n}\n"]);
const lambertFrag = glsl(["#define GLSLIFY 1\nvec4 lambert(vec4 _c0, float intensity, vec3 lightDirection) {\n  vec3 normal = normalize(vnormal);\n  vec3 lightDir = normalize(-lightDirection);\n  float diff = max(dot(normal, lightDir), 0.0);\n  return vec4(_c0.rgb * diff * intensity, _c0.a);\n}"]); // todo: respect makeGlobal?

Object.assign(window, {
  GridGeometry: _GridGeometry.GridGeometry,
  vectorizeText: _vectorizeText.default
});
Object.assign(window, THREE);

var _default = hy => [{
  name: 'pdots',
  type: 'vert',
  inputs: [{
    name: 'pos',
    type: 'vec3',
    default: hy.gradient()
  }, {
    name: 'size',
    type: 'float',
    default: 10
  }, {
    name: 'color',
    type: 'vec4',
    default: 1
  }, {
    name: 'fade',
    type: 'float',
    default: 0.025
  }],
  glsl: pdotsFrag,
  vert: pointsVert,
  primitive: 'points',
  blendMode: true,
  geometry: _GridGeometry.GridGeometry
}, {
  name: 'psquares',
  type: 'vert',
  inputs: [{
    name: 'pos',
    type: 'vec3',
    default: hy.gradient()
  }, {
    name: 'size',
    type: 'float',
    default: 1
  }, {
    name: 'color',
    type: 'vec4',
    default: 1
  }, {
    name: 'fade',
    type: 'float',
    default: 0.025
  }],
  glsl: psquaresFrag,
  vert: pointsVert,
  primitive: 'points',
  blendMode: true,
  geometry: _GridGeometry.GridGeometry
}, {
  name: 'plines',
  type: 'vert',
  inputs: [{
    name: 'pos',
    type: 'vec3',
    default: hy.gradient()
  }, {
    name: 'color',
    type: 'vec4',
    default: 1
  }],
  glsl: plinesFrag,
  vert: linesVert,
  primitive: 'lines',
  geometry: _GridGeometry.GridGeometry
}, {
  name: 'plinestrip',
  type: 'vert',
  inputs: [{
    name: 'pos',
    type: 'vec3',
    default: hy.solid(hy.noise(1).x, hy.noise(2).y, hy.noise(3).z).map(-1, 1, 0, 1)
  }, {
    name: 'color',
    type: 'vec4',
    default: 1
  }],
  glsl: plinestripFrag,
  vert: linestripVert,
  primitive: 'line strip',
  geometry: _GridGeometry.GridGeometry
}, {
  name: 'plineloop',
  type: 'vert',
  inputs: [{
    name: 'pos',
    type: 'vec3',
    default: hy.solid(hy.noise(1).x, hy.noise(2).y, hy.noise(3).z).map(-1, 1, 0, 1)
  }, {
    name: 'color',
    type: 'vec4',
    default: 1
  }],
  glsl: plineloopFrag,
  vert: lineloopVert,
  primitive: 'line loop',
  geometry: _GridGeometry.GridGeometry
}, {
  name: 'plane',
  type: 'vert',
  inputs: [{
    name: 'pos',
    type: 'vec3',
    default: hy.gradient()
  }, {
    name: 'color',
    type: 'vec4',
    default: 1
  }],
  glsl: `return color;`,
  vert: planeVert,
  primitive: 'triangles',
  geometry: THREE.PlaneGeometry
}, {
  name: 'box',
  type: 'vert',
  inputs: [{
    name: 'color',
    type: 'vec4',
    default: 1
  }],
  glsl: `return color;`,
  primitive: 'triangles',
  geometry: THREE.BoxGeometry
}, {
  name: 'sphere',
  type: 'vert',
  inputs: [{
    name: 'color',
    type: 'vec4',
    default: 1
  }],
  glsl: `return color;`,
  primitive: 'triangles',
  geometry: THREE.SphereGeometry
}, {
  name: 'cylinder',
  type: 'vert',
  inputs: [{
    name: 'color',
    type: 'vec4',
    default: 1
  }],
  glsl: `return color;`,
  primitive: 'triangles',
  geometry: THREE.CylinderGeometry
}, {
  name: 'cone',
  type: 'vert',
  inputs: [{
    name: 'color',
    type: 'vec4',
    default: 1
  }],
  glsl: `return color;`,
  primitive: 'triangles',
  geometry: THREE.ConeGeometry
}, {
  name: 'edges',
  type: 'vert',
  inputs: [{
    name: 'color',
    type: 'vec4',
    default: 1
  }],
  glsl: `return color;`,
  primitive: 'lines',
  geometry: THREE.EdgesGeometry
}, {
  name: 'text',
  type: 'vert',
  inputs: [{
    name: 'color',
    type: 'vec4',
    default: 1
  }],
  glsl: `return color;`,
  geometry: _vectorizeText.default,
  useUV: false,
  useNormal: false
}, // lighting related functions
{
  name: 'lambert',
  type: 'color',
  inputs: [{
    name: 'intensity',
    type: 'float',
    default: 1
  }, {
    name: 'lightDirection',
    type: 'vec3',
    default: [1.0, 1.0, -1.0]
  }],
  glsl: lambertFrag
}, {
  name: 'phong',
  type: 'color',
  inputs: [{
    name: 'shininess',
    type: 'float',
    default: 4
  }, {
    name: 'lightDirection',
    type: 'vec3',
    default: [1.0, 1.0, -1.0]
  }, {
    name: 'lightColor',
    type: 'vec3',
    default: [1.0, 1.0, 1.0]
  }, {
    name: 'ambientColor',
    type: 'vec3',
    default: [0.1, 0.1, 0.1]
  }, {
    name: 'specularColor',
    type: 'vec3',
    default: [1.0, 1.0, 1.0]
  }],
  glsl: phongFrag
}];

exports.default = _default;

},{"./geometries/GridGeometry.js":192,"glslify":77,"three/src/geometries/Geometries.js":152,"vectorize-text":183}],196:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _webcam = _interopRequireDefault(require("./lib/webcam.js"));

var _screenmedia = _interopRequireDefault(require("./lib/screenmedia.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class HydraSource {
  constructor({
    regl,
    width,
    height,
    pb,
    label = ""
  }) {
    this.label = label;
    this.regl = regl;
    this.src = null;
    this.dynamic = true;
    this.width = width;
    this.height = height;
    this.tex = this.regl.texture({
      //  shape: [width, height]
      shape: [1, 1]
    });
    this.pb = pb;
  }

  init(opts, params) {
    if ('src' in opts) {
      this.src = opts.src;
      this.tex = this.regl.texture({
        data: this.src,
        ...params
      });
    }

    if ('dynamic' in opts) this.dynamic = opts.dynamic;
  }

  initCam(index, params) {
    const self = this;
    (0, _webcam.default)(index).then(response => {
      self.src = response.video;
      self.dynamic = true;
      self.tex = self.regl.texture({
        data: self.src,
        ...params
      });
    }).catch(err => console.log('could not get camera', err));
  }

  initVideo(url = '', params) {
    // const self = this
    const vid = document.createElement('video');
    vid.crossOrigin = 'anonymous';
    vid.autoplay = true;
    vid.loop = true;
    vid.muted = true; // mute in order to load without user interaction

    const onload = vid.addEventListener('loadeddata', () => {
      this.src = vid;
      vid.play();
      this.tex = this.regl.texture({
        data: this.src,
        ...params
      });
      this.dynamic = true;
    });
    vid.src = url;
  }

  initImage(url = '', params) {
    const img = document.createElement('img');
    img.crossOrigin = 'anonymous';
    img.src = url;

    img.onload = () => {
      this.src = img;
      this.dynamic = false;
      this.tex = this.regl.texture({
        data: this.src,
        ...params
      });
    };
  }

  initStream(streamName, params) {
    //  console.log("initing stream!", streamName)
    let self = this;

    if (streamName && this.pb) {
      this.pb.initSource(streamName);
      this.pb.on('got video', function (nick, video) {
        if (nick === streamName) {
          self.src = video;
          self.dynamic = true;
          self.tex = self.regl.texture({
            data: self.src,
            ...params
          });
        }
      });
    }
  } // index only relevant in atom-hydra + desktop apps


  initScreen(index = 0, params) {
    const self = this;
    (0, _screenmedia.default)().then(function (response) {
      self.src = response.video;
      self.tex = self.regl.texture({
        data: self.src,
        ...params
      });
      self.dynamic = true; //  console.log("received screen input")
    }).catch(err => console.log('could not get screen', err));
  }

  resize(width, height) {
    this.width = width;
    this.height = height;
  }

  clear() {
    if (this.src && this.src.srcObject) {
      if (this.src.srcObject.getTracks) {
        this.src.srcObject.getTracks().forEach(track => track.stop());
      }
    }

    this.src = null;
    this.tex = this.regl.texture({
      shape: [1, 1]
    });
  }

  tick(time) {
    //  console.log(this.src, this.tex.width, this.tex.height)
    if (this.src !== null && this.dynamic === true) {
      if (this.src.videoWidth && this.src.videoWidth !== this.tex.width) {
        console.log(this.src.videoWidth, this.src.videoHeight, this.tex.width, this.tex.height);
        this.tex.resize(this.src.videoWidth, this.src.videoHeight);
      }

      if (this.src.width && this.src.width !== this.tex.width) {
        this.tex.resize(this.src.width, this.src.height);
      }

      this.tex.subimage(this.src);
    }
  }

  getTexture() {
    return this.tex;
  }

}

var _default = HydraSource;
exports.default = _default;

},{"./lib/screenmedia.js":205,"./lib/webcam.js":207}],197:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _output = _interopRequireDefault(require("./output.js"));

var _rafLoop = _interopRequireDefault(require("raf-loop"));

var _hydraSource = _interopRequireDefault(require("./hydra-source.js"));

var _mouse = _interopRequireDefault(require("./lib/mouse.js"));

var _audio = _interopRequireDefault(require("./lib/audio.js"));

var _videoRecorder = _interopRequireDefault(require("./lib/video-recorder.js"));

var _arrayUtils = _interopRequireDefault(require("./lib/array-utils.js"));

var _evalSandbox = _interopRequireDefault(require("./eval-sandbox.js"));

var _generatorFactory = _interopRequireDefault(require("./generator-factory.js"));

var _regl = _interopRequireDefault(require("regl"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// import strudel from './lib/strudel.js'
// const window = global.window
const Mouse = (0, _mouse.default)(); // to do: add ability to pass in certain uniforms and transforms

class HydraRenderer {
  constructor({
    pb = null,
    width = 1280,
    height = 720,
    numSources = 4,
    numOutputs = 4,
    makeGlobal = true,
    autoLoop = true,
    detectAudio = true,
    enableStreamCapture = true,
    canvas,
    precision,
    extendTransforms = {} // add your own functions on init

  } = {}) {
    _arrayUtils.default.init();

    this.pb = pb;
    this.width = width;
    this.height = height;
    this.renderAll = false;
    this.detectAudio = detectAudio;

    this._initCanvas(canvas); //global.window.test = 'hi'
    // object that contains all properties that will be made available on the global context and during local evaluation


    this.synth = {
      time: 0,
      bpm: 30,
      width: this.width,
      height: this.height,
      fps: undefined,
      stats: {
        fps: 0
      },
      speed: 1,
      mouse: Mouse,
      render: this._render.bind(this),
      setResolution: this.setResolution.bind(this),
      update: dt => {},
      // user defined update function
      hush: this.hush.bind(this),
      tick: this.tick.bind(this)
    };
    if (makeGlobal) window.loadScript = this.loadScript;
    this.timeSinceLastUpdate = 0;
    this._time = 0; // for internal use, only to use for deciding when to render frames
    // only allow valid precision options

    let precisionOptions = ['lowp', 'mediump', 'highp'];

    if (precision && precisionOptions.includes(precision.toLowerCase())) {
      this.precision = precision.toLowerCase(); //
      // if(!precisionValid){
      //   console.warn('[hydra-synth warning]\nConstructor was provided an invalid floating point precision value of "' + precision + '". Using default value of "mediump" instead.')
      // }
    } else {
      let isIOS = (/iPad|iPhone|iPod/.test(navigator.platform) || navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1) && !window.MSStream;
      this.precision = isIOS ? 'highp' : 'mediump';
    }

    this.extendTransforms = extendTransforms; // boolean to store when to save screenshot

    this.saveFrame = false; // if stream capture is enabled, this object contains the capture stream

    this.captureStream = null;
    this.generator = undefined;

    this._initRegl();

    this._initOutputs(numOutputs);

    this._initSources(numSources);

    this._generateGlslTransforms();

    this.synth.screencap = () => {
      this.saveFrame = true;
    };

    if (enableStreamCapture) {
      try {
        this.captureStream = this.canvas.captureStream(25); // to do: enable capture stream of specific sources and outputs

        this.synth.vidRecorder = new _videoRecorder.default(this.captureStream);
      } catch (e) {
        console.warn('[hydra-synth warning]\nnew MediaSource() is not currently supported on iOS.');
        console.error(e);
      }
    }

    if (detectAudio) this._initAudio();
    if (autoLoop) (0, _rafLoop.default)(this.tick.bind(this)).start(); // final argument is properties that the user can set, all others are treated as read-only

    this.sandbox = new _evalSandbox.default(this.synth, makeGlobal, ['speed', 'update', 'bpm', 'fps']);
  }

  eval(code) {
    this.sandbox.eval(code);
  }

  getScreenImage(callback) {
    this.imageCallback = callback;
    this.saveFrame = true;
  }

  hush() {
    this.s.forEach(source => {
      source.clear();
    });
    this.o.forEach(output => {
      this.synth.solid(0, 0, 0, 0).out(output);
    });
    this.synth.render(this.o[0]); // this.synth.update = (dt) => {}

    this.sandbox.set('update', dt => {});
  }

  loadScript(url = "", once = true) {
    const self = this || window;
    const p = new Promise((res, rej) => {
      if (once) {
        self.loadedScripts || (self.loadedScripts = {});

        if (self.loadedScripts[url]) {
          res();
          return;
        }
      }

      var script = document.createElement("script");

      script.onload = function () {
        console.log(`loaded script ${url}`);

        if (once) {
          self.loadedScripts[url] = true;
        }

        res();
      };

      script.onerror = err => {
        console.log(`error loading script ${url}`, "log-error");
        res();
      };

      script.src = url;
      document.head.appendChild(script);
    });
    return p;
  }

  setResolution(width, height) {
    //  console.log(width, height)
    this.canvas.width = width;
    this.canvas.height = height;
    this.width = width; // is this necessary?

    this.height = height; // ?

    this.sandbox.set('width', width);
    this.sandbox.set('height', height);
    this.o.forEach(output => {
      output.resize(width, height);
    });
    this.s.forEach(source => {
      source.resize(width, height);
    });

    this.regl._refresh();

    console.log(this.canvas.width);
  }

  canvasToImage(callback) {
    const a = document.createElement('a');
    a.style.display = 'none';
    let d = new Date();
    a.download = `hydra-${d.getFullYear()}-${d.getMonth() + 1}-${d.getDate()}-${d.getHours()}.${d.getMinutes()}.${d.getSeconds()}.png`;
    document.body.appendChild(a);
    var self = this;
    this.canvas.toBlob(blob => {
      if (self.imageCallback) {
        self.imageCallback(blob);
        delete self.imageCallback;
      } else {
        a.href = URL.createObjectURL(blob);
        console.log(a.href);
        a.click();
      }
    }, 'image/png');
    setTimeout(() => {
      document.body.removeChild(a);
      window.URL.revokeObjectURL(a.href);
    }, 300);
  }

  _initAudio() {
    const that = this;
    this.synth.a = new _audio.default({
      numBins: 4,
      parentEl: this.canvas.parentNode // changeListener: ({audio}) => {
      //   that.a = audio.bins.map((_, index) =>
      //     (scale = 1, offset = 0) => () => (audio.fft[index] * scale + offset)
      //   )
      //
      //   if (that.makeGlobal) {
      //     that.a.forEach((a, index) => {
      //       const aname = `a${index}`
      //       window[aname] = a
      //     })
      //   }
      // }

    });
  } // create main output canvas and add to screen


  _initCanvas(canvas) {
    if (canvas) {
      this.canvas = canvas;
      this.width = canvas.width;
      this.height = canvas.height;
    } else {
      this.canvas = document.createElement('canvas');
      this.canvas.width = this.width;
      this.canvas.height = this.height;
      this.canvas.style.width = '100%';
      this.canvas.style.height = '100%';
      this.canvas.style.imageRendering = 'pixelated';
      document.body.appendChild(this.canvas);
    }
  }

  _initRegl() {
    this.regl = (0, _regl.default)({
      //  profile: true,
      canvas: this.canvas,
      pixelRatio: 1 //,
      // extensions: [
      //   'oes_texture_half_float',
      //   'oes_texture_half_float_linear'
      // ],
      // optionalExtensions: [
      //   'oes_texture_float',
      //   'oes_texture_float_linear'
      //]

    }); // This clears the color buffer to black and the depth buffer to 1

    this.regl.clear({
      color: [0, 0, 0, 1]
    });
    this.renderAll = this.regl({
      frag: `
      precision ${this.precision} float;
      varying vec2 uv;
      uniform sampler2D tex0;
      uniform sampler2D tex1;
      uniform sampler2D tex2;
      uniform sampler2D tex3;

      void main () {
        vec2 st = vec2(1.0 - uv.x, uv.y);
        st*= vec2(2);
        vec2 q = floor(st).xy*(vec2(2.0, 1.0));
        int quad = int(q.x) + int(q.y);
        st.x += step(1., mod(st.y,2.0));
        st.y += step(1., mod(st.x,2.0));
        st = fract(st);
        if(quad==0){
          gl_FragColor = texture2D(tex0, st);
        } else if(quad==1){
          gl_FragColor = texture2D(tex1, st);
        } else if (quad==2){
          gl_FragColor = texture2D(tex2, st);
        } else {
          gl_FragColor = texture2D(tex3, st);
        }

      }
      `,
      vert: `
      precision ${this.precision} float;
      attribute vec2 position;
      varying vec2 uv;

      void main () {
        uv = position;
        gl_Position = vec4(1.0 - 2.0 * position, 0, 1);
      }`,
      attributes: {
        position: [[-2, 0], [0, -2], [2, 2]]
      },
      uniforms: {
        tex0: this.regl.prop('tex0'),
        tex1: this.regl.prop('tex1'),
        tex2: this.regl.prop('tex2'),
        tex3: this.regl.prop('tex3')
      },
      count: 3,
      depth: {
        enable: false
      }
    });
    this.renderFbo = this.regl({
      frag: `
      precision ${this.precision} float;
      varying vec2 uv;
      uniform vec2 resolution;
      uniform sampler2D tex0;

      void main () {
        gl_FragColor = texture2D(tex0, vec2(1.0 - uv.x, uv.y));
      }
      `,
      vert: `
      precision ${this.precision} float;
      attribute vec2 position;
      varying vec2 uv;

      void main () {
        uv = position;
        gl_Position = vec4(1.0 - 2.0 * position, 0, 1);
      }`,
      attributes: {
        position: [[-2, 0], [0, -2], [2, 2]]
      },
      uniforms: {
        tex0: this.regl.prop('tex0'),
        resolution: this.regl.prop('resolution')
      },
      count: 3,
      depth: {
        enable: false
      }
    });
  }

  _initOutputs(numOutputs) {
    const self = this;
    this.o = Array(numOutputs).fill().map((el, index) => {
      var o = new _output.default(index, this);
      self.synth['o' + index] = o;
      return o;
    }); // set default output

    this.output = this.o[0];
  }

  _initSources(numSources) {
    this.s = [];

    for (var i = 0; i < numSources; i++) {
      this.createSource(i);
    }
  }

  createSource(i) {
    let s = new _hydraSource.default({
      regl: this.regl,
      pb: this.pb,
      width: this.width,
      height: this.height,
      label: `s${i}`
    });
    this.synth['s' + this.s.length] = s;
    this.s.push(s);
    return s;
  }

  _generateGlslTransforms() {
    var self = this;
    this.generator = new _generatorFactory.default({
      defaultOutput: this.o[0],
      defaultUniforms: this.o[0].uniforms,
      extendTransforms: this.extendTransforms,
      changeListener: ({
        type,
        method,
        synth
      }) => {
        if (type === 'add') {
          self.synth[method] = synth.generators[method];
          if (self.sandbox) self.sandbox.add(method);
        } else if (type === 'remove') {// what to do here? dangerously deleting window methods
          //delete window[method]
        } //  }

      }
    });
    this.synth.setFunction = this.generator.setFunction.bind(this.generator);
  }

  _render(output) {
    if (output) {
      this.output = output;
      this.isRenderingAll = false;
    } else {
      this.isRenderingAll = true;
    }
  }

  _renderOut(i) {
    this.o[i].tick({
      time: this.synth.time,
      mouse: this.synth.mouse,
      bpm: this.synth.bpm,
      resolution: [this.canvas.width, this.canvas.height]
    });
  } // dt in ms


  tick(dt, uniforms) {
    this.sandbox.tick();
    if (this.detectAudio === true) this.synth.a.tick(); //  let updateInterval = 1000/this.synth.fps // ms

    this.sandbox.set('time', this.synth.time += dt * 0.001 * this.synth.speed);
    this.timeSinceLastUpdate += dt;

    if (!this.synth.fps || this.timeSinceLastUpdate >= 1000 / this.synth.fps) {
      //  console.log(1000/this.timeSinceLastUpdate)
      this.synth.stats.fps = Math.ceil(1000 / this.timeSinceLastUpdate);

      if (this.synth.update) {
        try {
          this.synth.update(this.timeSinceLastUpdate);
        } catch (e) {
          console.log(e);
        }
      } //  console.log(this.synth.speed, this.synth.time)


      for (let i = 0; i < this.s.length; i++) {
        this.s[i].tick(this.synth.time);
      } //  console.log(this.canvas.width, this.canvas.height)


      for (let i = 0; i < this.o.length; i++) {
        this._renderOut(i);
      }

      if (this.isRenderingAll) {
        this.renderAll({
          tex0: this.o[0].getCurrent(),
          tex1: this.o[1].getCurrent(),
          tex2: this.o[2].getCurrent(),
          tex3: this.o[3].getCurrent(),
          resolution: [this.canvas.width, this.canvas.height]
        });
      } else {
        this.renderFbo({
          tex0: this.output.getCurrent(),
          resolution: [this.canvas.width, this.canvas.height]
        });
      }

      this.timeSinceLastUpdate = 0;
    }

    if (this.saveFrame === true) {
      this.canvasToImage();
      this.saveFrame = false;
    } //  this.regl.poll()

  }

}

var _default = HydraRenderer;
exports.default = _default;

},{"./eval-sandbox.js":187,"./generator-factory.js":190,"./hydra-source.js":196,"./lib/array-utils.js":199,"./lib/audio.js":200,"./lib/mouse.js":203,"./lib/video-recorder.js":206,"./output.js":208,"raf-loop":96,"regl":102}],198:[function(require,module,exports){
"use strict";

var _hydraSynth = _interopRequireDefault(require("./hydra-synth.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

//import ShaderGenerator = require('./shader-generator.js')
// alert('hi')
// export default Synth
module.exports = _hydraSynth.default;

},{"./hydra-synth.js":197}],199:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _easingFunctions = _interopRequireDefault(require("./easing-functions.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// WIP utils for working with arrays
// Possibly should be integrated with lfo extension, etc.
// to do: transform time rather than array values, similar to working with coordinates in hydra
var map = (num, in_min, in_max, out_min, out_max) => {
  return (num - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
};

var _default = {
  init: () => {
    Array.prototype.fast = function (speed = 1) {
      this._speed = speed;
      return this;
    };

    Array.prototype.smooth = function (smooth = 1) {
      this._smooth = smooth;
      return this;
    };

    Array.prototype.ease = function (ease = 'linear') {
      if (typeof ease == 'function') {
        this._smooth = 1;
        this._ease = ease;
      } else if (_easingFunctions.default[ease]) {
        this._smooth = 1;
        this._ease = _easingFunctions.default[ease];
      }

      return this;
    };

    Array.prototype.offset = function (offset = 0.5) {
      this._offset = offset % 1.0;
      return this;
    }; // Array.prototype.bounce = function() {
    //   this.modifiers.bounce = true
    //   return this
    // }


    Array.prototype.fit = function (low = 0, high = 1) {
      let lowest = Math.min(...this);
      let highest = Math.max(...this);
      var newArr = this.map(num => map(num, lowest, highest, low, high));
      newArr._speed = this._speed;
      newArr._smooth = this._smooth;
      newArr._ease = this._ease;
      return newArr;
    };
  },
  getValue: (arr = []) => ({
    time,
    bpm
  }) => {
    let speed = arr._speed ? arr._speed : 1;
    let smooth = arr._smooth ? arr._smooth : 0;
    let index = time * speed * (bpm / 60) + (arr._offset || 0);

    if (smooth !== 0) {
      let ease = arr._ease ? arr._ease : _easingFunctions.default['linear'];

      let _index = index - smooth / 2;

      let currValue = arr[Math.floor(_index % arr.length)];
      let nextValue = arr[Math.floor((_index + 1) % arr.length)];
      let t = Math.min(_index % 1 / smooth, 1);
      return ease(t) * (nextValue - currValue) + currValue;
    } else {
      return arr[Math.floor(index % arr.length)];
    }
  }
};
exports.default = _default;

},{"./easing-functions.js":201}],200:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _meyda = _interopRequireDefault(require("meyda"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class Audio {
  constructor({
    numBins = 4,
    cutoff = 2,
    smooth = 0.4,
    max = 15,
    scale = 10,
    isDrawing = false,
    parentEl = document.body
  }) {
    this.vol = 0;
    this.scale = scale;
    this.max = max;
    this.cutoff = cutoff;
    this.smooth = smooth;
    this.setBins(numBins); // beat detection from: https://github.com/therewasaguy/p5-music-viz/blob/gh-pages/demos/01d_beat_detect_amplitude/sketch.js

    this.beat = {
      holdFrames: 20,
      threshold: 40,
      _cutoff: 0,
      // adaptive based on sound state
      decay: 0.98,
      _framesSinceBeat: 0 // keeps track of frames

    };

    this.onBeat = () => {//  console.log("beat")
    };

    this.canvas = document.createElement('canvas');
    this.canvas.width = 100;
    this.canvas.height = 80;
    this.canvas.style.width = "100px";
    this.canvas.style.height = "80px";
    this.canvas.style.position = 'absolute';
    this.canvas.style.right = '0px';
    this.canvas.style.bottom = '0px';
    parentEl.appendChild(this.canvas);
    this.isDrawing = isDrawing;
    this.ctx = this.canvas.getContext('2d');
    this.ctx.fillStyle = "#DFFFFF";
    this.ctx.strokeStyle = "#0ff";
    this.ctx.lineWidth = 0.5;

    if (window.navigator.mediaDevices) {
      window.navigator.mediaDevices.getUserMedia({
        video: false,
        audio: true
      }).then(stream => {
        //  console.log('got mic stream', stream)
        this.stream = stream;
        this.context = new AudioContext(); //  this.context = new AudioContext()

        let audio_stream = this.context.createMediaStreamSource(stream); //  console.log(this.context)

        this.meyda = _meyda.default.createMeydaAnalyzer({
          audioContext: this.context,
          source: audio_stream,
          featureExtractors: ['loudness' //  'perceptualSpread',
          //  'perceptualSharpness',
          //  'spectralCentroid'
          ]
        });
      }).catch(err => console.log('ERROR', err));
    }
  }

  detectBeat(level) {
    //console.log(level,   this.beat._cutoff)
    if (level > this.beat._cutoff && level > this.beat.threshold) {
      this.onBeat();
      this.beat._cutoff = level * 1.2;
      this.beat._framesSinceBeat = 0;
    } else {
      if (this.beat._framesSinceBeat <= this.beat.holdFrames) {
        this.beat._framesSinceBeat++;
      } else {
        this.beat._cutoff *= this.beat.decay;
        this.beat._cutoff = Math.max(this.beat._cutoff, this.beat.threshold);
      }
    }
  }

  tick() {
    if (this.meyda) {
      var features = this.meyda.get();

      if (features && features !== null) {
        this.vol = features.loudness.total;
        this.detectBeat(this.vol); // reduce loudness array to number of bins

        const reducer = (accumulator, currentValue) => accumulator + currentValue;

        let spacing = Math.floor(features.loudness.specific.length / this.bins.length);
        this.prevBins = this.bins.slice(0);
        this.bins = this.bins.map((bin, index) => {
          return features.loudness.specific.slice(index * spacing, (index + 1) * spacing).reduce(reducer);
        }).map((bin, index) => {
          // map to specified range
          // return (bin * (1.0 - this.smooth) + this.prevBins[index] * this.smooth)
          return bin * (1.0 - this.settings[index].smooth) + this.prevBins[index] * this.settings[index].smooth;
        }); // var y = this.canvas.height - scale*this.settings[index].cutoff
        // this.ctx.beginPath()
        // this.ctx.moveTo(index*spacing, y)
        // this.ctx.lineTo((index+1)*spacing, y)
        // this.ctx.stroke()
        //
        // var yMax = this.canvas.height - scale*(this.settings[index].scale + this.settings[index].cutoff)

        this.fft = this.bins.map((bin, index) => // Math.max(0, (bin - this.cutoff) / (this.max - this.cutoff))
        Math.max(0, (bin - this.settings[index].cutoff) / this.settings[index].scale));
        if (this.isDrawing) this.draw();
      }
    }
  }

  setCutoff(cutoff) {
    this.cutoff = cutoff;
    this.settings = this.settings.map(el => {
      el.cutoff = cutoff;
      return el;
    });
  }

  setSmooth(smooth) {
    this.smooth = smooth;
    this.settings = this.settings.map(el => {
      el.smooth = smooth;
      return el;
    });
  }

  setBins(numBins) {
    this.bins = Array(numBins).fill(0);
    this.prevBins = Array(numBins).fill(0);
    this.fft = Array(numBins).fill(0);
    this.settings = Array(numBins).fill(0).map(() => ({
      cutoff: this.cutoff,
      scale: this.scale,
      smooth: this.smooth
    })); // to do: what to do in non-global mode?

    this.bins.forEach((bin, index) => {
      window['a' + index] = (scale = 1, offset = 0) => () => a.fft[index] * scale + offset;
    }); //  console.log(this.settings)
  }

  setScale(scale) {
    this.scale = scale;
    this.settings = this.settings.map(el => {
      el.scale = scale;
      return el;
    });
  }

  setMax(max) {
    this.max = max;
    console.log('set max is deprecated');
  }

  hide() {
    this.isDrawing = false;
    this.canvas.style.display = 'none';
  }

  show() {
    this.isDrawing = true;
    this.canvas.style.display = 'block';
  }

  draw() {
    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
    var spacing = this.canvas.width / this.bins.length;
    var scale = this.canvas.height / (this.max * 2); //  console.log(this.bins)

    this.bins.forEach((bin, index) => {
      var height = bin * scale;
      this.ctx.fillRect(index * spacing, this.canvas.height - height, spacing, height); //   console.log(this.settings[index])

      var y = this.canvas.height - scale * this.settings[index].cutoff;
      this.ctx.beginPath();
      this.ctx.moveTo(index * spacing, y);
      this.ctx.lineTo((index + 1) * spacing, y);
      this.ctx.stroke();
      var yMax = this.canvas.height - scale * (this.settings[index].scale + this.settings[index].cutoff);
      this.ctx.beginPath();
      this.ctx.moveTo(index * spacing, yMax);
      this.ctx.lineTo((index + 1) * spacing, yMax);
      this.ctx.stroke();
    });
    /*var y = this.canvas.height - scale*this.cutoff
    this.ctx.beginPath()
    this.ctx.moveTo(0, y)
    this.ctx.lineTo(this.canvas.width, y)
    this.ctx.stroke()
    var yMax = this.canvas.height - scale*this.max
    this.ctx.beginPath()
    this.ctx.moveTo(0, yMax)
    this.ctx.lineTo(this.canvas.width, yMax)
    this.ctx.stroke()*/
  }

}

var _default = Audio;
exports.default = _default;

},{"meyda":84}],201:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
// from https://gist.github.com/gre/1650294
var _default = {
  // no easing, no acceleration
  linear: function (t) {
    return t;
  },
  // accelerating from zero velocity
  easeInQuad: function (t) {
    return t * t;
  },
  // decelerating to zero velocity
  easeOutQuad: function (t) {
    return t * (2 - t);
  },
  // acceleration until halfway, then deceleration
  easeInOutQuad: function (t) {
    return t < .5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
  },
  // accelerating from zero velocity
  easeInCubic: function (t) {
    return t * t * t;
  },
  // decelerating to zero velocity
  easeOutCubic: function (t) {
    return --t * t * t + 1;
  },
  // acceleration until halfway, then deceleration
  easeInOutCubic: function (t) {
    return t < .5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;
  },
  // accelerating from zero velocity
  easeInQuart: function (t) {
    return t * t * t * t;
  },
  // decelerating to zero velocity
  easeOutQuart: function (t) {
    return 1 - --t * t * t * t;
  },
  // acceleration until halfway, then deceleration
  easeInOutQuart: function (t) {
    return t < .5 ? 8 * t * t * t * t : 1 - 8 * --t * t * t * t;
  },
  // accelerating from zero velocity
  easeInQuint: function (t) {
    return t * t * t * t * t;
  },
  // decelerating to zero velocity
  easeOutQuint: function (t) {
    return 1 + --t * t * t * t * t;
  },
  // acceleration until halfway, then deceleration
  easeInOutQuint: function (t) {
    return t < .5 ? 16 * t * t * t * t * t : 1 + 16 * --t * t * t * t * t;
  },
  // sin shape
  sin: function (t) {
    return (1 + Math.sin(Math.PI * t - Math.PI / 2)) / 2;
  }
};
exports.default = _default;

},{}],202:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
// https://github.com/mikolalysenko/mouse-event
const mouse = {};

function mouseButtons(ev) {
  if (typeof ev === 'object') {
    if ('buttons' in ev) {
      return ev.buttons;
    } else if ('which' in ev) {
      var b = ev.which;

      if (b === 2) {
        return 4;
      } else if (b === 3) {
        return 2;
      } else if (b > 0) {
        return 1 << b - 1;
      }
    } else if ('button' in ev) {
      var b = ev.button;

      if (b === 1) {
        return 4;
      } else if (b === 2) {
        return 2;
      } else if (b >= 0) {
        return 1 << b;
      }
    }
  }

  return 0;
}

mouse.buttons = mouseButtons;

function mouseElement(ev) {
  return ev.target || ev.srcElement || window;
}

mouse.element = mouseElement;

function mouseRelativeX(ev) {
  if (typeof ev === 'object') {
    if ('pageX' in ev) {
      return ev.pageX;
    }
  }

  return 0;
}

mouse.x = mouseRelativeX;

function mouseRelativeY(ev) {
  if (typeof ev === 'object') {
    if ('pageY' in ev) {
      return ev.pageY;
    }
  }

  return 0;
}

mouse.y = mouseRelativeY;
var _default = mouse;
exports.default = _default;

},{}],203:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _mouseEvent = _interopRequireDefault(require("./mouse-event.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// based on https://github.com/mikolalysenko/mouse-change
var _default = mouseListen;
exports.default = _default;

function mouseListen(element, callback) {
  if (!callback) {
    callback = element;
    element = window;
  }

  var buttonState = 0;
  var x = 0;
  var y = 0;
  var mods = {
    shift: false,
    alt: false,
    control: false,
    meta: false
  };
  var attached = false;

  function updateMods(ev) {
    var changed = false;

    if ('altKey' in ev) {
      changed = changed || ev.altKey !== mods.alt;
      mods.alt = !!ev.altKey;
    }

    if ('shiftKey' in ev) {
      changed = changed || ev.shiftKey !== mods.shift;
      mods.shift = !!ev.shiftKey;
    }

    if ('ctrlKey' in ev) {
      changed = changed || ev.ctrlKey !== mods.control;
      mods.control = !!ev.ctrlKey;
    }

    if ('metaKey' in ev) {
      changed = changed || ev.metaKey !== mods.meta;
      mods.meta = !!ev.metaKey;
    }

    return changed;
  }

  function handleEvent(nextButtons, ev) {
    var nextX = _mouseEvent.default.x(ev);

    var nextY = _mouseEvent.default.y(ev);

    if ('buttons' in ev) {
      nextButtons = ev.buttons | 0;
    }

    if (nextButtons !== buttonState || nextX !== x || nextY !== y || updateMods(ev)) {
      buttonState = nextButtons | 0;
      x = nextX || 0;
      y = nextY || 0;
      callback && callback(buttonState, x, y, mods);
    }
  }

  function clearState(ev) {
    handleEvent(0, ev);
  }

  function handleBlur() {
    if (buttonState || x || y || mods.shift || mods.alt || mods.meta || mods.control) {
      x = y = 0;
      buttonState = 0;
      mods.shift = mods.alt = mods.control = mods.meta = false;
      callback && callback(0, 0, 0, mods);
    }
  }

  function handleMods(ev) {
    if (updateMods(ev)) {
      callback && callback(buttonState, x, y, mods);
    }
  }

  function handleMouseMove(ev) {
    if (_mouseEvent.default.buttons(ev) === 0) {
      handleEvent(0, ev);
    } else {
      handleEvent(buttonState, ev);
    }
  }

  function handleMouseDown(ev) {
    handleEvent(buttonState | _mouseEvent.default.buttons(ev), ev);
  }

  function handleMouseUp(ev) {
    handleEvent(buttonState & ~_mouseEvent.default.buttons(ev), ev);
  }

  function attachListeners() {
    if (attached) {
      return;
    }

    attached = true;
    element.addEventListener('mousemove', handleMouseMove);
    element.addEventListener('mousedown', handleMouseDown);
    element.addEventListener('mouseup', handleMouseUp);
    element.addEventListener('mouseleave', clearState);
    element.addEventListener('mouseenter', clearState);
    element.addEventListener('mouseout', clearState);
    element.addEventListener('mouseover', clearState);
    element.addEventListener('blur', handleBlur);
    element.addEventListener('keyup', handleMods);
    element.addEventListener('keydown', handleMods);
    element.addEventListener('keypress', handleMods);

    if (element !== window) {
      window.addEventListener('blur', handleBlur);
      window.addEventListener('keyup', handleMods);
      window.addEventListener('keydown', handleMods);
      window.addEventListener('keypress', handleMods);
    }
  }

  function detachListeners() {
    if (!attached) {
      return;
    }

    attached = false;
    element.removeEventListener('mousemove', handleMouseMove);
    element.removeEventListener('mousedown', handleMouseDown);
    element.removeEventListener('mouseup', handleMouseUp);
    element.removeEventListener('mouseleave', clearState);
    element.removeEventListener('mouseenter', clearState);
    element.removeEventListener('mouseout', clearState);
    element.removeEventListener('mouseover', clearState);
    element.removeEventListener('blur', handleBlur);
    element.removeEventListener('keyup', handleMods);
    element.removeEventListener('keydown', handleMods);
    element.removeEventListener('keypress', handleMods);

    if (element !== window) {
      window.removeEventListener('blur', handleBlur);
      window.removeEventListener('keyup', handleMods);
      window.removeEventListener('keydown', handleMods);
      window.removeEventListener('keypress', handleMods);
    }
  } // Attach listeners


  attachListeners();
  var result = {
    element: element
  };
  Object.defineProperties(result, {
    enabled: {
      get: function () {
        return attached;
      },
      set: function (f) {
        if (f) {
          attachListeners();
        } else {
          detachListeners();
        }
      },
      enumerable: true
    },
    buttons: {
      get: function () {
        return buttonState;
      },
      enumerable: true
    },
    x: {
      get: function () {
        return x;
      },
      enumerable: true
    },
    y: {
      get: function () {
        return y;
      },
      enumerable: true
    },
    mods: {
      get: function () {
        return mods;
      },
      enumerable: true
    }
  });
  return result;
}

},{"./mouse-event.js":202}],204:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

// attempt custom evaluation sandbox for hydra functions
// for now, just avoids polluting the global namespace
// should probably be replaced with an abstract syntax tree
var _default = parent => {
  var initialCode = ``;
  var sandbox = createSandbox(initialCode);

  var addToContext = (name, object) => {
    initialCode += `
      var ${name} = ${object}
    `;
    sandbox = createSandbox(initialCode);
  };

  return {
    addToContext: addToContext,
    eval: code => sandbox.eval(code)
  };

  function createSandbox(initial) {
    globalThis.eval(initial); // optional params

    var localEval = function (code) {
      globalThis.eval(code);
    }; // API/data for end-user


    return {
      eval: localEval
    };
  }
};

exports.default = _default;

},{}],205:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default(options) {
  return new Promise(function (resolve, reject) {
    //  async function startCapture(displayMediaOptions) {
    navigator.mediaDevices.getDisplayMedia(options).then(stream => {
      const video = document.createElement('video');
      video.srcObject = stream;
      video.addEventListener('loadedmetadata', () => {
        video.play();
        resolve({
          video: video
        });
      });
    }).catch(err => reject(err));
  });
}

},{}],206:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

class VideoRecorder {
  constructor(stream) {
    this.mediaSource = new MediaSource();
    this.stream = stream; // testing using a recording as input

    this.output = document.createElement('video');
    this.output.autoplay = true;
    this.output.loop = true;
    let self = this;
    this.mediaSource.addEventListener('sourceopen', () => {
      console.log('MediaSource opened');
      self.sourceBuffer = self.mediaSource.addSourceBuffer('video/webm; codecs="vp8"');
      console.log('Source buffer: ', sourceBuffer);
    });
  }

  start() {
    //  let options = {mimeType: 'video/webm'};
    //   let options = {mimeType: 'video/webm;codecs=h264'};
    let options = {
      mimeType: 'video/webm;codecs=vp9'
    };
    this.recordedBlobs = [];

    try {
      this.mediaRecorder = new MediaRecorder(this.stream, options);
    } catch (e0) {
      console.log('Unable to create MediaRecorder with options Object: ', e0);

      try {
        options = {
          mimeType: 'video/webm,codecs=vp9'
        };
        this.mediaRecorder = new MediaRecorder(this.stream, options);
      } catch (e1) {
        console.log('Unable to create MediaRecorder with options Object: ', e1);

        try {
          options = 'video/vp8'; // Chrome 47

          this.mediaRecorder = new MediaRecorder(this.stream, options);
        } catch (e2) {
          alert('MediaRecorder is not supported by this browser.\n\n' + 'Try Firefox 29 or later, or Chrome 47 or later, ' + 'with Enable experimental Web Platform features enabled from chrome://flags.');
          console.error('Exception while creating MediaRecorder:', e2);
          return;
        }
      }
    }

    console.log('Created MediaRecorder', this.mediaRecorder, 'with options', options);
    this.mediaRecorder.onstop = this._handleStop.bind(this);
    this.mediaRecorder.ondataavailable = this._handleDataAvailable.bind(this);
    this.mediaRecorder.start(100); // collect 100ms of data

    console.log('MediaRecorder started', this.mediaRecorder);
  }

  stop() {
    this.mediaRecorder.stop();
  }

  _handleStop() {
    //const superBuffer = new Blob(recordedBlobs, {type: 'video/webm'})
    // const blob = new Blob(this.recordedBlobs, {type: 'video/webm;codecs=h264'})
    const blob = new Blob(this.recordedBlobs, {
      type: this.mediaRecorder.mimeType
    });
    const url = window.URL.createObjectURL(blob);
    this.output.src = url;
    const a = document.createElement('a');
    a.style.display = 'none';
    a.href = url;
    let d = new Date();
    a.download = `hydra-${d.getFullYear()}-${d.getMonth() + 1}-${d.getDate()}-${d.getHours()}.${d.getMinutes()}.${d.getSeconds()}.webm`;
    document.body.appendChild(a);
    a.click();
    setTimeout(() => {
      document.body.removeChild(a);
      window.URL.revokeObjectURL(url);
    }, 300);
  }

  _handleDataAvailable(event) {
    if (event.data && event.data.size > 0) {
      this.recordedBlobs.push(event.data);
    }
  }

}

var _default = VideoRecorder;
exports.default = _default;

},{}],207:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

//const enumerateDevices = require('enumerate-devices')
function _default(deviceId) {
  return navigator.mediaDevices.enumerateDevices().then(devices => devices.filter(devices => devices.kind === 'videoinput')).then(cameras => {
    let constraints = {
      audio: false,
      video: true
    };

    if (cameras[deviceId]) {
      constraints['video'] = {
        deviceId: {
          exact: cameras[deviceId].deviceId
        }
      };
    } //  console.log(cameras)


    return window.navigator.mediaDevices.getUserMedia(constraints);
  }).then(stream => {
    const video = document.createElement('video');
    video.setAttribute('autoplay', '');
    video.setAttribute('muted', '');
    video.setAttribute('playsinline', ''); //  video.src = window.URL.createObjectURL(stream)

    video.srcObject = stream;
    return new Promise((resolve, reject) => {
      video.addEventListener('loadedmetadata', () => {
        video.play().then(() => resolve({
          video: video
        }));
      });
    });
  }).catch(console.log.bind(console));
}

},{}],208:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var mat4 = _interopRequireWildcard(require("gl-mat4"));

var _glslSource = _interopRequireDefault(require("./glsl-source.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

var Output = function (index, synth) {
  this.id = index;
  this.synth = synth;
  this.width = synth.width;
  this.height = synth.height;
  this.regl = synth.regl;
  this.precision = synth.precision;
  this.label = `o${index}`;
  this.positionBuffer = this.regl.buffer([[-5, -1, 0], [-1, -5, 0], [3, 3, 0]]);
  this.uvBuffer = this.regl.buffer([[-2, 0], [0, -2], [2, 2]]);
  this.draw = [];
  this.init();
  this.pingPongIndex = 0; // for each output, create two fbos for pingponging

  this.fbos = Array(2).fill().map(() => this._initFbo()); // for each output, create two temp buffers

  this.temp = Array(2).fill().map(() => this._initFbo());
  this.copyPass = this.regl({
    frag: `
      precision ${this.precision} float;
      varying vec2 uv;
      uniform sampler2D tex0;

      void main () {
        gl_FragColor = texture2D(tex0, uv);
      }
      `,
    vert: `
      precision ${this.precision} float;
      attribute vec2 position;
      varying vec2 uv;

      void main () {
        uv = position;
        gl_Position = vec4(2.0 * position - 1.0, 0, 1);
      }`,
    attributes: {
      position: [[-2, 0], [0, -2], [2, 2]]
    },
    uniforms: {
      tex0: this.regl.prop('tex0')
    },
    count: 3,
    depth: {
      enable: false
    },
    framebuffer: () => this.getTexture()
  });
};

Output.prototype._initFbo = function (options = {}) {
  const {
    color,
    ...fbOptions
  } = Object.assign({
    color: {
      mag: 'nearest',
      width: this.width,
      height: this.height,
      format: 'rgba'
    }
  }, options);
  return this.regl.framebuffer({
    color: this.regl.texture(color),
    depthStencil: false,
    ...fbOptions
  });
};

Output.prototype.resize = function (width, height) {
  this.width = width;
  this.height = height;
  this.fbos.forEach(fbo => {
    fbo.resize(width, height);
  });
  this.temp.forEach(tmp => {
    tmp.resize(width, height);
  });
};

Output.prototype.getCurrent = function () {
  return this.fbos[this.pingPongIndex];
};

Output.prototype.getTexture = function () {
  var index = this.pingPongIndex ? 0 : 1;
  return this.fbos[index];
};

Output.prototype.init = function () {
  this.attributes = {
    position: this.positionBuffer,
    uv: this.uvBuffer
  };
  this.uniforms = {
    time: this.regl.prop('time'),
    resolution: this.regl.prop('resolution')
  };
  this.initCamera();
  return this;
};

Output.prototype.initCamera = function () {
  this._camera = this.regl({
    context: {
      projection: mat4.identity([]),
      view: mat4.identity([])
    },
    uniforms: {
      view: this.regl.context('view'),
      projection: this.regl.context('projection')
    }
  });
};

Output.prototype.camera = function (eye, target = [0, 0, 0], options = {}) {
  options = Object.assign({
    fovy: Math.PI / 4,
    near: 0.1,
    far: 1000.0
  }, options);
  this.eye = eye;
  this.target = target;

  if (eye && target) {
    this._camera = this.regl({
      context: {
        projection: function (context) {
          if (options.type === 'perspective') {
            return mat4.perspective([], options.fovy, options.aspect || context.viewportWidth / context.viewportHeight, options.near, options.far);
          } else {
            return mat4.ortho([], -1.0, 1.0, -1.0, 1.0, options.near, options.far);
          }
        },
        view: function (context, props) {
          return mat4.lookAt([], props.eye, props.target, [0, 1, 0]);
        },
        eye: this.regl.prop('eye')
      },
      uniforms: {
        view: this.regl.context('view'),
        projection: this.regl.context('projection')
      }
    });
  } else {
    this.initCamera();
  }

  return this;
};

Output.prototype.perspective = function (eye, target = [0, 0, 0], options = {}) {
  options = Object.assign({
    type: 'perspective'
  }, options);
  return this.camera(eye, target, options);
};

Output.prototype.ortho = function (eye, target = [0, 0, 0], options = {}) {
  options = Object.assign({
    type: 'ortho'
  }, options);
  return this.camera(eye, target, options);
};

Output.prototype.render = function (passes) {
  const self = this; // ensure both fbo's have last frame

  this.copyPass({
    tex0: this.getCurrent()
  });
  self.draw = [];
  self.passes = passes;

  for (let i = 0; i < passes.length; i++) {
    let pass = passes[i];

    if (pass.clear) {
      switch (pass.clear) {
        case 'clear':
          self.draw.push(...this.clear(false));
          break;

        case 'fade':
          {
            const opt = typeof pass.userArgs[0] === 'object' ? pass.userArgs[0] : {
              amount: pass.userArgs[0]
            };
            opt.now = false;
            self.draw.push(this.fade(opt));
            break;
          }

        default:
          console.warn(`unrecognized clear: ${pass.clear}(${pass.userArgs.join(", ")})`);
          break;
      }

      continue;
    }

    const {
      attributes,
      elements,
      primitive
    } = this.getAttributes(pass.primitive, pass.geometry);
    const uniforms = this.getUniforms(pass.uniforms);
    const blend = this.getBlend(pass.blendMode);
    const draw = self.regl({
      frag: pass.frag,
      vert: pass.vert,
      viewport: typeof pass.viewport.x !== 'undefined' ? {
        x: pass.viewport.x * this.fbos[0].width,
        y: pass.viewport.y * this.fbos[0].height,
        width: pass.viewport.w * this.fbos[0].width,
        height: pass.viewport.h * this.fbos[0].height
      } : {},
      cull: {
        enable: !!pass.geometry,
        face: 'back'
      },
      attributes,
      primitive,
      uniforms,
      count: typeof elements === 'number' ? elements : elements.length,
      elements: typeof elements === 'number' ? null : elements,
      blend,
      lineWidth: pass.lineWidth,
      framebuffer: pass.framebuffer || (() => {
        self.pingPongIndex = self.pingPongIndex ? 0 : 1;
        return self.fbos[self.pingPongIndex];
      })
    });
    self.draw.push(draw);
  }
};

Output.prototype.clear = function (now = true) {
  const result = [this.fbos[0], this.fbos[1], this.temp[0], this.temp[1]].map(fbo => {
    const clear = () => this.regl.clear({
      color: [0, 0, 0, 0],
      framebuffer: fbo
    });

    if (now) clear();else return clear;
  });
  if (now) return this;
  return result;
};

Output.prototype.fade = function (options) {
  let amount = options;
  let camera = false;
  let now = true;

  if (typeof options === 'object') {
    ({
      amount,
      camera
    } = options);
    now = typeof options.now === 'undefined' ? true : options.now;
  }

  const self = this; // todo: do we need to fade also temp buffers?

  const fade = self.regl({
    frag: `
          precision ${self.precision} float;
          varying vec2 vuv;
          uniform sampler2D prevBuffer;
          void main() {
            vec4 color = mix(texture2D(prevBuffer, vuv), vec4(0), ${amount});
            gl_FragColor = color;
          }
        `,
    vert: _glslSource.default.compileVert(this.precision, camera, {
      glslName: 'clear'
    }),
    attributes: self.attributes,
    primitive: 'triangles',
    uniforms: Object.assign({}, {
      prevBuffer: () => {
        return self.fbos[self.pingPongIndex];
      }
    }, this.uniforms),
    count: 3,
    // next framebuffer
    framebuffer: () => {
      return self.fbos[self.pingPongIndex ? 0 : 1];
    }
  });
  if (now) return this;
  return fade;
};

Output.prototype.getAttributes = function (primitive, geometry) {
  let elements = 3;
  let attributes = this.attributes;

  if (geometry) {
    attributes = {};

    if (geometry.isBufferGeometry) {
      Object.keys(geometry.attributes).forEach(key => attributes[key] = geometry.attributes[key].array);
      elements = geometry.index ? geometry.index.array : geometry.attributes.position.count;
      primitive || (primitive = geometry.parameters.primitive);
    } else if (geometry.positions && (geometry.edges || geometry.cells)) {
      attributes.position = []; // todo: should be Float32Array

      geometry.positions.map((v, k) => attributes.position.push(v[0], v[1], 0));
      elements = geometry.edges ? geometry.edges : geometry.cells;
      primitive = geometry.edges ? 'lines' : 'triangles';
    }
  }

  primitive || (primitive = 'triangles');
  return {
    attributes,
    elements,
    primitive
  };
};

Output.prototype.getUniforms = function (uniforms) {
  const self = this;
  uniforms = Object.assign(uniforms, {
    prevBuffer: () => {
      // todo: changed, originally:
      // return self.fbos[self.pingPongIndex]
      return self.fbos[self.pingPongIndex ? 0 : 1];
    }
  });
  return Object.keys(uniforms).reduce((acc, key) => {
    acc[key] = typeof uniforms[key] === 'string' ? parseFloat(uniforms[key]) : uniforms[key];
    return acc;
  }, {});
};

Output.prototype.getBlend = function (blendMode) {
  let func;

  switch (blendMode) {
    case 'custom':
      func = {
        srcRGB: 'custom',
        // Define your custom blending function here
        dstRGB: 'custom',
        srcAlpha: 'custom',
        dstAlpha: 'custom'
      };
      break;

    case 'overlay':
      func = {
        srcRGB: 'dst color',
        dstRGB: 'one minus src color',
        srcAlpha: 'dst alpha',
        dstAlpha: 'one minus src alpha'
      };
      break;

    case 'screen':
      func = {
        srcRGB: 'one minus dst color',
        dstRGB: 'one',
        srcAlpha: 'one minus dst alpha',
        dstAlpha: 'one'
      };
      break;

    case 'multiply':
      func = {
        srcRGB: 'dst color',
        dstRGB: 'zero',
        srcAlpha: 'dst alpha',
        dstAlpha: 'zero'
      };
      break;

    case 'add':
      func = {
        srcRGB: 'one',
        dstRGB: 'one',
        srcAlpha: 'one',
        dstAlpha: 'one'
      };
      break;

    case 'alpha':
    default:
      func = {
        srcRGB: 'src alpha',
        srcAlpha: 1,
        dstRGB: 'one minus src alpha',
        dstAlpha: 1
      };
      break;
  }

  return {
    enable: blendMode ? typeof blendMode === 'string' ? blendMode !== 'disabled' : blendMode : false,
    func
  };
};

Output.prototype.tick = function (props) {
  const doDraw = () => this.draw.map(fn => fn(props));

  this._camera({
    eye: this.eye,
    target: this.target
  }, function () {
    doDraw();
  });
};

Output.prototype.renderTexture = function (options = {}) {
  const next = this.pingPongIndex ? 0 : 1;
  const original = this.fbos;
  this.fbos.map(() => this._initFbo({
    color: options
  }));

  this.synth._renderOut(this.id);

  const colorTex = this.fbos[this.pingPongIndex].color;
  this.fbos = original;
  return Array.isArray(colorTex) ? colorTex[0] : colorTex;
};

var _default = Output;
exports.default = _default;

},{"./glsl-source.js":191,"gl-mat4":62}],209:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.typeLookup = exports.getTypeLookup = exports.getLookup = exports.castType = void 0;
const typeLookup = {
  'src': {
    returnType: 'vec4',
    args: ['vec2 _st']
  },
  'vert': {
    returnType: 'vec4',
    args: ['vec2 _st']
  },
  'coord': {
    returnType: 'vec2',
    args: ['vec2 _st']
  },
  'color': {
    returnType: 'vec4',
    args: ['vec4 _c0']
  },
  'combine': {
    returnType: 'vec4',
    args: ['vec4 _c0', 'vec4 _c1']
  },
  'combineCoord': {
    returnType: 'vec2',
    args: ['vec2 _st', 'vec4 _c0']
  }
};
exports.typeLookup = typeLookup;
const getLookup = {
  float: 'x',
  vec2: 'xy',
  vec3: 'xyz',
  vec4: 'xyzw'
};
exports.getLookup = getLookup;
const getTypeLookup = {
  x: 'float',
  y: 'float',
  z: 'float',
  xy: 'vec2',
  yx: 'vec2',
  xyz: 'vec3',
  xzy: 'vec3',
  yzx: 'vec3',
  yxz: 'vec3',
  zxy: 'vec3',
  zyx: 'vec3',
  xyzw: 'vec4'
};
exports.getTypeLookup = getTypeLookup;

const castType = (func, fromType, toType, alpha = 0.0) => {
  const fromLen = fromType === 'float' ? 1 : fromType.substring(3);
  const toLen = toType === 'float' ? 1 : toType.substring(3);

  if (fromLen < toLen) {
    let diff = toLen - fromLen;
    let last = '';

    if (toType === 'vec4') {
      diff -= 1;
      last = ', ' + alpha;
    }

    func = `vec${toLen}(${func}${', 0.0'.repeat(diff)}${last})`;
  }

  return func;
};

exports.castType = castType;

},{}]},{},[198])(198)
});

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvYmFzZTY0LWpzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2JpZy1yYXQvYWRkLmpzIiwibm9kZV9tb2R1bGVzL2JpZy1yYXQvY21wLmpzIiwibm9kZV9tb2R1bGVzL2JpZy1yYXQvZGl2LmpzIiwibm9kZV9tb2R1bGVzL2JpZy1yYXQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYmlnLXJhdC9pcy1yYXQuanMiLCJub2RlX21vZHVsZXMvYmlnLXJhdC9saWIvYm4tc2lnbi5qcyIsIm5vZGVfbW9kdWxlcy9iaWctcmF0L2xpYi9ibi10by1udW0uanMiLCJub2RlX21vZHVsZXMvYmlnLXJhdC9saWIvY3R6LmpzIiwibm9kZV9tb2R1bGVzL2JpZy1yYXQvbGliL2lzLWJuLmpzIiwibm9kZV9tb2R1bGVzL2JpZy1yYXQvbGliL251bS10by1ibi5qcyIsIm5vZGVfbW9kdWxlcy9iaWctcmF0L2xpYi9yYXRpb25hbGl6ZS5qcyIsIm5vZGVfbW9kdWxlcy9iaWctcmF0L2xpYi9zdHItdG8tYm4uanMiLCJub2RlX21vZHVsZXMvYmlnLXJhdC9tdWwuanMiLCJub2RlX21vZHVsZXMvYmlnLXJhdC9ub2RlX21vZHVsZXMvYm4uanMvbGliL2JuLmpzIiwibm9kZV9tb2R1bGVzL2JpZy1yYXQvc2lnbi5qcyIsIm5vZGVfbW9kdWxlcy9iaWctcmF0L3N1Yi5qcyIsIm5vZGVfbW9kdWxlcy9iaWctcmF0L3RvLWZsb2F0LmpzIiwibm9kZV9tb2R1bGVzL2JpbmFyeS1zZWFyY2gtYm91bmRzL3NlYXJjaC1ib3VuZHMuanMiLCJub2RlX21vZHVsZXMvYml0LXR3aWRkbGUvdHdpZGRsZS5qcyIsIm5vZGVfbW9kdWxlcy9ib3gtaW50ZXJzZWN0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2JveC1pbnRlcnNlY3QvbGliL2JydXRlLmpzIiwibm9kZV9tb2R1bGVzL2JveC1pbnRlcnNlY3QvbGliL2ludGVyc2VjdC5qcyIsIm5vZGVfbW9kdWxlcy9ib3gtaW50ZXJzZWN0L2xpYi9tZWRpYW4uanMiLCJub2RlX21vZHVsZXMvYm94LWludGVyc2VjdC9saWIvcGFydGl0aW9uLmpzIiwibm9kZV9tb2R1bGVzL2JveC1pbnRlcnNlY3QvbGliL3NvcnQuanMiLCJub2RlX21vZHVsZXMvYm94LWludGVyc2VjdC9saWIvc3dlZXAuanMiLCJub2RlX21vZHVsZXMvYnJvd3Nlci1yZXNvbHZlL2VtcHR5LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2V2ZW50cy9ldmVudHMuanMiLCJub2RlX21vZHVsZXMvYnVmZmVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2NkdDJkL2NkdDJkLmpzIiwibm9kZV9tb2R1bGVzL2NkdDJkL2xpYi9kZWxhdW5heS5qcyIsIm5vZGVfbW9kdWxlcy9jZHQyZC9saWIvZmlsdGVyLmpzIiwibm9kZV9tb2R1bGVzL2NkdDJkL2xpYi9tb25vdG9uZS5qcyIsIm5vZGVfbW9kdWxlcy9jZHQyZC9saWIvdHJpYW5ndWxhdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9jbGVhbi1wc2xnL2NsZWFuLXBzbGcuanMiLCJub2RlX21vZHVsZXMvY2xlYW4tcHNsZy9saWIvcmF0LXNlZy1pbnRlcnNlY3QuanMiLCJub2RlX21vZHVsZXMvY29tcGFyZS1hbmdsZS9jbXBhbmdsZS5qcyIsIm5vZGVfbW9kdWxlcy9jd2lzZS1jb21waWxlci9jb21waWxlci5qcyIsIm5vZGVfbW9kdWxlcy9jd2lzZS1jb21waWxlci9saWIvY29tcGlsZS5qcyIsIm5vZGVfbW9kdWxlcy9jd2lzZS1jb21waWxlci9saWIvdGh1bmsuanMiLCJub2RlX21vZHVsZXMvZG91YmxlLWJpdHMvZG91YmxlLmpzIiwibm9kZV9tb2R1bGVzL2R1cC9kdXAuanMiLCJub2RlX21vZHVsZXMvZWRnZXMtdG8tYWRqYWNlbmN5LWxpc3QvZTJhLmpzIiwibm9kZV9tb2R1bGVzL2Z1bmN0aW9uYWwtcmVkLWJsYWNrLXRyZWUvcmJ0cmVlLmpzIiwibm9kZV9tb2R1bGVzL2dhbW1hL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2dsLW1hdDQvYWRqb2ludC5qcyIsIm5vZGVfbW9kdWxlcy9nbC1tYXQ0L2Nsb25lLmpzIiwibm9kZV9tb2R1bGVzL2dsLW1hdDQvY29weS5qcyIsIm5vZGVfbW9kdWxlcy9nbC1tYXQ0L2NyZWF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9nbC1tYXQ0L2RldGVybWluYW50LmpzIiwibm9kZV9tb2R1bGVzL2dsLW1hdDQvZnJvbVF1YXQuanMiLCJub2RlX21vZHVsZXMvZ2wtbWF0NC9mcm9tUm90YXRpb24uanMiLCJub2RlX21vZHVsZXMvZ2wtbWF0NC9mcm9tUm90YXRpb25UcmFuc2xhdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9nbC1tYXQ0L2Zyb21TY2FsaW5nLmpzIiwibm9kZV9tb2R1bGVzL2dsLW1hdDQvZnJvbVRyYW5zbGF0aW9uLmpzIiwibm9kZV9tb2R1bGVzL2dsLW1hdDQvZnJvbVhSb3RhdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9nbC1tYXQ0L2Zyb21ZUm90YXRpb24uanMiLCJub2RlX21vZHVsZXMvZ2wtbWF0NC9mcm9tWlJvdGF0aW9uLmpzIiwibm9kZV9tb2R1bGVzL2dsLW1hdDQvZnJ1c3R1bS5qcyIsIm5vZGVfbW9kdWxlcy9nbC1tYXQ0L2lkZW50aXR5LmpzIiwibm9kZV9tb2R1bGVzL2dsLW1hdDQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZ2wtbWF0NC9pbnZlcnQuanMiLCJub2RlX21vZHVsZXMvZ2wtbWF0NC9sb29rQXQuanMiLCJub2RlX21vZHVsZXMvZ2wtbWF0NC9tdWx0aXBseS5qcyIsIm5vZGVfbW9kdWxlcy9nbC1tYXQ0L29ydGhvLmpzIiwibm9kZV9tb2R1bGVzL2dsLW1hdDQvcGVyc3BlY3RpdmUuanMiLCJub2RlX21vZHVsZXMvZ2wtbWF0NC9wZXJzcGVjdGl2ZUZyb21GaWVsZE9mVmlldy5qcyIsIm5vZGVfbW9kdWxlcy9nbC1tYXQ0L3JvdGF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9nbC1tYXQ0L3JvdGF0ZVguanMiLCJub2RlX21vZHVsZXMvZ2wtbWF0NC9yb3RhdGVZLmpzIiwibm9kZV9tb2R1bGVzL2dsLW1hdDQvcm90YXRlWi5qcyIsIm5vZGVfbW9kdWxlcy9nbC1tYXQ0L3NjYWxlLmpzIiwibm9kZV9tb2R1bGVzL2dsLW1hdDQvc3RyLmpzIiwibm9kZV9tb2R1bGVzL2dsLW1hdDQvdHJhbnNsYXRlLmpzIiwibm9kZV9tb2R1bGVzL2dsLW1hdDQvdHJhbnNwb3NlLmpzIiwibm9kZV9tb2R1bGVzL2dsc2xpZnkvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9pZWVlNzU0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2luaGVyaXRzL2luaGVyaXRzX2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvaW50ZXJ2YWwtdHJlZS0xZC9pbnRlcnZhbC10cmVlLmpzIiwibm9kZV9tb2R1bGVzL2ludmVydC1wZXJtdXRhdGlvbi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pb3RhLWFycmF5L2lvdGEuanMiLCJub2RlX21vZHVsZXMvaXMtYnVmZmVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL21leWRhL2Rpc3Qvd2ViL21leWRhLm1pbi5qcyIsIm5vZGVfbW9kdWxlcy9uZGFycmF5LWV4dHJhY3QtY29udG91ci9jb250b3VyLmpzIiwibm9kZV9tb2R1bGVzL25kYXJyYXkvbmRhcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9uZXh0YWZ0ZXIvbmV4dGFmdGVyLmpzIiwibm9kZV9tb2R1bGVzL3BlcmZvcm1hbmNlLW5vdy9saWIvcGVyZm9ybWFuY2Utbm93LmpzIiwibm9kZV9tb2R1bGVzL3Blcm11dGF0aW9uLXBhcml0eS9wZXJtdXRhdGlvbi1zaWduLmpzIiwibm9kZV9tb2R1bGVzL3Blcm11dGF0aW9uLXJhbmsvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcGxhbmFyLWR1YWwvbG9vcHMuanMiLCJub2RlX21vZHVsZXMvcGxhbmFyLWdyYXBoLXRvLXBvbHlsaW5lL2xpYi90cmltLWxlYXZlcy5qcyIsIm5vZGVfbW9kdWxlcy9wbGFuYXItZ3JhcGgtdG8tcG9seWxpbmUvcGcycGwuanMiLCJub2RlX21vZHVsZXMvcG9pbnQtaW4tYmlnLXBvbHlnb24vcG5wLWJpZy5qcyIsIm5vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvcmFmLWxvb3AvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcmFmL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3JhdC12ZWMvYWRkLmpzIiwibm9kZV9tb2R1bGVzL3JhdC12ZWMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcmF0LXZlYy9tdWxzLmpzIiwibm9kZV9tb2R1bGVzL3JhdC12ZWMvc3ViLmpzIiwibm9kZV9tb2R1bGVzL3JlZ2wvZGlzdC9yZWdsLmpzIiwibm9kZV9tb2R1bGVzL3JpZ2h0LW5vdy9icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3JvYnVzdC1pbi1zcGhlcmUvaW4tc3BoZXJlLmpzIiwibm9kZV9tb2R1bGVzL3JvYnVzdC1vcmllbnRhdGlvbi9vcmllbnRhdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9yb2J1c3QtcHJvZHVjdC9wcm9kdWN0LmpzIiwibm9kZV9tb2R1bGVzL3JvYnVzdC1zY2FsZS9yb2J1c3Qtc2NhbGUuanMiLCJub2RlX21vZHVsZXMvcm9idXN0LXNlZ21lbnQtaW50ZXJzZWN0L3NlZ3NlZy5qcyIsIm5vZGVfbW9kdWxlcy9yb2J1c3Qtc3VidHJhY3Qvcm9idXN0LWRpZmYuanMiLCJub2RlX21vZHVsZXMvcm9idXN0LXN1bS9yb2J1c3Qtc3VtLmpzIiwibm9kZV9tb2R1bGVzL3NpZ251bS9zZ24uanMiLCJub2RlX21vZHVsZXMvc2ltcGxpY2lhbC1jb21wbGV4L25vZGVfbW9kdWxlcy91bmlvbi1maW5kL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3NpbXBsaWNpYWwtY29tcGxleC90b3BvbG9neS5qcyIsIm5vZGVfbW9kdWxlcy9zaW1wbGlmeS1wbGFuYXItZ3JhcGgvc2ltcGxpZnkuanMiLCJub2RlX21vZHVsZXMvc2xhYi1kZWNvbXBvc2l0aW9uL2xpYi9vcmRlci1zZWdtZW50cy5qcyIsIm5vZGVfbW9kdWxlcy9zbGFiLWRlY29tcG9zaXRpb24vc2xhYnMuanMiLCJub2RlX21vZHVsZXMvc3VyZmFjZS1uZXRzL3N1cmZhY2VuZXRzLmpzIiwibm9kZV9tb2R1bGVzL3RocmVlL3NyYy9jb25zdGFudHMuanMiLCJub2RlX21vZHVsZXMvdGhyZWUvc3JjL2NvcmUvQnVmZmVyQXR0cmlidXRlLmpzIiwibm9kZV9tb2R1bGVzL3RocmVlL3NyYy9jb3JlL0J1ZmZlckdlb21ldHJ5LmpzIiwibm9kZV9tb2R1bGVzL3RocmVlL3NyYy9jb3JlL0V2ZW50RGlzcGF0Y2hlci5qcyIsIm5vZGVfbW9kdWxlcy90aHJlZS9zcmMvY29yZS9MYXllcnMuanMiLCJub2RlX21vZHVsZXMvdGhyZWUvc3JjL2NvcmUvT2JqZWN0M0QuanMiLCJub2RlX21vZHVsZXMvdGhyZWUvc3JjL2V4dHJhcy9EYXRhVXRpbHMuanMiLCJub2RlX21vZHVsZXMvdGhyZWUvc3JjL2V4dHJhcy9FYXJjdXQuanMiLCJub2RlX21vZHVsZXMvdGhyZWUvc3JjL2V4dHJhcy9TaGFwZVV0aWxzLmpzIiwibm9kZV9tb2R1bGVzL3RocmVlL3NyYy9leHRyYXMvY29yZS9DdXJ2ZS5qcyIsIm5vZGVfbW9kdWxlcy90aHJlZS9zcmMvZXh0cmFzL2NvcmUvQ3VydmVQYXRoLmpzIiwibm9kZV9tb2R1bGVzL3RocmVlL3NyYy9leHRyYXMvY29yZS9JbnRlcnBvbGF0aW9ucy5qcyIsIm5vZGVfbW9kdWxlcy90aHJlZS9zcmMvZXh0cmFzL2NvcmUvUGF0aC5qcyIsIm5vZGVfbW9kdWxlcy90aHJlZS9zcmMvZXh0cmFzL2NvcmUvU2hhcGUuanMiLCJub2RlX21vZHVsZXMvdGhyZWUvc3JjL2V4dHJhcy9jdXJ2ZXMvQXJjQ3VydmUuanMiLCJub2RlX21vZHVsZXMvdGhyZWUvc3JjL2V4dHJhcy9jdXJ2ZXMvQ2F0bXVsbFJvbUN1cnZlMy5qcyIsIm5vZGVfbW9kdWxlcy90aHJlZS9zcmMvZXh0cmFzL2N1cnZlcy9DdWJpY0JlemllckN1cnZlLmpzIiwibm9kZV9tb2R1bGVzL3RocmVlL3NyYy9leHRyYXMvY3VydmVzL0N1YmljQmV6aWVyQ3VydmUzLmpzIiwibm9kZV9tb2R1bGVzL3RocmVlL3NyYy9leHRyYXMvY3VydmVzL0N1cnZlcy5qcyIsIm5vZGVfbW9kdWxlcy90aHJlZS9zcmMvZXh0cmFzL2N1cnZlcy9FbGxpcHNlQ3VydmUuanMiLCJub2RlX21vZHVsZXMvdGhyZWUvc3JjL2V4dHJhcy9jdXJ2ZXMvTGluZUN1cnZlLmpzIiwibm9kZV9tb2R1bGVzL3RocmVlL3NyYy9leHRyYXMvY3VydmVzL0xpbmVDdXJ2ZTMuanMiLCJub2RlX21vZHVsZXMvdGhyZWUvc3JjL2V4dHJhcy9jdXJ2ZXMvUXVhZHJhdGljQmV6aWVyQ3VydmUuanMiLCJub2RlX21vZHVsZXMvdGhyZWUvc3JjL2V4dHJhcy9jdXJ2ZXMvUXVhZHJhdGljQmV6aWVyQ3VydmUzLmpzIiwibm9kZV9tb2R1bGVzL3RocmVlL3NyYy9leHRyYXMvY3VydmVzL1NwbGluZUN1cnZlLmpzIiwibm9kZV9tb2R1bGVzL3RocmVlL3NyYy9nZW9tZXRyaWVzL0JveEdlb21ldHJ5LmpzIiwibm9kZV9tb2R1bGVzL3RocmVlL3NyYy9nZW9tZXRyaWVzL0NhcHN1bGVHZW9tZXRyeS5qcyIsIm5vZGVfbW9kdWxlcy90aHJlZS9zcmMvZ2VvbWV0cmllcy9DaXJjbGVHZW9tZXRyeS5qcyIsIm5vZGVfbW9kdWxlcy90aHJlZS9zcmMvZ2VvbWV0cmllcy9Db25lR2VvbWV0cnkuanMiLCJub2RlX21vZHVsZXMvdGhyZWUvc3JjL2dlb21ldHJpZXMvQ3lsaW5kZXJHZW9tZXRyeS5qcyIsIm5vZGVfbW9kdWxlcy90aHJlZS9zcmMvZ2VvbWV0cmllcy9Eb2RlY2FoZWRyb25HZW9tZXRyeS5qcyIsIm5vZGVfbW9kdWxlcy90aHJlZS9zcmMvZ2VvbWV0cmllcy9FZGdlc0dlb21ldHJ5LmpzIiwibm9kZV9tb2R1bGVzL3RocmVlL3NyYy9nZW9tZXRyaWVzL0V4dHJ1ZGVHZW9tZXRyeS5qcyIsIm5vZGVfbW9kdWxlcy90aHJlZS9zcmMvZ2VvbWV0cmllcy9HZW9tZXRyaWVzLmpzIiwibm9kZV9tb2R1bGVzL3RocmVlL3NyYy9nZW9tZXRyaWVzL0ljb3NhaGVkcm9uR2VvbWV0cnkuanMiLCJub2RlX21vZHVsZXMvdGhyZWUvc3JjL2dlb21ldHJpZXMvTGF0aGVHZW9tZXRyeS5qcyIsIm5vZGVfbW9kdWxlcy90aHJlZS9zcmMvZ2VvbWV0cmllcy9PY3RhaGVkcm9uR2VvbWV0cnkuanMiLCJub2RlX21vZHVsZXMvdGhyZWUvc3JjL2dlb21ldHJpZXMvUGxhbmVHZW9tZXRyeS5qcyIsIm5vZGVfbW9kdWxlcy90aHJlZS9zcmMvZ2VvbWV0cmllcy9Qb2x5aGVkcm9uR2VvbWV0cnkuanMiLCJub2RlX21vZHVsZXMvdGhyZWUvc3JjL2dlb21ldHJpZXMvUmluZ0dlb21ldHJ5LmpzIiwibm9kZV9tb2R1bGVzL3RocmVlL3NyYy9nZW9tZXRyaWVzL1NoYXBlR2VvbWV0cnkuanMiLCJub2RlX21vZHVsZXMvdGhyZWUvc3JjL2dlb21ldHJpZXMvU3BoZXJlR2VvbWV0cnkuanMiLCJub2RlX21vZHVsZXMvdGhyZWUvc3JjL2dlb21ldHJpZXMvVGV0cmFoZWRyb25HZW9tZXRyeS5qcyIsIm5vZGVfbW9kdWxlcy90aHJlZS9zcmMvZ2VvbWV0cmllcy9Ub3J1c0dlb21ldHJ5LmpzIiwibm9kZV9tb2R1bGVzL3RocmVlL3NyYy9nZW9tZXRyaWVzL1RvcnVzS25vdEdlb21ldHJ5LmpzIiwibm9kZV9tb2R1bGVzL3RocmVlL3NyYy9nZW9tZXRyaWVzL1R1YmVHZW9tZXRyeS5qcyIsIm5vZGVfbW9kdWxlcy90aHJlZS9zcmMvZ2VvbWV0cmllcy9XaXJlZnJhbWVHZW9tZXRyeS5qcyIsIm5vZGVfbW9kdWxlcy90aHJlZS9zcmMvbWF0aC9Cb3gzLmpzIiwibm9kZV9tb2R1bGVzL3RocmVlL3NyYy9tYXRoL0V1bGVyLmpzIiwibm9kZV9tb2R1bGVzL3RocmVlL3NyYy9tYXRoL01hdGhVdGlscy5qcyIsIm5vZGVfbW9kdWxlcy90aHJlZS9zcmMvbWF0aC9NYXRyaXgzLmpzIiwibm9kZV9tb2R1bGVzL3RocmVlL3NyYy9tYXRoL01hdHJpeDQuanMiLCJub2RlX21vZHVsZXMvdGhyZWUvc3JjL21hdGgvUXVhdGVybmlvbi5qcyIsIm5vZGVfbW9kdWxlcy90aHJlZS9zcmMvbWF0aC9TcGhlcmUuanMiLCJub2RlX21vZHVsZXMvdGhyZWUvc3JjL21hdGgvVHJpYW5nbGUuanMiLCJub2RlX21vZHVsZXMvdGhyZWUvc3JjL21hdGgvVmVjdG9yMi5qcyIsIm5vZGVfbW9kdWxlcy90aHJlZS9zcmMvbWF0aC9WZWN0b3IzLmpzIiwibm9kZV9tb2R1bGVzL3RocmVlL3NyYy91dGlscy5qcyIsIm5vZGVfbW9kdWxlcy90cmlhbmd1bGF0ZS1oeXBlcmN1YmUvdHJpYW5ndWxhdGUtY3ViZS5qcyIsIm5vZGVfbW9kdWxlcy90d28tcHJvZHVjdC90d28tcHJvZHVjdC5qcyIsIm5vZGVfbW9kdWxlcy90d28tc3VtL3R3by1zdW0uanMiLCJub2RlX21vZHVsZXMvdHlwZWRhcnJheS1wb29sL3Bvb2wuanMiLCJub2RlX21vZHVsZXMvdW5pb24tZmluZC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy91bmlxL3VuaXEuanMiLCJub2RlX21vZHVsZXMvdmVjdG9yaXplLXRleHQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdmVjdG9yaXplLXRleHQvbGliL3Z0ZXh0LmpzIiwibm9kZV9tb2R1bGVzL3plcm8tY3Jvc3NpbmdzL2xpYi96Yy1jb3JlLmpzIiwibm9kZV9tb2R1bGVzL3plcm8tY3Jvc3NpbmdzL3pjLmpzIiwic3JjL2V2YWwtc2FuZGJveC5qcyIsInNyYy9mb3JtYXQtYXJndW1lbnRzLmpzIiwic3JjL2dlbmVyYXRlLWdsc2wuanMiLCJzcmMvZ2VuZXJhdG9yLWZhY3RvcnkuanMiLCJzcmMvZ2xzbC1zb3VyY2UuanMiLCJzcmMvZ2xzbC9nZW9tZXRyaWVzL0dyaWRHZW9tZXRyeS5qcyIsInNyYy9nbHNsL2dsc2wtZnVuY3Rpb25zLmpzIiwic3JjL2dsc2wvdXRpbGl0eS1mdW5jdGlvbnMuanMiLCJzcmMvZ2xzbC92ZXJ0LWZ1bmN0aW9ucy5qcyIsInNyYy9oeWRyYS1zb3VyY2UuanMiLCJzcmMvaHlkcmEtc3ludGguanMiLCJzcmMvaW5kZXguanMiLCJzcmMvbGliL2FycmF5LXV0aWxzLmpzIiwic3JjL2xpYi9hdWRpby5qcyIsInNyYy9saWIvZWFzaW5nLWZ1bmN0aW9ucy5qcyIsInNyYy9saWIvbW91c2UtZXZlbnQuanMiLCJzcmMvbGliL21vdXNlLmpzIiwic3JjL2xpYi9zYW5kYm94LmpzIiwic3JjL2xpYi9zY3JlZW5tZWRpYS5qcyIsInNyYy9saWIvdmlkZW8tcmVjb3JkZXIuanMiLCJzcmMvbGliL3dlYmNhbS5qcyIsInNyYy9vdXRwdXQuanMiLCJzcmMvdHlwZXMuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3QzR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9JQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdlQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqYkE7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNqZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2p2REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcExBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0V0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN0RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3BHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbitCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25FQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3V0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOVpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDekNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3REQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM01BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMzRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUM3K1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5UUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFBO0lBQUE7SUFBQTtNQUFBO0lBQUE7RUFBQTtBQUFBOztBQUNBOztBQUFBO0VBQUE7RUFBQTtFQUFBO0lBQUE7SUFBQTtNQUFBO0lBQUE7RUFBQTtBQUFBOztBQUNBOztBQUFBO0VBQUE7RUFBQTtFQUFBO0lBQUE7SUFBQTtNQUFBO0lBQUE7RUFBQTtBQUFBOztBQUNBOztBQUFBO0VBQUE7RUFBQTtFQUFBO0lBQUE7SUFBQTtNQUFBO0lBQUE7RUFBQTtBQUFBOztBQUNBOztBQUFBO0VBQUE7RUFBQTtFQUFBO0lBQUE7SUFBQTtNQUFBO0lBQUE7RUFBQTtBQUFBOztBQUNBOztBQUFBO0VBQUE7RUFBQTtFQUFBO0lBQUE7SUFBQTtNQUFBO0lBQUE7RUFBQTtBQUFBOztBQUNBOztBQUFBO0VBQUE7RUFBQTtFQUFBO0lBQUE7SUFBQTtNQUFBO0lBQUE7RUFBQTtBQUFBOztBQUNBOztBQUFBO0VBQUE7RUFBQTtFQUFBO0lBQUE7SUFBQTtNQUFBO0lBQUE7RUFBQTtBQUFBOztBQUNBOztBQUFBO0VBQUE7RUFBQTtFQUFBO0lBQUE7SUFBQTtNQUFBO0lBQUE7RUFBQTtBQUFBOztBQUNBOztBQUFBO0VBQUE7RUFBQTtFQUFBO0lBQUE7SUFBQTtNQUFBO0lBQUE7RUFBQTtBQUFBOztBQUNBOztBQUFBO0VBQUE7RUFBQTtFQUFBO0lBQUE7SUFBQTtNQUFBO0lBQUE7RUFBQTtBQUFBOztBQUNBOztBQUFBO0VBQUE7RUFBQTtFQUFBO0lBQUE7SUFBQTtNQUFBO0lBQUE7RUFBQTtBQUFBOztBQUNBOztBQUFBO0VBQUE7RUFBQTtFQUFBO0lBQUE7SUFBQTtNQUFBO0lBQUE7RUFBQTtBQUFBOztBQUNBOztBQUFBO0VBQUE7RUFBQTtFQUFBO0lBQUE7SUFBQTtNQUFBO0lBQUE7RUFBQTtBQUFBOztBQUNBOztBQUFBO0VBQUE7RUFBQTtFQUFBO0lBQUE7SUFBQTtNQUFBO0lBQUE7RUFBQTtBQUFBOztBQUNBOztBQUFBO0VBQUE7RUFBQTtFQUFBO0lBQUE7SUFBQTtNQUFBO0lBQUE7RUFBQTtBQUFBOzs7Ozs7Ozs7O0FD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bEQsRUFBd0QsSUFBeEQsRUFBOEQsSUFBOUQsRUFBb0UsSUFBcEUsRUFBMEUsSUFBMUUsRUFBZ0YsSUFBaEYsRUFBc0YsSUFBdEYsRUFBNEYsSUFBNUYsRUFBa0csSUFBbEcsRUFBd0csSUFBeEcsRUFBOEcsSUFBOUcsRUFBb0gsSUFBcEgsRUFBMEgsSUFBMUgsRUFBZ0ksSUFBaEksRUFBc0ksSUFBdEksRUFBNEksSUFBNUksRUFBa0osSUFBbEosRUFBd0osSUFBeEosRUFBOEosSUFBOUosRUFBb0ssSUFBcEssRUFBMEssSUFBMUssRUFBZ0wsSUFBaEwsRUFBc0wsSUFBdEwsRUFBNEwsSUFBNUwsRUFBa00sSUFBbE0sRUFBd00sSUFBeE0sRUFBOE0sSUFBOU0sRUFBb04sSUFBcE4sRUFBME4sSUFBMU4sRUFBZ08sSUFBaE8sRUFBc08sSUFBdE8sRUFBNE8sSUFBNU8sRUFBa1AsSUFBbFAsRUFBd1AsSUFBeFAsRUFBOFAsSUFBOVAsRUFBb1EsSUFBcFEsRUFBMFEsSUFBMVEsRUFBZ1IsSUFBaFIsRUFBc1IsSUFBdFIsRUFBNFIsSUFBNVIsRUFBa1MsSUFBbFMsRUFBd1MsSUFBeFMsRUFBOFMsSUFBOVMsRUFBb1QsSUFBcFQsRUFBMFQsSUFBMVQsRUFBZ1UsSUFBaFUsRUFBc1UsSUFBdFUsRUFBNFUsSUFBNVUsRUFBa1YsSUFBbFYsRUFBd1YsSUFBeFYsRUFBOFYsSUFBOVYsRUFBb1csSUFBcFcsRUFBMFcsSUFBMVcsRUFBZ1gsSUFBaFgsRUFBc1gsSUFBdFgsRUFBNFgsSUFBNVgsRUFBa1ksSUFBbFksRUFBd1ksSUFBeFksRUFBOFksSUFBOVksRUFBb1osSUFBcFosRUFBMFosSUFBMVosRUFBZ2EsSUFBaGEsRUFBc2EsSUFBdGEsRUFBNGEsSUFBNWEsRUFBa2IsSUFBbGIsRUFBd2IsSUFBeGIsRUFBOGIsSUFBOWIsRUFBb2MsSUFBcGMsRUFBMGMsSUFBMWMsRUFBZ2QsSUFBaGQsRUFBc2QsSUFBdGQsRUFBNGQsSUFBNWQsRUFBa2UsSUFBbGUsRUFBd2UsSUFBeGUsRUFBOGUsSUFBOWUsRUFBb2YsSUFB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QUwsR0FBVSxFQUFFLEdBQUcsRUFBTCxHQUFVLEVBQVYsR0FBZSxFQUFFLEdBQUcsRUFBTCxHQUFVLEVBQW5DO1FBQ0EsS0FBSyxFQUFMLEdBQVUsRUFBRSxHQUFHLEVBQUwsR0FBVSxFQUFWLEdBQWUsRUFBRSxHQUFHLEVBQUwsR0FBVSxFQUFuQztRQUNBLEtBQUssRUFBTCxHQUFVLEVBQUUsR0FBRyxFQUFMLEdBQVUsRUFBVixHQUFlLEVBQUUsR0FBRyxFQUFMLEdBQVUsRUFBbkM7UUFDQSxLQUFLLEVBQUwsR0FBVSxFQUFFLEdBQUcsRUFBTCxHQUFVLEVBQVYsR0FBZSxFQUFFLEdBQUcsRUFBTCxHQUFVLEVBQW5DO1FBQ0E7O01BRUQsS0FBSyxLQUFMO1FBQ0MsS0FBSyxFQUFMLEdBQVUsRUFBRSxHQUFHLEVBQUwsR0FBVSxFQUFWLEdBQWUsRUFBRSxHQUFHLEVBQUwsR0FBVSxFQUFuQztRQUNBLEtBQUssRUFBTCxHQUFVLEVBQUUsR0FBRyxFQUFMLEdBQVUsRUFBVixHQUFlLEVBQUUsR0FBRyxFQUFMLEdBQVUsRUFBbkM7UUFDQSxLQUFLLEVBQUwsR0FBVSxFQUFFLEdBQUcsRUFBTCxHQUFVLEVBQVYsR0FBZSxFQUFFLEdBQUcsRUFBTCxHQUFVLEVBQW5DO1FBQ0EsS0FBSyxFQUFMLEdBQVUsRUFBRSxHQUFHLEVBQUwsR0FBVSxFQUFWLEdBQWUsRUFBRSxHQUFHLEVBQUwsR0FBVSxFQUFuQztRQUNBOztNQUVELEtBQUssS0FBTDtRQUNDLEtBQUssRUFBTCxHQUFVLEVBQUUsR0FBRyxFQUFMLEdBQVUsRUFBVixHQUFlLEVBQUUsR0FBRyxFQUFMLEdBQVUsRUFBbkM7UUFDQSxLQUFLLEVBQUwsR0FBVSxFQUFFLEdBQUcsRUFBTCxHQUFVLEVBQVYsR0FBZSxFQUFFLEdBQUcsRUFBTCxHQUFVLEVBQW5DO1FBQ0EsS0FBSyxFQUFMLEdBQVUsRUFBRSxHQUFHLEVBQUwsR0FBVSxFQUFWLEdBQWUsRUFBRSxHQUFHLEVBQUwsR0FBVSxFQUFuQztRQUNBLEtBQUssRUFBTCxHQUFVLEVBQUUsR0FBRyxFQUFM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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDM1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyY0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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OztBQUVBLE1BQU0sYUFBYSxHQUFHO0VBQ2xCLENBQUMsRUFBRSxPQURlO0VBQ04sQ0FBQyxFQUFFLE9BREc7RUFDTSxDQUFDLEVBQUUsT0FEVDtFQUVsQixFQUFFLEVBQUUsTUFGYztFQUVOLEVBQUUsRUFBRSxNQUZFO0VBR2xCLEdBQUcsRUFBRSxNQUhhO0VBR0wsR0FBRyxFQUFFLE1BSEE7RUFHUSxHQUFHLEVBQUUsTUFIYjtFQUdxQixHQUFHLEVBQUUsTUFIMUI7RUFHa0MsR0FBRyxFQUFFLE1BSHZDO0VBRytDLEdBQUcsRUFBRSxNQUhwRDtFQUlsQixJQUFJLEVBQUU7QUFKWSxDQUF0Qjs7O0FBT0EsTUFBTSxRQUFRLEdBQUcsQ0FBQyxJQUFELEVBQU8sUUFBUCxFQUFpQixNQUFqQixFQUF5QixLQUFLLEdBQUcsR0FBakMsS0FBeUM7RUFDdEQsTUFBTSxPQUFPLEdBQUcsUUFBUSxLQUFLLE9BQWIsR0FBdUIsQ0FBdkIsR0FBMkIsUUFBUSxDQUFDLFNBQVQsQ0FBbUIsQ0FBbkIsQ0FBM0M7RUFDQSxNQUFNLEtBQUssR0FBSSxNQUFNLEtBQUssT0FBWCxHQUFxQixDQUFyQixHQUF5QixNQUFNLENBQUMsU0FBUCxDQUFpQixDQUFqQixDQUF4Qzs7RUFDQSxJQUFJLE9BQU8sR0FBRyxLQUFkLEVBQXFCO0lBQ2pCLElBQUksSUFBSSxHQUFHLEtBQUssR0FBRyxPQUFuQjtJQUNBLElBQUksSUFBSSxHQUFHLEVBQVg7O0lBQ0EsSUFBSSxNQUFNLEtBQUssTUFBZixFQUF1QjtNQUNuQixJQUFJLElBQUksQ0FBUjtNQUNBLElBQUksR0FBRyxPQUFLLEtBQVo7SUFDSDs7SUFDRCxJQUFJLEdBQUksTUFBSyxLQUFNLElBQUcsSUFBSyxHQUFFLFFBQVEsTUFBUixDQUFlLElBQWYsQ0FBcUIsR0FBRSxJQUFLLEdBQXpEO0VBQ0g7O0VBQ0QsT0FBTyxJQUFQO0FBQ0gsQ0FiRCIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKCl7ZnVuY3Rpb24gcihlLG4sdCl7ZnVuY3Rpb24gbyhpLGYpe2lmKCFuW2ldKXtpZighZVtpXSl7dmFyIGM9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZTtpZighZiYmYylyZXR1cm4gYyhpLCEwKTtpZih1KXJldHVybiB1KGksITApO3ZhciBhPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIraStcIidcIik7dGhyb3cgYS5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGF9dmFyIHA9bltpXT17ZXhwb3J0czp7fX07ZVtpXVswXS5jYWxsKHAuZXhwb3J0cyxmdW5jdGlvbihyKXt2YXIgbj1lW2ldWzFdW3JdO3JldHVybiBvKG58fHIpfSxwLHAuZXhwb3J0cyxyLGUsbix0KX1yZXR1cm4gbltpXS5leHBvcnRzfWZvcih2YXIgdT1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlLGk9MDtpPHQubGVuZ3RoO2krKylvKHRbaV0pO3JldHVybiBvfXJldHVybiByfSkoKSIsIid1c2Ugc3RyaWN0J1xuXG5leHBvcnRzLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXG5leHBvcnRzLnRvQnl0ZUFycmF5ID0gdG9CeXRlQXJyYXlcbmV4cG9ydHMuZnJvbUJ5dGVBcnJheSA9IGZyb21CeXRlQXJyYXlcblxudmFyIGxvb2t1cCA9IFtdXG52YXIgcmV2TG9va3VwID0gW11cbnZhciBBcnIgPSB0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcgPyBVaW50OEFycmF5IDogQXJyYXlcblxudmFyIGNvZGUgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLydcbmZvciAodmFyIGkgPSAwLCBsZW4gPSBjb2RlLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gIGxvb2t1cFtpXSA9IGNvZGVbaV1cbiAgcmV2TG9va3VwW2NvZGUuY2hhckNvZGVBdChpKV0gPSBpXG59XG5cbi8vIFN1cHBvcnQgZGVjb2RpbmcgVVJMLXNhZmUgYmFzZTY0IHN0cmluZ3MsIGFzIE5vZGUuanMgZG9lcy5cbi8vIFNlZTogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQmFzZTY0I1VSTF9hcHBsaWNhdGlvbnNcbnJldkxvb2t1cFsnLScuY2hhckNvZGVBdCgwKV0gPSA2MlxucmV2TG9va3VwWydfJy5jaGFyQ29kZUF0KDApXSA9IDYzXG5cbmZ1bmN0aW9uIGdldExlbnMgKGI2NCkge1xuICB2YXIgbGVuID0gYjY0Lmxlbmd0aFxuXG4gIGlmIChsZW4gJSA0ID4gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdHJpbmcuIExlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNCcpXG4gIH1cblxuICAvLyBUcmltIG9mZiBleHRyYSBieXRlcyBhZnRlciBwbGFjZWhvbGRlciBieXRlcyBhcmUgZm91bmRcbiAgLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vYmVhdGdhbW1pdC9iYXNlNjQtanMvaXNzdWVzLzQyXG4gIHZhciB2YWxpZExlbiA9IGI2NC5pbmRleE9mKCc9JylcbiAgaWYgKHZhbGlkTGVuID09PSAtMSkgdmFsaWRMZW4gPSBsZW5cblxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gdmFsaWRMZW4gPT09IGxlblxuICAgID8gMFxuICAgIDogNCAtICh2YWxpZExlbiAlIDQpXG5cbiAgcmV0dXJuIFt2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuXVxufVxuXG4vLyBiYXNlNjQgaXMgNC8zICsgdXAgdG8gdHdvIGNoYXJhY3RlcnMgb2YgdGhlIG9yaWdpbmFsIGRhdGFcbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKGI2NCkge1xuICB2YXIgbGVucyA9IGdldExlbnMoYjY0KVxuICB2YXIgdmFsaWRMZW4gPSBsZW5zWzBdXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSBsZW5zWzFdXG4gIHJldHVybiAoKHZhbGlkTGVuICsgcGxhY2VIb2xkZXJzTGVuKSAqIDMgLyA0KSAtIHBsYWNlSG9sZGVyc0xlblxufVxuXG5mdW5jdGlvbiBfYnl0ZUxlbmd0aCAoYjY0LCB2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuKSB7XG4gIHJldHVybiAoKHZhbGlkTGVuICsgcGxhY2VIb2xkZXJzTGVuKSAqIDMgLyA0KSAtIHBsYWNlSG9sZGVyc0xlblxufVxuXG5mdW5jdGlvbiB0b0J5dGVBcnJheSAoYjY0KSB7XG4gIHZhciB0bXBcbiAgdmFyIGxlbnMgPSBnZXRMZW5zKGI2NClcbiAgdmFyIHZhbGlkTGVuID0gbGVuc1swXVxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gbGVuc1sxXVxuXG4gIHZhciBhcnIgPSBuZXcgQXJyKF9ieXRlTGVuZ3RoKGI2NCwgdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbikpXG5cbiAgdmFyIGN1ckJ5dGUgPSAwXG5cbiAgLy8gaWYgdGhlcmUgYXJlIHBsYWNlaG9sZGVycywgb25seSBnZXQgdXAgdG8gdGhlIGxhc3QgY29tcGxldGUgNCBjaGFyc1xuICB2YXIgbGVuID0gcGxhY2VIb2xkZXJzTGVuID4gMFxuICAgID8gdmFsaWRMZW4gLSA0XG4gICAgOiB2YWxpZExlblxuXG4gIHZhciBpXG4gIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxOCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDEyKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPDwgNikgfFxuICAgICAgcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAzKV1cbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gMTYpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIGlmIChwbGFjZUhvbGRlcnNMZW4gPT09IDIpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMikgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldID4+IDQpXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICBpZiAocGxhY2VIb2xkZXJzTGVuID09PSAxKSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDEwKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgNCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildID4+IDIpXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIGFyclxufVxuXG5mdW5jdGlvbiB0cmlwbGV0VG9CYXNlNjQgKG51bSkge1xuICByZXR1cm4gbG9va3VwW251bSA+PiAxOCAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtID4+IDEyICYgMHgzRl0gK1xuICAgIGxvb2t1cFtudW0gPj4gNiAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtICYgMHgzRl1cbn1cblxuZnVuY3Rpb24gZW5jb2RlQ2h1bmsgKHVpbnQ4LCBzdGFydCwgZW5kKSB7XG4gIHZhciB0bXBcbiAgdmFyIG91dHB1dCA9IFtdXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSArPSAzKSB7XG4gICAgdG1wID1cbiAgICAgICgodWludDhbaV0gPDwgMTYpICYgMHhGRjAwMDApICtcbiAgICAgICgodWludDhbaSArIDFdIDw8IDgpICYgMHhGRjAwKSArXG4gICAgICAodWludDhbaSArIDJdICYgMHhGRilcbiAgICBvdXRwdXQucHVzaCh0cmlwbGV0VG9CYXNlNjQodG1wKSlcbiAgfVxuICByZXR1cm4gb3V0cHV0LmpvaW4oJycpXG59XG5cbmZ1bmN0aW9uIGZyb21CeXRlQXJyYXkgKHVpbnQ4KSB7XG4gIHZhciB0bXBcbiAgdmFyIGxlbiA9IHVpbnQ4Lmxlbmd0aFxuICB2YXIgZXh0cmFCeXRlcyA9IGxlbiAlIDMgLy8gaWYgd2UgaGF2ZSAxIGJ5dGUgbGVmdCwgcGFkIDIgYnl0ZXNcbiAgdmFyIHBhcnRzID0gW11cbiAgdmFyIG1heENodW5rTGVuZ3RoID0gMTYzODMgLy8gbXVzdCBiZSBtdWx0aXBsZSBvZiAzXG5cbiAgLy8gZ28gdGhyb3VnaCB0aGUgYXJyYXkgZXZlcnkgdGhyZWUgYnl0ZXMsIHdlJ2xsIGRlYWwgd2l0aCB0cmFpbGluZyBzdHVmZiBsYXRlclxuICBmb3IgKHZhciBpID0gMCwgbGVuMiA9IGxlbiAtIGV4dHJhQnl0ZXM7IGkgPCBsZW4yOyBpICs9IG1heENodW5rTGVuZ3RoKSB7XG4gICAgcGFydHMucHVzaChlbmNvZGVDaHVuayh1aW50OCwgaSwgKGkgKyBtYXhDaHVua0xlbmd0aCkgPiBsZW4yID8gbGVuMiA6IChpICsgbWF4Q2h1bmtMZW5ndGgpKSlcbiAgfVxuXG4gIC8vIHBhZCB0aGUgZW5kIHdpdGggemVyb3MsIGJ1dCBtYWtlIHN1cmUgdG8gbm90IGZvcmdldCB0aGUgZXh0cmEgYnl0ZXNcbiAgaWYgKGV4dHJhQnl0ZXMgPT09IDEpIHtcbiAgICB0bXAgPSB1aW50OFtsZW4gLSAxXVxuICAgIHBhcnRzLnB1c2goXG4gICAgICBsb29rdXBbdG1wID4+IDJdICtcbiAgICAgIGxvb2t1cFsodG1wIDw8IDQpICYgMHgzRl0gK1xuICAgICAgJz09J1xuICAgIClcbiAgfSBlbHNlIGlmIChleHRyYUJ5dGVzID09PSAyKSB7XG4gICAgdG1wID0gKHVpbnQ4W2xlbiAtIDJdIDw8IDgpICsgdWludDhbbGVuIC0gMV1cbiAgICBwYXJ0cy5wdXNoKFxuICAgICAgbG9va3VwW3RtcCA+PiAxMF0gK1xuICAgICAgbG9va3VwWyh0bXAgPj4gNCkgJiAweDNGXSArXG4gICAgICBsb29rdXBbKHRtcCA8PCAyKSAmIDB4M0ZdICtcbiAgICAgICc9J1xuICAgIClcbiAgfVxuXG4gIHJldHVybiBwYXJ0cy5qb2luKCcnKVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbnZhciByYXRpb25hbGl6ZSA9IHJlcXVpcmUoJy4vbGliL3JhdGlvbmFsaXplJylcblxubW9kdWxlLmV4cG9ydHMgPSBhZGRcblxuZnVuY3Rpb24gYWRkKGEsIGIpIHtcbiAgcmV0dXJuIHJhdGlvbmFsaXplKFxuICAgIGFbMF0ubXVsKGJbMV0pLmFkZChiWzBdLm11bChhWzFdKSksXG4gICAgYVsxXS5tdWwoYlsxXSkpXG59XG4iLCIndXNlIHN0cmljdCdcblxubW9kdWxlLmV4cG9ydHMgPSBjbXBcblxuZnVuY3Rpb24gY21wKGEsIGIpIHtcbiAgICByZXR1cm4gYVswXS5tdWwoYlsxXSkuY21wKGJbMF0ubXVsKGFbMV0pKVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbnZhciByYXRpb25hbGl6ZSA9IHJlcXVpcmUoJy4vbGliL3JhdGlvbmFsaXplJylcblxubW9kdWxlLmV4cG9ydHMgPSBkaXZcblxuZnVuY3Rpb24gZGl2KGEsIGIpIHtcbiAgcmV0dXJuIHJhdGlvbmFsaXplKGFbMF0ubXVsKGJbMV0pLCBhWzFdLm11bChiWzBdKSlcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG52YXIgaXNSYXQgPSByZXF1aXJlKCcuL2lzLXJhdCcpXG52YXIgaXNCTiA9IHJlcXVpcmUoJy4vbGliL2lzLWJuJylcbnZhciBudW0yYm4gPSByZXF1aXJlKCcuL2xpYi9udW0tdG8tYm4nKVxudmFyIHN0cjJibiA9IHJlcXVpcmUoJy4vbGliL3N0ci10by1ibicpXG52YXIgcmF0aW9uYWxpemUgPSByZXF1aXJlKCcuL2xpYi9yYXRpb25hbGl6ZScpXG52YXIgZGl2ID0gcmVxdWlyZSgnLi9kaXYnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1ha2VSYXRpb25hbFxuXG5mdW5jdGlvbiBtYWtlUmF0aW9uYWwobnVtZXIsIGRlbm9tKSB7XG4gIGlmKGlzUmF0KG51bWVyKSkge1xuICAgIGlmKGRlbm9tKSB7XG4gICAgICByZXR1cm4gZGl2KG51bWVyLCBtYWtlUmF0aW9uYWwoZGVub20pKVxuICAgIH1cbiAgICByZXR1cm4gW251bWVyWzBdLmNsb25lKCksIG51bWVyWzFdLmNsb25lKCldXG4gIH1cbiAgdmFyIHNoaWZ0ID0gMFxuICB2YXIgYSwgYlxuICBpZihpc0JOKG51bWVyKSkge1xuICAgIGEgPSBudW1lci5jbG9uZSgpXG4gIH0gZWxzZSBpZih0eXBlb2YgbnVtZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgYSA9IHN0cjJibihudW1lcilcbiAgfSBlbHNlIGlmKG51bWVyID09PSAwKSB7XG4gICAgcmV0dXJuIFtudW0yYm4oMCksIG51bTJibigxKV1cbiAgfSBlbHNlIGlmKG51bWVyID09PSBNYXRoLmZsb29yKG51bWVyKSkge1xuICAgIGEgPSBudW0yYm4obnVtZXIpXG4gIH0gZWxzZSB7XG4gICAgd2hpbGUobnVtZXIgIT09IE1hdGguZmxvb3IobnVtZXIpKSB7XG4gICAgICBudW1lciA9IG51bWVyICogTWF0aC5wb3coMiwgMjU2KVxuICAgICAgc2hpZnQgLT0gMjU2XG4gICAgfVxuICAgIGEgPSBudW0yYm4obnVtZXIpXG4gIH1cbiAgaWYoaXNSYXQoZGVub20pKSB7XG4gICAgYS5tdWwoZGVub21bMV0pXG4gICAgYiA9IGRlbm9tWzBdLmNsb25lKClcbiAgfSBlbHNlIGlmKGlzQk4oZGVub20pKSB7XG4gICAgYiA9IGRlbm9tLmNsb25lKClcbiAgfSBlbHNlIGlmKHR5cGVvZiBkZW5vbSA9PT0gJ3N0cmluZycpIHtcbiAgICBiID0gc3RyMmJuKGRlbm9tKVxuICB9IGVsc2UgaWYoIWRlbm9tKSB7XG4gICAgYiA9IG51bTJibigxKVxuICB9IGVsc2UgaWYoZGVub20gPT09IE1hdGguZmxvb3IoZGVub20pKSB7XG4gICAgYiA9IG51bTJibihkZW5vbSlcbiAgfSBlbHNlIHtcbiAgICB3aGlsZShkZW5vbSAhPT0gTWF0aC5mbG9vcihkZW5vbSkpIHtcbiAgICAgIGRlbm9tID0gZGVub20gKiBNYXRoLnBvdygyLCAyNTYpXG4gICAgICBzaGlmdCArPSAyNTZcbiAgICB9XG4gICAgYiA9IG51bTJibihkZW5vbSlcbiAgfVxuICBpZihzaGlmdCA+IDApIHtcbiAgICBhID0gYS51c2hsbihzaGlmdClcbiAgfSBlbHNlIGlmKHNoaWZ0IDwgMCkge1xuICAgIGIgPSBiLnVzaGxuKC1zaGlmdClcbiAgfVxuICByZXR1cm4gcmF0aW9uYWxpemUoYSwgYilcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG52YXIgaXNCTiA9IHJlcXVpcmUoJy4vbGliL2lzLWJuJylcblxubW9kdWxlLmV4cG9ydHMgPSBpc1JhdFxuXG5mdW5jdGlvbiBpc1JhdCh4KSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KHgpICYmIHgubGVuZ3RoID09PSAyICYmIGlzQk4oeFswXSkgJiYgaXNCTih4WzFdKVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbnZhciBCTiA9IHJlcXVpcmUoJ2JuLmpzJylcblxubW9kdWxlLmV4cG9ydHMgPSBzaWduXG5cbmZ1bmN0aW9uIHNpZ24gKHgpIHtcbiAgcmV0dXJuIHguY21wKG5ldyBCTigwKSlcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG52YXIgc2lnbiA9IHJlcXVpcmUoJy4vYm4tc2lnbicpXG5cbm1vZHVsZS5leHBvcnRzID0gYm4ybnVtXG5cbi8vVE9ETzogTWFrZSB0aGlzIGJldHRlclxuZnVuY3Rpb24gYm4ybnVtKGIpIHtcbiAgdmFyIGwgPSBiLmxlbmd0aFxuICB2YXIgd29yZHMgPSBiLndvcmRzXG4gIHZhciBvdXQgPSAwXG4gIGlmIChsID09PSAxKSB7XG4gICAgb3V0ID0gd29yZHNbMF1cbiAgfSBlbHNlIGlmIChsID09PSAyKSB7XG4gICAgb3V0ID0gd29yZHNbMF0gKyAod29yZHNbMV0gKiAweDQwMDAwMDApXG4gIH0gZWxzZSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciB3ID0gd29yZHNbaV1cbiAgICAgIG91dCArPSB3ICogTWF0aC5wb3coMHg0MDAwMDAwLCBpKVxuICAgIH1cbiAgfVxuICByZXR1cm4gc2lnbihiKSAqIG91dFxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbnZhciBkYiA9IHJlcXVpcmUoJ2RvdWJsZS1iaXRzJylcbnZhciBjdHogPSByZXF1aXJlKCdiaXQtdHdpZGRsZScpLmNvdW50VHJhaWxpbmdaZXJvc1xuXG5tb2R1bGUuZXhwb3J0cyA9IGN0ek51bWJlclxuXG4vL0NvdW50cyB0aGUgbnVtYmVyIG9mIHRyYWlsaW5nIHplcm9zXG5mdW5jdGlvbiBjdHpOdW1iZXIoeCkge1xuICB2YXIgbCA9IGN0eihkYi5sbyh4KSlcbiAgaWYobCA8IDMyKSB7XG4gICAgcmV0dXJuIGxcbiAgfVxuICB2YXIgaCA9IGN0eihkYi5oaSh4KSlcbiAgaWYoaCA+IDIwKSB7XG4gICAgcmV0dXJuIDUyXG4gIH1cbiAgcmV0dXJuIGggKyAzMlxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbnZhciBCTiA9IHJlcXVpcmUoJ2JuLmpzJylcblxubW9kdWxlLmV4cG9ydHMgPSBpc0JOXG5cbi8vVGVzdCBpZiB4IGlzIGEgYmlnbnVtYmVyXG4vL0ZJWE1FOiBvYnZpb3VzbHkgdGhpcyBpcyB0aGUgd3Jvbmcgd2F5IHRvIGRvIGl0XG5mdW5jdGlvbiBpc0JOKHgpIHtcbiAgcmV0dXJuIHggJiYgdHlwZW9mIHggPT09ICdvYmplY3QnICYmIEJvb2xlYW4oeC53b3Jkcylcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG52YXIgQk4gPSByZXF1aXJlKCdibi5qcycpXG52YXIgZGIgPSByZXF1aXJlKCdkb3VibGUtYml0cycpXG5cbm1vZHVsZS5leHBvcnRzID0gbnVtMmJuXG5cbmZ1bmN0aW9uIG51bTJibih4KSB7XG4gIHZhciBlID0gZGIuZXhwb25lbnQoeClcbiAgaWYoZSA8IDUyKSB7XG4gICAgcmV0dXJuIG5ldyBCTih4KVxuICB9IGVsc2Uge1xuICAgIHJldHVybiAobmV3IEJOKHggKiBNYXRoLnBvdygyLCA1Mi1lKSkpLnVzaGxuKGUtNTIpXG4gIH1cbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG52YXIgbnVtMmJuID0gcmVxdWlyZSgnLi9udW0tdG8tYm4nKVxudmFyIHNpZ24gPSByZXF1aXJlKCcuL2JuLXNpZ24nKVxuXG5tb2R1bGUuZXhwb3J0cyA9IHJhdGlvbmFsaXplXG5cbmZ1bmN0aW9uIHJhdGlvbmFsaXplKG51bWVyLCBkZW5vbSkge1xuICB2YXIgc251bWVyID0gc2lnbihudW1lcilcbiAgdmFyIHNkZW5vbSA9IHNpZ24oZGVub20pXG4gIGlmKHNudW1lciA9PT0gMCkge1xuICAgIHJldHVybiBbbnVtMmJuKDApLCBudW0yYm4oMSldXG4gIH1cbiAgaWYoc2Rlbm9tID09PSAwKSB7XG4gICAgcmV0dXJuIFtudW0yYm4oMCksIG51bTJibigwKV1cbiAgfVxuICBpZihzZGVub20gPCAwKSB7XG4gICAgbnVtZXIgPSBudW1lci5uZWcoKVxuICAgIGRlbm9tID0gZGVub20ubmVnKClcbiAgfVxuICB2YXIgZCA9IG51bWVyLmdjZChkZW5vbSlcbiAgaWYoZC5jbXBuKDEpKSB7XG4gICAgcmV0dXJuIFsgbnVtZXIuZGl2KGQpLCBkZW5vbS5kaXYoZCkgXVxuICB9XG4gIHJldHVybiBbIG51bWVyLCBkZW5vbSBdXG59XG4iLCIndXNlIHN0cmljdCdcblxudmFyIEJOID0gcmVxdWlyZSgnYm4uanMnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0cjJCTlxuXG5mdW5jdGlvbiBzdHIyQk4oeCkge1xuICByZXR1cm4gbmV3IEJOKHgpXG59XG4iLCIndXNlIHN0cmljdCdcblxudmFyIHJhdGlvbmFsaXplID0gcmVxdWlyZSgnLi9saWIvcmF0aW9uYWxpemUnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IG11bFxuXG5mdW5jdGlvbiBtdWwoYSwgYikge1xuICByZXR1cm4gcmF0aW9uYWxpemUoYVswXS5tdWwoYlswXSksIGFbMV0ubXVsKGJbMV0pKVxufVxuIiwiKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8vIFV0aWxzXG4gIGZ1bmN0aW9uIGFzc2VydCAodmFsLCBtc2cpIHtcbiAgICBpZiAoIXZhbCkgdGhyb3cgbmV3IEVycm9yKG1zZyB8fCAnQXNzZXJ0aW9uIGZhaWxlZCcpO1xuICB9XG5cbiAgLy8gQ291bGQgdXNlIGBpbmhlcml0c2AgbW9kdWxlLCBidXQgZG9uJ3Qgd2FudCB0byBtb3ZlIGZyb20gc2luZ2xlIGZpbGVcbiAgLy8gYXJjaGl0ZWN0dXJlIHlldC5cbiAgZnVuY3Rpb24gaW5oZXJpdHMgKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yO1xuICAgIHZhciBUZW1wQ3RvciA9IGZ1bmN0aW9uICgpIHt9O1xuICAgIFRlbXBDdG9yLnByb3RvdHlwZSA9IHN1cGVyQ3Rvci5wcm90b3R5cGU7XG4gICAgY3Rvci5wcm90b3R5cGUgPSBuZXcgVGVtcEN0b3IoKTtcbiAgICBjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGN0b3I7XG4gIH1cblxuICAvLyBCTlxuXG4gIGZ1bmN0aW9uIEJOIChudW1iZXIsIGJhc2UsIGVuZGlhbikge1xuICAgIGlmIChCTi5pc0JOKG51bWJlcikpIHtcbiAgICAgIHJldHVybiBudW1iZXI7XG4gICAgfVxuXG4gICAgdGhpcy5uZWdhdGl2ZSA9IDA7XG4gICAgdGhpcy53b3JkcyA9IG51bGw7XG4gICAgdGhpcy5sZW5ndGggPSAwO1xuXG4gICAgLy8gUmVkdWN0aW9uIGNvbnRleHRcbiAgICB0aGlzLnJlZCA9IG51bGw7XG5cbiAgICBpZiAobnVtYmVyICE9PSBudWxsKSB7XG4gICAgICBpZiAoYmFzZSA9PT0gJ2xlJyB8fCBiYXNlID09PSAnYmUnKSB7XG4gICAgICAgIGVuZGlhbiA9IGJhc2U7XG4gICAgICAgIGJhc2UgPSAxMDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5faW5pdChudW1iZXIgfHwgMCwgYmFzZSB8fCAxMCwgZW5kaWFuIHx8ICdiZScpO1xuICAgIH1cbiAgfVxuICBpZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IEJOO1xuICB9IGVsc2Uge1xuICAgIGV4cG9ydHMuQk4gPSBCTjtcbiAgfVxuXG4gIEJOLkJOID0gQk47XG4gIEJOLndvcmRTaXplID0gMjY7XG5cbiAgdmFyIEJ1ZmZlcjtcbiAgdHJ5IHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5CdWZmZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBCdWZmZXIgPSB3aW5kb3cuQnVmZmVyO1xuICAgIH0gZWxzZSB7XG4gICAgICBCdWZmZXIgPSByZXF1aXJlKCdidWZmZXInKS5CdWZmZXI7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gIH1cblxuICBCTi5pc0JOID0gZnVuY3Rpb24gaXNCTiAobnVtKSB7XG4gICAgaWYgKG51bSBpbnN0YW5jZW9mIEJOKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVtICE9PSBudWxsICYmIHR5cGVvZiBudW0gPT09ICdvYmplY3QnICYmXG4gICAgICBudW0uY29uc3RydWN0b3Iud29yZFNpemUgPT09IEJOLndvcmRTaXplICYmIEFycmF5LmlzQXJyYXkobnVtLndvcmRzKTtcbiAgfTtcblxuICBCTi5tYXggPSBmdW5jdGlvbiBtYXggKGxlZnQsIHJpZ2h0KSB7XG4gICAgaWYgKGxlZnQuY21wKHJpZ2h0KSA+IDApIHJldHVybiBsZWZ0O1xuICAgIHJldHVybiByaWdodDtcbiAgfTtcblxuICBCTi5taW4gPSBmdW5jdGlvbiBtaW4gKGxlZnQsIHJpZ2h0KSB7XG4gICAgaWYgKGxlZnQuY21wKHJpZ2h0KSA8IDApIHJldHVybiBsZWZ0O1xuICAgIHJldHVybiByaWdodDtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbiBpbml0IChudW1iZXIsIGJhc2UsIGVuZGlhbikge1xuICAgIGlmICh0eXBlb2YgbnVtYmVyID09PSAnbnVtYmVyJykge1xuICAgICAgcmV0dXJuIHRoaXMuX2luaXROdW1iZXIobnVtYmVyLCBiYXNlLCBlbmRpYW4pO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgbnVtYmVyID09PSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuIHRoaXMuX2luaXRBcnJheShudW1iZXIsIGJhc2UsIGVuZGlhbik7XG4gICAgfVxuXG4gICAgaWYgKGJhc2UgPT09ICdoZXgnKSB7XG4gICAgICBiYXNlID0gMTY7XG4gICAgfVxuICAgIGFzc2VydChiYXNlID09PSAoYmFzZSB8IDApICYmIGJhc2UgPj0gMiAmJiBiYXNlIDw9IDM2KTtcblxuICAgIG51bWJlciA9IG51bWJlci50b1N0cmluZygpLnJlcGxhY2UoL1xccysvZywgJycpO1xuICAgIHZhciBzdGFydCA9IDA7XG4gICAgaWYgKG51bWJlclswXSA9PT0gJy0nKSB7XG4gICAgICBzdGFydCsrO1xuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDE7XG4gICAgfVxuXG4gICAgaWYgKHN0YXJ0IDwgbnVtYmVyLmxlbmd0aCkge1xuICAgICAgaWYgKGJhc2UgPT09IDE2KSB7XG4gICAgICAgIHRoaXMuX3BhcnNlSGV4KG51bWJlciwgc3RhcnQsIGVuZGlhbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9wYXJzZUJhc2UobnVtYmVyLCBiYXNlLCBzdGFydCk7XG4gICAgICAgIGlmIChlbmRpYW4gPT09ICdsZScpIHtcbiAgICAgICAgICB0aGlzLl9pbml0QXJyYXkodGhpcy50b0FycmF5KCksIGJhc2UsIGVuZGlhbik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLl9pbml0TnVtYmVyID0gZnVuY3Rpb24gX2luaXROdW1iZXIgKG51bWJlciwgYmFzZSwgZW5kaWFuKSB7XG4gICAgaWYgKG51bWJlciA8IDApIHtcbiAgICAgIHRoaXMubmVnYXRpdmUgPSAxO1xuICAgICAgbnVtYmVyID0gLW51bWJlcjtcbiAgICB9XG4gICAgaWYgKG51bWJlciA8IDB4NDAwMDAwMCkge1xuICAgICAgdGhpcy53b3JkcyA9IFsgbnVtYmVyICYgMHgzZmZmZmZmIF07XG4gICAgICB0aGlzLmxlbmd0aCA9IDE7XG4gICAgfSBlbHNlIGlmIChudW1iZXIgPCAweDEwMDAwMDAwMDAwMDAwKSB7XG4gICAgICB0aGlzLndvcmRzID0gW1xuICAgICAgICBudW1iZXIgJiAweDNmZmZmZmYsXG4gICAgICAgIChudW1iZXIgLyAweDQwMDAwMDApICYgMHgzZmZmZmZmXG4gICAgICBdO1xuICAgICAgdGhpcy5sZW5ndGggPSAyO1xuICAgIH0gZWxzZSB7XG4gICAgICBhc3NlcnQobnVtYmVyIDwgMHgyMDAwMDAwMDAwMDAwMCk7IC8vIDIgXiA1MyAodW5zYWZlKVxuICAgICAgdGhpcy53b3JkcyA9IFtcbiAgICAgICAgbnVtYmVyICYgMHgzZmZmZmZmLFxuICAgICAgICAobnVtYmVyIC8gMHg0MDAwMDAwKSAmIDB4M2ZmZmZmZixcbiAgICAgICAgMVxuICAgICAgXTtcbiAgICAgIHRoaXMubGVuZ3RoID0gMztcbiAgICB9XG5cbiAgICBpZiAoZW5kaWFuICE9PSAnbGUnKSByZXR1cm47XG5cbiAgICAvLyBSZXZlcnNlIHRoZSBieXRlc1xuICAgIHRoaXMuX2luaXRBcnJheSh0aGlzLnRvQXJyYXkoKSwgYmFzZSwgZW5kaWFuKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuX2luaXRBcnJheSA9IGZ1bmN0aW9uIF9pbml0QXJyYXkgKG51bWJlciwgYmFzZSwgZW5kaWFuKSB7XG4gICAgLy8gUGVyaGFwcyBhIFVpbnQ4QXJyYXlcbiAgICBhc3NlcnQodHlwZW9mIG51bWJlci5sZW5ndGggPT09ICdudW1iZXInKTtcbiAgICBpZiAobnVtYmVyLmxlbmd0aCA8PSAwKSB7XG4gICAgICB0aGlzLndvcmRzID0gWyAwIF07XG4gICAgICB0aGlzLmxlbmd0aCA9IDE7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB0aGlzLmxlbmd0aCA9IE1hdGguY2VpbChudW1iZXIubGVuZ3RoIC8gMyk7XG4gICAgdGhpcy53b3JkcyA9IG5ldyBBcnJheSh0aGlzLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLndvcmRzW2ldID0gMDtcbiAgICB9XG5cbiAgICB2YXIgaiwgdztcbiAgICB2YXIgb2ZmID0gMDtcbiAgICBpZiAoZW5kaWFuID09PSAnYmUnKSB7XG4gICAgICBmb3IgKGkgPSBudW1iZXIubGVuZ3RoIC0gMSwgaiA9IDA7IGkgPj0gMDsgaSAtPSAzKSB7XG4gICAgICAgIHcgPSBudW1iZXJbaV0gfCAobnVtYmVyW2kgLSAxXSA8PCA4KSB8IChudW1iZXJbaSAtIDJdIDw8IDE2KTtcbiAgICAgICAgdGhpcy53b3Jkc1tqXSB8PSAodyA8PCBvZmYpICYgMHgzZmZmZmZmO1xuICAgICAgICB0aGlzLndvcmRzW2ogKyAxXSA9ICh3ID4+PiAoMjYgLSBvZmYpKSAmIDB4M2ZmZmZmZjtcbiAgICAgICAgb2ZmICs9IDI0O1xuICAgICAgICBpZiAob2ZmID49IDI2KSB7XG4gICAgICAgICAgb2ZmIC09IDI2O1xuICAgICAgICAgIGorKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZW5kaWFuID09PSAnbGUnKSB7XG4gICAgICBmb3IgKGkgPSAwLCBqID0gMDsgaSA8IG51bWJlci5sZW5ndGg7IGkgKz0gMykge1xuICAgICAgICB3ID0gbnVtYmVyW2ldIHwgKG51bWJlcltpICsgMV0gPDwgOCkgfCAobnVtYmVyW2kgKyAyXSA8PCAxNik7XG4gICAgICAgIHRoaXMud29yZHNbal0gfD0gKHcgPDwgb2ZmKSAmIDB4M2ZmZmZmZjtcbiAgICAgICAgdGhpcy53b3Jkc1tqICsgMV0gPSAodyA+Pj4gKDI2IC0gb2ZmKSkgJiAweDNmZmZmZmY7XG4gICAgICAgIG9mZiArPSAyNDtcbiAgICAgICAgaWYgKG9mZiA+PSAyNikge1xuICAgICAgICAgIG9mZiAtPSAyNjtcbiAgICAgICAgICBqKys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuc3RyaXAoKTtcbiAgfTtcblxuICBmdW5jdGlvbiBwYXJzZUhleDRCaXRzIChzdHJpbmcsIGluZGV4KSB7XG4gICAgdmFyIGMgPSBzdHJpbmcuY2hhckNvZGVBdChpbmRleCk7XG4gICAgLy8gJ0EnIC0gJ0YnXG4gICAgaWYgKGMgPj0gNjUgJiYgYyA8PSA3MCkge1xuICAgICAgcmV0dXJuIGMgLSA1NTtcbiAgICAvLyAnYScgLSAnZidcbiAgICB9IGVsc2UgaWYgKGMgPj0gOTcgJiYgYyA8PSAxMDIpIHtcbiAgICAgIHJldHVybiBjIC0gODc7XG4gICAgLy8gJzAnIC0gJzknXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoYyAtIDQ4KSAmIDB4ZjtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZUhleEJ5dGUgKHN0cmluZywgbG93ZXJCb3VuZCwgaW5kZXgpIHtcbiAgICB2YXIgciA9IHBhcnNlSGV4NEJpdHMoc3RyaW5nLCBpbmRleCk7XG4gICAgaWYgKGluZGV4IC0gMSA+PSBsb3dlckJvdW5kKSB7XG4gICAgICByIHw9IHBhcnNlSGV4NEJpdHMoc3RyaW5nLCBpbmRleCAtIDEpIDw8IDQ7XG4gICAgfVxuICAgIHJldHVybiByO1xuICB9XG5cbiAgQk4ucHJvdG90eXBlLl9wYXJzZUhleCA9IGZ1bmN0aW9uIF9wYXJzZUhleCAobnVtYmVyLCBzdGFydCwgZW5kaWFuKSB7XG4gICAgLy8gQ3JlYXRlIHBvc3NpYmx5IGJpZ2dlciBhcnJheSB0byBlbnN1cmUgdGhhdCBpdCBmaXRzIHRoZSBudW1iZXJcbiAgICB0aGlzLmxlbmd0aCA9IE1hdGguY2VpbCgobnVtYmVyLmxlbmd0aCAtIHN0YXJ0KSAvIDYpO1xuICAgIHRoaXMud29yZHMgPSBuZXcgQXJyYXkodGhpcy5sZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IDA7XG4gICAgfVxuXG4gICAgLy8gMjQtYml0cyBjaHVua3NcbiAgICB2YXIgb2ZmID0gMDtcbiAgICB2YXIgaiA9IDA7XG5cbiAgICB2YXIgdztcbiAgICBpZiAoZW5kaWFuID09PSAnYmUnKSB7XG4gICAgICBmb3IgKGkgPSBudW1iZXIubGVuZ3RoIC0gMTsgaSA+PSBzdGFydDsgaSAtPSAyKSB7XG4gICAgICAgIHcgPSBwYXJzZUhleEJ5dGUobnVtYmVyLCBzdGFydCwgaSkgPDwgb2ZmO1xuICAgICAgICB0aGlzLndvcmRzW2pdIHw9IHcgJiAweDNmZmZmZmY7XG4gICAgICAgIGlmIChvZmYgPj0gMTgpIHtcbiAgICAgICAgICBvZmYgLT0gMTg7XG4gICAgICAgICAgaiArPSAxO1xuICAgICAgICAgIHRoaXMud29yZHNbal0gfD0gdyA+Pj4gMjY7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb2ZmICs9IDg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHBhcnNlTGVuZ3RoID0gbnVtYmVyLmxlbmd0aCAtIHN0YXJ0O1xuICAgICAgZm9yIChpID0gcGFyc2VMZW5ndGggJSAyID09PSAwID8gc3RhcnQgKyAxIDogc3RhcnQ7IGkgPCBudW1iZXIubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgdyA9IHBhcnNlSGV4Qnl0ZShudW1iZXIsIHN0YXJ0LCBpKSA8PCBvZmY7XG4gICAgICAgIHRoaXMud29yZHNbal0gfD0gdyAmIDB4M2ZmZmZmZjtcbiAgICAgICAgaWYgKG9mZiA+PSAxOCkge1xuICAgICAgICAgIG9mZiAtPSAxODtcbiAgICAgICAgICBqICs9IDE7XG4gICAgICAgICAgdGhpcy53b3Jkc1tqXSB8PSB3ID4+PiAyNjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvZmYgKz0gODtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuc3RyaXAoKTtcbiAgfTtcblxuICBmdW5jdGlvbiBwYXJzZUJhc2UgKHN0ciwgc3RhcnQsIGVuZCwgbXVsKSB7XG4gICAgdmFyIHIgPSAwO1xuICAgIHZhciBsZW4gPSBNYXRoLm1pbihzdHIubGVuZ3RoLCBlbmQpO1xuICAgIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB2YXIgYyA9IHN0ci5jaGFyQ29kZUF0KGkpIC0gNDg7XG5cbiAgICAgIHIgKj0gbXVsO1xuXG4gICAgICAvLyAnYSdcbiAgICAgIGlmIChjID49IDQ5KSB7XG4gICAgICAgIHIgKz0gYyAtIDQ5ICsgMHhhO1xuXG4gICAgICAvLyAnQSdcbiAgICAgIH0gZWxzZSBpZiAoYyA+PSAxNykge1xuICAgICAgICByICs9IGMgLSAxNyArIDB4YTtcblxuICAgICAgLy8gJzAnIC0gJzknXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByICs9IGM7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByO1xuICB9XG5cbiAgQk4ucHJvdG90eXBlLl9wYXJzZUJhc2UgPSBmdW5jdGlvbiBfcGFyc2VCYXNlIChudW1iZXIsIGJhc2UsIHN0YXJ0KSB7XG4gICAgLy8gSW5pdGlhbGl6ZSBhcyB6ZXJvXG4gICAgdGhpcy53b3JkcyA9IFsgMCBdO1xuICAgIHRoaXMubGVuZ3RoID0gMTtcblxuICAgIC8vIEZpbmQgbGVuZ3RoIG9mIGxpbWIgaW4gYmFzZVxuICAgIGZvciAodmFyIGxpbWJMZW4gPSAwLCBsaW1iUG93ID0gMTsgbGltYlBvdyA8PSAweDNmZmZmZmY7IGxpbWJQb3cgKj0gYmFzZSkge1xuICAgICAgbGltYkxlbisrO1xuICAgIH1cbiAgICBsaW1iTGVuLS07XG4gICAgbGltYlBvdyA9IChsaW1iUG93IC8gYmFzZSkgfCAwO1xuXG4gICAgdmFyIHRvdGFsID0gbnVtYmVyLmxlbmd0aCAtIHN0YXJ0O1xuICAgIHZhciBtb2QgPSB0b3RhbCAlIGxpbWJMZW47XG4gICAgdmFyIGVuZCA9IE1hdGgubWluKHRvdGFsLCB0b3RhbCAtIG1vZCkgKyBzdGFydDtcblxuICAgIHZhciB3b3JkID0gMDtcbiAgICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkgKz0gbGltYkxlbikge1xuICAgICAgd29yZCA9IHBhcnNlQmFzZShudW1iZXIsIGksIGkgKyBsaW1iTGVuLCBiYXNlKTtcblxuICAgICAgdGhpcy5pbXVsbihsaW1iUG93KTtcbiAgICAgIGlmICh0aGlzLndvcmRzWzBdICsgd29yZCA8IDB4NDAwMDAwMCkge1xuICAgICAgICB0aGlzLndvcmRzWzBdICs9IHdvcmQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9pYWRkbih3b3JkKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobW9kICE9PSAwKSB7XG4gICAgICB2YXIgcG93ID0gMTtcbiAgICAgIHdvcmQgPSBwYXJzZUJhc2UobnVtYmVyLCBpLCBudW1iZXIubGVuZ3RoLCBiYXNlKTtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IG1vZDsgaSsrKSB7XG4gICAgICAgIHBvdyAqPSBiYXNlO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmltdWxuKHBvdyk7XG4gICAgICBpZiAodGhpcy53b3Jkc1swXSArIHdvcmQgPCAweDQwMDAwMDApIHtcbiAgICAgICAgdGhpcy53b3Jkc1swXSArPSB3b3JkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5faWFkZG4od29yZCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5zdHJpcCgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gY29weSAoZGVzdCkge1xuICAgIGRlc3Qud29yZHMgPSBuZXcgQXJyYXkodGhpcy5sZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgZGVzdC53b3Jkc1tpXSA9IHRoaXMud29yZHNbaV07XG4gICAgfVxuICAgIGRlc3QubGVuZ3RoID0gdGhpcy5sZW5ndGg7XG4gICAgZGVzdC5uZWdhdGl2ZSA9IHRoaXMubmVnYXRpdmU7XG4gICAgZGVzdC5yZWQgPSB0aGlzLnJlZDtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiBjbG9uZSAoKSB7XG4gICAgdmFyIHIgPSBuZXcgQk4obnVsbCk7XG4gICAgdGhpcy5jb3B5KHIpO1xuICAgIHJldHVybiByO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5fZXhwYW5kID0gZnVuY3Rpb24gX2V4cGFuZCAoc2l6ZSkge1xuICAgIHdoaWxlICh0aGlzLmxlbmd0aCA8IHNpemUpIHtcbiAgICAgIHRoaXMud29yZHNbdGhpcy5sZW5ndGgrK10gPSAwO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvLyBSZW1vdmUgbGVhZGluZyBgMGAgZnJvbSBgdGhpc2BcbiAgQk4ucHJvdG90eXBlLnN0cmlwID0gZnVuY3Rpb24gc3RyaXAgKCkge1xuICAgIHdoaWxlICh0aGlzLmxlbmd0aCA+IDEgJiYgdGhpcy53b3Jkc1t0aGlzLmxlbmd0aCAtIDFdID09PSAwKSB7XG4gICAgICB0aGlzLmxlbmd0aC0tO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fbm9ybVNpZ24oKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuX25vcm1TaWduID0gZnVuY3Rpb24gX25vcm1TaWduICgpIHtcbiAgICAvLyAtMCA9IDBcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDEgJiYgdGhpcy53b3Jkc1swXSA9PT0gMCkge1xuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDA7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gaW5zcGVjdCAoKSB7XG4gICAgcmV0dXJuICh0aGlzLnJlZCA/ICc8Qk4tUjogJyA6ICc8Qk46ICcpICsgdGhpcy50b1N0cmluZygxNikgKyAnPic7XG4gIH07XG5cbiAgLypcblxuICB2YXIgemVyb3MgPSBbXTtcbiAgdmFyIGdyb3VwU2l6ZXMgPSBbXTtcbiAgdmFyIGdyb3VwQmFzZXMgPSBbXTtcblxuICB2YXIgcyA9ICcnO1xuICB2YXIgaSA9IC0xO1xuICB3aGlsZSAoKytpIDwgQk4ud29yZFNpemUpIHtcbiAgICB6ZXJvc1tpXSA9IHM7XG4gICAgcyArPSAnMCc7XG4gIH1cbiAgZ3JvdXBTaXplc1swXSA9IDA7XG4gIGdyb3VwU2l6ZXNbMV0gPSAwO1xuICBncm91cEJhc2VzWzBdID0gMDtcbiAgZ3JvdXBCYXNlc1sxXSA9IDA7XG4gIHZhciBiYXNlID0gMiAtIDE7XG4gIHdoaWxlICgrK2Jhc2UgPCAzNiArIDEpIHtcbiAgICB2YXIgZ3JvdXBTaXplID0gMDtcbiAgICB2YXIgZ3JvdXBCYXNlID0gMTtcbiAgICB3aGlsZSAoZ3JvdXBCYXNlIDwgKDEgPDwgQk4ud29yZFNpemUpIC8gYmFzZSkge1xuICAgICAgZ3JvdXBCYXNlICo9IGJhc2U7XG4gICAgICBncm91cFNpemUgKz0gMTtcbiAgICB9XG4gICAgZ3JvdXBTaXplc1tiYXNlXSA9IGdyb3VwU2l6ZTtcbiAgICBncm91cEJhc2VzW2Jhc2VdID0gZ3JvdXBCYXNlO1xuICB9XG5cbiAgKi9cblxuICB2YXIgemVyb3MgPSBbXG4gICAgJycsXG4gICAgJzAnLFxuICAgICcwMCcsXG4gICAgJzAwMCcsXG4gICAgJzAwMDAnLFxuICAgICcwMDAwMCcsXG4gICAgJzAwMDAwMCcsXG4gICAgJzAwMDAwMDAnLFxuICAgICcwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnXG4gIF07XG5cbiAgdmFyIGdyb3VwU2l6ZXMgPSBbXG4gICAgMCwgMCxcbiAgICAyNSwgMTYsIDEyLCAxMSwgMTAsIDksIDgsXG4gICAgOCwgNywgNywgNywgNywgNiwgNixcbiAgICA2LCA2LCA2LCA2LCA2LCA1LCA1LFxuICAgIDUsIDUsIDUsIDUsIDUsIDUsIDUsXG4gICAgNSwgNSwgNSwgNSwgNSwgNSwgNVxuICBdO1xuXG4gIHZhciBncm91cEJhc2VzID0gW1xuICAgIDAsIDAsXG4gICAgMzM1NTQ0MzIsIDQzMDQ2NzIxLCAxNjc3NzIxNiwgNDg4MjgxMjUsIDYwNDY2MTc2LCA0MDM1MzYwNywgMTY3NzcyMTYsXG4gICAgNDMwNDY3MjEsIDEwMDAwMDAwLCAxOTQ4NzE3MSwgMzU4MzE4MDgsIDYyNzQ4NTE3LCA3NTI5NTM2LCAxMTM5MDYyNSxcbiAgICAxNjc3NzIxNiwgMjQxMzc1NjksIDM0MDEyMjI0LCA0NzA0NTg4MSwgNjQwMDAwMDAsIDQwODQxMDEsIDUxNTM2MzIsXG4gICAgNjQzNjM0MywgNzk2MjYyNCwgOTc2NTYyNSwgMTE4ODEzNzYsIDE0MzQ4OTA3LCAxNzIxMDM2OCwgMjA1MTExNDksXG4gICAgMjQzMDAwMDAsIDI4NjI5MTUxLCAzMzU1NDQzMiwgMzkxMzUzOTMsIDQ1NDM1NDI0LCA1MjUyMTg3NSwgNjA0NjYxNzZcbiAgXTtcblxuICBCTi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoYmFzZSwgcGFkZGluZykge1xuICAgIGJhc2UgPSBiYXNlIHx8IDEwO1xuICAgIHBhZGRpbmcgPSBwYWRkaW5nIHwgMCB8fCAxO1xuXG4gICAgdmFyIG91dDtcbiAgICBpZiAoYmFzZSA9PT0gMTYgfHwgYmFzZSA9PT0gJ2hleCcpIHtcbiAgICAgIG91dCA9ICcnO1xuICAgICAgdmFyIG9mZiA9IDA7XG4gICAgICB2YXIgY2FycnkgPSAwO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciB3ID0gdGhpcy53b3Jkc1tpXTtcbiAgICAgICAgdmFyIHdvcmQgPSAoKCh3IDw8IG9mZikgfCBjYXJyeSkgJiAweGZmZmZmZikudG9TdHJpbmcoMTYpO1xuICAgICAgICBjYXJyeSA9ICh3ID4+PiAoMjQgLSBvZmYpKSAmIDB4ZmZmZmZmO1xuICAgICAgICBpZiAoY2FycnkgIT09IDAgfHwgaSAhPT0gdGhpcy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgb3V0ID0gemVyb3NbNiAtIHdvcmQubGVuZ3RoXSArIHdvcmQgKyBvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3V0ID0gd29yZCArIG91dDtcbiAgICAgICAgfVxuICAgICAgICBvZmYgKz0gMjtcbiAgICAgICAgaWYgKG9mZiA+PSAyNikge1xuICAgICAgICAgIG9mZiAtPSAyNjtcbiAgICAgICAgICBpLS07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChjYXJyeSAhPT0gMCkge1xuICAgICAgICBvdXQgPSBjYXJyeS50b1N0cmluZygxNikgKyBvdXQ7XG4gICAgICB9XG4gICAgICB3aGlsZSAob3V0Lmxlbmd0aCAlIHBhZGRpbmcgIT09IDApIHtcbiAgICAgICAgb3V0ID0gJzAnICsgb3V0O1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDApIHtcbiAgICAgICAgb3V0ID0gJy0nICsgb3V0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG5cbiAgICBpZiAoYmFzZSA9PT0gKGJhc2UgfCAwKSAmJiBiYXNlID49IDIgJiYgYmFzZSA8PSAzNikge1xuICAgICAgLy8gdmFyIGdyb3VwU2l6ZSA9IE1hdGguZmxvb3IoQk4ud29yZFNpemUgKiBNYXRoLkxOMiAvIE1hdGgubG9nKGJhc2UpKTtcbiAgICAgIHZhciBncm91cFNpemUgPSBncm91cFNpemVzW2Jhc2VdO1xuICAgICAgLy8gdmFyIGdyb3VwQmFzZSA9IE1hdGgucG93KGJhc2UsIGdyb3VwU2l6ZSk7XG4gICAgICB2YXIgZ3JvdXBCYXNlID0gZ3JvdXBCYXNlc1tiYXNlXTtcbiAgICAgIG91dCA9ICcnO1xuICAgICAgdmFyIGMgPSB0aGlzLmNsb25lKCk7XG4gICAgICBjLm5lZ2F0aXZlID0gMDtcbiAgICAgIHdoaWxlICghYy5pc1plcm8oKSkge1xuICAgICAgICB2YXIgciA9IGMubW9kbihncm91cEJhc2UpLnRvU3RyaW5nKGJhc2UpO1xuICAgICAgICBjID0gYy5pZGl2bihncm91cEJhc2UpO1xuXG4gICAgICAgIGlmICghYy5pc1plcm8oKSkge1xuICAgICAgICAgIG91dCA9IHplcm9zW2dyb3VwU2l6ZSAtIHIubGVuZ3RoXSArIHIgKyBvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3V0ID0gciArIG91dDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHRoaXMuaXNaZXJvKCkpIHtcbiAgICAgICAgb3V0ID0gJzAnICsgb3V0O1xuICAgICAgfVxuICAgICAgd2hpbGUgKG91dC5sZW5ndGggJSBwYWRkaW5nICE9PSAwKSB7XG4gICAgICAgIG91dCA9ICcwJyArIG91dDtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICAgIG91dCA9ICctJyArIG91dDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuXG4gICAgYXNzZXJ0KGZhbHNlLCAnQmFzZSBzaG91bGQgYmUgYmV0d2VlbiAyIGFuZCAzNicpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS50b051bWJlciA9IGZ1bmN0aW9uIHRvTnVtYmVyICgpIHtcbiAgICB2YXIgcmV0ID0gdGhpcy53b3Jkc1swXTtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDIpIHtcbiAgICAgIHJldCArPSB0aGlzLndvcmRzWzFdICogMHg0MDAwMDAwO1xuICAgIH0gZWxzZSBpZiAodGhpcy5sZW5ndGggPT09IDMgJiYgdGhpcy53b3Jkc1syXSA9PT0gMHgwMSkge1xuICAgICAgLy8gTk9URTogYXQgdGhpcyBzdGFnZSBpdCBpcyBrbm93biB0aGF0IHRoZSB0b3AgYml0IGlzIHNldFxuICAgICAgcmV0ICs9IDB4MTAwMDAwMDAwMDAwMDAgKyAodGhpcy53b3Jkc1sxXSAqIDB4NDAwMDAwMCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmxlbmd0aCA+IDIpIHtcbiAgICAgIGFzc2VydChmYWxzZSwgJ051bWJlciBjYW4gb25seSBzYWZlbHkgc3RvcmUgdXAgdG8gNTMgYml0cycpO1xuICAgIH1cbiAgICByZXR1cm4gKHRoaXMubmVnYXRpdmUgIT09IDApID8gLXJldCA6IHJldDtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OICgpIHtcbiAgICByZXR1cm4gdGhpcy50b1N0cmluZygxNik7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnRvQnVmZmVyID0gZnVuY3Rpb24gdG9CdWZmZXIgKGVuZGlhbiwgbGVuZ3RoKSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBCdWZmZXIgIT09ICd1bmRlZmluZWQnKTtcbiAgICByZXR1cm4gdGhpcy50b0FycmF5TGlrZShCdWZmZXIsIGVuZGlhbiwgbGVuZ3RoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uIHRvQXJyYXkgKGVuZGlhbiwgbGVuZ3RoKSB7XG4gICAgcmV0dXJuIHRoaXMudG9BcnJheUxpa2UoQXJyYXksIGVuZGlhbiwgbGVuZ3RoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUudG9BcnJheUxpa2UgPSBmdW5jdGlvbiB0b0FycmF5TGlrZSAoQXJyYXlUeXBlLCBlbmRpYW4sIGxlbmd0aCkge1xuICAgIHZhciBieXRlTGVuZ3RoID0gdGhpcy5ieXRlTGVuZ3RoKCk7XG4gICAgdmFyIHJlcUxlbmd0aCA9IGxlbmd0aCB8fCBNYXRoLm1heCgxLCBieXRlTGVuZ3RoKTtcbiAgICBhc3NlcnQoYnl0ZUxlbmd0aCA8PSByZXFMZW5ndGgsICdieXRlIGFycmF5IGxvbmdlciB0aGFuIGRlc2lyZWQgbGVuZ3RoJyk7XG4gICAgYXNzZXJ0KHJlcUxlbmd0aCA+IDAsICdSZXF1ZXN0ZWQgYXJyYXkgbGVuZ3RoIDw9IDAnKTtcblxuICAgIHRoaXMuc3RyaXAoKTtcbiAgICB2YXIgbGl0dGxlRW5kaWFuID0gZW5kaWFuID09PSAnbGUnO1xuICAgIHZhciByZXMgPSBuZXcgQXJyYXlUeXBlKHJlcUxlbmd0aCk7XG5cbiAgICB2YXIgYiwgaTtcbiAgICB2YXIgcSA9IHRoaXMuY2xvbmUoKTtcbiAgICBpZiAoIWxpdHRsZUVuZGlhbikge1xuICAgICAgLy8gQXNzdW1lIGJpZy1lbmRpYW5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCByZXFMZW5ndGggLSBieXRlTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmVzW2ldID0gMDtcbiAgICAgIH1cblxuICAgICAgZm9yIChpID0gMDsgIXEuaXNaZXJvKCk7IGkrKykge1xuICAgICAgICBiID0gcS5hbmRsbigweGZmKTtcbiAgICAgICAgcS5pdXNocm4oOCk7XG5cbiAgICAgICAgcmVzW3JlcUxlbmd0aCAtIGkgLSAxXSA9IGI7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAoaSA9IDA7ICFxLmlzWmVybygpOyBpKyspIHtcbiAgICAgICAgYiA9IHEuYW5kbG4oMHhmZik7XG4gICAgICAgIHEuaXVzaHJuKDgpO1xuXG4gICAgICAgIHJlc1tpXSA9IGI7XG4gICAgICB9XG5cbiAgICAgIGZvciAoOyBpIDwgcmVxTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmVzW2ldID0gMDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzO1xuICB9O1xuXG4gIGlmIChNYXRoLmNsejMyKSB7XG4gICAgQk4ucHJvdG90eXBlLl9jb3VudEJpdHMgPSBmdW5jdGlvbiBfY291bnRCaXRzICh3KSB7XG4gICAgICByZXR1cm4gMzIgLSBNYXRoLmNsejMyKHcpO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgQk4ucHJvdG90eXBlLl9jb3VudEJpdHMgPSBmdW5jdGlvbiBfY291bnRCaXRzICh3KSB7XG4gICAgICB2YXIgdCA9IHc7XG4gICAgICB2YXIgciA9IDA7XG4gICAgICBpZiAodCA+PSAweDEwMDApIHtcbiAgICAgICAgciArPSAxMztcbiAgICAgICAgdCA+Pj49IDEzO1xuICAgICAgfVxuICAgICAgaWYgKHQgPj0gMHg0MCkge1xuICAgICAgICByICs9IDc7XG4gICAgICAgIHQgPj4+PSA3O1xuICAgICAgfVxuICAgICAgaWYgKHQgPj0gMHg4KSB7XG4gICAgICAgIHIgKz0gNDtcbiAgICAgICAgdCA+Pj49IDQ7XG4gICAgICB9XG4gICAgICBpZiAodCA+PSAweDAyKSB7XG4gICAgICAgIHIgKz0gMjtcbiAgICAgICAgdCA+Pj49IDI7XG4gICAgICB9XG4gICAgICByZXR1cm4gciArIHQ7XG4gICAgfTtcbiAgfVxuXG4gIEJOLnByb3RvdHlwZS5femVyb0JpdHMgPSBmdW5jdGlvbiBfemVyb0JpdHMgKHcpIHtcbiAgICAvLyBTaG9ydC1jdXRcbiAgICBpZiAodyA9PT0gMCkgcmV0dXJuIDI2O1xuXG4gICAgdmFyIHQgPSB3O1xuICAgIHZhciByID0gMDtcbiAgICBpZiAoKHQgJiAweDFmZmYpID09PSAwKSB7XG4gICAgICByICs9IDEzO1xuICAgICAgdCA+Pj49IDEzO1xuICAgIH1cbiAgICBpZiAoKHQgJiAweDdmKSA9PT0gMCkge1xuICAgICAgciArPSA3O1xuICAgICAgdCA+Pj49IDc7XG4gICAgfVxuICAgIGlmICgodCAmIDB4ZikgPT09IDApIHtcbiAgICAgIHIgKz0gNDtcbiAgICAgIHQgPj4+PSA0O1xuICAgIH1cbiAgICBpZiAoKHQgJiAweDMpID09PSAwKSB7XG4gICAgICByICs9IDI7XG4gICAgICB0ID4+Pj0gMjtcbiAgICB9XG4gICAgaWYgKCh0ICYgMHgxKSA9PT0gMCkge1xuICAgICAgcisrO1xuICAgIH1cbiAgICByZXR1cm4gcjtcbiAgfTtcblxuICAvLyBSZXR1cm4gbnVtYmVyIG9mIHVzZWQgYml0cyBpbiBhIEJOXG4gIEJOLnByb3RvdHlwZS5iaXRMZW5ndGggPSBmdW5jdGlvbiBiaXRMZW5ndGggKCkge1xuICAgIHZhciB3ID0gdGhpcy53b3Jkc1t0aGlzLmxlbmd0aCAtIDFdO1xuICAgIHZhciBoaSA9IHRoaXMuX2NvdW50Qml0cyh3KTtcbiAgICByZXR1cm4gKHRoaXMubGVuZ3RoIC0gMSkgKiAyNiArIGhpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHRvQml0QXJyYXkgKG51bSkge1xuICAgIHZhciB3ID0gbmV3IEFycmF5KG51bS5iaXRMZW5ndGgoKSk7XG5cbiAgICBmb3IgKHZhciBiaXQgPSAwOyBiaXQgPCB3Lmxlbmd0aDsgYml0KyspIHtcbiAgICAgIHZhciBvZmYgPSAoYml0IC8gMjYpIHwgMDtcbiAgICAgIHZhciB3Yml0ID0gYml0ICUgMjY7XG5cbiAgICAgIHdbYml0XSA9IChudW0ud29yZHNbb2ZmXSAmICgxIDw8IHdiaXQpKSA+Pj4gd2JpdDtcbiAgICB9XG5cbiAgICByZXR1cm4gdztcbiAgfVxuXG4gIC8vIE51bWJlciBvZiB0cmFpbGluZyB6ZXJvIGJpdHNcbiAgQk4ucHJvdG90eXBlLnplcm9CaXRzID0gZnVuY3Rpb24gemVyb0JpdHMgKCkge1xuICAgIGlmICh0aGlzLmlzWmVybygpKSByZXR1cm4gMDtcblxuICAgIHZhciByID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBiID0gdGhpcy5femVyb0JpdHModGhpcy53b3Jkc1tpXSk7XG4gICAgICByICs9IGI7XG4gICAgICBpZiAoYiAhPT0gMjYpIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gcjtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuYnl0ZUxlbmd0aCA9IGZ1bmN0aW9uIGJ5dGVMZW5ndGggKCkge1xuICAgIHJldHVybiBNYXRoLmNlaWwodGhpcy5iaXRMZW5ndGgoKSAvIDgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS50b1R3b3MgPSBmdW5jdGlvbiB0b1R3b3MgKHdpZHRoKSB7XG4gICAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDApIHtcbiAgICAgIHJldHVybiB0aGlzLmFicygpLmlub3RuKHdpZHRoKS5pYWRkbigxKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuZnJvbVR3b3MgPSBmdW5jdGlvbiBmcm9tVHdvcyAod2lkdGgpIHtcbiAgICBpZiAodGhpcy50ZXN0bih3aWR0aCAtIDEpKSB7XG4gICAgICByZXR1cm4gdGhpcy5ub3RuKHdpZHRoKS5pYWRkbigxKS5pbmVnKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNsb25lKCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmlzTmVnID0gZnVuY3Rpb24gaXNOZWcgKCkge1xuICAgIHJldHVybiB0aGlzLm5lZ2F0aXZlICE9PSAwO1xuICB9O1xuXG4gIC8vIFJldHVybiBuZWdhdGl2ZSBjbG9uZSBvZiBgdGhpc2BcbiAgQk4ucHJvdG90eXBlLm5lZyA9IGZ1bmN0aW9uIG5lZyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pbmVnKCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmluZWcgPSBmdW5jdGlvbiBpbmVnICgpIHtcbiAgICBpZiAoIXRoaXMuaXNaZXJvKCkpIHtcbiAgICAgIHRoaXMubmVnYXRpdmUgXj0gMTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvLyBPciBgbnVtYCB3aXRoIGB0aGlzYCBpbi1wbGFjZVxuICBCTi5wcm90b3R5cGUuaXVvciA9IGZ1bmN0aW9uIGl1b3IgKG51bSkge1xuICAgIHdoaWxlICh0aGlzLmxlbmd0aCA8IG51bS5sZW5ndGgpIHtcbiAgICAgIHRoaXMud29yZHNbdGhpcy5sZW5ndGgrK10gPSAwO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLndvcmRzW2ldID0gdGhpcy53b3Jkc1tpXSB8IG51bS53b3Jkc1tpXTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zdHJpcCgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5pb3IgPSBmdW5jdGlvbiBpb3IgKG51bSkge1xuICAgIGFzc2VydCgodGhpcy5uZWdhdGl2ZSB8IG51bS5uZWdhdGl2ZSkgPT09IDApO1xuICAgIHJldHVybiB0aGlzLml1b3IobnVtKTtcbiAgfTtcblxuICAvLyBPciBgbnVtYCB3aXRoIGB0aGlzYFxuICBCTi5wcm90b3R5cGUub3IgPSBmdW5jdGlvbiBvciAobnVtKSB7XG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aCkgcmV0dXJuIHRoaXMuY2xvbmUoKS5pb3IobnVtKTtcbiAgICByZXR1cm4gbnVtLmNsb25lKCkuaW9yKHRoaXMpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS51b3IgPSBmdW5jdGlvbiB1b3IgKG51bSkge1xuICAgIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpIHJldHVybiB0aGlzLmNsb25lKCkuaXVvcihudW0pO1xuICAgIHJldHVybiBudW0uY2xvbmUoKS5pdW9yKHRoaXMpO1xuICB9O1xuXG4gIC8vIEFuZCBgbnVtYCB3aXRoIGB0aGlzYCBpbi1wbGFjZVxuICBCTi5wcm90b3R5cGUuaXVhbmQgPSBmdW5jdGlvbiBpdWFuZCAobnVtKSB7XG4gICAgLy8gYiA9IG1pbi1sZW5ndGgobnVtLCB0aGlzKVxuICAgIHZhciBiO1xuICAgIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpIHtcbiAgICAgIGIgPSBudW07XG4gICAgfSBlbHNlIHtcbiAgICAgIGIgPSB0aGlzO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYi5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IHRoaXMud29yZHNbaV0gJiBudW0ud29yZHNbaV07XG4gICAgfVxuXG4gICAgdGhpcy5sZW5ndGggPSBiLmxlbmd0aDtcblxuICAgIHJldHVybiB0aGlzLnN0cmlwKCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmlhbmQgPSBmdW5jdGlvbiBpYW5kIChudW0pIHtcbiAgICBhc3NlcnQoKHRoaXMubmVnYXRpdmUgfCBudW0ubmVnYXRpdmUpID09PSAwKTtcbiAgICByZXR1cm4gdGhpcy5pdWFuZChudW0pO1xuICB9O1xuXG4gIC8vIEFuZCBgbnVtYCB3aXRoIGB0aGlzYFxuICBCTi5wcm90b3R5cGUuYW5kID0gZnVuY3Rpb24gYW5kIChudW0pIHtcbiAgICBpZiAodGhpcy5sZW5ndGggPiBudW0ubGVuZ3RoKSByZXR1cm4gdGhpcy5jbG9uZSgpLmlhbmQobnVtKTtcbiAgICByZXR1cm4gbnVtLmNsb25lKCkuaWFuZCh0aGlzKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUudWFuZCA9IGZ1bmN0aW9uIHVhbmQgKG51bSkge1xuICAgIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpIHJldHVybiB0aGlzLmNsb25lKCkuaXVhbmQobnVtKTtcbiAgICByZXR1cm4gbnVtLmNsb25lKCkuaXVhbmQodGhpcyk7XG4gIH07XG5cbiAgLy8gWG9yIGBudW1gIHdpdGggYHRoaXNgIGluLXBsYWNlXG4gIEJOLnByb3RvdHlwZS5pdXhvciA9IGZ1bmN0aW9uIGl1eG9yIChudW0pIHtcbiAgICAvLyBhLmxlbmd0aCA+IGIubGVuZ3RoXG4gICAgdmFyIGE7XG4gICAgdmFyIGI7XG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aCkge1xuICAgICAgYSA9IHRoaXM7XG4gICAgICBiID0gbnVtO1xuICAgIH0gZWxzZSB7XG4gICAgICBhID0gbnVtO1xuICAgICAgYiA9IHRoaXM7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLndvcmRzW2ldID0gYS53b3Jkc1tpXSBeIGIud29yZHNbaV07XG4gICAgfVxuXG4gICAgaWYgKHRoaXMgIT09IGEpIHtcbiAgICAgIGZvciAoOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLndvcmRzW2ldID0gYS53b3Jkc1tpXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmxlbmd0aCA9IGEubGVuZ3RoO1xuXG4gICAgcmV0dXJuIHRoaXMuc3RyaXAoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuaXhvciA9IGZ1bmN0aW9uIGl4b3IgKG51bSkge1xuICAgIGFzc2VydCgodGhpcy5uZWdhdGl2ZSB8IG51bS5uZWdhdGl2ZSkgPT09IDApO1xuICAgIHJldHVybiB0aGlzLml1eG9yKG51bSk7XG4gIH07XG5cbiAgLy8gWG9yIGBudW1gIHdpdGggYHRoaXNgXG4gIEJOLnByb3RvdHlwZS54b3IgPSBmdW5jdGlvbiB4b3IgKG51bSkge1xuICAgIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpIHJldHVybiB0aGlzLmNsb25lKCkuaXhvcihudW0pO1xuICAgIHJldHVybiBudW0uY2xvbmUoKS5peG9yKHRoaXMpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS51eG9yID0gZnVuY3Rpb24gdXhvciAobnVtKSB7XG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aCkgcmV0dXJuIHRoaXMuY2xvbmUoKS5pdXhvcihudW0pO1xuICAgIHJldHVybiBudW0uY2xvbmUoKS5pdXhvcih0aGlzKTtcbiAgfTtcblxuICAvLyBOb3QgYGB0aGlzYGAgd2l0aCBgYHdpZHRoYGAgYml0d2lkdGhcbiAgQk4ucHJvdG90eXBlLmlub3RuID0gZnVuY3Rpb24gaW5vdG4gKHdpZHRoKSB7XG4gICAgYXNzZXJ0KHR5cGVvZiB3aWR0aCA9PT0gJ251bWJlcicgJiYgd2lkdGggPj0gMCk7XG5cbiAgICB2YXIgYnl0ZXNOZWVkZWQgPSBNYXRoLmNlaWwod2lkdGggLyAyNikgfCAwO1xuICAgIHZhciBiaXRzTGVmdCA9IHdpZHRoICUgMjY7XG5cbiAgICAvLyBFeHRlbmQgdGhlIGJ1ZmZlciB3aXRoIGxlYWRpbmcgemVyb2VzXG4gICAgdGhpcy5fZXhwYW5kKGJ5dGVzTmVlZGVkKTtcblxuICAgIGlmIChiaXRzTGVmdCA+IDApIHtcbiAgICAgIGJ5dGVzTmVlZGVkLS07XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIGNvbXBsZXRlIHdvcmRzXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlc05lZWRlZDsgaSsrKSB7XG4gICAgICB0aGlzLndvcmRzW2ldID0gfnRoaXMud29yZHNbaV0gJiAweDNmZmZmZmY7XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIHRoZSByZXNpZHVlXG4gICAgaWYgKGJpdHNMZWZ0ID4gMCkge1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IH50aGlzLndvcmRzW2ldICYgKDB4M2ZmZmZmZiA+PiAoMjYgLSBiaXRzTGVmdCkpO1xuICAgIH1cblxuICAgIC8vIEFuZCByZW1vdmUgbGVhZGluZyB6ZXJvZXNcbiAgICByZXR1cm4gdGhpcy5zdHJpcCgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5ub3RuID0gZnVuY3Rpb24gbm90biAod2lkdGgpIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmlub3RuKHdpZHRoKTtcbiAgfTtcblxuICAvLyBTZXQgYGJpdGAgb2YgYHRoaXNgXG4gIEJOLnByb3RvdHlwZS5zZXRuID0gZnVuY3Rpb24gc2V0biAoYml0LCB2YWwpIHtcbiAgICBhc3NlcnQodHlwZW9mIGJpdCA9PT0gJ251bWJlcicgJiYgYml0ID49IDApO1xuXG4gICAgdmFyIG9mZiA9IChiaXQgLyAyNikgfCAwO1xuICAgIHZhciB3Yml0ID0gYml0ICUgMjY7XG5cbiAgICB0aGlzLl9leHBhbmQob2ZmICsgMSk7XG5cbiAgICBpZiAodmFsKSB7XG4gICAgICB0aGlzLndvcmRzW29mZl0gPSB0aGlzLndvcmRzW29mZl0gfCAoMSA8PCB3Yml0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy53b3Jkc1tvZmZdID0gdGhpcy53b3Jkc1tvZmZdICYgfigxIDw8IHdiaXQpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnN0cmlwKCk7XG4gIH07XG5cbiAgLy8gQWRkIGBudW1gIHRvIGB0aGlzYCBpbi1wbGFjZVxuICBCTi5wcm90b3R5cGUuaWFkZCA9IGZ1bmN0aW9uIGlhZGQgKG51bSkge1xuICAgIHZhciByO1xuXG4gICAgLy8gbmVnYXRpdmUgKyBwb3NpdGl2ZVxuICAgIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwICYmIG51bS5uZWdhdGl2ZSA9PT0gMCkge1xuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDA7XG4gICAgICByID0gdGhpcy5pc3ViKG51bSk7XG4gICAgICB0aGlzLm5lZ2F0aXZlIF49IDE7XG4gICAgICByZXR1cm4gdGhpcy5fbm9ybVNpZ24oKTtcblxuICAgIC8vIHBvc2l0aXZlICsgbmVnYXRpdmVcbiAgICB9IGVsc2UgaWYgKHRoaXMubmVnYXRpdmUgPT09IDAgJiYgbnVtLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICBudW0ubmVnYXRpdmUgPSAwO1xuICAgICAgciA9IHRoaXMuaXN1YihudW0pO1xuICAgICAgbnVtLm5lZ2F0aXZlID0gMTtcbiAgICAgIHJldHVybiByLl9ub3JtU2lnbigpO1xuICAgIH1cblxuICAgIC8vIGEubGVuZ3RoID4gYi5sZW5ndGhcbiAgICB2YXIgYSwgYjtcbiAgICBpZiAodGhpcy5sZW5ndGggPiBudW0ubGVuZ3RoKSB7XG4gICAgICBhID0gdGhpcztcbiAgICAgIGIgPSBudW07XG4gICAgfSBlbHNlIHtcbiAgICAgIGEgPSBudW07XG4gICAgICBiID0gdGhpcztcbiAgICB9XG5cbiAgICB2YXIgY2FycnkgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYi5sZW5ndGg7IGkrKykge1xuICAgICAgciA9IChhLndvcmRzW2ldIHwgMCkgKyAoYi53b3Jkc1tpXSB8IDApICsgY2Fycnk7XG4gICAgICB0aGlzLndvcmRzW2ldID0gciAmIDB4M2ZmZmZmZjtcbiAgICAgIGNhcnJ5ID0gciA+Pj4gMjY7XG4gICAgfVxuICAgIGZvciAoOyBjYXJyeSAhPT0gMCAmJiBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgciA9IChhLndvcmRzW2ldIHwgMCkgKyBjYXJyeTtcbiAgICAgIHRoaXMud29yZHNbaV0gPSByICYgMHgzZmZmZmZmO1xuICAgICAgY2FycnkgPSByID4+PiAyNjtcbiAgICB9XG5cbiAgICB0aGlzLmxlbmd0aCA9IGEubGVuZ3RoO1xuICAgIGlmIChjYXJyeSAhPT0gMCkge1xuICAgICAgdGhpcy53b3Jkc1t0aGlzLmxlbmd0aF0gPSBjYXJyeTtcbiAgICAgIHRoaXMubGVuZ3RoKys7XG4gICAgLy8gQ29weSB0aGUgcmVzdCBvZiB0aGUgd29yZHNcbiAgICB9IGVsc2UgaWYgKGEgIT09IHRoaXMpIHtcbiAgICAgIGZvciAoOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLndvcmRzW2ldID0gYS53b3Jkc1tpXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvLyBBZGQgYG51bWAgdG8gYHRoaXNgXG4gIEJOLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQgKG51bSkge1xuICAgIHZhciByZXM7XG4gICAgaWYgKG51bS5uZWdhdGl2ZSAhPT0gMCAmJiB0aGlzLm5lZ2F0aXZlID09PSAwKSB7XG4gICAgICBudW0ubmVnYXRpdmUgPSAwO1xuICAgICAgcmVzID0gdGhpcy5zdWIobnVtKTtcbiAgICAgIG51bS5uZWdhdGl2ZSBePSAxO1xuICAgICAgcmV0dXJuIHJlcztcbiAgICB9IGVsc2UgaWYgKG51bS5uZWdhdGl2ZSA9PT0gMCAmJiB0aGlzLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMDtcbiAgICAgIHJlcyA9IG51bS5zdWIodGhpcyk7XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMTtcbiAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aCkgcmV0dXJuIHRoaXMuY2xvbmUoKS5pYWRkKG51bSk7XG5cbiAgICByZXR1cm4gbnVtLmNsb25lKCkuaWFkZCh0aGlzKTtcbiAgfTtcblxuICAvLyBTdWJ0cmFjdCBgbnVtYCBmcm9tIGB0aGlzYCBpbi1wbGFjZVxuICBCTi5wcm90b3R5cGUuaXN1YiA9IGZ1bmN0aW9uIGlzdWIgKG51bSkge1xuICAgIC8vIHRoaXMgLSAoLW51bSkgPSB0aGlzICsgbnVtXG4gICAgaWYgKG51bS5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgbnVtLm5lZ2F0aXZlID0gMDtcbiAgICAgIHZhciByID0gdGhpcy5pYWRkKG51bSk7XG4gICAgICBudW0ubmVnYXRpdmUgPSAxO1xuICAgICAgcmV0dXJuIHIuX25vcm1TaWduKCk7XG5cbiAgICAvLyAtdGhpcyAtIG51bSA9IC0odGhpcyArIG51bSlcbiAgICB9IGVsc2UgaWYgKHRoaXMubmVnYXRpdmUgIT09IDApIHtcbiAgICAgIHRoaXMubmVnYXRpdmUgPSAwO1xuICAgICAgdGhpcy5pYWRkKG51bSk7XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMTtcbiAgICAgIHJldHVybiB0aGlzLl9ub3JtU2lnbigpO1xuICAgIH1cblxuICAgIC8vIEF0IHRoaXMgcG9pbnQgYm90aCBudW1iZXJzIGFyZSBwb3NpdGl2ZVxuICAgIHZhciBjbXAgPSB0aGlzLmNtcChudW0pO1xuXG4gICAgLy8gT3B0aW1pemF0aW9uIC0gemVyb2lmeVxuICAgIGlmIChjbXAgPT09IDApIHtcbiAgICAgIHRoaXMubmVnYXRpdmUgPSAwO1xuICAgICAgdGhpcy5sZW5ndGggPSAxO1xuICAgICAgdGhpcy53b3Jkc1swXSA9IDA7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyBhID4gYlxuICAgIHZhciBhLCBiO1xuICAgIGlmIChjbXAgPiAwKSB7XG4gICAgICBhID0gdGhpcztcbiAgICAgIGIgPSBudW07XG4gICAgfSBlbHNlIHtcbiAgICAgIGEgPSBudW07XG4gICAgICBiID0gdGhpcztcbiAgICB9XG5cbiAgICB2YXIgY2FycnkgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYi5sZW5ndGg7IGkrKykge1xuICAgICAgciA9IChhLndvcmRzW2ldIHwgMCkgLSAoYi53b3Jkc1tpXSB8IDApICsgY2Fycnk7XG4gICAgICBjYXJyeSA9IHIgPj4gMjY7XG4gICAgICB0aGlzLndvcmRzW2ldID0gciAmIDB4M2ZmZmZmZjtcbiAgICB9XG4gICAgZm9yICg7IGNhcnJ5ICE9PSAwICYmIGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICByID0gKGEud29yZHNbaV0gfCAwKSArIGNhcnJ5O1xuICAgICAgY2FycnkgPSByID4+IDI2O1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IHIgJiAweDNmZmZmZmY7XG4gICAgfVxuXG4gICAgLy8gQ29weSByZXN0IG9mIHRoZSB3b3Jkc1xuICAgIGlmIChjYXJyeSA9PT0gMCAmJiBpIDwgYS5sZW5ndGggJiYgYSAhPT0gdGhpcykge1xuICAgICAgZm9yICg7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMud29yZHNbaV0gPSBhLndvcmRzW2ldO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMubGVuZ3RoID0gTWF0aC5tYXgodGhpcy5sZW5ndGgsIGkpO1xuXG4gICAgaWYgKGEgIT09IHRoaXMpIHtcbiAgICAgIHRoaXMubmVnYXRpdmUgPSAxO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnN0cmlwKCk7XG4gIH07XG5cbiAgLy8gU3VidHJhY3QgYG51bWAgZnJvbSBgdGhpc2BcbiAgQk4ucHJvdG90eXBlLnN1YiA9IGZ1bmN0aW9uIHN1YiAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pc3ViKG51bSk7XG4gIH07XG5cbiAgZnVuY3Rpb24gc21hbGxNdWxUbyAoc2VsZiwgbnVtLCBvdXQpIHtcbiAgICBvdXQubmVnYXRpdmUgPSBudW0ubmVnYXRpdmUgXiBzZWxmLm5lZ2F0aXZlO1xuICAgIHZhciBsZW4gPSAoc2VsZi5sZW5ndGggKyBudW0ubGVuZ3RoKSB8IDA7XG4gICAgb3V0Lmxlbmd0aCA9IGxlbjtcbiAgICBsZW4gPSAobGVuIC0gMSkgfCAwO1xuXG4gICAgLy8gUGVlbCBvbmUgaXRlcmF0aW9uIChjb21waWxlciBjYW4ndCBkbyBpdCwgYmVjYXVzZSBvZiBjb2RlIGNvbXBsZXhpdHkpXG4gICAgdmFyIGEgPSBzZWxmLndvcmRzWzBdIHwgMDtcbiAgICB2YXIgYiA9IG51bS53b3Jkc1swXSB8IDA7XG4gICAgdmFyIHIgPSBhICogYjtcblxuICAgIHZhciBsbyA9IHIgJiAweDNmZmZmZmY7XG4gICAgdmFyIGNhcnJ5ID0gKHIgLyAweDQwMDAwMDApIHwgMDtcbiAgICBvdXQud29yZHNbMF0gPSBsbztcblxuICAgIGZvciAodmFyIGsgPSAxOyBrIDwgbGVuOyBrKyspIHtcbiAgICAgIC8vIFN1bSBhbGwgd29yZHMgd2l0aCB0aGUgc2FtZSBgaSArIGogPSBrYCBhbmQgYWNjdW11bGF0ZSBgbmNhcnJ5YCxcbiAgICAgIC8vIG5vdGUgdGhhdCBuY2FycnkgY291bGQgYmUgPj0gMHgzZmZmZmZmXG4gICAgICB2YXIgbmNhcnJ5ID0gY2FycnkgPj4+IDI2O1xuICAgICAgdmFyIHJ3b3JkID0gY2FycnkgJiAweDNmZmZmZmY7XG4gICAgICB2YXIgbWF4SiA9IE1hdGgubWluKGssIG51bS5sZW5ndGggLSAxKTtcbiAgICAgIGZvciAodmFyIGogPSBNYXRoLm1heCgwLCBrIC0gc2VsZi5sZW5ndGggKyAxKTsgaiA8PSBtYXhKOyBqKyspIHtcbiAgICAgICAgdmFyIGkgPSAoayAtIGopIHwgMDtcbiAgICAgICAgYSA9IHNlbGYud29yZHNbaV0gfCAwO1xuICAgICAgICBiID0gbnVtLndvcmRzW2pdIHwgMDtcbiAgICAgICAgciA9IGEgKiBiICsgcndvcmQ7XG4gICAgICAgIG5jYXJyeSArPSAociAvIDB4NDAwMDAwMCkgfCAwO1xuICAgICAgICByd29yZCA9IHIgJiAweDNmZmZmZmY7XG4gICAgICB9XG4gICAgICBvdXQud29yZHNba10gPSByd29yZCB8IDA7XG4gICAgICBjYXJyeSA9IG5jYXJyeSB8IDA7XG4gICAgfVxuICAgIGlmIChjYXJyeSAhPT0gMCkge1xuICAgICAgb3V0LndvcmRzW2tdID0gY2FycnkgfCAwO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXQubGVuZ3RoLS07XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dC5zdHJpcCgpO1xuICB9XG5cbiAgLy8gVE9ETyhpbmR1dG55KTogaXQgbWF5IGJlIHJlYXNvbmFibGUgdG8gb21pdCBpdCBmb3IgdXNlcnMgd2hvIGRvbid0IG5lZWRcbiAgLy8gdG8gd29yayB3aXRoIDI1Ni1iaXQgbnVtYmVycywgb3RoZXJ3aXNlIGl0IGdpdmVzIDIwJSBpbXByb3ZlbWVudCBmb3IgMjU2LWJpdFxuICAvLyBtdWx0aXBsaWNhdGlvbiAobGlrZSBlbGxpcHRpYyBzZWNwMjU2azEpLlxuICB2YXIgY29tYjEwTXVsVG8gPSBmdW5jdGlvbiBjb21iMTBNdWxUbyAoc2VsZiwgbnVtLCBvdXQpIHtcbiAgICB2YXIgYSA9IHNlbGYud29yZHM7XG4gICAgdmFyIGIgPSBudW0ud29yZHM7XG4gICAgdmFyIG8gPSBvdXQud29yZHM7XG4gICAgdmFyIGMgPSAwO1xuICAgIHZhciBsbztcbiAgICB2YXIgbWlkO1xuICAgIHZhciBoaTtcbiAgICB2YXIgYTAgPSBhWzBdIHwgMDtcbiAgICB2YXIgYWwwID0gYTAgJiAweDFmZmY7XG4gICAgdmFyIGFoMCA9IGEwID4+PiAxMztcbiAgICB2YXIgYTEgPSBhWzFdIHwgMDtcbiAgICB2YXIgYWwxID0gYTEgJiAweDFmZmY7XG4gICAgdmFyIGFoMSA9IGExID4+PiAxMztcbiAgICB2YXIgYTIgPSBhWzJdIHwgMDtcbiAgICB2YXIgYWwyID0gYTIgJiAweDFmZmY7XG4gICAgdmFyIGFoMiA9IGEyID4+PiAxMztcbiAgICB2YXIgYTMgPSBhWzNdIHwgMDtcbiAgICB2YXIgYWwzID0gYTMgJiAweDFmZmY7XG4gICAgdmFyIGFoMyA9IGEzID4+PiAxMztcbiAgICB2YXIgYTQgPSBhWzRdIHwgMDtcbiAgICB2YXIgYWw0ID0gYTQgJiAweDFmZmY7XG4gICAgdmFyIGFoNCA9IGE0ID4+PiAxMztcbiAgICB2YXIgYTUgPSBhWzVdIHwgMDtcbiAgICB2YXIgYWw1ID0gYTUgJiAweDFmZmY7XG4gICAgdmFyIGFoNSA9IGE1ID4+PiAxMztcbiAgICB2YXIgYTYgPSBhWzZdIHwgMDtcbiAgICB2YXIgYWw2ID0gYTYgJiAweDFmZmY7XG4gICAgdmFyIGFoNiA9IGE2ID4+PiAxMztcbiAgICB2YXIgYTcgPSBhWzddIHwgMDtcbiAgICB2YXIgYWw3ID0gYTcgJiAweDFmZmY7XG4gICAgdmFyIGFoNyA9IGE3ID4+PiAxMztcbiAgICB2YXIgYTggPSBhWzhdIHwgMDtcbiAgICB2YXIgYWw4ID0gYTggJiAweDFmZmY7XG4gICAgdmFyIGFoOCA9IGE4ID4+PiAxMztcbiAgICB2YXIgYTkgPSBhWzldIHwgMDtcbiAgICB2YXIgYWw5ID0gYTkgJiAweDFmZmY7XG4gICAgdmFyIGFoOSA9IGE5ID4+PiAxMztcbiAgICB2YXIgYjAgPSBiWzBdIHwgMDtcbiAgICB2YXIgYmwwID0gYjAgJiAweDFmZmY7XG4gICAgdmFyIGJoMCA9IGIwID4+PiAxMztcbiAgICB2YXIgYjEgPSBiWzFdIHwgMDtcbiAgICB2YXIgYmwxID0gYjEgJiAweDFmZmY7XG4gICAgdmFyIGJoMSA9IGIxID4+PiAxMztcbiAgICB2YXIgYjIgPSBiWzJdIHwgMDtcbiAgICB2YXIgYmwyID0gYjIgJiAweDFmZmY7XG4gICAgdmFyIGJoMiA9IGIyID4+PiAxMztcbiAgICB2YXIgYjMgPSBiWzNdIHwgMDtcbiAgICB2YXIgYmwzID0gYjMgJiAweDFmZmY7XG4gICAgdmFyIGJoMyA9IGIzID4+PiAxMztcbiAgICB2YXIgYjQgPSBiWzRdIHwgMDtcbiAgICB2YXIgYmw0ID0gYjQgJiAweDFmZmY7XG4gICAgdmFyIGJoNCA9IGI0ID4+PiAxMztcbiAgICB2YXIgYjUgPSBiWzVdIHwgMDtcbiAgICB2YXIgYmw1ID0gYjUgJiAweDFmZmY7XG4gICAgdmFyIGJoNSA9IGI1ID4+PiAxMztcbiAgICB2YXIgYjYgPSBiWzZdIHwgMDtcbiAgICB2YXIgYmw2ID0gYjYgJiAweDFmZmY7XG4gICAgdmFyIGJoNiA9IGI2ID4+PiAxMztcbiAgICB2YXIgYjcgPSBiWzddIHwgMDtcbiAgICB2YXIgYmw3ID0gYjcgJiAweDFmZmY7XG4gICAgdmFyIGJoNyA9IGI3ID4+PiAxMztcbiAgICB2YXIgYjggPSBiWzhdIHwgMDtcbiAgICB2YXIgYmw4ID0gYjggJiAweDFmZmY7XG4gICAgdmFyIGJoOCA9IGI4ID4+PiAxMztcbiAgICB2YXIgYjkgPSBiWzldIHwgMDtcbiAgICB2YXIgYmw5ID0gYjkgJiAweDFmZmY7XG4gICAgdmFyIGJoOSA9IGI5ID4+PiAxMztcblxuICAgIG91dC5uZWdhdGl2ZSA9IHNlbGYubmVnYXRpdmUgXiBudW0ubmVnYXRpdmU7XG4gICAgb3V0Lmxlbmd0aCA9IDE5O1xuICAgIC8qIGsgPSAwICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWwwLCBibDApO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDAsIGJoMCk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDAsIGJsMCkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDAsIGJoMCk7XG4gICAgdmFyIHcwID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MCA+Pj4gMjYpKSB8IDA7XG4gICAgdzAgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSAxICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWwxLCBibDApO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDEsIGJoMCk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDEsIGJsMCkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDEsIGJoMCk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwwLCBibDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDAsIGJoMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMCwgYmwxKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMCwgYmgxKSkgfCAwO1xuICAgIHZhciB3MSA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzEgPj4+IDI2KSkgfCAwO1xuICAgIHcxICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gMiAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsMiwgYmwwKTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWwyLCBiaDApO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgyLCBibDApKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWgyLCBiaDApO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMSwgYmwxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwxLCBiaDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDEsIGJsMSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDEsIGJoMSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDAsIGJsMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMCwgYmgyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgwLCBibDIpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgwLCBiaDIpKSB8IDA7XG4gICAgdmFyIHcyID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MiA+Pj4gMjYpKSB8IDA7XG4gICAgdzIgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSAzICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWwzLCBibDApO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDMsIGJoMCk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDMsIGJsMCkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDMsIGJoMCk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwyLCBibDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDIsIGJoMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMiwgYmwxKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMiwgYmgxKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMSwgYmwyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwxLCBiaDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDEsIGJsMikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDEsIGJoMikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDAsIGJsMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMCwgYmgzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgwLCBibDMpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgwLCBiaDMpKSB8IDA7XG4gICAgdmFyIHczID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MyA+Pj4gMjYpKSB8IDA7XG4gICAgdzMgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSA0ICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw0LCBibDApO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDQsIGJoMCk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDQsIGJsMCkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDQsIGJoMCk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwzLCBibDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDMsIGJoMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMywgYmwxKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMywgYmgxKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMiwgYmwyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwyLCBiaDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDIsIGJsMikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDIsIGJoMikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDEsIGJsMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMSwgYmgzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgxLCBibDMpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgxLCBiaDMpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwwLCBibDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDAsIGJoNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMCwgYmw0KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMCwgYmg0KSkgfCAwO1xuICAgIHZhciB3NCA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzQgPj4+IDI2KSkgfCAwO1xuICAgIHc0ICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gNSAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsNSwgYmwwKTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw1LCBiaDApO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg1LCBibDApKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg1LCBiaDApO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNCwgYmwxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw0LCBiaDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDQsIGJsMSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDQsIGJoMSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDMsIGJsMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMywgYmgyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgzLCBibDIpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgzLCBiaDIpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwyLCBibDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDIsIGJoMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMiwgYmwzKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMiwgYmgzKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMSwgYmw0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwxLCBiaDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDEsIGJsNCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDEsIGJoNCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDAsIGJsNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMCwgYmg1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgwLCBibDUpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgwLCBiaDUpKSB8IDA7XG4gICAgdmFyIHc1ID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3NSA+Pj4gMjYpKSB8IDA7XG4gICAgdzUgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSA2ICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw2LCBibDApO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDYsIGJoMCk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDYsIGJsMCkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDYsIGJoMCk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw1LCBibDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDUsIGJoMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNSwgYmwxKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNSwgYmgxKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNCwgYmwyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw0LCBiaDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDQsIGJsMikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDQsIGJoMikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDMsIGJsMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMywgYmgzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgzLCBibDMpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgzLCBiaDMpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwyLCBibDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDIsIGJoNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMiwgYmw0KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMiwgYmg0KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMSwgYmw1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwxLCBiaDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDEsIGJsNSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDEsIGJoNSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDAsIGJsNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMCwgYmg2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgwLCBibDYpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgwLCBiaDYpKSB8IDA7XG4gICAgdmFyIHc2ID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3NiA+Pj4gMjYpKSB8IDA7XG4gICAgdzYgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSA3ICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw3LCBibDApO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDcsIGJoMCk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDcsIGJsMCkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDcsIGJoMCk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw2LCBibDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDYsIGJoMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNiwgYmwxKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNiwgYmgxKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNSwgYmwyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw1LCBiaDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDUsIGJsMikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDUsIGJoMikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDQsIGJsMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNCwgYmgzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg0LCBibDMpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg0LCBiaDMpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwzLCBibDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDMsIGJoNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMywgYmw0KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMywgYmg0KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMiwgYmw1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwyLCBiaDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDIsIGJsNSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDIsIGJoNSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDEsIGJsNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMSwgYmg2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgxLCBibDYpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgxLCBiaDYpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwwLCBibDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDAsIGJoNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMCwgYmw3KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMCwgYmg3KSkgfCAwO1xuICAgIHZhciB3NyA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzcgPj4+IDI2KSkgfCAwO1xuICAgIHc3ICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gOCAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsOCwgYmwwKTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw4LCBiaDApO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg4LCBibDApKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg4LCBiaDApO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNywgYmwxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw3LCBiaDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDcsIGJsMSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDcsIGJoMSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDYsIGJsMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNiwgYmgyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg2LCBibDIpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg2LCBiaDIpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw1LCBibDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDUsIGJoMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNSwgYmwzKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNSwgYmgzKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNCwgYmw0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw0LCBiaDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDQsIGJsNCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDQsIGJoNCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDMsIGJsNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMywgYmg1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgzLCBibDUpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgzLCBiaDUpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwyLCBibDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDIsIGJoNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMiwgYmw2KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMiwgYmg2KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMSwgYmw3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwxLCBiaDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDEsIGJsNykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDEsIGJoNykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDAsIGJsOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMCwgYmg4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgwLCBibDgpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgwLCBiaDgpKSB8IDA7XG4gICAgdmFyIHc4ID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3OCA+Pj4gMjYpKSB8IDA7XG4gICAgdzggJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSA5ICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw5LCBibDApO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDksIGJoMCk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDksIGJsMCkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDksIGJoMCk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw4LCBibDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDgsIGJoMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOCwgYmwxKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoOCwgYmgxKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNywgYmwyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw3LCBiaDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDcsIGJsMikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDcsIGJoMikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDYsIGJsMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNiwgYmgzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg2LCBibDMpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg2LCBiaDMpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw1LCBibDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDUsIGJoNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNSwgYmw0KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNSwgYmg0KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNCwgYmw1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw0LCBiaDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDQsIGJsNSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDQsIGJoNSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDMsIGJsNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMywgYmg2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgzLCBibDYpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgzLCBiaDYpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwyLCBibDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDIsIGJoNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMiwgYmw3KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMiwgYmg3KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMSwgYmw4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwxLCBiaDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDEsIGJsOCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDEsIGJoOCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDAsIGJsOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMCwgYmg5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgwLCBibDkpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgwLCBiaDkpKSB8IDA7XG4gICAgdmFyIHc5ID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3OSA+Pj4gMjYpKSB8IDA7XG4gICAgdzkgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSAxMCAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsOSwgYmwxKTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw5LCBiaDEpO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg5LCBibDEpKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg5LCBiaDEpO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsOCwgYmwyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw4LCBiaDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDgsIGJsMikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDgsIGJoMikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDcsIGJsMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNywgYmgzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg3LCBibDMpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg3LCBiaDMpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw2LCBibDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDYsIGJoNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNiwgYmw0KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNiwgYmg0KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNSwgYmw1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw1LCBiaDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDUsIGJsNSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDUsIGJoNSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDQsIGJsNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNCwgYmg2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg0LCBibDYpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg0LCBiaDYpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwzLCBibDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDMsIGJoNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMywgYmw3KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMywgYmg3KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMiwgYmw4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwyLCBiaDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDIsIGJsOCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDIsIGJoOCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDEsIGJsOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMSwgYmg5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgxLCBibDkpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgxLCBiaDkpKSB8IDA7XG4gICAgdmFyIHcxMCA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzEwID4+PiAyNikpIHwgMDtcbiAgICB3MTAgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSAxMSAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsOSwgYmwyKTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw5LCBiaDIpO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg5LCBibDIpKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg5LCBiaDIpO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsOCwgYmwzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw4LCBiaDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDgsIGJsMykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDgsIGJoMykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDcsIGJsNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNywgYmg0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg3LCBibDQpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg3LCBiaDQpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw2LCBibDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDYsIGJoNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNiwgYmw1KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNiwgYmg1KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNSwgYmw2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw1LCBiaDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDUsIGJsNikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDUsIGJoNikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDQsIGJsNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNCwgYmg3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg0LCBibDcpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg0LCBiaDcpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwzLCBibDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDMsIGJoOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMywgYmw4KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMywgYmg4KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMiwgYmw5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwyLCBiaDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDIsIGJsOSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDIsIGJoOSkpIHwgMDtcbiAgICB2YXIgdzExID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MTEgPj4+IDI2KSkgfCAwO1xuICAgIHcxMSAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDEyICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw5LCBibDMpO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDksIGJoMyk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDksIGJsMykpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDksIGJoMyk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw4LCBibDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDgsIGJoNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOCwgYmw0KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoOCwgYmg0KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNywgYmw1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw3LCBiaDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDcsIGJsNSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDcsIGJoNSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDYsIGJsNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNiwgYmg2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg2LCBibDYpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg2LCBiaDYpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw1LCBibDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDUsIGJoNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNSwgYmw3KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNSwgYmg3KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNCwgYmw4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw0LCBiaDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDQsIGJsOCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDQsIGJoOCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDMsIGJsOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMywgYmg5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgzLCBibDkpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgzLCBiaDkpKSB8IDA7XG4gICAgdmFyIHcxMiA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzEyID4+PiAyNikpIHwgMDtcbiAgICB3MTIgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSAxMyAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsOSwgYmw0KTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw5LCBiaDQpO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg5LCBibDQpKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg5LCBiaDQpO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsOCwgYmw1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw4LCBiaDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDgsIGJsNSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDgsIGJoNSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDcsIGJsNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNywgYmg2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg3LCBibDYpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg3LCBiaDYpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw2LCBibDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDYsIGJoNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNiwgYmw3KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNiwgYmg3KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNSwgYmw4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw1LCBiaDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDUsIGJsOCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDUsIGJoOCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDQsIGJsOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNCwgYmg5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg0LCBibDkpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg0LCBiaDkpKSB8IDA7XG4gICAgdmFyIHcxMyA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzEzID4+PiAyNikpIHwgMDtcbiAgICB3MTMgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSAxNCAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsOSwgYmw1KTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw5LCBiaDUpO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg5LCBibDUpKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg5LCBiaDUpO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsOCwgYmw2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw4LCBiaDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDgsIGJsNikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDgsIGJoNikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDcsIGJsNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNywgYmg3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg3LCBibDcpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg3LCBiaDcpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw2LCBibDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDYsIGJoOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNiwgYmw4KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNiwgYmg4KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNSwgYmw5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw1LCBiaDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDUsIGJsOSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDUsIGJoOSkpIHwgMDtcbiAgICB2YXIgdzE0ID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MTQgPj4+IDI2KSkgfCAwO1xuICAgIHcxNCAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDE1ICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw5LCBibDYpO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDksIGJoNik7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDksIGJsNikpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDksIGJoNik7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw4LCBibDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDgsIGJoNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOCwgYmw3KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoOCwgYmg3KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNywgYmw4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw3LCBiaDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDcsIGJsOCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDcsIGJoOCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDYsIGJsOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNiwgYmg5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg2LCBibDkpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg2LCBiaDkpKSB8IDA7XG4gICAgdmFyIHcxNSA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzE1ID4+PiAyNikpIHwgMDtcbiAgICB3MTUgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSAxNiAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsOSwgYmw3KTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw5LCBiaDcpO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg5LCBibDcpKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg5LCBiaDcpO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsOCwgYmw4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw4LCBiaDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDgsIGJsOCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDgsIGJoOCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDcsIGJsOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNywgYmg5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg3LCBibDkpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg3LCBiaDkpKSB8IDA7XG4gICAgdmFyIHcxNiA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzE2ID4+PiAyNikpIHwgMDtcbiAgICB3MTYgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSAxNyAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsOSwgYmw4KTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw5LCBiaDgpO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg5LCBibDgpKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg5LCBiaDgpO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsOCwgYmw5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw4LCBiaDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDgsIGJsOSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDgsIGJoOSkpIHwgMDtcbiAgICB2YXIgdzE3ID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MTcgPj4+IDI2KSkgfCAwO1xuICAgIHcxNyAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDE4ICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw5LCBibDkpO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDksIGJoOSk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDksIGJsOSkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDksIGJoOSk7XG4gICAgdmFyIHcxOCA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzE4ID4+PiAyNikpIHwgMDtcbiAgICB3MTggJj0gMHgzZmZmZmZmO1xuICAgIG9bMF0gPSB3MDtcbiAgICBvWzFdID0gdzE7XG4gICAgb1syXSA9IHcyO1xuICAgIG9bM10gPSB3MztcbiAgICBvWzRdID0gdzQ7XG4gICAgb1s1XSA9IHc1O1xuICAgIG9bNl0gPSB3NjtcbiAgICBvWzddID0gdzc7XG4gICAgb1s4XSA9IHc4O1xuICAgIG9bOV0gPSB3OTtcbiAgICBvWzEwXSA9IHcxMDtcbiAgICBvWzExXSA9IHcxMTtcbiAgICBvWzEyXSA9IHcxMjtcbiAgICBvWzEzXSA9IHcxMztcbiAgICBvWzE0XSA9IHcxNDtcbiAgICBvWzE1XSA9IHcxNTtcbiAgICBvWzE2XSA9IHcxNjtcbiAgICBvWzE3XSA9IHcxNztcbiAgICBvWzE4XSA9IHcxODtcbiAgICBpZiAoYyAhPT0gMCkge1xuICAgICAgb1sxOV0gPSBjO1xuICAgICAgb3V0Lmxlbmd0aCsrO1xuICAgIH1cbiAgICByZXR1cm4gb3V0O1xuICB9O1xuXG4gIC8vIFBvbHlmaWxsIGNvbWJcbiAgaWYgKCFNYXRoLmltdWwpIHtcbiAgICBjb21iMTBNdWxUbyA9IHNtYWxsTXVsVG87XG4gIH1cblxuICBmdW5jdGlvbiBiaWdNdWxUbyAoc2VsZiwgbnVtLCBvdXQpIHtcbiAgICBvdXQubmVnYXRpdmUgPSBudW0ubmVnYXRpdmUgXiBzZWxmLm5lZ2F0aXZlO1xuICAgIG91dC5sZW5ndGggPSBzZWxmLmxlbmd0aCArIG51bS5sZW5ndGg7XG5cbiAgICB2YXIgY2FycnkgPSAwO1xuICAgIHZhciBobmNhcnJ5ID0gMDtcbiAgICBmb3IgKHZhciBrID0gMDsgayA8IG91dC5sZW5ndGggLSAxOyBrKyspIHtcbiAgICAgIC8vIFN1bSBhbGwgd29yZHMgd2l0aCB0aGUgc2FtZSBgaSArIGogPSBrYCBhbmQgYWNjdW11bGF0ZSBgbmNhcnJ5YCxcbiAgICAgIC8vIG5vdGUgdGhhdCBuY2FycnkgY291bGQgYmUgPj0gMHgzZmZmZmZmXG4gICAgICB2YXIgbmNhcnJ5ID0gaG5jYXJyeTtcbiAgICAgIGhuY2FycnkgPSAwO1xuICAgICAgdmFyIHJ3b3JkID0gY2FycnkgJiAweDNmZmZmZmY7XG4gICAgICB2YXIgbWF4SiA9IE1hdGgubWluKGssIG51bS5sZW5ndGggLSAxKTtcbiAgICAgIGZvciAodmFyIGogPSBNYXRoLm1heCgwLCBrIC0gc2VsZi5sZW5ndGggKyAxKTsgaiA8PSBtYXhKOyBqKyspIHtcbiAgICAgICAgdmFyIGkgPSBrIC0gajtcbiAgICAgICAgdmFyIGEgPSBzZWxmLndvcmRzW2ldIHwgMDtcbiAgICAgICAgdmFyIGIgPSBudW0ud29yZHNbal0gfCAwO1xuICAgICAgICB2YXIgciA9IGEgKiBiO1xuXG4gICAgICAgIHZhciBsbyA9IHIgJiAweDNmZmZmZmY7XG4gICAgICAgIG5jYXJyeSA9IChuY2FycnkgKyAoKHIgLyAweDQwMDAwMDApIHwgMCkpIHwgMDtcbiAgICAgICAgbG8gPSAobG8gKyByd29yZCkgfCAwO1xuICAgICAgICByd29yZCA9IGxvICYgMHgzZmZmZmZmO1xuICAgICAgICBuY2FycnkgPSAobmNhcnJ5ICsgKGxvID4+PiAyNikpIHwgMDtcblxuICAgICAgICBobmNhcnJ5ICs9IG5jYXJyeSA+Pj4gMjY7XG4gICAgICAgIG5jYXJyeSAmPSAweDNmZmZmZmY7XG4gICAgICB9XG4gICAgICBvdXQud29yZHNba10gPSByd29yZDtcbiAgICAgIGNhcnJ5ID0gbmNhcnJ5O1xuICAgICAgbmNhcnJ5ID0gaG5jYXJyeTtcbiAgICB9XG4gICAgaWYgKGNhcnJ5ICE9PSAwKSB7XG4gICAgICBvdXQud29yZHNba10gPSBjYXJyeTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0Lmxlbmd0aC0tO1xuICAgIH1cblxuICAgIHJldHVybiBvdXQuc3RyaXAoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGp1bWJvTXVsVG8gKHNlbGYsIG51bSwgb3V0KSB7XG4gICAgdmFyIGZmdG0gPSBuZXcgRkZUTSgpO1xuICAgIHJldHVybiBmZnRtLm11bHAoc2VsZiwgbnVtLCBvdXQpO1xuICB9XG5cbiAgQk4ucHJvdG90eXBlLm11bFRvID0gZnVuY3Rpb24gbXVsVG8gKG51bSwgb3V0KSB7XG4gICAgdmFyIHJlcztcbiAgICB2YXIgbGVuID0gdGhpcy5sZW5ndGggKyBudW0ubGVuZ3RoO1xuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMTAgJiYgbnVtLmxlbmd0aCA9PT0gMTApIHtcbiAgICAgIHJlcyA9IGNvbWIxME11bFRvKHRoaXMsIG51bSwgb3V0KTtcbiAgICB9IGVsc2UgaWYgKGxlbiA8IDYzKSB7XG4gICAgICByZXMgPSBzbWFsbE11bFRvKHRoaXMsIG51bSwgb3V0KTtcbiAgICB9IGVsc2UgaWYgKGxlbiA8IDEwMjQpIHtcbiAgICAgIHJlcyA9IGJpZ011bFRvKHRoaXMsIG51bSwgb3V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzID0ganVtYm9NdWxUbyh0aGlzLCBudW0sIG91dCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlcztcbiAgfTtcblxuICAvLyBDb29sZXktVHVrZXkgYWxnb3JpdGhtIGZvciBGRlRcbiAgLy8gc2xpZ2h0bHkgcmV2aXNpdGVkIHRvIHJlbHkgb24gbG9vcGluZyBpbnN0ZWFkIG9mIHJlY3Vyc2lvblxuXG4gIGZ1bmN0aW9uIEZGVE0gKHgsIHkpIHtcbiAgICB0aGlzLnggPSB4O1xuICAgIHRoaXMueSA9IHk7XG4gIH1cblxuICBGRlRNLnByb3RvdHlwZS5tYWtlUkJUID0gZnVuY3Rpb24gbWFrZVJCVCAoTikge1xuICAgIHZhciB0ID0gbmV3IEFycmF5KE4pO1xuICAgIHZhciBsID0gQk4ucHJvdG90eXBlLl9jb3VudEJpdHMoTikgLSAxO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTjsgaSsrKSB7XG4gICAgICB0W2ldID0gdGhpcy5yZXZCaW4oaSwgbCwgTik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHQ7XG4gIH07XG5cbiAgLy8gUmV0dXJucyBiaW5hcnktcmV2ZXJzZWQgcmVwcmVzZW50YXRpb24gb2YgYHhgXG4gIEZGVE0ucHJvdG90eXBlLnJldkJpbiA9IGZ1bmN0aW9uIHJldkJpbiAoeCwgbCwgTikge1xuICAgIGlmICh4ID09PSAwIHx8IHggPT09IE4gLSAxKSByZXR1cm4geDtcblxuICAgIHZhciByYiA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgIHJiIHw9ICh4ICYgMSkgPDwgKGwgLSBpIC0gMSk7XG4gICAgICB4ID4+PSAxO1xuICAgIH1cblxuICAgIHJldHVybiByYjtcbiAgfTtcblxuICAvLyBQZXJmb3JtcyBcInR3ZWVkbGluZ1wiIHBoYXNlLCB0aGVyZWZvcmUgJ2VtdWxhdGluZydcbiAgLy8gYmVoYXZpb3VyIG9mIHRoZSByZWN1cnNpdmUgYWxnb3JpdGhtXG4gIEZGVE0ucHJvdG90eXBlLnBlcm11dGUgPSBmdW5jdGlvbiBwZXJtdXRlIChyYnQsIHJ3cywgaXdzLCBydHdzLCBpdHdzLCBOKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBOOyBpKyspIHtcbiAgICAgIHJ0d3NbaV0gPSByd3NbcmJ0W2ldXTtcbiAgICAgIGl0d3NbaV0gPSBpd3NbcmJ0W2ldXTtcbiAgICB9XG4gIH07XG5cbiAgRkZUTS5wcm90b3R5cGUudHJhbnNmb3JtID0gZnVuY3Rpb24gdHJhbnNmb3JtIChyd3MsIGl3cywgcnR3cywgaXR3cywgTiwgcmJ0KSB7XG4gICAgdGhpcy5wZXJtdXRlKHJidCwgcndzLCBpd3MsIHJ0d3MsIGl0d3MsIE4pO1xuXG4gICAgZm9yICh2YXIgcyA9IDE7IHMgPCBOOyBzIDw8PSAxKSB7XG4gICAgICB2YXIgbCA9IHMgPDwgMTtcblxuICAgICAgdmFyIHJ0d2RmID0gTWF0aC5jb3MoMiAqIE1hdGguUEkgLyBsKTtcbiAgICAgIHZhciBpdHdkZiA9IE1hdGguc2luKDIgKiBNYXRoLlBJIC8gbCk7XG5cbiAgICAgIGZvciAodmFyIHAgPSAwOyBwIDwgTjsgcCArPSBsKSB7XG4gICAgICAgIHZhciBydHdkZl8gPSBydHdkZjtcbiAgICAgICAgdmFyIGl0d2RmXyA9IGl0d2RmO1xuXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgczsgaisrKSB7XG4gICAgICAgICAgdmFyIHJlID0gcnR3c1twICsgal07XG4gICAgICAgICAgdmFyIGllID0gaXR3c1twICsgal07XG5cbiAgICAgICAgICB2YXIgcm8gPSBydHdzW3AgKyBqICsgc107XG4gICAgICAgICAgdmFyIGlvID0gaXR3c1twICsgaiArIHNdO1xuXG4gICAgICAgICAgdmFyIHJ4ID0gcnR3ZGZfICogcm8gLSBpdHdkZl8gKiBpbztcblxuICAgICAgICAgIGlvID0gcnR3ZGZfICogaW8gKyBpdHdkZl8gKiBybztcbiAgICAgICAgICBybyA9IHJ4O1xuXG4gICAgICAgICAgcnR3c1twICsgal0gPSByZSArIHJvO1xuICAgICAgICAgIGl0d3NbcCArIGpdID0gaWUgKyBpbztcblxuICAgICAgICAgIHJ0d3NbcCArIGogKyBzXSA9IHJlIC0gcm87XG4gICAgICAgICAgaXR3c1twICsgaiArIHNdID0gaWUgLSBpbztcblxuICAgICAgICAgIC8qIGpzaGludCBtYXhkZXB0aCA6IGZhbHNlICovXG4gICAgICAgICAgaWYgKGogIT09IGwpIHtcbiAgICAgICAgICAgIHJ4ID0gcnR3ZGYgKiBydHdkZl8gLSBpdHdkZiAqIGl0d2RmXztcblxuICAgICAgICAgICAgaXR3ZGZfID0gcnR3ZGYgKiBpdHdkZl8gKyBpdHdkZiAqIHJ0d2RmXztcbiAgICAgICAgICAgIHJ0d2RmXyA9IHJ4O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBGRlRNLnByb3RvdHlwZS5ndWVzc0xlbjEzYiA9IGZ1bmN0aW9uIGd1ZXNzTGVuMTNiIChuLCBtKSB7XG4gICAgdmFyIE4gPSBNYXRoLm1heChtLCBuKSB8IDE7XG4gICAgdmFyIG9kZCA9IE4gJiAxO1xuICAgIHZhciBpID0gMDtcbiAgICBmb3IgKE4gPSBOIC8gMiB8IDA7IE47IE4gPSBOID4+PiAxKSB7XG4gICAgICBpKys7XG4gICAgfVxuXG4gICAgcmV0dXJuIDEgPDwgaSArIDEgKyBvZGQ7XG4gIH07XG5cbiAgRkZUTS5wcm90b3R5cGUuY29uanVnYXRlID0gZnVuY3Rpb24gY29uanVnYXRlIChyd3MsIGl3cywgTikge1xuICAgIGlmIChOIDw9IDEpIHJldHVybjtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTiAvIDI7IGkrKykge1xuICAgICAgdmFyIHQgPSByd3NbaV07XG5cbiAgICAgIHJ3c1tpXSA9IHJ3c1tOIC0gaSAtIDFdO1xuICAgICAgcndzW04gLSBpIC0gMV0gPSB0O1xuXG4gICAgICB0ID0gaXdzW2ldO1xuXG4gICAgICBpd3NbaV0gPSAtaXdzW04gLSBpIC0gMV07XG4gICAgICBpd3NbTiAtIGkgLSAxXSA9IC10O1xuICAgIH1cbiAgfTtcblxuICBGRlRNLnByb3RvdHlwZS5ub3JtYWxpemUxM2IgPSBmdW5jdGlvbiBub3JtYWxpemUxM2IgKHdzLCBOKSB7XG4gICAgdmFyIGNhcnJ5ID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IE4gLyAyOyBpKyspIHtcbiAgICAgIHZhciB3ID0gTWF0aC5yb3VuZCh3c1syICogaSArIDFdIC8gTikgKiAweDIwMDAgK1xuICAgICAgICBNYXRoLnJvdW5kKHdzWzIgKiBpXSAvIE4pICtcbiAgICAgICAgY2Fycnk7XG5cbiAgICAgIHdzW2ldID0gdyAmIDB4M2ZmZmZmZjtcblxuICAgICAgaWYgKHcgPCAweDQwMDAwMDApIHtcbiAgICAgICAgY2FycnkgPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FycnkgPSB3IC8gMHg0MDAwMDAwIHwgMDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gd3M7XG4gIH07XG5cbiAgRkZUTS5wcm90b3R5cGUuY29udmVydDEzYiA9IGZ1bmN0aW9uIGNvbnZlcnQxM2IgKHdzLCBsZW4sIHJ3cywgTikge1xuICAgIHZhciBjYXJyeSA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgY2FycnkgPSBjYXJyeSArICh3c1tpXSB8IDApO1xuXG4gICAgICByd3NbMiAqIGldID0gY2FycnkgJiAweDFmZmY7IGNhcnJ5ID0gY2FycnkgPj4+IDEzO1xuICAgICAgcndzWzIgKiBpICsgMV0gPSBjYXJyeSAmIDB4MWZmZjsgY2FycnkgPSBjYXJyeSA+Pj4gMTM7XG4gICAgfVxuXG4gICAgLy8gUGFkIHdpdGggemVyb2VzXG4gICAgZm9yIChpID0gMiAqIGxlbjsgaSA8IE47ICsraSkge1xuICAgICAgcndzW2ldID0gMDtcbiAgICB9XG5cbiAgICBhc3NlcnQoY2FycnkgPT09IDApO1xuICAgIGFzc2VydCgoY2FycnkgJiB+MHgxZmZmKSA9PT0gMCk7XG4gIH07XG5cbiAgRkZUTS5wcm90b3R5cGUuc3R1YiA9IGZ1bmN0aW9uIHN0dWIgKE4pIHtcbiAgICB2YXIgcGggPSBuZXcgQXJyYXkoTik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBOOyBpKyspIHtcbiAgICAgIHBoW2ldID0gMDtcbiAgICB9XG5cbiAgICByZXR1cm4gcGg7XG4gIH07XG5cbiAgRkZUTS5wcm90b3R5cGUubXVscCA9IGZ1bmN0aW9uIG11bHAgKHgsIHksIG91dCkge1xuICAgIHZhciBOID0gMiAqIHRoaXMuZ3Vlc3NMZW4xM2IoeC5sZW5ndGgsIHkubGVuZ3RoKTtcblxuICAgIHZhciByYnQgPSB0aGlzLm1ha2VSQlQoTik7XG5cbiAgICB2YXIgXyA9IHRoaXMuc3R1YihOKTtcblxuICAgIHZhciByd3MgPSBuZXcgQXJyYXkoTik7XG4gICAgdmFyIHJ3c3QgPSBuZXcgQXJyYXkoTik7XG4gICAgdmFyIGl3c3QgPSBuZXcgQXJyYXkoTik7XG5cbiAgICB2YXIgbnJ3cyA9IG5ldyBBcnJheShOKTtcbiAgICB2YXIgbnJ3c3QgPSBuZXcgQXJyYXkoTik7XG4gICAgdmFyIG5pd3N0ID0gbmV3IEFycmF5KE4pO1xuXG4gICAgdmFyIHJtd3MgPSBvdXQud29yZHM7XG4gICAgcm13cy5sZW5ndGggPSBOO1xuXG4gICAgdGhpcy5jb252ZXJ0MTNiKHgud29yZHMsIHgubGVuZ3RoLCByd3MsIE4pO1xuICAgIHRoaXMuY29udmVydDEzYih5LndvcmRzLCB5Lmxlbmd0aCwgbnJ3cywgTik7XG5cbiAgICB0aGlzLnRyYW5zZm9ybShyd3MsIF8sIHJ3c3QsIGl3c3QsIE4sIHJidCk7XG4gICAgdGhpcy50cmFuc2Zvcm0obnJ3cywgXywgbnJ3c3QsIG5pd3N0LCBOLCByYnQpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBOOyBpKyspIHtcbiAgICAgIHZhciByeCA9IHJ3c3RbaV0gKiBucndzdFtpXSAtIGl3c3RbaV0gKiBuaXdzdFtpXTtcbiAgICAgIGl3c3RbaV0gPSByd3N0W2ldICogbml3c3RbaV0gKyBpd3N0W2ldICogbnJ3c3RbaV07XG4gICAgICByd3N0W2ldID0gcng7XG4gICAgfVxuXG4gICAgdGhpcy5jb25qdWdhdGUocndzdCwgaXdzdCwgTik7XG4gICAgdGhpcy50cmFuc2Zvcm0ocndzdCwgaXdzdCwgcm13cywgXywgTiwgcmJ0KTtcbiAgICB0aGlzLmNvbmp1Z2F0ZShybXdzLCBfLCBOKTtcbiAgICB0aGlzLm5vcm1hbGl6ZTEzYihybXdzLCBOKTtcblxuICAgIG91dC5uZWdhdGl2ZSA9IHgubmVnYXRpdmUgXiB5Lm5lZ2F0aXZlO1xuICAgIG91dC5sZW5ndGggPSB4Lmxlbmd0aCArIHkubGVuZ3RoO1xuICAgIHJldHVybiBvdXQuc3RyaXAoKTtcbiAgfTtcblxuICAvLyBNdWx0aXBseSBgdGhpc2AgYnkgYG51bWBcbiAgQk4ucHJvdG90eXBlLm11bCA9IGZ1bmN0aW9uIG11bCAobnVtKSB7XG4gICAgdmFyIG91dCA9IG5ldyBCTihudWxsKTtcbiAgICBvdXQud29yZHMgPSBuZXcgQXJyYXkodGhpcy5sZW5ndGggKyBudW0ubGVuZ3RoKTtcbiAgICByZXR1cm4gdGhpcy5tdWxUbyhudW0sIG91dCk7XG4gIH07XG5cbiAgLy8gTXVsdGlwbHkgZW1wbG95aW5nIEZGVFxuICBCTi5wcm90b3R5cGUubXVsZiA9IGZ1bmN0aW9uIG11bGYgKG51bSkge1xuICAgIHZhciBvdXQgPSBuZXcgQk4obnVsbCk7XG4gICAgb3V0LndvcmRzID0gbmV3IEFycmF5KHRoaXMubGVuZ3RoICsgbnVtLmxlbmd0aCk7XG4gICAgcmV0dXJuIGp1bWJvTXVsVG8odGhpcywgbnVtLCBvdXQpO1xuICB9O1xuXG4gIC8vIEluLXBsYWNlIE11bHRpcGxpY2F0aW9uXG4gIEJOLnByb3RvdHlwZS5pbXVsID0gZnVuY3Rpb24gaW11bCAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5tdWxUbyhudW0sIHRoaXMpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5pbXVsbiA9IGZ1bmN0aW9uIGltdWxuIChudW0pIHtcbiAgICBhc3NlcnQodHlwZW9mIG51bSA9PT0gJ251bWJlcicpO1xuICAgIGFzc2VydChudW0gPCAweDQwMDAwMDApO1xuXG4gICAgLy8gQ2FycnlcbiAgICB2YXIgY2FycnkgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHcgPSAodGhpcy53b3Jkc1tpXSB8IDApICogbnVtO1xuICAgICAgdmFyIGxvID0gKHcgJiAweDNmZmZmZmYpICsgKGNhcnJ5ICYgMHgzZmZmZmZmKTtcbiAgICAgIGNhcnJ5ID4+PSAyNjtcbiAgICAgIGNhcnJ5ICs9ICh3IC8gMHg0MDAwMDAwKSB8IDA7XG4gICAgICAvLyBOT1RFOiBsbyBpcyAyN2JpdCBtYXhpbXVtXG4gICAgICBjYXJyeSArPSBsbyA+Pj4gMjY7XG4gICAgICB0aGlzLndvcmRzW2ldID0gbG8gJiAweDNmZmZmZmY7XG4gICAgfVxuXG4gICAgaWYgKGNhcnJ5ICE9PSAwKSB7XG4gICAgICB0aGlzLndvcmRzW2ldID0gY2Fycnk7XG4gICAgICB0aGlzLmxlbmd0aCsrO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5tdWxuID0gZnVuY3Rpb24gbXVsbiAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pbXVsbihudW0pO1xuICB9O1xuXG4gIC8vIGB0aGlzYCAqIGB0aGlzYFxuICBCTi5wcm90b3R5cGUuc3FyID0gZnVuY3Rpb24gc3FyICgpIHtcbiAgICByZXR1cm4gdGhpcy5tdWwodGhpcyk7XG4gIH07XG5cbiAgLy8gYHRoaXNgICogYHRoaXNgIGluLXBsYWNlXG4gIEJOLnByb3RvdHlwZS5pc3FyID0gZnVuY3Rpb24gaXNxciAoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW11bCh0aGlzLmNsb25lKCkpO1xuICB9O1xuXG4gIC8vIE1hdGgucG93KGB0aGlzYCwgYG51bWApXG4gIEJOLnByb3RvdHlwZS5wb3cgPSBmdW5jdGlvbiBwb3cgKG51bSkge1xuICAgIHZhciB3ID0gdG9CaXRBcnJheShudW0pO1xuICAgIGlmICh3Lmxlbmd0aCA9PT0gMCkgcmV0dXJuIG5ldyBCTigxKTtcblxuICAgIC8vIFNraXAgbGVhZGluZyB6ZXJvZXNcbiAgICB2YXIgcmVzID0gdGhpcztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHcubGVuZ3RoOyBpKyssIHJlcyA9IHJlcy5zcXIoKSkge1xuICAgICAgaWYgKHdbaV0gIT09IDApIGJyZWFrO1xuICAgIH1cblxuICAgIGlmICgrK2kgPCB3Lmxlbmd0aCkge1xuICAgICAgZm9yICh2YXIgcSA9IHJlcy5zcXIoKTsgaSA8IHcubGVuZ3RoOyBpKyssIHEgPSBxLnNxcigpKSB7XG4gICAgICAgIGlmICh3W2ldID09PSAwKSBjb250aW51ZTtcblxuICAgICAgICByZXMgPSByZXMubXVsKHEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXM7XG4gIH07XG5cbiAgLy8gU2hpZnQtbGVmdCBpbi1wbGFjZVxuICBCTi5wcm90b3R5cGUuaXVzaGxuID0gZnVuY3Rpb24gaXVzaGxuIChiaXRzKSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBiaXRzID09PSAnbnVtYmVyJyAmJiBiaXRzID49IDApO1xuICAgIHZhciByID0gYml0cyAlIDI2O1xuICAgIHZhciBzID0gKGJpdHMgLSByKSAvIDI2O1xuICAgIHZhciBjYXJyeU1hc2sgPSAoMHgzZmZmZmZmID4+PiAoMjYgLSByKSkgPDwgKDI2IC0gcik7XG4gICAgdmFyIGk7XG5cbiAgICBpZiAociAhPT0gMCkge1xuICAgICAgdmFyIGNhcnJ5ID0gMDtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG5ld0NhcnJ5ID0gdGhpcy53b3Jkc1tpXSAmIGNhcnJ5TWFzaztcbiAgICAgICAgdmFyIGMgPSAoKHRoaXMud29yZHNbaV0gfCAwKSAtIG5ld0NhcnJ5KSA8PCByO1xuICAgICAgICB0aGlzLndvcmRzW2ldID0gYyB8IGNhcnJ5O1xuICAgICAgICBjYXJyeSA9IG5ld0NhcnJ5ID4+PiAoMjYgLSByKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNhcnJ5KSB7XG4gICAgICAgIHRoaXMud29yZHNbaV0gPSBjYXJyeTtcbiAgICAgICAgdGhpcy5sZW5ndGgrKztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocyAhPT0gMCkge1xuICAgICAgZm9yIChpID0gdGhpcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICB0aGlzLndvcmRzW2kgKyBzXSA9IHRoaXMud29yZHNbaV07XG4gICAgICB9XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBzOyBpKyspIHtcbiAgICAgICAgdGhpcy53b3Jkc1tpXSA9IDA7XG4gICAgICB9XG5cbiAgICAgIHRoaXMubGVuZ3RoICs9IHM7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc3RyaXAoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuaXNobG4gPSBmdW5jdGlvbiBpc2hsbiAoYml0cykge1xuICAgIC8vIFRPRE8oaW5kdXRueSk6IGltcGxlbWVudCBtZVxuICAgIGFzc2VydCh0aGlzLm5lZ2F0aXZlID09PSAwKTtcbiAgICByZXR1cm4gdGhpcy5pdXNobG4oYml0cyk7XG4gIH07XG5cbiAgLy8gU2hpZnQtcmlnaHQgaW4tcGxhY2VcbiAgLy8gTk9URTogYGhpbnRgIGlzIGEgbG93ZXN0IGJpdCBiZWZvcmUgdHJhaWxpbmcgemVyb2VzXG4gIC8vIE5PVEU6IGlmIGBleHRlbmRlZGAgaXMgcHJlc2VudCAtIGl0IHdpbGwgYmUgZmlsbGVkIHdpdGggZGVzdHJveWVkIGJpdHNcbiAgQk4ucHJvdG90eXBlLml1c2hybiA9IGZ1bmN0aW9uIGl1c2hybiAoYml0cywgaGludCwgZXh0ZW5kZWQpIHtcbiAgICBhc3NlcnQodHlwZW9mIGJpdHMgPT09ICdudW1iZXInICYmIGJpdHMgPj0gMCk7XG4gICAgdmFyIGg7XG4gICAgaWYgKGhpbnQpIHtcbiAgICAgIGggPSAoaGludCAtIChoaW50ICUgMjYpKSAvIDI2O1xuICAgIH0gZWxzZSB7XG4gICAgICBoID0gMDtcbiAgICB9XG5cbiAgICB2YXIgciA9IGJpdHMgJSAyNjtcbiAgICB2YXIgcyA9IE1hdGgubWluKChiaXRzIC0gcikgLyAyNiwgdGhpcy5sZW5ndGgpO1xuICAgIHZhciBtYXNrID0gMHgzZmZmZmZmIF4gKCgweDNmZmZmZmYgPj4+IHIpIDw8IHIpO1xuICAgIHZhciBtYXNrZWRXb3JkcyA9IGV4dGVuZGVkO1xuXG4gICAgaCAtPSBzO1xuICAgIGggPSBNYXRoLm1heCgwLCBoKTtcblxuICAgIC8vIEV4dGVuZGVkIG1vZGUsIGNvcHkgbWFza2VkIHBhcnRcbiAgICBpZiAobWFza2VkV29yZHMpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgczsgaSsrKSB7XG4gICAgICAgIG1hc2tlZFdvcmRzLndvcmRzW2ldID0gdGhpcy53b3Jkc1tpXTtcbiAgICAgIH1cbiAgICAgIG1hc2tlZFdvcmRzLmxlbmd0aCA9IHM7XG4gICAgfVxuXG4gICAgaWYgKHMgPT09IDApIHtcbiAgICAgIC8vIE5vLW9wLCB3ZSBzaG91bGQgbm90IG1vdmUgYW55dGhpbmcgYXQgYWxsXG4gICAgfSBlbHNlIGlmICh0aGlzLmxlbmd0aCA+IHMpIHtcbiAgICAgIHRoaXMubGVuZ3RoIC09IHM7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLndvcmRzW2ldID0gdGhpcy53b3Jkc1tpICsgc107XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMud29yZHNbMF0gPSAwO1xuICAgICAgdGhpcy5sZW5ndGggPSAxO1xuICAgIH1cblxuICAgIHZhciBjYXJyeSA9IDA7XG4gICAgZm9yIChpID0gdGhpcy5sZW5ndGggLSAxOyBpID49IDAgJiYgKGNhcnJ5ICE9PSAwIHx8IGkgPj0gaCk7IGktLSkge1xuICAgICAgdmFyIHdvcmQgPSB0aGlzLndvcmRzW2ldIHwgMDtcbiAgICAgIHRoaXMud29yZHNbaV0gPSAoY2FycnkgPDwgKDI2IC0gcikpIHwgKHdvcmQgPj4+IHIpO1xuICAgICAgY2FycnkgPSB3b3JkICYgbWFzaztcbiAgICB9XG5cbiAgICAvLyBQdXNoIGNhcnJpZWQgYml0cyBhcyBhIG1hc2tcbiAgICBpZiAobWFza2VkV29yZHMgJiYgY2FycnkgIT09IDApIHtcbiAgICAgIG1hc2tlZFdvcmRzLndvcmRzW21hc2tlZFdvcmRzLmxlbmd0aCsrXSA9IGNhcnJ5O1xuICAgIH1cblxuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhpcy53b3Jkc1swXSA9IDA7XG4gICAgICB0aGlzLmxlbmd0aCA9IDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc3RyaXAoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuaXNocm4gPSBmdW5jdGlvbiBpc2hybiAoYml0cywgaGludCwgZXh0ZW5kZWQpIHtcbiAgICAvLyBUT0RPKGluZHV0bnkpOiBpbXBsZW1lbnQgbWVcbiAgICBhc3NlcnQodGhpcy5uZWdhdGl2ZSA9PT0gMCk7XG4gICAgcmV0dXJuIHRoaXMuaXVzaHJuKGJpdHMsIGhpbnQsIGV4dGVuZGVkKTtcbiAgfTtcblxuICAvLyBTaGlmdC1sZWZ0XG4gIEJOLnByb3RvdHlwZS5zaGxuID0gZnVuY3Rpb24gc2hsbiAoYml0cykge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkuaXNobG4oYml0cyk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnVzaGxuID0gZnVuY3Rpb24gdXNobG4gKGJpdHMpIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLml1c2hsbihiaXRzKTtcbiAgfTtcblxuICAvLyBTaGlmdC1yaWdodFxuICBCTi5wcm90b3R5cGUuc2hybiA9IGZ1bmN0aW9uIHNocm4gKGJpdHMpIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmlzaHJuKGJpdHMpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS51c2hybiA9IGZ1bmN0aW9uIHVzaHJuIChiaXRzKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pdXNocm4oYml0cyk7XG4gIH07XG5cbiAgLy8gVGVzdCBpZiBuIGJpdCBpcyBzZXRcbiAgQk4ucHJvdG90eXBlLnRlc3RuID0gZnVuY3Rpb24gdGVzdG4gKGJpdCkge1xuICAgIGFzc2VydCh0eXBlb2YgYml0ID09PSAnbnVtYmVyJyAmJiBiaXQgPj0gMCk7XG4gICAgdmFyIHIgPSBiaXQgJSAyNjtcbiAgICB2YXIgcyA9IChiaXQgLSByKSAvIDI2O1xuICAgIHZhciBxID0gMSA8PCByO1xuXG4gICAgLy8gRmFzdCBjYXNlOiBiaXQgaXMgbXVjaCBoaWdoZXIgdGhhbiBhbGwgZXhpc3Rpbmcgd29yZHNcbiAgICBpZiAodGhpcy5sZW5ndGggPD0gcykgcmV0dXJuIGZhbHNlO1xuXG4gICAgLy8gQ2hlY2sgYml0IGFuZCByZXR1cm5cbiAgICB2YXIgdyA9IHRoaXMud29yZHNbc107XG5cbiAgICByZXR1cm4gISEodyAmIHEpO1xuICB9O1xuXG4gIC8vIFJldHVybiBvbmx5IGxvd2VycyBiaXRzIG9mIG51bWJlciAoaW4tcGxhY2UpXG4gIEJOLnByb3RvdHlwZS5pbWFza24gPSBmdW5jdGlvbiBpbWFza24gKGJpdHMpIHtcbiAgICBhc3NlcnQodHlwZW9mIGJpdHMgPT09ICdudW1iZXInICYmIGJpdHMgPj0gMCk7XG4gICAgdmFyIHIgPSBiaXRzICUgMjY7XG4gICAgdmFyIHMgPSAoYml0cyAtIHIpIC8gMjY7XG5cbiAgICBhc3NlcnQodGhpcy5uZWdhdGl2ZSA9PT0gMCwgJ2ltYXNrbiB3b3JrcyBvbmx5IHdpdGggcG9zaXRpdmUgbnVtYmVycycpO1xuXG4gICAgaWYgKHRoaXMubGVuZ3RoIDw9IHMpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGlmIChyICE9PSAwKSB7XG4gICAgICBzKys7XG4gICAgfVxuICAgIHRoaXMubGVuZ3RoID0gTWF0aC5taW4ocywgdGhpcy5sZW5ndGgpO1xuXG4gICAgaWYgKHIgIT09IDApIHtcbiAgICAgIHZhciBtYXNrID0gMHgzZmZmZmZmIF4gKCgweDNmZmZmZmYgPj4+IHIpIDw8IHIpO1xuICAgICAgdGhpcy53b3Jkc1t0aGlzLmxlbmd0aCAtIDFdICY9IG1hc2s7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc3RyaXAoKTtcbiAgfTtcblxuICAvLyBSZXR1cm4gb25seSBsb3dlcnMgYml0cyBvZiBudW1iZXJcbiAgQk4ucHJvdG90eXBlLm1hc2tuID0gZnVuY3Rpb24gbWFza24gKGJpdHMpIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmltYXNrbihiaXRzKTtcbiAgfTtcblxuICAvLyBBZGQgcGxhaW4gbnVtYmVyIGBudW1gIHRvIGB0aGlzYFxuICBCTi5wcm90b3R5cGUuaWFkZG4gPSBmdW5jdGlvbiBpYWRkbiAobnVtKSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBudW0gPT09ICdudW1iZXInKTtcbiAgICBhc3NlcnQobnVtIDwgMHg0MDAwMDAwKTtcbiAgICBpZiAobnVtIDwgMCkgcmV0dXJuIHRoaXMuaXN1Ym4oLW51bSk7XG5cbiAgICAvLyBQb3NzaWJsZSBzaWduIGNoYW5nZVxuICAgIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICBpZiAodGhpcy5sZW5ndGggPT09IDEgJiYgKHRoaXMud29yZHNbMF0gfCAwKSA8IG51bSkge1xuICAgICAgICB0aGlzLndvcmRzWzBdID0gbnVtIC0gKHRoaXMud29yZHNbMF0gfCAwKTtcbiAgICAgICAgdGhpcy5uZWdhdGl2ZSA9IDA7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMDtcbiAgICAgIHRoaXMuaXN1Ym4obnVtKTtcbiAgICAgIHRoaXMubmVnYXRpdmUgPSAxO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gQWRkIHdpdGhvdXQgY2hlY2tzXG4gICAgcmV0dXJuIHRoaXMuX2lhZGRuKG51bSk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLl9pYWRkbiA9IGZ1bmN0aW9uIF9pYWRkbiAobnVtKSB7XG4gICAgdGhpcy53b3Jkc1swXSArPSBudW07XG5cbiAgICAvLyBDYXJyeVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGggJiYgdGhpcy53b3Jkc1tpXSA+PSAweDQwMDAwMDA7IGkrKykge1xuICAgICAgdGhpcy53b3Jkc1tpXSAtPSAweDQwMDAwMDA7XG4gICAgICBpZiAoaSA9PT0gdGhpcy5sZW5ndGggLSAxKSB7XG4gICAgICAgIHRoaXMud29yZHNbaSArIDFdID0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMud29yZHNbaSArIDFdKys7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMubGVuZ3RoID0gTWF0aC5tYXgodGhpcy5sZW5ndGgsIGkgKyAxKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8vIFN1YnRyYWN0IHBsYWluIG51bWJlciBgbnVtYCBmcm9tIGB0aGlzYFxuICBCTi5wcm90b3R5cGUuaXN1Ym4gPSBmdW5jdGlvbiBpc3VibiAobnVtKSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBudW0gPT09ICdudW1iZXInKTtcbiAgICBhc3NlcnQobnVtIDwgMHg0MDAwMDAwKTtcbiAgICBpZiAobnVtIDwgMCkgcmV0dXJuIHRoaXMuaWFkZG4oLW51bSk7XG5cbiAgICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDA7XG4gICAgICB0aGlzLmlhZGRuKG51bSk7XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHRoaXMud29yZHNbMF0gLT0gbnVtO1xuXG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAxICYmIHRoaXMud29yZHNbMF0gPCAwKSB7XG4gICAgICB0aGlzLndvcmRzWzBdID0gLXRoaXMud29yZHNbMF07XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQ2FycnlcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGggJiYgdGhpcy53b3Jkc1tpXSA8IDA7IGkrKykge1xuICAgICAgICB0aGlzLndvcmRzW2ldICs9IDB4NDAwMDAwMDtcbiAgICAgICAgdGhpcy53b3Jkc1tpICsgMV0gLT0gMTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zdHJpcCgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5hZGRuID0gZnVuY3Rpb24gYWRkbiAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pYWRkbihudW0pO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5zdWJuID0gZnVuY3Rpb24gc3VibiAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pc3VibihudW0pO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5pYWJzID0gZnVuY3Rpb24gaWFicyAoKSB7XG4gICAgdGhpcy5uZWdhdGl2ZSA9IDA7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuYWJzID0gZnVuY3Rpb24gYWJzICgpIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmlhYnMoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuX2lzaGxuc3VibXVsID0gZnVuY3Rpb24gX2lzaGxuc3VibXVsIChudW0sIG11bCwgc2hpZnQpIHtcbiAgICB2YXIgbGVuID0gbnVtLmxlbmd0aCArIHNoaWZ0O1xuICAgIHZhciBpO1xuXG4gICAgdGhpcy5fZXhwYW5kKGxlbik7XG5cbiAgICB2YXIgdztcbiAgICB2YXIgY2FycnkgPSAwO1xuICAgIGZvciAoaSA9IDA7IGkgPCBudW0ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHcgPSAodGhpcy53b3Jkc1tpICsgc2hpZnRdIHwgMCkgKyBjYXJyeTtcbiAgICAgIHZhciByaWdodCA9IChudW0ud29yZHNbaV0gfCAwKSAqIG11bDtcbiAgICAgIHcgLT0gcmlnaHQgJiAweDNmZmZmZmY7XG4gICAgICBjYXJyeSA9ICh3ID4+IDI2KSAtICgocmlnaHQgLyAweDQwMDAwMDApIHwgMCk7XG4gICAgICB0aGlzLndvcmRzW2kgKyBzaGlmdF0gPSB3ICYgMHgzZmZmZmZmO1xuICAgIH1cbiAgICBmb3IgKDsgaSA8IHRoaXMubGVuZ3RoIC0gc2hpZnQ7IGkrKykge1xuICAgICAgdyA9ICh0aGlzLndvcmRzW2kgKyBzaGlmdF0gfCAwKSArIGNhcnJ5O1xuICAgICAgY2FycnkgPSB3ID4+IDI2O1xuICAgICAgdGhpcy53b3Jkc1tpICsgc2hpZnRdID0gdyAmIDB4M2ZmZmZmZjtcbiAgICB9XG5cbiAgICBpZiAoY2FycnkgPT09IDApIHJldHVybiB0aGlzLnN0cmlwKCk7XG5cbiAgICAvLyBTdWJ0cmFjdGlvbiBvdmVyZmxvd1xuICAgIGFzc2VydChjYXJyeSA9PT0gLTEpO1xuICAgIGNhcnJ5ID0gMDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgdyA9IC0odGhpcy53b3Jkc1tpXSB8IDApICsgY2Fycnk7XG4gICAgICBjYXJyeSA9IHcgPj4gMjY7XG4gICAgICB0aGlzLndvcmRzW2ldID0gdyAmIDB4M2ZmZmZmZjtcbiAgICB9XG4gICAgdGhpcy5uZWdhdGl2ZSA9IDE7XG5cbiAgICByZXR1cm4gdGhpcy5zdHJpcCgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5fd29yZERpdiA9IGZ1bmN0aW9uIF93b3JkRGl2IChudW0sIG1vZGUpIHtcbiAgICB2YXIgc2hpZnQgPSB0aGlzLmxlbmd0aCAtIG51bS5sZW5ndGg7XG5cbiAgICB2YXIgYSA9IHRoaXMuY2xvbmUoKTtcbiAgICB2YXIgYiA9IG51bTtcblxuICAgIC8vIE5vcm1hbGl6ZVxuICAgIHZhciBiaGkgPSBiLndvcmRzW2IubGVuZ3RoIC0gMV0gfCAwO1xuICAgIHZhciBiaGlCaXRzID0gdGhpcy5fY291bnRCaXRzKGJoaSk7XG4gICAgc2hpZnQgPSAyNiAtIGJoaUJpdHM7XG4gICAgaWYgKHNoaWZ0ICE9PSAwKSB7XG4gICAgICBiID0gYi51c2hsbihzaGlmdCk7XG4gICAgICBhLml1c2hsbihzaGlmdCk7XG4gICAgICBiaGkgPSBiLndvcmRzW2IubGVuZ3RoIC0gMV0gfCAwO1xuICAgIH1cblxuICAgIC8vIEluaXRpYWxpemUgcXVvdGllbnRcbiAgICB2YXIgbSA9IGEubGVuZ3RoIC0gYi5sZW5ndGg7XG4gICAgdmFyIHE7XG5cbiAgICBpZiAobW9kZSAhPT0gJ21vZCcpIHtcbiAgICAgIHEgPSBuZXcgQk4obnVsbCk7XG4gICAgICBxLmxlbmd0aCA9IG0gKyAxO1xuICAgICAgcS53b3JkcyA9IG5ldyBBcnJheShxLmxlbmd0aCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcS53b3Jkc1tpXSA9IDA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGRpZmYgPSBhLmNsb25lKCkuX2lzaGxuc3VibXVsKGIsIDEsIG0pO1xuICAgIGlmIChkaWZmLm5lZ2F0aXZlID09PSAwKSB7XG4gICAgICBhID0gZGlmZjtcbiAgICAgIGlmIChxKSB7XG4gICAgICAgIHEud29yZHNbbV0gPSAxO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAodmFyIGogPSBtIC0gMTsgaiA+PSAwOyBqLS0pIHtcbiAgICAgIHZhciBxaiA9IChhLndvcmRzW2IubGVuZ3RoICsgal0gfCAwKSAqIDB4NDAwMDAwMCArXG4gICAgICAgIChhLndvcmRzW2IubGVuZ3RoICsgaiAtIDFdIHwgMCk7XG5cbiAgICAgIC8vIE5PVEU6IChxaiAvIGJoaSkgaXMgKDB4M2ZmZmZmZiAqIDB4NDAwMDAwMCArIDB4M2ZmZmZmZikgLyAweDIwMDAwMDAgbWF4XG4gICAgICAvLyAoMHg3ZmZmZmZmKVxuICAgICAgcWogPSBNYXRoLm1pbigocWogLyBiaGkpIHwgMCwgMHgzZmZmZmZmKTtcblxuICAgICAgYS5faXNobG5zdWJtdWwoYiwgcWosIGopO1xuICAgICAgd2hpbGUgKGEubmVnYXRpdmUgIT09IDApIHtcbiAgICAgICAgcWotLTtcbiAgICAgICAgYS5uZWdhdGl2ZSA9IDA7XG4gICAgICAgIGEuX2lzaGxuc3VibXVsKGIsIDEsIGopO1xuICAgICAgICBpZiAoIWEuaXNaZXJvKCkpIHtcbiAgICAgICAgICBhLm5lZ2F0aXZlIF49IDE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChxKSB7XG4gICAgICAgIHEud29yZHNbal0gPSBxajtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHEpIHtcbiAgICAgIHEuc3RyaXAoKTtcbiAgICB9XG4gICAgYS5zdHJpcCgpO1xuXG4gICAgLy8gRGVub3JtYWxpemVcbiAgICBpZiAobW9kZSAhPT0gJ2RpdicgJiYgc2hpZnQgIT09IDApIHtcbiAgICAgIGEuaXVzaHJuKHNoaWZ0KTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgZGl2OiBxIHx8IG51bGwsXG4gICAgICBtb2Q6IGFcbiAgICB9O1xuICB9O1xuXG4gIC8vIE5PVEU6IDEpIGBtb2RlYCBjYW4gYmUgc2V0IHRvIGBtb2RgIHRvIHJlcXVlc3QgbW9kIG9ubHksXG4gIC8vICAgICAgIHRvIGBkaXZgIHRvIHJlcXVlc3QgZGl2IG9ubHksIG9yIGJlIGFic2VudCB0b1xuICAvLyAgICAgICByZXF1ZXN0IGJvdGggZGl2ICYgbW9kXG4gIC8vICAgICAgIDIpIGBwb3NpdGl2ZWAgaXMgdHJ1ZSBpZiB1bnNpZ25lZCBtb2QgaXMgcmVxdWVzdGVkXG4gIEJOLnByb3RvdHlwZS5kaXZtb2QgPSBmdW5jdGlvbiBkaXZtb2QgKG51bSwgbW9kZSwgcG9zaXRpdmUpIHtcbiAgICBhc3NlcnQoIW51bS5pc1plcm8oKSk7XG5cbiAgICBpZiAodGhpcy5pc1plcm8oKSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGl2OiBuZXcgQk4oMCksXG4gICAgICAgIG1vZDogbmV3IEJOKDApXG4gICAgICB9O1xuICAgIH1cblxuICAgIHZhciBkaXYsIG1vZCwgcmVzO1xuICAgIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwICYmIG51bS5uZWdhdGl2ZSA9PT0gMCkge1xuICAgICAgcmVzID0gdGhpcy5uZWcoKS5kaXZtb2QobnVtLCBtb2RlKTtcblxuICAgICAgaWYgKG1vZGUgIT09ICdtb2QnKSB7XG4gICAgICAgIGRpdiA9IHJlcy5kaXYubmVnKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChtb2RlICE9PSAnZGl2Jykge1xuICAgICAgICBtb2QgPSByZXMubW9kLm5lZygpO1xuICAgICAgICBpZiAocG9zaXRpdmUgJiYgbW9kLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICAgICAgbW9kLmlhZGQobnVtKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBkaXY6IGRpdixcbiAgICAgICAgbW9kOiBtb2RcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKHRoaXMubmVnYXRpdmUgPT09IDAgJiYgbnVtLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICByZXMgPSB0aGlzLmRpdm1vZChudW0ubmVnKCksIG1vZGUpO1xuXG4gICAgICBpZiAobW9kZSAhPT0gJ21vZCcpIHtcbiAgICAgICAgZGl2ID0gcmVzLmRpdi5uZWcoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGl2OiBkaXYsXG4gICAgICAgIG1vZDogcmVzLm1vZFxuICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAoKHRoaXMubmVnYXRpdmUgJiBudW0ubmVnYXRpdmUpICE9PSAwKSB7XG4gICAgICByZXMgPSB0aGlzLm5lZygpLmRpdm1vZChudW0ubmVnKCksIG1vZGUpO1xuXG4gICAgICBpZiAobW9kZSAhPT0gJ2RpdicpIHtcbiAgICAgICAgbW9kID0gcmVzLm1vZC5uZWcoKTtcbiAgICAgICAgaWYgKHBvc2l0aXZlICYmIG1vZC5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgICAgIG1vZC5pc3ViKG51bSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGl2OiByZXMuZGl2LFxuICAgICAgICBtb2Q6IG1vZFxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBCb3RoIG51bWJlcnMgYXJlIHBvc2l0aXZlIGF0IHRoaXMgcG9pbnRcblxuICAgIC8vIFN0cmlwIGJvdGggbnVtYmVycyB0byBhcHByb3hpbWF0ZSBzaGlmdCB2YWx1ZVxuICAgIGlmIChudW0ubGVuZ3RoID4gdGhpcy5sZW5ndGggfHwgdGhpcy5jbXAobnVtKSA8IDApIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRpdjogbmV3IEJOKDApLFxuICAgICAgICBtb2Q6IHRoaXNcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gVmVyeSBzaG9ydCByZWR1Y3Rpb25cbiAgICBpZiAobnVtLmxlbmd0aCA9PT0gMSkge1xuICAgICAgaWYgKG1vZGUgPT09ICdkaXYnKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZGl2OiB0aGlzLmRpdm4obnVtLndvcmRzWzBdKSxcbiAgICAgICAgICBtb2Q6IG51bGxcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgaWYgKG1vZGUgPT09ICdtb2QnKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZGl2OiBudWxsLFxuICAgICAgICAgIG1vZDogbmV3IEJOKHRoaXMubW9kbihudW0ud29yZHNbMF0pKVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBkaXY6IHRoaXMuZGl2bihudW0ud29yZHNbMF0pLFxuICAgICAgICBtb2Q6IG5ldyBCTih0aGlzLm1vZG4obnVtLndvcmRzWzBdKSlcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3dvcmREaXYobnVtLCBtb2RlKTtcbiAgfTtcblxuICAvLyBGaW5kIGB0aGlzYCAvIGBudW1gXG4gIEJOLnByb3RvdHlwZS5kaXYgPSBmdW5jdGlvbiBkaXYgKG51bSkge1xuICAgIHJldHVybiB0aGlzLmRpdm1vZChudW0sICdkaXYnLCBmYWxzZSkuZGl2O1xuICB9O1xuXG4gIC8vIEZpbmQgYHRoaXNgICUgYG51bWBcbiAgQk4ucHJvdG90eXBlLm1vZCA9IGZ1bmN0aW9uIG1vZCAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuZGl2bW9kKG51bSwgJ21vZCcsIGZhbHNlKS5tb2Q7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnVtb2QgPSBmdW5jdGlvbiB1bW9kIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5kaXZtb2QobnVtLCAnbW9kJywgdHJ1ZSkubW9kO1xuICB9O1xuXG4gIC8vIEZpbmQgUm91bmQoYHRoaXNgIC8gYG51bWApXG4gIEJOLnByb3RvdHlwZS5kaXZSb3VuZCA9IGZ1bmN0aW9uIGRpdlJvdW5kIChudW0pIHtcbiAgICB2YXIgZG0gPSB0aGlzLmRpdm1vZChudW0pO1xuXG4gICAgLy8gRmFzdCBjYXNlIC0gZXhhY3QgZGl2aXNpb25cbiAgICBpZiAoZG0ubW9kLmlzWmVybygpKSByZXR1cm4gZG0uZGl2O1xuXG4gICAgdmFyIG1vZCA9IGRtLmRpdi5uZWdhdGl2ZSAhPT0gMCA/IGRtLm1vZC5pc3ViKG51bSkgOiBkbS5tb2Q7XG5cbiAgICB2YXIgaGFsZiA9IG51bS51c2hybigxKTtcbiAgICB2YXIgcjIgPSBudW0uYW5kbG4oMSk7XG4gICAgdmFyIGNtcCA9IG1vZC5jbXAoaGFsZik7XG5cbiAgICAvLyBSb3VuZCBkb3duXG4gICAgaWYgKGNtcCA8IDAgfHwgcjIgPT09IDEgJiYgY21wID09PSAwKSByZXR1cm4gZG0uZGl2O1xuXG4gICAgLy8gUm91bmQgdXBcbiAgICByZXR1cm4gZG0uZGl2Lm5lZ2F0aXZlICE9PSAwID8gZG0uZGl2LmlzdWJuKDEpIDogZG0uZGl2LmlhZGRuKDEpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5tb2RuID0gZnVuY3Rpb24gbW9kbiAobnVtKSB7XG4gICAgYXNzZXJ0KG51bSA8PSAweDNmZmZmZmYpO1xuICAgIHZhciBwID0gKDEgPDwgMjYpICUgbnVtO1xuXG4gICAgdmFyIGFjYyA9IDA7XG4gICAgZm9yICh2YXIgaSA9IHRoaXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGFjYyA9IChwICogYWNjICsgKHRoaXMud29yZHNbaV0gfCAwKSkgJSBudW07XG4gICAgfVxuXG4gICAgcmV0dXJuIGFjYztcbiAgfTtcblxuICAvLyBJbi1wbGFjZSBkaXZpc2lvbiBieSBudW1iZXJcbiAgQk4ucHJvdG90eXBlLmlkaXZuID0gZnVuY3Rpb24gaWRpdm4gKG51bSkge1xuICAgIGFzc2VydChudW0gPD0gMHgzZmZmZmZmKTtcblxuICAgIHZhciBjYXJyeSA9IDA7XG4gICAgZm9yICh2YXIgaSA9IHRoaXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciB3ID0gKHRoaXMud29yZHNbaV0gfCAwKSArIGNhcnJ5ICogMHg0MDAwMDAwO1xuICAgICAgdGhpcy53b3Jkc1tpXSA9ICh3IC8gbnVtKSB8IDA7XG4gICAgICBjYXJyeSA9IHcgJSBudW07XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc3RyaXAoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuZGl2biA9IGZ1bmN0aW9uIGRpdm4gKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkuaWRpdm4obnVtKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuZWdjZCA9IGZ1bmN0aW9uIGVnY2QgKHApIHtcbiAgICBhc3NlcnQocC5uZWdhdGl2ZSA9PT0gMCk7XG4gICAgYXNzZXJ0KCFwLmlzWmVybygpKTtcblxuICAgIHZhciB4ID0gdGhpcztcbiAgICB2YXIgeSA9IHAuY2xvbmUoKTtcblxuICAgIGlmICh4Lm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICB4ID0geC51bW9kKHApO1xuICAgIH0gZWxzZSB7XG4gICAgICB4ID0geC5jbG9uZSgpO1xuICAgIH1cblxuICAgIC8vIEEgKiB4ICsgQiAqIHkgPSB4XG4gICAgdmFyIEEgPSBuZXcgQk4oMSk7XG4gICAgdmFyIEIgPSBuZXcgQk4oMCk7XG5cbiAgICAvLyBDICogeCArIEQgKiB5ID0geVxuICAgIHZhciBDID0gbmV3IEJOKDApO1xuICAgIHZhciBEID0gbmV3IEJOKDEpO1xuXG4gICAgdmFyIGcgPSAwO1xuXG4gICAgd2hpbGUgKHguaXNFdmVuKCkgJiYgeS5pc0V2ZW4oKSkge1xuICAgICAgeC5pdXNocm4oMSk7XG4gICAgICB5Lml1c2hybigxKTtcbiAgICAgICsrZztcbiAgICB9XG5cbiAgICB2YXIgeXAgPSB5LmNsb25lKCk7XG4gICAgdmFyIHhwID0geC5jbG9uZSgpO1xuXG4gICAgd2hpbGUgKCF4LmlzWmVybygpKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgaW0gPSAxOyAoeC53b3Jkc1swXSAmIGltKSA9PT0gMCAmJiBpIDwgMjY7ICsraSwgaW0gPDw9IDEpO1xuICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgIHguaXVzaHJuKGkpO1xuICAgICAgICB3aGlsZSAoaS0tID4gMCkge1xuICAgICAgICAgIGlmIChBLmlzT2RkKCkgfHwgQi5pc09kZCgpKSB7XG4gICAgICAgICAgICBBLmlhZGQoeXApO1xuICAgICAgICAgICAgQi5pc3ViKHhwKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBBLml1c2hybigxKTtcbiAgICAgICAgICBCLml1c2hybigxKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBqID0gMCwgam0gPSAxOyAoeS53b3Jkc1swXSAmIGptKSA9PT0gMCAmJiBqIDwgMjY7ICsraiwgam0gPDw9IDEpO1xuICAgICAgaWYgKGogPiAwKSB7XG4gICAgICAgIHkuaXVzaHJuKGopO1xuICAgICAgICB3aGlsZSAoai0tID4gMCkge1xuICAgICAgICAgIGlmIChDLmlzT2RkKCkgfHwgRC5pc09kZCgpKSB7XG4gICAgICAgICAgICBDLmlhZGQoeXApO1xuICAgICAgICAgICAgRC5pc3ViKHhwKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBDLml1c2hybigxKTtcbiAgICAgICAgICBELml1c2hybigxKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoeC5jbXAoeSkgPj0gMCkge1xuICAgICAgICB4LmlzdWIoeSk7XG4gICAgICAgIEEuaXN1YihDKTtcbiAgICAgICAgQi5pc3ViKEQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeS5pc3ViKHgpO1xuICAgICAgICBDLmlzdWIoQSk7XG4gICAgICAgIEQuaXN1YihCKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgYTogQyxcbiAgICAgIGI6IEQsXG4gICAgICBnY2Q6IHkuaXVzaGxuKGcpXG4gICAgfTtcbiAgfTtcblxuICAvLyBUaGlzIGlzIHJlZHVjZWQgaW5jYXJuYXRpb24gb2YgdGhlIGJpbmFyeSBFRUFcbiAgLy8gYWJvdmUsIGRlc2lnbmF0ZWQgdG8gaW52ZXJ0IG1lbWJlcnMgb2YgdGhlXG4gIC8vIF9wcmltZV8gZmllbGRzIEYocCkgYXQgYSBtYXhpbWFsIHNwZWVkXG4gIEJOLnByb3RvdHlwZS5faW52bXAgPSBmdW5jdGlvbiBfaW52bXAgKHApIHtcbiAgICBhc3NlcnQocC5uZWdhdGl2ZSA9PT0gMCk7XG4gICAgYXNzZXJ0KCFwLmlzWmVybygpKTtcblxuICAgIHZhciBhID0gdGhpcztcbiAgICB2YXIgYiA9IHAuY2xvbmUoKTtcblxuICAgIGlmIChhLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICBhID0gYS51bW9kKHApO1xuICAgIH0gZWxzZSB7XG4gICAgICBhID0gYS5jbG9uZSgpO1xuICAgIH1cblxuICAgIHZhciB4MSA9IG5ldyBCTigxKTtcbiAgICB2YXIgeDIgPSBuZXcgQk4oMCk7XG5cbiAgICB2YXIgZGVsdGEgPSBiLmNsb25lKCk7XG5cbiAgICB3aGlsZSAoYS5jbXBuKDEpID4gMCAmJiBiLmNtcG4oMSkgPiAwKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgaW0gPSAxOyAoYS53b3Jkc1swXSAmIGltKSA9PT0gMCAmJiBpIDwgMjY7ICsraSwgaW0gPDw9IDEpO1xuICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgIGEuaXVzaHJuKGkpO1xuICAgICAgICB3aGlsZSAoaS0tID4gMCkge1xuICAgICAgICAgIGlmICh4MS5pc09kZCgpKSB7XG4gICAgICAgICAgICB4MS5pYWRkKGRlbHRhKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB4MS5pdXNocm4oMSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaiA9IDAsIGptID0gMTsgKGIud29yZHNbMF0gJiBqbSkgPT09IDAgJiYgaiA8IDI2OyArK2osIGptIDw8PSAxKTtcbiAgICAgIGlmIChqID4gMCkge1xuICAgICAgICBiLml1c2hybihqKTtcbiAgICAgICAgd2hpbGUgKGotLSA+IDApIHtcbiAgICAgICAgICBpZiAoeDIuaXNPZGQoKSkge1xuICAgICAgICAgICAgeDIuaWFkZChkZWx0YSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgeDIuaXVzaHJuKDEpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChhLmNtcChiKSA+PSAwKSB7XG4gICAgICAgIGEuaXN1YihiKTtcbiAgICAgICAgeDEuaXN1Yih4Mik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBiLmlzdWIoYSk7XG4gICAgICAgIHgyLmlzdWIoeDEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciByZXM7XG4gICAgaWYgKGEuY21wbigxKSA9PT0gMCkge1xuICAgICAgcmVzID0geDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlcyA9IHgyO1xuICAgIH1cblxuICAgIGlmIChyZXMuY21wbigwKSA8IDApIHtcbiAgICAgIHJlcy5pYWRkKHApO1xuICAgIH1cblxuICAgIHJldHVybiByZXM7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmdjZCA9IGZ1bmN0aW9uIGdjZCAobnVtKSB7XG4gICAgaWYgKHRoaXMuaXNaZXJvKCkpIHJldHVybiBudW0uYWJzKCk7XG4gICAgaWYgKG51bS5pc1plcm8oKSkgcmV0dXJuIHRoaXMuYWJzKCk7XG5cbiAgICB2YXIgYSA9IHRoaXMuY2xvbmUoKTtcbiAgICB2YXIgYiA9IG51bS5jbG9uZSgpO1xuICAgIGEubmVnYXRpdmUgPSAwO1xuICAgIGIubmVnYXRpdmUgPSAwO1xuXG4gICAgLy8gUmVtb3ZlIGNvbW1vbiBmYWN0b3Igb2YgdHdvXG4gICAgZm9yICh2YXIgc2hpZnQgPSAwOyBhLmlzRXZlbigpICYmIGIuaXNFdmVuKCk7IHNoaWZ0KyspIHtcbiAgICAgIGEuaXVzaHJuKDEpO1xuICAgICAgYi5pdXNocm4oMSk7XG4gICAgfVxuXG4gICAgZG8ge1xuICAgICAgd2hpbGUgKGEuaXNFdmVuKCkpIHtcbiAgICAgICAgYS5pdXNocm4oMSk7XG4gICAgICB9XG4gICAgICB3aGlsZSAoYi5pc0V2ZW4oKSkge1xuICAgICAgICBiLml1c2hybigxKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHIgPSBhLmNtcChiKTtcbiAgICAgIGlmIChyIDwgMCkge1xuICAgICAgICAvLyBTd2FwIGBhYCBhbmQgYGJgIHRvIG1ha2UgYGFgIGFsd2F5cyBiaWdnZXIgdGhhbiBgYmBcbiAgICAgICAgdmFyIHQgPSBhO1xuICAgICAgICBhID0gYjtcbiAgICAgICAgYiA9IHQ7XG4gICAgICB9IGVsc2UgaWYgKHIgPT09IDAgfHwgYi5jbXBuKDEpID09PSAwKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBhLmlzdWIoYik7XG4gICAgfSB3aGlsZSAodHJ1ZSk7XG5cbiAgICByZXR1cm4gYi5pdXNobG4oc2hpZnQpO1xuICB9O1xuXG4gIC8vIEludmVydCBudW1iZXIgaW4gdGhlIGZpZWxkIEYobnVtKVxuICBCTi5wcm90b3R5cGUuaW52bSA9IGZ1bmN0aW9uIGludm0gKG51bSkge1xuICAgIHJldHVybiB0aGlzLmVnY2QobnVtKS5hLnVtb2QobnVtKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuaXNFdmVuID0gZnVuY3Rpb24gaXNFdmVuICgpIHtcbiAgICByZXR1cm4gKHRoaXMud29yZHNbMF0gJiAxKSA9PT0gMDtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuaXNPZGQgPSBmdW5jdGlvbiBpc09kZCAoKSB7XG4gICAgcmV0dXJuICh0aGlzLndvcmRzWzBdICYgMSkgPT09IDE7XG4gIH07XG5cbiAgLy8gQW5kIGZpcnN0IHdvcmQgYW5kIG51bVxuICBCTi5wcm90b3R5cGUuYW5kbG4gPSBmdW5jdGlvbiBhbmRsbiAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMud29yZHNbMF0gJiBudW07XG4gIH07XG5cbiAgLy8gSW5jcmVtZW50IGF0IHRoZSBiaXQgcG9zaXRpb24gaW4tbGluZVxuICBCTi5wcm90b3R5cGUuYmluY24gPSBmdW5jdGlvbiBiaW5jbiAoYml0KSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBiaXQgPT09ICdudW1iZXInKTtcbiAgICB2YXIgciA9IGJpdCAlIDI2O1xuICAgIHZhciBzID0gKGJpdCAtIHIpIC8gMjY7XG4gICAgdmFyIHEgPSAxIDw8IHI7XG5cbiAgICAvLyBGYXN0IGNhc2U6IGJpdCBpcyBtdWNoIGhpZ2hlciB0aGFuIGFsbCBleGlzdGluZyB3b3Jkc1xuICAgIGlmICh0aGlzLmxlbmd0aCA8PSBzKSB7XG4gICAgICB0aGlzLl9leHBhbmQocyArIDEpO1xuICAgICAgdGhpcy53b3Jkc1tzXSB8PSBxO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gQWRkIGJpdCBhbmQgcHJvcGFnYXRlLCBpZiBuZWVkZWRcbiAgICB2YXIgY2FycnkgPSBxO1xuICAgIGZvciAodmFyIGkgPSBzOyBjYXJyeSAhPT0gMCAmJiBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHcgPSB0aGlzLndvcmRzW2ldIHwgMDtcbiAgICAgIHcgKz0gY2Fycnk7XG4gICAgICBjYXJyeSA9IHcgPj4+IDI2O1xuICAgICAgdyAmPSAweDNmZmZmZmY7XG4gICAgICB0aGlzLndvcmRzW2ldID0gdztcbiAgICB9XG4gICAgaWYgKGNhcnJ5ICE9PSAwKSB7XG4gICAgICB0aGlzLndvcmRzW2ldID0gY2Fycnk7XG4gICAgICB0aGlzLmxlbmd0aCsrO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuaXNaZXJvID0gZnVuY3Rpb24gaXNaZXJvICgpIHtcbiAgICByZXR1cm4gdGhpcy5sZW5ndGggPT09IDEgJiYgdGhpcy53b3Jkc1swXSA9PT0gMDtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuY21wbiA9IGZ1bmN0aW9uIGNtcG4gKG51bSkge1xuICAgIHZhciBuZWdhdGl2ZSA9IG51bSA8IDA7XG5cbiAgICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCAmJiAhbmVnYXRpdmUpIHJldHVybiAtMTtcbiAgICBpZiAodGhpcy5uZWdhdGl2ZSA9PT0gMCAmJiBuZWdhdGl2ZSkgcmV0dXJuIDE7XG5cbiAgICB0aGlzLnN0cmlwKCk7XG5cbiAgICB2YXIgcmVzO1xuICAgIGlmICh0aGlzLmxlbmd0aCA+IDEpIHtcbiAgICAgIHJlcyA9IDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChuZWdhdGl2ZSkge1xuICAgICAgICBudW0gPSAtbnVtO1xuICAgICAgfVxuXG4gICAgICBhc3NlcnQobnVtIDw9IDB4M2ZmZmZmZiwgJ051bWJlciBpcyB0b28gYmlnJyk7XG5cbiAgICAgIHZhciB3ID0gdGhpcy53b3Jkc1swXSB8IDA7XG4gICAgICByZXMgPSB3ID09PSBudW0gPyAwIDogdyA8IG51bSA/IC0xIDogMTtcbiAgICB9XG4gICAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDApIHJldHVybiAtcmVzIHwgMDtcbiAgICByZXR1cm4gcmVzO1xuICB9O1xuXG4gIC8vIENvbXBhcmUgdHdvIG51bWJlcnMgYW5kIHJldHVybjpcbiAgLy8gMSAtIGlmIGB0aGlzYCA+IGBudW1gXG4gIC8vIDAgLSBpZiBgdGhpc2AgPT0gYG51bWBcbiAgLy8gLTEgLSBpZiBgdGhpc2AgPCBgbnVtYFxuICBCTi5wcm90b3R5cGUuY21wID0gZnVuY3Rpb24gY21wIChudW0pIHtcbiAgICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCAmJiBudW0ubmVnYXRpdmUgPT09IDApIHJldHVybiAtMTtcbiAgICBpZiAodGhpcy5uZWdhdGl2ZSA9PT0gMCAmJiBudW0ubmVnYXRpdmUgIT09IDApIHJldHVybiAxO1xuXG4gICAgdmFyIHJlcyA9IHRoaXMudWNtcChudW0pO1xuICAgIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwKSByZXR1cm4gLXJlcyB8IDA7XG4gICAgcmV0dXJuIHJlcztcbiAgfTtcblxuICAvLyBVbnNpZ25lZCBjb21wYXJpc29uXG4gIEJOLnByb3RvdHlwZS51Y21wID0gZnVuY3Rpb24gdWNtcCAobnVtKSB7XG4gICAgLy8gQXQgdGhpcyBwb2ludCBib3RoIG51bWJlcnMgaGF2ZSB0aGUgc2FtZSBzaWduXG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aCkgcmV0dXJuIDE7XG4gICAgaWYgKHRoaXMubGVuZ3RoIDwgbnVtLmxlbmd0aCkgcmV0dXJuIC0xO1xuXG4gICAgdmFyIHJlcyA9IDA7XG4gICAgZm9yICh2YXIgaSA9IHRoaXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciBhID0gdGhpcy53b3Jkc1tpXSB8IDA7XG4gICAgICB2YXIgYiA9IG51bS53b3Jkc1tpXSB8IDA7XG5cbiAgICAgIGlmIChhID09PSBiKSBjb250aW51ZTtcbiAgICAgIGlmIChhIDwgYikge1xuICAgICAgICByZXMgPSAtMTtcbiAgICAgIH0gZWxzZSBpZiAoYSA+IGIpIHtcbiAgICAgICAgcmVzID0gMTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5ndG4gPSBmdW5jdGlvbiBndG4gKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNtcG4obnVtKSA9PT0gMTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuZ3QgPSBmdW5jdGlvbiBndCAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY21wKG51bSkgPT09IDE7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmd0ZW4gPSBmdW5jdGlvbiBndGVuIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbXBuKG51bSkgPj0gMDtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuZ3RlID0gZnVuY3Rpb24gZ3RlIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbXAobnVtKSA+PSAwO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5sdG4gPSBmdW5jdGlvbiBsdG4gKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNtcG4obnVtKSA9PT0gLTE7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmx0ID0gZnVuY3Rpb24gbHQgKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNtcChudW0pID09PSAtMTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUubHRlbiA9IGZ1bmN0aW9uIGx0ZW4gKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNtcG4obnVtKSA8PSAwO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5sdGUgPSBmdW5jdGlvbiBsdGUgKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNtcChudW0pIDw9IDA7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmVxbiA9IGZ1bmN0aW9uIGVxbiAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY21wbihudW0pID09PSAwO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5lcSA9IGZ1bmN0aW9uIGVxIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbXAobnVtKSA9PT0gMDtcbiAgfTtcblxuICAvL1xuICAvLyBBIHJlZHVjZSBjb250ZXh0LCBjb3VsZCBiZSB1c2luZyBtb250Z29tZXJ5IG9yIHNvbWV0aGluZyBiZXR0ZXIsIGRlcGVuZGluZ1xuICAvLyBvbiB0aGUgYG1gIGl0c2VsZi5cbiAgLy9cbiAgQk4ucmVkID0gZnVuY3Rpb24gcmVkIChudW0pIHtcbiAgICByZXR1cm4gbmV3IFJlZChudW0pO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS50b1JlZCA9IGZ1bmN0aW9uIHRvUmVkIChjdHgpIHtcbiAgICBhc3NlcnQoIXRoaXMucmVkLCAnQWxyZWFkeSBhIG51bWJlciBpbiByZWR1Y3Rpb24gY29udGV4dCcpO1xuICAgIGFzc2VydCh0aGlzLm5lZ2F0aXZlID09PSAwLCAncmVkIHdvcmtzIG9ubHkgd2l0aCBwb3NpdGl2ZXMnKTtcbiAgICByZXR1cm4gY3R4LmNvbnZlcnRUbyh0aGlzKS5fZm9yY2VSZWQoY3R4KTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuZnJvbVJlZCA9IGZ1bmN0aW9uIGZyb21SZWQgKCkge1xuICAgIGFzc2VydCh0aGlzLnJlZCwgJ2Zyb21SZWQgd29ya3Mgb25seSB3aXRoIG51bWJlcnMgaW4gcmVkdWN0aW9uIGNvbnRleHQnKTtcbiAgICByZXR1cm4gdGhpcy5yZWQuY29udmVydEZyb20odGhpcyk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLl9mb3JjZVJlZCA9IGZ1bmN0aW9uIF9mb3JjZVJlZCAoY3R4KSB7XG4gICAgdGhpcy5yZWQgPSBjdHg7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmZvcmNlUmVkID0gZnVuY3Rpb24gZm9yY2VSZWQgKGN0eCkge1xuICAgIGFzc2VydCghdGhpcy5yZWQsICdBbHJlYWR5IGEgbnVtYmVyIGluIHJlZHVjdGlvbiBjb250ZXh0Jyk7XG4gICAgcmV0dXJuIHRoaXMuX2ZvcmNlUmVkKGN0eCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnJlZEFkZCA9IGZ1bmN0aW9uIHJlZEFkZCAobnVtKSB7XG4gICAgYXNzZXJ0KHRoaXMucmVkLCAncmVkQWRkIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICAgIHJldHVybiB0aGlzLnJlZC5hZGQodGhpcywgbnVtKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUucmVkSUFkZCA9IGZ1bmN0aW9uIHJlZElBZGQgKG51bSkge1xuICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZElBZGQgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gICAgcmV0dXJuIHRoaXMucmVkLmlhZGQodGhpcywgbnVtKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUucmVkU3ViID0gZnVuY3Rpb24gcmVkU3ViIChudW0pIHtcbiAgICBhc3NlcnQodGhpcy5yZWQsICdyZWRTdWIgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gICAgcmV0dXJuIHRoaXMucmVkLnN1Yih0aGlzLCBudW0pO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5yZWRJU3ViID0gZnVuY3Rpb24gcmVkSVN1YiAobnVtKSB7XG4gICAgYXNzZXJ0KHRoaXMucmVkLCAncmVkSVN1YiB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgICByZXR1cm4gdGhpcy5yZWQuaXN1Yih0aGlzLCBudW0pO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5yZWRTaGwgPSBmdW5jdGlvbiByZWRTaGwgKG51bSkge1xuICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZFNobCB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgICByZXR1cm4gdGhpcy5yZWQuc2hsKHRoaXMsIG51bSk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnJlZE11bCA9IGZ1bmN0aW9uIHJlZE11bCAobnVtKSB7XG4gICAgYXNzZXJ0KHRoaXMucmVkLCAncmVkTXVsIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICAgIHRoaXMucmVkLl92ZXJpZnkyKHRoaXMsIG51bSk7XG4gICAgcmV0dXJuIHRoaXMucmVkLm11bCh0aGlzLCBudW0pO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5yZWRJTXVsID0gZnVuY3Rpb24gcmVkSU11bCAobnVtKSB7XG4gICAgYXNzZXJ0KHRoaXMucmVkLCAncmVkTXVsIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICAgIHRoaXMucmVkLl92ZXJpZnkyKHRoaXMsIG51bSk7XG4gICAgcmV0dXJuIHRoaXMucmVkLmltdWwodGhpcywgbnVtKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUucmVkU3FyID0gZnVuY3Rpb24gcmVkU3FyICgpIHtcbiAgICBhc3NlcnQodGhpcy5yZWQsICdyZWRTcXIgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gICAgdGhpcy5yZWQuX3ZlcmlmeTEodGhpcyk7XG4gICAgcmV0dXJuIHRoaXMucmVkLnNxcih0aGlzKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUucmVkSVNxciA9IGZ1bmN0aW9uIHJlZElTcXIgKCkge1xuICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZElTcXIgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gICAgdGhpcy5yZWQuX3ZlcmlmeTEodGhpcyk7XG4gICAgcmV0dXJuIHRoaXMucmVkLmlzcXIodGhpcyk7XG4gIH07XG5cbiAgLy8gU3F1YXJlIHJvb3Qgb3ZlciBwXG4gIEJOLnByb3RvdHlwZS5yZWRTcXJ0ID0gZnVuY3Rpb24gcmVkU3FydCAoKSB7XG4gICAgYXNzZXJ0KHRoaXMucmVkLCAncmVkU3FydCB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgICB0aGlzLnJlZC5fdmVyaWZ5MSh0aGlzKTtcbiAgICByZXR1cm4gdGhpcy5yZWQuc3FydCh0aGlzKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUucmVkSW52bSA9IGZ1bmN0aW9uIHJlZEludm0gKCkge1xuICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZEludm0gd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gICAgdGhpcy5yZWQuX3ZlcmlmeTEodGhpcyk7XG4gICAgcmV0dXJuIHRoaXMucmVkLmludm0odGhpcyk7XG4gIH07XG5cbiAgLy8gUmV0dXJuIG5lZ2F0aXZlIGNsb25lIG9mIGB0aGlzYCAlIGByZWQgbW9kdWxvYFxuICBCTi5wcm90b3R5cGUucmVkTmVnID0gZnVuY3Rpb24gcmVkTmVnICgpIHtcbiAgICBhc3NlcnQodGhpcy5yZWQsICdyZWROZWcgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gICAgdGhpcy5yZWQuX3ZlcmlmeTEodGhpcyk7XG4gICAgcmV0dXJuIHRoaXMucmVkLm5lZyh0aGlzKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUucmVkUG93ID0gZnVuY3Rpb24gcmVkUG93IChudW0pIHtcbiAgICBhc3NlcnQodGhpcy5yZWQgJiYgIW51bS5yZWQsICdyZWRQb3cobm9ybWFsTnVtKScpO1xuICAgIHRoaXMucmVkLl92ZXJpZnkxKHRoaXMpO1xuICAgIHJldHVybiB0aGlzLnJlZC5wb3codGhpcywgbnVtKTtcbiAgfTtcblxuICAvLyBQcmltZSBudW1iZXJzIHdpdGggZWZmaWNpZW50IHJlZHVjdGlvblxuICB2YXIgcHJpbWVzID0ge1xuICAgIGsyNTY6IG51bGwsXG4gICAgcDIyNDogbnVsbCxcbiAgICBwMTkyOiBudWxsLFxuICAgIHAyNTUxOTogbnVsbFxuICB9O1xuXG4gIC8vIFBzZXVkby1NZXJzZW5uZSBwcmltZVxuICBmdW5jdGlvbiBNUHJpbWUgKG5hbWUsIHApIHtcbiAgICAvLyBQID0gMiBeIE4gLSBLXG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB0aGlzLnAgPSBuZXcgQk4ocCwgMTYpO1xuICAgIHRoaXMubiA9IHRoaXMucC5iaXRMZW5ndGgoKTtcbiAgICB0aGlzLmsgPSBuZXcgQk4oMSkuaXVzaGxuKHRoaXMubikuaXN1Yih0aGlzLnApO1xuXG4gICAgdGhpcy50bXAgPSB0aGlzLl90bXAoKTtcbiAgfVxuXG4gIE1QcmltZS5wcm90b3R5cGUuX3RtcCA9IGZ1bmN0aW9uIF90bXAgKCkge1xuICAgIHZhciB0bXAgPSBuZXcgQk4obnVsbCk7XG4gICAgdG1wLndvcmRzID0gbmV3IEFycmF5KE1hdGguY2VpbCh0aGlzLm4gLyAxMykpO1xuICAgIHJldHVybiB0bXA7XG4gIH07XG5cbiAgTVByaW1lLnByb3RvdHlwZS5pcmVkdWNlID0gZnVuY3Rpb24gaXJlZHVjZSAobnVtKSB7XG4gICAgLy8gQXNzdW1lcyB0aGF0IGBudW1gIGlzIGxlc3MgdGhhbiBgUF4yYFxuICAgIC8vIG51bSA9IEhJICogKDIgXiBOIC0gSykgKyBISSAqIEsgKyBMTyA9IEhJICogSyArIExPIChtb2QgUClcbiAgICB2YXIgciA9IG51bTtcbiAgICB2YXIgcmxlbjtcblxuICAgIGRvIHtcbiAgICAgIHRoaXMuc3BsaXQociwgdGhpcy50bXApO1xuICAgICAgciA9IHRoaXMuaW11bEsocik7XG4gICAgICByID0gci5pYWRkKHRoaXMudG1wKTtcbiAgICAgIHJsZW4gPSByLmJpdExlbmd0aCgpO1xuICAgIH0gd2hpbGUgKHJsZW4gPiB0aGlzLm4pO1xuXG4gICAgdmFyIGNtcCA9IHJsZW4gPCB0aGlzLm4gPyAtMSA6IHIudWNtcCh0aGlzLnApO1xuICAgIGlmIChjbXAgPT09IDApIHtcbiAgICAgIHIud29yZHNbMF0gPSAwO1xuICAgICAgci5sZW5ndGggPSAxO1xuICAgIH0gZWxzZSBpZiAoY21wID4gMCkge1xuICAgICAgci5pc3ViKHRoaXMucCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChyLnN0cmlwICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gciBpcyBCTiB2NCBpbnN0YW5jZVxuICAgICAgICByLnN0cmlwKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyByIGlzIEJOIHY1IGluc3RhbmNlXG4gICAgICAgIHIuX3N0cmlwKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHI7XG4gIH07XG5cbiAgTVByaW1lLnByb3RvdHlwZS5zcGxpdCA9IGZ1bmN0aW9uIHNwbGl0IChpbnB1dCwgb3V0KSB7XG4gICAgaW5wdXQuaXVzaHJuKHRoaXMubiwgMCwgb3V0KTtcbiAgfTtcblxuICBNUHJpbWUucHJvdG90eXBlLmltdWxLID0gZnVuY3Rpb24gaW11bEsgKG51bSkge1xuICAgIHJldHVybiBudW0uaW11bCh0aGlzLmspO1xuICB9O1xuXG4gIGZ1bmN0aW9uIEsyNTYgKCkge1xuICAgIE1QcmltZS5jYWxsKFxuICAgICAgdGhpcyxcbiAgICAgICdrMjU2JyxcbiAgICAgICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZSBmZmZmZmMyZicpO1xuICB9XG4gIGluaGVyaXRzKEsyNTYsIE1QcmltZSk7XG5cbiAgSzI1Ni5wcm90b3R5cGUuc3BsaXQgPSBmdW5jdGlvbiBzcGxpdCAoaW5wdXQsIG91dHB1dCkge1xuICAgIC8vIDI1NiA9IDkgKiAyNiArIDIyXG4gICAgdmFyIG1hc2sgPSAweDNmZmZmZjtcblxuICAgIHZhciBvdXRMZW4gPSBNYXRoLm1pbihpbnB1dC5sZW5ndGgsIDkpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3V0TGVuOyBpKyspIHtcbiAgICAgIG91dHB1dC53b3Jkc1tpXSA9IGlucHV0LndvcmRzW2ldO1xuICAgIH1cbiAgICBvdXRwdXQubGVuZ3RoID0gb3V0TGVuO1xuXG4gICAgaWYgKGlucHV0Lmxlbmd0aCA8PSA5KSB7XG4gICAgICBpbnB1dC53b3Jkc1swXSA9IDA7XG4gICAgICBpbnB1dC5sZW5ndGggPSAxO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFNoaWZ0IGJ5IDkgbGltYnNcbiAgICB2YXIgcHJldiA9IGlucHV0LndvcmRzWzldO1xuICAgIG91dHB1dC53b3Jkc1tvdXRwdXQubGVuZ3RoKytdID0gcHJldiAmIG1hc2s7XG5cbiAgICBmb3IgKGkgPSAxMDsgaSA8IGlucHV0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgbmV4dCA9IGlucHV0LndvcmRzW2ldIHwgMDtcbiAgICAgIGlucHV0LndvcmRzW2kgLSAxMF0gPSAoKG5leHQgJiBtYXNrKSA8PCA0KSB8IChwcmV2ID4+PiAyMik7XG4gICAgICBwcmV2ID0gbmV4dDtcbiAgICB9XG4gICAgcHJldiA+Pj49IDIyO1xuICAgIGlucHV0LndvcmRzW2kgLSAxMF0gPSBwcmV2O1xuICAgIGlmIChwcmV2ID09PSAwICYmIGlucHV0Lmxlbmd0aCA+IDEwKSB7XG4gICAgICBpbnB1dC5sZW5ndGggLT0gMTA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlucHV0Lmxlbmd0aCAtPSA5O1xuICAgIH1cbiAgfTtcblxuICBLMjU2LnByb3RvdHlwZS5pbXVsSyA9IGZ1bmN0aW9uIGltdWxLIChudW0pIHtcbiAgICAvLyBLID0gMHgxMDAwMDAzZDEgPSBbIDB4NDAsIDB4M2QxIF1cbiAgICBudW0ud29yZHNbbnVtLmxlbmd0aF0gPSAwO1xuICAgIG51bS53b3Jkc1tudW0ubGVuZ3RoICsgMV0gPSAwO1xuICAgIG51bS5sZW5ndGggKz0gMjtcblxuICAgIC8vIGJvdW5kZWQgYXQ6IDB4NDAgKiAweDNmZmZmZmYgKyAweDNkMCA9IDB4MTAwMDAwMzkwXG4gICAgdmFyIGxvID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bS5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHcgPSBudW0ud29yZHNbaV0gfCAwO1xuICAgICAgbG8gKz0gdyAqIDB4M2QxO1xuICAgICAgbnVtLndvcmRzW2ldID0gbG8gJiAweDNmZmZmZmY7XG4gICAgICBsbyA9IHcgKiAweDQwICsgKChsbyAvIDB4NDAwMDAwMCkgfCAwKTtcbiAgICB9XG5cbiAgICAvLyBGYXN0IGxlbmd0aCByZWR1Y3Rpb25cbiAgICBpZiAobnVtLndvcmRzW251bS5sZW5ndGggLSAxXSA9PT0gMCkge1xuICAgICAgbnVtLmxlbmd0aC0tO1xuICAgICAgaWYgKG51bS53b3Jkc1tudW0ubGVuZ3RoIC0gMV0gPT09IDApIHtcbiAgICAgICAgbnVtLmxlbmd0aC0tO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVtO1xuICB9O1xuXG4gIGZ1bmN0aW9uIFAyMjQgKCkge1xuICAgIE1QcmltZS5jYWxsKFxuICAgICAgdGhpcyxcbiAgICAgICdwMjI0JyxcbiAgICAgICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiAwMDAwMDAwMCAwMDAwMDAwMCAwMDAwMDAwMScpO1xuICB9XG4gIGluaGVyaXRzKFAyMjQsIE1QcmltZSk7XG5cbiAgZnVuY3Rpb24gUDE5MiAoKSB7XG4gICAgTVByaW1lLmNhbGwoXG4gICAgICB0aGlzLFxuICAgICAgJ3AxOTInLFxuICAgICAgJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZlIGZmZmZmZmZmIGZmZmZmZmZmJyk7XG4gIH1cbiAgaW5oZXJpdHMoUDE5MiwgTVByaW1lKTtcblxuICBmdW5jdGlvbiBQMjU1MTkgKCkge1xuICAgIC8vIDIgXiAyNTUgLSAxOVxuICAgIE1QcmltZS5jYWxsKFxuICAgICAgdGhpcyxcbiAgICAgICcyNTUxOScsXG4gICAgICAnN2ZmZmZmZmZmZmZmZmZmZiBmZmZmZmZmZmZmZmZmZmZmIGZmZmZmZmZmZmZmZmZmZmYgZmZmZmZmZmZmZmZmZmZlZCcpO1xuICB9XG4gIGluaGVyaXRzKFAyNTUxOSwgTVByaW1lKTtcblxuICBQMjU1MTkucHJvdG90eXBlLmltdWxLID0gZnVuY3Rpb24gaW11bEsgKG51bSkge1xuICAgIC8vIEsgPSAweDEzXG4gICAgdmFyIGNhcnJ5ID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bS5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGhpID0gKG51bS53b3Jkc1tpXSB8IDApICogMHgxMyArIGNhcnJ5O1xuICAgICAgdmFyIGxvID0gaGkgJiAweDNmZmZmZmY7XG4gICAgICBoaSA+Pj49IDI2O1xuXG4gICAgICBudW0ud29yZHNbaV0gPSBsbztcbiAgICAgIGNhcnJ5ID0gaGk7XG4gICAgfVxuICAgIGlmIChjYXJyeSAhPT0gMCkge1xuICAgICAgbnVtLndvcmRzW251bS5sZW5ndGgrK10gPSBjYXJyeTtcbiAgICB9XG4gICAgcmV0dXJuIG51bTtcbiAgfTtcblxuICAvLyBFeHBvcnRlZCBtb3N0bHkgZm9yIHRlc3RpbmcgcHVycG9zZXMsIHVzZSBwbGFpbiBuYW1lIGluc3RlYWRcbiAgQk4uX3ByaW1lID0gZnVuY3Rpb24gcHJpbWUgKG5hbWUpIHtcbiAgICAvLyBDYWNoZWQgdmVyc2lvbiBvZiBwcmltZVxuICAgIGlmIChwcmltZXNbbmFtZV0pIHJldHVybiBwcmltZXNbbmFtZV07XG5cbiAgICB2YXIgcHJpbWU7XG4gICAgaWYgKG5hbWUgPT09ICdrMjU2Jykge1xuICAgICAgcHJpbWUgPSBuZXcgSzI1NigpO1xuICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gJ3AyMjQnKSB7XG4gICAgICBwcmltZSA9IG5ldyBQMjI0KCk7XG4gICAgfSBlbHNlIGlmIChuYW1lID09PSAncDE5MicpIHtcbiAgICAgIHByaW1lID0gbmV3IFAxOTIoKTtcbiAgICB9IGVsc2UgaWYgKG5hbWUgPT09ICdwMjU1MTknKSB7XG4gICAgICBwcmltZSA9IG5ldyBQMjU1MTkoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIHByaW1lICcgKyBuYW1lKTtcbiAgICB9XG4gICAgcHJpbWVzW25hbWVdID0gcHJpbWU7XG5cbiAgICByZXR1cm4gcHJpbWU7XG4gIH07XG5cbiAgLy9cbiAgLy8gQmFzZSByZWR1Y3Rpb24gZW5naW5lXG4gIC8vXG4gIGZ1bmN0aW9uIFJlZCAobSkge1xuICAgIGlmICh0eXBlb2YgbSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHZhciBwcmltZSA9IEJOLl9wcmltZShtKTtcbiAgICAgIHRoaXMubSA9IHByaW1lLnA7XG4gICAgICB0aGlzLnByaW1lID0gcHJpbWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFzc2VydChtLmd0bigxKSwgJ21vZHVsdXMgbXVzdCBiZSBncmVhdGVyIHRoYW4gMScpO1xuICAgICAgdGhpcy5tID0gbTtcbiAgICAgIHRoaXMucHJpbWUgPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIFJlZC5wcm90b3R5cGUuX3ZlcmlmeTEgPSBmdW5jdGlvbiBfdmVyaWZ5MSAoYSkge1xuICAgIGFzc2VydChhLm5lZ2F0aXZlID09PSAwLCAncmVkIHdvcmtzIG9ubHkgd2l0aCBwb3NpdGl2ZXMnKTtcbiAgICBhc3NlcnQoYS5yZWQsICdyZWQgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5fdmVyaWZ5MiA9IGZ1bmN0aW9uIF92ZXJpZnkyIChhLCBiKSB7XG4gICAgYXNzZXJ0KChhLm5lZ2F0aXZlIHwgYi5uZWdhdGl2ZSkgPT09IDAsICdyZWQgd29ya3Mgb25seSB3aXRoIHBvc2l0aXZlcycpO1xuICAgIGFzc2VydChhLnJlZCAmJiBhLnJlZCA9PT0gYi5yZWQsXG4gICAgICAncmVkIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUuaW1vZCA9IGZ1bmN0aW9uIGltb2QgKGEpIHtcbiAgICBpZiAodGhpcy5wcmltZSkgcmV0dXJuIHRoaXMucHJpbWUuaXJlZHVjZShhKS5fZm9yY2VSZWQodGhpcyk7XG4gICAgcmV0dXJuIGEudW1vZCh0aGlzLm0pLl9mb3JjZVJlZCh0aGlzKTtcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLm5lZyA9IGZ1bmN0aW9uIG5lZyAoYSkge1xuICAgIGlmIChhLmlzWmVybygpKSB7XG4gICAgICByZXR1cm4gYS5jbG9uZSgpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLm0uc3ViKGEpLl9mb3JjZVJlZCh0aGlzKTtcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZCAoYSwgYikge1xuICAgIHRoaXMuX3ZlcmlmeTIoYSwgYik7XG5cbiAgICB2YXIgcmVzID0gYS5hZGQoYik7XG4gICAgaWYgKHJlcy5jbXAodGhpcy5tKSA+PSAwKSB7XG4gICAgICByZXMuaXN1Yih0aGlzLm0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLl9mb3JjZVJlZCh0aGlzKTtcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLmlhZGQgPSBmdW5jdGlvbiBpYWRkIChhLCBiKSB7XG4gICAgdGhpcy5fdmVyaWZ5MihhLCBiKTtcblxuICAgIHZhciByZXMgPSBhLmlhZGQoYik7XG4gICAgaWYgKHJlcy5jbXAodGhpcy5tKSA+PSAwKSB7XG4gICAgICByZXMuaXN1Yih0aGlzLm0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUuc3ViID0gZnVuY3Rpb24gc3ViIChhLCBiKSB7XG4gICAgdGhpcy5fdmVyaWZ5MihhLCBiKTtcblxuICAgIHZhciByZXMgPSBhLnN1YihiKTtcbiAgICBpZiAocmVzLmNtcG4oMCkgPCAwKSB7XG4gICAgICByZXMuaWFkZCh0aGlzLm0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLl9mb3JjZVJlZCh0aGlzKTtcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLmlzdWIgPSBmdW5jdGlvbiBpc3ViIChhLCBiKSB7XG4gICAgdGhpcy5fdmVyaWZ5MihhLCBiKTtcblxuICAgIHZhciByZXMgPSBhLmlzdWIoYik7XG4gICAgaWYgKHJlcy5jbXBuKDApIDwgMCkge1xuICAgICAgcmVzLmlhZGQodGhpcy5tKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLnNobCA9IGZ1bmN0aW9uIHNobCAoYSwgbnVtKSB7XG4gICAgdGhpcy5fdmVyaWZ5MShhKTtcbiAgICByZXR1cm4gdGhpcy5pbW9kKGEudXNobG4obnVtKSk7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5pbXVsID0gZnVuY3Rpb24gaW11bCAoYSwgYikge1xuICAgIHRoaXMuX3ZlcmlmeTIoYSwgYik7XG4gICAgcmV0dXJuIHRoaXMuaW1vZChhLmltdWwoYikpO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUubXVsID0gZnVuY3Rpb24gbXVsIChhLCBiKSB7XG4gICAgdGhpcy5fdmVyaWZ5MihhLCBiKTtcbiAgICByZXR1cm4gdGhpcy5pbW9kKGEubXVsKGIpKTtcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLmlzcXIgPSBmdW5jdGlvbiBpc3FyIChhKSB7XG4gICAgcmV0dXJuIHRoaXMuaW11bChhLCBhLmNsb25lKCkpO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUuc3FyID0gZnVuY3Rpb24gc3FyIChhKSB7XG4gICAgcmV0dXJuIHRoaXMubXVsKGEsIGEpO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUuc3FydCA9IGZ1bmN0aW9uIHNxcnQgKGEpIHtcbiAgICBpZiAoYS5pc1plcm8oKSkgcmV0dXJuIGEuY2xvbmUoKTtcblxuICAgIHZhciBtb2QzID0gdGhpcy5tLmFuZGxuKDMpO1xuICAgIGFzc2VydChtb2QzICUgMiA9PT0gMSk7XG5cbiAgICAvLyBGYXN0IGNhc2VcbiAgICBpZiAobW9kMyA9PT0gMykge1xuICAgICAgdmFyIHBvdyA9IHRoaXMubS5hZGQobmV3IEJOKDEpKS5pdXNocm4oMik7XG4gICAgICByZXR1cm4gdGhpcy5wb3coYSwgcG93KTtcbiAgICB9XG5cbiAgICAvLyBUb25lbGxpLVNoYW5rcyBhbGdvcml0aG0gKFRvdGFsbHkgdW5vcHRpbWl6ZWQgYW5kIHNsb3cpXG4gICAgLy9cbiAgICAvLyBGaW5kIFEgYW5kIFMsIHRoYXQgUSAqIDIgXiBTID0gKFAgLSAxKVxuICAgIHZhciBxID0gdGhpcy5tLnN1Ym4oMSk7XG4gICAgdmFyIHMgPSAwO1xuICAgIHdoaWxlICghcS5pc1plcm8oKSAmJiBxLmFuZGxuKDEpID09PSAwKSB7XG4gICAgICBzKys7XG4gICAgICBxLml1c2hybigxKTtcbiAgICB9XG4gICAgYXNzZXJ0KCFxLmlzWmVybygpKTtcblxuICAgIHZhciBvbmUgPSBuZXcgQk4oMSkudG9SZWQodGhpcyk7XG4gICAgdmFyIG5PbmUgPSBvbmUucmVkTmVnKCk7XG5cbiAgICAvLyBGaW5kIHF1YWRyYXRpYyBub24tcmVzaWR1ZVxuICAgIC8vIE5PVEU6IE1heCBpcyBzdWNoIGJlY2F1c2Ugb2YgZ2VuZXJhbGl6ZWQgUmllbWFubiBoeXBvdGhlc2lzLlxuICAgIHZhciBscG93ID0gdGhpcy5tLnN1Ym4oMSkuaXVzaHJuKDEpO1xuICAgIHZhciB6ID0gdGhpcy5tLmJpdExlbmd0aCgpO1xuICAgIHogPSBuZXcgQk4oMiAqIHogKiB6KS50b1JlZCh0aGlzKTtcblxuICAgIHdoaWxlICh0aGlzLnBvdyh6LCBscG93KS5jbXAobk9uZSkgIT09IDApIHtcbiAgICAgIHoucmVkSUFkZChuT25lKTtcbiAgICB9XG5cbiAgICB2YXIgYyA9IHRoaXMucG93KHosIHEpO1xuICAgIHZhciByID0gdGhpcy5wb3coYSwgcS5hZGRuKDEpLml1c2hybigxKSk7XG4gICAgdmFyIHQgPSB0aGlzLnBvdyhhLCBxKTtcbiAgICB2YXIgbSA9IHM7XG4gICAgd2hpbGUgKHQuY21wKG9uZSkgIT09IDApIHtcbiAgICAgIHZhciB0bXAgPSB0O1xuICAgICAgZm9yICh2YXIgaSA9IDA7IHRtcC5jbXAob25lKSAhPT0gMDsgaSsrKSB7XG4gICAgICAgIHRtcCA9IHRtcC5yZWRTcXIoKTtcbiAgICAgIH1cbiAgICAgIGFzc2VydChpIDwgbSk7XG4gICAgICB2YXIgYiA9IHRoaXMucG93KGMsIG5ldyBCTigxKS5pdXNobG4obSAtIGkgLSAxKSk7XG5cbiAgICAgIHIgPSByLnJlZE11bChiKTtcbiAgICAgIGMgPSBiLnJlZFNxcigpO1xuICAgICAgdCA9IHQucmVkTXVsKGMpO1xuICAgICAgbSA9IGk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHI7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5pbnZtID0gZnVuY3Rpb24gaW52bSAoYSkge1xuICAgIHZhciBpbnYgPSBhLl9pbnZtcCh0aGlzLm0pO1xuICAgIGlmIChpbnYubmVnYXRpdmUgIT09IDApIHtcbiAgICAgIGludi5uZWdhdGl2ZSA9IDA7XG4gICAgICByZXR1cm4gdGhpcy5pbW9kKGludikucmVkTmVnKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmltb2QoaW52KTtcbiAgICB9XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5wb3cgPSBmdW5jdGlvbiBwb3cgKGEsIG51bSkge1xuICAgIGlmIChudW0uaXNaZXJvKCkpIHJldHVybiBuZXcgQk4oMSkudG9SZWQodGhpcyk7XG4gICAgaWYgKG51bS5jbXBuKDEpID09PSAwKSByZXR1cm4gYS5jbG9uZSgpO1xuXG4gICAgdmFyIHdpbmRvd1NpemUgPSA0O1xuICAgIHZhciB3bmQgPSBuZXcgQXJyYXkoMSA8PCB3aW5kb3dTaXplKTtcbiAgICB3bmRbMF0gPSBuZXcgQk4oMSkudG9SZWQodGhpcyk7XG4gICAgd25kWzFdID0gYTtcbiAgICBmb3IgKHZhciBpID0gMjsgaSA8IHduZC5sZW5ndGg7IGkrKykge1xuICAgICAgd25kW2ldID0gdGhpcy5tdWwod25kW2kgLSAxXSwgYSk7XG4gICAgfVxuXG4gICAgdmFyIHJlcyA9IHduZFswXTtcbiAgICB2YXIgY3VycmVudCA9IDA7XG4gICAgdmFyIGN1cnJlbnRMZW4gPSAwO1xuICAgIHZhciBzdGFydCA9IG51bS5iaXRMZW5ndGgoKSAlIDI2O1xuICAgIGlmIChzdGFydCA9PT0gMCkge1xuICAgICAgc3RhcnQgPSAyNjtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSBudW0ubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciB3b3JkID0gbnVtLndvcmRzW2ldO1xuICAgICAgZm9yICh2YXIgaiA9IHN0YXJ0IC0gMTsgaiA+PSAwOyBqLS0pIHtcbiAgICAgICAgdmFyIGJpdCA9ICh3b3JkID4+IGopICYgMTtcbiAgICAgICAgaWYgKHJlcyAhPT0gd25kWzBdKSB7XG4gICAgICAgICAgcmVzID0gdGhpcy5zcXIocmVzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChiaXQgPT09IDAgJiYgY3VycmVudCA9PT0gMCkge1xuICAgICAgICAgIGN1cnJlbnRMZW4gPSAwO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgY3VycmVudCA8PD0gMTtcbiAgICAgICAgY3VycmVudCB8PSBiaXQ7XG4gICAgICAgIGN1cnJlbnRMZW4rKztcbiAgICAgICAgaWYgKGN1cnJlbnRMZW4gIT09IHdpbmRvd1NpemUgJiYgKGkgIT09IDAgfHwgaiAhPT0gMCkpIGNvbnRpbnVlO1xuXG4gICAgICAgIHJlcyA9IHRoaXMubXVsKHJlcywgd25kW2N1cnJlbnRdKTtcbiAgICAgICAgY3VycmVudExlbiA9IDA7XG4gICAgICAgIGN1cnJlbnQgPSAwO1xuICAgICAgfVxuICAgICAgc3RhcnQgPSAyNjtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUuY29udmVydFRvID0gZnVuY3Rpb24gY29udmVydFRvIChudW0pIHtcbiAgICB2YXIgciA9IG51bS51bW9kKHRoaXMubSk7XG5cbiAgICByZXR1cm4gciA9PT0gbnVtID8gci5jbG9uZSgpIDogcjtcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLmNvbnZlcnRGcm9tID0gZnVuY3Rpb24gY29udmVydEZyb20gKG51bSkge1xuICAgIHZhciByZXMgPSBudW0uY2xvbmUoKTtcbiAgICByZXMucmVkID0gbnVsbDtcbiAgICByZXR1cm4gcmVzO1xuICB9O1xuXG4gIC8vXG4gIC8vIE1vbnRnb21lcnkgbWV0aG9kIGVuZ2luZVxuICAvL1xuXG4gIEJOLm1vbnQgPSBmdW5jdGlvbiBtb250IChudW0pIHtcbiAgICByZXR1cm4gbmV3IE1vbnQobnVtKTtcbiAgfTtcblxuICBmdW5jdGlvbiBNb250IChtKSB7XG4gICAgUmVkLmNhbGwodGhpcywgbSk7XG5cbiAgICB0aGlzLnNoaWZ0ID0gdGhpcy5tLmJpdExlbmd0aCgpO1xuICAgIGlmICh0aGlzLnNoaWZ0ICUgMjYgIT09IDApIHtcbiAgICAgIHRoaXMuc2hpZnQgKz0gMjYgLSAodGhpcy5zaGlmdCAlIDI2KTtcbiAgICB9XG5cbiAgICB0aGlzLnIgPSBuZXcgQk4oMSkuaXVzaGxuKHRoaXMuc2hpZnQpO1xuICAgIHRoaXMucjIgPSB0aGlzLmltb2QodGhpcy5yLnNxcigpKTtcbiAgICB0aGlzLnJpbnYgPSB0aGlzLnIuX2ludm1wKHRoaXMubSk7XG5cbiAgICB0aGlzLm1pbnYgPSB0aGlzLnJpbnYubXVsKHRoaXMucikuaXN1Ym4oMSkuZGl2KHRoaXMubSk7XG4gICAgdGhpcy5taW52ID0gdGhpcy5taW52LnVtb2QodGhpcy5yKTtcbiAgICB0aGlzLm1pbnYgPSB0aGlzLnIuc3ViKHRoaXMubWludik7XG4gIH1cbiAgaW5oZXJpdHMoTW9udCwgUmVkKTtcblxuICBNb250LnByb3RvdHlwZS5jb252ZXJ0VG8gPSBmdW5jdGlvbiBjb252ZXJ0VG8gKG51bSkge1xuICAgIHJldHVybiB0aGlzLmltb2QobnVtLnVzaGxuKHRoaXMuc2hpZnQpKTtcbiAgfTtcblxuICBNb250LnByb3RvdHlwZS5jb252ZXJ0RnJvbSA9IGZ1bmN0aW9uIGNvbnZlcnRGcm9tIChudW0pIHtcbiAgICB2YXIgciA9IHRoaXMuaW1vZChudW0ubXVsKHRoaXMucmludikpO1xuICAgIHIucmVkID0gbnVsbDtcbiAgICByZXR1cm4gcjtcbiAgfTtcblxuICBNb250LnByb3RvdHlwZS5pbXVsID0gZnVuY3Rpb24gaW11bCAoYSwgYikge1xuICAgIGlmIChhLmlzWmVybygpIHx8IGIuaXNaZXJvKCkpIHtcbiAgICAgIGEud29yZHNbMF0gPSAwO1xuICAgICAgYS5sZW5ndGggPSAxO1xuICAgICAgcmV0dXJuIGE7XG4gICAgfVxuXG4gICAgdmFyIHQgPSBhLmltdWwoYik7XG4gICAgdmFyIGMgPSB0Lm1hc2tuKHRoaXMuc2hpZnQpLm11bCh0aGlzLm1pbnYpLmltYXNrbih0aGlzLnNoaWZ0KS5tdWwodGhpcy5tKTtcbiAgICB2YXIgdSA9IHQuaXN1YihjKS5pdXNocm4odGhpcy5zaGlmdCk7XG4gICAgdmFyIHJlcyA9IHU7XG5cbiAgICBpZiAodS5jbXAodGhpcy5tKSA+PSAwKSB7XG4gICAgICByZXMgPSB1LmlzdWIodGhpcy5tKTtcbiAgICB9IGVsc2UgaWYgKHUuY21wbigwKSA8IDApIHtcbiAgICAgIHJlcyA9IHUuaWFkZCh0aGlzLm0pO1xuICAgIH1cblxuICAgIHJldHVybiByZXMuX2ZvcmNlUmVkKHRoaXMpO1xuICB9O1xuXG4gIE1vbnQucHJvdG90eXBlLm11bCA9IGZ1bmN0aW9uIG11bCAoYSwgYikge1xuICAgIGlmIChhLmlzWmVybygpIHx8IGIuaXNaZXJvKCkpIHJldHVybiBuZXcgQk4oMCkuX2ZvcmNlUmVkKHRoaXMpO1xuXG4gICAgdmFyIHQgPSBhLm11bChiKTtcbiAgICB2YXIgYyA9IHQubWFza24odGhpcy5zaGlmdCkubXVsKHRoaXMubWludikuaW1hc2tuKHRoaXMuc2hpZnQpLm11bCh0aGlzLm0pO1xuICAgIHZhciB1ID0gdC5pc3ViKGMpLml1c2hybih0aGlzLnNoaWZ0KTtcbiAgICB2YXIgcmVzID0gdTtcbiAgICBpZiAodS5jbXAodGhpcy5tKSA+PSAwKSB7XG4gICAgICByZXMgPSB1LmlzdWIodGhpcy5tKTtcbiAgICB9IGVsc2UgaWYgKHUuY21wbigwKSA8IDApIHtcbiAgICAgIHJlcyA9IHUuaWFkZCh0aGlzLm0pO1xuICAgIH1cblxuICAgIHJldHVybiByZXMuX2ZvcmNlUmVkKHRoaXMpO1xuICB9O1xuXG4gIE1vbnQucHJvdG90eXBlLmludm0gPSBmdW5jdGlvbiBpbnZtIChhKSB7XG4gICAgLy8gKEFSKV4tMSAqIFJeMiA9IChBXi0xICogUl4tMSkgKiBSXjIgPSBBXi0xICogUlxuICAgIHZhciByZXMgPSB0aGlzLmltb2QoYS5faW52bXAodGhpcy5tKS5tdWwodGhpcy5yMikpO1xuICAgIHJldHVybiByZXMuX2ZvcmNlUmVkKHRoaXMpO1xuICB9O1xufSkodHlwZW9mIG1vZHVsZSA9PT0gJ3VuZGVmaW5lZCcgfHwgbW9kdWxlLCB0aGlzKTtcbiIsIid1c2Ugc3RyaWN0J1xuXG52YXIgYm5zaWduID0gcmVxdWlyZSgnLi9saWIvYm4tc2lnbicpXG5cbm1vZHVsZS5leHBvcnRzID0gc2lnblxuXG5mdW5jdGlvbiBzaWduKHgpIHtcbiAgcmV0dXJuIGJuc2lnbih4WzBdKSAqIGJuc2lnbih4WzFdKVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbnZhciByYXRpb25hbGl6ZSA9IHJlcXVpcmUoJy4vbGliL3JhdGlvbmFsaXplJylcblxubW9kdWxlLmV4cG9ydHMgPSBzdWJcblxuZnVuY3Rpb24gc3ViKGEsIGIpIHtcbiAgcmV0dXJuIHJhdGlvbmFsaXplKGFbMF0ubXVsKGJbMV0pLnN1YihhWzFdLm11bChiWzBdKSksIGFbMV0ubXVsKGJbMV0pKVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbnZhciBibjJudW0gPSByZXF1aXJlKCcuL2xpYi9ibi10by1udW0nKVxudmFyIGN0eiA9IHJlcXVpcmUoJy4vbGliL2N0eicpXG5cbm1vZHVsZS5leHBvcnRzID0gcm91bmRSYXRcblxuLy8gUm91bmQgYSByYXRpb25hbCB0byB0aGUgY2xvc2VzdCBmbG9hdFxuZnVuY3Rpb24gcm91bmRSYXQgKGYpIHtcbiAgdmFyIGEgPSBmWzBdXG4gIHZhciBiID0gZlsxXVxuICBpZiAoYS5jbXBuKDApID09PSAwKSB7XG4gICAgcmV0dXJuIDBcbiAgfVxuICB2YXIgaCA9IGEuYWJzKCkuZGl2bW9kKGIuYWJzKCkpXG4gIHZhciBpdiA9IGguZGl2XG4gIHZhciB4ID0gYm4ybnVtKGl2KVxuICB2YXIgaXIgPSBoLm1vZFxuICB2YXIgc2duID0gKGEubmVnYXRpdmUgIT09IGIubmVnYXRpdmUpID8gLTEgOiAxXG4gIGlmIChpci5jbXBuKDApID09PSAwKSB7XG4gICAgcmV0dXJuIHNnbiAqIHhcbiAgfVxuICBpZiAoeCkge1xuICAgIHZhciBzID0gY3R6KHgpICsgNFxuICAgIHZhciB5ID0gYm4ybnVtKGlyLnVzaGxuKHMpLmRpdlJvdW5kKGIpKVxuICAgIHJldHVybiBzZ24gKiAoeCArIHkgKiBNYXRoLnBvdygyLCAtcykpXG4gIH0gZWxzZSB7XG4gICAgdmFyIHliaXRzID0gYi5iaXRMZW5ndGgoKSAtIGlyLmJpdExlbmd0aCgpICsgNTNcbiAgICB2YXIgeSA9IGJuMm51bShpci51c2hsbih5Yml0cykuZGl2Um91bmQoYikpXG4gICAgaWYgKHliaXRzIDwgMTAyMykge1xuICAgICAgcmV0dXJuIHNnbiAqIHkgKiBNYXRoLnBvdygyLCAteWJpdHMpXG4gICAgfVxuICAgIHkgKj0gTWF0aC5wb3coMiwgLTEwMjMpXG4gICAgcmV0dXJuIHNnbiAqIHkgKiBNYXRoLnBvdygyLCAxMDIzIC0geWJpdHMpXG4gIH1cbn1cbiIsIlwidXNlIHN0cmljdFwiXG5cbi8vIChhLCB5LCBjLCBsLCBoKSA9IChhcnJheSwgeVssIGNtcCwgbG8sIGhpXSlcblxuZnVuY3Rpb24gZ2UoYSwgeSwgYywgbCwgaCkge1xuICB2YXIgaSA9IGggKyAxO1xuICB3aGlsZSAobCA8PSBoKSB7XG4gICAgdmFyIG0gPSAobCArIGgpID4+PiAxLCB4ID0gYVttXTtcbiAgICB2YXIgcCA9IChjICE9PSB1bmRlZmluZWQpID8gYyh4LCB5KSA6ICh4IC0geSk7XG4gICAgaWYgKHAgPj0gMCkgeyBpID0gbTsgaCA9IG0gLSAxIH0gZWxzZSB7IGwgPSBtICsgMSB9XG4gIH1cbiAgcmV0dXJuIGk7XG59O1xuXG5mdW5jdGlvbiBndChhLCB5LCBjLCBsLCBoKSB7XG4gIHZhciBpID0gaCArIDE7XG4gIHdoaWxlIChsIDw9IGgpIHtcbiAgICB2YXIgbSA9IChsICsgaCkgPj4+IDEsIHggPSBhW21dO1xuICAgIHZhciBwID0gKGMgIT09IHVuZGVmaW5lZCkgPyBjKHgsIHkpIDogKHggLSB5KTtcbiAgICBpZiAocCA+IDApIHsgaSA9IG07IGggPSBtIC0gMSB9IGVsc2UgeyBsID0gbSArIDEgfVxuICB9XG4gIHJldHVybiBpO1xufTtcblxuZnVuY3Rpb24gbHQoYSwgeSwgYywgbCwgaCkge1xuICB2YXIgaSA9IGwgLSAxO1xuICB3aGlsZSAobCA8PSBoKSB7XG4gICAgdmFyIG0gPSAobCArIGgpID4+PiAxLCB4ID0gYVttXTtcbiAgICB2YXIgcCA9IChjICE9PSB1bmRlZmluZWQpID8gYyh4LCB5KSA6ICh4IC0geSk7XG4gICAgaWYgKHAgPCAwKSB7IGkgPSBtOyBsID0gbSArIDEgfSBlbHNlIHsgaCA9IG0gLSAxIH1cbiAgfVxuICByZXR1cm4gaTtcbn07XG5cbmZ1bmN0aW9uIGxlKGEsIHksIGMsIGwsIGgpIHtcbiAgdmFyIGkgPSBsIC0gMTtcbiAgd2hpbGUgKGwgPD0gaCkge1xuICAgIHZhciBtID0gKGwgKyBoKSA+Pj4gMSwgeCA9IGFbbV07XG4gICAgdmFyIHAgPSAoYyAhPT0gdW5kZWZpbmVkKSA/IGMoeCwgeSkgOiAoeCAtIHkpO1xuICAgIGlmIChwIDw9IDApIHsgaSA9IG07IGwgPSBtICsgMSB9IGVsc2UgeyBoID0gbSAtIDEgfVxuICB9XG4gIHJldHVybiBpO1xufTtcblxuZnVuY3Rpb24gZXEoYSwgeSwgYywgbCwgaCkge1xuICB3aGlsZSAobCA8PSBoKSB7XG4gICAgdmFyIG0gPSAobCArIGgpID4+PiAxLCB4ID0gYVttXTtcbiAgICB2YXIgcCA9IChjICE9PSB1bmRlZmluZWQpID8gYyh4LCB5KSA6ICh4IC0geSk7XG4gICAgaWYgKHAgPT09IDApIHsgcmV0dXJuIG0gfVxuICAgIGlmIChwIDw9IDApIHsgbCA9IG0gKyAxIH0gZWxzZSB7IGggPSBtIC0gMSB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufTtcblxuZnVuY3Rpb24gbm9ybShhLCB5LCBjLCBsLCBoLCBmKSB7XG4gIGlmICh0eXBlb2YgYyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBmKGEsIHksIGMsIChsID09PSB1bmRlZmluZWQpID8gMCA6IGwgfCAwLCAoaCA9PT0gdW5kZWZpbmVkKSA/IGEubGVuZ3RoIC0gMSA6IGggfCAwKTtcbiAgfVxuICByZXR1cm4gZihhLCB5LCB1bmRlZmluZWQsIChjID09PSB1bmRlZmluZWQpID8gMCA6IGMgfCAwLCAobCA9PT0gdW5kZWZpbmVkKSA/IGEubGVuZ3RoIC0gMSA6IGwgfCAwKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGdlOiBmdW5jdGlvbihhLCB5LCBjLCBsLCBoKSB7IHJldHVybiBub3JtKGEsIHksIGMsIGwsIGgsIGdlKX0sXG4gIGd0OiBmdW5jdGlvbihhLCB5LCBjLCBsLCBoKSB7IHJldHVybiBub3JtKGEsIHksIGMsIGwsIGgsIGd0KX0sXG4gIGx0OiBmdW5jdGlvbihhLCB5LCBjLCBsLCBoKSB7IHJldHVybiBub3JtKGEsIHksIGMsIGwsIGgsIGx0KX0sXG4gIGxlOiBmdW5jdGlvbihhLCB5LCBjLCBsLCBoKSB7IHJldHVybiBub3JtKGEsIHksIGMsIGwsIGgsIGxlKX0sXG4gIGVxOiBmdW5jdGlvbihhLCB5LCBjLCBsLCBoKSB7IHJldHVybiBub3JtKGEsIHksIGMsIGwsIGgsIGVxKX1cbn1cbiIsIi8qKlxuICogQml0IHR3aWRkbGluZyBoYWNrcyBmb3IgSmF2YVNjcmlwdC5cbiAqXG4gKiBBdXRob3I6IE1pa29sYSBMeXNlbmtvXG4gKlxuICogUG9ydGVkIGZyb20gU3RhbmZvcmQgYml0IHR3aWRkbGluZyBoYWNrIGxpYnJhcnk6XG4gKiAgICBodHRwOi8vZ3JhcGhpY3Muc3RhbmZvcmQuZWR1L35zZWFuZGVyL2JpdGhhY2tzLmh0bWxcbiAqL1xuXG5cInVzZSBzdHJpY3RcIjsgXCJ1c2UgcmVzdHJpY3RcIjtcblxuLy9OdW1iZXIgb2YgYml0cyBpbiBhbiBpbnRlZ2VyXG52YXIgSU5UX0JJVFMgPSAzMjtcblxuLy9Db25zdGFudHNcbmV4cG9ydHMuSU5UX0JJVFMgID0gSU5UX0JJVFM7XG5leHBvcnRzLklOVF9NQVggICA9ICAweDdmZmZmZmZmO1xuZXhwb3J0cy5JTlRfTUlOICAgPSAtMTw8KElOVF9CSVRTLTEpO1xuXG4vL1JldHVybnMgLTEsIDAsICsxIGRlcGVuZGluZyBvbiBzaWduIG9mIHhcbmV4cG9ydHMuc2lnbiA9IGZ1bmN0aW9uKHYpIHtcbiAgcmV0dXJuICh2ID4gMCkgLSAodiA8IDApO1xufVxuXG4vL0NvbXB1dGVzIGFic29sdXRlIHZhbHVlIG9mIGludGVnZXJcbmV4cG9ydHMuYWJzID0gZnVuY3Rpb24odikge1xuICB2YXIgbWFzayA9IHYgPj4gKElOVF9CSVRTLTEpO1xuICByZXR1cm4gKHYgXiBtYXNrKSAtIG1hc2s7XG59XG5cbi8vQ29tcHV0ZXMgbWluaW11bSBvZiBpbnRlZ2VycyB4IGFuZCB5XG5leHBvcnRzLm1pbiA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgcmV0dXJuIHkgXiAoKHggXiB5KSAmIC0oeCA8IHkpKTtcbn1cblxuLy9Db21wdXRlcyBtYXhpbXVtIG9mIGludGVnZXJzIHggYW5kIHlcbmV4cG9ydHMubWF4ID0gZnVuY3Rpb24oeCwgeSkge1xuICByZXR1cm4geCBeICgoeCBeIHkpICYgLSh4IDwgeSkpO1xufVxuXG4vL0NoZWNrcyBpZiBhIG51bWJlciBpcyBhIHBvd2VyIG9mIHR3b1xuZXhwb3J0cy5pc1BvdzIgPSBmdW5jdGlvbih2KSB7XG4gIHJldHVybiAhKHYgJiAodi0xKSkgJiYgKCEhdik7XG59XG5cbi8vQ29tcHV0ZXMgbG9nIGJhc2UgMiBvZiB2XG5leHBvcnRzLmxvZzIgPSBmdW5jdGlvbih2KSB7XG4gIHZhciByLCBzaGlmdDtcbiAgciA9ICAgICAodiA+IDB4RkZGRikgPDwgNDsgdiA+Pj49IHI7XG4gIHNoaWZ0ID0gKHYgPiAweEZGICApIDw8IDM7IHYgPj4+PSBzaGlmdDsgciB8PSBzaGlmdDtcbiAgc2hpZnQgPSAodiA+IDB4RiAgICkgPDwgMjsgdiA+Pj49IHNoaWZ0OyByIHw9IHNoaWZ0O1xuICBzaGlmdCA9ICh2ID4gMHgzICAgKSA8PCAxOyB2ID4+Pj0gc2hpZnQ7IHIgfD0gc2hpZnQ7XG4gIHJldHVybiByIHwgKHYgPj4gMSk7XG59XG5cbi8vQ29tcHV0ZXMgbG9nIGJhc2UgMTAgb2YgdlxuZXhwb3J0cy5sb2cxMCA9IGZ1bmN0aW9uKHYpIHtcbiAgcmV0dXJuICAodiA+PSAxMDAwMDAwMDAwKSA/IDkgOiAodiA+PSAxMDAwMDAwMDApID8gOCA6ICh2ID49IDEwMDAwMDAwKSA/IDcgOlxuICAgICAgICAgICh2ID49IDEwMDAwMDApID8gNiA6ICh2ID49IDEwMDAwMCkgPyA1IDogKHYgPj0gMTAwMDApID8gNCA6XG4gICAgICAgICAgKHYgPj0gMTAwMCkgPyAzIDogKHYgPj0gMTAwKSA/IDIgOiAodiA+PSAxMCkgPyAxIDogMDtcbn1cblxuLy9Db3VudHMgbnVtYmVyIG9mIGJpdHNcbmV4cG9ydHMucG9wQ291bnQgPSBmdW5jdGlvbih2KSB7XG4gIHYgPSB2IC0gKCh2ID4+PiAxKSAmIDB4NTU1NTU1NTUpO1xuICB2ID0gKHYgJiAweDMzMzMzMzMzKSArICgodiA+Pj4gMikgJiAweDMzMzMzMzMzKTtcbiAgcmV0dXJuICgodiArICh2ID4+PiA0KSAmIDB4RjBGMEYwRikgKiAweDEwMTAxMDEpID4+PiAyNDtcbn1cblxuLy9Db3VudHMgbnVtYmVyIG9mIHRyYWlsaW5nIHplcm9zXG5mdW5jdGlvbiBjb3VudFRyYWlsaW5nWmVyb3Modikge1xuICB2YXIgYyA9IDMyO1xuICB2ICY9IC12O1xuICBpZiAodikgYy0tO1xuICBpZiAodiAmIDB4MDAwMEZGRkYpIGMgLT0gMTY7XG4gIGlmICh2ICYgMHgwMEZGMDBGRikgYyAtPSA4O1xuICBpZiAodiAmIDB4MEYwRjBGMEYpIGMgLT0gNDtcbiAgaWYgKHYgJiAweDMzMzMzMzMzKSBjIC09IDI7XG4gIGlmICh2ICYgMHg1NTU1NTU1NSkgYyAtPSAxO1xuICByZXR1cm4gYztcbn1cbmV4cG9ydHMuY291bnRUcmFpbGluZ1plcm9zID0gY291bnRUcmFpbGluZ1plcm9zO1xuXG4vL1JvdW5kcyB0byBuZXh0IHBvd2VyIG9mIDJcbmV4cG9ydHMubmV4dFBvdzIgPSBmdW5jdGlvbih2KSB7XG4gIHYgKz0gdiA9PT0gMDtcbiAgLS12O1xuICB2IHw9IHYgPj4+IDE7XG4gIHYgfD0gdiA+Pj4gMjtcbiAgdiB8PSB2ID4+PiA0O1xuICB2IHw9IHYgPj4+IDg7XG4gIHYgfD0gdiA+Pj4gMTY7XG4gIHJldHVybiB2ICsgMTtcbn1cblxuLy9Sb3VuZHMgZG93biB0byBwcmV2aW91cyBwb3dlciBvZiAyXG5leHBvcnRzLnByZXZQb3cyID0gZnVuY3Rpb24odikge1xuICB2IHw9IHYgPj4+IDE7XG4gIHYgfD0gdiA+Pj4gMjtcbiAgdiB8PSB2ID4+PiA0O1xuICB2IHw9IHYgPj4+IDg7XG4gIHYgfD0gdiA+Pj4gMTY7XG4gIHJldHVybiB2IC0gKHY+Pj4xKTtcbn1cblxuLy9Db21wdXRlcyBwYXJpdHkgb2Ygd29yZFxuZXhwb3J0cy5wYXJpdHkgPSBmdW5jdGlvbih2KSB7XG4gIHYgXj0gdiA+Pj4gMTY7XG4gIHYgXj0gdiA+Pj4gODtcbiAgdiBePSB2ID4+PiA0O1xuICB2ICY9IDB4ZjtcbiAgcmV0dXJuICgweDY5OTYgPj4+IHYpICYgMTtcbn1cblxudmFyIFJFVkVSU0VfVEFCTEUgPSBuZXcgQXJyYXkoMjU2KTtcblxuKGZ1bmN0aW9uKHRhYikge1xuICBmb3IodmFyIGk9MDsgaTwyNTY7ICsraSkge1xuICAgIHZhciB2ID0gaSwgciA9IGksIHMgPSA3O1xuICAgIGZvciAodiA+Pj49IDE7IHY7IHYgPj4+PSAxKSB7XG4gICAgICByIDw8PSAxO1xuICAgICAgciB8PSB2ICYgMTtcbiAgICAgIC0tcztcbiAgICB9XG4gICAgdGFiW2ldID0gKHIgPDwgcykgJiAweGZmO1xuICB9XG59KShSRVZFUlNFX1RBQkxFKTtcblxuLy9SZXZlcnNlIGJpdHMgaW4gYSAzMiBiaXQgd29yZFxuZXhwb3J0cy5yZXZlcnNlID0gZnVuY3Rpb24odikge1xuICByZXR1cm4gIChSRVZFUlNFX1RBQkxFWyB2ICAgICAgICAgJiAweGZmXSA8PCAyNCkgfFxuICAgICAgICAgIChSRVZFUlNFX1RBQkxFWyh2ID4+PiA4KSAgJiAweGZmXSA8PCAxNikgfFxuICAgICAgICAgIChSRVZFUlNFX1RBQkxFWyh2ID4+PiAxNikgJiAweGZmXSA8PCA4KSAgfFxuICAgICAgICAgICBSRVZFUlNFX1RBQkxFWyh2ID4+PiAyNCkgJiAweGZmXTtcbn1cblxuLy9JbnRlcmxlYXZlIGJpdHMgb2YgMiBjb29yZGluYXRlcyB3aXRoIDE2IGJpdHMuICBVc2VmdWwgZm9yIGZhc3QgcXVhZHRyZWUgY29kZXNcbmV4cG9ydHMuaW50ZXJsZWF2ZTIgPSBmdW5jdGlvbih4LCB5KSB7XG4gIHggJj0gMHhGRkZGO1xuICB4ID0gKHggfCAoeCA8PCA4KSkgJiAweDAwRkYwMEZGO1xuICB4ID0gKHggfCAoeCA8PCA0KSkgJiAweDBGMEYwRjBGO1xuICB4ID0gKHggfCAoeCA8PCAyKSkgJiAweDMzMzMzMzMzO1xuICB4ID0gKHggfCAoeCA8PCAxKSkgJiAweDU1NTU1NTU1O1xuXG4gIHkgJj0gMHhGRkZGO1xuICB5ID0gKHkgfCAoeSA8PCA4KSkgJiAweDAwRkYwMEZGO1xuICB5ID0gKHkgfCAoeSA8PCA0KSkgJiAweDBGMEYwRjBGO1xuICB5ID0gKHkgfCAoeSA8PCAyKSkgJiAweDMzMzMzMzMzO1xuICB5ID0gKHkgfCAoeSA8PCAxKSkgJiAweDU1NTU1NTU1O1xuXG4gIHJldHVybiB4IHwgKHkgPDwgMSk7XG59XG5cbi8vRXh0cmFjdHMgdGhlIG50aCBpbnRlcmxlYXZlZCBjb21wb25lbnRcbmV4cG9ydHMuZGVpbnRlcmxlYXZlMiA9IGZ1bmN0aW9uKHYsIG4pIHtcbiAgdiA9ICh2ID4+PiBuKSAmIDB4NTU1NTU1NTU7XG4gIHYgPSAodiB8ICh2ID4+PiAxKSkgICYgMHgzMzMzMzMzMztcbiAgdiA9ICh2IHwgKHYgPj4+IDIpKSAgJiAweDBGMEYwRjBGO1xuICB2ID0gKHYgfCAodiA+Pj4gNCkpICAmIDB4MDBGRjAwRkY7XG4gIHYgPSAodiB8ICh2ID4+PiAxNikpICYgMHgwMDBGRkZGO1xuICByZXR1cm4gKHYgPDwgMTYpID4+IDE2O1xufVxuXG5cbi8vSW50ZXJsZWF2ZSBiaXRzIG9mIDMgY29vcmRpbmF0ZXMsIGVhY2ggd2l0aCAxMCBiaXRzLiAgVXNlZnVsIGZvciBmYXN0IG9jdHJlZSBjb2Rlc1xuZXhwb3J0cy5pbnRlcmxlYXZlMyA9IGZ1bmN0aW9uKHgsIHksIHopIHtcbiAgeCAmPSAweDNGRjtcbiAgeCAgPSAoeCB8ICh4PDwxNikpICYgNDI3ODE5MDMzNTtcbiAgeCAgPSAoeCB8ICh4PDw4KSkgICYgMjUxNzE5Njk1O1xuICB4ICA9ICh4IHwgKHg8PDQpKSAgJiAzMjcyMzU2MDM1O1xuICB4ICA9ICh4IHwgKHg8PDIpKSAgJiAxMjI3MTMzNTEzO1xuXG4gIHkgJj0gMHgzRkY7XG4gIHkgID0gKHkgfCAoeTw8MTYpKSAmIDQyNzgxOTAzMzU7XG4gIHkgID0gKHkgfCAoeTw8OCkpICAmIDI1MTcxOTY5NTtcbiAgeSAgPSAoeSB8ICh5PDw0KSkgICYgMzI3MjM1NjAzNTtcbiAgeSAgPSAoeSB8ICh5PDwyKSkgICYgMTIyNzEzMzUxMztcbiAgeCB8PSAoeSA8PCAxKTtcbiAgXG4gIHogJj0gMHgzRkY7XG4gIHogID0gKHogfCAoejw8MTYpKSAmIDQyNzgxOTAzMzU7XG4gIHogID0gKHogfCAoejw8OCkpICAmIDI1MTcxOTY5NTtcbiAgeiAgPSAoeiB8ICh6PDw0KSkgICYgMzI3MjM1NjAzNTtcbiAgeiAgPSAoeiB8ICh6PDwyKSkgICYgMTIyNzEzMzUxMztcbiAgXG4gIHJldHVybiB4IHwgKHogPDwgMik7XG59XG5cbi8vRXh0cmFjdHMgbnRoIGludGVybGVhdmVkIGNvbXBvbmVudCBvZiBhIDMtdHVwbGVcbmV4cG9ydHMuZGVpbnRlcmxlYXZlMyA9IGZ1bmN0aW9uKHYsIG4pIHtcbiAgdiA9ICh2ID4+PiBuKSAgICAgICAmIDEyMjcxMzM1MTM7XG4gIHYgPSAodiB8ICh2Pj4+MikpICAgJiAzMjcyMzU2MDM1O1xuICB2ID0gKHYgfCAodj4+PjQpKSAgICYgMjUxNzE5Njk1O1xuICB2ID0gKHYgfCAodj4+PjgpKSAgICYgNDI3ODE5MDMzNTtcbiAgdiA9ICh2IHwgKHY+Pj4xNikpICAmIDB4M0ZGO1xuICByZXR1cm4gKHY8PDIyKT4+MjI7XG59XG5cbi8vQ29tcHV0ZXMgbmV4dCBjb21iaW5hdGlvbiBpbiBjb2xleGljb2dyYXBoaWMgb3JkZXIgKHRoaXMgaXMgbWlzdGFrZW5seSBjYWxsZWQgbmV4dFBlcm11dGF0aW9uIG9uIHRoZSBiaXQgdHdpZGRsaW5nIGhhY2tzIHBhZ2UpXG5leHBvcnRzLm5leHRDb21iaW5hdGlvbiA9IGZ1bmN0aW9uKHYpIHtcbiAgdmFyIHQgPSB2IHwgKHYgLSAxKTtcbiAgcmV0dXJuICh0ICsgMSkgfCAoKCh+dCAmIC1+dCkgLSAxKSA+Pj4gKGNvdW50VHJhaWxpbmdaZXJvcyh2KSArIDEpKTtcbn1cblxuIiwiJ3VzZSBzdHJpY3QnXG5cbm1vZHVsZS5leHBvcnRzID0gYm94SW50ZXJzZWN0V3JhcHBlclxuXG52YXIgcG9vbCA9IHJlcXVpcmUoJ3R5cGVkYXJyYXktcG9vbCcpXG52YXIgc3dlZXAgPSByZXF1aXJlKCcuL2xpYi9zd2VlcCcpXG52YXIgYm94SW50ZXJzZWN0SXRlciA9IHJlcXVpcmUoJy4vbGliL2ludGVyc2VjdCcpXG5cbmZ1bmN0aW9uIGJveEVtcHR5KGQsIGJveCkge1xuICBmb3IodmFyIGo9MDsgajxkOyArK2opIHtcbiAgICBpZighKGJveFtqXSA8PSBib3hbaitkXSkpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG4vL1VucGFjayBib3hlcyBpbnRvIGEgZmxhdCB0eXBlZCBhcnJheSwgcmVtb3ZlIGVtcHR5IGJveGVzXG5mdW5jdGlvbiBjb252ZXJ0Qm94ZXMoYm94ZXMsIGQsIGRhdGEsIGlkcykge1xuICB2YXIgcHRyID0gMFxuICB2YXIgY291bnQgPSAwXG4gIGZvcih2YXIgaT0wLCBuPWJveGVzLmxlbmd0aDsgaTxuOyArK2kpIHtcbiAgICB2YXIgYiA9IGJveGVzW2ldXG4gICAgaWYoYm94RW1wdHkoZCwgYikpIHtcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuICAgIGZvcih2YXIgaj0wOyBqPDIqZDsgKytqKSB7XG4gICAgICBkYXRhW3B0cisrXSA9IGJbal1cbiAgICB9XG4gICAgaWRzW2NvdW50KytdID0gaVxuICB9XG4gIHJldHVybiBjb3VudFxufVxuXG4vL1BlcmZvcm0gdHlwZSBjb252ZXJzaW9ucywgY2hlY2sgYm91bmRzXG5mdW5jdGlvbiBib3hJbnRlcnNlY3QocmVkLCBibHVlLCB2aXNpdCwgZnVsbCkge1xuICB2YXIgbiA9IHJlZC5sZW5ndGhcbiAgdmFyIG0gPSBibHVlLmxlbmd0aFxuXG4gIC8vSWYgZWl0aGVyIGFycmF5IGlzIGVtcHR5LCB0aGVuIHdlIGNhbiBza2lwIHRoaXMgd2hvbGUgdGhpbmdcbiAgaWYobiA8PSAwIHx8IG0gPD0gMCkge1xuICAgIHJldHVyblxuICB9XG5cbiAgLy9Db21wdXRlIGRpbWVuc2lvbiwgaWYgaXQgaXMgMCB0aGVuIHdlIHNraXBcbiAgdmFyIGQgPSAocmVkWzBdLmxlbmd0aCk+Pj4xXG4gIGlmKGQgPD0gMCkge1xuICAgIHJldHVyblxuICB9XG5cbiAgdmFyIHJldHZhbFxuXG4gIC8vQ29udmVydCByZWQgYm94ZXNcbiAgdmFyIHJlZExpc3QgID0gcG9vbC5tYWxsb2NEb3VibGUoMipkKm4pXG4gIHZhciByZWRJZHMgICA9IHBvb2wubWFsbG9jSW50MzIobilcbiAgbiA9IGNvbnZlcnRCb3hlcyhyZWQsIGQsIHJlZExpc3QsIHJlZElkcylcblxuICBpZihuID4gMCkge1xuICAgIGlmKGQgPT09IDEgJiYgZnVsbCkge1xuICAgICAgLy9TcGVjaWFsIGNhc2U6IDFkIGNvbXBsZXRlXG4gICAgICBzd2VlcC5pbml0KG4pXG4gICAgICByZXR2YWwgPSBzd2VlcC5zd2VlcENvbXBsZXRlKFxuICAgICAgICBkLCB2aXNpdCwgXG4gICAgICAgIDAsIG4sIHJlZExpc3QsIHJlZElkcyxcbiAgICAgICAgMCwgbiwgcmVkTGlzdCwgcmVkSWRzKVxuICAgIH0gZWxzZSB7XG5cbiAgICAgIC8vQ29udmVydCBibHVlIGJveGVzXG4gICAgICB2YXIgYmx1ZUxpc3QgPSBwb29sLm1hbGxvY0RvdWJsZSgyKmQqbSlcbiAgICAgIHZhciBibHVlSWRzICA9IHBvb2wubWFsbG9jSW50MzIobSlcbiAgICAgIG0gPSBjb252ZXJ0Qm94ZXMoYmx1ZSwgZCwgYmx1ZUxpc3QsIGJsdWVJZHMpXG5cbiAgICAgIGlmKG0gPiAwKSB7XG4gICAgICAgIHN3ZWVwLmluaXQobittKVxuXG4gICAgICAgIGlmKGQgPT09IDEpIHtcbiAgICAgICAgICAvL1NwZWNpYWwgY2FzZTogMWQgYmlwYXJ0aXRlXG4gICAgICAgICAgcmV0dmFsID0gc3dlZXAuc3dlZXBCaXBhcnRpdGUoXG4gICAgICAgICAgICBkLCB2aXNpdCwgXG4gICAgICAgICAgICAwLCBuLCByZWRMaXN0LCAgcmVkSWRzLFxuICAgICAgICAgICAgMCwgbSwgYmx1ZUxpc3QsIGJsdWVJZHMpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy9HZW5lcmFsIGNhc2U6ICBkPjFcbiAgICAgICAgICByZXR2YWwgPSBib3hJbnRlcnNlY3RJdGVyKFxuICAgICAgICAgICAgZCwgdmlzaXQsICAgIGZ1bGwsXG4gICAgICAgICAgICBuLCByZWRMaXN0LCAgcmVkSWRzLFxuICAgICAgICAgICAgbSwgYmx1ZUxpc3QsIGJsdWVJZHMpXG4gICAgICAgIH1cblxuICAgICAgICBwb29sLmZyZWUoYmx1ZUxpc3QpXG4gICAgICAgIHBvb2wuZnJlZShibHVlSWRzKVxuICAgICAgfVxuICAgIH1cblxuICAgIHBvb2wuZnJlZShyZWRMaXN0KVxuICAgIHBvb2wuZnJlZShyZWRJZHMpXG4gIH1cblxuICByZXR1cm4gcmV0dmFsXG59XG5cblxudmFyIFJFU1VMVFxuXG5mdW5jdGlvbiBhcHBlbmRJdGVtKGksaikge1xuICBSRVNVTFQucHVzaChbaSxqXSlcbn1cblxuZnVuY3Rpb24gaW50ZXJzZWN0RnVsbEFycmF5KHgpIHtcbiAgUkVTVUxUID0gW11cbiAgYm94SW50ZXJzZWN0KHgsIHgsIGFwcGVuZEl0ZW0sIHRydWUpXG4gIHJldHVybiBSRVNVTFRcbn1cblxuZnVuY3Rpb24gaW50ZXJzZWN0QmlwYXJ0aXRlQXJyYXkoeCwgeSkge1xuICBSRVNVTFQgPSBbXVxuICBib3hJbnRlcnNlY3QoeCwgeSwgYXBwZW5kSXRlbSwgZmFsc2UpXG4gIHJldHVybiBSRVNVTFRcbn1cblxuLy9Vc2VyLWZyaWVuZGx5IHdyYXBwZXIsIGhhbmRsZSBmdWxsIGlucHV0IGFuZCBuby12aXNpdG9yIGNhc2VzXG5mdW5jdGlvbiBib3hJbnRlcnNlY3RXcmFwcGVyKGFyZzAsIGFyZzEsIGFyZzIpIHtcbiAgdmFyIHJlc3VsdFxuICBzd2l0Y2goYXJndW1lbnRzLmxlbmd0aCkge1xuICAgIGNhc2UgMTpcbiAgICAgIHJldHVybiBpbnRlcnNlY3RGdWxsQXJyYXkoYXJnMClcbiAgICBjYXNlIDI6XG4gICAgICBpZih0eXBlb2YgYXJnMSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gYm94SW50ZXJzZWN0KGFyZzAsIGFyZzAsIGFyZzEsIHRydWUpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gaW50ZXJzZWN0QmlwYXJ0aXRlQXJyYXkoYXJnMCwgYXJnMSlcbiAgICAgIH1cbiAgICBjYXNlIDM6XG4gICAgICByZXR1cm4gYm94SW50ZXJzZWN0KGFyZzAsIGFyZzEsIGFyZzIsIGZhbHNlKVxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JveC1pbnRlcnNlY3Q6IEludmFsaWQgYXJndW1lbnRzJylcbiAgfVxufSIsIid1c2Ugc3RyaWN0J1xuXG52YXIgRElNRU5TSU9OICAgPSAnZCdcbnZhciBBWElTICAgICAgICA9ICdheCdcbnZhciBWSVNJVCAgICAgICA9ICd2didcbnZhciBGTElQICAgICAgICA9ICdmcCdcblxudmFyIEVMRU1fU0laRSAgID0gJ2VzJ1xuXG52YXIgUkVEX1NUQVJUICAgPSAncnMnXG52YXIgUkVEX0VORCAgICAgPSAncmUnXG52YXIgUkVEX0JPWEVTICAgPSAncmInXG52YXIgUkVEX0lOREVYICAgPSAncmknXG52YXIgUkVEX1BUUiAgICAgPSAncnAnXG5cbnZhciBCTFVFX1NUQVJUICA9ICdicydcbnZhciBCTFVFX0VORCAgICA9ICdiZSdcbnZhciBCTFVFX0JPWEVTICA9ICdiYidcbnZhciBCTFVFX0lOREVYICA9ICdiaSdcbnZhciBCTFVFX1BUUiAgICA9ICdicCdcblxudmFyIFJFVFZBTCAgICAgID0gJ3J2J1xuXG52YXIgSU5ORVJfTEFCRUwgPSAnUSdcblxudmFyIEFSR1MgPSBbXG4gIERJTUVOU0lPTixcbiAgQVhJUyxcbiAgVklTSVQsXG4gIFJFRF9TVEFSVCxcbiAgUkVEX0VORCxcbiAgUkVEX0JPWEVTLFxuICBSRURfSU5ERVgsXG4gIEJMVUVfU1RBUlQsXG4gIEJMVUVfRU5ELFxuICBCTFVFX0JPWEVTLFxuICBCTFVFX0lOREVYXG5dXG5cbmZ1bmN0aW9uIGdlbmVyYXRlQnJ1dGVGb3JjZShyZWRNYWpvciwgZmxpcCwgZnVsbCkge1xuICB2YXIgZnVuY05hbWUgPSAnYnJ1dGVGb3JjZScgKyBcbiAgICAocmVkTWFqb3IgPyAnUmVkJyA6ICdCbHVlJykgKyBcbiAgICAoZmxpcCA/ICdGbGlwJyA6ICcnKSArXG4gICAgKGZ1bGwgPyAnRnVsbCcgOiAnJylcblxuICB2YXIgY29kZSA9IFsnZnVuY3Rpb24gJywgZnVuY05hbWUsICcoJywgQVJHUy5qb2luKCksICcpeycsXG4gICAgJ3ZhciAnLCBFTEVNX1NJWkUsICc9MionLCBESU1FTlNJT04sICc7J11cblxuICB2YXIgcmVkTG9vcCA9IFxuICAgICdmb3IodmFyIGk9JyArIFJFRF9TVEFSVCArICcsJyArIFJFRF9QVFIgKyAnPScgKyBFTEVNX1NJWkUgKyAnKicgKyBSRURfU1RBUlQgKyAnOycgK1xuICAgICAgICAnaTwnICsgUkVEX0VORCArJzsnICtcbiAgICAgICAgJysraSwnICsgUkVEX1BUUiArICcrPScgKyBFTEVNX1NJWkUgKyAnKXsnICtcbiAgICAgICAgJ3ZhciB4MD0nICsgUkVEX0JPWEVTICsgJ1snICsgQVhJUyArICcrJyArIFJFRF9QVFIgKyAnXSwnICtcbiAgICAgICAgICAgICd4MT0nICsgUkVEX0JPWEVTICsgJ1snICsgQVhJUyArICcrJyArIFJFRF9QVFIgKyAnKycgKyBESU1FTlNJT04gKyAnXSwnICtcbiAgICAgICAgICAgICd4aT0nICsgUkVEX0lOREVYICsgJ1tpXTsnXG5cbiAgdmFyIGJsdWVMb29wID0gXG4gICAgJ2Zvcih2YXIgaj0nICsgQkxVRV9TVEFSVCArICcsJyArIEJMVUVfUFRSICsgJz0nICsgRUxFTV9TSVpFICsgJyonICsgQkxVRV9TVEFSVCArICc7JyArXG4gICAgICAgICdqPCcgKyBCTFVFX0VORCArICc7JyArXG4gICAgICAgICcrK2osJyArIEJMVUVfUFRSICsgJys9JyArIEVMRU1fU0laRSArICcpeycgK1xuICAgICAgICAndmFyIHkwPScgKyBCTFVFX0JPWEVTICsgJ1snICsgQVhJUyArICcrJyArIEJMVUVfUFRSICsgJ10sJyArXG4gICAgICAgICAgICAoZnVsbCA/ICd5MT0nICsgQkxVRV9CT1hFUyArICdbJyArIEFYSVMgKyAnKycgKyBCTFVFX1BUUiArICcrJyArIERJTUVOU0lPTiArICddLCcgOiAnJykgK1xuICAgICAgICAgICAgJ3lpPScgKyBCTFVFX0lOREVYICsgJ1tqXTsnXG5cbiAgaWYocmVkTWFqb3IpIHtcbiAgICBjb2RlLnB1c2gocmVkTG9vcCwgSU5ORVJfTEFCRUwsICc6JywgYmx1ZUxvb3ApXG4gIH0gZWxzZSB7XG4gICAgY29kZS5wdXNoKGJsdWVMb29wLCBJTk5FUl9MQUJFTCwgJzonLCByZWRMb29wKVxuICB9XG5cbiAgaWYoZnVsbCkge1xuICAgIGNvZGUucHVzaCgnaWYoeTE8eDB8fHgxPHkwKWNvbnRpbnVlOycpXG4gIH0gZWxzZSBpZihmbGlwKSB7XG4gICAgY29kZS5wdXNoKCdpZih5MDw9eDB8fHgxPHkwKWNvbnRpbnVlOycpXG4gIH0gZWxzZSB7XG4gICAgY29kZS5wdXNoKCdpZih5MDx4MHx8eDE8eTApY29udGludWU7JylcbiAgfVxuXG4gIGNvZGUucHVzaCgnZm9yKHZhciBrPScrQVhJUysnKzE7azwnK0RJTUVOU0lPTisnOysrayl7JytcbiAgICAndmFyIHIwPScrUkVEX0JPWEVTKydbaysnK1JFRF9QVFIrJ10sJytcbiAgICAgICAgJ3IxPScrUkVEX0JPWEVTKydbaysnK0RJTUVOU0lPTisnKycrUkVEX1BUUisnXSwnK1xuICAgICAgICAnYjA9JytCTFVFX0JPWEVTKydbaysnK0JMVUVfUFRSKyddLCcrXG4gICAgICAgICdiMT0nK0JMVUVfQk9YRVMrJ1trKycrRElNRU5TSU9OKycrJytCTFVFX1BUUisnXTsnK1xuICAgICAgJ2lmKHIxPGIwfHxiMTxyMCljb250aW51ZSAnICsgSU5ORVJfTEFCRUwgKyAnO30nICtcbiAgICAgICd2YXIgJyArIFJFVFZBTCArICc9JyArIFZJU0lUICsgJygnKVxuXG4gIGlmKGZsaXApIHtcbiAgICBjb2RlLnB1c2goJ3lpLHhpJylcbiAgfSBlbHNlIHtcbiAgICBjb2RlLnB1c2goJ3hpLHlpJylcbiAgfVxuXG4gIGNvZGUucHVzaCgnKTtpZignICsgUkVUVkFMICsgJyE9PXZvaWQgMClyZXR1cm4gJyArIFJFVFZBTCArICc7fX19JylcblxuICByZXR1cm4ge1xuICAgIG5hbWU6IGZ1bmNOYW1lLCBcbiAgICBjb2RlOiBjb2RlLmpvaW4oJycpXG4gIH1cbn1cblxuZnVuY3Rpb24gYnJ1dGVGb3JjZVBsYW5uZXIoZnVsbCkge1xuICB2YXIgZnVuY05hbWUgPSAnYnJ1dGVGb3JjZScgKyAoZnVsbCA/ICdGdWxsJyA6ICdQYXJ0aWFsJylcbiAgdmFyIHByZWZpeCA9IFtdXG4gIHZhciBmYXJncyA9IEFSR1Muc2xpY2UoKVxuICBpZighZnVsbCkge1xuICAgIGZhcmdzLnNwbGljZSgzLCAwLCBGTElQKVxuICB9XG5cbiAgdmFyIGNvZGUgPSBbJ2Z1bmN0aW9uICcgKyBmdW5jTmFtZSArICcoJyArIGZhcmdzLmpvaW4oKSArICcpeyddXG5cbiAgZnVuY3Rpb24gaW52b2tlKHJlZE1ham9yLCBmbGlwKSB7XG4gICAgdmFyIHJlcyA9IGdlbmVyYXRlQnJ1dGVGb3JjZShyZWRNYWpvciwgZmxpcCwgZnVsbClcbiAgICBwcmVmaXgucHVzaChyZXMuY29kZSlcbiAgICBjb2RlLnB1c2goJ3JldHVybiAnICsgcmVzLm5hbWUgKyAnKCcgKyBBUkdTLmpvaW4oKSArICcpOycpXG4gIH1cblxuICBjb2RlLnB1c2goJ2lmKCcgKyBSRURfRU5EICsgJy0nICsgUkVEX1NUQVJUICsgJz4nICtcbiAgICAgICAgICAgICAgICAgICAgQkxVRV9FTkQgKyAnLScgKyBCTFVFX1NUQVJUICsgJyl7JylcblxuICBpZihmdWxsKSB7XG4gICAgaW52b2tlKHRydWUsIGZhbHNlKVxuICAgIGNvZGUucHVzaCgnfWVsc2V7JylcbiAgICBpbnZva2UoZmFsc2UsIGZhbHNlKVxuICB9IGVsc2Uge1xuICAgIGNvZGUucHVzaCgnaWYoJyArIEZMSVAgKyAnKXsnKVxuICAgIGludm9rZSh0cnVlLCB0cnVlKVxuICAgIGNvZGUucHVzaCgnfWVsc2V7JylcbiAgICBpbnZva2UodHJ1ZSwgZmFsc2UpXG4gICAgY29kZS5wdXNoKCd9fWVsc2V7aWYoJyArIEZMSVAgKyAnKXsnKVxuICAgIGludm9rZShmYWxzZSwgdHJ1ZSlcbiAgICBjb2RlLnB1c2goJ31lbHNleycpXG4gICAgaW52b2tlKGZhbHNlLCBmYWxzZSlcbiAgICBjb2RlLnB1c2goJ30nKVxuICB9XG4gIGNvZGUucHVzaCgnfX1yZXR1cm4gJyArIGZ1bmNOYW1lKVxuXG4gIHZhciBjb2RlU3RyID0gcHJlZml4LmpvaW4oJycpICsgY29kZS5qb2luKCcnKVxuICB2YXIgcHJvYyA9IG5ldyBGdW5jdGlvbihjb2RlU3RyKVxuICByZXR1cm4gcHJvYygpXG59XG5cblxuZXhwb3J0cy5wYXJ0aWFsID0gYnJ1dGVGb3JjZVBsYW5uZXIoZmFsc2UpXG5leHBvcnRzLmZ1bGwgICAgPSBicnV0ZUZvcmNlUGxhbm5lcih0cnVlKSIsIid1c2Ugc3RyaWN0J1xuXG5tb2R1bGUuZXhwb3J0cyA9IGJveEludGVyc2VjdEl0ZXJcblxudmFyIHBvb2wgPSByZXF1aXJlKCd0eXBlZGFycmF5LXBvb2wnKVxudmFyIGJpdHMgPSByZXF1aXJlKCdiaXQtdHdpZGRsZScpXG52YXIgYnJ1dGVGb3JjZSA9IHJlcXVpcmUoJy4vYnJ1dGUnKVxudmFyIGJydXRlRm9yY2VQYXJ0aWFsID0gYnJ1dGVGb3JjZS5wYXJ0aWFsXG52YXIgYnJ1dGVGb3JjZUZ1bGwgPSBicnV0ZUZvcmNlLmZ1bGxcbnZhciBzd2VlcCA9IHJlcXVpcmUoJy4vc3dlZXAnKVxudmFyIGZpbmRNZWRpYW4gPSByZXF1aXJlKCcuL21lZGlhbicpXG52YXIgZ2VuUGFydGl0aW9uID0gcmVxdWlyZSgnLi9wYXJ0aXRpb24nKVxuXG4vL1R3aWRkbGUgcGFyYW1ldGVyc1xudmFyIEJSVVRFX0ZPUkNFX0NVVE9GRiAgICA9IDEyOCAgICAgICAvL0N1dCBvZmYgZm9yIGJydXRlIGZvcmNlIHNlYXJjaFxudmFyIFNDQU5fQ1VUT0ZGICAgICAgICAgICA9ICgxPDwyMikgICAvL0N1dCBvZmYgZm9yIHR3byB3YXkgc2NhblxudmFyIFNDQU5fQ09NUExFVEVfQ1VUT0ZGICA9ICgxPDwyMikgIFxuXG4vL1BhcnRpdGlvbiBmdW5jdGlvbnNcbnZhciBwYXJ0aXRpb25JbnRlcmlvckNvbnRhaW5zSW50ZXJ2YWwgPSBnZW5QYXJ0aXRpb24oXG4gICchKGxvPj1wMCkmJiEocDE+PWhpKScsIFxuICBbJ3AwJywgJ3AxJ10pXG5cbnZhciBwYXJ0aXRpb25TdGFydEVxdWFsID0gZ2VuUGFydGl0aW9uKFxuICAnbG89PT1wMCcsXG4gIFsncDAnXSlcblxudmFyIHBhcnRpdGlvblN0YXJ0TGVzc1RoYW4gPSBnZW5QYXJ0aXRpb24oXG4gICdsbzxwMCcsXG4gIFsncDAnXSlcblxudmFyIHBhcnRpdGlvbkVuZExlc3NUaGFuRXF1YWwgPSBnZW5QYXJ0aXRpb24oXG4gICdoaTw9cDAnLFxuICBbJ3AwJ10pXG5cbnZhciBwYXJ0aXRpb25Db250YWluc1BvaW50ID0gZ2VuUGFydGl0aW9uKFxuICAnbG88PXAwJiZwMDw9aGknLFxuICBbJ3AwJ10pXG5cbnZhciBwYXJ0aXRpb25Db250YWluc1BvaW50UHJvcGVyID0gZ2VuUGFydGl0aW9uKFxuICAnbG88cDAmJnAwPD1oaScsXG4gIFsncDAnXSlcblxuLy9GcmFtZSBzaXplIGZvciBpdGVyYXRpdmUgbG9vcFxudmFyIElGUkFNRV9TSVpFID0gNlxudmFyIERGUkFNRV9TSVpFID0gMlxuXG4vL0RhdGEgZm9yIGJveCBzdGF0Y2tcbnZhciBJTklUX0NBUEFDSVRZID0gMTAyNFxudmFyIEJPWF9JU1RBQ0sgID0gcG9vbC5tYWxsb2NJbnQzMihJTklUX0NBUEFDSVRZKVxudmFyIEJPWF9EU1RBQ0sgID0gcG9vbC5tYWxsb2NEb3VibGUoSU5JVF9DQVBBQ0lUWSlcblxuLy9Jbml0aWFsaXplIGl0ZXJhdGl2ZSBsb29wIHF1ZXVlXG5mdW5jdGlvbiBpdGVySW5pdChkLCBjb3VudCkge1xuICB2YXIgbGV2ZWxzID0gKDggKiBiaXRzLmxvZzIoY291bnQrMSkgKiAoZCsxKSl8MFxuICB2YXIgbWF4SW50cyA9IGJpdHMubmV4dFBvdzIoSUZSQU1FX1NJWkUqbGV2ZWxzKVxuICBpZihCT1hfSVNUQUNLLmxlbmd0aCA8IG1heEludHMpIHtcbiAgICBwb29sLmZyZWUoQk9YX0lTVEFDSylcbiAgICBCT1hfSVNUQUNLID0gcG9vbC5tYWxsb2NJbnQzMihtYXhJbnRzKVxuICB9XG4gIHZhciBtYXhEb3VibGVzID0gYml0cy5uZXh0UG93MihERlJBTUVfU0laRSpsZXZlbHMpXG4gIGlmKEJPWF9EU1RBQ0subGVuZ3RoIDwgbWF4RG91Ymxlcykge1xuICAgIHBvb2wuZnJlZShCT1hfRFNUQUNLKVxuICAgIEJPWF9EU1RBQ0sgPSBwb29sLm1hbGxvY0RvdWJsZShtYXhEb3VibGVzKVxuICB9XG59XG5cbi8vQXBwZW5kIGl0ZW0gdG8gcXVldWVcbmZ1bmN0aW9uIGl0ZXJQdXNoKHB0cixcbiAgYXhpcywgXG4gIHJlZFN0YXJ0LCByZWRFbmQsIFxuICBibHVlU3RhcnQsIGJsdWVFbmQsIFxuICBzdGF0ZSwgXG4gIGxvLCBoaSkge1xuXG4gIHZhciBpcHRyID0gSUZSQU1FX1NJWkUgKiBwdHJcbiAgQk9YX0lTVEFDS1tpcHRyXSAgID0gYXhpc1xuICBCT1hfSVNUQUNLW2lwdHIrMV0gPSByZWRTdGFydFxuICBCT1hfSVNUQUNLW2lwdHIrMl0gPSByZWRFbmRcbiAgQk9YX0lTVEFDS1tpcHRyKzNdID0gYmx1ZVN0YXJ0XG4gIEJPWF9JU1RBQ0tbaXB0cis0XSA9IGJsdWVFbmRcbiAgQk9YX0lTVEFDS1tpcHRyKzVdID0gc3RhdGVcblxuICB2YXIgZHB0ciA9IERGUkFNRV9TSVpFICogcHRyXG4gIEJPWF9EU1RBQ0tbZHB0cl0gICA9IGxvXG4gIEJPWF9EU1RBQ0tbZHB0cisxXSA9IGhpXG59XG5cbi8vU3BlY2lhbCBjYXNlOiAgSW50ZXJzZWN0IHNpbmdsZSBwb2ludCB3aXRoIGxpc3Qgb2YgaW50ZXJ2YWxzXG5mdW5jdGlvbiBvbmVQb2ludFBhcnRpYWwoXG4gIGQsIGF4aXMsIHZpc2l0LCBmbGlwLFxuICByZWRTdGFydCwgcmVkRW5kLCByZWQsIHJlZEluZGV4LFxuICBibHVlT2Zmc2V0LCBibHVlLCBibHVlSWQpIHtcblxuICB2YXIgZWxlbVNpemUgPSAyICogZFxuICB2YXIgYmx1ZVB0ciAgPSBibHVlT2Zmc2V0ICogZWxlbVNpemVcbiAgdmFyIGJsdWVYICAgID0gYmx1ZVtibHVlUHRyICsgYXhpc11cblxucmVkX2xvb3A6XG4gIGZvcih2YXIgaT1yZWRTdGFydCwgcmVkUHRyPXJlZFN0YXJ0KmVsZW1TaXplOyBpPHJlZEVuZDsgKytpLCByZWRQdHIrPWVsZW1TaXplKSB7XG4gICAgdmFyIHIwID0gcmVkW3JlZFB0citheGlzXVxuICAgIHZhciByMSA9IHJlZFtyZWRQdHIrYXhpcytkXVxuICAgIGlmKGJsdWVYIDwgcjAgfHwgcjEgPCBibHVlWCkge1xuICAgICAgY29udGludWVcbiAgICB9XG4gICAgaWYoZmxpcCAmJiBibHVlWCA9PT0gcjApIHtcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuICAgIHZhciByZWRJZCA9IHJlZEluZGV4W2ldXG4gICAgZm9yKHZhciBqPWF4aXMrMTsgajxkOyArK2opIHtcbiAgICAgIHZhciByMCA9IHJlZFtyZWRQdHIral1cbiAgICAgIHZhciByMSA9IHJlZFtyZWRQdHIraitkXVxuICAgICAgdmFyIGIwID0gYmx1ZVtibHVlUHRyK2pdXG4gICAgICB2YXIgYjEgPSBibHVlW2JsdWVQdHIraitkXVxuICAgICAgaWYocjEgPCBiMCB8fCBiMSA8IHIwKSB7XG4gICAgICAgIGNvbnRpbnVlIHJlZF9sb29wXG4gICAgICB9XG4gICAgfVxuICAgIHZhciByZXR2YWxcbiAgICBpZihmbGlwKSB7XG4gICAgICByZXR2YWwgPSB2aXNpdChibHVlSWQsIHJlZElkKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR2YWwgPSB2aXNpdChyZWRJZCwgYmx1ZUlkKVxuICAgIH1cbiAgICBpZihyZXR2YWwgIT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIHJldHZhbFxuICAgIH1cbiAgfVxufVxuXG4vL1NwZWNpYWwgY2FzZTogIEludGVyc2VjdCBvbmUgcG9pbnQgd2l0aCBsaXN0IG9mIGludGVydmFsc1xuZnVuY3Rpb24gb25lUG9pbnRGdWxsKFxuICBkLCBheGlzLCB2aXNpdCxcbiAgcmVkU3RhcnQsIHJlZEVuZCwgcmVkLCByZWRJbmRleCxcbiAgYmx1ZU9mZnNldCwgYmx1ZSwgYmx1ZUlkKSB7XG5cbiAgdmFyIGVsZW1TaXplID0gMiAqIGRcbiAgdmFyIGJsdWVQdHIgID0gYmx1ZU9mZnNldCAqIGVsZW1TaXplXG4gIHZhciBibHVlWCAgICA9IGJsdWVbYmx1ZVB0ciArIGF4aXNdXG5cbnJlZF9sb29wOlxuICBmb3IodmFyIGk9cmVkU3RhcnQsIHJlZFB0cj1yZWRTdGFydCplbGVtU2l6ZTsgaTxyZWRFbmQ7ICsraSwgcmVkUHRyKz1lbGVtU2l6ZSkge1xuICAgIHZhciByZWRJZCA9IHJlZEluZGV4W2ldXG4gICAgaWYocmVkSWQgPT09IGJsdWVJZCkge1xuICAgICAgY29udGludWVcbiAgICB9XG4gICAgdmFyIHIwID0gcmVkW3JlZFB0citheGlzXVxuICAgIHZhciByMSA9IHJlZFtyZWRQdHIrYXhpcytkXVxuICAgIGlmKGJsdWVYIDwgcjAgfHwgcjEgPCBibHVlWCkge1xuICAgICAgY29udGludWVcbiAgICB9XG4gICAgZm9yKHZhciBqPWF4aXMrMTsgajxkOyArK2opIHtcbiAgICAgIHZhciByMCA9IHJlZFtyZWRQdHIral1cbiAgICAgIHZhciByMSA9IHJlZFtyZWRQdHIraitkXVxuICAgICAgdmFyIGIwID0gYmx1ZVtibHVlUHRyK2pdXG4gICAgICB2YXIgYjEgPSBibHVlW2JsdWVQdHIraitkXVxuICAgICAgaWYocjEgPCBiMCB8fCBiMSA8IHIwKSB7XG4gICAgICAgIGNvbnRpbnVlIHJlZF9sb29wXG4gICAgICB9XG4gICAgfVxuICAgIHZhciByZXR2YWwgPSB2aXNpdChyZWRJZCwgYmx1ZUlkKVxuICAgIGlmKHJldHZhbCAhPT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gcmV0dmFsXG4gICAgfVxuICB9XG59XG5cbi8vVGhlIG1haW4gYm94IGludGVyc2VjdGlvbiByb3V0aW5lXG5mdW5jdGlvbiBib3hJbnRlcnNlY3RJdGVyKFxuICBkLCB2aXNpdCwgaW5pdEZ1bGwsXG4gIHhTaXplLCB4Qm94ZXMsIHhJbmRleCxcbiAgeVNpemUsIHlCb3hlcywgeUluZGV4KSB7XG5cbiAgLy9SZXNlcnZlIG1lbW9yeSBmb3Igc3RhY2tcbiAgaXRlckluaXQoZCwgeFNpemUgKyB5U2l6ZSlcblxuICB2YXIgdG9wICA9IDBcbiAgdmFyIGVsZW1TaXplID0gMiAqIGRcbiAgdmFyIHJldHZhbFxuXG4gIGl0ZXJQdXNoKHRvcCsrLFxuICAgICAgMCxcbiAgICAgIDAsIHhTaXplLFxuICAgICAgMCwgeVNpemUsXG4gICAgICBpbml0RnVsbCA/IDE2IDogMCwgXG4gICAgICAtSW5maW5pdHksIEluZmluaXR5KVxuICBpZighaW5pdEZ1bGwpIHtcbiAgICBpdGVyUHVzaCh0b3ArKyxcbiAgICAgIDAsXG4gICAgICAwLCB5U2l6ZSxcbiAgICAgIDAsIHhTaXplLFxuICAgICAgMSwgXG4gICAgICAtSW5maW5pdHksIEluZmluaXR5KVxuICB9XG5cbiAgd2hpbGUodG9wID4gMCkge1xuICAgIHRvcCAgLT0gMVxuXG4gICAgdmFyIGlwdHIgPSB0b3AgKiBJRlJBTUVfU0laRVxuICAgIHZhciBheGlzICAgICAgPSBCT1hfSVNUQUNLW2lwdHJdXG4gICAgdmFyIHJlZFN0YXJ0ICA9IEJPWF9JU1RBQ0tbaXB0cisxXVxuICAgIHZhciByZWRFbmQgICAgPSBCT1hfSVNUQUNLW2lwdHIrMl1cbiAgICB2YXIgYmx1ZVN0YXJ0ID0gQk9YX0lTVEFDS1tpcHRyKzNdXG4gICAgdmFyIGJsdWVFbmQgICA9IEJPWF9JU1RBQ0tbaXB0cis0XVxuICAgIHZhciBzdGF0ZSAgICAgPSBCT1hfSVNUQUNLW2lwdHIrNV1cblxuICAgIHZhciBkcHRyID0gdG9wICogREZSQU1FX1NJWkVcbiAgICB2YXIgbG8gICAgICAgID0gQk9YX0RTVEFDS1tkcHRyXVxuICAgIHZhciBoaSAgICAgICAgPSBCT1hfRFNUQUNLW2RwdHIrMV1cblxuICAgIC8vVW5wYWNrIHN0YXRlIGluZm9cbiAgICB2YXIgZmxpcCAgICAgID0gKHN0YXRlICYgMSlcbiAgICB2YXIgZnVsbCAgICAgID0gISEoc3RhdGUgJiAxNilcblxuICAgIC8vVW5wYWNrIGluZGljZXNcbiAgICB2YXIgcmVkICAgICAgID0geEJveGVzXG4gICAgdmFyIHJlZEluZGV4ICA9IHhJbmRleFxuICAgIHZhciBibHVlICAgICAgPSB5Qm94ZXNcbiAgICB2YXIgYmx1ZUluZGV4ID0geUluZGV4XG4gICAgaWYoZmxpcCkge1xuICAgICAgcmVkICAgICAgICAgPSB5Qm94ZXNcbiAgICAgIHJlZEluZGV4ICAgID0geUluZGV4XG4gICAgICBibHVlICAgICAgICA9IHhCb3hlc1xuICAgICAgYmx1ZUluZGV4ICAgPSB4SW5kZXhcbiAgICB9XG5cbiAgICBpZihzdGF0ZSAmIDIpIHtcbiAgICAgIHJlZEVuZCA9IHBhcnRpdGlvblN0YXJ0TGVzc1RoYW4oXG4gICAgICAgIGQsIGF4aXMsXG4gICAgICAgIHJlZFN0YXJ0LCByZWRFbmQsIHJlZCwgcmVkSW5kZXgsXG4gICAgICAgIGhpKVxuICAgICAgaWYocmVkU3RhcnQgPj0gcmVkRW5kKSB7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG4gICAgfVxuICAgIGlmKHN0YXRlICYgNCkge1xuICAgICAgcmVkU3RhcnQgPSBwYXJ0aXRpb25FbmRMZXNzVGhhbkVxdWFsKFxuICAgICAgICBkLCBheGlzLFxuICAgICAgICByZWRTdGFydCwgcmVkRW5kLCByZWQsIHJlZEluZGV4LFxuICAgICAgICBsbylcbiAgICAgIGlmKHJlZFN0YXJ0ID49IHJlZEVuZCkge1xuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICB2YXIgcmVkQ291bnQgID0gcmVkRW5kICAtIHJlZFN0YXJ0XG4gICAgdmFyIGJsdWVDb3VudCA9IGJsdWVFbmQgLSBibHVlU3RhcnRcblxuICAgIGlmKGZ1bGwpIHtcbiAgICAgIGlmKGQgKiByZWRDb3VudCAqIChyZWRDb3VudCArIGJsdWVDb3VudCkgPCBTQ0FOX0NPTVBMRVRFX0NVVE9GRikge1xuICAgICAgICByZXR2YWwgPSBzd2VlcC5zY2FuQ29tcGxldGUoXG4gICAgICAgICAgZCwgYXhpcywgdmlzaXQsIFxuICAgICAgICAgIHJlZFN0YXJ0LCByZWRFbmQsIHJlZCwgcmVkSW5kZXgsXG4gICAgICAgICAgYmx1ZVN0YXJ0LCBibHVlRW5kLCBibHVlLCBibHVlSW5kZXgpXG4gICAgICAgIGlmKHJldHZhbCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgcmV0dXJuIHJldHZhbFxuICAgICAgICB9XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmKGQgKiBNYXRoLm1pbihyZWRDb3VudCwgYmx1ZUNvdW50KSA8IEJSVVRFX0ZPUkNFX0NVVE9GRikge1xuICAgICAgICAvL0lmIGlucHV0IHNtYWxsLCB0aGVuIHVzZSBicnV0ZSBmb3JjZVxuICAgICAgICByZXR2YWwgPSBicnV0ZUZvcmNlUGFydGlhbChcbiAgICAgICAgICAgIGQsIGF4aXMsIHZpc2l0LCBmbGlwLFxuICAgICAgICAgICAgcmVkU3RhcnQsICByZWRFbmQsICByZWQsICByZWRJbmRleCxcbiAgICAgICAgICAgIGJsdWVTdGFydCwgYmx1ZUVuZCwgYmx1ZSwgYmx1ZUluZGV4KVxuICAgICAgICBpZihyZXR2YWwgIT09IHZvaWQgMCkge1xuICAgICAgICAgIHJldHVybiByZXR2YWxcbiAgICAgICAgfVxuICAgICAgICBjb250aW51ZVxuICAgICAgfSBlbHNlIGlmKGQgKiByZWRDb3VudCAqIGJsdWVDb3VudCA8IFNDQU5fQ1VUT0ZGKSB7XG4gICAgICAgIC8vSWYgaW5wdXQgbWVkaXVtIHNpemVkLCB0aGVuIHVzZSBzd2VlcCBhbmQgcHJ1bmVcbiAgICAgICAgcmV0dmFsID0gc3dlZXAuc2NhbkJpcGFydGl0ZShcbiAgICAgICAgICBkLCBheGlzLCB2aXNpdCwgZmxpcCwgXG4gICAgICAgICAgcmVkU3RhcnQsIHJlZEVuZCwgcmVkLCByZWRJbmRleCxcbiAgICAgICAgICBibHVlU3RhcnQsIGJsdWVFbmQsIGJsdWUsIGJsdWVJbmRleClcbiAgICAgICAgaWYocmV0dmFsICE9PSB2b2lkIDApIHtcbiAgICAgICAgICByZXR1cm4gcmV0dmFsXG4gICAgICAgIH1cbiAgICAgICAgY29udGludWVcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLy9GaXJzdCwgZmluZCBhbGwgcmVkIGludGVydmFscyB3aG9zZSBpbnRlcmlvciBjb250YWlucyAobG8saGkpXG4gICAgdmFyIHJlZDAgPSBwYXJ0aXRpb25JbnRlcmlvckNvbnRhaW5zSW50ZXJ2YWwoXG4gICAgICBkLCBheGlzLCBcbiAgICAgIHJlZFN0YXJ0LCByZWRFbmQsIHJlZCwgcmVkSW5kZXgsXG4gICAgICBsbywgaGkpXG5cbiAgICAvL0xvd2VyIGRpbWVuc2lvbmFsIGNhc2VcbiAgICBpZihyZWRTdGFydCA8IHJlZDApIHtcblxuICAgICAgaWYoZCAqIChyZWQwIC0gcmVkU3RhcnQpIDwgQlJVVEVfRk9SQ0VfQ1VUT0ZGKSB7XG4gICAgICAgIC8vU3BlY2lhbCBjYXNlIGZvciBzbWFsbCBpbnB1dHM6IHVzZSBicnV0ZSBmb3JjZVxuICAgICAgICByZXR2YWwgPSBicnV0ZUZvcmNlRnVsbChcbiAgICAgICAgICBkLCBheGlzKzEsIHZpc2l0LFxuICAgICAgICAgIHJlZFN0YXJ0LCByZWQwLCByZWQsIHJlZEluZGV4LFxuICAgICAgICAgIGJsdWVTdGFydCwgYmx1ZUVuZCwgYmx1ZSwgYmx1ZUluZGV4KVxuICAgICAgICBpZihyZXR2YWwgIT09IHZvaWQgMCkge1xuICAgICAgICAgIHJldHVybiByZXR2YWxcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmKGF4aXMgPT09IGQtMikge1xuICAgICAgICBpZihmbGlwKSB7XG4gICAgICAgICAgcmV0dmFsID0gc3dlZXAuc3dlZXBCaXBhcnRpdGUoXG4gICAgICAgICAgICBkLCB2aXNpdCxcbiAgICAgICAgICAgIGJsdWVTdGFydCwgYmx1ZUVuZCwgYmx1ZSwgYmx1ZUluZGV4LFxuICAgICAgICAgICAgcmVkU3RhcnQsIHJlZDAsIHJlZCwgcmVkSW5kZXgpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dmFsID0gc3dlZXAuc3dlZXBCaXBhcnRpdGUoXG4gICAgICAgICAgICBkLCB2aXNpdCxcbiAgICAgICAgICAgIHJlZFN0YXJ0LCByZWQwLCByZWQsIHJlZEluZGV4LFxuICAgICAgICAgICAgYmx1ZVN0YXJ0LCBibHVlRW5kLCBibHVlLCBibHVlSW5kZXgpXG4gICAgICAgIH1cbiAgICAgICAgaWYocmV0dmFsICE9PSB2b2lkIDApIHtcbiAgICAgICAgICByZXR1cm4gcmV0dmFsXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGl0ZXJQdXNoKHRvcCsrLFxuICAgICAgICAgIGF4aXMrMSxcbiAgICAgICAgICByZWRTdGFydCwgcmVkMCxcbiAgICAgICAgICBibHVlU3RhcnQsIGJsdWVFbmQsXG4gICAgICAgICAgZmxpcCxcbiAgICAgICAgICAtSW5maW5pdHksIEluZmluaXR5KVxuICAgICAgICBpdGVyUHVzaCh0b3ArKyxcbiAgICAgICAgICBheGlzKzEsXG4gICAgICAgICAgYmx1ZVN0YXJ0LCBibHVlRW5kLFxuICAgICAgICAgIHJlZFN0YXJ0LCByZWQwLFxuICAgICAgICAgIGZsaXBeMSxcbiAgICAgICAgICAtSW5maW5pdHksIEluZmluaXR5KVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vRGl2aWRlIGFuZCBjb25xdWVyIHBoYXNlXG4gICAgaWYocmVkMCA8IHJlZEVuZCkge1xuXG4gICAgICAvL0N1dCBibHVlIGludG8gMyBwYXJ0czpcbiAgICAgIC8vXG4gICAgICAvLyAgUG9pbnRzIDwgbWlkIHBvaW50XG4gICAgICAvLyAgUG9pbnRzID0gbWlkIHBvaW50XG4gICAgICAvLyAgUG9pbnRzID4gbWlkIHBvaW50XG4gICAgICAvL1xuICAgICAgdmFyIGJsdWUwID0gZmluZE1lZGlhbihcbiAgICAgICAgZCwgYXhpcywgXG4gICAgICAgIGJsdWVTdGFydCwgYmx1ZUVuZCwgYmx1ZSwgYmx1ZUluZGV4KVxuICAgICAgdmFyIG1pZCA9IGJsdWVbZWxlbVNpemUgKiBibHVlMCArIGF4aXNdXG4gICAgICB2YXIgYmx1ZTEgPSBwYXJ0aXRpb25TdGFydEVxdWFsKFxuICAgICAgICBkLCBheGlzLFxuICAgICAgICBibHVlMCwgYmx1ZUVuZCwgYmx1ZSwgYmx1ZUluZGV4LFxuICAgICAgICBtaWQpXG5cbiAgICAgIC8vUmlnaHQgY2FzZVxuICAgICAgaWYoYmx1ZTEgPCBibHVlRW5kKSB7XG4gICAgICAgIGl0ZXJQdXNoKHRvcCsrLFxuICAgICAgICAgIGF4aXMsXG4gICAgICAgICAgcmVkMCwgcmVkRW5kLFxuICAgICAgICAgIGJsdWUxLCBibHVlRW5kLFxuICAgICAgICAgIChmbGlwfDQpICsgKGZ1bGwgPyAxNiA6IDApLFxuICAgICAgICAgIG1pZCwgaGkpXG4gICAgICB9XG5cbiAgICAgIC8vTGVmdCBjYXNlXG4gICAgICBpZihibHVlU3RhcnQgPCBibHVlMCkge1xuICAgICAgICBpdGVyUHVzaCh0b3ArKyxcbiAgICAgICAgICBheGlzLFxuICAgICAgICAgIHJlZDAsIHJlZEVuZCxcbiAgICAgICAgICBibHVlU3RhcnQsIGJsdWUwLFxuICAgICAgICAgIChmbGlwfDIpICsgKGZ1bGwgPyAxNiA6IDApLFxuICAgICAgICAgIGxvLCBtaWQpXG4gICAgICB9XG5cbiAgICAgIC8vQ2VudGVyIGNhc2UgKHRoZSBoYXJkIHBhcnQpXG4gICAgICBpZihibHVlMCArIDEgPT09IGJsdWUxKSB7XG4gICAgICAgIC8vT3B0aW1pemF0aW9uOiBSYW5nZSB3aXRoIGV4YWN0bHkgMSBwb2ludCwgdXNlIGEgYnJ1dGUgZm9yY2Ugc2NhblxuICAgICAgICBpZihmdWxsKSB7XG4gICAgICAgICAgcmV0dmFsID0gb25lUG9pbnRGdWxsKFxuICAgICAgICAgICAgZCwgYXhpcywgdmlzaXQsXG4gICAgICAgICAgICByZWQwLCByZWRFbmQsIHJlZCwgcmVkSW5kZXgsXG4gICAgICAgICAgICBibHVlMCwgYmx1ZSwgYmx1ZUluZGV4W2JsdWUwXSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR2YWwgPSBvbmVQb2ludFBhcnRpYWwoXG4gICAgICAgICAgICBkLCBheGlzLCB2aXNpdCwgZmxpcCxcbiAgICAgICAgICAgIHJlZDAsIHJlZEVuZCwgcmVkLCByZWRJbmRleCxcbiAgICAgICAgICAgIGJsdWUwLCBibHVlLCBibHVlSW5kZXhbYmx1ZTBdKVxuICAgICAgICB9XG4gICAgICAgIGlmKHJldHZhbCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgcmV0dXJuIHJldHZhbFxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYoYmx1ZTAgPCBibHVlMSkge1xuICAgICAgICB2YXIgcmVkMVxuICAgICAgICBpZihmdWxsKSB7XG4gICAgICAgICAgLy9JZiBmdWxsIGludGVyc2VjdGlvbiwgbmVlZCB0byBoYW5kbGUgc3BlY2lhbCBjYXNlXG4gICAgICAgICAgcmVkMSA9IHBhcnRpdGlvbkNvbnRhaW5zUG9pbnQoXG4gICAgICAgICAgICBkLCBheGlzLFxuICAgICAgICAgICAgcmVkMCwgcmVkRW5kLCByZWQsIHJlZEluZGV4LFxuICAgICAgICAgICAgbWlkKVxuICAgICAgICAgIGlmKHJlZDAgPCByZWQxKSB7XG4gICAgICAgICAgICB2YXIgcmVkWCA9IHBhcnRpdGlvblN0YXJ0RXF1YWwoXG4gICAgICAgICAgICAgIGQsIGF4aXMsXG4gICAgICAgICAgICAgIHJlZDAsIHJlZDEsIHJlZCwgcmVkSW5kZXgsXG4gICAgICAgICAgICAgIG1pZClcbiAgICAgICAgICAgIGlmKGF4aXMgPT09IGQtMikge1xuICAgICAgICAgICAgICAvL0RlZ2VuZXJhdGUgc3dlZXAgaW50ZXJzZWN0aW9uOlxuICAgICAgICAgICAgICAvLyAgW3JlZDAsIHJlZFhdIHdpdGggW2JsdWUwLCBibHVlMV1cbiAgICAgICAgICAgICAgaWYocmVkMCA8IHJlZFgpIHtcbiAgICAgICAgICAgICAgICByZXR2YWwgPSBzd2VlcC5zd2VlcENvbXBsZXRlKFxuICAgICAgICAgICAgICAgICAgZCwgdmlzaXQsXG4gICAgICAgICAgICAgICAgICByZWQwLCByZWRYLCByZWQsIHJlZEluZGV4LFxuICAgICAgICAgICAgICAgICAgYmx1ZTAsIGJsdWUxLCBibHVlLCBibHVlSW5kZXgpXG4gICAgICAgICAgICAgICAgaWYocmV0dmFsICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiByZXR2YWxcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAvL05vcm1hbCBzd2VlcCBpbnRlcnNlY3Rpb246XG4gICAgICAgICAgICAgIC8vICBbcmVkWCwgcmVkMV0gd2l0aCBbYmx1ZTAsIGJsdWUxXVxuICAgICAgICAgICAgICBpZihyZWRYIDwgcmVkMSkge1xuICAgICAgICAgICAgICAgIHJldHZhbCA9IHN3ZWVwLnN3ZWVwQmlwYXJ0aXRlKFxuICAgICAgICAgICAgICAgICAgZCwgdmlzaXQsXG4gICAgICAgICAgICAgICAgICByZWRYLCByZWQxLCByZWQsIHJlZEluZGV4LFxuICAgICAgICAgICAgICAgICAgYmx1ZTAsIGJsdWUxLCBibHVlLCBibHVlSW5kZXgpXG4gICAgICAgICAgICAgICAgaWYocmV0dmFsICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiByZXR2YWxcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmKHJlZDAgPCByZWRYKSB7XG4gICAgICAgICAgICAgICAgaXRlclB1c2godG9wKyssXG4gICAgICAgICAgICAgICAgICBheGlzKzEsXG4gICAgICAgICAgICAgICAgICByZWQwLCByZWRYLFxuICAgICAgICAgICAgICAgICAgYmx1ZTAsIGJsdWUxLFxuICAgICAgICAgICAgICAgICAgMTYsXG4gICAgICAgICAgICAgICAgICAtSW5maW5pdHksIEluZmluaXR5KVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmKHJlZFggPCByZWQxKSB7XG4gICAgICAgICAgICAgICAgaXRlclB1c2godG9wKyssXG4gICAgICAgICAgICAgICAgICBheGlzKzEsXG4gICAgICAgICAgICAgICAgICByZWRYLCByZWQxLFxuICAgICAgICAgICAgICAgICAgYmx1ZTAsIGJsdWUxLFxuICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgIC1JbmZpbml0eSwgSW5maW5pdHkpXG4gICAgICAgICAgICAgICAgaXRlclB1c2godG9wKyssXG4gICAgICAgICAgICAgICAgICBheGlzKzEsXG4gICAgICAgICAgICAgICAgICBibHVlMCwgYmx1ZTEsXG4gICAgICAgICAgICAgICAgICByZWRYLCByZWQxLFxuICAgICAgICAgICAgICAgICAgMSxcbiAgICAgICAgICAgICAgICAgIC1JbmZpbml0eSwgSW5maW5pdHkpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYoZmxpcCkge1xuICAgICAgICAgICAgcmVkMSA9IHBhcnRpdGlvbkNvbnRhaW5zUG9pbnRQcm9wZXIoXG4gICAgICAgICAgICAgIGQsIGF4aXMsXG4gICAgICAgICAgICAgIHJlZDAsIHJlZEVuZCwgcmVkLCByZWRJbmRleCxcbiAgICAgICAgICAgICAgbWlkKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZWQxID0gcGFydGl0aW9uQ29udGFpbnNQb2ludChcbiAgICAgICAgICAgICAgZCwgYXhpcyxcbiAgICAgICAgICAgICAgcmVkMCwgcmVkRW5kLCByZWQsIHJlZEluZGV4LFxuICAgICAgICAgICAgICBtaWQpXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmKHJlZDAgPCByZWQxKSB7XG4gICAgICAgICAgICBpZihheGlzID09PSBkLTIpIHtcbiAgICAgICAgICAgICAgaWYoZmxpcCkge1xuICAgICAgICAgICAgICAgIHJldHZhbCA9IHN3ZWVwLnN3ZWVwQmlwYXJ0aXRlKFxuICAgICAgICAgICAgICAgICAgZCwgdmlzaXQsXG4gICAgICAgICAgICAgICAgICBibHVlMCwgYmx1ZTEsIGJsdWUsIGJsdWVJbmRleCxcbiAgICAgICAgICAgICAgICAgIHJlZDAsIHJlZDEsIHJlZCwgcmVkSW5kZXgpXG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dmFsID0gc3dlZXAuc3dlZXBCaXBhcnRpdGUoXG4gICAgICAgICAgICAgICAgICBkLCB2aXNpdCxcbiAgICAgICAgICAgICAgICAgIHJlZDAsIHJlZDEsIHJlZCwgcmVkSW5kZXgsXG4gICAgICAgICAgICAgICAgICBibHVlMCwgYmx1ZTEsIGJsdWUsIGJsdWVJbmRleClcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaXRlclB1c2godG9wKyssXG4gICAgICAgICAgICAgICAgYXhpcysxLFxuICAgICAgICAgICAgICAgIHJlZDAsIHJlZDEsXG4gICAgICAgICAgICAgICAgYmx1ZTAsIGJsdWUxLFxuICAgICAgICAgICAgICAgIGZsaXAsXG4gICAgICAgICAgICAgICAgLUluZmluaXR5LCBJbmZpbml0eSlcbiAgICAgICAgICAgICAgaXRlclB1c2godG9wKyssXG4gICAgICAgICAgICAgICAgYXhpcysxLFxuICAgICAgICAgICAgICAgIGJsdWUwLCBibHVlMSxcbiAgICAgICAgICAgICAgICByZWQwLCByZWQxLFxuICAgICAgICAgICAgICAgIGZsaXBeMSxcbiAgICAgICAgICAgICAgICAtSW5maW5pdHksIEluZmluaXR5KVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufSIsIid1c2Ugc3RyaWN0J1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZpbmRNZWRpYW5cblxudmFyIGdlblBhcnRpdGlvbiA9IHJlcXVpcmUoJy4vcGFydGl0aW9uJylcblxudmFyIHBhcnRpdGlvblN0YXJ0TGVzc1RoYW4gPSBnZW5QYXJ0aXRpb24oJ2xvPHAwJywgWydwMCddKVxuXG52YXIgUEFSVElUSU9OX1RIUkVTSE9MRCA9IDggICAvL0N1dCBvZmYgZm9yIHVzaW5nIGluc2VydGlvbiBzb3J0IGluIGZpbmRNZWRpYW5cblxuLy9CYXNlIGNhc2UgZm9yIG1lZGlhbiBmaW5kaW5nOiAgVXNlIGluc2VydGlvbiBzb3J0XG5mdW5jdGlvbiBpbnNlcnRpb25Tb3J0KGQsIGF4aXMsIHN0YXJ0LCBlbmQsIGJveGVzLCBpZHMpIHtcbiAgdmFyIGVsZW1TaXplID0gMiAqIGRcbiAgdmFyIGJveFB0ciA9IGVsZW1TaXplICogKHN0YXJ0KzEpICsgYXhpc1xuICBmb3IodmFyIGk9c3RhcnQrMTsgaTxlbmQ7ICsraSwgYm94UHRyKz1lbGVtU2l6ZSkge1xuICAgIHZhciB4ID0gYm94ZXNbYm94UHRyXVxuICAgIGZvcih2YXIgaj1pLCBwdHI9ZWxlbVNpemUqKGktMSk7IFxuICAgICAgICBqPnN0YXJ0ICYmIGJveGVzW3B0citheGlzXSA+IHg7IFxuICAgICAgICAtLWosIHB0ci09ZWxlbVNpemUpIHtcbiAgICAgIC8vU3dhcFxuICAgICAgdmFyIGFQdHIgPSBwdHJcbiAgICAgIHZhciBiUHRyID0gcHRyK2VsZW1TaXplXG4gICAgICBmb3IodmFyIGs9MDsgazxlbGVtU2l6ZTsgKytrLCArK2FQdHIsICsrYlB0cikge1xuICAgICAgICB2YXIgeSA9IGJveGVzW2FQdHJdXG4gICAgICAgIGJveGVzW2FQdHJdID0gYm94ZXNbYlB0cl1cbiAgICAgICAgYm94ZXNbYlB0cl0gPSB5XG4gICAgICB9XG4gICAgICB2YXIgdG1wID0gaWRzW2pdXG4gICAgICBpZHNbal0gPSBpZHNbai0xXVxuICAgICAgaWRzW2otMV0gPSB0bXBcbiAgICB9XG4gIH1cbn1cblxuLy9GaW5kIG1lZGlhbiB1c2luZyBxdWljayBzZWxlY3QgYWxnb3JpdGhtXG4vLyAgdGFrZXMgTyhuKSB0aW1lIHdpdGggaGlnaCBwcm9iYWJpbGl0eVxuZnVuY3Rpb24gZmluZE1lZGlhbihkLCBheGlzLCBzdGFydCwgZW5kLCBib3hlcywgaWRzKSB7XG4gIGlmKGVuZCA8PSBzdGFydCsxKSB7XG4gICAgcmV0dXJuIHN0YXJ0XG4gIH1cblxuICB2YXIgbG8gICAgICAgPSBzdGFydFxuICB2YXIgaGkgICAgICAgPSBlbmRcbiAgdmFyIG1pZCAgICAgID0gKChlbmQgKyBzdGFydCkgPj4+IDEpXG4gIHZhciBlbGVtU2l6ZSA9IDIqZFxuICB2YXIgcGl2b3QgICAgPSBtaWRcbiAgdmFyIHZhbHVlICAgID0gYm94ZXNbZWxlbVNpemUqbWlkK2F4aXNdXG4gIFxuICB3aGlsZShsbyA8IGhpKSB7XG4gICAgaWYoaGkgLSBsbyA8IFBBUlRJVElPTl9USFJFU0hPTEQpIHtcbiAgICAgIGluc2VydGlvblNvcnQoZCwgYXhpcywgbG8sIGhpLCBib3hlcywgaWRzKVxuICAgICAgdmFsdWUgPSBib3hlc1tlbGVtU2l6ZSptaWQrYXhpc11cbiAgICAgIGJyZWFrXG4gICAgfVxuICAgIFxuICAgIC8vU2VsZWN0IHBpdm90IHVzaW5nIG1lZGlhbi1vZi0zXG4gICAgdmFyIGNvdW50ICA9IGhpIC0gbG9cbiAgICB2YXIgcGl2b3QwID0gKE1hdGgucmFuZG9tKCkqY291bnQrbG8pfDBcbiAgICB2YXIgdmFsdWUwID0gYm94ZXNbZWxlbVNpemUqcGl2b3QwICsgYXhpc11cbiAgICB2YXIgcGl2b3QxID0gKE1hdGgucmFuZG9tKCkqY291bnQrbG8pfDBcbiAgICB2YXIgdmFsdWUxID0gYm94ZXNbZWxlbVNpemUqcGl2b3QxICsgYXhpc11cbiAgICB2YXIgcGl2b3QyID0gKE1hdGgucmFuZG9tKCkqY291bnQrbG8pfDBcbiAgICB2YXIgdmFsdWUyID0gYm94ZXNbZWxlbVNpemUqcGl2b3QyICsgYXhpc11cbiAgICBpZih2YWx1ZTAgPD0gdmFsdWUxKSB7XG4gICAgICBpZih2YWx1ZTIgPj0gdmFsdWUxKSB7XG4gICAgICAgIHBpdm90ID0gcGl2b3QxXG4gICAgICAgIHZhbHVlID0gdmFsdWUxXG4gICAgICB9IGVsc2UgaWYodmFsdWUwID49IHZhbHVlMikge1xuICAgICAgICBwaXZvdCA9IHBpdm90MFxuICAgICAgICB2YWx1ZSA9IHZhbHVlMFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGl2b3QgPSBwaXZvdDJcbiAgICAgICAgdmFsdWUgPSB2YWx1ZTJcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYodmFsdWUxID49IHZhbHVlMikge1xuICAgICAgICBwaXZvdCA9IHBpdm90MVxuICAgICAgICB2YWx1ZSA9IHZhbHVlMVxuICAgICAgfSBlbHNlIGlmKHZhbHVlMiA+PSB2YWx1ZTApIHtcbiAgICAgICAgcGl2b3QgPSBwaXZvdDBcbiAgICAgICAgdmFsdWUgPSB2YWx1ZTBcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBpdm90ID0gcGl2b3QyXG4gICAgICAgIHZhbHVlID0gdmFsdWUyXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy9Td2FwIHBpdm90IHRvIGVuZCBvZiBhcnJheVxuICAgIHZhciBhUHRyID0gZWxlbVNpemUgKiAoaGktMSlcbiAgICB2YXIgYlB0ciA9IGVsZW1TaXplICogcGl2b3RcbiAgICBmb3IodmFyIGk9MDsgaTxlbGVtU2l6ZTsgKytpLCArK2FQdHIsICsrYlB0cikge1xuICAgICAgdmFyIHggPSBib3hlc1thUHRyXVxuICAgICAgYm94ZXNbYVB0cl0gPSBib3hlc1tiUHRyXVxuICAgICAgYm94ZXNbYlB0cl0gPSB4XG4gICAgfVxuICAgIHZhciB5ID0gaWRzW2hpLTFdXG4gICAgaWRzW2hpLTFdID0gaWRzW3Bpdm90XVxuICAgIGlkc1twaXZvdF0gPSB5XG5cbiAgICAvL1BhcnRpdGlvbiB1c2luZyBwaXZvdFxuICAgIHBpdm90ID0gcGFydGl0aW9uU3RhcnRMZXNzVGhhbihcbiAgICAgIGQsIGF4aXMsIFxuICAgICAgbG8sIGhpLTEsIGJveGVzLCBpZHMsXG4gICAgICB2YWx1ZSlcblxuICAgIC8vU3dhcCBwaXZvdCBiYWNrXG4gICAgdmFyIGFQdHIgPSBlbGVtU2l6ZSAqIChoaS0xKVxuICAgIHZhciBiUHRyID0gZWxlbVNpemUgKiBwaXZvdFxuICAgIGZvcih2YXIgaT0wOyBpPGVsZW1TaXplOyArK2ksICsrYVB0ciwgKytiUHRyKSB7XG4gICAgICB2YXIgeCA9IGJveGVzW2FQdHJdXG4gICAgICBib3hlc1thUHRyXSA9IGJveGVzW2JQdHJdXG4gICAgICBib3hlc1tiUHRyXSA9IHhcbiAgICB9XG4gICAgdmFyIHkgPSBpZHNbaGktMV1cbiAgICBpZHNbaGktMV0gPSBpZHNbcGl2b3RdXG4gICAgaWRzW3Bpdm90XSA9IHlcblxuICAgIC8vU3dhcCBwaXZvdCB0byBsYXN0IHBpdm90XG4gICAgaWYobWlkIDwgcGl2b3QpIHtcbiAgICAgIGhpID0gcGl2b3QtMVxuICAgICAgd2hpbGUobG8gPCBoaSAmJiBcbiAgICAgICAgYm94ZXNbZWxlbVNpemUqKGhpLTEpK2F4aXNdID09PSB2YWx1ZSkge1xuICAgICAgICBoaSAtPSAxXG4gICAgICB9XG4gICAgICBoaSArPSAxXG4gICAgfSBlbHNlIGlmKHBpdm90IDwgbWlkKSB7XG4gICAgICBsbyA9IHBpdm90ICsgMVxuICAgICAgd2hpbGUobG8gPCBoaSAmJlxuICAgICAgICBib3hlc1tlbGVtU2l6ZSpsbytheGlzXSA9PT0gdmFsdWUpIHtcbiAgICAgICAgbG8gKz0gMVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIC8vTWFrZSBzdXJlIHBpdm90IGlzIGF0IHN0YXJ0XG4gIHJldHVybiBwYXJ0aXRpb25TdGFydExlc3NUaGFuKFxuICAgIGQsIGF4aXMsIFxuICAgIHN0YXJ0LCBtaWQsIGJveGVzLCBpZHMsXG4gICAgYm94ZXNbZWxlbVNpemUqbWlkK2F4aXNdKVxufSIsIid1c2Ugc3RyaWN0J1xuXG5tb2R1bGUuZXhwb3J0cyA9IGdlblBhcnRpdGlvblxuXG52YXIgY29kZSA9ICdmb3IodmFyIGo9MiphLGs9aipjLGw9ayxtPWMsbj1iLG89YStiLHA9YztkPnA7KytwLGsrPWope3ZhciBfO2lmKCQpaWYobT09PXApbSs9MSxsKz1qO2Vsc2V7Zm9yKHZhciBzPTA7aj5zOysrcyl7dmFyIHQ9ZVtrK3NdO2VbaytzXT1lW2xdLGVbbCsrXT10fXZhciB1PWZbcF07ZltwXT1mW21dLGZbbSsrXT11fX1yZXR1cm4gbSdcblxuZnVuY3Rpb24gZ2VuUGFydGl0aW9uKHByZWRpY2F0ZSwgYXJncykge1xuICB2YXIgZmFyZ3MgPSdhYmNkZWYnLnNwbGl0KCcnKS5jb25jYXQoYXJncylcbiAgdmFyIHJlYWRzID0gW11cbiAgaWYocHJlZGljYXRlLmluZGV4T2YoJ2xvJykgPj0gMCkge1xuICAgIHJlYWRzLnB1c2goJ2xvPWVbaytuXScpXG4gIH1cbiAgaWYocHJlZGljYXRlLmluZGV4T2YoJ2hpJykgPj0gMCkge1xuICAgIHJlYWRzLnB1c2goJ2hpPWVbaytvXScpXG4gIH1cbiAgZmFyZ3MucHVzaChcbiAgICBjb2RlLnJlcGxhY2UoJ18nLCByZWFkcy5qb2luKCkpXG4gICAgICAgIC5yZXBsYWNlKCckJywgcHJlZGljYXRlKSlcbiAgcmV0dXJuIEZ1bmN0aW9uLmFwcGx5KHZvaWQgMCwgZmFyZ3MpXG59IiwiJ3VzZSBzdHJpY3QnO1xuXG4vL1RoaXMgY29kZSBpcyBleHRyYWN0ZWQgZnJvbSBuZGFycmF5LXNvcnRcbi8vSXQgaXMgaW5saW5lZCBoZXJlIGFzIGEgdGVtcG9yYXJ5IHdvcmthcm91bmRcblxubW9kdWxlLmV4cG9ydHMgPSB3cmFwcGVyO1xuXG52YXIgSU5TRVJUX1NPUlRfQ1VUT0ZGID0gMzJcblxuZnVuY3Rpb24gd3JhcHBlcihkYXRhLCBuMCkge1xuICBpZiAobjAgPD0gNCpJTlNFUlRfU09SVF9DVVRPRkYpIHtcbiAgICBpbnNlcnRpb25Tb3J0KDAsIG4wIC0gMSwgZGF0YSk7XG4gIH0gZWxzZSB7XG4gICAgcXVpY2tTb3J0KDAsIG4wIC0gMSwgZGF0YSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5zZXJ0aW9uU29ydChsZWZ0LCByaWdodCwgZGF0YSkge1xuICB2YXIgcHRyID0gMioobGVmdCsxKVxuICBmb3IodmFyIGk9bGVmdCsxOyBpPD1yaWdodDsgKytpKSB7XG4gICAgdmFyIGEgPSBkYXRhW3B0cisrXVxuICAgIHZhciBiID0gZGF0YVtwdHIrK11cbiAgICB2YXIgaiA9IGlcbiAgICB2YXIganB0ciA9IHB0ci0yXG4gICAgd2hpbGUoai0tID4gbGVmdCkge1xuICAgICAgdmFyIHggPSBkYXRhW2pwdHItMl1cbiAgICAgIHZhciB5ID0gZGF0YVtqcHRyLTFdXG4gICAgICBpZih4IDwgYSkge1xuICAgICAgICBicmVha1xuICAgICAgfSBlbHNlIGlmKHggPT09IGEgJiYgeSA8IGIpIHtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIGRhdGFbanB0cl0gICA9IHhcbiAgICAgIGRhdGFbanB0cisxXSA9IHlcbiAgICAgIGpwdHIgLT0gMlxuICAgIH1cbiAgICBkYXRhW2pwdHJdICAgPSBhXG4gICAgZGF0YVtqcHRyKzFdID0gYlxuICB9XG59XG5cbmZ1bmN0aW9uIHN3YXAoaSwgaiwgZGF0YSkge1xuICBpICo9IDJcbiAgaiAqPSAyXG4gIHZhciB4ID0gZGF0YVtpXVxuICB2YXIgeSA9IGRhdGFbaSsxXVxuICBkYXRhW2ldID0gZGF0YVtqXVxuICBkYXRhW2krMV0gPSBkYXRhW2orMV1cbiAgZGF0YVtqXSA9IHhcbiAgZGF0YVtqKzFdID0geVxufVxuXG5mdW5jdGlvbiBtb3ZlKGksIGosIGRhdGEpIHtcbiAgaSAqPSAyXG4gIGogKj0gMlxuICBkYXRhW2ldID0gZGF0YVtqXVxuICBkYXRhW2krMV0gPSBkYXRhW2orMV1cbn1cblxuZnVuY3Rpb24gcm90YXRlKGksIGosIGssIGRhdGEpIHtcbiAgaSAqPSAyXG4gIGogKj0gMlxuICBrICo9IDJcbiAgdmFyIHggPSBkYXRhW2ldXG4gIHZhciB5ID0gZGF0YVtpKzFdXG4gIGRhdGFbaV0gPSBkYXRhW2pdXG4gIGRhdGFbaSsxXSA9IGRhdGFbaisxXVxuICBkYXRhW2pdID0gZGF0YVtrXVxuICBkYXRhW2orMV0gPSBkYXRhW2srMV1cbiAgZGF0YVtrXSA9IHhcbiAgZGF0YVtrKzFdID0geVxufVxuXG5mdW5jdGlvbiBzaHVmZmxlUGl2b3QoaSwgaiwgcHgsIHB5LCBkYXRhKSB7XG4gIGkgKj0gMlxuICBqICo9IDJcbiAgZGF0YVtpXSA9IGRhdGFbal1cbiAgZGF0YVtqXSA9IHB4XG4gIGRhdGFbaSsxXSA9IGRhdGFbaisxXVxuICBkYXRhW2orMV0gPSBweVxufVxuXG5mdW5jdGlvbiBjb21wYXJlKGksIGosIGRhdGEpIHtcbiAgaSAqPSAyXG4gIGogKj0gMlxuICB2YXIgeCA9IGRhdGFbaV0sXG4gICAgICB5ID0gZGF0YVtqXVxuICBpZih4IDwgeSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9IGVsc2UgaWYoeCA9PT0geSkge1xuICAgIHJldHVybiBkYXRhW2krMV0gPiBkYXRhW2orMV1cbiAgfVxuICByZXR1cm4gdHJ1ZVxufVxuXG5mdW5jdGlvbiBjb21wYXJlUGl2b3QoaSwgeSwgYiwgZGF0YSkge1xuICBpICo9IDJcbiAgdmFyIHggPSBkYXRhW2ldXG4gIGlmKHggPCB5KSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfSBlbHNlIGlmKHggPT09IHkpIHtcbiAgICByZXR1cm4gZGF0YVtpKzFdIDwgYlxuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG5mdW5jdGlvbiBxdWlja1NvcnQobGVmdCwgcmlnaHQsIGRhdGEpIHtcbiAgdmFyIHNpeHRoID0gKHJpZ2h0IC0gbGVmdCArIDEpIC8gNiB8IDAsIFxuICAgICAgaW5kZXgxID0gbGVmdCArIHNpeHRoLCBcbiAgICAgIGluZGV4NSA9IHJpZ2h0IC0gc2l4dGgsIFxuICAgICAgaW5kZXgzID0gbGVmdCArIHJpZ2h0ID4+IDEsIFxuICAgICAgaW5kZXgyID0gaW5kZXgzIC0gc2l4dGgsIFxuICAgICAgaW5kZXg0ID0gaW5kZXgzICsgc2l4dGgsIFxuICAgICAgZWwxID0gaW5kZXgxLCBcbiAgICAgIGVsMiA9IGluZGV4MiwgXG4gICAgICBlbDMgPSBpbmRleDMsIFxuICAgICAgZWw0ID0gaW5kZXg0LCBcbiAgICAgIGVsNSA9IGluZGV4NSwgXG4gICAgICBsZXNzID0gbGVmdCArIDEsIFxuICAgICAgZ3JlYXQgPSByaWdodCAtIDEsIFxuICAgICAgdG1wID0gMFxuICBpZihjb21wYXJlKGVsMSwgZWwyLCBkYXRhKSkge1xuICAgIHRtcCA9IGVsMVxuICAgIGVsMSA9IGVsMlxuICAgIGVsMiA9IHRtcFxuICB9XG4gIGlmKGNvbXBhcmUoZWw0LCBlbDUsIGRhdGEpKSB7XG4gICAgdG1wID0gZWw0XG4gICAgZWw0ID0gZWw1XG4gICAgZWw1ID0gdG1wXG4gIH1cbiAgaWYoY29tcGFyZShlbDEsIGVsMywgZGF0YSkpIHtcbiAgICB0bXAgPSBlbDFcbiAgICBlbDEgPSBlbDNcbiAgICBlbDMgPSB0bXBcbiAgfVxuICBpZihjb21wYXJlKGVsMiwgZWwzLCBkYXRhKSkge1xuICAgIHRtcCA9IGVsMlxuICAgIGVsMiA9IGVsM1xuICAgIGVsMyA9IHRtcFxuICB9XG4gIGlmKGNvbXBhcmUoZWwxLCBlbDQsIGRhdGEpKSB7XG4gICAgdG1wID0gZWwxXG4gICAgZWwxID0gZWw0XG4gICAgZWw0ID0gdG1wXG4gIH1cbiAgaWYoY29tcGFyZShlbDMsIGVsNCwgZGF0YSkpIHtcbiAgICB0bXAgPSBlbDNcbiAgICBlbDMgPSBlbDRcbiAgICBlbDQgPSB0bXBcbiAgfVxuICBpZihjb21wYXJlKGVsMiwgZWw1LCBkYXRhKSkge1xuICAgIHRtcCA9IGVsMlxuICAgIGVsMiA9IGVsNVxuICAgIGVsNSA9IHRtcFxuICB9XG4gIGlmKGNvbXBhcmUoZWwyLCBlbDMsIGRhdGEpKSB7XG4gICAgdG1wID0gZWwyXG4gICAgZWwyID0gZWwzXG4gICAgZWwzID0gdG1wXG4gIH1cbiAgaWYoY29tcGFyZShlbDQsIGVsNSwgZGF0YSkpIHtcbiAgICB0bXAgPSBlbDRcbiAgICBlbDQgPSBlbDVcbiAgICBlbDUgPSB0bXBcbiAgfVxuXG4gIHZhciBwaXZvdDFYID0gZGF0YVsyKmVsMl1cbiAgdmFyIHBpdm90MVkgPSBkYXRhWzIqZWwyKzFdXG4gIHZhciBwaXZvdDJYID0gZGF0YVsyKmVsNF1cbiAgdmFyIHBpdm90MlkgPSBkYXRhWzIqZWw0KzFdXG5cbiAgdmFyIHB0cjAgPSAyICogZWwxO1xuICB2YXIgcHRyMiA9IDIgKiBlbDM7XG4gIHZhciBwdHI0ID0gMiAqIGVsNTtcbiAgdmFyIHB0cjUgPSAyICogaW5kZXgxO1xuICB2YXIgcHRyNiA9IDIgKiBpbmRleDM7XG4gIHZhciBwdHI3ID0gMiAqIGluZGV4NTtcbiAgZm9yICh2YXIgaTEgPSAwOyBpMSA8IDI7ICsraTEpIHtcbiAgICB2YXIgeCA9IGRhdGFbcHRyMCtpMV07XG4gICAgdmFyIHkgPSBkYXRhW3B0cjIraTFdO1xuICAgIHZhciB6ID0gZGF0YVtwdHI0K2kxXTtcbiAgICBkYXRhW3B0cjUraTFdID0geDtcbiAgICBkYXRhW3B0cjYraTFdID0geTtcbiAgICBkYXRhW3B0cjcraTFdID0gejtcbiAgfVxuXG4gIG1vdmUoaW5kZXgyLCBsZWZ0LCBkYXRhKVxuICBtb3ZlKGluZGV4NCwgcmlnaHQsIGRhdGEpXG4gIGZvciAodmFyIGsgPSBsZXNzOyBrIDw9IGdyZWF0OyArK2spIHtcbiAgICBpZiAoY29tcGFyZVBpdm90KGssIHBpdm90MVgsIHBpdm90MVksIGRhdGEpKSB7XG4gICAgICBpZiAoayAhPT0gbGVzcykge1xuICAgICAgICBzd2FwKGssIGxlc3MsIGRhdGEpXG4gICAgICB9XG4gICAgICArK2xlc3M7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghY29tcGFyZVBpdm90KGssIHBpdm90MlgsIHBpdm90MlksIGRhdGEpKSB7XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgaWYgKCFjb21wYXJlUGl2b3QoZ3JlYXQsIHBpdm90MlgsIHBpdm90MlksIGRhdGEpKSB7XG4gICAgICAgICAgICBpZiAoLS1ncmVhdCA8IGspIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGNvbXBhcmVQaXZvdChncmVhdCwgcGl2b3QxWCwgcGl2b3QxWSwgZGF0YSkpIHtcbiAgICAgICAgICAgICAgcm90YXRlKGssIGxlc3MsIGdyZWF0LCBkYXRhKVxuICAgICAgICAgICAgICArK2xlc3M7XG4gICAgICAgICAgICAgIC0tZ3JlYXQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzd2FwKGssIGdyZWF0LCBkYXRhKVxuICAgICAgICAgICAgICAtLWdyZWF0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHNodWZmbGVQaXZvdChsZWZ0LCBsZXNzLTEsIHBpdm90MVgsIHBpdm90MVksIGRhdGEpXG4gIHNodWZmbGVQaXZvdChyaWdodCwgZ3JlYXQrMSwgcGl2b3QyWCwgcGl2b3QyWSwgZGF0YSlcbiAgaWYgKGxlc3MgLSAyIC0gbGVmdCA8PSBJTlNFUlRfU09SVF9DVVRPRkYpIHtcbiAgICBpbnNlcnRpb25Tb3J0KGxlZnQsIGxlc3MgLSAyLCBkYXRhKTtcbiAgfSBlbHNlIHtcbiAgICBxdWlja1NvcnQobGVmdCwgbGVzcyAtIDIsIGRhdGEpO1xuICB9XG4gIGlmIChyaWdodCAtIChncmVhdCArIDIpIDw9IElOU0VSVF9TT1JUX0NVVE9GRikge1xuICAgIGluc2VydGlvblNvcnQoZ3JlYXQgKyAyLCByaWdodCwgZGF0YSk7XG4gIH0gZWxzZSB7XG4gICAgcXVpY2tTb3J0KGdyZWF0ICsgMiwgcmlnaHQsIGRhdGEpO1xuICB9XG4gIGlmIChncmVhdCAtIGxlc3MgPD0gSU5TRVJUX1NPUlRfQ1VUT0ZGKSB7XG4gICAgaW5zZXJ0aW9uU29ydChsZXNzLCBncmVhdCwgZGF0YSk7XG4gIH0gZWxzZSB7XG4gICAgcXVpY2tTb3J0KGxlc3MsIGdyZWF0LCBkYXRhKTtcbiAgfVxufSIsIid1c2Ugc3RyaWN0J1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgaW5pdDogICAgICAgICAgIHNxSW5pdCxcbiAgc3dlZXBCaXBhcnRpdGU6IHN3ZWVwQmlwYXJ0aXRlLFxuICBzd2VlcENvbXBsZXRlOiAgc3dlZXBDb21wbGV0ZSxcbiAgc2NhbkJpcGFydGl0ZTogIHNjYW5CaXBhcnRpdGUsXG4gIHNjYW5Db21wbGV0ZTogICBzY2FuQ29tcGxldGVcbn1cblxudmFyIHBvb2wgID0gcmVxdWlyZSgndHlwZWRhcnJheS1wb29sJylcbnZhciBiaXRzICA9IHJlcXVpcmUoJ2JpdC10d2lkZGxlJylcbnZhciBpc29ydCA9IHJlcXVpcmUoJy4vc29ydCcpXG5cbi8vRmxhZyBmb3IgYmx1ZVxudmFyIEJMVUVfRkxBRyA9ICgxPDwyOClcblxuLy8xRCBzd2VlcCBldmVudCBxdWV1ZSBzdHVmZiAodXNlIHBvb2wgdG8gc2F2ZSBzcGFjZSlcbnZhciBJTklUX0NBUEFDSVRZICAgICAgPSAxMDI0XG52YXIgUkVEX1NXRUVQX1FVRVVFICAgID0gcG9vbC5tYWxsb2NJbnQzMihJTklUX0NBUEFDSVRZKVxudmFyIFJFRF9TV0VFUF9JTkRFWCAgICA9IHBvb2wubWFsbG9jSW50MzIoSU5JVF9DQVBBQ0lUWSlcbnZhciBCTFVFX1NXRUVQX1FVRVVFICAgPSBwb29sLm1hbGxvY0ludDMyKElOSVRfQ0FQQUNJVFkpXG52YXIgQkxVRV9TV0VFUF9JTkRFWCAgID0gcG9vbC5tYWxsb2NJbnQzMihJTklUX0NBUEFDSVRZKVxudmFyIENPTU1PTl9TV0VFUF9RVUVVRSA9IHBvb2wubWFsbG9jSW50MzIoSU5JVF9DQVBBQ0lUWSlcbnZhciBDT01NT05fU1dFRVBfSU5ERVggPSBwb29sLm1hbGxvY0ludDMyKElOSVRfQ0FQQUNJVFkpXG52YXIgU1dFRVBfRVZFTlRTICAgICAgID0gcG9vbC5tYWxsb2NEb3VibGUoSU5JVF9DQVBBQ0lUWSAqIDgpXG5cbi8vUmVzZXJ2ZXMgbWVtb3J5IGZvciB0aGUgMUQgc3dlZXAgZGF0YSBzdHJ1Y3R1cmVzXG5mdW5jdGlvbiBzcUluaXQoY291bnQpIHtcbiAgdmFyIHJjb3VudCA9IGJpdHMubmV4dFBvdzIoY291bnQpXG4gIGlmKFJFRF9TV0VFUF9RVUVVRS5sZW5ndGggPCByY291bnQpIHtcbiAgICBwb29sLmZyZWUoUkVEX1NXRUVQX1FVRVVFKVxuICAgIFJFRF9TV0VFUF9RVUVVRSA9IHBvb2wubWFsbG9jSW50MzIocmNvdW50KVxuICB9XG4gIGlmKFJFRF9TV0VFUF9JTkRFWC5sZW5ndGggPCByY291bnQpIHtcbiAgICBwb29sLmZyZWUoUkVEX1NXRUVQX0lOREVYKVxuICAgIFJFRF9TV0VFUF9JTkRFWCA9IHBvb2wubWFsbG9jSW50MzIocmNvdW50KVxuICB9XG4gIGlmKEJMVUVfU1dFRVBfUVVFVUUubGVuZ3RoIDwgcmNvdW50KSB7XG4gICAgcG9vbC5mcmVlKEJMVUVfU1dFRVBfUVVFVUUpXG4gICAgQkxVRV9TV0VFUF9RVUVVRSA9IHBvb2wubWFsbG9jSW50MzIocmNvdW50KVxuICB9XG4gIGlmKEJMVUVfU1dFRVBfSU5ERVgubGVuZ3RoIDwgcmNvdW50KSB7XG4gICAgcG9vbC5mcmVlKEJMVUVfU1dFRVBfSU5ERVgpXG4gICAgQkxVRV9TV0VFUF9JTkRFWCA9IHBvb2wubWFsbG9jSW50MzIocmNvdW50KVxuICB9XG4gIGlmKENPTU1PTl9TV0VFUF9RVUVVRS5sZW5ndGggPCByY291bnQpIHtcbiAgICBwb29sLmZyZWUoQ09NTU9OX1NXRUVQX1FVRVVFKVxuICAgIENPTU1PTl9TV0VFUF9RVUVVRSA9IHBvb2wubWFsbG9jSW50MzIocmNvdW50KVxuICB9XG4gIGlmKENPTU1PTl9TV0VFUF9JTkRFWC5sZW5ndGggPCByY291bnQpIHtcbiAgICBwb29sLmZyZWUoQ09NTU9OX1NXRUVQX0lOREVYKVxuICAgIENPTU1PTl9TV0VFUF9JTkRFWCA9IHBvb2wubWFsbG9jSW50MzIocmNvdW50KVxuICB9XG4gIHZhciBldmVudExlbmd0aCA9IDggKiByY291bnRcbiAgaWYoU1dFRVBfRVZFTlRTLmxlbmd0aCA8IGV2ZW50TGVuZ3RoKSB7XG4gICAgcG9vbC5mcmVlKFNXRUVQX0VWRU5UUylcbiAgICBTV0VFUF9FVkVOVFMgPSBwb29sLm1hbGxvY0RvdWJsZShldmVudExlbmd0aClcbiAgfVxufVxuXG4vL1JlbW92ZSBhbiBpdGVtIGZyb20gdGhlIGFjdGl2ZSBxdWV1ZSBpbiBPKDEpXG5mdW5jdGlvbiBzcVBvcChxdWV1ZSwgaW5kZXgsIGNvdW50LCBpdGVtKSB7XG4gIHZhciBpZHggPSBpbmRleFtpdGVtXVxuICB2YXIgdG9wID0gcXVldWVbY291bnQtMV1cbiAgcXVldWVbaWR4XSA9IHRvcFxuICBpbmRleFt0b3BdID0gaWR4XG59XG5cbi8vSW5zZXJ0IGFuIGl0ZW0gaW50byB0aGUgYWN0aXZlIHF1ZXVlIGluIE8oMSlcbmZ1bmN0aW9uIHNxUHVzaChxdWV1ZSwgaW5kZXgsIGNvdW50LCBpdGVtKSB7XG4gIHF1ZXVlW2NvdW50XSA9IGl0ZW1cbiAgaW5kZXhbaXRlbV0gID0gY291bnRcbn1cblxuLy9SZWN1cnNpb24gYmFzZSBjYXNlOiB1c2UgMUQgc3dlZXAgYWxnb3JpdGhtXG5mdW5jdGlvbiBzd2VlcEJpcGFydGl0ZShcbiAgICBkLCB2aXNpdCxcbiAgICByZWRTdGFydCwgIHJlZEVuZCwgcmVkLCByZWRJbmRleCxcbiAgICBibHVlU3RhcnQsIGJsdWVFbmQsIGJsdWUsIGJsdWVJbmRleCkge1xuXG4gIC8vc3RvcmUgZXZlbnRzIGFzIHBhaXJzIFtjb29yZGluYXRlLCBpZHhdXG4gIC8vXG4gIC8vICByZWQgY3JlYXRlOiAgLShpZHgrMSlcbiAgLy8gIHJlZCBkZXN0cm95OiBpZHhcbiAgLy8gIGJsdWUgY3JlYXRlOiAtKGlkeCtCTFVFX0ZMQUcpXG4gIC8vICBibHVlIGRlc3Ryb3k6IGlkeCtCTFVFX0ZMQUdcbiAgLy9cbiAgdmFyIHB0ciAgICAgID0gMFxuICB2YXIgZWxlbVNpemUgPSAyKmRcbiAgdmFyIGlzdGFydCAgID0gZC0xXG4gIHZhciBpZW5kICAgICA9IGVsZW1TaXplLTFcblxuICBmb3IodmFyIGk9cmVkU3RhcnQ7IGk8cmVkRW5kOyArK2kpIHtcbiAgICB2YXIgaWR4ID0gcmVkSW5kZXhbaV1cbiAgICB2YXIgcmVkT2Zmc2V0ID0gZWxlbVNpemUqaVxuICAgIFNXRUVQX0VWRU5UU1twdHIrK10gPSByZWRbcmVkT2Zmc2V0K2lzdGFydF1cbiAgICBTV0VFUF9FVkVOVFNbcHRyKytdID0gLShpZHgrMSlcbiAgICBTV0VFUF9FVkVOVFNbcHRyKytdID0gcmVkW3JlZE9mZnNldCtpZW5kXVxuICAgIFNXRUVQX0VWRU5UU1twdHIrK10gPSBpZHhcbiAgfVxuXG4gIGZvcih2YXIgaT1ibHVlU3RhcnQ7IGk8Ymx1ZUVuZDsgKytpKSB7XG4gICAgdmFyIGlkeCA9IGJsdWVJbmRleFtpXStCTFVFX0ZMQUdcbiAgICB2YXIgYmx1ZU9mZnNldCA9IGVsZW1TaXplKmlcbiAgICBTV0VFUF9FVkVOVFNbcHRyKytdID0gYmx1ZVtibHVlT2Zmc2V0K2lzdGFydF1cbiAgICBTV0VFUF9FVkVOVFNbcHRyKytdID0gLWlkeFxuICAgIFNXRUVQX0VWRU5UU1twdHIrK10gPSBibHVlW2JsdWVPZmZzZXQraWVuZF1cbiAgICBTV0VFUF9FVkVOVFNbcHRyKytdID0gaWR4XG4gIH1cblxuICAvL3Byb2Nlc3MgZXZlbnRzIGZyb20gbGVmdC0+cmlnaHRcbiAgdmFyIG4gPSBwdHIgPj4+IDFcbiAgaXNvcnQoU1dFRVBfRVZFTlRTLCBuKVxuICBcbiAgdmFyIHJlZEFjdGl2ZSAgPSAwXG4gIHZhciBibHVlQWN0aXZlID0gMFxuICBmb3IodmFyIGk9MDsgaTxuOyArK2kpIHtcbiAgICB2YXIgZSA9IFNXRUVQX0VWRU5UU1syKmkrMV18MFxuICAgIGlmKGUgPj0gQkxVRV9GTEFHKSB7XG4gICAgICAvL2JsdWUgZGVzdHJveSBldmVudFxuICAgICAgZSA9IChlLUJMVUVfRkxBRyl8MFxuICAgICAgc3FQb3AoQkxVRV9TV0VFUF9RVUVVRSwgQkxVRV9TV0VFUF9JTkRFWCwgYmx1ZUFjdGl2ZS0tLCBlKVxuICAgIH0gZWxzZSBpZihlID49IDApIHtcbiAgICAgIC8vcmVkIGRlc3Ryb3kgZXZlbnRcbiAgICAgIHNxUG9wKFJFRF9TV0VFUF9RVUVVRSwgUkVEX1NXRUVQX0lOREVYLCByZWRBY3RpdmUtLSwgZSlcbiAgICB9IGVsc2UgaWYoZSA8PSAtQkxVRV9GTEFHKSB7XG4gICAgICAvL2JsdWUgY3JlYXRlIGV2ZW50XG4gICAgICBlID0gKC1lLUJMVUVfRkxBRyl8MFxuICAgICAgZm9yKHZhciBqPTA7IGo8cmVkQWN0aXZlOyArK2opIHtcbiAgICAgICAgdmFyIHJldHZhbCA9IHZpc2l0KFJFRF9TV0VFUF9RVUVVRVtqXSwgZSlcbiAgICAgICAgaWYocmV0dmFsICE9PSB2b2lkIDApIHtcbiAgICAgICAgICByZXR1cm4gcmV0dmFsXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHNxUHVzaChCTFVFX1NXRUVQX1FVRVVFLCBCTFVFX1NXRUVQX0lOREVYLCBibHVlQWN0aXZlKyssIGUpXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vcmVkIGNyZWF0ZSBldmVudFxuICAgICAgZSA9ICgtZS0xKXwwXG4gICAgICBmb3IodmFyIGo9MDsgajxibHVlQWN0aXZlOyArK2opIHtcbiAgICAgICAgdmFyIHJldHZhbCA9IHZpc2l0KGUsIEJMVUVfU1dFRVBfUVVFVUVbal0pXG4gICAgICAgIGlmKHJldHZhbCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgcmV0dXJuIHJldHZhbFxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzcVB1c2goUkVEX1NXRUVQX1FVRVVFLCBSRURfU1dFRVBfSU5ERVgsIHJlZEFjdGl2ZSsrLCBlKVxuICAgIH1cbiAgfVxufVxuXG4vL0NvbXBsZXRlIHN3ZWVwXG5mdW5jdGlvbiBzd2VlcENvbXBsZXRlKGQsIHZpc2l0LCBcbiAgcmVkU3RhcnQsIHJlZEVuZCwgcmVkLCByZWRJbmRleCxcbiAgYmx1ZVN0YXJ0LCBibHVlRW5kLCBibHVlLCBibHVlSW5kZXgpIHtcblxuICB2YXIgcHRyICAgICAgPSAwXG4gIHZhciBlbGVtU2l6ZSA9IDIqZFxuICB2YXIgaXN0YXJ0ICAgPSBkLTFcbiAgdmFyIGllbmQgICAgID0gZWxlbVNpemUtMVxuXG4gIGZvcih2YXIgaT1yZWRTdGFydDsgaTxyZWRFbmQ7ICsraSkge1xuICAgIHZhciBpZHggPSAocmVkSW5kZXhbaV0rMSk8PDFcbiAgICB2YXIgcmVkT2Zmc2V0ID0gZWxlbVNpemUqaVxuICAgIFNXRUVQX0VWRU5UU1twdHIrK10gPSByZWRbcmVkT2Zmc2V0K2lzdGFydF1cbiAgICBTV0VFUF9FVkVOVFNbcHRyKytdID0gLWlkeFxuICAgIFNXRUVQX0VWRU5UU1twdHIrK10gPSByZWRbcmVkT2Zmc2V0K2llbmRdXG4gICAgU1dFRVBfRVZFTlRTW3B0cisrXSA9IGlkeFxuICB9XG5cbiAgZm9yKHZhciBpPWJsdWVTdGFydDsgaTxibHVlRW5kOyArK2kpIHtcbiAgICB2YXIgaWR4ID0gKGJsdWVJbmRleFtpXSsxKTw8MVxuICAgIHZhciBibHVlT2Zmc2V0ID0gZWxlbVNpemUqaVxuICAgIFNXRUVQX0VWRU5UU1twdHIrK10gPSBibHVlW2JsdWVPZmZzZXQraXN0YXJ0XVxuICAgIFNXRUVQX0VWRU5UU1twdHIrK10gPSAoLWlkeCl8MVxuICAgIFNXRUVQX0VWRU5UU1twdHIrK10gPSBibHVlW2JsdWVPZmZzZXQraWVuZF1cbiAgICBTV0VFUF9FVkVOVFNbcHRyKytdID0gaWR4fDFcbiAgfVxuXG4gIC8vcHJvY2VzcyBldmVudHMgZnJvbSBsZWZ0LT5yaWdodFxuICB2YXIgbiA9IHB0ciA+Pj4gMVxuICBpc29ydChTV0VFUF9FVkVOVFMsIG4pXG4gIFxuICB2YXIgcmVkQWN0aXZlICAgID0gMFxuICB2YXIgYmx1ZUFjdGl2ZSAgID0gMFxuICB2YXIgY29tbW9uQWN0aXZlID0gMFxuICBmb3IodmFyIGk9MDsgaTxuOyArK2kpIHtcbiAgICB2YXIgZSAgICAgPSBTV0VFUF9FVkVOVFNbMippKzFdfDBcbiAgICB2YXIgY29sb3IgPSBlJjFcbiAgICBpZihpIDwgbi0xICYmIChlPj4xKSA9PT0gKFNXRUVQX0VWRU5UU1syKmkrM10+PjEpKSB7XG4gICAgICBjb2xvciA9IDJcbiAgICAgIGkgKz0gMVxuICAgIH1cbiAgICBcbiAgICBpZihlIDwgMCkge1xuICAgICAgLy9DcmVhdGUgZXZlbnRcbiAgICAgIHZhciBpZCA9IC0oZT4+MSkgLSAxXG5cbiAgICAgIC8vSW50ZXJzZWN0IHdpdGggY29tbW9uXG4gICAgICBmb3IodmFyIGo9MDsgajxjb21tb25BY3RpdmU7ICsraikge1xuICAgICAgICB2YXIgcmV0dmFsID0gdmlzaXQoQ09NTU9OX1NXRUVQX1FVRVVFW2pdLCBpZClcbiAgICAgICAgaWYocmV0dmFsICE9PSB2b2lkIDApIHtcbiAgICAgICAgICByZXR1cm4gcmV0dmFsXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYoY29sb3IgIT09IDApIHtcbiAgICAgICAgLy9JbnRlcnNlY3Qgd2l0aCByZWRcbiAgICAgICAgZm9yKHZhciBqPTA7IGo8cmVkQWN0aXZlOyArK2opIHtcbiAgICAgICAgICB2YXIgcmV0dmFsID0gdmlzaXQoUkVEX1NXRUVQX1FVRVVFW2pdLCBpZClcbiAgICAgICAgICBpZihyZXR2YWwgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgcmV0dXJuIHJldHZhbFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZihjb2xvciAhPT0gMSkge1xuICAgICAgICAvL0ludGVyc2VjdCB3aXRoIGJsdWVcbiAgICAgICAgZm9yKHZhciBqPTA7IGo8Ymx1ZUFjdGl2ZTsgKytqKSB7XG4gICAgICAgICAgdmFyIHJldHZhbCA9IHZpc2l0KEJMVUVfU1dFRVBfUVVFVUVbal0sIGlkKVxuICAgICAgICAgIGlmKHJldHZhbCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gcmV0dmFsXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmKGNvbG9yID09PSAwKSB7XG4gICAgICAgIC8vUmVkXG4gICAgICAgIHNxUHVzaChSRURfU1dFRVBfUVVFVUUsIFJFRF9TV0VFUF9JTkRFWCwgcmVkQWN0aXZlKyssIGlkKVxuICAgICAgfSBlbHNlIGlmKGNvbG9yID09PSAxKSB7XG4gICAgICAgIC8vQmx1ZVxuICAgICAgICBzcVB1c2goQkxVRV9TV0VFUF9RVUVVRSwgQkxVRV9TV0VFUF9JTkRFWCwgYmx1ZUFjdGl2ZSsrLCBpZClcbiAgICAgIH0gZWxzZSBpZihjb2xvciA9PT0gMikge1xuICAgICAgICAvL0JvdGhcbiAgICAgICAgc3FQdXNoKENPTU1PTl9TV0VFUF9RVUVVRSwgQ09NTU9OX1NXRUVQX0lOREVYLCBjb21tb25BY3RpdmUrKywgaWQpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vRGVzdHJveSBldmVudFxuICAgICAgdmFyIGlkID0gKGU+PjEpIC0gMVxuICAgICAgaWYoY29sb3IgPT09IDApIHtcbiAgICAgICAgLy9SZWRcbiAgICAgICAgc3FQb3AoUkVEX1NXRUVQX1FVRVVFLCBSRURfU1dFRVBfSU5ERVgsIHJlZEFjdGl2ZS0tLCBpZClcbiAgICAgIH0gZWxzZSBpZihjb2xvciA9PT0gMSkge1xuICAgICAgICAvL0JsdWVcbiAgICAgICAgc3FQb3AoQkxVRV9TV0VFUF9RVUVVRSwgQkxVRV9TV0VFUF9JTkRFWCwgYmx1ZUFjdGl2ZS0tLCBpZClcbiAgICAgIH0gZWxzZSBpZihjb2xvciA9PT0gMikge1xuICAgICAgICAvL0JvdGhcbiAgICAgICAgc3FQb3AoQ09NTU9OX1NXRUVQX1FVRVVFLCBDT01NT05fU1dFRVBfSU5ERVgsIGNvbW1vbkFjdGl2ZS0tLCBpZClcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLy9Td2VlcCBhbmQgcHJ1bmUvc2NhbmxpbmUgYWxnb3JpdGhtOlxuLy8gIFNjYW4gYWxvbmcgYXhpcywgZGV0ZWN0IGludGVyc2VjdGlvbnNcbi8vICBCcnV0ZSBmb3JjZSBhbGwgYm94ZXMgYWxvbmcgYXhpc1xuZnVuY3Rpb24gc2NhbkJpcGFydGl0ZShcbiAgZCwgYXhpcywgdmlzaXQsIGZsaXAsXG4gIHJlZFN0YXJ0LCAgcmVkRW5kLCByZWQsIHJlZEluZGV4LFxuICBibHVlU3RhcnQsIGJsdWVFbmQsIGJsdWUsIGJsdWVJbmRleCkge1xuICBcbiAgdmFyIHB0ciAgICAgID0gMFxuICB2YXIgZWxlbVNpemUgPSAyKmRcbiAgdmFyIGlzdGFydCAgID0gYXhpc1xuICB2YXIgaWVuZCAgICAgPSBheGlzK2RcblxuICB2YXIgcmVkU2hpZnQgID0gMVxuICB2YXIgYmx1ZVNoaWZ0ID0gMVxuICBpZihmbGlwKSB7XG4gICAgYmx1ZVNoaWZ0ID0gQkxVRV9GTEFHXG4gIH0gZWxzZSB7XG4gICAgcmVkU2hpZnQgID0gQkxVRV9GTEFHXG4gIH1cblxuICBmb3IodmFyIGk9cmVkU3RhcnQ7IGk8cmVkRW5kOyArK2kpIHtcbiAgICB2YXIgaWR4ID0gaSArIHJlZFNoaWZ0XG4gICAgdmFyIHJlZE9mZnNldCA9IGVsZW1TaXplKmlcbiAgICBTV0VFUF9FVkVOVFNbcHRyKytdID0gcmVkW3JlZE9mZnNldCtpc3RhcnRdXG4gICAgU1dFRVBfRVZFTlRTW3B0cisrXSA9IC1pZHhcbiAgICBTV0VFUF9FVkVOVFNbcHRyKytdID0gcmVkW3JlZE9mZnNldCtpZW5kXVxuICAgIFNXRUVQX0VWRU5UU1twdHIrK10gPSBpZHhcbiAgfVxuICBmb3IodmFyIGk9Ymx1ZVN0YXJ0OyBpPGJsdWVFbmQ7ICsraSkge1xuICAgIHZhciBpZHggPSBpICsgYmx1ZVNoaWZ0XG4gICAgdmFyIGJsdWVPZmZzZXQgPSBlbGVtU2l6ZSppXG4gICAgU1dFRVBfRVZFTlRTW3B0cisrXSA9IGJsdWVbYmx1ZU9mZnNldCtpc3RhcnRdXG4gICAgU1dFRVBfRVZFTlRTW3B0cisrXSA9IC1pZHhcbiAgfVxuXG4gIC8vcHJvY2VzcyBldmVudHMgZnJvbSBsZWZ0LT5yaWdodFxuICB2YXIgbiA9IHB0ciA+Pj4gMVxuICBpc29ydChTV0VFUF9FVkVOVFMsIG4pXG4gIFxuICB2YXIgcmVkQWN0aXZlICAgID0gMFxuICBmb3IodmFyIGk9MDsgaTxuOyArK2kpIHtcbiAgICB2YXIgZSA9IFNXRUVQX0VWRU5UU1syKmkrMV18MFxuICAgIGlmKGUgPCAwKSB7XG4gICAgICB2YXIgaWR4ICAgPSAtZVxuICAgICAgdmFyIGlzUmVkID0gZmFsc2VcbiAgICAgIGlmKGlkeCA+PSBCTFVFX0ZMQUcpIHtcbiAgICAgICAgaXNSZWQgPSAhZmxpcFxuICAgICAgICBpZHggLT0gQkxVRV9GTEFHIFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaXNSZWQgPSAhIWZsaXBcbiAgICAgICAgaWR4IC09IDFcbiAgICAgIH1cbiAgICAgIGlmKGlzUmVkKSB7XG4gICAgICAgIHNxUHVzaChSRURfU1dFRVBfUVVFVUUsIFJFRF9TV0VFUF9JTkRFWCwgcmVkQWN0aXZlKyssIGlkeClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBibHVlSWQgID0gYmx1ZUluZGV4W2lkeF1cbiAgICAgICAgdmFyIGJsdWVQdHIgPSBlbGVtU2l6ZSAqIGlkeFxuICAgICAgICBcbiAgICAgICAgdmFyIGIwID0gYmx1ZVtibHVlUHRyK2F4aXMrMV1cbiAgICAgICAgdmFyIGIxID0gYmx1ZVtibHVlUHRyK2F4aXMrMStkXVxuXG5yZWRfbG9vcDpcbiAgICAgICAgZm9yKHZhciBqPTA7IGo8cmVkQWN0aXZlOyArK2opIHtcbiAgICAgICAgICB2YXIgb2lkeCAgID0gUkVEX1NXRUVQX1FVRVVFW2pdXG4gICAgICAgICAgdmFyIHJlZFB0ciA9IGVsZW1TaXplICogb2lkeFxuXG4gICAgICAgICAgaWYoYjEgPCByZWRbcmVkUHRyK2F4aXMrMV0gfHwgXG4gICAgICAgICAgICAgcmVkW3JlZFB0citheGlzKzErZF0gPCBiMCkge1xuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmb3IodmFyIGs9YXhpcysyOyBrPGQ7ICsraykge1xuICAgICAgICAgICAgaWYoYmx1ZVtibHVlUHRyICsgayArIGRdIDwgcmVkW3JlZFB0ciArIGtdIHx8IFxuICAgICAgICAgICAgICAgcmVkW3JlZFB0ciArIGsgKyBkXSA8IGJsdWVbYmx1ZVB0ciArIGtdKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlIHJlZF9sb29wXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHJlZElkICA9IHJlZEluZGV4W29pZHhdXG4gICAgICAgICAgdmFyIHJldHZhbFxuICAgICAgICAgIGlmKGZsaXApIHtcbiAgICAgICAgICAgIHJldHZhbCA9IHZpc2l0KGJsdWVJZCwgcmVkSWQpXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHZhbCA9IHZpc2l0KHJlZElkLCBibHVlSWQpXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmKHJldHZhbCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gcmV0dmFsIFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzcVBvcChSRURfU1dFRVBfUVVFVUUsIFJFRF9TV0VFUF9JTkRFWCwgcmVkQWN0aXZlLS0sIGUgLSByZWRTaGlmdClcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gc2NhbkNvbXBsZXRlKFxuICBkLCBheGlzLCB2aXNpdCxcbiAgcmVkU3RhcnQsICByZWRFbmQsIHJlZCwgcmVkSW5kZXgsXG4gIGJsdWVTdGFydCwgYmx1ZUVuZCwgYmx1ZSwgYmx1ZUluZGV4KSB7XG5cbiAgdmFyIHB0ciAgICAgID0gMFxuICB2YXIgZWxlbVNpemUgPSAyKmRcbiAgdmFyIGlzdGFydCAgID0gYXhpc1xuICB2YXIgaWVuZCAgICAgPSBheGlzK2RcblxuICBmb3IodmFyIGk9cmVkU3RhcnQ7IGk8cmVkRW5kOyArK2kpIHtcbiAgICB2YXIgaWR4ID0gaSArIEJMVUVfRkxBR1xuICAgIHZhciByZWRPZmZzZXQgPSBlbGVtU2l6ZSppXG4gICAgU1dFRVBfRVZFTlRTW3B0cisrXSA9IHJlZFtyZWRPZmZzZXQraXN0YXJ0XVxuICAgIFNXRUVQX0VWRU5UU1twdHIrK10gPSAtaWR4XG4gICAgU1dFRVBfRVZFTlRTW3B0cisrXSA9IHJlZFtyZWRPZmZzZXQraWVuZF1cbiAgICBTV0VFUF9FVkVOVFNbcHRyKytdID0gaWR4XG4gIH1cbiAgZm9yKHZhciBpPWJsdWVTdGFydDsgaTxibHVlRW5kOyArK2kpIHtcbiAgICB2YXIgaWR4ID0gaSArIDFcbiAgICB2YXIgYmx1ZU9mZnNldCA9IGVsZW1TaXplKmlcbiAgICBTV0VFUF9FVkVOVFNbcHRyKytdID0gYmx1ZVtibHVlT2Zmc2V0K2lzdGFydF1cbiAgICBTV0VFUF9FVkVOVFNbcHRyKytdID0gLWlkeFxuICB9XG5cbiAgLy9wcm9jZXNzIGV2ZW50cyBmcm9tIGxlZnQtPnJpZ2h0XG4gIHZhciBuID0gcHRyID4+PiAxXG4gIGlzb3J0KFNXRUVQX0VWRU5UUywgbilcbiAgXG4gIHZhciByZWRBY3RpdmUgICAgPSAwXG4gIGZvcih2YXIgaT0wOyBpPG47ICsraSkge1xuICAgIHZhciBlID0gU1dFRVBfRVZFTlRTWzIqaSsxXXwwXG4gICAgaWYoZSA8IDApIHtcbiAgICAgIHZhciBpZHggICA9IC1lXG4gICAgICBpZihpZHggPj0gQkxVRV9GTEFHKSB7XG4gICAgICAgIFJFRF9TV0VFUF9RVUVVRVtyZWRBY3RpdmUrK10gPSBpZHggLSBCTFVFX0ZMQUdcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlkeCAtPSAxXG4gICAgICAgIHZhciBibHVlSWQgID0gYmx1ZUluZGV4W2lkeF1cbiAgICAgICAgdmFyIGJsdWVQdHIgPSBlbGVtU2l6ZSAqIGlkeFxuXG4gICAgICAgIHZhciBiMCA9IGJsdWVbYmx1ZVB0citheGlzKzFdXG4gICAgICAgIHZhciBiMSA9IGJsdWVbYmx1ZVB0citheGlzKzErZF1cblxucmVkX2xvb3A6XG4gICAgICAgIGZvcih2YXIgaj0wOyBqPHJlZEFjdGl2ZTsgKytqKSB7XG4gICAgICAgICAgdmFyIG9pZHggICA9IFJFRF9TV0VFUF9RVUVVRVtqXVxuICAgICAgICAgIHZhciByZWRJZCAgPSByZWRJbmRleFtvaWR4XVxuXG4gICAgICAgICAgaWYocmVkSWQgPT09IGJsdWVJZCkge1xuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgcmVkUHRyID0gZWxlbVNpemUgKiBvaWR4XG4gICAgICAgICAgaWYoYjEgPCByZWRbcmVkUHRyK2F4aXMrMV0gfHwgXG4gICAgICAgICAgICByZWRbcmVkUHRyK2F4aXMrMStkXSA8IGIwKSB7XG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IodmFyIGs9YXhpcysyOyBrPGQ7ICsraykge1xuICAgICAgICAgICAgaWYoYmx1ZVtibHVlUHRyICsgayArIGRdIDwgcmVkW3JlZFB0ciArIGtdIHx8IFxuICAgICAgICAgICAgICAgcmVkW3JlZFB0ciArIGsgKyBkXSAgIDwgYmx1ZVtibHVlUHRyICsga10pIHtcbiAgICAgICAgICAgICAgY29udGludWUgcmVkX2xvb3BcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgcmV0dmFsID0gdmlzaXQocmVkSWQsIGJsdWVJZClcbiAgICAgICAgICBpZihyZXR2YWwgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgcmV0dXJuIHJldHZhbCBcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGlkeCA9IGUgLSBCTFVFX0ZMQUdcbiAgICAgIGZvcih2YXIgaj1yZWRBY3RpdmUtMTsgaj49MDsgLS1qKSB7XG4gICAgICAgIGlmKFJFRF9TV0VFUF9RVUVVRVtqXSA9PT0gaWR4KSB7XG4gICAgICAgICAgZm9yKHZhciBrPWorMTsgazxyZWRBY3RpdmU7ICsraykge1xuICAgICAgICAgICAgUkVEX1NXRUVQX1FVRVVFW2stMV0gPSBSRURfU1dFRVBfUVVFVUVba11cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLS1yZWRBY3RpdmVcbiAgICB9XG4gIH1cbn0iLCIiLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUiA9IHR5cGVvZiBSZWZsZWN0ID09PSAnb2JqZWN0JyA/IFJlZmxlY3QgOiBudWxsXG52YXIgUmVmbGVjdEFwcGx5ID0gUiAmJiB0eXBlb2YgUi5hcHBseSA9PT0gJ2Z1bmN0aW9uJ1xuICA/IFIuYXBwbHlcbiAgOiBmdW5jdGlvbiBSZWZsZWN0QXBwbHkodGFyZ2V0LCByZWNlaXZlciwgYXJncykge1xuICAgIHJldHVybiBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbCh0YXJnZXQsIHJlY2VpdmVyLCBhcmdzKTtcbiAgfVxuXG52YXIgUmVmbGVjdE93bktleXNcbmlmIChSICYmIHR5cGVvZiBSLm93bktleXMgPT09ICdmdW5jdGlvbicpIHtcbiAgUmVmbGVjdE93bktleXMgPSBSLm93bktleXNcbn0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICBSZWZsZWN0T3duS2V5cyA9IGZ1bmN0aW9uIFJlZmxlY3RPd25LZXlzKHRhcmdldCkge1xuICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0YXJnZXQpXG4gICAgICAuY29uY2F0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHModGFyZ2V0KSk7XG4gIH07XG59IGVsc2Uge1xuICBSZWZsZWN0T3duS2V5cyA9IGZ1bmN0aW9uIFJlZmxlY3RPd25LZXlzKHRhcmdldCkge1xuICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0YXJnZXQpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBQcm9jZXNzRW1pdFdhcm5pbmcod2FybmluZykge1xuICBpZiAoY29uc29sZSAmJiBjb25zb2xlLndhcm4pIGNvbnNvbGUud2Fybih3YXJuaW5nKTtcbn1cblxudmFyIE51bWJlcklzTmFOID0gTnVtYmVyLmlzTmFOIHx8IGZ1bmN0aW9uIE51bWJlcklzTmFOKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPT0gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcbiAgRXZlbnRFbWl0dGVyLmluaXQuY2FsbCh0aGlzKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRFbWl0dGVyO1xubW9kdWxlLmV4cG9ydHMub25jZSA9IG9uY2U7XG5cbi8vIEJhY2t3YXJkcy1jb21wYXQgd2l0aCBub2RlIDAuMTAueFxuRXZlbnRFbWl0dGVyLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzID0gdW5kZWZpbmVkO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzQ291bnQgPSAwO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fbWF4TGlzdGVuZXJzID0gdW5kZWZpbmVkO1xuXG4vLyBCeSBkZWZhdWx0IEV2ZW50RW1pdHRlcnMgd2lsbCBwcmludCBhIHdhcm5pbmcgaWYgbW9yZSB0aGFuIDEwIGxpc3RlbmVycyBhcmVcbi8vIGFkZGVkIHRvIGl0LiBUaGlzIGlzIGEgdXNlZnVsIGRlZmF1bHQgd2hpY2ggaGVscHMgZmluZGluZyBtZW1vcnkgbGVha3MuXG52YXIgZGVmYXVsdE1heExpc3RlbmVycyA9IDEwO1xuXG5mdW5jdGlvbiBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKSB7XG4gIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJsaXN0ZW5lclwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbi4gUmVjZWl2ZWQgdHlwZSAnICsgdHlwZW9mIGxpc3RlbmVyKTtcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnRFbWl0dGVyLCAnZGVmYXVsdE1heExpc3RlbmVycycsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZGVmYXVsdE1heExpc3RlbmVycztcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbihhcmcpIHtcbiAgICBpZiAodHlwZW9mIGFyZyAhPT0gJ251bWJlcicgfHwgYXJnIDwgMCB8fCBOdW1iZXJJc05hTihhcmcpKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIG9mIFwiZGVmYXVsdE1heExpc3RlbmVyc1wiIGlzIG91dCBvZiByYW5nZS4gSXQgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXIuIFJlY2VpdmVkICcgKyBhcmcgKyAnLicpO1xuICAgIH1cbiAgICBkZWZhdWx0TWF4TGlzdGVuZXJzID0gYXJnO1xuICB9XG59KTtcblxuRXZlbnRFbWl0dGVyLmluaXQgPSBmdW5jdGlvbigpIHtcblxuICBpZiAodGhpcy5fZXZlbnRzID09PSB1bmRlZmluZWQgfHxcbiAgICAgIHRoaXMuX2V2ZW50cyA9PT0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpLl9ldmVudHMpIHtcbiAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgfVxuXG4gIHRoaXMuX21heExpc3RlbmVycyA9IHRoaXMuX21heExpc3RlbmVycyB8fCB1bmRlZmluZWQ7XG59O1xuXG4vLyBPYnZpb3VzbHkgbm90IGFsbCBFbWl0dGVycyBzaG91bGQgYmUgbGltaXRlZCB0byAxMC4gVGhpcyBmdW5jdGlvbiBhbGxvd3Ncbi8vIHRoYXQgdG8gYmUgaW5jcmVhc2VkLiBTZXQgdG8gemVybyBmb3IgdW5saW1pdGVkLlxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5zZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbiBzZXRNYXhMaXN0ZW5lcnMobikge1xuICBpZiAodHlwZW9mIG4gIT09ICdudW1iZXInIHx8IG4gPCAwIHx8IE51bWJlcklzTmFOKG4pKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBvZiBcIm5cIiBpcyBvdXQgb2YgcmFuZ2UuIEl0IG11c3QgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyLiBSZWNlaXZlZCAnICsgbiArICcuJyk7XG4gIH1cbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gbjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiBfZ2V0TWF4TGlzdGVuZXJzKHRoYXQpIHtcbiAgaWYgKHRoYXQuX21heExpc3RlbmVycyA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBFdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycztcbiAgcmV0dXJuIHRoYXQuX21heExpc3RlbmVycztcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5nZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbiBnZXRNYXhMaXN0ZW5lcnMoKSB7XG4gIHJldHVybiBfZ2V0TWF4TGlzdGVuZXJzKHRoaXMpO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24gZW1pdCh0eXBlKSB7XG4gIHZhciBhcmdzID0gW107XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSBhcmdzLnB1c2goYXJndW1lbnRzW2ldKTtcbiAgdmFyIGRvRXJyb3IgPSAodHlwZSA9PT0gJ2Vycm9yJyk7XG5cbiAgdmFyIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgaWYgKGV2ZW50cyAhPT0gdW5kZWZpbmVkKVxuICAgIGRvRXJyb3IgPSAoZG9FcnJvciAmJiBldmVudHMuZXJyb3IgPT09IHVuZGVmaW5lZCk7XG4gIGVsc2UgaWYgKCFkb0Vycm9yKVxuICAgIHJldHVybiBmYWxzZTtcblxuICAvLyBJZiB0aGVyZSBpcyBubyAnZXJyb3InIGV2ZW50IGxpc3RlbmVyIHRoZW4gdGhyb3cuXG4gIGlmIChkb0Vycm9yKSB7XG4gICAgdmFyIGVyO1xuICAgIGlmIChhcmdzLmxlbmd0aCA+IDApXG4gICAgICBlciA9IGFyZ3NbMF07XG4gICAgaWYgKGVyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIC8vIE5vdGU6IFRoZSBjb21tZW50cyBvbiB0aGUgYHRocm93YCBsaW5lcyBhcmUgaW50ZW50aW9uYWwsIHRoZXkgc2hvd1xuICAgICAgLy8gdXAgaW4gTm9kZSdzIG91dHB1dCBpZiB0aGlzIHJlc3VsdHMgaW4gYW4gdW5oYW5kbGVkIGV4Y2VwdGlvbi5cbiAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICAgIH1cbiAgICAvLyBBdCBsZWFzdCBnaXZlIHNvbWUga2luZCBvZiBjb250ZXh0IHRvIHRoZSB1c2VyXG4gICAgdmFyIGVyciA9IG5ldyBFcnJvcignVW5oYW5kbGVkIGVycm9yLicgKyAoZXIgPyAnICgnICsgZXIubWVzc2FnZSArICcpJyA6ICcnKSk7XG4gICAgZXJyLmNvbnRleHQgPSBlcjtcbiAgICB0aHJvdyBlcnI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gIH1cblxuICB2YXIgaGFuZGxlciA9IGV2ZW50c1t0eXBlXTtcblxuICBpZiAoaGFuZGxlciA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBmYWxzZTtcblxuICBpZiAodHlwZW9mIGhhbmRsZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICBSZWZsZWN0QXBwbHkoaGFuZGxlciwgdGhpcywgYXJncyk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGxlbiA9IGhhbmRsZXIubGVuZ3RoO1xuICAgIHZhciBsaXN0ZW5lcnMgPSBhcnJheUNsb25lKGhhbmRsZXIsIGxlbik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSlcbiAgICAgIFJlZmxlY3RBcHBseShsaXN0ZW5lcnNbaV0sIHRoaXMsIGFyZ3MpO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5mdW5jdGlvbiBfYWRkTGlzdGVuZXIodGFyZ2V0LCB0eXBlLCBsaXN0ZW5lciwgcHJlcGVuZCkge1xuICB2YXIgbTtcbiAgdmFyIGV2ZW50cztcbiAgdmFyIGV4aXN0aW5nO1xuXG4gIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpO1xuXG4gIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpIHtcbiAgICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGFyZ2V0Ll9ldmVudHNDb3VudCA9IDA7XG4gIH0gZWxzZSB7XG4gICAgLy8gVG8gYXZvaWQgcmVjdXJzaW9uIGluIHRoZSBjYXNlIHRoYXQgdHlwZSA9PT0gXCJuZXdMaXN0ZW5lclwiISBCZWZvcmVcbiAgICAvLyBhZGRpbmcgaXQgdG8gdGhlIGxpc3RlbmVycywgZmlyc3QgZW1pdCBcIm5ld0xpc3RlbmVyXCIuXG4gICAgaWYgKGV2ZW50cy5uZXdMaXN0ZW5lciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0YXJnZXQuZW1pdCgnbmV3TGlzdGVuZXInLCB0eXBlLFxuICAgICAgICAgICAgICAgICAgbGlzdGVuZXIubGlzdGVuZXIgPyBsaXN0ZW5lci5saXN0ZW5lciA6IGxpc3RlbmVyKTtcblxuICAgICAgLy8gUmUtYXNzaWduIGBldmVudHNgIGJlY2F1c2UgYSBuZXdMaXN0ZW5lciBoYW5kbGVyIGNvdWxkIGhhdmUgY2F1c2VkIHRoZVxuICAgICAgLy8gdGhpcy5fZXZlbnRzIHRvIGJlIGFzc2lnbmVkIHRvIGEgbmV3IG9iamVjdFxuICAgICAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7XG4gICAgfVxuICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdO1xuICB9XG5cbiAgaWYgKGV4aXN0aW5nID09PSB1bmRlZmluZWQpIHtcbiAgICAvLyBPcHRpbWl6ZSB0aGUgY2FzZSBvZiBvbmUgbGlzdGVuZXIuIERvbid0IG5lZWQgdGhlIGV4dHJhIGFycmF5IG9iamVjdC5cbiAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXSA9IGxpc3RlbmVyO1xuICAgICsrdGFyZ2V0Ll9ldmVudHNDb3VudDtcbiAgfSBlbHNlIHtcbiAgICBpZiAodHlwZW9mIGV4aXN0aW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBBZGRpbmcgdGhlIHNlY29uZCBlbGVtZW50LCBuZWVkIHRvIGNoYW5nZSB0byBhcnJheS5cbiAgICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdID1cbiAgICAgICAgcHJlcGVuZCA/IFtsaXN0ZW5lciwgZXhpc3RpbmddIDogW2V4aXN0aW5nLCBsaXN0ZW5lcl07XG4gICAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IGdvdCBhbiBhcnJheSwganVzdCBhcHBlbmQuXG4gICAgfSBlbHNlIGlmIChwcmVwZW5kKSB7XG4gICAgICBleGlzdGluZy51bnNoaWZ0KGxpc3RlbmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXhpc3RpbmcucHVzaChsaXN0ZW5lcik7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgZm9yIGxpc3RlbmVyIGxlYWtcbiAgICBtID0gX2dldE1heExpc3RlbmVycyh0YXJnZXQpO1xuICAgIGlmIChtID4gMCAmJiBleGlzdGluZy5sZW5ndGggPiBtICYmICFleGlzdGluZy53YXJuZWQpIHtcbiAgICAgIGV4aXN0aW5nLndhcm5lZCA9IHRydWU7XG4gICAgICAvLyBObyBlcnJvciBjb2RlIGZvciB0aGlzIHNpbmNlIGl0IGlzIGEgV2FybmluZ1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4XG4gICAgICB2YXIgdyA9IG5ldyBFcnJvcignUG9zc2libGUgRXZlbnRFbWl0dGVyIG1lbW9yeSBsZWFrIGRldGVjdGVkLiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZXhpc3RpbmcubGVuZ3RoICsgJyAnICsgU3RyaW5nKHR5cGUpICsgJyBsaXN0ZW5lcnMgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICdhZGRlZC4gVXNlIGVtaXR0ZXIuc2V0TWF4TGlzdGVuZXJzKCkgdG8gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICdpbmNyZWFzZSBsaW1pdCcpO1xuICAgICAgdy5uYW1lID0gJ01heExpc3RlbmVyc0V4Y2VlZGVkV2FybmluZyc7XG4gICAgICB3LmVtaXR0ZXIgPSB0YXJnZXQ7XG4gICAgICB3LnR5cGUgPSB0eXBlO1xuICAgICAgdy5jb3VudCA9IGV4aXN0aW5nLmxlbmd0aDtcbiAgICAgIFByb2Nlc3NFbWl0V2FybmluZyh3KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24gYWRkTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgcmV0dXJuIF9hZGRMaXN0ZW5lcih0aGlzLCB0eXBlLCBsaXN0ZW5lciwgZmFsc2UpO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucHJlcGVuZExpc3RlbmVyID1cbiAgICBmdW5jdGlvbiBwcmVwZW5kTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIHJldHVybiBfYWRkTGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIsIHRydWUpO1xuICAgIH07XG5cbmZ1bmN0aW9uIG9uY2VXcmFwcGVyKCkge1xuICBpZiAoIXRoaXMuZmlyZWQpIHtcbiAgICB0aGlzLnRhcmdldC5yZW1vdmVMaXN0ZW5lcih0aGlzLnR5cGUsIHRoaXMud3JhcEZuKTtcbiAgICB0aGlzLmZpcmVkID0gdHJ1ZTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMClcbiAgICAgIHJldHVybiB0aGlzLmxpc3RlbmVyLmNhbGwodGhpcy50YXJnZXQpO1xuICAgIHJldHVybiB0aGlzLmxpc3RlbmVyLmFwcGx5KHRoaXMudGFyZ2V0LCBhcmd1bWVudHMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9vbmNlV3JhcCh0YXJnZXQsIHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBzdGF0ZSA9IHsgZmlyZWQ6IGZhbHNlLCB3cmFwRm46IHVuZGVmaW5lZCwgdGFyZ2V0OiB0YXJnZXQsIHR5cGU6IHR5cGUsIGxpc3RlbmVyOiBsaXN0ZW5lciB9O1xuICB2YXIgd3JhcHBlZCA9IG9uY2VXcmFwcGVyLmJpbmQoc3RhdGUpO1xuICB3cmFwcGVkLmxpc3RlbmVyID0gbGlzdGVuZXI7XG4gIHN0YXRlLndyYXBGbiA9IHdyYXBwZWQ7XG4gIHJldHVybiB3cmFwcGVkO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbiBvbmNlKHR5cGUsIGxpc3RlbmVyKSB7XG4gIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpO1xuICB0aGlzLm9uKHR5cGUsIF9vbmNlV3JhcCh0aGlzLCB0eXBlLCBsaXN0ZW5lcikpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucHJlcGVuZE9uY2VMaXN0ZW5lciA9XG4gICAgZnVuY3Rpb24gcHJlcGVuZE9uY2VMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcik7XG4gICAgICB0aGlzLnByZXBlbmRMaXN0ZW5lcih0eXBlLCBfb25jZVdyYXAodGhpcywgdHlwZSwgbGlzdGVuZXIpKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbi8vIEVtaXRzIGEgJ3JlbW92ZUxpc3RlbmVyJyBldmVudCBpZiBhbmQgb25seSBpZiB0aGUgbGlzdGVuZXIgd2FzIHJlbW92ZWQuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID1cbiAgICBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgdmFyIGxpc3QsIGV2ZW50cywgcG9zaXRpb24sIGksIG9yaWdpbmFsTGlzdGVuZXI7XG5cbiAgICAgIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpO1xuXG4gICAgICBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gICAgICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICBsaXN0ID0gZXZlbnRzW3R5cGVdO1xuICAgICAgaWYgKGxpc3QgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgIGlmIChsaXN0ID09PSBsaXN0ZW5lciB8fCBsaXN0Lmxpc3RlbmVyID09PSBsaXN0ZW5lcikge1xuICAgICAgICBpZiAoLS10aGlzLl9ldmVudHNDb3VudCA9PT0gMClcbiAgICAgICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBkZWxldGUgZXZlbnRzW3R5cGVdO1xuICAgICAgICAgIGlmIChldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdC5saXN0ZW5lciB8fCBsaXN0ZW5lcik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGxpc3QgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcG9zaXRpb24gPSAtMTtcblxuICAgICAgICBmb3IgKGkgPSBsaXN0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgaWYgKGxpc3RbaV0gPT09IGxpc3RlbmVyIHx8IGxpc3RbaV0ubGlzdGVuZXIgPT09IGxpc3RlbmVyKSB7XG4gICAgICAgICAgICBvcmlnaW5hbExpc3RlbmVyID0gbGlzdFtpXS5saXN0ZW5lcjtcbiAgICAgICAgICAgIHBvc2l0aW9uID0gaTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwb3NpdGlvbiA8IDApXG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgaWYgKHBvc2l0aW9uID09PSAwKVxuICAgICAgICAgIGxpc3Quc2hpZnQoKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgc3BsaWNlT25lKGxpc3QsIHBvc2l0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSlcbiAgICAgICAgICBldmVudHNbdHlwZV0gPSBsaXN0WzBdO1xuXG4gICAgICAgIGlmIChldmVudHMucmVtb3ZlTGlzdGVuZXIgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgb3JpZ2luYWxMaXN0ZW5lciB8fCBsaXN0ZW5lcik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub2ZmID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPVxuICAgIGZ1bmN0aW9uIHJlbW92ZUFsbExpc3RlbmVycyh0eXBlKSB7XG4gICAgICB2YXIgbGlzdGVuZXJzLCBldmVudHMsIGk7XG5cbiAgICAgIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgICAgIGlmIChldmVudHMgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgIC8vIG5vdCBsaXN0ZW5pbmcgZm9yIHJlbW92ZUxpc3RlbmVyLCBubyBuZWVkIHRvIGVtaXRcbiAgICAgIGlmIChldmVudHMucmVtb3ZlTGlzdGVuZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICAgICAgICB9IGVsc2UgaWYgKGV2ZW50c1t0eXBlXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKC0tdGhpcy5fZXZlbnRzQ291bnQgPT09IDApXG4gICAgICAgICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGRlbGV0ZSBldmVudHNbdHlwZV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIC8vIGVtaXQgcmVtb3ZlTGlzdGVuZXIgZm9yIGFsbCBsaXN0ZW5lcnMgb24gYWxsIGV2ZW50c1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhldmVudHMpO1xuICAgICAgICB2YXIga2V5O1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgaWYgKGtleSA9PT0gJ3JlbW92ZUxpc3RlbmVyJykgY29udGludWU7XG4gICAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoa2V5KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygncmVtb3ZlTGlzdGVuZXInKTtcbiAgICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgbGlzdGVuZXJzID0gZXZlbnRzW3R5cGVdO1xuXG4gICAgICBpZiAodHlwZW9mIGxpc3RlbmVycyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVycyk7XG4gICAgICB9IGVsc2UgaWYgKGxpc3RlbmVycyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIExJRk8gb3JkZXJcbiAgICAgICAgZm9yIChpID0gbGlzdGVuZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnNbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbmZ1bmN0aW9uIF9saXN0ZW5lcnModGFyZ2V0LCB0eXBlLCB1bndyYXApIHtcbiAgdmFyIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuXG4gIGlmIChldmVudHMgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gW107XG5cbiAgdmFyIGV2bGlzdGVuZXIgPSBldmVudHNbdHlwZV07XG4gIGlmIChldmxpc3RlbmVyID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIFtdO1xuXG4gIGlmICh0eXBlb2YgZXZsaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJylcbiAgICByZXR1cm4gdW53cmFwID8gW2V2bGlzdGVuZXIubGlzdGVuZXIgfHwgZXZsaXN0ZW5lcl0gOiBbZXZsaXN0ZW5lcl07XG5cbiAgcmV0dXJuIHVud3JhcCA/XG4gICAgdW53cmFwTGlzdGVuZXJzKGV2bGlzdGVuZXIpIDogYXJyYXlDbG9uZShldmxpc3RlbmVyLCBldmxpc3RlbmVyLmxlbmd0aCk7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24gbGlzdGVuZXJzKHR5cGUpIHtcbiAgcmV0dXJuIF9saXN0ZW5lcnModGhpcywgdHlwZSwgdHJ1ZSk7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJhd0xpc3RlbmVycyA9IGZ1bmN0aW9uIHJhd0xpc3RlbmVycyh0eXBlKSB7XG4gIHJldHVybiBfbGlzdGVuZXJzKHRoaXMsIHR5cGUsIGZhbHNlKTtcbn07XG5cbkV2ZW50RW1pdHRlci5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24oZW1pdHRlciwgdHlwZSkge1xuICBpZiAodHlwZW9mIGVtaXR0ZXIubGlzdGVuZXJDb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBlbWl0dGVyLmxpc3RlbmVyQ291bnQodHlwZSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGxpc3RlbmVyQ291bnQuY2FsbChlbWl0dGVyLCB0eXBlKTtcbiAgfVxufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lckNvdW50ID0gbGlzdGVuZXJDb3VudDtcbmZ1bmN0aW9uIGxpc3RlbmVyQ291bnQodHlwZSkge1xuICB2YXIgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuXG4gIGlmIChldmVudHMgIT09IHVuZGVmaW5lZCkge1xuICAgIHZhciBldmxpc3RlbmVyID0gZXZlbnRzW3R5cGVdO1xuXG4gICAgaWYgKHR5cGVvZiBldmxpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9IGVsc2UgaWYgKGV2bGlzdGVuZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGV2bGlzdGVuZXIubGVuZ3RoO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiAwO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmV2ZW50TmFtZXMgPSBmdW5jdGlvbiBldmVudE5hbWVzKCkge1xuICByZXR1cm4gdGhpcy5fZXZlbnRzQ291bnQgPiAwID8gUmVmbGVjdE93bktleXModGhpcy5fZXZlbnRzKSA6IFtdO1xufTtcblxuZnVuY3Rpb24gYXJyYXlDbG9uZShhcnIsIG4pIHtcbiAgdmFyIGNvcHkgPSBuZXcgQXJyYXkobik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgKytpKVxuICAgIGNvcHlbaV0gPSBhcnJbaV07XG4gIHJldHVybiBjb3B5O1xufVxuXG5mdW5jdGlvbiBzcGxpY2VPbmUobGlzdCwgaW5kZXgpIHtcbiAgZm9yICg7IGluZGV4ICsgMSA8IGxpc3QubGVuZ3RoOyBpbmRleCsrKVxuICAgIGxpc3RbaW5kZXhdID0gbGlzdFtpbmRleCArIDFdO1xuICBsaXN0LnBvcCgpO1xufVxuXG5mdW5jdGlvbiB1bndyYXBMaXN0ZW5lcnMoYXJyKSB7XG4gIHZhciByZXQgPSBuZXcgQXJyYXkoYXJyLmxlbmd0aCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcmV0Lmxlbmd0aDsgKytpKSB7XG4gICAgcmV0W2ldID0gYXJyW2ldLmxpc3RlbmVyIHx8IGFycltpXTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBvbmNlKGVtaXR0ZXIsIG5hbWUpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICBmdW5jdGlvbiBlcnJvckxpc3RlbmVyKGVycikge1xuICAgICAgZW1pdHRlci5yZW1vdmVMaXN0ZW5lcihuYW1lLCByZXNvbHZlcik7XG4gICAgICByZWplY3QoZXJyKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZXNvbHZlcigpIHtcbiAgICAgIGlmICh0eXBlb2YgZW1pdHRlci5yZW1vdmVMaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBlbWl0dGVyLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIGVycm9yTGlzdGVuZXIpO1xuICAgICAgfVxuICAgICAgcmVzb2x2ZShbXS5zbGljZS5jYWxsKGFyZ3VtZW50cykpO1xuICAgIH07XG5cbiAgICBldmVudFRhcmdldEFnbm9zdGljQWRkTGlzdGVuZXIoZW1pdHRlciwgbmFtZSwgcmVzb2x2ZXIsIHsgb25jZTogdHJ1ZSB9KTtcbiAgICBpZiAobmFtZSAhPT0gJ2Vycm9yJykge1xuICAgICAgYWRkRXJyb3JIYW5kbGVySWZFdmVudEVtaXR0ZXIoZW1pdHRlciwgZXJyb3JMaXN0ZW5lciwgeyBvbmNlOiB0cnVlIH0pO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGFkZEVycm9ySGFuZGxlcklmRXZlbnRFbWl0dGVyKGVtaXR0ZXIsIGhhbmRsZXIsIGZsYWdzKSB7XG4gIGlmICh0eXBlb2YgZW1pdHRlci5vbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGV2ZW50VGFyZ2V0QWdub3N0aWNBZGRMaXN0ZW5lcihlbWl0dGVyLCAnZXJyb3InLCBoYW5kbGVyLCBmbGFncyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZXZlbnRUYXJnZXRBZ25vc3RpY0FkZExpc3RlbmVyKGVtaXR0ZXIsIG5hbWUsIGxpc3RlbmVyLCBmbGFncykge1xuICBpZiAodHlwZW9mIGVtaXR0ZXIub24gPT09ICdmdW5jdGlvbicpIHtcbiAgICBpZiAoZmxhZ3Mub25jZSkge1xuICAgICAgZW1pdHRlci5vbmNlKG5hbWUsIGxpc3RlbmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZW1pdHRlci5vbihuYW1lLCBsaXN0ZW5lcik7XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiBlbWl0dGVyLmFkZEV2ZW50TGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBFdmVudFRhcmdldCBkb2VzIG5vdCBoYXZlIGBlcnJvcmAgZXZlbnQgc2VtYW50aWNzIGxpa2UgTm9kZVxuICAgIC8vIEV2ZW50RW1pdHRlcnMsIHdlIGRvIG5vdCBsaXN0ZW4gZm9yIGBlcnJvcmAgZXZlbnRzIGhlcmUuXG4gICAgZW1pdHRlci5hZGRFdmVudExpc3RlbmVyKG5hbWUsIGZ1bmN0aW9uIHdyYXBMaXN0ZW5lcihhcmcpIHtcbiAgICAgIC8vIElFIGRvZXMgbm90IGhhdmUgYnVpbHRpbiBgeyBvbmNlOiB0cnVlIH1gIHN1cHBvcnQgc28gd2VcbiAgICAgIC8vIGhhdmUgdG8gZG8gaXQgbWFudWFsbHkuXG4gICAgICBpZiAoZmxhZ3Mub25jZSkge1xuICAgICAgICBlbWl0dGVyLnJlbW92ZUV2ZW50TGlzdGVuZXIobmFtZSwgd3JhcExpc3RlbmVyKTtcbiAgICAgIH1cbiAgICAgIGxpc3RlbmVyKGFyZyk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwiZW1pdHRlclwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBFdmVudEVtaXR0ZXIuIFJlY2VpdmVkIHR5cGUgJyArIHR5cGVvZiBlbWl0dGVyKTtcbiAgfVxufVxuIiwiLyohXG4gKiBUaGUgYnVmZmVyIG1vZHVsZSBmcm9tIG5vZGUuanMsIGZvciB0aGUgYnJvd3Nlci5cbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xuXG4ndXNlIHN0cmljdCdcblxudmFyIGJhc2U2NCA9IHJlcXVpcmUoJ2Jhc2U2NC1qcycpXG52YXIgaWVlZTc1NCA9IHJlcXVpcmUoJ2llZWU3NTQnKVxuXG5leHBvcnRzLkJ1ZmZlciA9IEJ1ZmZlclxuZXhwb3J0cy5TbG93QnVmZmVyID0gU2xvd0J1ZmZlclxuZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFUyA9IDUwXG5cbnZhciBLX01BWF9MRU5HVEggPSAweDdmZmZmZmZmXG5leHBvcnRzLmtNYXhMZW5ndGggPSBLX01BWF9MRU5HVEhcblxuLyoqXG4gKiBJZiBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgOlxuICogICA9PT0gdHJ1ZSAgICBVc2UgVWludDhBcnJheSBpbXBsZW1lbnRhdGlvbiAoZmFzdGVzdClcbiAqICAgPT09IGZhbHNlICAgUHJpbnQgd2FybmluZyBhbmQgcmVjb21tZW5kIHVzaW5nIGBidWZmZXJgIHY0Lnggd2hpY2ggaGFzIGFuIE9iamVjdFxuICogICAgICAgICAgICAgICBpbXBsZW1lbnRhdGlvbiAobW9zdCBjb21wYXRpYmxlLCBldmVuIElFNilcbiAqXG4gKiBCcm93c2VycyB0aGF0IHN1cHBvcnQgdHlwZWQgYXJyYXlzIGFyZSBJRSAxMCssIEZpcmVmb3ggNCssIENocm9tZSA3KywgU2FmYXJpIDUuMSssXG4gKiBPcGVyYSAxMS42KywgaU9TIDQuMisuXG4gKlxuICogV2UgcmVwb3J0IHRoYXQgdGhlIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCB0eXBlZCBhcnJheXMgaWYgdGhlIGFyZSBub3Qgc3ViY2xhc3NhYmxlXG4gKiB1c2luZyBfX3Byb3RvX18uIEZpcmVmb3ggNC0yOSBsYWNrcyBzdXBwb3J0IGZvciBhZGRpbmcgbmV3IHByb3BlcnRpZXMgdG8gYFVpbnQ4QXJyYXlgXG4gKiAoU2VlOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02OTU0MzgpLiBJRSAxMCBsYWNrcyBzdXBwb3J0XG4gKiBmb3IgX19wcm90b19fIGFuZCBoYXMgYSBidWdneSB0eXBlZCBhcnJheSBpbXBsZW1lbnRhdGlvbi5cbiAqL1xuQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgPSB0eXBlZEFycmF5U3VwcG9ydCgpXG5cbmlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgJiYgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmXG4gICAgdHlwZW9mIGNvbnNvbGUuZXJyb3IgPT09ICdmdW5jdGlvbicpIHtcbiAgY29uc29sZS5lcnJvcihcbiAgICAnVGhpcyBicm93c2VyIGxhY2tzIHR5cGVkIGFycmF5IChVaW50OEFycmF5KSBzdXBwb3J0IHdoaWNoIGlzIHJlcXVpcmVkIGJ5ICcgK1xuICAgICdgYnVmZmVyYCB2NS54LiBVc2UgYGJ1ZmZlcmAgdjQueCBpZiB5b3UgcmVxdWlyZSBvbGQgYnJvd3NlciBzdXBwb3J0LidcbiAgKVxufVxuXG5mdW5jdGlvbiB0eXBlZEFycmF5U3VwcG9ydCAoKSB7XG4gIC8vIENhbiB0eXBlZCBhcnJheSBpbnN0YW5jZXMgY2FuIGJlIGF1Z21lbnRlZD9cbiAgdHJ5IHtcbiAgICB2YXIgYXJyID0gbmV3IFVpbnQ4QXJyYXkoMSlcbiAgICBhcnIuX19wcm90b19fID0geyBfX3Byb3RvX186IFVpbnQ4QXJyYXkucHJvdG90eXBlLCBmb286IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDQyIH0gfVxuICAgIHJldHVybiBhcnIuZm9vKCkgPT09IDQyXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLnByb3RvdHlwZSwgJ3BhcmVudCcsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGhpcykpIHJldHVybiB1bmRlZmluZWRcbiAgICByZXR1cm4gdGhpcy5idWZmZXJcbiAgfVxufSlcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlci5wcm90b3R5cGUsICdvZmZzZXQnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKHRoaXMpKSByZXR1cm4gdW5kZWZpbmVkXG4gICAgcmV0dXJuIHRoaXMuYnl0ZU9mZnNldFxuICB9XG59KVxuXG5mdW5jdGlvbiBjcmVhdGVCdWZmZXIgKGxlbmd0aCkge1xuICBpZiAobGVuZ3RoID4gS19NQVhfTEVOR1RIKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBcIicgKyBsZW5ndGggKyAnXCIgaXMgaW52YWxpZCBmb3Igb3B0aW9uIFwic2l6ZVwiJylcbiAgfVxuICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZVxuICB2YXIgYnVmID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKVxuICBidWYuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICByZXR1cm4gYnVmXG59XG5cbi8qKlxuICogVGhlIEJ1ZmZlciBjb25zdHJ1Y3RvciByZXR1cm5zIGluc3RhbmNlcyBvZiBgVWludDhBcnJheWAgdGhhdCBoYXZlIHRoZWlyXG4gKiBwcm90b3R5cGUgY2hhbmdlZCB0byBgQnVmZmVyLnByb3RvdHlwZWAuIEZ1cnRoZXJtb3JlLCBgQnVmZmVyYCBpcyBhIHN1YmNsYXNzIG9mXG4gKiBgVWludDhBcnJheWAsIHNvIHRoZSByZXR1cm5lZCBpbnN0YW5jZXMgd2lsbCBoYXZlIGFsbCB0aGUgbm9kZSBgQnVmZmVyYCBtZXRob2RzXG4gKiBhbmQgdGhlIGBVaW50OEFycmF5YCBtZXRob2RzLiBTcXVhcmUgYnJhY2tldCBub3RhdGlvbiB3b3JrcyBhcyBleHBlY3RlZCAtLSBpdFxuICogcmV0dXJucyBhIHNpbmdsZSBvY3RldC5cbiAqXG4gKiBUaGUgYFVpbnQ4QXJyYXlgIHByb3RvdHlwZSByZW1haW5zIHVubW9kaWZpZWQuXG4gKi9cblxuZnVuY3Rpb24gQnVmZmVyIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICAvLyBDb21tb24gY2FzZS5cbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZ09yT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgJ1RoZSBcInN0cmluZ1wiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBzdHJpbmcuIFJlY2VpdmVkIHR5cGUgbnVtYmVyJ1xuICAgICAgKVxuICAgIH1cbiAgICByZXR1cm4gYWxsb2NVbnNhZmUoYXJnKVxuICB9XG4gIHJldHVybiBmcm9tKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG4vLyBGaXggc3ViYXJyYXkoKSBpbiBFUzIwMTYuIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvcHVsbC85N1xuaWYgKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC5zcGVjaWVzICE9IG51bGwgJiZcbiAgICBCdWZmZXJbU3ltYm9sLnNwZWNpZXNdID09PSBCdWZmZXIpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlciwgU3ltYm9sLnNwZWNpZXMsIHtcbiAgICB2YWx1ZTogbnVsbCxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgd3JpdGFibGU6IGZhbHNlXG4gIH0pXG59XG5cbkJ1ZmZlci5wb29sU2l6ZSA9IDgxOTIgLy8gbm90IHVzZWQgYnkgdGhpcyBpbXBsZW1lbnRhdGlvblxuXG5mdW5jdGlvbiBmcm9tICh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGZyb21TdHJpbmcodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQpXG4gIH1cblxuICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KHZhbHVlKSkge1xuICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKHZhbHVlKVxuICB9XG5cbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICB0aHJvdyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgJyArXG4gICAgICAnb3IgQXJyYXktbGlrZSBPYmplY3QuIFJlY2VpdmVkIHR5cGUgJyArICh0eXBlb2YgdmFsdWUpXG4gICAgKVxuICB9XG5cbiAgaWYgKGlzSW5zdGFuY2UodmFsdWUsIEFycmF5QnVmZmVyKSB8fFxuICAgICAgKHZhbHVlICYmIGlzSW5zdGFuY2UodmFsdWUuYnVmZmVyLCBBcnJheUJ1ZmZlcikpKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheUJ1ZmZlcih2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBcInZhbHVlXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgb2YgdHlwZSBudW1iZXIuIFJlY2VpdmVkIHR5cGUgbnVtYmVyJ1xuICAgIClcbiAgfVxuXG4gIHZhciB2YWx1ZU9mID0gdmFsdWUudmFsdWVPZiAmJiB2YWx1ZS52YWx1ZU9mKClcbiAgaWYgKHZhbHVlT2YgIT0gbnVsbCAmJiB2YWx1ZU9mICE9PSB2YWx1ZSkge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbSh2YWx1ZU9mLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICB2YXIgYiA9IGZyb21PYmplY3QodmFsdWUpXG4gIGlmIChiKSByZXR1cm4gYlxuXG4gIGlmICh0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9QcmltaXRpdmUgIT0gbnVsbCAmJlxuICAgICAgdHlwZW9mIHZhbHVlW1N5bWJvbC50b1ByaW1pdGl2ZV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20oXG4gICAgICB2YWx1ZVtTeW1ib2wudG9QcmltaXRpdmVdKCdzdHJpbmcnKSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoXG4gICAgKVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAnVGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgJyArXG4gICAgJ29yIEFycmF5LWxpa2UgT2JqZWN0LiBSZWNlaXZlZCB0eXBlICcgKyAodHlwZW9mIHZhbHVlKVxuICApXG59XG5cbi8qKlxuICogRnVuY3Rpb25hbGx5IGVxdWl2YWxlbnQgdG8gQnVmZmVyKGFyZywgZW5jb2RpbmcpIGJ1dCB0aHJvd3MgYSBUeXBlRXJyb3JcbiAqIGlmIHZhbHVlIGlzIGEgbnVtYmVyLlxuICogQnVmZmVyLmZyb20oc3RyWywgZW5jb2RpbmddKVxuICogQnVmZmVyLmZyb20oYXJyYXkpXG4gKiBCdWZmZXIuZnJvbShidWZmZXIpXG4gKiBCdWZmZXIuZnJvbShhcnJheUJ1ZmZlclssIGJ5dGVPZmZzZXRbLCBsZW5ndGhdXSlcbiAqKi9cbkJ1ZmZlci5mcm9tID0gZnVuY3Rpb24gKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGZyb20odmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuLy8gTm90ZTogQ2hhbmdlIHByb3RvdHlwZSAqYWZ0ZXIqIEJ1ZmZlci5mcm9tIGlzIGRlZmluZWQgdG8gd29ya2Fyb3VuZCBDaHJvbWUgYnVnOlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvcHVsbC8xNDhcbkJ1ZmZlci5wcm90b3R5cGUuX19wcm90b19fID0gVWludDhBcnJheS5wcm90b3R5cGVcbkJ1ZmZlci5fX3Byb3RvX18gPSBVaW50OEFycmF5XG5cbmZ1bmN0aW9uIGFzc2VydFNpemUgKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBudW1iZXInKVxuICB9IGVsc2UgaWYgKHNpemUgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBcIicgKyBzaXplICsgJ1wiIGlzIGludmFsaWQgZm9yIG9wdGlvbiBcInNpemVcIicpXG4gIH1cbn1cblxuZnVuY3Rpb24gYWxsb2MgKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgaWYgKHNpemUgPD0gMCkge1xuICAgIHJldHVybiBjcmVhdGVCdWZmZXIoc2l6ZSlcbiAgfVxuICBpZiAoZmlsbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gT25seSBwYXkgYXR0ZW50aW9uIHRvIGVuY29kaW5nIGlmIGl0J3MgYSBzdHJpbmcuIFRoaXNcbiAgICAvLyBwcmV2ZW50cyBhY2NpZGVudGFsbHkgc2VuZGluZyBpbiBhIG51bWJlciB0aGF0IHdvdWxkXG4gICAgLy8gYmUgaW50ZXJwcmV0dGVkIGFzIGEgc3RhcnQgb2Zmc2V0LlxuICAgIHJldHVybiB0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnXG4gICAgICA/IGNyZWF0ZUJ1ZmZlcihzaXplKS5maWxsKGZpbGwsIGVuY29kaW5nKVxuICAgICAgOiBjcmVhdGVCdWZmZXIoc2l6ZSkuZmlsbChmaWxsKVxuICB9XG4gIHJldHVybiBjcmVhdGVCdWZmZXIoc2l6ZSlcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiBhbGxvYyhzaXplWywgZmlsbFssIGVuY29kaW5nXV0pXG4gKiovXG5CdWZmZXIuYWxsb2MgPSBmdW5jdGlvbiAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGFsbG9jKHNpemUsIGZpbGwsIGVuY29kaW5nKVxufVxuXG5mdW5jdGlvbiBhbGxvY1Vuc2FmZSAoc2l6ZSkge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIHJldHVybiBjcmVhdGVCdWZmZXIoc2l6ZSA8IDAgPyAwIDogY2hlY2tlZChzaXplKSB8IDApXG59XG5cbi8qKlxuICogRXF1aXZhbGVudCB0byBCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqICovXG5CdWZmZXIuYWxsb2NVbnNhZmUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUoc2l6ZSlcbn1cbi8qKlxuICogRXF1aXZhbGVudCB0byBTbG93QnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUoc2l6ZSlcbn1cblxuZnVuY3Rpb24gZnJvbVN0cmluZyAoc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJyB8fCBlbmNvZGluZyA9PT0gJycpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICB9XG5cbiAgaWYgKCFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gIH1cblxuICB2YXIgbGVuZ3RoID0gYnl0ZUxlbmd0aChzdHJpbmcsIGVuY29kaW5nKSB8IDBcbiAgdmFyIGJ1ZiA9IGNyZWF0ZUJ1ZmZlcihsZW5ndGgpXG5cbiAgdmFyIGFjdHVhbCA9IGJ1Zi53cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuXG4gIGlmIChhY3R1YWwgIT09IGxlbmd0aCkge1xuICAgIC8vIFdyaXRpbmcgYSBoZXggc3RyaW5nLCBmb3IgZXhhbXBsZSwgdGhhdCBjb250YWlucyBpbnZhbGlkIGNoYXJhY3RlcnMgd2lsbFxuICAgIC8vIGNhdXNlIGV2ZXJ5dGhpbmcgYWZ0ZXIgdGhlIGZpcnN0IGludmFsaWQgY2hhcmFjdGVyIHRvIGJlIGlnbm9yZWQuIChlLmcuXG4gICAgLy8gJ2FieHhjZCcgd2lsbCBiZSB0cmVhdGVkIGFzICdhYicpXG4gICAgYnVmID0gYnVmLnNsaWNlKDAsIGFjdHVhbClcbiAgfVxuXG4gIHJldHVybiBidWZcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5TGlrZSAoYXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCA8IDAgPyAwIDogY2hlY2tlZChhcnJheS5sZW5ndGgpIHwgMFxuICB2YXIgYnVmID0gY3JlYXRlQnVmZmVyKGxlbmd0aClcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgIGJ1ZltpXSA9IGFycmF5W2ldICYgMjU1XG4gIH1cbiAgcmV0dXJuIGJ1ZlxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlCdWZmZXIgKGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKGJ5dGVPZmZzZXQgPCAwIHx8IGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0KSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1wib2Zmc2V0XCIgaXMgb3V0c2lkZSBvZiBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIGlmIChhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCArIChsZW5ndGggfHwgMCkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJsZW5ndGhcIiBpcyBvdXRzaWRlIG9mIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgdmFyIGJ1ZlxuICBpZiAoYnl0ZU9mZnNldCA9PT0gdW5kZWZpbmVkICYmIGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYnVmID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXkpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBidWYgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldClcbiAgfSBlbHNlIHtcbiAgICBidWYgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2VcbiAgYnVmLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgcmV0dXJuIGJ1ZlxufVxuXG5mdW5jdGlvbiBmcm9tT2JqZWN0IChvYmopIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihvYmopKSB7XG4gICAgdmFyIGxlbiA9IGNoZWNrZWQob2JqLmxlbmd0aCkgfCAwXG4gICAgdmFyIGJ1ZiA9IGNyZWF0ZUJ1ZmZlcihsZW4pXG5cbiAgICBpZiAoYnVmLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGJ1ZlxuICAgIH1cblxuICAgIG9iai5jb3B5KGJ1ZiwgMCwgMCwgbGVuKVxuICAgIHJldHVybiBidWZcbiAgfVxuXG4gIGlmIChvYmoubGVuZ3RoICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAodHlwZW9mIG9iai5sZW5ndGggIT09ICdudW1iZXInIHx8IG51bWJlcklzTmFOKG9iai5sZW5ndGgpKSB7XG4gICAgICByZXR1cm4gY3JlYXRlQnVmZmVyKDApXG4gICAgfVxuICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKG9iailcbiAgfVxuXG4gIGlmIChvYmoudHlwZSA9PT0gJ0J1ZmZlcicgJiYgQXJyYXkuaXNBcnJheShvYmouZGF0YSkpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5TGlrZShvYmouZGF0YSlcbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja2VkIChsZW5ndGgpIHtcbiAgLy8gTm90ZTogY2Fubm90IHVzZSBgbGVuZ3RoIDwgS19NQVhfTEVOR1RIYCBoZXJlIGJlY2F1c2UgdGhhdCBmYWlscyB3aGVuXG4gIC8vIGxlbmd0aCBpcyBOYU4gKHdoaWNoIGlzIG90aGVyd2lzZSBjb2VyY2VkIHRvIHplcm8uKVxuICBpZiAobGVuZ3RoID49IEtfTUFYX0xFTkdUSCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIGFsbG9jYXRlIEJ1ZmZlciBsYXJnZXIgdGhhbiBtYXhpbXVtICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICdzaXplOiAweCcgKyBLX01BWF9MRU5HVEgudG9TdHJpbmcoMTYpICsgJyBieXRlcycpXG4gIH1cbiAgcmV0dXJuIGxlbmd0aCB8IDBcbn1cblxuZnVuY3Rpb24gU2xvd0J1ZmZlciAobGVuZ3RoKSB7XG4gIGlmICgrbGVuZ3RoICE9IGxlbmd0aCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVxZXFlcVxuICAgIGxlbmd0aCA9IDBcbiAgfVxuICByZXR1cm4gQnVmZmVyLmFsbG9jKCtsZW5ndGgpXG59XG5cbkJ1ZmZlci5pc0J1ZmZlciA9IGZ1bmN0aW9uIGlzQnVmZmVyIChiKSB7XG4gIHJldHVybiBiICE9IG51bGwgJiYgYi5faXNCdWZmZXIgPT09IHRydWUgJiZcbiAgICBiICE9PSBCdWZmZXIucHJvdG90eXBlIC8vIHNvIEJ1ZmZlci5pc0J1ZmZlcihCdWZmZXIucHJvdG90eXBlKSB3aWxsIGJlIGZhbHNlXG59XG5cbkJ1ZmZlci5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAoYSwgYikge1xuICBpZiAoaXNJbnN0YW5jZShhLCBVaW50OEFycmF5KSkgYSA9IEJ1ZmZlci5mcm9tKGEsIGEub2Zmc2V0LCBhLmJ5dGVMZW5ndGgpXG4gIGlmIChpc0luc3RhbmNlKGIsIFVpbnQ4QXJyYXkpKSBiID0gQnVmZmVyLmZyb20oYiwgYi5vZmZzZXQsIGIuYnl0ZUxlbmd0aClcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYSkgfHwgIUJ1ZmZlci5pc0J1ZmZlcihiKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIFwiYnVmMVwiLCBcImJ1ZjJcIiBhcmd1bWVudHMgbXVzdCBiZSBvbmUgb2YgdHlwZSBCdWZmZXIgb3IgVWludDhBcnJheSdcbiAgICApXG4gIH1cblxuICBpZiAoYSA9PT0gYikgcmV0dXJuIDBcblxuICB2YXIgeCA9IGEubGVuZ3RoXG4gIHZhciB5ID0gYi5sZW5ndGhcblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gTWF0aC5taW4oeCwgeSk7IGkgPCBsZW47ICsraSkge1xuICAgIGlmIChhW2ldICE9PSBiW2ldKSB7XG4gICAgICB4ID0gYVtpXVxuICAgICAgeSA9IGJbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG5CdWZmZXIuaXNFbmNvZGluZyA9IGZ1bmN0aW9uIGlzRW5jb2RpbmcgKGVuY29kaW5nKSB7XG4gIHN3aXRjaCAoU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgY2FzZSAnYXNjaWknOlxuICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5CdWZmZXIuY29uY2F0ID0gZnVuY3Rpb24gY29uY2F0IChsaXN0LCBsZW5ndGgpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGxpc3QpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgfVxuXG4gIGlmIChsaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBCdWZmZXIuYWxsb2MoMClcbiAgfVxuXG4gIHZhciBpXG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGxlbmd0aCA9IDBcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgICAgbGVuZ3RoICs9IGxpc3RbaV0ubGVuZ3RoXG4gICAgfVxuICB9XG5cbiAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShsZW5ndGgpXG4gIHZhciBwb3MgPSAwXG4gIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGJ1ZiA9IGxpc3RbaV1cbiAgICBpZiAoaXNJbnN0YW5jZShidWYsIFVpbnQ4QXJyYXkpKSB7XG4gICAgICBidWYgPSBCdWZmZXIuZnJvbShidWYpXG4gICAgfVxuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gICAgfVxuICAgIGJ1Zi5jb3B5KGJ1ZmZlciwgcG9zKVxuICAgIHBvcyArPSBidWYubGVuZ3RoXG4gIH1cbiAgcmV0dXJuIGJ1ZmZlclxufVxuXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoc3RyaW5nKSkge1xuICAgIHJldHVybiBzdHJpbmcubGVuZ3RoXG4gIH1cbiAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhzdHJpbmcpIHx8IGlzSW5zdGFuY2Uoc3RyaW5nLCBBcnJheUJ1ZmZlcikpIHtcbiAgICByZXR1cm4gc3RyaW5nLmJ5dGVMZW5ndGhcbiAgfVxuICBpZiAodHlwZW9mIHN0cmluZyAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBcInN0cmluZ1wiIGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgc3RyaW5nLCBCdWZmZXIsIG9yIEFycmF5QnVmZmVyLiAnICtcbiAgICAgICdSZWNlaXZlZCB0eXBlICcgKyB0eXBlb2Ygc3RyaW5nXG4gICAgKVxuICB9XG5cbiAgdmFyIGxlbiA9IHN0cmluZy5sZW5ndGhcbiAgdmFyIG11c3RNYXRjaCA9IChhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gPT09IHRydWUpXG4gIGlmICghbXVzdE1hdGNoICYmIGxlbiA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBVc2UgYSBmb3IgbG9vcCB0byBhdm9pZCByZWN1cnNpb25cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGVuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gbGVuICogMlxuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGxlbiA+Pj4gMVxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkge1xuICAgICAgICAgIHJldHVybiBtdXN0TWF0Y2ggPyAtMSA6IHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoIC8vIGFzc3VtZSB1dGY4XG4gICAgICAgIH1cbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cbkJ1ZmZlci5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuXG5mdW5jdGlvbiBzbG93VG9TdHJpbmcgKGVuY29kaW5nLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG5cbiAgLy8gTm8gbmVlZCB0byB2ZXJpZnkgdGhhdCBcInRoaXMubGVuZ3RoIDw9IE1BWF9VSU5UMzJcIiBzaW5jZSBpdCdzIGEgcmVhZC1vbmx5XG4gIC8vIHByb3BlcnR5IG9mIGEgdHlwZWQgYXJyYXkuXG5cbiAgLy8gVGhpcyBiZWhhdmVzIG5laXRoZXIgbGlrZSBTdHJpbmcgbm9yIFVpbnQ4QXJyYXkgaW4gdGhhdCB3ZSBzZXQgc3RhcnQvZW5kXG4gIC8vIHRvIHRoZWlyIHVwcGVyL2xvd2VyIGJvdW5kcyBpZiB0aGUgdmFsdWUgcGFzc2VkIGlzIG91dCBvZiByYW5nZS5cbiAgLy8gdW5kZWZpbmVkIGlzIGhhbmRsZWQgc3BlY2lhbGx5IGFzIHBlciBFQ01BLTI2MiA2dGggRWRpdGlvbixcbiAgLy8gU2VjdGlvbiAxMy4zLjMuNyBSdW50aW1lIFNlbWFudGljczogS2V5ZWRCaW5kaW5nSW5pdGlhbGl6YXRpb24uXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkIHx8IHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIC8vIFJldHVybiBlYXJseSBpZiBzdGFydCA+IHRoaXMubGVuZ3RoLiBEb25lIGhlcmUgdG8gcHJldmVudCBwb3RlbnRpYWwgdWludDMyXG4gIC8vIGNvZXJjaW9uIGZhaWwgYmVsb3cuXG4gIGlmIChzdGFydCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoZW5kID09PSB1bmRlZmluZWQgfHwgZW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKGVuZCA8PSAwKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICAvLyBGb3JjZSBjb2Vyc2lvbiB0byB1aW50MzIuIFRoaXMgd2lsbCBhbHNvIGNvZXJjZSBmYWxzZXkvTmFOIHZhbHVlcyB0byAwLlxuICBlbmQgPj4+PSAwXG4gIHN0YXJ0ID4+Pj0gMFxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxhdGluMVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdXRmMTZsZVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9IChlbmNvZGluZyArICcnKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG4vLyBUaGlzIHByb3BlcnR5IGlzIHVzZWQgYnkgYEJ1ZmZlci5pc0J1ZmZlcmAgKGFuZCB0aGUgYGlzLWJ1ZmZlcmAgbnBtIHBhY2thZ2UpXG4vLyB0byBkZXRlY3QgYSBCdWZmZXIgaW5zdGFuY2UuIEl0J3Mgbm90IHBvc3NpYmxlIHRvIHVzZSBgaW5zdGFuY2VvZiBCdWZmZXJgXG4vLyByZWxpYWJseSBpbiBhIGJyb3dzZXJpZnkgY29udGV4dCBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIG11bHRpcGxlIGRpZmZlcmVudFxuLy8gY29waWVzIG9mIHRoZSAnYnVmZmVyJyBwYWNrYWdlIGluIHVzZS4gVGhpcyBtZXRob2Qgd29ya3MgZXZlbiBmb3IgQnVmZmVyXG4vLyBpbnN0YW5jZXMgdGhhdCB3ZXJlIGNyZWF0ZWQgZnJvbSBhbm90aGVyIGNvcHkgb2YgdGhlIGBidWZmZXJgIHBhY2thZ2UuXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL2lzc3Vlcy8xNTRcbkJ1ZmZlci5wcm90b3R5cGUuX2lzQnVmZmVyID0gdHJ1ZVxuXG5mdW5jdGlvbiBzd2FwIChiLCBuLCBtKSB7XG4gIHZhciBpID0gYltuXVxuICBiW25dID0gYlttXVxuICBiW21dID0gaVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAxNiA9IGZ1bmN0aW9uIHN3YXAxNiAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgMiAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMTYtYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gMikge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDEpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMzIgPSBmdW5jdGlvbiBzd2FwMzIgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDQgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDMyLWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAzKVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyAyKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDY0ID0gZnVuY3Rpb24gc3dhcDY0ICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSA4ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA2NC1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA4KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgNylcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgNilcbiAgICBzd2FwKHRoaXMsIGkgKyAyLCBpICsgNSlcbiAgICBzd2FwKHRoaXMsIGkgKyAzLCBpICsgNClcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICB2YXIgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbmd0aCA9PT0gMCkgcmV0dXJuICcnXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIDAsIGxlbmd0aClcbiAgcmV0dXJuIHNsb3dUb1N0cmluZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9Mb2NhbGVTdHJpbmcgPSBCdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nXG5cbkJ1ZmZlci5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzIChiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgaWYgKHRoaXMgPT09IGIpIHJldHVybiB0cnVlXG4gIHJldHVybiBCdWZmZXIuY29tcGFyZSh0aGlzLCBiKSA9PT0gMFxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0ICgpIHtcbiAgdmFyIHN0ciA9ICcnXG4gIHZhciBtYXggPSBleHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTXG4gIHN0ciA9IHRoaXMudG9TdHJpbmcoJ2hleCcsIDAsIG1heCkucmVwbGFjZSgvKC57Mn0pL2csICckMSAnKS50cmltKClcbiAgaWYgKHRoaXMubGVuZ3RoID4gbWF4KSBzdHIgKz0gJyAuLi4gJ1xuICByZXR1cm4gJzxCdWZmZXIgJyArIHN0ciArICc+J1xufVxuXG5CdWZmZXIucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlICh0YXJnZXQsIHN0YXJ0LCBlbmQsIHRoaXNTdGFydCwgdGhpc0VuZCkge1xuICBpZiAoaXNJbnN0YW5jZSh0YXJnZXQsIFVpbnQ4QXJyYXkpKSB7XG4gICAgdGFyZ2V0ID0gQnVmZmVyLmZyb20odGFyZ2V0LCB0YXJnZXQub2Zmc2V0LCB0YXJnZXQuYnl0ZUxlbmd0aClcbiAgfVxuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0YXJnZXQpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdUaGUgXCJ0YXJnZXRcIiBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIEJ1ZmZlciBvciBVaW50OEFycmF5LiAnICtcbiAgICAgICdSZWNlaXZlZCB0eXBlICcgKyAodHlwZW9mIHRhcmdldClcbiAgICApXG4gIH1cblxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuZCA9IHRhcmdldCA/IHRhcmdldC5sZW5ndGggOiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc1N0YXJ0ID0gMFxuICB9XG4gIGlmICh0aGlzRW5kID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzRW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChzdGFydCA8IDAgfHwgZW5kID4gdGFyZ2V0Lmxlbmd0aCB8fCB0aGlzU3RhcnQgPCAwIHx8IHRoaXNFbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdvdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kICYmIHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kKSB7XG4gICAgcmV0dXJuIC0xXG4gIH1cbiAgaWYgKHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAxXG4gIH1cblxuICBzdGFydCA+Pj49IDBcbiAgZW5kID4+Pj0gMFxuICB0aGlzU3RhcnQgPj4+PSAwXG4gIHRoaXNFbmQgPj4+PSAwXG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCkgcmV0dXJuIDBcblxuICB2YXIgeCA9IHRoaXNFbmQgLSB0aGlzU3RhcnRcbiAgdmFyIHkgPSBlbmQgLSBzdGFydFxuICB2YXIgbGVuID0gTWF0aC5taW4oeCwgeSlcblxuICB2YXIgdGhpc0NvcHkgPSB0aGlzLnNsaWNlKHRoaXNTdGFydCwgdGhpc0VuZClcbiAgdmFyIHRhcmdldENvcHkgPSB0YXJnZXQuc2xpY2Uoc3RhcnQsIGVuZClcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKHRoaXNDb3B5W2ldICE9PSB0YXJnZXRDb3B5W2ldKSB7XG4gICAgICB4ID0gdGhpc0NvcHlbaV1cbiAgICAgIHkgPSB0YXJnZXRDb3B5W2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuLy8gRmluZHMgZWl0aGVyIHRoZSBmaXJzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPj0gYGJ5dGVPZmZzZXRgLFxuLy8gT1IgdGhlIGxhc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0IDw9IGBieXRlT2Zmc2V0YC5cbi8vXG4vLyBBcmd1bWVudHM6XG4vLyAtIGJ1ZmZlciAtIGEgQnVmZmVyIHRvIHNlYXJjaFxuLy8gLSB2YWwgLSBhIHN0cmluZywgQnVmZmVyLCBvciBudW1iZXJcbi8vIC0gYnl0ZU9mZnNldCAtIGFuIGluZGV4IGludG8gYGJ1ZmZlcmA7IHdpbGwgYmUgY2xhbXBlZCB0byBhbiBpbnQzMlxuLy8gLSBlbmNvZGluZyAtIGFuIG9wdGlvbmFsIGVuY29kaW5nLCByZWxldmFudCBpcyB2YWwgaXMgYSBzdHJpbmdcbi8vIC0gZGlyIC0gdHJ1ZSBmb3IgaW5kZXhPZiwgZmFsc2UgZm9yIGxhc3RJbmRleE9mXG5mdW5jdGlvbiBiaWRpcmVjdGlvbmFsSW5kZXhPZiAoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgLy8gRW1wdHkgYnVmZmVyIG1lYW5zIG5vIG1hdGNoXG4gIGlmIChidWZmZXIubGVuZ3RoID09PSAwKSByZXR1cm4gLTFcblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldFxuICBpZiAodHlwZW9mIGJ5dGVPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBieXRlT2Zmc2V0XG4gICAgYnl0ZU9mZnNldCA9IDBcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0ID4gMHg3ZmZmZmZmZikge1xuICAgIGJ5dGVPZmZzZXQgPSAweDdmZmZmZmZmXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IC0weDgwMDAwMDAwKSB7XG4gICAgYnl0ZU9mZnNldCA9IC0weDgwMDAwMDAwXG4gIH1cbiAgYnl0ZU9mZnNldCA9ICtieXRlT2Zmc2V0IC8vIENvZXJjZSB0byBOdW1iZXIuXG4gIGlmIChudW1iZXJJc05hTihieXRlT2Zmc2V0KSkge1xuICAgIC8vIGJ5dGVPZmZzZXQ6IGl0IGl0J3MgdW5kZWZpbmVkLCBudWxsLCBOYU4sIFwiZm9vXCIsIGV0Yywgc2VhcmNoIHdob2xlIGJ1ZmZlclxuICAgIGJ5dGVPZmZzZXQgPSBkaXIgPyAwIDogKGJ1ZmZlci5sZW5ndGggLSAxKVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXQ6IG5lZ2F0aXZlIG9mZnNldHMgc3RhcnQgZnJvbSB0aGUgZW5kIG9mIHRoZSBidWZmZXJcbiAgaWYgKGJ5dGVPZmZzZXQgPCAwKSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCArIGJ5dGVPZmZzZXRcbiAgaWYgKGJ5dGVPZmZzZXQgPj0gYnVmZmVyLmxlbmd0aCkge1xuICAgIGlmIChkaXIpIHJldHVybiAtMVxuICAgIGVsc2UgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggLSAxXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IDApIHtcbiAgICBpZiAoZGlyKSBieXRlT2Zmc2V0ID0gMFxuICAgIGVsc2UgcmV0dXJuIC0xXG4gIH1cblxuICAvLyBOb3JtYWxpemUgdmFsXG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIHZhbCA9IEJ1ZmZlci5mcm9tKHZhbCwgZW5jb2RpbmcpXG4gIH1cblxuICAvLyBGaW5hbGx5LCBzZWFyY2ggZWl0aGVyIGluZGV4T2YgKGlmIGRpciBpcyB0cnVlKSBvciBsYXN0SW5kZXhPZlxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbCkpIHtcbiAgICAvLyBTcGVjaWFsIGNhc2U6IGxvb2tpbmcgZm9yIGVtcHR5IHN0cmluZy9idWZmZXIgYWx3YXlzIGZhaWxzXG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiAtMVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMHhGRiAvLyBTZWFyY2ggZm9yIGEgYnl0ZSB2YWx1ZSBbMC0yNTVdXG4gICAgaWYgKHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAoZGlyKSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUubGFzdEluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIFsgdmFsIF0sIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCd2YWwgbXVzdCBiZSBzdHJpbmcsIG51bWJlciBvciBCdWZmZXInKVxufVxuXG5mdW5jdGlvbiBhcnJheUluZGV4T2YgKGFyciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIHZhciBpbmRleFNpemUgPSAxXG4gIHZhciBhcnJMZW5ndGggPSBhcnIubGVuZ3RoXG4gIHZhciB2YWxMZW5ndGggPSB2YWwubGVuZ3RoXG5cbiAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgIGlmIChlbmNvZGluZyA9PT0gJ3VjczInIHx8IGVuY29kaW5nID09PSAndWNzLTInIHx8XG4gICAgICAgIGVuY29kaW5nID09PSAndXRmMTZsZScgfHwgZW5jb2RpbmcgPT09ICd1dGYtMTZsZScpIHtcbiAgICAgIGlmIChhcnIubGVuZ3RoIDwgMiB8fCB2YWwubGVuZ3RoIDwgMikge1xuICAgICAgICByZXR1cm4gLTFcbiAgICAgIH1cbiAgICAgIGluZGV4U2l6ZSA9IDJcbiAgICAgIGFyckxlbmd0aCAvPSAyXG4gICAgICB2YWxMZW5ndGggLz0gMlxuICAgICAgYnl0ZU9mZnNldCAvPSAyXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZCAoYnVmLCBpKSB7XG4gICAgaWYgKGluZGV4U2l6ZSA9PT0gMSkge1xuICAgICAgcmV0dXJuIGJ1ZltpXVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYnVmLnJlYWRVSW50MTZCRShpICogaW5kZXhTaXplKVxuICAgIH1cbiAgfVxuXG4gIHZhciBpXG4gIGlmIChkaXIpIHtcbiAgICB2YXIgZm91bmRJbmRleCA9IC0xXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA8IGFyckxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAocmVhZChhcnIsIGkpID09PSByZWFkKHZhbCwgZm91bmRJbmRleCA9PT0gLTEgPyAwIDogaSAtIGZvdW5kSW5kZXgpKSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ID09PSAtMSkgZm91bmRJbmRleCA9IGlcbiAgICAgICAgaWYgKGkgLSBmb3VuZEluZGV4ICsgMSA9PT0gdmFsTGVuZ3RoKSByZXR1cm4gZm91bmRJbmRleCAqIGluZGV4U2l6ZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggIT09IC0xKSBpIC09IGkgLSBmb3VuZEluZGV4XG4gICAgICAgIGZvdW5kSW5kZXggPSAtMVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoYnl0ZU9mZnNldCArIHZhbExlbmd0aCA+IGFyckxlbmd0aCkgYnl0ZU9mZnNldCA9IGFyckxlbmd0aCAtIHZhbExlbmd0aFxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgZm91bmQgPSB0cnVlXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHZhbExlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmIChyZWFkKGFyciwgaSArIGopICE9PSByZWFkKHZhbCwgaikpIHtcbiAgICAgICAgICBmb3VuZCA9IGZhbHNlXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGZvdW5kKSByZXR1cm4gaVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluY2x1ZGVzID0gZnVuY3Rpb24gaW5jbHVkZXMgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIHRoaXMuaW5kZXhPZih2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSAhPT0gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24gaW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgdHJ1ZSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5sYXN0SW5kZXhPZiA9IGZ1bmN0aW9uIGxhc3RJbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBmYWxzZSlcbn1cblxuZnVuY3Rpb24gaGV4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwXG4gIHZhciByZW1haW5pbmcgPSBidWYubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gIH0gZWxzZSB7XG4gICAgbGVuZ3RoID0gTnVtYmVyKGxlbmd0aClcbiAgICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7XG4gICAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgICB9XG4gIH1cblxuICB2YXIgc3RyTGVuID0gc3RyaW5nLmxlbmd0aFxuXG4gIGlmIChsZW5ndGggPiBzdHJMZW4gLyAyKSB7XG4gICAgbGVuZ3RoID0gc3RyTGVuIC8gMlxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgcGFyc2VkID0gcGFyc2VJbnQoc3RyaW5nLnN1YnN0cihpICogMiwgMiksIDE2KVxuICAgIGlmIChudW1iZXJJc05hTihwYXJzZWQpKSByZXR1cm4gaVxuICAgIGJ1ZltvZmZzZXQgKyBpXSA9IHBhcnNlZFxuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIHV0ZjhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjhUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGFzY2lpV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihhc2NpaVRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gbGF0aW4xV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYXNjaWlXcml0ZShidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGJhc2U2NFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYmFzZTY0VG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiB1Y3MyV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGYxNmxlVG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gd3JpdGUgKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKSB7XG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcpXG4gIGlmIChvZmZzZXQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBvZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBvZmZzZXRcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgb2Zmc2V0WywgbGVuZ3RoXVssIGVuY29kaW5nXSlcbiAgfSBlbHNlIGlmIChpc0Zpbml0ZShvZmZzZXQpKSB7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gICAgaWYgKGlzRmluaXRlKGxlbmd0aCkpIHtcbiAgICAgIGxlbmd0aCA9IGxlbmd0aCA+Pj4gMFxuICAgICAgaWYgKGVuY29kaW5nID09PSB1bmRlZmluZWQpIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgfSBlbHNlIHtcbiAgICAgIGVuY29kaW5nID0gbGVuZ3RoXG4gICAgICBsZW5ndGggPSB1bmRlZmluZWRcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ0J1ZmZlci53cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXRbLCBsZW5ndGhdKSBpcyBubyBsb25nZXIgc3VwcG9ydGVkJ1xuICAgIClcbiAgfVxuXG4gIHZhciByZW1haW5pbmcgPSB0aGlzLmxlbmd0aCAtIG9mZnNldFxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgfHwgbGVuZ3RoID4gcmVtYWluaW5nKSBsZW5ndGggPSByZW1haW5pbmdcblxuICBpZiAoKHN0cmluZy5sZW5ndGggPiAwICYmIChsZW5ndGggPCAwIHx8IG9mZnNldCA8IDApKSB8fCBvZmZzZXQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIHdyaXRlIG91dHNpZGUgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxhdGluMVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIC8vIFdhcm5pbmc6IG1heExlbmd0aCBub3QgdGFrZW4gaW50byBhY2NvdW50IGluIGJhc2U2NFdyaXRlXG4gICAgICAgIHJldHVybiBiYXNlNjRXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdWNzMldyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTiAoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ0J1ZmZlcicsXG4gICAgZGF0YTogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5fYXJyIHx8IHRoaXMsIDApXG4gIH1cbn1cblxuZnVuY3Rpb24gYmFzZTY0U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBpZiAoc3RhcnQgPT09IDAgJiYgZW5kID09PSBidWYubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1ZilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmLnNsaWNlKHN0YXJ0LCBlbmQpKVxuICB9XG59XG5cbmZ1bmN0aW9uIHV0ZjhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcbiAgdmFyIHJlcyA9IFtdXG5cbiAgdmFyIGkgPSBzdGFydFxuICB3aGlsZSAoaSA8IGVuZCkge1xuICAgIHZhciBmaXJzdEJ5dGUgPSBidWZbaV1cbiAgICB2YXIgY29kZVBvaW50ID0gbnVsbFxuICAgIHZhciBieXRlc1BlclNlcXVlbmNlID0gKGZpcnN0Qnl0ZSA+IDB4RUYpID8gNFxuICAgICAgOiAoZmlyc3RCeXRlID4gMHhERikgPyAzXG4gICAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4QkYpID8gMlxuICAgICAgICAgIDogMVxuXG4gICAgaWYgKGkgKyBieXRlc1BlclNlcXVlbmNlIDw9IGVuZCkge1xuICAgICAgdmFyIHNlY29uZEJ5dGUsIHRoaXJkQnl0ZSwgZm91cnRoQnl0ZSwgdGVtcENvZGVQb2ludFxuXG4gICAgICBzd2l0Y2ggKGJ5dGVzUGVyU2VxdWVuY2UpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGlmIChmaXJzdEJ5dGUgPCAweDgwKSB7XG4gICAgICAgICAgICBjb2RlUG9pbnQgPSBmaXJzdEJ5dGVcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHgxRikgPDwgMHg2IHwgKHNlY29uZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4QyB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKHRoaXJkQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0ZGICYmICh0ZW1wQ29kZVBvaW50IDwgMHhEODAwIHx8IHRlbXBDb2RlUG9pbnQgPiAweERGRkYpKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGZvdXJ0aEJ5dGUgPSBidWZbaSArIDNdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwICYmIChmb3VydGhCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweDEyIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweEMgfCAodGhpcmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKGZvdXJ0aEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweEZGRkYgJiYgdGVtcENvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNvZGVQb2ludCA9PT0gbnVsbCkge1xuICAgICAgLy8gd2UgZGlkIG5vdCBnZW5lcmF0ZSBhIHZhbGlkIGNvZGVQb2ludCBzbyBpbnNlcnQgYVxuICAgICAgLy8gcmVwbGFjZW1lbnQgY2hhciAoVStGRkZEKSBhbmQgYWR2YW5jZSBvbmx5IDEgYnl0ZVxuICAgICAgY29kZVBvaW50ID0gMHhGRkZEXG4gICAgICBieXRlc1BlclNlcXVlbmNlID0gMVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50ID4gMHhGRkZGKSB7XG4gICAgICAvLyBlbmNvZGUgdG8gdXRmMTYgKHN1cnJvZ2F0ZSBwYWlyIGRhbmNlKVxuICAgICAgY29kZVBvaW50IC09IDB4MTAwMDBcbiAgICAgIHJlcy5wdXNoKGNvZGVQb2ludCA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMClcbiAgICAgIGNvZGVQb2ludCA9IDB4REMwMCB8IGNvZGVQb2ludCAmIDB4M0ZGXG4gICAgfVxuXG4gICAgcmVzLnB1c2goY29kZVBvaW50KVxuICAgIGkgKz0gYnl0ZXNQZXJTZXF1ZW5jZVxuICB9XG5cbiAgcmV0dXJuIGRlY29kZUNvZGVQb2ludHNBcnJheShyZXMpXG59XG5cbi8vIEJhc2VkIG9uIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzIyNzQ3MjcyLzY4MDc0MiwgdGhlIGJyb3dzZXIgd2l0aFxuLy8gdGhlIGxvd2VzdCBsaW1pdCBpcyBDaHJvbWUsIHdpdGggMHgxMDAwMCBhcmdzLlxuLy8gV2UgZ28gMSBtYWduaXR1ZGUgbGVzcywgZm9yIHNhZmV0eVxudmFyIE1BWF9BUkdVTUVOVFNfTEVOR1RIID0gMHgxMDAwXG5cbmZ1bmN0aW9uIGRlY29kZUNvZGVQb2ludHNBcnJheSAoY29kZVBvaW50cykge1xuICB2YXIgbGVuID0gY29kZVBvaW50cy5sZW5ndGhcbiAgaWYgKGxlbiA8PSBNQVhfQVJHVU1FTlRTX0xFTkdUSCkge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY29kZVBvaW50cykgLy8gYXZvaWQgZXh0cmEgc2xpY2UoKVxuICB9XG5cbiAgLy8gRGVjb2RlIGluIGNodW5rcyB0byBhdm9pZCBcImNhbGwgc3RhY2sgc2l6ZSBleGNlZWRlZFwiLlxuICB2YXIgcmVzID0gJydcbiAgdmFyIGkgPSAwXG4gIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoXG4gICAgICBTdHJpbmcsXG4gICAgICBjb2RlUG9pbnRzLnNsaWNlKGksIGkgKz0gTUFYX0FSR1VNRU5UU19MRU5HVEgpXG4gICAgKVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0gJiAweDdGKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gbGF0aW4xU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gaGV4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuXG4gIGlmICghc3RhcnQgfHwgc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgfHwgZW5kIDwgMCB8fCBlbmQgPiBsZW4pIGVuZCA9IGxlblxuXG4gIHZhciBvdXQgPSAnJ1xuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIG91dCArPSB0b0hleChidWZbaV0pXG4gIH1cbiAgcmV0dXJuIG91dFxufVxuXG5mdW5jdGlvbiB1dGYxNmxlU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgYnl0ZXMgPSBidWYuc2xpY2Uoc3RhcnQsIGVuZClcbiAgdmFyIHJlcyA9ICcnXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSArIChieXRlc1tpICsgMV0gKiAyNTYpKVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIHNsaWNlIChzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBzdGFydCA9IH5+c3RhcnRcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW4gOiB+fmVuZFxuXG4gIGlmIChzdGFydCA8IDApIHtcbiAgICBzdGFydCArPSBsZW5cbiAgICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgfSBlbHNlIGlmIChzdGFydCA+IGxlbikge1xuICAgIHN0YXJ0ID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgMCkge1xuICAgIGVuZCArPSBsZW5cbiAgICBpZiAoZW5kIDwgMCkgZW5kID0gMFxuICB9IGVsc2UgaWYgKGVuZCA+IGxlbikge1xuICAgIGVuZCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIHZhciBuZXdCdWYgPSB0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpXG4gIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlXG4gIG5ld0J1Zi5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIHJldHVybiBuZXdCdWZcbn1cblxuLypcbiAqIE5lZWQgdG8gbWFrZSBzdXJlIHRoYXQgYnVmZmVyIGlzbid0IHRyeWluZyB0byB3cml0ZSBvdXQgb2YgYm91bmRzLlxuICovXG5mdW5jdGlvbiBjaGVja09mZnNldCAob2Zmc2V0LCBleHQsIGxlbmd0aCkge1xuICBpZiAoKG9mZnNldCAlIDEpICE9PSAwIHx8IG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdvZmZzZXQgaXMgbm90IHVpbnQnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gbGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVHJ5aW5nIHRvIGFjY2VzcyBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRMRSA9IGZ1bmN0aW9uIHJlYWRVSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50QkUgPSBmdW5jdGlvbiByZWFkVUludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcbiAgfVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF1cbiAgdmFyIG11bCA9IDFcbiAgd2hpbGUgKGJ5dGVMZW5ndGggPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50OCA9IGZ1bmN0aW9uIHJlYWRVSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkJFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCA4KSB8IHRoaXNbb2Zmc2V0ICsgMV1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyTEUgPSBmdW5jdGlvbiByZWFkVUludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICgodGhpc1tvZmZzZXRdKSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikpICtcbiAgICAgICh0aGlzW29mZnNldCArIDNdICogMHgxMDAwMDAwKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSAqIDB4MTAwMDAwMCkgK1xuICAgICgodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICB0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRMRSA9IGZ1bmN0aW9uIHJlYWRJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50QkUgPSBmdW5jdGlvbiByZWFkSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoXG4gIHZhciBtdWwgPSAxXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0taV1cbiAgd2hpbGUgKGkgPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1pXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDggPSBmdW5jdGlvbiByZWFkSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgaWYgKCEodGhpc1tvZmZzZXRdICYgMHg4MCkpIHJldHVybiAodGhpc1tvZmZzZXRdKVxuICByZXR1cm4gKCgweGZmIC0gdGhpc1tvZmZzZXRdICsgMSkgKiAtMSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFID0gZnVuY3Rpb24gcmVhZEludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIDFdIHwgKHRoaXNbb2Zmc2V0XSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyTEUgPSBmdW5jdGlvbiByZWFkSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDNdIDw8IDI0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkJFID0gZnVuY3Rpb24gcmVhZEludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgMjQpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdExFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0QkUgPSBmdW5jdGlvbiByZWFkRmxvYXRCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlTEUgPSBmdW5jdGlvbiByZWFkRG91YmxlTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCA1MiwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkUgPSBmdW5jdGlvbiByZWFkRG91YmxlQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgNTIsIDgpXG59XG5cbmZ1bmN0aW9uIGNoZWNrSW50IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJidWZmZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyIGluc3RhbmNlJylcbiAgaWYgKHZhbHVlID4gbWF4IHx8IHZhbHVlIDwgbWluKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IGlzIG91dCBvZiBib3VuZHMnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludEJFID0gZnVuY3Rpb24gd3JpdGVVSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxuICB9XG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxuICB2YXIgbXVsID0gMVxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVVSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4ZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgKDggKiBieXRlTGVuZ3RoKSAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gMFxuICB2YXIgbXVsID0gMVxuICB2YXIgc3ViID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgLSAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50QkUgPSBmdW5jdGlvbiB3cml0ZUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsICg4ICogYnl0ZUxlbmd0aCkgLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHZhciBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpICsgMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDFcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDggPSBmdW5jdGlvbiB3cml0ZUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweDdmLCAtMHg4MClcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmICsgdmFsdWUgKyAxXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDFcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5mdW5jdGlvbiBjaGVja0lFRUU3NTQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG4gIGlmIChvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuZnVuY3Rpb24gd3JpdGVGbG9hdCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgNCwgMy40MDI4MjM0NjYzODUyODg2ZSszOCwgLTMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgMjMsIDQpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFID0gZnVuY3Rpb24gd3JpdGVGbG9hdExFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gd3JpdGVEb3VibGUgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDgsIDEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4LCAtMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgNTIsIDgpXG4gIHJldHVybiBvZmZzZXQgKyA4XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUJFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuLy8gY29weSh0YXJnZXRCdWZmZXIsIHRhcmdldFN0YXJ0PTAsIHNvdXJjZVN0YXJ0PTAsIHNvdXJjZUVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gY29weSAodGFyZ2V0LCB0YXJnZXRTdGFydCwgc3RhcnQsIGVuZCkge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0YXJnZXQpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdhcmd1bWVudCBzaG91bGQgYmUgYSBCdWZmZXInKVxuICBpZiAoIXN0YXJ0KSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgJiYgZW5kICE9PSAwKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0U3RhcnQgPj0gdGFyZ2V0Lmxlbmd0aCkgdGFyZ2V0U3RhcnQgPSB0YXJnZXQubGVuZ3RoXG4gIGlmICghdGFyZ2V0U3RhcnQpIHRhcmdldFN0YXJ0ID0gMFxuICBpZiAoZW5kID4gMCAmJiBlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICAvLyBDb3B5IDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVybiAwXG4gIGlmICh0YXJnZXQubGVuZ3RoID09PSAwIHx8IHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIEZhdGFsIGVycm9yIGNvbmRpdGlvbnNcbiAgaWYgKHRhcmdldFN0YXJ0IDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCd0YXJnZXRTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgfVxuICBpZiAoc3RhcnQgPCAwIHx8IHN0YXJ0ID49IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbiAgaWYgKGVuZCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VFbmQgb3V0IG9mIGJvdW5kcycpXG5cbiAgLy8gQXJlIHdlIG9vYj9cbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0IDwgZW5kIC0gc3RhcnQpIHtcbiAgICBlbmQgPSB0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgKyBzdGFydFxuICB9XG5cbiAgdmFyIGxlbiA9IGVuZCAtIHN0YXJ0XG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCAmJiB0eXBlb2YgVWludDhBcnJheS5wcm90b3R5cGUuY29weVdpdGhpbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIFVzZSBidWlsdC1pbiB3aGVuIGF2YWlsYWJsZSwgbWlzc2luZyBmcm9tIElFMTFcbiAgICB0aGlzLmNvcHlXaXRoaW4odGFyZ2V0U3RhcnQsIHN0YXJ0LCBlbmQpXG4gIH0gZWxzZSBpZiAodGhpcyA9PT0gdGFyZ2V0ICYmIHN0YXJ0IDwgdGFyZ2V0U3RhcnQgJiYgdGFyZ2V0U3RhcnQgPCBlbmQpIHtcbiAgICAvLyBkZXNjZW5kaW5nIGNvcHkgZnJvbSBlbmRcbiAgICBmb3IgKHZhciBpID0gbGVuIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0U3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIFVpbnQ4QXJyYXkucHJvdG90eXBlLnNldC5jYWxsKFxuICAgICAgdGFyZ2V0LFxuICAgICAgdGhpcy5zdWJhcnJheShzdGFydCwgZW5kKSxcbiAgICAgIHRhcmdldFN0YXJ0XG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIGxlblxufVxuXG4vLyBVc2FnZTpcbi8vICAgIGJ1ZmZlci5maWxsKG51bWJlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoYnVmZmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChzdHJpbmdbLCBvZmZzZXRbLCBlbmRdXVssIGVuY29kaW5nXSlcbkJ1ZmZlci5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uIGZpbGwgKHZhbCwgc3RhcnQsIGVuZCwgZW5jb2RpbmcpIHtcbiAgLy8gSGFuZGxlIHN0cmluZyBjYXNlczpcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKHR5cGVvZiBzdGFydCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gc3RhcnRcbiAgICAgIHN0YXJ0ID0gMFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbmQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IGVuZFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgICB9XG4gICAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZW5jb2RpbmcgbXVzdCBiZSBhIHN0cmluZycpXG4gICAgfVxuICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnICYmICFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICB9XG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDEpIHtcbiAgICAgIHZhciBjb2RlID0gdmFsLmNoYXJDb2RlQXQoMClcbiAgICAgIGlmICgoZW5jb2RpbmcgPT09ICd1dGY4JyAmJiBjb2RlIDwgMTI4KSB8fFxuICAgICAgICAgIGVuY29kaW5nID09PSAnbGF0aW4xJykge1xuICAgICAgICAvLyBGYXN0IHBhdGg6IElmIGB2YWxgIGZpdHMgaW50byBhIHNpbmdsZSBieXRlLCB1c2UgdGhhdCBudW1lcmljIHZhbHVlLlxuICAgICAgICB2YWwgPSBjb2RlXG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMjU1XG4gIH1cblxuICAvLyBJbnZhbGlkIHJhbmdlcyBhcmUgbm90IHNldCB0byBhIGRlZmF1bHQsIHNvIGNhbiByYW5nZSBjaGVjayBlYXJseS5cbiAgaWYgKHN0YXJ0IDwgMCB8fCB0aGlzLmxlbmd0aCA8IHN0YXJ0IHx8IHRoaXMubGVuZ3RoIDwgZW5kKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ091dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHN0YXJ0ID0gc3RhcnQgPj4+IDBcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyB0aGlzLmxlbmd0aCA6IGVuZCA+Pj4gMFxuXG4gIGlmICghdmFsKSB2YWwgPSAwXG5cbiAgdmFyIGlcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgICAgdGhpc1tpXSA9IHZhbFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgYnl0ZXMgPSBCdWZmZXIuaXNCdWZmZXIodmFsKVxuICAgICAgPyB2YWxcbiAgICAgIDogQnVmZmVyLmZyb20odmFsLCBlbmNvZGluZylcbiAgICB2YXIgbGVuID0gYnl0ZXMubGVuZ3RoXG4gICAgaWYgKGxlbiA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIHZhbHVlIFwiJyArIHZhbCArXG4gICAgICAgICdcIiBpcyBpbnZhbGlkIGZvciBhcmd1bWVudCBcInZhbHVlXCInKVxuICAgIH1cbiAgICBmb3IgKGkgPSAwOyBpIDwgZW5kIC0gc3RhcnQ7ICsraSkge1xuICAgICAgdGhpc1tpICsgc3RhcnRdID0gYnl0ZXNbaSAlIGxlbl1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpc1xufVxuXG4vLyBIRUxQRVIgRlVOQ1RJT05TXG4vLyA9PT09PT09PT09PT09PT09XG5cbnZhciBJTlZBTElEX0JBU0U2NF9SRSA9IC9bXisvMC05QS1aYS16LV9dL2dcblxuZnVuY3Rpb24gYmFzZTY0Y2xlYW4gKHN0cikge1xuICAvLyBOb2RlIHRha2VzIGVxdWFsIHNpZ25zIGFzIGVuZCBvZiB0aGUgQmFzZTY0IGVuY29kaW5nXG4gIHN0ciA9IHN0ci5zcGxpdCgnPScpWzBdXG4gIC8vIE5vZGUgc3RyaXBzIG91dCBpbnZhbGlkIGNoYXJhY3RlcnMgbGlrZSBcXG4gYW5kIFxcdCBmcm9tIHRoZSBzdHJpbmcsIGJhc2U2NC1qcyBkb2VzIG5vdFxuICBzdHIgPSBzdHIudHJpbSgpLnJlcGxhY2UoSU5WQUxJRF9CQVNFNjRfUkUsICcnKVxuICAvLyBOb2RlIGNvbnZlcnRzIHN0cmluZ3Mgd2l0aCBsZW5ndGggPCAyIHRvICcnXG4gIGlmIChzdHIubGVuZ3RoIDwgMikgcmV0dXJuICcnXG4gIC8vIE5vZGUgYWxsb3dzIGZvciBub24tcGFkZGVkIGJhc2U2NCBzdHJpbmdzIChtaXNzaW5nIHRyYWlsaW5nID09PSksIGJhc2U2NC1qcyBkb2VzIG5vdFxuICB3aGlsZSAoc3RyLmxlbmd0aCAlIDQgIT09IDApIHtcbiAgICBzdHIgPSBzdHIgKyAnPSdcbiAgfVxuICByZXR1cm4gc3RyXG59XG5cbmZ1bmN0aW9uIHRvSGV4IChuKSB7XG4gIGlmIChuIDwgMTYpIHJldHVybiAnMCcgKyBuLnRvU3RyaW5nKDE2KVxuICByZXR1cm4gbi50b1N0cmluZygxNilcbn1cblxuZnVuY3Rpb24gdXRmOFRvQnl0ZXMgKHN0cmluZywgdW5pdHMpIHtcbiAgdW5pdHMgPSB1bml0cyB8fCBJbmZpbml0eVxuICB2YXIgY29kZVBvaW50XG4gIHZhciBsZW5ndGggPSBzdHJpbmcubGVuZ3RoXG4gIHZhciBsZWFkU3Vycm9nYXRlID0gbnVsbFxuICB2YXIgYnl0ZXMgPSBbXVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBjb2RlUG9pbnQgPSBzdHJpbmcuY2hhckNvZGVBdChpKVxuXG4gICAgLy8gaXMgc3Vycm9nYXRlIGNvbXBvbmVudFxuICAgIGlmIChjb2RlUG9pbnQgPiAweEQ3RkYgJiYgY29kZVBvaW50IDwgMHhFMDAwKSB7XG4gICAgICAvLyBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCFsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAgIC8vIG5vIGxlYWQgeWV0XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPiAweERCRkYpIHtcbiAgICAgICAgICAvLyB1bmV4cGVjdGVkIHRyYWlsXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfSBlbHNlIGlmIChpICsgMSA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgLy8gdW5wYWlyZWQgbGVhZFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyB2YWxpZCBsZWFkXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcblxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyAyIGxlYWRzIGluIGEgcm93XG4gICAgICBpZiAoY29kZVBvaW50IDwgMHhEQzAwKSB7XG4gICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIHZhbGlkIHN1cnJvZ2F0ZSBwYWlyXG4gICAgICBjb2RlUG9pbnQgPSAobGVhZFN1cnJvZ2F0ZSAtIDB4RDgwMCA8PCAxMCB8IGNvZGVQb2ludCAtIDB4REMwMCkgKyAweDEwMDAwXG4gICAgfSBlbHNlIGlmIChsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAvLyB2YWxpZCBibXAgY2hhciwgYnV0IGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICB9XG5cbiAgICBsZWFkU3Vycm9nYXRlID0gbnVsbFxuXG4gICAgLy8gZW5jb2RlIHV0ZjhcbiAgICBpZiAoY29kZVBvaW50IDwgMHg4MCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAxKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKGNvZGVQb2ludClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4ODAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgfCAweEMwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAzKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDIHwgMHhFMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gNCkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4MTIgfCAweEYwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvZGUgcG9pbnQnKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBieXRlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVRvQnl0ZXMgKHN0cikge1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICAvLyBOb2RlJ3MgY29kZSBzZWVtcyB0byBiZSBkb2luZyB0aGlzIGFuZCBub3QgJiAweDdGLi5cbiAgICBieXRlQXJyYXkucHVzaChzdHIuY2hhckNvZGVBdChpKSAmIDB4RkYpXG4gIH1cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiB1dGYxNmxlVG9CeXRlcyAoc3RyLCB1bml0cykge1xuICB2YXIgYywgaGksIGxvXG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuXG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KGkpXG4gICAgaGkgPSBjID4+IDhcbiAgICBsbyA9IGMgJSAyNTZcbiAgICBieXRlQXJyYXkucHVzaChsbylcbiAgICBieXRlQXJyYXkucHVzaChoaSlcbiAgfVxuXG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gYmFzZTY0VG9CeXRlcyAoc3RyKSB7XG4gIHJldHVybiBiYXNlNjQudG9CeXRlQXJyYXkoYmFzZTY0Y2xlYW4oc3RyKSlcbn1cblxuZnVuY3Rpb24gYmxpdEJ1ZmZlciAoc3JjLCBkc3QsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKGkgKyBvZmZzZXQgPj0gZHN0Lmxlbmd0aCkgfHwgKGkgPj0gc3JjLmxlbmd0aCkpIGJyZWFrXG4gICAgZHN0W2kgKyBvZmZzZXRdID0gc3JjW2ldXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuLy8gQXJyYXlCdWZmZXIgb3IgVWludDhBcnJheSBvYmplY3RzIGZyb20gb3RoZXIgY29udGV4dHMgKGkuZS4gaWZyYW1lcykgZG8gbm90IHBhc3Ncbi8vIHRoZSBgaW5zdGFuY2VvZmAgY2hlY2sgYnV0IHRoZXkgc2hvdWxkIGJlIHRyZWF0ZWQgYXMgb2YgdGhhdCB0eXBlLlxuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9pc3N1ZXMvMTY2XG5mdW5jdGlvbiBpc0luc3RhbmNlIChvYmosIHR5cGUpIHtcbiAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIHR5cGUgfHxcbiAgICAob2JqICE9IG51bGwgJiYgb2JqLmNvbnN0cnVjdG9yICE9IG51bGwgJiYgb2JqLmNvbnN0cnVjdG9yLm5hbWUgIT0gbnVsbCAmJlxuICAgICAgb2JqLmNvbnN0cnVjdG9yLm5hbWUgPT09IHR5cGUubmFtZSlcbn1cbmZ1bmN0aW9uIG51bWJlcklzTmFOIChvYmopIHtcbiAgLy8gRm9yIElFMTEgc3VwcG9ydFxuICByZXR1cm4gb2JqICE9PSBvYmogLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zZWxmLWNvbXBhcmVcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG52YXIgbW9ub3RvbmVUcmlhbmd1bGF0ZSA9IHJlcXVpcmUoJy4vbGliL21vbm90b25lJylcbnZhciBtYWtlSW5kZXggPSByZXF1aXJlKCcuL2xpYi90cmlhbmd1bGF0aW9uJylcbnZhciBkZWxhdW5heUZsaXAgPSByZXF1aXJlKCcuL2xpYi9kZWxhdW5heScpXG52YXIgZmlsdGVyVHJpYW5ndWxhdGlvbiA9IHJlcXVpcmUoJy4vbGliL2ZpbHRlcicpXG5cbm1vZHVsZS5leHBvcnRzID0gY2R0MmRcblxuZnVuY3Rpb24gY2Fub25pY2FsaXplRWRnZShlKSB7XG4gIHJldHVybiBbTWF0aC5taW4oZVswXSwgZVsxXSksIE1hdGgubWF4KGVbMF0sIGVbMV0pXVxufVxuXG5mdW5jdGlvbiBjb21wYXJlRWRnZShhLCBiKSB7XG4gIHJldHVybiBhWzBdLWJbMF0gfHwgYVsxXS1iWzFdXG59XG5cbmZ1bmN0aW9uIGNhbm9uaWNhbGl6ZUVkZ2VzKGVkZ2VzKSB7XG4gIHJldHVybiBlZGdlcy5tYXAoY2Fub25pY2FsaXplRWRnZSkuc29ydChjb21wYXJlRWRnZSlcbn1cblxuZnVuY3Rpb24gZ2V0RGVmYXVsdChvcHRpb25zLCBwcm9wZXJ0eSwgZGZsdCkge1xuICBpZihwcm9wZXJ0eSBpbiBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG9wdGlvbnNbcHJvcGVydHldXG4gIH1cbiAgcmV0dXJuIGRmbHRcbn1cblxuZnVuY3Rpb24gY2R0MmQocG9pbnRzLCBlZGdlcywgb3B0aW9ucykge1xuXG4gIGlmKCFBcnJheS5pc0FycmF5KGVkZ2VzKSkge1xuICAgIG9wdGlvbnMgPSBlZGdlcyB8fCB7fVxuICAgIGVkZ2VzID0gW11cbiAgfSBlbHNlIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fVxuICAgIGVkZ2VzID0gZWRnZXMgfHwgW11cbiAgfVxuXG4gIC8vUGFyc2Ugb3V0IG9wdGlvbnNcbiAgdmFyIGRlbGF1bmF5ID0gISFnZXREZWZhdWx0KG9wdGlvbnMsICdkZWxhdW5heScsIHRydWUpXG4gIHZhciBpbnRlcmlvciA9ICEhZ2V0RGVmYXVsdChvcHRpb25zLCAnaW50ZXJpb3InLCB0cnVlKVxuICB2YXIgZXh0ZXJpb3IgPSAhIWdldERlZmF1bHQob3B0aW9ucywgJ2V4dGVyaW9yJywgdHJ1ZSlcbiAgdmFyIGluZmluaXR5ID0gISFnZXREZWZhdWx0KG9wdGlvbnMsICdpbmZpbml0eScsIGZhbHNlKVxuXG4gIC8vSGFuZGxlIHRyaXZpYWwgY2FzZVxuICBpZigoIWludGVyaW9yICYmICFleHRlcmlvcikgfHwgcG9pbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBbXVxuICB9XG5cbiAgLy9Db25zdHJ1Y3QgaW5pdGlhbCB0cmlhbmd1bGF0aW9uXG4gIHZhciBjZWxscyA9IG1vbm90b25lVHJpYW5ndWxhdGUocG9pbnRzLCBlZGdlcylcblxuICAvL0lmIGRlbGF1bmF5IHJlZmluZW1lbnQgbmVlZGVkLCB0aGVuIGltcHJvdmUgcXVhbGl0eSBieSBlZGdlIGZsaXBwaW5nXG4gIGlmKGRlbGF1bmF5IHx8IGludGVyaW9yICE9PSBleHRlcmlvciB8fCBpbmZpbml0eSkge1xuXG4gICAgLy9JbmRleCBhbGwgb2YgdGhlIGNlbGxzIHRvIHN1cHBvcnQgZmFzdCBuZWlnaGJvcmhvb2QgcXVlcmllc1xuICAgIHZhciB0cmlhbmd1bGF0aW9uID0gbWFrZUluZGV4KHBvaW50cy5sZW5ndGgsIGNhbm9uaWNhbGl6ZUVkZ2VzKGVkZ2VzKSlcbiAgICBmb3IodmFyIGk9MDsgaTxjZWxscy5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIGYgPSBjZWxsc1tpXVxuICAgICAgdHJpYW5ndWxhdGlvbi5hZGRUcmlhbmdsZShmWzBdLCBmWzFdLCBmWzJdKVxuICAgIH1cblxuICAgIC8vUnVuIGVkZ2UgZmxpcHBpbmdcbiAgICBpZihkZWxhdW5heSkge1xuICAgICAgZGVsYXVuYXlGbGlwKHBvaW50cywgdHJpYW5ndWxhdGlvbilcbiAgICB9XG5cbiAgICAvL0ZpbHRlciBwb2ludHNcbiAgICBpZighZXh0ZXJpb3IpIHtcbiAgICAgIHJldHVybiBmaWx0ZXJUcmlhbmd1bGF0aW9uKHRyaWFuZ3VsYXRpb24sIC0xKVxuICAgIH0gZWxzZSBpZighaW50ZXJpb3IpIHtcbiAgICAgIHJldHVybiBmaWx0ZXJUcmlhbmd1bGF0aW9uKHRyaWFuZ3VsYXRpb24sICAxLCBpbmZpbml0eSlcbiAgICB9IGVsc2UgaWYoaW5maW5pdHkpIHtcbiAgICAgIHJldHVybiBmaWx0ZXJUcmlhbmd1bGF0aW9uKHRyaWFuZ3VsYXRpb24sIDAsIGluZmluaXR5KVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdHJpYW5ndWxhdGlvbi5jZWxscygpXG4gICAgfVxuICAgIFxuICB9IGVsc2Uge1xuICAgIHJldHVybiBjZWxsc1xuICB9XG59XG4iLCIndXNlIHN0cmljdCdcblxudmFyIGluQ2lyY2xlID0gcmVxdWlyZSgncm9idXN0LWluLXNwaGVyZScpWzRdXG52YXIgYnNlYXJjaCA9IHJlcXVpcmUoJ2JpbmFyeS1zZWFyY2gtYm91bmRzJylcblxubW9kdWxlLmV4cG9ydHMgPSBkZWxhdW5heVJlZmluZVxuXG5mdW5jdGlvbiB0ZXN0RmxpcChwb2ludHMsIHRyaWFuZ3VsYXRpb24sIHN0YWNrLCBhLCBiLCB4KSB7XG4gIHZhciB5ID0gdHJpYW5ndWxhdGlvbi5vcHBvc2l0ZShhLCBiKVxuXG4gIC8vVGVzdCBib3VuZGFyeSBlZGdlXG4gIGlmKHkgPCAwKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICAvL1N3YXAgZWRnZSBpZiBvcmRlciBmbGlwcGVkXG4gIGlmKGIgPCBhKSB7XG4gICAgdmFyIHRtcCA9IGFcbiAgICBhID0gYlxuICAgIGIgPSB0bXBcbiAgICB0bXAgPSB4XG4gICAgeCA9IHlcbiAgICB5ID0gdG1wXG4gIH1cblxuICAvL1Rlc3QgaWYgZWRnZSBpcyBjb25zdHJhaW5lZFxuICBpZih0cmlhbmd1bGF0aW9uLmlzQ29uc3RyYWludChhLCBiKSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgLy9UZXN0IGlmIGVkZ2UgaXMgZGVsYXVuYXlcbiAgaWYoaW5DaXJjbGUocG9pbnRzW2FdLCBwb2ludHNbYl0sIHBvaW50c1t4XSwgcG9pbnRzW3ldKSA8IDApIHtcbiAgICBzdGFjay5wdXNoKGEsIGIpXG4gIH1cbn1cblxuLy9Bc3N1bWUgZWRnZXMgYXJlIHNvcnRlZCBsZXhpY29ncmFwaGljYWxseVxuZnVuY3Rpb24gZGVsYXVuYXlSZWZpbmUocG9pbnRzLCB0cmlhbmd1bGF0aW9uKSB7XG4gIHZhciBzdGFjayA9IFtdXG5cbiAgdmFyIG51bVBvaW50cyA9IHBvaW50cy5sZW5ndGhcbiAgdmFyIHN0YXJzID0gdHJpYW5ndWxhdGlvbi5zdGFyc1xuICBmb3IodmFyIGE9MDsgYTxudW1Qb2ludHM7ICsrYSkge1xuICAgIHZhciBzdGFyID0gc3RhcnNbYV1cbiAgICBmb3IodmFyIGo9MTsgajxzdGFyLmxlbmd0aDsgais9Mikge1xuICAgICAgdmFyIGIgPSBzdGFyW2pdXG5cbiAgICAgIC8vSWYgb3JkZXIgaXMgbm90IGNvbnNpc3RlbnQsIHRoZW4gc2tpcCBlZGdlXG4gICAgICBpZihiIDwgYSkge1xuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvL0NoZWNrIGlmIGVkZ2UgaXMgY29uc3RyYWluZWRcbiAgICAgIGlmKHRyaWFuZ3VsYXRpb24uaXNDb25zdHJhaW50KGEsIGIpKSB7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vRmluZCBvcHBvc2l0ZSBlZGdlXG4gICAgICB2YXIgeCA9IHN0YXJbai0xXSwgeSA9IC0xXG4gICAgICBmb3IodmFyIGs9MTsgazxzdGFyLmxlbmd0aDsgays9Mikge1xuICAgICAgICBpZihzdGFyW2stMV0gPT09IGIpIHtcbiAgICAgICAgICB5ID0gc3RhcltrXVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy9JZiB0aGlzIGlzIGEgYm91bmRhcnkgZWRnZSwgZG9uJ3QgZmxpcCBpdFxuICAgICAgaWYoeSA8IDApIHtcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy9JZiBlZGdlIGlzIGluIGNpcmNsZSwgZmxpcCBpdFxuICAgICAgaWYoaW5DaXJjbGUocG9pbnRzW2FdLCBwb2ludHNbYl0sIHBvaW50c1t4XSwgcG9pbnRzW3ldKSA8IDApIHtcbiAgICAgICAgc3RhY2sucHVzaChhLCBiKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHdoaWxlKHN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICB2YXIgYiA9IHN0YWNrLnBvcCgpXG4gICAgdmFyIGEgPSBzdGFjay5wb3AoKVxuXG4gICAgLy9GaW5kIG9wcG9zaXRlIHBhaXJzXG4gICAgdmFyIHggPSAtMSwgeSA9IC0xXG4gICAgdmFyIHN0YXIgPSBzdGFyc1thXVxuICAgIGZvcih2YXIgaT0xOyBpPHN0YXIubGVuZ3RoOyBpKz0yKSB7XG4gICAgICB2YXIgcyA9IHN0YXJbaS0xXVxuICAgICAgdmFyIHQgPSBzdGFyW2ldXG4gICAgICBpZihzID09PSBiKSB7XG4gICAgICAgIHkgPSB0XG4gICAgICB9IGVsc2UgaWYodCA9PT0gYikge1xuICAgICAgICB4ID0gc1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vSWYgeC95IGFyZSBib3RoIHZhbGlkIHRoZW4gc2tpcCBlZGdlXG4gICAgaWYoeCA8IDAgfHwgeSA8IDApIHtcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuXG4gICAgLy9JZiBlZGdlIGlzIG5vdyBkZWxhdW5heSwgdGhlbiBkb24ndCBmbGlwIGl0XG4gICAgaWYoaW5DaXJjbGUocG9pbnRzW2FdLCBwb2ludHNbYl0sIHBvaW50c1t4XSwgcG9pbnRzW3ldKSA+PSAwKSB7XG4gICAgICBjb250aW51ZVxuICAgIH1cblxuICAgIC8vRmxpcCB0aGUgZWRnZVxuICAgIHRyaWFuZ3VsYXRpb24uZmxpcChhLCBiKVxuXG4gICAgLy9UZXN0IGZsaXBwaW5nIG5laWdoYm9yaW5nIGVkZ2VzXG4gICAgdGVzdEZsaXAocG9pbnRzLCB0cmlhbmd1bGF0aW9uLCBzdGFjaywgeCwgYSwgeSlcbiAgICB0ZXN0RmxpcChwb2ludHMsIHRyaWFuZ3VsYXRpb24sIHN0YWNrLCBhLCB5LCB4KVxuICAgIHRlc3RGbGlwKHBvaW50cywgdHJpYW5ndWxhdGlvbiwgc3RhY2ssIHksIGIsIHgpXG4gICAgdGVzdEZsaXAocG9pbnRzLCB0cmlhbmd1bGF0aW9uLCBzdGFjaywgYiwgeCwgeSlcbiAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbnZhciBic2VhcmNoID0gcmVxdWlyZSgnYmluYXJ5LXNlYXJjaC1ib3VuZHMnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzaWZ5RmFjZXNcblxuZnVuY3Rpb24gRmFjZUluZGV4KGNlbGxzLCBuZWlnaGJvciwgY29uc3RyYWludCwgZmxhZ3MsIGFjdGl2ZSwgbmV4dCwgYm91bmRhcnkpIHtcbiAgdGhpcy5jZWxscyAgICAgICA9IGNlbGxzXG4gIHRoaXMubmVpZ2hib3IgICAgPSBuZWlnaGJvclxuICB0aGlzLmZsYWdzICAgICAgID0gZmxhZ3NcbiAgdGhpcy5jb25zdHJhaW50ICA9IGNvbnN0cmFpbnRcbiAgdGhpcy5hY3RpdmUgICAgICA9IGFjdGl2ZVxuICB0aGlzLm5leHQgICAgICAgID0gbmV4dFxuICB0aGlzLmJvdW5kYXJ5ICAgID0gYm91bmRhcnlcbn1cblxudmFyIHByb3RvID0gRmFjZUluZGV4LnByb3RvdHlwZVxuXG5mdW5jdGlvbiBjb21wYXJlQ2VsbChhLCBiKSB7XG4gIHJldHVybiBhWzBdIC0gYlswXSB8fFxuICAgICAgICAgYVsxXSAtIGJbMV0gfHxcbiAgICAgICAgIGFbMl0gLSBiWzJdXG59XG5cbnByb3RvLmxvY2F0ZSA9IChmdW5jdGlvbigpIHtcbiAgdmFyIGtleSA9IFswLDAsMF1cbiAgcmV0dXJuIGZ1bmN0aW9uKGEsIGIsIGMpIHtcbiAgICB2YXIgeCA9IGEsIHkgPSBiLCB6ID0gY1xuICAgIGlmKGIgPCBjKSB7XG4gICAgICBpZihiIDwgYSkge1xuICAgICAgICB4ID0gYlxuICAgICAgICB5ID0gY1xuICAgICAgICB6ID0gYVxuICAgICAgfVxuICAgIH0gZWxzZSBpZihjIDwgYSkge1xuICAgICAgeCA9IGNcbiAgICAgIHkgPSBhXG4gICAgICB6ID0gYlxuICAgIH1cbiAgICBpZih4IDwgMCkge1xuICAgICAgcmV0dXJuIC0xXG4gICAgfVxuICAgIGtleVswXSA9IHhcbiAgICBrZXlbMV0gPSB5XG4gICAga2V5WzJdID0gelxuICAgIHJldHVybiBic2VhcmNoLmVxKHRoaXMuY2VsbHMsIGtleSwgY29tcGFyZUNlbGwpXG4gIH1cbn0pKClcblxuZnVuY3Rpb24gaW5kZXhDZWxscyh0cmlhbmd1bGF0aW9uLCBpbmZpbml0eSkge1xuICAvL0ZpcnN0IGdldCBjZWxscyBhbmQgY2Fub25pY2FsaXplXG4gIHZhciBjZWxscyA9IHRyaWFuZ3VsYXRpb24uY2VsbHMoKVxuICB2YXIgbmMgPSBjZWxscy5sZW5ndGhcbiAgZm9yKHZhciBpPTA7IGk8bmM7ICsraSkge1xuICAgIHZhciBjID0gY2VsbHNbaV1cbiAgICB2YXIgeCA9IGNbMF0sIHkgPSBjWzFdLCB6ID0gY1syXVxuICAgIGlmKHkgPCB6KSB7XG4gICAgICBpZih5IDwgeCkge1xuICAgICAgICBjWzBdID0geVxuICAgICAgICBjWzFdID0gelxuICAgICAgICBjWzJdID0geFxuICAgICAgfVxuICAgIH0gZWxzZSBpZih6IDwgeCkge1xuICAgICAgY1swXSA9IHpcbiAgICAgIGNbMV0gPSB4XG4gICAgICBjWzJdID0geVxuICAgIH1cbiAgfVxuICBjZWxscy5zb3J0KGNvbXBhcmVDZWxsKVxuXG4gIC8vSW5pdGlhbGl6ZSBmbGFnIGFycmF5XG4gIHZhciBmbGFncyA9IG5ldyBBcnJheShuYylcbiAgZm9yKHZhciBpPTA7IGk8ZmxhZ3MubGVuZ3RoOyArK2kpIHtcbiAgICBmbGFnc1tpXSA9IDBcbiAgfVxuXG4gIC8vQnVpbGQgbmVpZ2hib3IgaW5kZXgsIGluaXRpYWxpemUgcXVldWVzXG4gIHZhciBhY3RpdmUgPSBbXVxuICB2YXIgbmV4dCAgID0gW11cbiAgdmFyIG5laWdoYm9yID0gbmV3IEFycmF5KDMqbmMpXG4gIHZhciBjb25zdHJhaW50ID0gbmV3IEFycmF5KDMqbmMpXG4gIHZhciBib3VuZGFyeSA9IG51bGxcbiAgaWYoaW5maW5pdHkpIHtcbiAgICBib3VuZGFyeSA9IFtdXG4gIH1cbiAgdmFyIGluZGV4ID0gbmV3IEZhY2VJbmRleChcbiAgICBjZWxscyxcbiAgICBuZWlnaGJvcixcbiAgICBjb25zdHJhaW50LFxuICAgIGZsYWdzLFxuICAgIGFjdGl2ZSxcbiAgICBuZXh0LFxuICAgIGJvdW5kYXJ5KVxuICBmb3IodmFyIGk9MDsgaTxuYzsgKytpKSB7XG4gICAgdmFyIGMgPSBjZWxsc1tpXVxuICAgIGZvcih2YXIgaj0wOyBqPDM7ICsraikge1xuICAgICAgdmFyIHggPSBjW2pdLCB5ID0gY1soaisxKSUzXVxuICAgICAgdmFyIGEgPSBuZWlnaGJvclszKmkral0gPSBpbmRleC5sb2NhdGUoeSwgeCwgdHJpYW5ndWxhdGlvbi5vcHBvc2l0ZSh5LCB4KSlcbiAgICAgIHZhciBiID0gY29uc3RyYWludFszKmkral0gPSB0cmlhbmd1bGF0aW9uLmlzQ29uc3RyYWludCh4LCB5KVxuICAgICAgaWYoYSA8IDApIHtcbiAgICAgICAgaWYoYikge1xuICAgICAgICAgIG5leHQucHVzaChpKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFjdGl2ZS5wdXNoKGkpXG4gICAgICAgICAgZmxhZ3NbaV0gPSAxXG4gICAgICAgIH1cbiAgICAgICAgaWYoaW5maW5pdHkpIHtcbiAgICAgICAgICBib3VuZGFyeS5wdXNoKFt5LCB4LCAtMV0pXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGluZGV4XG59XG5cbmZ1bmN0aW9uIGZpbHRlckNlbGxzKGNlbGxzLCBmbGFncywgdGFyZ2V0KSB7XG4gIHZhciBwdHIgPSAwXG4gIGZvcih2YXIgaT0wOyBpPGNlbGxzLmxlbmd0aDsgKytpKSB7XG4gICAgaWYoZmxhZ3NbaV0gPT09IHRhcmdldCkge1xuICAgICAgY2VsbHNbcHRyKytdID0gY2VsbHNbaV1cbiAgICB9XG4gIH1cbiAgY2VsbHMubGVuZ3RoID0gcHRyXG4gIHJldHVybiBjZWxsc1xufVxuXG5mdW5jdGlvbiBjbGFzc2lmeUZhY2VzKHRyaWFuZ3VsYXRpb24sIHRhcmdldCwgaW5maW5pdHkpIHtcbiAgdmFyIGluZGV4ID0gaW5kZXhDZWxscyh0cmlhbmd1bGF0aW9uLCBpbmZpbml0eSlcblxuICBpZih0YXJnZXQgPT09IDApIHtcbiAgICBpZihpbmZpbml0eSkge1xuICAgICAgcmV0dXJuIGluZGV4LmNlbGxzLmNvbmNhdChpbmRleC5ib3VuZGFyeSlcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGluZGV4LmNlbGxzXG4gICAgfVxuICB9XG5cbiAgdmFyIHNpZGUgPSAxXG4gIHZhciBhY3RpdmUgPSBpbmRleC5hY3RpdmVcbiAgdmFyIG5leHQgPSBpbmRleC5uZXh0XG4gIHZhciBmbGFncyA9IGluZGV4LmZsYWdzXG4gIHZhciBjZWxscyA9IGluZGV4LmNlbGxzXG4gIHZhciBjb25zdHJhaW50ID0gaW5kZXguY29uc3RyYWludFxuICB2YXIgbmVpZ2hib3IgPSBpbmRleC5uZWlnaGJvclxuXG4gIHdoaWxlKGFjdGl2ZS5sZW5ndGggPiAwIHx8IG5leHQubGVuZ3RoID4gMCkge1xuICAgIHdoaWxlKGFjdGl2ZS5sZW5ndGggPiAwKSB7XG4gICAgICB2YXIgdCA9IGFjdGl2ZS5wb3AoKVxuICAgICAgaWYoZmxhZ3NbdF0gPT09IC1zaWRlKSB7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG4gICAgICBmbGFnc1t0XSA9IHNpZGVcbiAgICAgIHZhciBjID0gY2VsbHNbdF1cbiAgICAgIGZvcih2YXIgaj0wOyBqPDM7ICsraikge1xuICAgICAgICB2YXIgZiA9IG5laWdoYm9yWzMqdCtqXVxuICAgICAgICBpZihmID49IDAgJiYgZmxhZ3NbZl0gPT09IDApIHtcbiAgICAgICAgICBpZihjb25zdHJhaW50WzMqdCtqXSkge1xuICAgICAgICAgICAgbmV4dC5wdXNoKGYpXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFjdGl2ZS5wdXNoKGYpXG4gICAgICAgICAgICBmbGFnc1tmXSA9IHNpZGVcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvL1N3YXAgYXJyYXlzIGFuZCBsb29wXG4gICAgdmFyIHRtcCA9IG5leHRcbiAgICBuZXh0ID0gYWN0aXZlXG4gICAgYWN0aXZlID0gdG1wXG4gICAgbmV4dC5sZW5ndGggPSAwXG4gICAgc2lkZSA9IC1zaWRlXG4gIH1cblxuICB2YXIgcmVzdWx0ID0gZmlsdGVyQ2VsbHMoY2VsbHMsIGZsYWdzLCB0YXJnZXQpXG4gIGlmKGluZmluaXR5KSB7XG4gICAgcmV0dXJuIHJlc3VsdC5jb25jYXQoaW5kZXguYm91bmRhcnkpXG4gIH1cbiAgcmV0dXJuIHJlc3VsdFxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbnZhciBic2VhcmNoID0gcmVxdWlyZSgnYmluYXJ5LXNlYXJjaC1ib3VuZHMnKVxudmFyIG9yaWVudCA9IHJlcXVpcmUoJ3JvYnVzdC1vcmllbnRhdGlvbicpWzNdXG5cbnZhciBFVkVOVF9QT0lOVCA9IDBcbnZhciBFVkVOVF9FTkQgICA9IDFcbnZhciBFVkVOVF9TVEFSVCA9IDJcblxubW9kdWxlLmV4cG9ydHMgPSBtb25vdG9uZVRyaWFuZ3VsYXRlXG5cbi8vQSBwYXJ0aWFsIGNvbnZleCBodWxsIGZyYWdtZW50LCBtYWRlIG9mIHR3byB1bmltb25vdG9uZSBwb2x5Z29uc1xuZnVuY3Rpb24gUGFydGlhbEh1bGwoYSwgYiwgaWR4LCBsb3dlcklkcywgdXBwZXJJZHMpIHtcbiAgdGhpcy5hID0gYVxuICB0aGlzLmIgPSBiXG4gIHRoaXMuaWR4ID0gaWR4XG4gIHRoaXMubG93ZXJJZHMgPSBsb3dlcklkc1xuICB0aGlzLnVwcGVySWRzID0gdXBwZXJJZHNcbn1cblxuLy9BbiBldmVudCBpbiB0aGUgc3dlZXAgbGluZSBwcm9jZWR1cmVcbmZ1bmN0aW9uIEV2ZW50KGEsIGIsIHR5cGUsIGlkeCkge1xuICB0aGlzLmEgICAgPSBhXG4gIHRoaXMuYiAgICA9IGJcbiAgdGhpcy50eXBlID0gdHlwZVxuICB0aGlzLmlkeCAgPSBpZHhcbn1cblxuLy9UaGlzIGlzIHVzZWQgdG8gY29tcGFyZSBldmVudHMgZm9yIHRoZSBzd2VlcCBsaW5lIHByb2NlZHVyZVxuLy8gUG9pbnRzIGFyZTpcbi8vICAxLiBzb3J0ZWQgbGV4aWNvZ3JhcGhpY2FsbHlcbi8vICAyLiBzb3J0ZWQgYnkgdHlwZSAgKHBvaW50IDwgZW5kIDwgc3RhcnQpXG4vLyAgMy4gc2VnbWVudHMgc29ydGVkIGJ5IHdpbmRpbmcgb3JkZXJcbi8vICA0LiBzb3J0ZWQgYnkgaW5kZXhcbmZ1bmN0aW9uIGNvbXBhcmVFdmVudChhLCBiKSB7XG4gIHZhciBkID1cbiAgICAoYS5hWzBdIC0gYi5hWzBdKSB8fFxuICAgIChhLmFbMV0gLSBiLmFbMV0pIHx8XG4gICAgKGEudHlwZSAtIGIudHlwZSlcbiAgaWYoZCkgeyByZXR1cm4gZCB9XG4gIGlmKGEudHlwZSAhPT0gRVZFTlRfUE9JTlQpIHtcbiAgICBkID0gb3JpZW50KGEuYSwgYS5iLCBiLmIpXG4gICAgaWYoZCkgeyByZXR1cm4gZCB9XG4gIH1cbiAgcmV0dXJuIGEuaWR4IC0gYi5pZHhcbn1cblxuZnVuY3Rpb24gdGVzdFBvaW50KGh1bGwsIHApIHtcbiAgcmV0dXJuIG9yaWVudChodWxsLmEsIGh1bGwuYiwgcClcbn1cblxuZnVuY3Rpb24gYWRkUG9pbnQoY2VsbHMsIGh1bGxzLCBwb2ludHMsIHAsIGlkeCkge1xuICB2YXIgbG8gPSBic2VhcmNoLmx0KGh1bGxzLCBwLCB0ZXN0UG9pbnQpXG4gIHZhciBoaSA9IGJzZWFyY2guZ3QoaHVsbHMsIHAsIHRlc3RQb2ludClcbiAgZm9yKHZhciBpPWxvOyBpPGhpOyArK2kpIHtcbiAgICB2YXIgaHVsbCA9IGh1bGxzW2ldXG5cbiAgICAvL0luc2VydCBwIGludG8gbG93ZXIgaHVsbFxuICAgIHZhciBsb3dlcklkcyA9IGh1bGwubG93ZXJJZHNcbiAgICB2YXIgbSA9IGxvd2VySWRzLmxlbmd0aFxuICAgIHdoaWxlKG0gPiAxICYmIG9yaWVudChcbiAgICAgICAgcG9pbnRzW2xvd2VySWRzW20tMl1dLFxuICAgICAgICBwb2ludHNbbG93ZXJJZHNbbS0xXV0sXG4gICAgICAgIHApID4gMCkge1xuICAgICAgY2VsbHMucHVzaChcbiAgICAgICAgW2xvd2VySWRzW20tMV0sXG4gICAgICAgICBsb3dlcklkc1ttLTJdLFxuICAgICAgICAgaWR4XSlcbiAgICAgIG0gLT0gMVxuICAgIH1cbiAgICBsb3dlcklkcy5sZW5ndGggPSBtXG4gICAgbG93ZXJJZHMucHVzaChpZHgpXG5cbiAgICAvL0luc2VydCBwIGludG8gdXBwZXIgaHVsbFxuICAgIHZhciB1cHBlcklkcyA9IGh1bGwudXBwZXJJZHNcbiAgICB2YXIgbSA9IHVwcGVySWRzLmxlbmd0aFxuICAgIHdoaWxlKG0gPiAxICYmIG9yaWVudChcbiAgICAgICAgcG9pbnRzW3VwcGVySWRzW20tMl1dLFxuICAgICAgICBwb2ludHNbdXBwZXJJZHNbbS0xXV0sXG4gICAgICAgIHApIDwgMCkge1xuICAgICAgY2VsbHMucHVzaChcbiAgICAgICAgW3VwcGVySWRzW20tMl0sXG4gICAgICAgICB1cHBlcklkc1ttLTFdLFxuICAgICAgICAgaWR4XSlcbiAgICAgIG0gLT0gMVxuICAgIH1cbiAgICB1cHBlcklkcy5sZW5ndGggPSBtXG4gICAgdXBwZXJJZHMucHVzaChpZHgpXG4gIH1cbn1cblxuZnVuY3Rpb24gZmluZFNwbGl0KGh1bGwsIGVkZ2UpIHtcbiAgdmFyIGRcbiAgaWYoaHVsbC5hWzBdIDwgZWRnZS5hWzBdKSB7XG4gICAgZCA9IG9yaWVudChodWxsLmEsIGh1bGwuYiwgZWRnZS5hKVxuICB9IGVsc2Uge1xuICAgIGQgPSBvcmllbnQoZWRnZS5iLCBlZGdlLmEsIGh1bGwuYSlcbiAgfVxuICBpZihkKSB7IHJldHVybiBkIH1cbiAgaWYoZWRnZS5iWzBdIDwgaHVsbC5iWzBdKSB7XG4gICAgZCA9IG9yaWVudChodWxsLmEsIGh1bGwuYiwgZWRnZS5iKVxuICB9IGVsc2Uge1xuICAgIGQgPSBvcmllbnQoZWRnZS5iLCBlZGdlLmEsIGh1bGwuYilcbiAgfVxuICByZXR1cm4gZCB8fCBodWxsLmlkeCAtIGVkZ2UuaWR4XG59XG5cbmZ1bmN0aW9uIHNwbGl0SHVsbHMoaHVsbHMsIHBvaW50cywgZXZlbnQpIHtcbiAgdmFyIHNwbGl0SWR4ID0gYnNlYXJjaC5sZShodWxscywgZXZlbnQsIGZpbmRTcGxpdClcbiAgdmFyIGh1bGwgPSBodWxsc1tzcGxpdElkeF1cbiAgdmFyIHVwcGVySWRzID0gaHVsbC51cHBlcklkc1xuICB2YXIgeCA9IHVwcGVySWRzW3VwcGVySWRzLmxlbmd0aC0xXVxuICBodWxsLnVwcGVySWRzID0gW3hdXG4gIGh1bGxzLnNwbGljZShzcGxpdElkeCsxLCAwLFxuICAgIG5ldyBQYXJ0aWFsSHVsbChldmVudC5hLCBldmVudC5iLCBldmVudC5pZHgsIFt4XSwgdXBwZXJJZHMpKVxufVxuXG5cbmZ1bmN0aW9uIG1lcmdlSHVsbHMoaHVsbHMsIHBvaW50cywgZXZlbnQpIHtcbiAgLy9Td2FwIHBvaW50ZXJzIGZvciBtZXJnZSBzZWFyY2hcbiAgdmFyIHRtcCA9IGV2ZW50LmFcbiAgZXZlbnQuYSA9IGV2ZW50LmJcbiAgZXZlbnQuYiA9IHRtcFxuICB2YXIgbWVyZ2VJZHggPSBic2VhcmNoLmVxKGh1bGxzLCBldmVudCwgZmluZFNwbGl0KVxuICB2YXIgdXBwZXIgPSBodWxsc1ttZXJnZUlkeF1cbiAgdmFyIGxvd2VyID0gaHVsbHNbbWVyZ2VJZHgtMV1cbiAgbG93ZXIudXBwZXJJZHMgPSB1cHBlci51cHBlcklkc1xuICBodWxscy5zcGxpY2UobWVyZ2VJZHgsIDEpXG59XG5cblxuZnVuY3Rpb24gbW9ub3RvbmVUcmlhbmd1bGF0ZShwb2ludHMsIGVkZ2VzKSB7XG5cbiAgdmFyIG51bVBvaW50cyA9IHBvaW50cy5sZW5ndGhcbiAgdmFyIG51bUVkZ2VzID0gZWRnZXMubGVuZ3RoXG5cbiAgdmFyIGV2ZW50cyA9IFtdXG5cbiAgLy9DcmVhdGUgcG9pbnQgZXZlbnRzXG4gIGZvcih2YXIgaT0wOyBpPG51bVBvaW50czsgKytpKSB7XG4gICAgZXZlbnRzLnB1c2gobmV3IEV2ZW50KFxuICAgICAgcG9pbnRzW2ldLFxuICAgICAgbnVsbCxcbiAgICAgIEVWRU5UX1BPSU5ULFxuICAgICAgaSkpXG4gIH1cblxuICAvL0NyZWF0ZSBlZGdlIGV2ZW50c1xuICBmb3IodmFyIGk9MDsgaTxudW1FZGdlczsgKytpKSB7XG4gICAgdmFyIGUgPSBlZGdlc1tpXVxuICAgIHZhciBhID0gcG9pbnRzW2VbMF1dXG4gICAgdmFyIGIgPSBwb2ludHNbZVsxXV1cbiAgICBpZihhWzBdIDwgYlswXSkge1xuICAgICAgZXZlbnRzLnB1c2goXG4gICAgICAgIG5ldyBFdmVudChhLCBiLCBFVkVOVF9TVEFSVCwgaSksXG4gICAgICAgIG5ldyBFdmVudChiLCBhLCBFVkVOVF9FTkQsIGkpKVxuICAgIH0gZWxzZSBpZihhWzBdID4gYlswXSkge1xuICAgICAgZXZlbnRzLnB1c2goXG4gICAgICAgIG5ldyBFdmVudChiLCBhLCBFVkVOVF9TVEFSVCwgaSksXG4gICAgICAgIG5ldyBFdmVudChhLCBiLCBFVkVOVF9FTkQsIGkpKVxuICAgIH1cbiAgfVxuXG4gIC8vU29ydCBldmVudHNcbiAgZXZlbnRzLnNvcnQoY29tcGFyZUV2ZW50KVxuXG4gIC8vSW5pdGlhbGl6ZSBodWxsXG4gIHZhciBtaW5YID0gZXZlbnRzWzBdLmFbMF0gLSAoMSArIE1hdGguYWJzKGV2ZW50c1swXS5hWzBdKSkgKiBNYXRoLnBvdygyLCAtNTIpXG4gIHZhciBodWxsID0gWyBuZXcgUGFydGlhbEh1bGwoW21pblgsIDFdLCBbbWluWCwgMF0sIC0xLCBbXSwgW10sIFtdLCBbXSkgXVxuXG4gIC8vUHJvY2VzcyBldmVudHMgaW4gb3JkZXJcbiAgdmFyIGNlbGxzID0gW11cbiAgZm9yKHZhciBpPTAsIG51bUV2ZW50cz1ldmVudHMubGVuZ3RoOyBpPG51bUV2ZW50czsgKytpKSB7XG4gICAgdmFyIGV2ZW50ID0gZXZlbnRzW2ldXG4gICAgdmFyIHR5cGUgPSBldmVudC50eXBlXG4gICAgaWYodHlwZSA9PT0gRVZFTlRfUE9JTlQpIHtcbiAgICAgIGFkZFBvaW50KGNlbGxzLCBodWxsLCBwb2ludHMsIGV2ZW50LmEsIGV2ZW50LmlkeClcbiAgICB9IGVsc2UgaWYodHlwZSA9PT0gRVZFTlRfU1RBUlQpIHtcbiAgICAgIHNwbGl0SHVsbHMoaHVsbCwgcG9pbnRzLCBldmVudClcbiAgICB9IGVsc2Uge1xuICAgICAgbWVyZ2VIdWxscyhodWxsLCBwb2ludHMsIGV2ZW50KVxuICAgIH1cbiAgfVxuXG4gIC8vUmV0dXJuIHRyaWFuZ3VsYXRpb25cbiAgcmV0dXJuIGNlbGxzXG59XG4iLCIndXNlIHN0cmljdCdcblxudmFyIGJzZWFyY2ggPSByZXF1aXJlKCdiaW5hcnktc2VhcmNoLWJvdW5kcycpXG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlVHJpYW5ndWxhdGlvblxuXG5mdW5jdGlvbiBUcmlhbmd1bGF0aW9uKHN0YXJzLCBlZGdlcykge1xuICB0aGlzLnN0YXJzID0gc3RhcnNcbiAgdGhpcy5lZGdlcyA9IGVkZ2VzXG59XG5cbnZhciBwcm90byA9IFRyaWFuZ3VsYXRpb24ucHJvdG90eXBlXG5cbmZ1bmN0aW9uIHJlbW92ZVBhaXIobGlzdCwgaiwgaykge1xuICBmb3IodmFyIGk9MSwgbj1saXN0Lmxlbmd0aDsgaTxuOyBpKz0yKSB7XG4gICAgaWYobGlzdFtpLTFdID09PSBqICYmIGxpc3RbaV0gPT09IGspIHtcbiAgICAgIGxpc3RbaS0xXSA9IGxpc3Rbbi0yXVxuICAgICAgbGlzdFtpXSA9IGxpc3Rbbi0xXVxuICAgICAgbGlzdC5sZW5ndGggPSBuIC0gMlxuICAgICAgcmV0dXJuXG4gICAgfVxuICB9XG59XG5cbnByb3RvLmlzQ29uc3RyYWludCA9IChmdW5jdGlvbigpIHtcbiAgdmFyIGUgPSBbMCwwXVxuICBmdW5jdGlvbiBjb21wYXJlTGV4KGEsIGIpIHtcbiAgICByZXR1cm4gYVswXSAtIGJbMF0gfHwgYVsxXSAtIGJbMV1cbiAgfVxuICByZXR1cm4gZnVuY3Rpb24oaSwgaikge1xuICAgIGVbMF0gPSBNYXRoLm1pbihpLGopXG4gICAgZVsxXSA9IE1hdGgubWF4KGksailcbiAgICByZXR1cm4gYnNlYXJjaC5lcSh0aGlzLmVkZ2VzLCBlLCBjb21wYXJlTGV4KSA+PSAwXG4gIH1cbn0pKClcblxucHJvdG8ucmVtb3ZlVHJpYW5nbGUgPSBmdW5jdGlvbihpLCBqLCBrKSB7XG4gIHZhciBzdGFycyA9IHRoaXMuc3RhcnNcbiAgcmVtb3ZlUGFpcihzdGFyc1tpXSwgaiwgaylcbiAgcmVtb3ZlUGFpcihzdGFyc1tqXSwgaywgaSlcbiAgcmVtb3ZlUGFpcihzdGFyc1trXSwgaSwgailcbn1cblxucHJvdG8uYWRkVHJpYW5nbGUgPSBmdW5jdGlvbihpLCBqLCBrKSB7XG4gIHZhciBzdGFycyA9IHRoaXMuc3RhcnNcbiAgc3RhcnNbaV0ucHVzaChqLCBrKVxuICBzdGFyc1tqXS5wdXNoKGssIGkpXG4gIHN0YXJzW2tdLnB1c2goaSwgailcbn1cblxucHJvdG8ub3Bwb3NpdGUgPSBmdW5jdGlvbihqLCBpKSB7XG4gIHZhciBsaXN0ID0gdGhpcy5zdGFyc1tpXVxuICBmb3IodmFyIGs9MSwgbj1saXN0Lmxlbmd0aDsgazxuOyBrKz0yKSB7XG4gICAgaWYobGlzdFtrXSA9PT0gaikge1xuICAgICAgcmV0dXJuIGxpc3Rbay0xXVxuICAgIH1cbiAgfVxuICByZXR1cm4gLTFcbn1cblxucHJvdG8uZmxpcCA9IGZ1bmN0aW9uKGksIGopIHtcbiAgdmFyIGEgPSB0aGlzLm9wcG9zaXRlKGksIGopXG4gIHZhciBiID0gdGhpcy5vcHBvc2l0ZShqLCBpKVxuICB0aGlzLnJlbW92ZVRyaWFuZ2xlKGksIGosIGEpXG4gIHRoaXMucmVtb3ZlVHJpYW5nbGUoaiwgaSwgYilcbiAgdGhpcy5hZGRUcmlhbmdsZShpLCBiLCBhKVxuICB0aGlzLmFkZFRyaWFuZ2xlKGosIGEsIGIpXG59XG5cbnByb3RvLmVkZ2VzID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzdGFycyA9IHRoaXMuc3RhcnNcbiAgdmFyIHJlc3VsdCA9IFtdXG4gIGZvcih2YXIgaT0wLCBuPXN0YXJzLmxlbmd0aDsgaTxuOyArK2kpIHtcbiAgICB2YXIgbGlzdCA9IHN0YXJzW2ldXG4gICAgZm9yKHZhciBqPTAsIG09bGlzdC5sZW5ndGg7IGo8bTsgais9Mikge1xuICAgICAgcmVzdWx0LnB1c2goW2xpc3Rbal0sIGxpc3RbaisxXV0pXG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHRcbn1cblxucHJvdG8uY2VsbHMgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHN0YXJzID0gdGhpcy5zdGFyc1xuICB2YXIgcmVzdWx0ID0gW11cbiAgZm9yKHZhciBpPTAsIG49c3RhcnMubGVuZ3RoOyBpPG47ICsraSkge1xuICAgIHZhciBsaXN0ID0gc3RhcnNbaV1cbiAgICBmb3IodmFyIGo9MCwgbT1saXN0Lmxlbmd0aDsgajxtOyBqKz0yKSB7XG4gICAgICB2YXIgcyA9IGxpc3Rbal1cbiAgICAgIHZhciB0ID0gbGlzdFtqKzFdXG4gICAgICBpZihpIDwgTWF0aC5taW4ocywgdCkpIHtcbiAgICAgICAgcmVzdWx0LnB1c2goW2ksIHMsIHRdKVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVRyaWFuZ3VsYXRpb24obnVtVmVydHMsIGVkZ2VzKSB7XG4gIHZhciBzdGFycyA9IG5ldyBBcnJheShudW1WZXJ0cylcbiAgZm9yKHZhciBpPTA7IGk8bnVtVmVydHM7ICsraSkge1xuICAgIHN0YXJzW2ldID0gW11cbiAgfVxuICByZXR1cm4gbmV3IFRyaWFuZ3VsYXRpb24oc3RhcnMsIGVkZ2VzKVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbm1vZHVsZS5leHBvcnRzID0gY2xlYW5QU0xHXG5cbnZhciBVbmlvbkZpbmQgPSByZXF1aXJlKCd1bmlvbi1maW5kJylcbnZhciBib3hJbnRlcnNlY3QgPSByZXF1aXJlKCdib3gtaW50ZXJzZWN0JylcbnZhciBzZWdzZWcgPSByZXF1aXJlKCdyb2J1c3Qtc2VnbWVudC1pbnRlcnNlY3QnKVxudmFyIHJhdCA9IHJlcXVpcmUoJ2JpZy1yYXQnKVxudmFyIHJhdENtcCA9IHJlcXVpcmUoJ2JpZy1yYXQvY21wJylcbnZhciByYXRUb0Zsb2F0ID0gcmVxdWlyZSgnYmlnLXJhdC90by1mbG9hdCcpXG52YXIgcmF0VmVjID0gcmVxdWlyZSgncmF0LXZlYycpXG52YXIgbmV4dGFmdGVyID0gcmVxdWlyZSgnbmV4dGFmdGVyJylcblxudmFyIHNvbHZlSW50ZXJzZWN0aW9uID0gcmVxdWlyZSgnLi9saWIvcmF0LXNlZy1pbnRlcnNlY3QnKVxuXG4vLyBCb3VuZHMgb24gYSByYXRpb25hbCBudW1iZXIgd2hlbiByb3VuZGVkIHRvIGEgZmxvYXRcbmZ1bmN0aW9uIGJvdW5kUmF0IChyKSB7XG4gIHZhciBmID0gcmF0VG9GbG9hdChyKVxuICByZXR1cm4gW1xuICAgIG5leHRhZnRlcihmLCAtSW5maW5pdHkpLFxuICAgIG5leHRhZnRlcihmLCBJbmZpbml0eSlcbiAgXVxufVxuXG4vLyBDb252ZXJ0IGEgbGlzdCBvZiBlZGdlcyBpbiBhIHBzbGcgdG8gYm91bmRpbmcgYm94ZXNcbmZ1bmN0aW9uIGJvdW5kRWRnZXMgKHBvaW50cywgZWRnZXMpIHtcbiAgdmFyIGJvdW5kcyA9IG5ldyBBcnJheShlZGdlcy5sZW5ndGgpXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZWRnZXMubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgZSA9IGVkZ2VzW2ldXG4gICAgdmFyIGEgPSBwb2ludHNbZVswXV1cbiAgICB2YXIgYiA9IHBvaW50c1tlWzFdXVxuICAgIGJvdW5kc1tpXSA9IFtcbiAgICAgIG5leHRhZnRlcihNYXRoLm1pbihhWzBdLCBiWzBdKSwgLUluZmluaXR5KSxcbiAgICAgIG5leHRhZnRlcihNYXRoLm1pbihhWzFdLCBiWzFdKSwgLUluZmluaXR5KSxcbiAgICAgIG5leHRhZnRlcihNYXRoLm1heChhWzBdLCBiWzBdKSwgSW5maW5pdHkpLFxuICAgICAgbmV4dGFmdGVyKE1hdGgubWF4KGFbMV0sIGJbMV0pLCBJbmZpbml0eSlcbiAgICBdXG4gIH1cbiAgcmV0dXJuIGJvdW5kc1xufVxuXG4vLyBDb252ZXJ0IGEgbGlzdCBvZiBwb2ludHMgaW50byBib3VuZGluZyBib3hlcyBieSBkdXBsaWNhdGluZyBjb29yZHNcbmZ1bmN0aW9uIGJvdW5kUG9pbnRzIChwb2ludHMpIHtcbiAgdmFyIGJvdW5kcyA9IG5ldyBBcnJheShwb2ludHMubGVuZ3RoKVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7ICsraSkge1xuICAgIHZhciBwID0gcG9pbnRzW2ldXG4gICAgYm91bmRzW2ldID0gW1xuICAgICAgbmV4dGFmdGVyKHBbMF0sIC1JbmZpbml0eSksXG4gICAgICBuZXh0YWZ0ZXIocFsxXSwgLUluZmluaXR5KSxcbiAgICAgIG5leHRhZnRlcihwWzBdLCBJbmZpbml0eSksXG4gICAgICBuZXh0YWZ0ZXIocFsxXSwgSW5maW5pdHkpXG4gICAgXVxuICB9XG4gIHJldHVybiBib3VuZHNcbn1cblxuLy8gRmluZCBhbGwgcGFpcnMgb2YgY3Jvc3NpbmcgZWRnZXMgaW4gYSBwc2xnIChnaXZlbiBlZGdlIGJvdW5kcylcbmZ1bmN0aW9uIGdldENyb3NzaW5ncyAocG9pbnRzLCBlZGdlcywgZWRnZUJvdW5kcykge1xuICB2YXIgcmVzdWx0ID0gW11cbiAgYm94SW50ZXJzZWN0KGVkZ2VCb3VuZHMsIGZ1bmN0aW9uIChpLCBqKSB7XG4gICAgdmFyIGUgPSBlZGdlc1tpXVxuICAgIHZhciBmID0gZWRnZXNbal1cbiAgICBpZiAoZVswXSA9PT0gZlswXSB8fCBlWzBdID09PSBmWzFdIHx8XG4gICAgICBlWzFdID09PSBmWzBdIHx8IGVbMV0gPT09IGZbMV0pIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICB2YXIgYSA9IHBvaW50c1tlWzBdXVxuICAgIHZhciBiID0gcG9pbnRzW2VbMV1dXG4gICAgdmFyIGMgPSBwb2ludHNbZlswXV1cbiAgICB2YXIgZCA9IHBvaW50c1tmWzFdXVxuICAgIGlmIChzZWdzZWcoYSwgYiwgYywgZCkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKFtpLCBqXSlcbiAgICB9XG4gIH0pXG4gIHJldHVybiByZXN1bHRcbn1cblxuLy8gRmluZCBhbGwgcGFpcnMgb2YgY3Jvc3NpbmcgdmVydGljZXMgaW4gYSBwc2xnIChnaXZlbiBlZGdlL3ZlcnQgYm91bmRzKVxuZnVuY3Rpb24gZ2V0VEp1bmN0aW9ucyAocG9pbnRzLCBlZGdlcywgZWRnZUJvdW5kcywgdmVydEJvdW5kcykge1xuICB2YXIgcmVzdWx0ID0gW11cbiAgYm94SW50ZXJzZWN0KGVkZ2VCb3VuZHMsIHZlcnRCb3VuZHMsIGZ1bmN0aW9uIChpLCB2KSB7XG4gICAgdmFyIGUgPSBlZGdlc1tpXVxuICAgIGlmIChlWzBdID09PSB2IHx8IGVbMV0gPT09IHYpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICB2YXIgcCA9IHBvaW50c1t2XVxuICAgIHZhciBhID0gcG9pbnRzW2VbMF1dXG4gICAgdmFyIGIgPSBwb2ludHNbZVsxXV1cbiAgICBpZiAoc2Vnc2VnKGEsIGIsIHAsIHApKSB7XG4gICAgICByZXN1bHQucHVzaChbaSwgdl0pXG4gICAgfVxuICB9KVxuICByZXR1cm4gcmVzdWx0XG59XG5cbi8vIEN1dCBlZGdlcyBhbG9uZyBjcm9zc2luZ3MvdGp1bmN0aW9uc1xuZnVuY3Rpb24gY3V0RWRnZXMgKGZsb2F0UG9pbnRzLCBlZGdlcywgY3Jvc3NpbmdzLCBqdW5jdGlvbnMsIHVzZUNvbG9yKSB7XG4gIHZhciBpLCBlXG5cbiAgLy8gQ29udmVydCBjcm9zc2luZ3MgaW50byB0anVuY3Rpb25zIGJ5IGNvbnN0cnVjdGluZyByYXRpb25hbCBwb2ludHNcbiAgdmFyIHJhdFBvaW50cyA9IGZsb2F0UG9pbnRzLm1hcChmdW5jdGlvbihwKSB7XG4gICAgICByZXR1cm4gW1xuICAgICAgICAgIHJhdChwWzBdKSxcbiAgICAgICAgICByYXQocFsxXSlcbiAgICAgIF1cbiAgfSlcbiAgZm9yIChpID0gMDsgaSA8IGNyb3NzaW5ncy5sZW5ndGg7ICsraSkge1xuICAgIHZhciBjcm9zc2luZyA9IGNyb3NzaW5nc1tpXVxuICAgIGUgPSBjcm9zc2luZ1swXVxuICAgIHZhciBmID0gY3Jvc3NpbmdbMV1cbiAgICB2YXIgZWUgPSBlZGdlc1tlXVxuICAgIHZhciBlZiA9IGVkZ2VzW2ZdXG4gICAgdmFyIHggPSBzb2x2ZUludGVyc2VjdGlvbihcbiAgICAgIHJhdFZlYyhmbG9hdFBvaW50c1tlZVswXV0pLFxuICAgICAgcmF0VmVjKGZsb2F0UG9pbnRzW2VlWzFdXSksXG4gICAgICByYXRWZWMoZmxvYXRQb2ludHNbZWZbMF1dKSxcbiAgICAgIHJhdFZlYyhmbG9hdFBvaW50c1tlZlsxXV0pKVxuICAgIGlmICgheCkge1xuICAgICAgLy8gU2VnbWVudHMgYXJlIHBhcmFsbGVsLCBzaG91bGQgYWxyZWFkeSBiZSBoYW5kbGVkIGJ5IHQtanVuY3Rpb25zXG4gICAgICBjb250aW51ZVxuICAgIH1cbiAgICB2YXIgaWR4ID0gZmxvYXRQb2ludHMubGVuZ3RoXG4gICAgZmxvYXRQb2ludHMucHVzaChbcmF0VG9GbG9hdCh4WzBdKSwgcmF0VG9GbG9hdCh4WzFdKV0pXG4gICAgcmF0UG9pbnRzLnB1c2goeClcbiAgICBqdW5jdGlvbnMucHVzaChbZSwgaWR4XSwgW2YsIGlkeF0pXG4gIH1cblxuICAvLyBTb3J0IHRqdW5jdGlvbnNcbiAganVuY3Rpb25zLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICBpZiAoYVswXSAhPT0gYlswXSkge1xuICAgICAgcmV0dXJuIGFbMF0gLSBiWzBdXG4gICAgfVxuICAgIHZhciB1ID0gcmF0UG9pbnRzW2FbMV1dXG4gICAgdmFyIHYgPSByYXRQb2ludHNbYlsxXV1cbiAgICByZXR1cm4gcmF0Q21wKHVbMF0sIHZbMF0pIHx8IHJhdENtcCh1WzFdLCB2WzFdKVxuICB9KVxuXG4gIC8vIFNwbGl0IGVkZ2VzIGFsb25nIGp1bmN0aW9uc1xuICBmb3IgKGkgPSBqdW5jdGlvbnMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICB2YXIganVuY3Rpb24gPSBqdW5jdGlvbnNbaV1cbiAgICBlID0ganVuY3Rpb25bMF1cblxuICAgIHZhciBlZGdlID0gZWRnZXNbZV1cbiAgICB2YXIgcyA9IGVkZ2VbMF1cbiAgICB2YXIgdCA9IGVkZ2VbMV1cblxuICAgIC8vIENoZWNrIGlmIGVkZ2UgaXMgbm90IGxleGljb2dyYXBoaWNhbGx5IHNvcnRlZFxuICAgIHZhciBhID0gZmxvYXRQb2ludHNbc11cbiAgICB2YXIgYiA9IGZsb2F0UG9pbnRzW3RdXG4gICAgaWYgKCgoYVswXSAtIGJbMF0pIHx8IChhWzFdIC0gYlsxXSkpIDwgMCkge1xuICAgICAgdmFyIHRtcCA9IHNcbiAgICAgIHMgPSB0XG4gICAgICB0ID0gdG1wXG4gICAgfVxuXG4gICAgLy8gU3BsaXQgbGVhZGluZyBlZGdlXG4gICAgZWRnZVswXSA9IHNcbiAgICB2YXIgbGFzdCA9IGVkZ2VbMV0gPSBqdW5jdGlvblsxXVxuXG4gICAgLy8gSWYgd2UgYXJlIGdyb3VwaW5nIGVkZ2VzIGJ5IGNvbG9yLCByZW1lbWJlciB0byB0cmFjayBkYXRhXG4gICAgdmFyIGNvbG9yXG4gICAgaWYgKHVzZUNvbG9yKSB7XG4gICAgICBjb2xvciA9IGVkZ2VbMl1cbiAgICB9XG5cbiAgICAvLyBTcGxpdCBvdGhlciBlZGdlc1xuICAgIHdoaWxlIChpID4gMCAmJiBqdW5jdGlvbnNbaSAtIDFdWzBdID09PSBlKSB7XG4gICAgICB2YXIganVuY3Rpb24gPSBqdW5jdGlvbnNbLS1pXVxuICAgICAgdmFyIG5leHQgPSBqdW5jdGlvblsxXVxuICAgICAgaWYgKHVzZUNvbG9yKSB7XG4gICAgICAgIGVkZ2VzLnB1c2goW2xhc3QsIG5leHQsIGNvbG9yXSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVkZ2VzLnB1c2goW2xhc3QsIG5leHRdKVxuICAgICAgfVxuICAgICAgbGFzdCA9IG5leHRcbiAgICB9XG5cbiAgICAvLyBBZGQgZmluYWwgZWRnZVxuICAgIGlmICh1c2VDb2xvcikge1xuICAgICAgZWRnZXMucHVzaChbbGFzdCwgdCwgY29sb3JdKVxuICAgIH0gZWxzZSB7XG4gICAgICBlZGdlcy5wdXNoKFtsYXN0LCB0XSlcbiAgICB9XG4gIH1cblxuICAvLyBSZXR1cm4gY29uc3RydWN0ZWQgcmF0aW9uYWwgcG9pbnRzXG4gIHJldHVybiByYXRQb2ludHNcbn1cblxuLy8gTWVyZ2Ugb3ZlcmxhcHBpbmcgcG9pbnRzXG5mdW5jdGlvbiBkZWR1cFBvaW50cyAoZmxvYXRQb2ludHMsIHJhdFBvaW50cywgZmxvYXRCb3VuZHMpIHtcbiAgdmFyIG51bVBvaW50cyA9IHJhdFBvaW50cy5sZW5ndGhcbiAgdmFyIHVmID0gbmV3IFVuaW9uRmluZChudW1Qb2ludHMpXG5cbiAgLy8gQ29tcHV0ZSByYXRpb25hbCBib3VuZHNcbiAgdmFyIGJvdW5kcyA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcmF0UG9pbnRzLmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIHAgPSByYXRQb2ludHNbaV1cbiAgICB2YXIgeGIgPSBib3VuZFJhdChwWzBdKVxuICAgIHZhciB5YiA9IGJvdW5kUmF0KHBbMV0pXG4gICAgYm91bmRzLnB1c2goW1xuICAgICAgbmV4dGFmdGVyKHhiWzBdLCAtSW5maW5pdHkpLFxuICAgICAgbmV4dGFmdGVyKHliWzBdLCAtSW5maW5pdHkpLFxuICAgICAgbmV4dGFmdGVyKHhiWzFdLCBJbmZpbml0eSksXG4gICAgICBuZXh0YWZ0ZXIoeWJbMV0sIEluZmluaXR5KVxuICAgIF0pXG4gIH1cblxuICAvLyBMaW5rIGFsbCBwb2ludHMgd2l0aCBvdmVyIGxhcHBpbmcgYm94ZXNcbiAgYm94SW50ZXJzZWN0KGJvdW5kcywgZnVuY3Rpb24gKGksIGopIHtcbiAgICB1Zi5saW5rKGksIGopXG4gIH0pXG5cbiAgLy8gRG8gMSBwYXNzIG92ZXIgcG9pbnRzIHRvIGNvbWJpbmUgcG9pbnRzIGluIGxhYmVsIHNldHNcbiAgdmFyIG5vRHVwZXMgPSB0cnVlXG4gIHZhciBsYWJlbHMgPSBuZXcgQXJyYXkobnVtUG9pbnRzKVxuICBmb3IgKHZhciBpID0gMDsgaSA8IG51bVBvaW50czsgKytpKSB7XG4gICAgdmFyIGogPSB1Zi5maW5kKGkpXG4gICAgaWYgKGogIT09IGkpIHtcbiAgICAgIC8vIENsZWFyIG5vLWR1cGVzIGZsYWcsIHplcm8gb3V0IGxhYmVsXG4gICAgICBub0R1cGVzID0gZmFsc2VcbiAgICAgIC8vIE1ha2UgZWFjaCBwb2ludCB0aGUgdG9wLWxlZnQgcG9pbnQgZnJvbSBpdHMgY2VsbFxuICAgICAgZmxvYXRQb2ludHNbal0gPSBbXG4gICAgICAgIE1hdGgubWluKGZsb2F0UG9pbnRzW2ldWzBdLCBmbG9hdFBvaW50c1tqXVswXSksXG4gICAgICAgIE1hdGgubWluKGZsb2F0UG9pbnRzW2ldWzFdLCBmbG9hdFBvaW50c1tqXVsxXSlcbiAgICAgIF1cbiAgICB9XG4gIH1cblxuICAvLyBJZiBubyBkdXBsaWNhdGVzLCByZXR1cm4gbnVsbCB0byBzaWduYWwgdGVybWluYXRpb25cbiAgaWYgKG5vRHVwZXMpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgdmFyIHB0ciA9IDBcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1Qb2ludHM7ICsraSkge1xuICAgIHZhciBqID0gdWYuZmluZChpKVxuICAgIGlmIChqID09PSBpKSB7XG4gICAgICBsYWJlbHNbaV0gPSBwdHJcbiAgICAgIGZsb2F0UG9pbnRzW3B0cisrXSA9IGZsb2F0UG9pbnRzW2ldXG4gICAgfSBlbHNlIHtcbiAgICAgIGxhYmVsc1tpXSA9IC0xXG4gICAgfVxuICB9XG5cbiAgZmxvYXRQb2ludHMubGVuZ3RoID0gcHRyXG5cbiAgLy8gRG8gYSBzZWNvbmQgcGFzcyB0byBmaXggdXAgbWlzc2luZyBsYWJlbHNcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1Qb2ludHM7ICsraSkge1xuICAgIGlmIChsYWJlbHNbaV0gPCAwKSB7XG4gICAgICBsYWJlbHNbaV0gPSBsYWJlbHNbdWYuZmluZChpKV1cbiAgICB9XG4gIH1cblxuICAvLyBSZXR1cm4gcmVzdWx0aW5nIHVuaW9uLWZpbmQgZGF0YSBzdHJ1Y3R1cmVcbiAgcmV0dXJuIGxhYmVsc1xufVxuXG5mdW5jdGlvbiBjb21wYXJlTGV4MiAoYSwgYikgeyByZXR1cm4gKGFbMF0gLSBiWzBdKSB8fCAoYVsxXSAtIGJbMV0pIH1cbmZ1bmN0aW9uIGNvbXBhcmVMZXgzIChhLCBiKSB7XG4gIHZhciBkID0gKGFbMF0gLSBiWzBdKSB8fCAoYVsxXSAtIGJbMV0pXG4gIGlmIChkKSB7XG4gICAgcmV0dXJuIGRcbiAgfVxuICBpZiAoYVsyXSA8IGJbMl0pIHtcbiAgICByZXR1cm4gLTFcbiAgfSBlbHNlIGlmIChhWzJdID4gYlsyXSkge1xuICAgIHJldHVybiAxXG4gIH1cbiAgcmV0dXJuIDBcbn1cblxuLy8gUmVtb3ZlIGR1cGxpY2F0ZSBlZGdlIGxhYmVsc1xuZnVuY3Rpb24gZGVkdXBFZGdlcyAoZWRnZXMsIGxhYmVscywgdXNlQ29sb3IpIHtcbiAgaWYgKGVkZ2VzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVyblxuICB9XG4gIGlmIChsYWJlbHMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVkZ2VzLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgZSA9IGVkZ2VzW2ldXG4gICAgICB2YXIgYSA9IGxhYmVsc1tlWzBdXVxuICAgICAgdmFyIGIgPSBsYWJlbHNbZVsxXV1cbiAgICAgIGVbMF0gPSBNYXRoLm1pbihhLCBiKVxuICAgICAgZVsxXSA9IE1hdGgubWF4KGEsIGIpXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWRnZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciBlID0gZWRnZXNbaV1cbiAgICAgIHZhciBhID0gZVswXVxuICAgICAgdmFyIGIgPSBlWzFdXG4gICAgICBlWzBdID0gTWF0aC5taW4oYSwgYilcbiAgICAgIGVbMV0gPSBNYXRoLm1heChhLCBiKVxuICAgIH1cbiAgfVxuICBpZiAodXNlQ29sb3IpIHtcbiAgICBlZGdlcy5zb3J0KGNvbXBhcmVMZXgzKVxuICB9IGVsc2Uge1xuICAgIGVkZ2VzLnNvcnQoY29tcGFyZUxleDIpXG4gIH1cbiAgdmFyIHB0ciA9IDFcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBlZGdlcy5sZW5ndGg7ICsraSkge1xuICAgIHZhciBwcmV2ID0gZWRnZXNbaSAtIDFdXG4gICAgdmFyIG5leHQgPSBlZGdlc1tpXVxuICAgIGlmIChuZXh0WzBdID09PSBwcmV2WzBdICYmIG5leHRbMV0gPT09IHByZXZbMV0gJiZcbiAgICAgICghdXNlQ29sb3IgfHwgbmV4dFsyXSA9PT0gcHJldlsyXSkpIHtcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuICAgIGVkZ2VzW3B0cisrXSA9IG5leHRcbiAgfVxuICBlZGdlcy5sZW5ndGggPSBwdHJcbn1cblxuZnVuY3Rpb24gcHJlUm91bmQgKHBvaW50cywgZWRnZXMsIHVzZUNvbG9yKSB7XG4gIHZhciBsYWJlbHMgPSBkZWR1cFBvaW50cyhwb2ludHMsIFtdLCBib3VuZFBvaW50cyhwb2ludHMpKVxuICBkZWR1cEVkZ2VzKGVkZ2VzLCBsYWJlbHMsIHVzZUNvbG9yKVxuICByZXR1cm4gISFsYWJlbHNcbn1cblxuLy8gUmVwZWF0IHVudGlsIGNvbnZlcmdlbmNlXG5mdW5jdGlvbiBzbmFwUm91bmQgKHBvaW50cywgZWRnZXMsIHVzZUNvbG9yKSB7XG4gIC8vIDEuIGZpbmQgZWRnZSBjcm9zc2luZ3NcbiAgdmFyIGVkZ2VCb3VuZHMgPSBib3VuZEVkZ2VzKHBvaW50cywgZWRnZXMpXG4gIHZhciBjcm9zc2luZ3MgPSBnZXRDcm9zc2luZ3MocG9pbnRzLCBlZGdlcywgZWRnZUJvdW5kcylcblxuICAvLyAyLiBmaW5kIHQtanVuY3Rpb25zXG4gIHZhciB2ZXJ0Qm91bmRzID0gYm91bmRQb2ludHMocG9pbnRzKVxuICB2YXIgdGp1bmN0aW9ucyA9IGdldFRKdW5jdGlvbnMocG9pbnRzLCBlZGdlcywgZWRnZUJvdW5kcywgdmVydEJvdW5kcylcblxuICAvLyAzLiBjdXQgZWRnZXMsIGNvbnN0cnVjdCByYXRpb25hbCBwb2ludHNcbiAgdmFyIHJhdFBvaW50cyA9IGN1dEVkZ2VzKHBvaW50cywgZWRnZXMsIGNyb3NzaW5ncywgdGp1bmN0aW9ucywgdXNlQ29sb3IpXG5cbiAgLy8gNC4gZGVkdXBlIHZlcnRzXG4gIHZhciBsYWJlbHMgPSBkZWR1cFBvaW50cyhwb2ludHMsIHJhdFBvaW50cywgdmVydEJvdW5kcylcblxuICAvLyA1LiBkZWR1cGUgZWRnZXNcbiAgZGVkdXBFZGdlcyhlZGdlcywgbGFiZWxzLCB1c2VDb2xvcilcblxuICAvLyA2LiBjaGVjayB0ZXJtaW5hdGlvblxuICBpZiAoIWxhYmVscykge1xuICAgIHJldHVybiAoY3Jvc3NpbmdzLmxlbmd0aCA+IDAgfHwgdGp1bmN0aW9ucy5sZW5ndGggPiAwKVxuICB9XG5cbiAgLy8gTW9yZSBpdGVyYXRpb25zIG5lY2Vzc2FyeVxuICByZXR1cm4gdHJ1ZVxufVxuXG4vLyBNYWluIGxvb3AsIHJ1bnMgUFNMRyBjbGVhbiB1cCB1bnRpbCBjb21wbGV0aW9uXG5mdW5jdGlvbiBjbGVhblBTTEcgKHBvaW50cywgZWRnZXMsIGNvbG9ycykge1xuICAvLyBJZiB1c2luZyBjb2xvcnMsIGF1Z21lbnQgZWRnZXMgd2l0aCBjb2xvciBkYXRhXG4gIHZhciBwcmV2RWRnZXNcbiAgaWYgKGNvbG9ycykge1xuICAgIHByZXZFZGdlcyA9IGVkZ2VzXG4gICAgdmFyIGF1Z0VkZ2VzID0gbmV3IEFycmF5KGVkZ2VzLmxlbmd0aClcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVkZ2VzLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgZSA9IGVkZ2VzW2ldXG4gICAgICBhdWdFZGdlc1tpXSA9IFtlWzBdLCBlWzFdLCBjb2xvcnNbaV1dXG4gICAgfVxuICAgIGVkZ2VzID0gYXVnRWRnZXNcbiAgfVxuXG4gIC8vIEZpcnN0IHJvdW5kOiByZW1vdmUgZHVwbGljYXRlIGVkZ2VzIGFuZCBwb2ludHNcbiAgdmFyIG1vZGlmaWVkID0gcHJlUm91bmQocG9pbnRzLCBlZGdlcywgISFjb2xvcnMpXG5cbiAgLy8gUnVuIHNuYXAgcm91bmRpbmcgdW50aWwgY29udmVyZ2VuY2VcbiAgd2hpbGUgKHNuYXBSb3VuZChwb2ludHMsIGVkZ2VzLCAhIWNvbG9ycykpIHtcbiAgICBtb2RpZmllZCA9IHRydWVcbiAgfVxuXG4gIC8vIFN0cmlwIGNvbG9yIHRhZ3NcbiAgaWYgKCEhY29sb3JzICYmIG1vZGlmaWVkKSB7XG4gICAgcHJldkVkZ2VzLmxlbmd0aCA9IDBcbiAgICBjb2xvcnMubGVuZ3RoID0gMFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWRnZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciBlID0gZWRnZXNbaV1cbiAgICAgIHByZXZFZGdlcy5wdXNoKFtlWzBdLCBlWzFdXSlcbiAgICAgIGNvbG9ycy5wdXNoKGVbMl0pXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG1vZGlmaWVkXG59XG4iLCIndXNlIHN0cmljdCdcblxubW9kdWxlLmV4cG9ydHMgPSBzb2x2ZUludGVyc2VjdGlvblxuXG52YXIgcmF0TXVsID0gcmVxdWlyZSgnYmlnLXJhdC9tdWwnKVxudmFyIHJhdERpdiA9IHJlcXVpcmUoJ2JpZy1yYXQvZGl2JylcbnZhciByYXRTdWIgPSByZXF1aXJlKCdiaWctcmF0L3N1YicpXG52YXIgcmF0U2lnbiA9IHJlcXVpcmUoJ2JpZy1yYXQvc2lnbicpXG52YXIgcnZTdWIgPSByZXF1aXJlKCdyYXQtdmVjL3N1YicpXG52YXIgcnZBZGQgPSByZXF1aXJlKCdyYXQtdmVjL2FkZCcpXG52YXIgcnZNdWxzID0gcmVxdWlyZSgncmF0LXZlYy9tdWxzJylcblxuZnVuY3Rpb24gcmF0UGVycCAoYSwgYikge1xuICByZXR1cm4gcmF0U3ViKHJhdE11bChhWzBdLCBiWzFdKSwgcmF0TXVsKGFbMV0sIGJbMF0pKVxufVxuXG4vLyBTb2x2ZSBmb3IgaW50ZXJzZWN0aW9uXG4vLyAgeCA9IGEgKyB0IChiLWEpXG4vLyAgKHggLSBjKSBeIChkLWMpID0gMFxuLy8gICh0ICogKGItYSkgKyAoYS1jKSApIF4gKGQtYykgPSAwXG4vLyAgdCAqIChiLWEpXihkLWMpID0gKGQtYyleKGEtYylcbi8vICB0ID0gKGQtYyleKGEtYykgLyAoYi1hKV4oZC1jKVxuXG5mdW5jdGlvbiBzb2x2ZUludGVyc2VjdGlvbiAoYSwgYiwgYywgZCkge1xuICB2YXIgYmEgPSBydlN1YihiLCBhKVxuICB2YXIgZGMgPSBydlN1YihkLCBjKVxuXG4gIHZhciBiYVhkYyA9IHJhdFBlcnAoYmEsIGRjKVxuXG4gIGlmIChyYXRTaWduKGJhWGRjKSA9PT0gMCkge1xuICAgIHJldHVybiBudWxsXG4gIH1cblxuICB2YXIgYWMgPSBydlN1YihhLCBjKVxuICB2YXIgZGNYYWMgPSByYXRQZXJwKGRjLCBhYylcblxuICB2YXIgdCA9IHJhdERpdihkY1hhYywgYmFYZGMpXG4gIHZhciBzID0gcnZNdWxzKGJhLCB0KVxuICB2YXIgciA9IHJ2QWRkKGEsIHMpXG5cbiAgcmV0dXJuIHJcbn1cbiIsIlwidXNlIHN0cmljdFwiXG5cbm1vZHVsZS5leHBvcnRzID0gY29tcGFyZUFuZ2xlXG5cbnZhciBvcmllbnQgPSByZXF1aXJlKFwicm9idXN0LW9yaWVudGF0aW9uXCIpXG52YXIgc2duID0gcmVxdWlyZShcInNpZ251bVwiKVxudmFyIHR3b1N1bSA9IHJlcXVpcmUoXCJ0d28tc3VtXCIpXG52YXIgcm9idXN0UHJvZHVjdCA9IHJlcXVpcmUoXCJyb2J1c3QtcHJvZHVjdFwiKVxudmFyIHJvYnVzdFN1bSA9IHJlcXVpcmUoXCJyb2J1c3Qtc3VtXCIpXG5cbmZ1bmN0aW9uIHRlc3RJbnRlcmlvcihhLCBiLCBjKSB7XG4gIHZhciB4MCA9IHR3b1N1bShhWzBdLCAtYlswXSlcbiAgdmFyIHkwID0gdHdvU3VtKGFbMV0sIC1iWzFdKVxuICB2YXIgeDEgPSB0d29TdW0oY1swXSwgLWJbMF0pXG4gIHZhciB5MSA9IHR3b1N1bShjWzFdLCAtYlsxXSlcblxuICB2YXIgZCA9IHJvYnVzdFN1bShcbiAgICByb2J1c3RQcm9kdWN0KHgwLCB4MSksXG4gICAgcm9idXN0UHJvZHVjdCh5MCwgeTEpKVxuXG4gIHJldHVybiBkW2QubGVuZ3RoLTFdID49IDBcbn1cblxuZnVuY3Rpb24gY29tcGFyZUFuZ2xlKGEsIGIsIGMsIGQpIHtcbiAgdmFyIGJjZCA9IG9yaWVudChiLCBjLCBkKVxuICBpZihiY2QgPT09IDApIHtcbiAgICAvL0hhbmRsZSBkZWdlbmVyYXRlIGNhc2VzXG4gICAgdmFyIHNhYmMgPSBzZ24ob3JpZW50KGEsIGIsIGMpKVxuICAgIHZhciBzYWJkID0gc2duKG9yaWVudChhLCBiLCBkKSlcbiAgICBpZihzYWJjID09PSBzYWJkKSB7XG4gICAgICBpZihzYWJjID09PSAwKSB7XG4gICAgICAgIHZhciBpYyA9IHRlc3RJbnRlcmlvcihhLCBiLCBjKVxuICAgICAgICB2YXIgaWQgPSB0ZXN0SW50ZXJpb3IoYSwgYiwgZClcbiAgICAgICAgaWYoaWMgPT09IGlkKSB7XG4gICAgICAgICAgcmV0dXJuIDBcbiAgICAgICAgfSBlbHNlIGlmKGljKSB7XG4gICAgICAgICAgcmV0dXJuIDFcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gLTFcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIDBcbiAgICB9IGVsc2UgaWYoc2FiZCA9PT0gMCkge1xuICAgICAgaWYoc2FiYyA+IDApIHtcbiAgICAgICAgcmV0dXJuIC0xXG4gICAgICB9IGVsc2UgaWYodGVzdEludGVyaW9yKGEsIGIsIGQpKSB7XG4gICAgICAgIHJldHVybiAtMVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIDFcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYoc2FiYyA9PT0gMCkge1xuICAgICAgaWYoc2FiZCA+IDApIHtcbiAgICAgICAgcmV0dXJuIDFcbiAgICAgIH0gZWxzZSBpZih0ZXN0SW50ZXJpb3IoYSwgYiwgYykpIHtcbiAgICAgICAgcmV0dXJuIDFcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAtMVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2duKHNhYmQgLSBzYWJjKVxuICB9XG4gIHZhciBhYmMgPSBvcmllbnQoYSwgYiwgYylcbiAgaWYoYWJjID4gMCkge1xuICAgIGlmKGJjZCA+IDAgJiYgb3JpZW50KGEsIGIsIGQpID4gMCkge1xuICAgICAgcmV0dXJuIDFcbiAgICB9XG4gICAgcmV0dXJuIC0xXG4gIH0gZWxzZSBpZihhYmMgPCAwKSB7XG4gICAgaWYoYmNkID4gMCB8fCBvcmllbnQoYSwgYiwgZCkgPiAwKSB7XG4gICAgICByZXR1cm4gMVxuICAgIH1cbiAgICByZXR1cm4gLTFcbiAgfSBlbHNlIHtcbiAgICB2YXIgYWJkID0gb3JpZW50KGEsIGIsIGQpXG4gICAgaWYoYWJkID4gMCkge1xuICAgICAgcmV0dXJuIDFcbiAgICB9IGVsc2Uge1xuICAgICAgaWYodGVzdEludGVyaW9yKGEsIGIsIGMpKSB7XG4gICAgICAgIHJldHVybiAxXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gLTFcbiAgICAgIH1cbiAgICB9XG4gIH1cbn0iLCJcInVzZSBzdHJpY3RcIlxuXG52YXIgY3JlYXRlVGh1bmsgPSByZXF1aXJlKFwiLi9saWIvdGh1bmsuanNcIilcblxuZnVuY3Rpb24gUHJvY2VkdXJlKCkge1xuICB0aGlzLmFyZ1R5cGVzID0gW11cbiAgdGhpcy5zaGltQXJncyA9IFtdXG4gIHRoaXMuYXJyYXlBcmdzID0gW11cbiAgdGhpcy5hcnJheUJsb2NrSW5kaWNlcyA9IFtdXG4gIHRoaXMuc2NhbGFyQXJncyA9IFtdXG4gIHRoaXMub2Zmc2V0QXJncyA9IFtdXG4gIHRoaXMub2Zmc2V0QXJnSW5kZXggPSBbXVxuICB0aGlzLmluZGV4QXJncyA9IFtdXG4gIHRoaXMuc2hhcGVBcmdzID0gW11cbiAgdGhpcy5mdW5jTmFtZSA9IFwiXCJcbiAgdGhpcy5wcmUgPSBudWxsXG4gIHRoaXMuYm9keSA9IG51bGxcbiAgdGhpcy5wb3N0ID0gbnVsbFxuICB0aGlzLmRlYnVnID0gZmFsc2Vcbn1cblxuZnVuY3Rpb24gY29tcGlsZUN3aXNlKHVzZXJfYXJncykge1xuICAvL0NyZWF0ZSBwcm9jZWR1cmVcbiAgdmFyIHByb2MgPSBuZXcgUHJvY2VkdXJlKClcbiAgXG4gIC8vUGFyc2UgYmxvY2tzXG4gIHByb2MucHJlICAgID0gdXNlcl9hcmdzLnByZVxuICBwcm9jLmJvZHkgICA9IHVzZXJfYXJncy5ib2R5XG4gIHByb2MucG9zdCAgID0gdXNlcl9hcmdzLnBvc3RcblxuICAvL1BhcnNlIGFyZ3VtZW50c1xuICB2YXIgcHJvY19hcmdzID0gdXNlcl9hcmdzLmFyZ3Muc2xpY2UoMClcbiAgcHJvYy5hcmdUeXBlcyA9IHByb2NfYXJnc1xuICBmb3IodmFyIGk9MDsgaTxwcm9jX2FyZ3MubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgYXJnX3R5cGUgPSBwcm9jX2FyZ3NbaV1cbiAgICBpZihhcmdfdHlwZSA9PT0gXCJhcnJheVwiIHx8ICh0eXBlb2YgYXJnX3R5cGUgPT09IFwib2JqZWN0XCIgJiYgYXJnX3R5cGUuYmxvY2tJbmRpY2VzKSkge1xuICAgICAgcHJvYy5hcmdUeXBlc1tpXSA9IFwiYXJyYXlcIlxuICAgICAgcHJvYy5hcnJheUFyZ3MucHVzaChpKVxuICAgICAgcHJvYy5hcnJheUJsb2NrSW5kaWNlcy5wdXNoKGFyZ190eXBlLmJsb2NrSW5kaWNlcyA/IGFyZ190eXBlLmJsb2NrSW5kaWNlcyA6IDApXG4gICAgICBwcm9jLnNoaW1BcmdzLnB1c2goXCJhcnJheVwiICsgaSlcbiAgICAgIGlmKGkgPCBwcm9jLnByZS5hcmdzLmxlbmd0aCAmJiBwcm9jLnByZS5hcmdzW2ldLmNvdW50PjApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY3dpc2U6IHByZSgpIGJsb2NrIG1heSBub3QgcmVmZXJlbmNlIGFycmF5IGFyZ3NcIilcbiAgICAgIH1cbiAgICAgIGlmKGkgPCBwcm9jLnBvc3QuYXJncy5sZW5ndGggJiYgcHJvYy5wb3N0LmFyZ3NbaV0uY291bnQ+MCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjd2lzZTogcG9zdCgpIGJsb2NrIG1heSBub3QgcmVmZXJlbmNlIGFycmF5IGFyZ3NcIilcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYoYXJnX3R5cGUgPT09IFwic2NhbGFyXCIpIHtcbiAgICAgIHByb2Muc2NhbGFyQXJncy5wdXNoKGkpXG4gICAgICBwcm9jLnNoaW1BcmdzLnB1c2goXCJzY2FsYXJcIiArIGkpXG4gICAgfSBlbHNlIGlmKGFyZ190eXBlID09PSBcImluZGV4XCIpIHtcbiAgICAgIHByb2MuaW5kZXhBcmdzLnB1c2goaSlcbiAgICAgIGlmKGkgPCBwcm9jLnByZS5hcmdzLmxlbmd0aCAmJiBwcm9jLnByZS5hcmdzW2ldLmNvdW50ID4gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjd2lzZTogcHJlKCkgYmxvY2sgbWF5IG5vdCByZWZlcmVuY2UgYXJyYXkgaW5kZXhcIilcbiAgICAgIH1cbiAgICAgIGlmKGkgPCBwcm9jLmJvZHkuYXJncy5sZW5ndGggJiYgcHJvYy5ib2R5LmFyZ3NbaV0ubHZhbHVlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImN3aXNlOiBib2R5KCkgYmxvY2sgbWF5IG5vdCB3cml0ZSB0byBhcnJheSBpbmRleFwiKVxuICAgICAgfVxuICAgICAgaWYoaSA8IHByb2MucG9zdC5hcmdzLmxlbmd0aCAmJiBwcm9jLnBvc3QuYXJnc1tpXS5jb3VudCA+IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY3dpc2U6IHBvc3QoKSBibG9jayBtYXkgbm90IHJlZmVyZW5jZSBhcnJheSBpbmRleFwiKVxuICAgICAgfVxuICAgIH0gZWxzZSBpZihhcmdfdHlwZSA9PT0gXCJzaGFwZVwiKSB7XG4gICAgICBwcm9jLnNoYXBlQXJncy5wdXNoKGkpXG4gICAgICBpZihpIDwgcHJvYy5wcmUuYXJncy5sZW5ndGggJiYgcHJvYy5wcmUuYXJnc1tpXS5sdmFsdWUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY3dpc2U6IHByZSgpIGJsb2NrIG1heSBub3Qgd3JpdGUgdG8gYXJyYXkgc2hhcGVcIilcbiAgICAgIH1cbiAgICAgIGlmKGkgPCBwcm9jLmJvZHkuYXJncy5sZW5ndGggJiYgcHJvYy5ib2R5LmFyZ3NbaV0ubHZhbHVlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImN3aXNlOiBib2R5KCkgYmxvY2sgbWF5IG5vdCB3cml0ZSB0byBhcnJheSBzaGFwZVwiKVxuICAgICAgfVxuICAgICAgaWYoaSA8IHByb2MucG9zdC5hcmdzLmxlbmd0aCAmJiBwcm9jLnBvc3QuYXJnc1tpXS5sdmFsdWUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY3dpc2U6IHBvc3QoKSBibG9jayBtYXkgbm90IHdyaXRlIHRvIGFycmF5IHNoYXBlXCIpXG4gICAgICB9XG4gICAgfSBlbHNlIGlmKHR5cGVvZiBhcmdfdHlwZSA9PT0gXCJvYmplY3RcIiAmJiBhcmdfdHlwZS5vZmZzZXQpIHtcbiAgICAgIHByb2MuYXJnVHlwZXNbaV0gPSBcIm9mZnNldFwiXG4gICAgICBwcm9jLm9mZnNldEFyZ3MucHVzaCh7IGFycmF5OiBhcmdfdHlwZS5hcnJheSwgb2Zmc2V0OmFyZ190eXBlLm9mZnNldCB9KVxuICAgICAgcHJvYy5vZmZzZXRBcmdJbmRleC5wdXNoKGkpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImN3aXNlOiBVbmtub3duIGFyZ3VtZW50IHR5cGUgXCIgKyBwcm9jX2FyZ3NbaV0pXG4gICAgfVxuICB9XG4gIFxuICAvL01ha2Ugc3VyZSBhdCBsZWFzdCBvbmUgYXJyYXkgYXJndW1lbnQgd2FzIHNwZWNpZmllZFxuICBpZihwcm9jLmFycmF5QXJncy5sZW5ndGggPD0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImN3aXNlOiBObyBhcnJheSBhcmd1bWVudHMgc3BlY2lmaWVkXCIpXG4gIH1cbiAgXG4gIC8vTWFrZSBzdXJlIGFyZ3VtZW50cyBhcmUgY29ycmVjdFxuICBpZihwcm9jLnByZS5hcmdzLmxlbmd0aCA+IHByb2NfYXJncy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJjd2lzZTogVG9vIG1hbnkgYXJndW1lbnRzIGluIHByZSgpIGJsb2NrXCIpXG4gIH1cbiAgaWYocHJvYy5ib2R5LmFyZ3MubGVuZ3RoID4gcHJvY19hcmdzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImN3aXNlOiBUb28gbWFueSBhcmd1bWVudHMgaW4gYm9keSgpIGJsb2NrXCIpXG4gIH1cbiAgaWYocHJvYy5wb3N0LmFyZ3MubGVuZ3RoID4gcHJvY19hcmdzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImN3aXNlOiBUb28gbWFueSBhcmd1bWVudHMgaW4gcG9zdCgpIGJsb2NrXCIpXG4gIH1cblxuICAvL0NoZWNrIGRlYnVnIGZsYWdcbiAgcHJvYy5kZWJ1ZyA9ICEhdXNlcl9hcmdzLnByaW50Q29kZSB8fCAhIXVzZXJfYXJncy5kZWJ1Z1xuICBcbiAgLy9SZXRyaWV2ZSBuYW1lXG4gIHByb2MuZnVuY05hbWUgPSB1c2VyX2FyZ3MuZnVuY05hbWUgfHwgXCJjd2lzZVwiXG4gIFxuICAvL1JlYWQgaW4gYmxvY2sgc2l6ZVxuICBwcm9jLmJsb2NrU2l6ZSA9IHVzZXJfYXJncy5ibG9ja1NpemUgfHwgNjRcblxuICByZXR1cm4gY3JlYXRlVGh1bmsocHJvYylcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb21waWxlQ3dpc2VcbiIsIlwidXNlIHN0cmljdFwiXG5cbnZhciB1bmlxID0gcmVxdWlyZShcInVuaXFcIilcblxuLy8gVGhpcyBmdW5jdGlvbiBnZW5lcmF0ZXMgdmVyeSBzaW1wbGUgbG9vcHMgYW5hbG9nb3VzIHRvIGhvdyB5b3UgdHlwaWNhbGx5IHRyYXZlcnNlIGFycmF5cyAodGhlIG91dGVybW9zdCBsb29wIGNvcnJlc3BvbmRzIHRvIHRoZSBzbG93ZXN0IGNoYW5naW5nIGluZGV4LCB0aGUgaW5uZXJtb3N0IGxvb3AgdG8gdGhlIGZhc3Rlc3QgY2hhbmdpbmcgaW5kZXgpXG4vLyBUT0RPOiBJZiB0d28gYXJyYXlzIGhhdmUgdGhlIHNhbWUgc3RyaWRlcyAoYW5kIG9mZnNldHMpIHRoZXJlIGlzIHBvdGVudGlhbCBmb3IgZGVjcmVhc2luZyB0aGUgbnVtYmVyIG9mIFwicG9pbnRlcnNcIiBhbmQgcmVsYXRlZCB2YXJpYWJsZXMuIFRoZSBkcmF3YmFjayBpcyB0aGF0IHRoZSB0eXBlIHNpZ25hdHVyZSB3b3VsZCBiZWNvbWUgbW9yZSBzcGVjaWZpYyBhbmQgdGhhdCB0aGVyZSB3b3VsZCB0aHVzIGJlIGxlc3MgcG90ZW50aWFsIGZvciBjYWNoaW5nLCBidXQgaXQgbWlnaHQgc3RpbGwgYmUgd29ydGggaXQsIGVzcGVjaWFsbHkgd2hlbiBkZWFsaW5nIHdpdGggbGFyZ2UgbnVtYmVycyBvZiBhcmd1bWVudHMuXG5mdW5jdGlvbiBpbm5lckZpbGwob3JkZXIsIHByb2MsIGJvZHkpIHtcbiAgdmFyIGRpbWVuc2lvbiA9IG9yZGVyLmxlbmd0aFxuICAgICwgbmFyZ3MgPSBwcm9jLmFycmF5QXJncy5sZW5ndGhcbiAgICAsIGhhc19pbmRleCA9IHByb2MuaW5kZXhBcmdzLmxlbmd0aD4wXG4gICAgLCBjb2RlID0gW11cbiAgICAsIHZhcnMgPSBbXVxuICAgICwgaWR4PTAsIHBpZHg9MCwgaSwgalxuICBmb3IoaT0wOyBpPGRpbWVuc2lvbjsgKytpKSB7IC8vIEl0ZXJhdGlvbiB2YXJpYWJsZXNcbiAgICB2YXJzLnB1c2goW1wiaVwiLGksXCI9MFwiXS5qb2luKFwiXCIpKVxuICB9XG4gIC8vQ29tcHV0ZSBzY2FuIGRlbHRhc1xuICBmb3Ioaj0wOyBqPG5hcmdzOyArK2opIHtcbiAgICBmb3IoaT0wOyBpPGRpbWVuc2lvbjsgKytpKSB7XG4gICAgICBwaWR4ID0gaWR4XG4gICAgICBpZHggPSBvcmRlcltpXVxuICAgICAgaWYoaSA9PT0gMCkgeyAvLyBUaGUgaW5uZXJtb3N0L2Zhc3Rlc3QgZGltZW5zaW9uJ3MgZGVsdGEgaXMgc2ltcGx5IGl0cyBzdHJpZGVcbiAgICAgICAgdmFycy5wdXNoKFtcImRcIixqLFwic1wiLGksXCI9dFwiLGosXCJwXCIsaWR4XS5qb2luKFwiXCIpKVxuICAgICAgfSBlbHNlIHsgLy8gRm9yIG90aGVyIGRpbWVuc2lvbnMgdGhlIGRlbHRhIGlzIGJhc2ljYWxseSB0aGUgc3RyaWRlIG1pbnVzIHNvbWV0aGluZyB3aGljaCBlc3NlbnRpYWxseSBcInJld2luZHNcIiB0aGUgcHJldmlvdXMgKG1vcmUgaW5uZXIpIGRpbWVuc2lvblxuICAgICAgICB2YXJzLnB1c2goW1wiZFwiLGosXCJzXCIsaSxcIj0odFwiLGosXCJwXCIsaWR4LFwiLXNcIixwaWR4LFwiKnRcIixqLFwicFwiLHBpZHgsXCIpXCJdLmpvaW4oXCJcIikpXG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmICh2YXJzLmxlbmd0aCA+IDApIHtcbiAgICBjb2RlLnB1c2goXCJ2YXIgXCIgKyB2YXJzLmpvaW4oXCIsXCIpKVxuICB9ICBcbiAgLy9TY2FuIGxvb3BcbiAgZm9yKGk9ZGltZW5zaW9uLTE7IGk+PTA7IC0taSkgeyAvLyBTdGFydCBhdCBsYXJnZXN0IHN0cmlkZSBhbmQgd29yayB5b3VyIHdheSBpbndhcmRzXG4gICAgaWR4ID0gb3JkZXJbaV1cbiAgICBjb2RlLnB1c2goW1wiZm9yKGlcIixpLFwiPTA7aVwiLGksXCI8c1wiLGlkeCxcIjsrK2lcIixpLFwiKXtcIl0uam9pbihcIlwiKSlcbiAgfVxuICAvL1B1c2ggYm9keSBvZiBpbm5lciBsb29wXG4gIGNvZGUucHVzaChib2R5KVxuICAvL0FkdmFuY2Ugc2NhbiBwb2ludGVyc1xuICBmb3IoaT0wOyBpPGRpbWVuc2lvbjsgKytpKSB7XG4gICAgcGlkeCA9IGlkeFxuICAgIGlkeCA9IG9yZGVyW2ldXG4gICAgZm9yKGo9MDsgajxuYXJnczsgKytqKSB7XG4gICAgICBjb2RlLnB1c2goW1wicFwiLGosXCIrPWRcIixqLFwic1wiLGldLmpvaW4oXCJcIikpXG4gICAgfVxuICAgIGlmKGhhc19pbmRleCkge1xuICAgICAgaWYoaSA+IDApIHtcbiAgICAgICAgY29kZS5wdXNoKFtcImluZGV4W1wiLHBpZHgsXCJdLT1zXCIscGlkeF0uam9pbihcIlwiKSlcbiAgICAgIH1cbiAgICAgIGNvZGUucHVzaChbXCIrK2luZGV4W1wiLGlkeCxcIl1cIl0uam9pbihcIlwiKSlcbiAgICB9XG4gICAgY29kZS5wdXNoKFwifVwiKVxuICB9XG4gIHJldHVybiBjb2RlLmpvaW4oXCJcXG5cIilcbn1cblxuLy8gR2VuZXJhdGUgXCJvdXRlclwiIGxvb3BzIHRoYXQgbG9vcCBvdmVyIGJsb2NrcyBvZiBkYXRhLCBhcHBseWluZyBcImlubmVyXCIgbG9vcHMgdG8gdGhlIGJsb2NrcyBieSBtYW5pcHVsYXRpbmcgdGhlIGxvY2FsIHZhcmlhYmxlcyBpbiBzdWNoIGEgd2F5IHRoYXQgdGhlIGlubmVyIGxvb3Agb25seSBcInNlZXNcIiB0aGUgY3VycmVudCBibG9jay5cbi8vIFRPRE86IElmIHRoaXMgaXMgdXNlZCwgdGhlbiB0aGUgcHJldmlvdXMgZGVjbGFyYXRpb24gKGRvbmUgYnkgZ2VuZXJhdGVDd2lzZU9wKSBvZiBzKiBpcyBlc3NlbnRpYWxseSB1bm5lY2Vzc2FyeS5cbi8vICAgICAgIEkgYmVsaWV2ZSB0aGUgcyogYXJlIG5vdCB1c2VkIGVsc2V3aGVyZSAoaW4gcGFydGljdWxhciwgSSBkb24ndCB0aGluayB0aGV5J3JlIHVzZWQgaW4gdGhlIHByZS9wb3N0IHBhcnRzIGFuZCBcInNoYXBlXCIgaXMgZGVmaW5lZCBpbmRlcGVuZGVudGx5KSwgc28gaXQgd291bGQgYmUgcG9zc2libGUgdG8gbWFrZSBkZWZpbmluZyB0aGUgcyogZGVwZW5kZW50IG9uIHdoYXQgbG9vcCBtZXRob2QgaXMgYmVpbmcgdXNlZC5cbmZ1bmN0aW9uIG91dGVyRmlsbChtYXRjaGVkLCBvcmRlciwgcHJvYywgYm9keSkge1xuICB2YXIgZGltZW5zaW9uID0gb3JkZXIubGVuZ3RoXG4gICAgLCBuYXJncyA9IHByb2MuYXJyYXlBcmdzLmxlbmd0aFxuICAgICwgYmxvY2tTaXplID0gcHJvYy5ibG9ja1NpemVcbiAgICAsIGhhc19pbmRleCA9IHByb2MuaW5kZXhBcmdzLmxlbmd0aCA+IDBcbiAgICAsIGNvZGUgPSBbXVxuICBmb3IodmFyIGk9MDsgaTxuYXJnczsgKytpKSB7XG4gICAgY29kZS5wdXNoKFtcInZhciBvZmZzZXRcIixpLFwiPXBcIixpXS5qb2luKFwiXCIpKVxuICB9XG4gIC8vR2VuZXJhdGUgbG9vcHMgZm9yIHVubWF0Y2hlZCBkaW1lbnNpb25zXG4gIC8vIFRoZSBvcmRlciBpbiB3aGljaCB0aGVzZSBkaW1lbnNpb25zIGFyZSB0cmF2ZXJzZWQgaXMgZmFpcmx5IGFyYml0cmFyeSAoZnJvbSBzbWFsbCBzdHJpZGUgdG8gbGFyZ2Ugc3RyaWRlLCBmb3IgdGhlIGZpcnN0IGFyZ3VtZW50KVxuICAvLyBUT0RPOiBJdCB3b3VsZCBiZSBuaWNlIGlmIHRoZSBvcmRlciBpbiB3aGljaCB0aGVzZSBsb29wcyBhcmUgcGxhY2VkIHdvdWxkIGFsc28gYmUgc29tZWhvdyBcIm9wdGltYWxcIiAoYXQgdGhlIHZlcnkgbGVhc3Qgd2Ugc2hvdWxkIGNoZWNrIHRoYXQgaXQgcmVhbGx5IGRvZXNuJ3QgaHVydCB1cyBpZiB0aGV5J3JlIG5vdCkuXG4gIGZvcih2YXIgaT1tYXRjaGVkOyBpPGRpbWVuc2lvbjsgKytpKSB7XG4gICAgY29kZS5wdXNoKFtcImZvcih2YXIgalwiK2krXCI9U1NbXCIsIG9yZGVyW2ldLCBcIl18MDtqXCIsIGksIFwiPjA7KXtcIl0uam9pbihcIlwiKSkgLy8gSXRlcmF0ZSBiYWNrIHRvIGZyb250XG4gICAgY29kZS5wdXNoKFtcImlmKGpcIixpLFwiPFwiLGJsb2NrU2l6ZSxcIil7XCJdLmpvaW4oXCJcIikpIC8vIEVpdGhlciBkZWNyZWFzZSBqIGJ5IGJsb2NrU2l6ZSAocyA9IGJsb2NrU2l6ZSksIG9yIHNldCBpdCB0byB6ZXJvIChhZnRlciBzZXR0aW5nIHMgPSBqKS5cbiAgICBjb2RlLnB1c2goW1wic1wiLG9yZGVyW2ldLFwiPWpcIixpXS5qb2luKFwiXCIpKVxuICAgIGNvZGUucHVzaChbXCJqXCIsaSxcIj0wXCJdLmpvaW4oXCJcIikpXG4gICAgY29kZS5wdXNoKFtcIn1lbHNle3NcIixvcmRlcltpXSxcIj1cIixibG9ja1NpemVdLmpvaW4oXCJcIikpXG4gICAgY29kZS5wdXNoKFtcImpcIixpLFwiLT1cIixibG9ja1NpemUsXCJ9XCJdLmpvaW4oXCJcIikpXG4gICAgaWYoaGFzX2luZGV4KSB7XG4gICAgICBjb2RlLnB1c2goW1wiaW5kZXhbXCIsb3JkZXJbaV0sXCJdPWpcIixpXS5qb2luKFwiXCIpKVxuICAgIH1cbiAgfVxuICBmb3IodmFyIGk9MDsgaTxuYXJnczsgKytpKSB7XG4gICAgdmFyIGluZGV4U3RyID0gW1wib2Zmc2V0XCIraV1cbiAgICBmb3IodmFyIGo9bWF0Y2hlZDsgajxkaW1lbnNpb247ICsraikge1xuICAgICAgaW5kZXhTdHIucHVzaChbXCJqXCIsaixcIip0XCIsaSxcInBcIixvcmRlcltqXV0uam9pbihcIlwiKSlcbiAgICB9XG4gICAgY29kZS5wdXNoKFtcInBcIixpLFwiPShcIixpbmRleFN0ci5qb2luKFwiK1wiKSxcIilcIl0uam9pbihcIlwiKSlcbiAgfVxuICBjb2RlLnB1c2goaW5uZXJGaWxsKG9yZGVyLCBwcm9jLCBib2R5KSlcbiAgZm9yKHZhciBpPW1hdGNoZWQ7IGk8ZGltZW5zaW9uOyArK2kpIHtcbiAgICBjb2RlLnB1c2goXCJ9XCIpXG4gIH1cbiAgcmV0dXJuIGNvZGUuam9pbihcIlxcblwiKVxufVxuXG4vL0NvdW50IHRoZSBudW1iZXIgb2YgY29tcGF0aWJsZSBpbm5lciBvcmRlcnNcbi8vIFRoaXMgaXMgdGhlIGxlbmd0aCBvZiB0aGUgbG9uZ2VzdCBjb21tb24gcHJlZml4IG9mIHRoZSBhcnJheXMgaW4gb3JkZXJzLlxuLy8gRWFjaCBhcnJheSBpbiBvcmRlcnMgbGlzdHMgdGhlIGRpbWVuc2lvbnMgb2YgdGhlIGNvcnJlc3BvbmQgbmRhcnJheSBpbiBvcmRlciBvZiBpbmNyZWFzaW5nIHN0cmlkZS5cbi8vIFRoaXMgaXMgdGh1cyB0aGUgbWF4aW11bSBudW1iZXIgb2YgZGltZW5zaW9ucyB0aGF0IGNhbiBiZSBlZmZpY2llbnRseSB0cmF2ZXJzZWQgYnkgc2ltcGxlIG5lc3RlZCBsb29wcyBmb3IgYWxsIGFycmF5cy5cbmZ1bmN0aW9uIGNvdW50TWF0Y2hlcyhvcmRlcnMpIHtcbiAgdmFyIG1hdGNoZWQgPSAwLCBkaW1lbnNpb24gPSBvcmRlcnNbMF0ubGVuZ3RoXG4gIHdoaWxlKG1hdGNoZWQgPCBkaW1lbnNpb24pIHtcbiAgICBmb3IodmFyIGo9MTsgajxvcmRlcnMubGVuZ3RoOyArK2opIHtcbiAgICAgIGlmKG9yZGVyc1tqXVttYXRjaGVkXSAhPT0gb3JkZXJzWzBdW21hdGNoZWRdKSB7XG4gICAgICAgIHJldHVybiBtYXRjaGVkXG4gICAgICB9XG4gICAgfVxuICAgICsrbWF0Y2hlZFxuICB9XG4gIHJldHVybiBtYXRjaGVkXG59XG5cbi8vUHJvY2Vzc2VzIGEgYmxvY2sgYWNjb3JkaW5nIHRvIHRoZSBnaXZlbiBkYXRhIHR5cGVzXG4vLyBSZXBsYWNlcyB2YXJpYWJsZSBuYW1lcyBieSBkaWZmZXJlbnQgb25lcywgZWl0aGVyIFwibG9jYWxcIiBvbmVzICh0aGF0IGFyZSB0aGVuIGZlcnJpZWQgaW4gYW5kIG91dCBvZiB0aGUgZ2l2ZW4gYXJyYXkpIG9yIG9uZXMgbWF0Y2hpbmcgdGhlIGFyZ3VtZW50cyB0aGF0IHRoZSBmdW5jdGlvbiBwZXJmb3JtaW5nIHRoZSB1bHRpbWF0ZSBsb29wIHdpbGwgYWNjZXB0LlxuZnVuY3Rpb24gcHJvY2Vzc0Jsb2NrKGJsb2NrLCBwcm9jLCBkdHlwZXMpIHtcbiAgdmFyIGNvZGUgPSBibG9jay5ib2R5XG4gIHZhciBwcmUgPSBbXVxuICB2YXIgcG9zdCA9IFtdXG4gIGZvcih2YXIgaT0wOyBpPGJsb2NrLmFyZ3MubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgY2FyZyA9IGJsb2NrLmFyZ3NbaV1cbiAgICBpZihjYXJnLmNvdW50IDw9IDApIHtcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuICAgIHZhciByZSA9IG5ldyBSZWdFeHAoY2FyZy5uYW1lLCBcImdcIilcbiAgICB2YXIgcHRyU3RyID0gXCJcIlxuICAgIHZhciBhcnJOdW0gPSBwcm9jLmFycmF5QXJncy5pbmRleE9mKGkpXG4gICAgc3dpdGNoKHByb2MuYXJnVHlwZXNbaV0pIHtcbiAgICAgIGNhc2UgXCJvZmZzZXRcIjpcbiAgICAgICAgdmFyIG9mZkFyZ0luZGV4ID0gcHJvYy5vZmZzZXRBcmdJbmRleC5pbmRleE9mKGkpXG4gICAgICAgIHZhciBvZmZBcmcgPSBwcm9jLm9mZnNldEFyZ3Nbb2ZmQXJnSW5kZXhdXG4gICAgICAgIGFyck51bSA9IG9mZkFyZy5hcnJheVxuICAgICAgICBwdHJTdHIgPSBcIitxXCIgKyBvZmZBcmdJbmRleCAvLyBBZGRzIG9mZnNldCB0byB0aGUgXCJwb2ludGVyXCIgaW4gdGhlIGFycmF5XG4gICAgICBjYXNlIFwiYXJyYXlcIjpcbiAgICAgICAgcHRyU3RyID0gXCJwXCIgKyBhcnJOdW0gKyBwdHJTdHJcbiAgICAgICAgdmFyIGxvY2FsU3RyID0gXCJsXCIgKyBpXG4gICAgICAgIHZhciBhcnJTdHIgPSBcImFcIiArIGFyck51bVxuICAgICAgICBpZiAocHJvYy5hcnJheUJsb2NrSW5kaWNlc1thcnJOdW1dID09PSAwKSB7IC8vIEFyZ3VtZW50IHRvIGJvZHkgaXMganVzdCBhIHNpbmdsZSB2YWx1ZSBmcm9tIHRoaXMgYXJyYXlcbiAgICAgICAgICBpZihjYXJnLmNvdW50ID09PSAxKSB7IC8vIEFyZ3VtZW50L2FycmF5IHVzZWQgb25seSBvbmNlKD8pXG4gICAgICAgICAgICBpZihkdHlwZXNbYXJyTnVtXSA9PT0gXCJnZW5lcmljXCIpIHtcbiAgICAgICAgICAgICAgaWYoY2FyZy5sdmFsdWUpIHtcbiAgICAgICAgICAgICAgICBwcmUucHVzaChbXCJ2YXIgXCIsIGxvY2FsU3RyLCBcIj1cIiwgYXJyU3RyLCBcIi5nZXQoXCIsIHB0clN0ciwgXCIpXCJdLmpvaW4oXCJcIikpIC8vIElzIHRoaXMgbmVjZXNzYXJ5IGlmIHRoZSBhcmd1bWVudCBpcyBPTkxZIHVzZWQgYXMgYW4gbHZhbHVlPyAoa2VlcCBpbiBtaW5kIHRoYXQgd2UgY2FuIGhhdmUgYSArPSBzb21ldGhpbmcsIHNvIHdlIHdvdWxkIGFjdHVhbGx5IG5lZWQgdG8gY2hlY2sgY2FyZy5ydmFsdWUpXG4gICAgICAgICAgICAgICAgY29kZSA9IGNvZGUucmVwbGFjZShyZSwgbG9jYWxTdHIpXG4gICAgICAgICAgICAgICAgcG9zdC5wdXNoKFthcnJTdHIsIFwiLnNldChcIiwgcHRyU3RyLCBcIixcIiwgbG9jYWxTdHIsXCIpXCJdLmpvaW4oXCJcIikpXG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29kZSA9IGNvZGUucmVwbGFjZShyZSwgW2FyclN0ciwgXCIuZ2V0KFwiLCBwdHJTdHIsIFwiKVwiXS5qb2luKFwiXCIpKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjb2RlID0gY29kZS5yZXBsYWNlKHJlLCBbYXJyU3RyLCBcIltcIiwgcHRyU3RyLCBcIl1cIl0uam9pbihcIlwiKSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYoZHR5cGVzW2Fyck51bV0gPT09IFwiZ2VuZXJpY1wiKSB7XG4gICAgICAgICAgICBwcmUucHVzaChbXCJ2YXIgXCIsIGxvY2FsU3RyLCBcIj1cIiwgYXJyU3RyLCBcIi5nZXQoXCIsIHB0clN0ciwgXCIpXCJdLmpvaW4oXCJcIikpIC8vIFRPRE86IENvdWxkIHdlIG9wdGltaXplIGJ5IGNoZWNraW5nIGZvciBjYXJnLnJ2YWx1ZT9cbiAgICAgICAgICAgIGNvZGUgPSBjb2RlLnJlcGxhY2UocmUsIGxvY2FsU3RyKVxuICAgICAgICAgICAgaWYoY2FyZy5sdmFsdWUpIHtcbiAgICAgICAgICAgICAgcG9zdC5wdXNoKFthcnJTdHIsIFwiLnNldChcIiwgcHRyU3RyLCBcIixcIiwgbG9jYWxTdHIsXCIpXCJdLmpvaW4oXCJcIikpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHByZS5wdXNoKFtcInZhciBcIiwgbG9jYWxTdHIsIFwiPVwiLCBhcnJTdHIsIFwiW1wiLCBwdHJTdHIsIFwiXVwiXS5qb2luKFwiXCIpKSAvLyBUT0RPOiBDb3VsZCB3ZSBvcHRpbWl6ZSBieSBjaGVja2luZyBmb3IgY2FyZy5ydmFsdWU/XG4gICAgICAgICAgICBjb2RlID0gY29kZS5yZXBsYWNlKHJlLCBsb2NhbFN0cilcbiAgICAgICAgICAgIGlmKGNhcmcubHZhbHVlKSB7XG4gICAgICAgICAgICAgIHBvc3QucHVzaChbYXJyU3RyLCBcIltcIiwgcHRyU3RyLCBcIl09XCIsIGxvY2FsU3RyXS5qb2luKFwiXCIpKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHsgLy8gQXJndW1lbnQgdG8gYm9keSBpcyBhIFwiYmxvY2tcIlxuICAgICAgICAgIHZhciByZVN0ckFyciA9IFtjYXJnLm5hbWVdLCBwdHJTdHJBcnIgPSBbcHRyU3RyXVxuICAgICAgICAgIGZvcih2YXIgaj0wOyBqPE1hdGguYWJzKHByb2MuYXJyYXlCbG9ja0luZGljZXNbYXJyTnVtXSk7IGorKykge1xuICAgICAgICAgICAgcmVTdHJBcnIucHVzaChcIlxcXFxzKlxcXFxbKFteXFxcXF1dKylcXFxcXVwiKVxuICAgICAgICAgICAgcHRyU3RyQXJyLnB1c2goXCIkXCIgKyAoaisxKSArIFwiKnRcIiArIGFyck51bSArIFwiYlwiICsgaikgLy8gTWF0Y2hlZCBpbmRleCB0aW1lcyBzdHJpZGVcbiAgICAgICAgICB9XG4gICAgICAgICAgcmUgPSBuZXcgUmVnRXhwKHJlU3RyQXJyLmpvaW4oXCJcIiksIFwiZ1wiKVxuICAgICAgICAgIHB0clN0ciA9IHB0clN0ckFyci5qb2luKFwiK1wiKVxuICAgICAgICAgIGlmKGR0eXBlc1thcnJOdW1dID09PSBcImdlbmVyaWNcIikge1xuICAgICAgICAgICAgLyppZihjYXJnLmx2YWx1ZSkge1xuICAgICAgICAgICAgICBwcmUucHVzaChbXCJ2YXIgXCIsIGxvY2FsU3RyLCBcIj1cIiwgYXJyU3RyLCBcIi5nZXQoXCIsIHB0clN0ciwgXCIpXCJdLmpvaW4oXCJcIikpIC8vIElzIHRoaXMgbmVjZXNzYXJ5IGlmIHRoZSBhcmd1bWVudCBpcyBPTkxZIHVzZWQgYXMgYW4gbHZhbHVlPyAoa2VlcCBpbiBtaW5kIHRoYXQgd2UgY2FuIGhhdmUgYSArPSBzb21ldGhpbmcsIHNvIHdlIHdvdWxkIGFjdHVhbGx5IG5lZWQgdG8gY2hlY2sgY2FyZy5ydmFsdWUpXG4gICAgICAgICAgICAgIGNvZGUgPSBjb2RlLnJlcGxhY2UocmUsIGxvY2FsU3RyKVxuICAgICAgICAgICAgICBwb3N0LnB1c2goW2FyclN0ciwgXCIuc2V0KFwiLCBwdHJTdHIsIFwiLFwiLCBsb2NhbFN0cixcIilcIl0uam9pbihcIlwiKSlcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNvZGUgPSBjb2RlLnJlcGxhY2UocmUsIFthcnJTdHIsIFwiLmdldChcIiwgcHRyU3RyLCBcIilcIl0uam9pbihcIlwiKSlcbiAgICAgICAgICAgIH0qL1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY3dpc2U6IEdlbmVyaWMgYXJyYXlzIG5vdCBzdXBwb3J0ZWQgaW4gY29tYmluYXRpb24gd2l0aCBibG9ja3MhXCIpXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFRoaXMgZG9lcyBub3QgcHJvZHVjZSBhbnkgbG9jYWwgdmFyaWFibGVzLCBldmVuIGlmIHZhcmlhYmxlcyBhcmUgdXNlZCBtdWx0aXBsZSB0aW1lcy4gSXQgd291bGQgYmUgcG9zc2libGUgdG8gZG8gc28sIGJ1dCBpdCB3b3VsZCBjb21wbGljYXRlIHRoaW5ncyBxdWl0ZSBhIGJpdC5cbiAgICAgICAgICAgIGNvZGUgPSBjb2RlLnJlcGxhY2UocmUsIFthcnJTdHIsIFwiW1wiLCBwdHJTdHIsIFwiXVwiXS5qb2luKFwiXCIpKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgYnJlYWtcbiAgICAgIGNhc2UgXCJzY2FsYXJcIjpcbiAgICAgICAgY29kZSA9IGNvZGUucmVwbGFjZShyZSwgXCJZXCIgKyBwcm9jLnNjYWxhckFyZ3MuaW5kZXhPZihpKSlcbiAgICAgIGJyZWFrXG4gICAgICBjYXNlIFwiaW5kZXhcIjpcbiAgICAgICAgY29kZSA9IGNvZGUucmVwbGFjZShyZSwgXCJpbmRleFwiKVxuICAgICAgYnJlYWtcbiAgICAgIGNhc2UgXCJzaGFwZVwiOlxuICAgICAgICBjb2RlID0gY29kZS5yZXBsYWNlKHJlLCBcInNoYXBlXCIpXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuICByZXR1cm4gW3ByZS5qb2luKFwiXFxuXCIpLCBjb2RlLCBwb3N0LmpvaW4oXCJcXG5cIildLmpvaW4oXCJcXG5cIikudHJpbSgpXG59XG5cbmZ1bmN0aW9uIHR5cGVTdW1tYXJ5KGR0eXBlcykge1xuICB2YXIgc3VtbWFyeSA9IG5ldyBBcnJheShkdHlwZXMubGVuZ3RoKVxuICB2YXIgYWxsRXF1YWwgPSB0cnVlXG4gIGZvcih2YXIgaT0wOyBpPGR0eXBlcy5sZW5ndGg7ICsraSkge1xuICAgIHZhciB0ID0gZHR5cGVzW2ldXG4gICAgdmFyIGRpZ2l0cyA9IHQubWF0Y2goL1xcZCsvKVxuICAgIGlmKCFkaWdpdHMpIHtcbiAgICAgIGRpZ2l0cyA9IFwiXCJcbiAgICB9IGVsc2Uge1xuICAgICAgZGlnaXRzID0gZGlnaXRzWzBdXG4gICAgfVxuICAgIGlmKHQuY2hhckF0KDApID09PSAwKSB7XG4gICAgICBzdW1tYXJ5W2ldID0gXCJ1XCIgKyB0LmNoYXJBdCgxKSArIGRpZ2l0c1xuICAgIH0gZWxzZSB7XG4gICAgICBzdW1tYXJ5W2ldID0gdC5jaGFyQXQoMCkgKyBkaWdpdHNcbiAgICB9XG4gICAgaWYoaSA+IDApIHtcbiAgICAgIGFsbEVxdWFsID0gYWxsRXF1YWwgJiYgc3VtbWFyeVtpXSA9PT0gc3VtbWFyeVtpLTFdXG4gICAgfVxuICB9XG4gIGlmKGFsbEVxdWFsKSB7XG4gICAgcmV0dXJuIHN1bW1hcnlbMF1cbiAgfVxuICByZXR1cm4gc3VtbWFyeS5qb2luKFwiXCIpXG59XG5cbi8vR2VuZXJhdGVzIGEgY3dpc2Ugb3BlcmF0b3JcbmZ1bmN0aW9uIGdlbmVyYXRlQ1dpc2VPcChwcm9jLCB0eXBlc2lnKSB7XG5cbiAgLy9Db21wdXRlIGRpbWVuc2lvblxuICAvLyBBcnJheXMgZ2V0IHB1dCBmaXJzdCBpbiB0eXBlc2lnLCBhbmQgdGhlcmUgYXJlIHR3byBlbnRyaWVzIHBlciBhcnJheSAoZHR5cGUgYW5kIG9yZGVyKSwgc28gdGhpcyBnZXRzIHRoZSBudW1iZXIgb2YgZGltZW5zaW9ucyBpbiB0aGUgZmlyc3QgYXJyYXkgYXJnLlxuICB2YXIgZGltZW5zaW9uID0gKHR5cGVzaWdbMV0ubGVuZ3RoIC0gTWF0aC5hYnMocHJvYy5hcnJheUJsb2NrSW5kaWNlc1swXSkpfDBcbiAgdmFyIG9yZGVycyA9IG5ldyBBcnJheShwcm9jLmFycmF5QXJncy5sZW5ndGgpXG4gIHZhciBkdHlwZXMgPSBuZXcgQXJyYXkocHJvYy5hcnJheUFyZ3MubGVuZ3RoKVxuICBmb3IodmFyIGk9MDsgaTxwcm9jLmFycmF5QXJncy5sZW5ndGg7ICsraSkge1xuICAgIGR0eXBlc1tpXSA9IHR5cGVzaWdbMippXVxuICAgIG9yZGVyc1tpXSA9IHR5cGVzaWdbMippKzFdXG4gIH1cbiAgXG4gIC8vRGV0ZXJtaW5lIHdoZXJlIGJsb2NrIGFuZCBsb29wIGluZGljZXMgc3RhcnQgYW5kIGVuZFxuICB2YXIgYmxvY2tCZWdpbiA9IFtdLCBibG9ja0VuZCA9IFtdIC8vIFRoZXNlIGluZGljZXMgYXJlIGV4cG9zZWQgYXMgYmxvY2tzXG4gIHZhciBsb29wQmVnaW4gPSBbXSwgbG9vcEVuZCA9IFtdIC8vIFRoZXNlIGluZGljZXMgYXJlIGl0ZXJhdGVkIG92ZXJcbiAgdmFyIGxvb3BPcmRlcnMgPSBbXSAvLyBvcmRlcnMgcmVzdHJpY3RlZCB0byB0aGUgbG9vcCBpbmRpY2VzXG4gIGZvcih2YXIgaT0wOyBpPHByb2MuYXJyYXlBcmdzLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKHByb2MuYXJyYXlCbG9ja0luZGljZXNbaV08MCkge1xuICAgICAgbG9vcEJlZ2luLnB1c2goMClcbiAgICAgIGxvb3BFbmQucHVzaChkaW1lbnNpb24pXG4gICAgICBibG9ja0JlZ2luLnB1c2goZGltZW5zaW9uKVxuICAgICAgYmxvY2tFbmQucHVzaChkaW1lbnNpb24rcHJvYy5hcnJheUJsb2NrSW5kaWNlc1tpXSlcbiAgICB9IGVsc2Uge1xuICAgICAgbG9vcEJlZ2luLnB1c2gocHJvYy5hcnJheUJsb2NrSW5kaWNlc1tpXSkgLy8gTm9uLW5lZ2F0aXZlXG4gICAgICBsb29wRW5kLnB1c2gocHJvYy5hcnJheUJsb2NrSW5kaWNlc1tpXStkaW1lbnNpb24pXG4gICAgICBibG9ja0JlZ2luLnB1c2goMClcbiAgICAgIGJsb2NrRW5kLnB1c2gocHJvYy5hcnJheUJsb2NrSW5kaWNlc1tpXSlcbiAgICB9XG4gICAgdmFyIG5ld09yZGVyID0gW11cbiAgICBmb3IodmFyIGo9MDsgajxvcmRlcnNbaV0ubGVuZ3RoOyBqKyspIHtcbiAgICAgIGlmIChsb29wQmVnaW5baV08PW9yZGVyc1tpXVtqXSAmJiBvcmRlcnNbaV1bal08bG9vcEVuZFtpXSkge1xuICAgICAgICBuZXdPcmRlci5wdXNoKG9yZGVyc1tpXVtqXS1sb29wQmVnaW5baV0pIC8vIElmIHRoaXMgaXMgYSBsb29wIGluZGV4LCBwdXQgaXQgaW4gbmV3T3JkZXIsIHN1YnRyYWN0aW5nIGxvb3BCZWdpbiwgdG8gbWFrZSBzdXJlIHRoYXQgYWxsIGxvb3BPcmRlcnMgYXJlIHVzaW5nIGEgY29tbW9uIHNldCBvZiBpbmRpY2VzLlxuICAgICAgfVxuICAgIH1cbiAgICBsb29wT3JkZXJzLnB1c2gobmV3T3JkZXIpXG4gIH1cblxuICAvL0ZpcnN0IGNyZWF0ZSBhcmd1bWVudHMgZm9yIHByb2NlZHVyZVxuICB2YXIgYXJnbGlzdCA9IFtcIlNTXCJdIC8vIFNTIGlzIHRoZSBvdmVyYWxsIHNoYXBlIG92ZXIgd2hpY2ggd2UgaXRlcmF0ZVxuICB2YXIgY29kZSA9IFtcIid1c2Ugc3RyaWN0J1wiXVxuICB2YXIgdmFycyA9IFtdXG4gIFxuICBmb3IodmFyIGo9MDsgajxkaW1lbnNpb247ICsraikge1xuICAgIHZhcnMucHVzaChbXCJzXCIsIGosIFwiPVNTW1wiLCBqLCBcIl1cIl0uam9pbihcIlwiKSkgLy8gVGhlIGxpbWl0cyBmb3IgZWFjaCBkaW1lbnNpb24uXG4gIH1cbiAgZm9yKHZhciBpPTA7IGk8cHJvYy5hcnJheUFyZ3MubGVuZ3RoOyArK2kpIHtcbiAgICBhcmdsaXN0LnB1c2goXCJhXCIraSkgLy8gQWN0dWFsIGRhdGEgYXJyYXlcbiAgICBhcmdsaXN0LnB1c2goXCJ0XCIraSkgLy8gU3RyaWRlc1xuICAgIGFyZ2xpc3QucHVzaChcInBcIitpKSAvLyBPZmZzZXQgaW4gdGhlIGFycmF5IGF0IHdoaWNoIHRoZSBkYXRhIHN0YXJ0cyAoYWxzbyB1c2VkIGZvciBpdGVyYXRpbmcgb3ZlciB0aGUgZGF0YSlcbiAgICBcbiAgICBmb3IodmFyIGo9MDsgajxkaW1lbnNpb247ICsraikgeyAvLyBVbnBhY2sgdGhlIHN0cmlkZXMgaW50byB2YXJzIGZvciBsb29waW5nXG4gICAgICB2YXJzLnB1c2goW1widFwiLGksXCJwXCIsaixcIj10XCIsaSxcIltcIixsb29wQmVnaW5baV0raixcIl1cIl0uam9pbihcIlwiKSlcbiAgICB9XG4gICAgXG4gICAgZm9yKHZhciBqPTA7IGo8TWF0aC5hYnMocHJvYy5hcnJheUJsb2NrSW5kaWNlc1tpXSk7ICsraikgeyAvLyBVbnBhY2sgdGhlIHN0cmlkZXMgaW50byB2YXJzIGZvciBibG9jayBpdGVyYXRpb25cbiAgICAgIHZhcnMucHVzaChbXCJ0XCIsaSxcImJcIixqLFwiPXRcIixpLFwiW1wiLGJsb2NrQmVnaW5baV0raixcIl1cIl0uam9pbihcIlwiKSlcbiAgICB9XG4gIH1cbiAgZm9yKHZhciBpPTA7IGk8cHJvYy5zY2FsYXJBcmdzLmxlbmd0aDsgKytpKSB7XG4gICAgYXJnbGlzdC5wdXNoKFwiWVwiICsgaSlcbiAgfVxuICBpZihwcm9jLnNoYXBlQXJncy5sZW5ndGggPiAwKSB7XG4gICAgdmFycy5wdXNoKFwic2hhcGU9U1Muc2xpY2UoMClcIikgLy8gTWFrZXMgdGhlIHNoYXBlIG92ZXIgd2hpY2ggd2UgaXRlcmF0ZSBhdmFpbGFibGUgdG8gdGhlIHVzZXIgZGVmaW5lZCBmdW5jdGlvbnMgKHNvIHlvdSBjYW4gdXNlIHdpZHRoL2hlaWdodCBmb3IgZXhhbXBsZSlcbiAgfVxuICBpZihwcm9jLmluZGV4QXJncy5sZW5ndGggPiAwKSB7XG4gICAgLy8gUHJlcGFyZSBhbiBhcnJheSB0byBrZWVwIHRyYWNrIG9mIHRoZSAobG9naWNhbCkgaW5kaWNlcywgaW5pdGlhbGl6ZWQgdG8gZGltZW5zaW9uIHplcm9lcy5cbiAgICB2YXIgemVyb3MgPSBuZXcgQXJyYXkoZGltZW5zaW9uKVxuICAgIGZvcih2YXIgaT0wOyBpPGRpbWVuc2lvbjsgKytpKSB7XG4gICAgICB6ZXJvc1tpXSA9IFwiMFwiXG4gICAgfVxuICAgIHZhcnMucHVzaChbXCJpbmRleD1bXCIsIHplcm9zLmpvaW4oXCIsXCIpLCBcIl1cIl0uam9pbihcIlwiKSlcbiAgfVxuICBmb3IodmFyIGk9MDsgaTxwcm9jLm9mZnNldEFyZ3MubGVuZ3RoOyArK2kpIHsgLy8gT2Zmc2V0IGFyZ3VtZW50cyB1c2VkIGZvciBzdGVuY2lsIG9wZXJhdGlvbnNcbiAgICB2YXIgb2ZmX2FyZyA9IHByb2Mub2Zmc2V0QXJnc1tpXVxuICAgIHZhciBpbml0X3N0cmluZyA9IFtdXG4gICAgZm9yKHZhciBqPTA7IGo8b2ZmX2FyZy5vZmZzZXQubGVuZ3RoOyArK2opIHtcbiAgICAgIGlmKG9mZl9hcmcub2Zmc2V0W2pdID09PSAwKSB7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9IGVsc2UgaWYob2ZmX2FyZy5vZmZzZXRbal0gPT09IDEpIHtcbiAgICAgICAgaW5pdF9zdHJpbmcucHVzaChbXCJ0XCIsIG9mZl9hcmcuYXJyYXksIFwicFwiLCBqXS5qb2luKFwiXCIpKSAgICAgIFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5pdF9zdHJpbmcucHVzaChbb2ZmX2FyZy5vZmZzZXRbal0sIFwiKnRcIiwgb2ZmX2FyZy5hcnJheSwgXCJwXCIsIGpdLmpvaW4oXCJcIikpXG4gICAgICB9XG4gICAgfVxuICAgIGlmKGluaXRfc3RyaW5nLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdmFycy5wdXNoKFwicVwiICsgaSArIFwiPTBcIilcbiAgICB9IGVsc2Uge1xuICAgICAgdmFycy5wdXNoKFtcInFcIiwgaSwgXCI9XCIsIGluaXRfc3RyaW5nLmpvaW4oXCIrXCIpXS5qb2luKFwiXCIpKVxuICAgIH1cbiAgfVxuXG4gIC8vUHJlcGFyZSB0aGlzIHZhcmlhYmxlc1xuICB2YXIgdGhpc1ZhcnMgPSB1bmlxKFtdLmNvbmNhdChwcm9jLnByZS50aGlzVmFycylcbiAgICAgICAgICAgICAgICAgICAgICAuY29uY2F0KHByb2MuYm9keS50aGlzVmFycylcbiAgICAgICAgICAgICAgICAgICAgICAuY29uY2F0KHByb2MucG9zdC50aGlzVmFycykpXG4gIHZhcnMgPSB2YXJzLmNvbmNhdCh0aGlzVmFycylcbiAgaWYgKHZhcnMubGVuZ3RoID4gMCkge1xuICAgIGNvZGUucHVzaChcInZhciBcIiArIHZhcnMuam9pbihcIixcIikpXG4gIH1cbiAgZm9yKHZhciBpPTA7IGk8cHJvYy5hcnJheUFyZ3MubGVuZ3RoOyArK2kpIHtcbiAgICBjb2RlLnB1c2goXCJwXCIraStcInw9MFwiKVxuICB9XG4gIFxuICAvL0lubGluZSBwcmVsdWRlXG4gIGlmKHByb2MucHJlLmJvZHkubGVuZ3RoID4gMykge1xuICAgIGNvZGUucHVzaChwcm9jZXNzQmxvY2socHJvYy5wcmUsIHByb2MsIGR0eXBlcykpXG4gIH1cblxuICAvL1Byb2Nlc3MgYm9keVxuICB2YXIgYm9keSA9IHByb2Nlc3NCbG9jayhwcm9jLmJvZHksIHByb2MsIGR0eXBlcylcbiAgdmFyIG1hdGNoZWQgPSBjb3VudE1hdGNoZXMobG9vcE9yZGVycylcbiAgaWYobWF0Y2hlZCA8IGRpbWVuc2lvbikge1xuICAgIGNvZGUucHVzaChvdXRlckZpbGwobWF0Y2hlZCwgbG9vcE9yZGVyc1swXSwgcHJvYywgYm9keSkpIC8vIFRPRE86IFJhdGhlciB0aGFuIHBhc3NpbmcgbG9vcE9yZGVyc1swXSwgaXQgbWlnaHQgYmUgaW50ZXJlc3RpbmcgdG8gbG9vayBhdCBwYXNzaW5nIGFuIG9yZGVyIHRoYXQgcmVwcmVzZW50cyB0aGUgbWFqb3JpdHkgb2YgdGhlIGFyZ3VtZW50cyBmb3IgZXhhbXBsZS5cbiAgfSBlbHNlIHtcbiAgICBjb2RlLnB1c2goaW5uZXJGaWxsKGxvb3BPcmRlcnNbMF0sIHByb2MsIGJvZHkpKVxuICB9XG5cbiAgLy9JbmxpbmUgZXBpbG9nXG4gIGlmKHByb2MucG9zdC5ib2R5Lmxlbmd0aCA+IDMpIHtcbiAgICBjb2RlLnB1c2gocHJvY2Vzc0Jsb2NrKHByb2MucG9zdCwgcHJvYywgZHR5cGVzKSlcbiAgfVxuICBcbiAgaWYocHJvYy5kZWJ1Zykge1xuICAgIGNvbnNvbGUubG9nKFwiLS0tLS1HZW5lcmF0ZWQgY3dpc2Ugcm91dGluZSBmb3IgXCIsIHR5cGVzaWcsIFwiOlxcblwiICsgY29kZS5qb2luKFwiXFxuXCIpICsgXCJcXG4tLS0tLS0tLS0tXCIpXG4gIH1cbiAgXG4gIHZhciBsb29wTmFtZSA9IFsocHJvYy5mdW5jTmFtZXx8XCJ1bm5hbWVkXCIpLCBcIl9jd2lzZV9sb29wX1wiLCBvcmRlcnNbMF0uam9pbihcInNcIiksXCJtXCIsbWF0Y2hlZCx0eXBlU3VtbWFyeShkdHlwZXMpXS5qb2luKFwiXCIpXG4gIHZhciBmID0gbmV3IEZ1bmN0aW9uKFtcImZ1bmN0aW9uIFwiLGxvb3BOYW1lLFwiKFwiLCBhcmdsaXN0LmpvaW4oXCIsXCIpLFwiKXtcIiwgY29kZS5qb2luKFwiXFxuXCIpLFwifSByZXR1cm4gXCIsIGxvb3BOYW1lXS5qb2luKFwiXCIpKVxuICByZXR1cm4gZigpXG59XG5tb2R1bGUuZXhwb3J0cyA9IGdlbmVyYXRlQ1dpc2VPcFxuIiwiXCJ1c2Ugc3RyaWN0XCJcblxuLy8gVGhlIGZ1bmN0aW9uIGJlbG93IGlzIGNhbGxlZCB3aGVuIGNvbnN0cnVjdGluZyBhIGN3aXNlIGZ1bmN0aW9uIG9iamVjdCwgYW5kIGRvZXMgdGhlIGZvbGxvd2luZzpcbi8vIEEgZnVuY3Rpb24gb2JqZWN0IGlzIGNvbnN0cnVjdGVkIHdoaWNoIGFjY2VwdHMgYXMgYXJndW1lbnQgYSBjb21waWxhdGlvbiBmdW5jdGlvbiBhbmQgcmV0dXJucyBhbm90aGVyIGZ1bmN0aW9uLlxuLy8gSXQgaXMgdGhpcyBvdGhlciBmdW5jdGlvbiB0aGF0IGlzIGV2ZW50dWFsbHkgcmV0dXJuZWQgYnkgY3JlYXRlVGh1bmssIGFuZCB0aGlzIGZ1bmN0aW9uIGlzIHRoZSBvbmUgdGhhdCBhY3R1YWxseVxuLy8gY2hlY2tzIHdoZXRoZXIgYSBjZXJ0YWluIHBhdHRlcm4gb2YgYXJndW1lbnRzIGhhcyBhbHJlYWR5IGJlZW4gdXNlZCBiZWZvcmUgYW5kIGNvbXBpbGVzIG5ldyBsb29wcyBhcyBuZWVkZWQuXG4vLyBUaGUgY29tcGlsYXRpb24gcGFzc2VkIHRvIHRoZSBmaXJzdCBmdW5jdGlvbiBvYmplY3QgaXMgdXNlZCBmb3IgY29tcGlsaW5nIG5ldyBmdW5jdGlvbnMuXG4vLyBPbmNlIHRoaXMgZnVuY3Rpb24gb2JqZWN0IGlzIGNyZWF0ZWQsIGl0IGlzIGNhbGxlZCB3aXRoIGNvbXBpbGUgYXMgYXJndW1lbnQsIHdoZXJlIHRoZSBmaXJzdCBhcmd1bWVudCBvZiBjb21waWxlXG4vLyBpcyBib3VuZCB0byBcInByb2NcIiAoZXNzZW50aWFsbHkgY29udGFpbmluZyBhIHByZXByb2Nlc3NlZCB2ZXJzaW9uIG9mIHRoZSB1c2VyIGFyZ3VtZW50cyB0byBjd2lzZSkuXG4vLyBTbyBjcmVhdGVUaHVuayByb3VnaGx5IHdvcmtzIGxpa2UgdGhpczpcbi8vIGZ1bmN0aW9uIGNyZWF0ZVRodW5rKHByb2MpIHtcbi8vICAgdmFyIHRodW5rID0gZnVuY3Rpb24oY29tcGlsZUJvdW5kKSB7XG4vLyAgICAgdmFyIENBQ0hFRCA9IHt9XG4vLyAgICAgcmV0dXJuIGZ1bmN0aW9uKGFycmF5cyBhbmQgc2NhbGFycykge1xuLy8gICAgICAgaWYgKGR0eXBlIGFuZCBvcmRlciBvZiBhcnJheXMgaW4gQ0FDSEVEKSB7XG4vLyAgICAgICAgIHZhciBmdW5jID0gQ0FDSEVEW2R0eXBlIGFuZCBvcmRlciBvZiBhcnJheXNdXG4vLyAgICAgICB9IGVsc2Uge1xuLy8gICAgICAgICB2YXIgZnVuYyA9IENBQ0hFRFtkdHlwZSBhbmQgb3JkZXIgb2YgYXJyYXlzXSA9IGNvbXBpbGVCb3VuZChkdHlwZSBhbmQgb3JkZXIgb2YgYXJyYXlzKVxuLy8gICAgICAgfVxuLy8gICAgICAgcmV0dXJuIGZ1bmMoYXJyYXlzIGFuZCBzY2FsYXJzKVxuLy8gICAgIH1cbi8vICAgfVxuLy8gICByZXR1cm4gdGh1bmsoY29tcGlsZS5iaW5kMShwcm9jKSlcbi8vIH1cblxudmFyIGNvbXBpbGUgPSByZXF1aXJlKFwiLi9jb21waWxlLmpzXCIpXG5cbmZ1bmN0aW9uIGNyZWF0ZVRodW5rKHByb2MpIHtcbiAgdmFyIGNvZGUgPSBbXCIndXNlIHN0cmljdCdcIiwgXCJ2YXIgQ0FDSEVEPXt9XCJdXG4gIHZhciB2YXJzID0gW11cbiAgdmFyIHRodW5rTmFtZSA9IHByb2MuZnVuY05hbWUgKyBcIl9jd2lzZV90aHVua1wiXG4gIFxuICAvL0J1aWxkIHRodW5rXG4gIGNvZGUucHVzaChbXCJyZXR1cm4gZnVuY3Rpb24gXCIsIHRodW5rTmFtZSwgXCIoXCIsIHByb2Muc2hpbUFyZ3Muam9pbihcIixcIiksIFwiKXtcIl0uam9pbihcIlwiKSlcbiAgdmFyIHR5cGVzaWcgPSBbXVxuICB2YXIgc3RyaW5nX3R5cGVzaWcgPSBbXVxuICB2YXIgcHJvY19hcmdzID0gW1tcImFycmF5XCIscHJvYy5hcnJheUFyZ3NbMF0sXCIuc2hhcGUuc2xpY2UoXCIsIC8vIFNsaWNlIHNoYXBlIHNvIHRoYXQgd2Ugb25seSByZXRhaW4gdGhlIHNoYXBlIG92ZXIgd2hpY2ggd2UgaXRlcmF0ZSAod2hpY2ggZ2V0cyBwYXNzZWQgdG8gdGhlIGN3aXNlIG9wZXJhdG9yIGFzIFNTKS5cbiAgICAgICAgICAgICAgICAgICAgTWF0aC5tYXgoMCxwcm9jLmFycmF5QmxvY2tJbmRpY2VzWzBdKSxwcm9jLmFycmF5QmxvY2tJbmRpY2VzWzBdPDA/KFwiLFwiK3Byb2MuYXJyYXlCbG9ja0luZGljZXNbMF0rXCIpXCIpOlwiKVwiXS5qb2luKFwiXCIpXVxuICB2YXIgc2hhcGVMZW5ndGhDb25kaXRpb25zID0gW10sIHNoYXBlQ29uZGl0aW9ucyA9IFtdXG4gIC8vIFByb2Nlc3MgYXJyYXkgYXJndW1lbnRzXG4gIGZvcih2YXIgaT0wOyBpPHByb2MuYXJyYXlBcmdzLmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGogPSBwcm9jLmFycmF5QXJnc1tpXVxuICAgIHZhcnMucHVzaChbXCJ0XCIsIGosIFwiPWFycmF5XCIsIGosIFwiLmR0eXBlLFwiLFxuICAgICAgICAgICAgICAgXCJyXCIsIGosIFwiPWFycmF5XCIsIGosIFwiLm9yZGVyXCJdLmpvaW4oXCJcIikpXG4gICAgdHlwZXNpZy5wdXNoKFwidFwiICsgailcbiAgICB0eXBlc2lnLnB1c2goXCJyXCIgKyBqKVxuICAgIHN0cmluZ190eXBlc2lnLnB1c2goXCJ0XCIrailcbiAgICBzdHJpbmdfdHlwZXNpZy5wdXNoKFwiclwiK2orXCIuam9pbigpXCIpXG4gICAgcHJvY19hcmdzLnB1c2goXCJhcnJheVwiICsgaiArIFwiLmRhdGFcIilcbiAgICBwcm9jX2FyZ3MucHVzaChcImFycmF5XCIgKyBqICsgXCIuc3RyaWRlXCIpXG4gICAgcHJvY19hcmdzLnB1c2goXCJhcnJheVwiICsgaiArIFwiLm9mZnNldHwwXCIpXG4gICAgaWYgKGk+MCkgeyAvLyBHYXRoZXIgY29uZGl0aW9ucyB0byBjaGVjayBmb3Igc2hhcGUgZXF1YWxpdHkgKGlnbm9yaW5nIGJsb2NrIGluZGljZXMpXG4gICAgICBzaGFwZUxlbmd0aENvbmRpdGlvbnMucHVzaChcImFycmF5XCIgKyBwcm9jLmFycmF5QXJnc1swXSArIFwiLnNoYXBlLmxlbmd0aD09PWFycmF5XCIgKyBqICsgXCIuc2hhcGUubGVuZ3RoK1wiICsgKE1hdGguYWJzKHByb2MuYXJyYXlCbG9ja0luZGljZXNbMF0pLU1hdGguYWJzKHByb2MuYXJyYXlCbG9ja0luZGljZXNbaV0pKSlcbiAgICAgIHNoYXBlQ29uZGl0aW9ucy5wdXNoKFwiYXJyYXlcIiArIHByb2MuYXJyYXlBcmdzWzBdICsgXCIuc2hhcGVbc2hhcGVJbmRleCtcIiArIE1hdGgubWF4KDAscHJvYy5hcnJheUJsb2NrSW5kaWNlc1swXSkgKyBcIl09PT1hcnJheVwiICsgaiArIFwiLnNoYXBlW3NoYXBlSW5kZXgrXCIgKyBNYXRoLm1heCgwLHByb2MuYXJyYXlCbG9ja0luZGljZXNbaV0pICsgXCJdXCIpXG4gICAgfVxuICB9XG4gIC8vIENoZWNrIGZvciBzaGFwZSBlcXVhbGl0eVxuICBpZiAocHJvYy5hcnJheUFyZ3MubGVuZ3RoID4gMSkge1xuICAgIGNvZGUucHVzaChcImlmICghKFwiICsgc2hhcGVMZW5ndGhDb25kaXRpb25zLmpvaW4oXCIgJiYgXCIpICsgXCIpKSB0aHJvdyBuZXcgRXJyb3IoJ2N3aXNlOiBBcnJheXMgZG8gbm90IGFsbCBoYXZlIHRoZSBzYW1lIGRpbWVuc2lvbmFsaXR5IScpXCIpXG4gICAgY29kZS5wdXNoKFwiZm9yKHZhciBzaGFwZUluZGV4PWFycmF5XCIgKyBwcm9jLmFycmF5QXJnc1swXSArIFwiLnNoYXBlLmxlbmd0aC1cIiArIE1hdGguYWJzKHByb2MuYXJyYXlCbG9ja0luZGljZXNbMF0pICsgXCI7IHNoYXBlSW5kZXgtLT4wOykge1wiKVxuICAgIGNvZGUucHVzaChcImlmICghKFwiICsgc2hhcGVDb25kaXRpb25zLmpvaW4oXCIgJiYgXCIpICsgXCIpKSB0aHJvdyBuZXcgRXJyb3IoJ2N3aXNlOiBBcnJheXMgZG8gbm90IGFsbCBoYXZlIHRoZSBzYW1lIHNoYXBlIScpXCIpXG4gICAgY29kZS5wdXNoKFwifVwiKVxuICB9XG4gIC8vIFByb2Nlc3Mgc2NhbGFyIGFyZ3VtZW50c1xuICBmb3IodmFyIGk9MDsgaTxwcm9jLnNjYWxhckFyZ3MubGVuZ3RoOyArK2kpIHtcbiAgICBwcm9jX2FyZ3MucHVzaChcInNjYWxhclwiICsgcHJvYy5zY2FsYXJBcmdzW2ldKVxuICB9XG4gIC8vIENoZWNrIGZvciBjYWNoZWQgZnVuY3Rpb24gKGFuZCBpZiBub3QgcHJlc2VudCwgZ2VuZXJhdGUgaXQpXG4gIHZhcnMucHVzaChbXCJ0eXBlPVtcIiwgc3RyaW5nX3R5cGVzaWcuam9pbihcIixcIiksIFwiXS5qb2luKClcIl0uam9pbihcIlwiKSlcbiAgdmFycy5wdXNoKFwicHJvYz1DQUNIRURbdHlwZV1cIilcbiAgY29kZS5wdXNoKFwidmFyIFwiICsgdmFycy5qb2luKFwiLFwiKSlcbiAgXG4gIGNvZGUucHVzaChbXCJpZighcHJvYyl7XCIsXG4gICAgICAgICAgICAgXCJDQUNIRURbdHlwZV09cHJvYz1jb21waWxlKFtcIiwgdHlwZXNpZy5qb2luKFwiLFwiKSwgXCJdKX1cIixcbiAgICAgICAgICAgICBcInJldHVybiBwcm9jKFwiLCBwcm9jX2FyZ3Muam9pbihcIixcIiksIFwiKX1cIl0uam9pbihcIlwiKSlcblxuICBpZihwcm9jLmRlYnVnKSB7XG4gICAgY29uc29sZS5sb2coXCItLS0tLUdlbmVyYXRlZCB0aHVuazpcXG5cIiArIGNvZGUuam9pbihcIlxcblwiKSArIFwiXFxuLS0tLS0tLS0tLVwiKVxuICB9XG4gIFxuICAvL0NvbXBpbGUgdGh1bmtcbiAgdmFyIHRodW5rID0gbmV3IEZ1bmN0aW9uKFwiY29tcGlsZVwiLCBjb2RlLmpvaW4oXCJcXG5cIikpXG4gIHJldHVybiB0aHVuayhjb21waWxlLmJpbmQodW5kZWZpbmVkLCBwcm9jKSlcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVUaHVua1xuIiwidmFyIGhhc1R5cGVkQXJyYXlzID0gZmFsc2VcbmlmKHR5cGVvZiBGbG9hdDY0QXJyYXkgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgdmFyIERPVUJMRV9WSUVXID0gbmV3IEZsb2F0NjRBcnJheSgxKVxuICAgICwgVUlOVF9WSUVXICAgPSBuZXcgVWludDMyQXJyYXkoRE9VQkxFX1ZJRVcuYnVmZmVyKVxuICBET1VCTEVfVklFV1swXSA9IDEuMFxuICBoYXNUeXBlZEFycmF5cyA9IHRydWVcbiAgaWYoVUlOVF9WSUVXWzFdID09PSAweDNmZjAwMDAwKSB7XG4gICAgLy9Vc2UgbGl0dGxlIGVuZGlhblxuICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZG91YmxlQml0c0xFKG4pIHtcbiAgICAgIERPVUJMRV9WSUVXWzBdID0gblxuICAgICAgcmV0dXJuIFsgVUlOVF9WSUVXWzBdLCBVSU5UX1ZJRVdbMV0gXVxuICAgIH1cbiAgICBmdW5jdGlvbiB0b0RvdWJsZUxFKGxvLCBoaSkge1xuICAgICAgVUlOVF9WSUVXWzBdID0gbG9cbiAgICAgIFVJTlRfVklFV1sxXSA9IGhpXG4gICAgICByZXR1cm4gRE9VQkxFX1ZJRVdbMF1cbiAgICB9XG4gICAgbW9kdWxlLmV4cG9ydHMucGFjayA9IHRvRG91YmxlTEVcbiAgICBmdW5jdGlvbiBsb3dVaW50TEUobikge1xuICAgICAgRE9VQkxFX1ZJRVdbMF0gPSBuXG4gICAgICByZXR1cm4gVUlOVF9WSUVXWzBdXG4gICAgfVxuICAgIG1vZHVsZS5leHBvcnRzLmxvID0gbG93VWludExFXG4gICAgZnVuY3Rpb24gaGlnaFVpbnRMRShuKSB7XG4gICAgICBET1VCTEVfVklFV1swXSA9IG5cbiAgICAgIHJldHVybiBVSU5UX1ZJRVdbMV1cbiAgICB9XG4gICAgbW9kdWxlLmV4cG9ydHMuaGkgPSBoaWdoVWludExFXG4gIH0gZWxzZSBpZihVSU5UX1ZJRVdbMF0gPT09IDB4M2ZmMDAwMDApIHtcbiAgICAvL1VzZSBiaWcgZW5kaWFuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBkb3VibGVCaXRzQkUobikge1xuICAgICAgRE9VQkxFX1ZJRVdbMF0gPSBuXG4gICAgICByZXR1cm4gWyBVSU5UX1ZJRVdbMV0sIFVJTlRfVklFV1swXSBdXG4gICAgfVxuICAgIGZ1bmN0aW9uIHRvRG91YmxlQkUobG8sIGhpKSB7XG4gICAgICBVSU5UX1ZJRVdbMV0gPSBsb1xuICAgICAgVUlOVF9WSUVXWzBdID0gaGlcbiAgICAgIHJldHVybiBET1VCTEVfVklFV1swXVxuICAgIH1cbiAgICBtb2R1bGUuZXhwb3J0cy5wYWNrID0gdG9Eb3VibGVCRVxuICAgIGZ1bmN0aW9uIGxvd1VpbnRCRShuKSB7XG4gICAgICBET1VCTEVfVklFV1swXSA9IG5cbiAgICAgIHJldHVybiBVSU5UX1ZJRVdbMV1cbiAgICB9XG4gICAgbW9kdWxlLmV4cG9ydHMubG8gPSBsb3dVaW50QkVcbiAgICBmdW5jdGlvbiBoaWdoVWludEJFKG4pIHtcbiAgICAgIERPVUJMRV9WSUVXWzBdID0gblxuICAgICAgcmV0dXJuIFVJTlRfVklFV1swXVxuICAgIH1cbiAgICBtb2R1bGUuZXhwb3J0cy5oaSA9IGhpZ2hVaW50QkVcbiAgfSBlbHNlIHtcbiAgICBoYXNUeXBlZEFycmF5cyA9IGZhbHNlXG4gIH1cbn1cbmlmKCFoYXNUeXBlZEFycmF5cykge1xuICB2YXIgYnVmZmVyID0gbmV3IEJ1ZmZlcig4KVxuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGRvdWJsZUJpdHMobikge1xuICAgIGJ1ZmZlci53cml0ZURvdWJsZUxFKG4sIDAsIHRydWUpXG4gICAgcmV0dXJuIFsgYnVmZmVyLnJlYWRVSW50MzJMRSgwLCB0cnVlKSwgYnVmZmVyLnJlYWRVSW50MzJMRSg0LCB0cnVlKSBdXG4gIH1cbiAgZnVuY3Rpb24gdG9Eb3VibGUobG8sIGhpKSB7XG4gICAgYnVmZmVyLndyaXRlVUludDMyTEUobG8sIDAsIHRydWUpXG4gICAgYnVmZmVyLndyaXRlVUludDMyTEUoaGksIDQsIHRydWUpXG4gICAgcmV0dXJuIGJ1ZmZlci5yZWFkRG91YmxlTEUoMCwgdHJ1ZSlcbiAgfVxuICBtb2R1bGUuZXhwb3J0cy5wYWNrID0gdG9Eb3VibGUgIFxuICBmdW5jdGlvbiBsb3dVaW50KG4pIHtcbiAgICBidWZmZXIud3JpdGVEb3VibGVMRShuLCAwLCB0cnVlKVxuICAgIHJldHVybiBidWZmZXIucmVhZFVJbnQzMkxFKDAsIHRydWUpXG4gIH1cbiAgbW9kdWxlLmV4cG9ydHMubG8gPSBsb3dVaW50XG4gIGZ1bmN0aW9uIGhpZ2hVaW50KG4pIHtcbiAgICBidWZmZXIud3JpdGVEb3VibGVMRShuLCAwLCB0cnVlKVxuICAgIHJldHVybiBidWZmZXIucmVhZFVJbnQzMkxFKDQsIHRydWUpXG4gIH1cbiAgbW9kdWxlLmV4cG9ydHMuaGkgPSBoaWdoVWludFxufVxuXG5tb2R1bGUuZXhwb3J0cy5zaWduID0gZnVuY3Rpb24obikge1xuICByZXR1cm4gbW9kdWxlLmV4cG9ydHMuaGkobikgPj4+IDMxXG59XG5cbm1vZHVsZS5leHBvcnRzLmV4cG9uZW50ID0gZnVuY3Rpb24obikge1xuICB2YXIgYiA9IG1vZHVsZS5leHBvcnRzLmhpKG4pXG4gIHJldHVybiAoKGI8PDEpID4+PiAyMSkgLSAxMDIzXG59XG5cbm1vZHVsZS5leHBvcnRzLmZyYWN0aW9uID0gZnVuY3Rpb24obikge1xuICB2YXIgbG8gPSBtb2R1bGUuZXhwb3J0cy5sbyhuKVxuICB2YXIgaGkgPSBtb2R1bGUuZXhwb3J0cy5oaShuKVxuICB2YXIgYiA9IGhpICYgKCgxPDwyMCkgLSAxKVxuICBpZihoaSAmIDB4N2ZmMDAwMDApIHtcbiAgICBiICs9ICgxPDwyMClcbiAgfVxuICByZXR1cm4gW2xvLCBiXVxufVxuXG5tb2R1bGUuZXhwb3J0cy5kZW5vcm1hbGl6ZWQgPSBmdW5jdGlvbihuKSB7XG4gIHZhciBoaSA9IG1vZHVsZS5leHBvcnRzLmhpKG4pXG4gIHJldHVybiAhKGhpICYgMHg3ZmYwMDAwMClcbn0iLCJcInVzZSBzdHJpY3RcIlxuXG5mdW5jdGlvbiBkdXBlX2FycmF5KGNvdW50LCB2YWx1ZSwgaSkge1xuICB2YXIgYyA9IGNvdW50W2ldfDBcbiAgaWYoYyA8PSAwKSB7XG4gICAgcmV0dXJuIFtdXG4gIH1cbiAgdmFyIHJlc3VsdCA9IG5ldyBBcnJheShjKSwgalxuICBpZihpID09PSBjb3VudC5sZW5ndGgtMSkge1xuICAgIGZvcihqPTA7IGo8YzsgKytqKSB7XG4gICAgICByZXN1bHRbal0gPSB2YWx1ZVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBmb3Ioaj0wOyBqPGM7ICsraikge1xuICAgICAgcmVzdWx0W2pdID0gZHVwZV9hcnJheShjb3VudCwgdmFsdWUsIGkrMSlcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG5mdW5jdGlvbiBkdXBlX251bWJlcihjb3VudCwgdmFsdWUpIHtcbiAgdmFyIHJlc3VsdCwgaVxuICByZXN1bHQgPSBuZXcgQXJyYXkoY291bnQpXG4gIGZvcihpPTA7IGk8Y291bnQ7ICsraSkge1xuICAgIHJlc3VsdFtpXSA9IHZhbHVlXG4gIH1cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG5mdW5jdGlvbiBkdXBlKGNvdW50LCB2YWx1ZSkge1xuICBpZih0eXBlb2YgdmFsdWUgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB2YWx1ZSA9IDBcbiAgfVxuICBzd2l0Y2godHlwZW9mIGNvdW50KSB7XG4gICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgaWYoY291bnQgPiAwKSB7XG4gICAgICAgIHJldHVybiBkdXBlX251bWJlcihjb3VudHwwLCB2YWx1ZSlcbiAgICAgIH1cbiAgICBicmVha1xuICAgIGNhc2UgXCJvYmplY3RcIjpcbiAgICAgIGlmKHR5cGVvZiAoY291bnQubGVuZ3RoKSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICByZXR1cm4gZHVwZV9hcnJheShjb3VudCwgdmFsdWUsIDApXG4gICAgICB9XG4gICAgYnJlYWtcbiAgfVxuICByZXR1cm4gW11cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBkdXBlIiwiXCJ1c2Ugc3RyaWN0XCJcblxubW9kdWxlLmV4cG9ydHMgPSBlZGdlVG9BZGphY2VuY3lcblxudmFyIHVuaXEgPSByZXF1aXJlKFwidW5pcVwiKVxuXG5mdW5jdGlvbiBlZGdlVG9BZGphY2VuY3koZWRnZXMsIG51bVZlcnRpY2VzKSB7XG4gIHZhciBudW1FZGdlcyA9IGVkZ2VzLmxlbmd0aFxuICBpZih0eXBlb2YgbnVtVmVydGljZXMgIT09IFwibnVtYmVyXCIpIHtcbiAgICBudW1WZXJ0aWNlcyA9IDBcbiAgICBmb3IodmFyIGk9MDsgaTxudW1FZGdlczsgKytpKSB7XG4gICAgICB2YXIgZSA9IGVkZ2VzW2ldXG4gICAgICBudW1WZXJ0aWNlcyA9IE1hdGgubWF4KG51bVZlcnRpY2VzLCBlWzBdLCBlWzFdKVxuICAgIH1cbiAgICBudW1WZXJ0aWNlcyA9IChudW1WZXJ0aWNlc3wwKSArIDFcbiAgfVxuICBudW1WZXJ0aWNlcyA9IG51bVZlcnRpY2VzfDBcbiAgdmFyIGFkaiA9IG5ldyBBcnJheShudW1WZXJ0aWNlcylcbiAgZm9yKHZhciBpPTA7IGk8bnVtVmVydGljZXM7ICsraSkge1xuICAgIGFkaltpXSA9IFtdXG4gIH1cbiAgZm9yKHZhciBpPTA7IGk8bnVtRWRnZXM7ICsraSkge1xuICAgIHZhciBlID0gZWRnZXNbaV1cbiAgICBhZGpbZVswXV0ucHVzaChlWzFdKVxuICAgIGFkaltlWzFdXS5wdXNoKGVbMF0pXG4gIH1cbiAgZm9yKHZhciBqPTA7IGo8bnVtVmVydGljZXM7ICsraikge1xuICAgIHVuaXEoYWRqW2pdLCBmdW5jdGlvbihhLCBiKSB7XG4gICAgICByZXR1cm4gYSAtIGJcbiAgICB9KVxuICB9XG4gIHJldHVybiBhZGpcbn0iLCJcInVzZSBzdHJpY3RcIlxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZVJCVHJlZVxuXG52YXIgUkVEICAgPSAwXG52YXIgQkxBQ0sgPSAxXG5cbmZ1bmN0aW9uIFJCTm9kZShjb2xvciwga2V5LCB2YWx1ZSwgbGVmdCwgcmlnaHQsIGNvdW50KSB7XG4gIHRoaXMuX2NvbG9yID0gY29sb3JcbiAgdGhpcy5rZXkgPSBrZXlcbiAgdGhpcy52YWx1ZSA9IHZhbHVlXG4gIHRoaXMubGVmdCA9IGxlZnRcbiAgdGhpcy5yaWdodCA9IHJpZ2h0XG4gIHRoaXMuX2NvdW50ID0gY291bnRcbn1cblxuZnVuY3Rpb24gY2xvbmVOb2RlKG5vZGUpIHtcbiAgcmV0dXJuIG5ldyBSQk5vZGUobm9kZS5fY29sb3IsIG5vZGUua2V5LCBub2RlLnZhbHVlLCBub2RlLmxlZnQsIG5vZGUucmlnaHQsIG5vZGUuX2NvdW50KVxufVxuXG5mdW5jdGlvbiByZXBhaW50KGNvbG9yLCBub2RlKSB7XG4gIHJldHVybiBuZXcgUkJOb2RlKGNvbG9yLCBub2RlLmtleSwgbm9kZS52YWx1ZSwgbm9kZS5sZWZ0LCBub2RlLnJpZ2h0LCBub2RlLl9jb3VudClcbn1cblxuZnVuY3Rpb24gcmVjb3VudChub2RlKSB7XG4gIG5vZGUuX2NvdW50ID0gMSArIChub2RlLmxlZnQgPyBub2RlLmxlZnQuX2NvdW50IDogMCkgKyAobm9kZS5yaWdodCA/IG5vZGUucmlnaHQuX2NvdW50IDogMClcbn1cblxuZnVuY3Rpb24gUmVkQmxhY2tUcmVlKGNvbXBhcmUsIHJvb3QpIHtcbiAgdGhpcy5fY29tcGFyZSA9IGNvbXBhcmVcbiAgdGhpcy5yb290ID0gcm9vdFxufVxuXG52YXIgcHJvdG8gPSBSZWRCbGFja1RyZWUucHJvdG90eXBlXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm90bywgXCJrZXlzXCIsIHtcbiAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICB2YXIgcmVzdWx0ID0gW11cbiAgICB0aGlzLmZvckVhY2goZnVuY3Rpb24oayx2KSB7XG4gICAgICByZXN1bHQucHVzaChrKVxuICAgIH0pXG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG59KVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkocHJvdG8sIFwidmFsdWVzXCIsIHtcbiAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICB2YXIgcmVzdWx0ID0gW11cbiAgICB0aGlzLmZvckVhY2goZnVuY3Rpb24oayx2KSB7XG4gICAgICByZXN1bHQucHVzaCh2KVxuICAgIH0pXG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG59KVxuXG4vL1JldHVybnMgdGhlIG51bWJlciBvZiBub2RlcyBpbiB0aGUgdHJlZVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3RvLCBcImxlbmd0aFwiLCB7XG4gIGdldDogZnVuY3Rpb24oKSB7XG4gICAgaWYodGhpcy5yb290KSB7XG4gICAgICByZXR1cm4gdGhpcy5yb290Ll9jb3VudFxuICAgIH1cbiAgICByZXR1cm4gMFxuICB9XG59KVxuXG4vL0luc2VydCBhIG5ldyBpdGVtIGludG8gdGhlIHRyZWVcbnByb3RvLmluc2VydCA9IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgdmFyIGNtcCA9IHRoaXMuX2NvbXBhcmVcbiAgLy9GaW5kIHBvaW50IHRvIGluc2VydCBuZXcgbm9kZSBhdFxuICB2YXIgbiA9IHRoaXMucm9vdFxuICB2YXIgbl9zdGFjayA9IFtdXG4gIHZhciBkX3N0YWNrID0gW11cbiAgd2hpbGUobikge1xuICAgIHZhciBkID0gY21wKGtleSwgbi5rZXkpXG4gICAgbl9zdGFjay5wdXNoKG4pXG4gICAgZF9zdGFjay5wdXNoKGQpXG4gICAgaWYoZCA8PSAwKSB7XG4gICAgICBuID0gbi5sZWZ0XG4gICAgfSBlbHNlIHtcbiAgICAgIG4gPSBuLnJpZ2h0XG4gICAgfVxuICB9XG4gIC8vUmVidWlsZCBwYXRoIHRvIGxlYWYgbm9kZVxuICBuX3N0YWNrLnB1c2gobmV3IFJCTm9kZShSRUQsIGtleSwgdmFsdWUsIG51bGwsIG51bGwsIDEpKVxuICBmb3IodmFyIHM9bl9zdGFjay5sZW5ndGgtMjsgcz49MDsgLS1zKSB7XG4gICAgdmFyIG4gPSBuX3N0YWNrW3NdXG4gICAgaWYoZF9zdGFja1tzXSA8PSAwKSB7XG4gICAgICBuX3N0YWNrW3NdID0gbmV3IFJCTm9kZShuLl9jb2xvciwgbi5rZXksIG4udmFsdWUsIG5fc3RhY2tbcysxXSwgbi5yaWdodCwgbi5fY291bnQrMSlcbiAgICB9IGVsc2Uge1xuICAgICAgbl9zdGFja1tzXSA9IG5ldyBSQk5vZGUobi5fY29sb3IsIG4ua2V5LCBuLnZhbHVlLCBuLmxlZnQsIG5fc3RhY2tbcysxXSwgbi5fY291bnQrMSlcbiAgICB9XG4gIH1cbiAgLy9SZWJhbGFuY2UgdHJlZSB1c2luZyByb3RhdGlvbnNcbiAgLy9jb25zb2xlLmxvZyhcInN0YXJ0IGluc2VydFwiLCBrZXksIGRfc3RhY2spXG4gIGZvcih2YXIgcz1uX3N0YWNrLmxlbmd0aC0xOyBzPjE7IC0tcykge1xuICAgIHZhciBwID0gbl9zdGFja1tzLTFdXG4gICAgdmFyIG4gPSBuX3N0YWNrW3NdXG4gICAgaWYocC5fY29sb3IgPT09IEJMQUNLIHx8IG4uX2NvbG9yID09PSBCTEFDSykge1xuICAgICAgYnJlYWtcbiAgICB9XG4gICAgdmFyIHBwID0gbl9zdGFja1tzLTJdXG4gICAgaWYocHAubGVmdCA9PT0gcCkge1xuICAgICAgaWYocC5sZWZ0ID09PSBuKSB7XG4gICAgICAgIHZhciB5ID0gcHAucmlnaHRcbiAgICAgICAgaWYoeSAmJiB5Ll9jb2xvciA9PT0gUkVEKSB7XG4gICAgICAgICAgLy9jb25zb2xlLmxvZyhcIkxMclwiKVxuICAgICAgICAgIHAuX2NvbG9yID0gQkxBQ0tcbiAgICAgICAgICBwcC5yaWdodCA9IHJlcGFpbnQoQkxBQ0ssIHkpXG4gICAgICAgICAgcHAuX2NvbG9yID0gUkVEXG4gICAgICAgICAgcyAtPSAxXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy9jb25zb2xlLmxvZyhcIkxMYlwiKVxuICAgICAgICAgIHBwLl9jb2xvciA9IFJFRFxuICAgICAgICAgIHBwLmxlZnQgPSBwLnJpZ2h0XG4gICAgICAgICAgcC5fY29sb3IgPSBCTEFDS1xuICAgICAgICAgIHAucmlnaHQgPSBwcFxuICAgICAgICAgIG5fc3RhY2tbcy0yXSA9IHBcbiAgICAgICAgICBuX3N0YWNrW3MtMV0gPSBuXG4gICAgICAgICAgcmVjb3VudChwcClcbiAgICAgICAgICByZWNvdW50KHApXG4gICAgICAgICAgaWYocyA+PSAzKSB7XG4gICAgICAgICAgICB2YXIgcHBwID0gbl9zdGFja1tzLTNdXG4gICAgICAgICAgICBpZihwcHAubGVmdCA9PT0gcHApIHtcbiAgICAgICAgICAgICAgcHBwLmxlZnQgPSBwXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBwcHAucmlnaHQgPSBwXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciB5ID0gcHAucmlnaHRcbiAgICAgICAgaWYoeSAmJiB5Ll9jb2xvciA9PT0gUkVEKSB7XG4gICAgICAgICAgLy9jb25zb2xlLmxvZyhcIkxSclwiKVxuICAgICAgICAgIHAuX2NvbG9yID0gQkxBQ0tcbiAgICAgICAgICBwcC5yaWdodCA9IHJlcGFpbnQoQkxBQ0ssIHkpXG4gICAgICAgICAgcHAuX2NvbG9yID0gUkVEXG4gICAgICAgICAgcyAtPSAxXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy9jb25zb2xlLmxvZyhcIkxSYlwiKVxuICAgICAgICAgIHAucmlnaHQgPSBuLmxlZnRcbiAgICAgICAgICBwcC5fY29sb3IgPSBSRURcbiAgICAgICAgICBwcC5sZWZ0ID0gbi5yaWdodFxuICAgICAgICAgIG4uX2NvbG9yID0gQkxBQ0tcbiAgICAgICAgICBuLmxlZnQgPSBwXG4gICAgICAgICAgbi5yaWdodCA9IHBwXG4gICAgICAgICAgbl9zdGFja1tzLTJdID0gblxuICAgICAgICAgIG5fc3RhY2tbcy0xXSA9IHBcbiAgICAgICAgICByZWNvdW50KHBwKVxuICAgICAgICAgIHJlY291bnQocClcbiAgICAgICAgICByZWNvdW50KG4pXG4gICAgICAgICAgaWYocyA+PSAzKSB7XG4gICAgICAgICAgICB2YXIgcHBwID0gbl9zdGFja1tzLTNdXG4gICAgICAgICAgICBpZihwcHAubGVmdCA9PT0gcHApIHtcbiAgICAgICAgICAgICAgcHBwLmxlZnQgPSBuXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBwcHAucmlnaHQgPSBuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYocC5yaWdodCA9PT0gbikge1xuICAgICAgICB2YXIgeSA9IHBwLmxlZnRcbiAgICAgICAgaWYoeSAmJiB5Ll9jb2xvciA9PT0gUkVEKSB7XG4gICAgICAgICAgLy9jb25zb2xlLmxvZyhcIlJSclwiLCB5LmtleSlcbiAgICAgICAgICBwLl9jb2xvciA9IEJMQUNLXG4gICAgICAgICAgcHAubGVmdCA9IHJlcGFpbnQoQkxBQ0ssIHkpXG4gICAgICAgICAgcHAuX2NvbG9yID0gUkVEXG4gICAgICAgICAgcyAtPSAxXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy9jb25zb2xlLmxvZyhcIlJSYlwiKVxuICAgICAgICAgIHBwLl9jb2xvciA9IFJFRFxuICAgICAgICAgIHBwLnJpZ2h0ID0gcC5sZWZ0XG4gICAgICAgICAgcC5fY29sb3IgPSBCTEFDS1xuICAgICAgICAgIHAubGVmdCA9IHBwXG4gICAgICAgICAgbl9zdGFja1tzLTJdID0gcFxuICAgICAgICAgIG5fc3RhY2tbcy0xXSA9IG5cbiAgICAgICAgICByZWNvdW50KHBwKVxuICAgICAgICAgIHJlY291bnQocClcbiAgICAgICAgICBpZihzID49IDMpIHtcbiAgICAgICAgICAgIHZhciBwcHAgPSBuX3N0YWNrW3MtM11cbiAgICAgICAgICAgIGlmKHBwcC5yaWdodCA9PT0gcHApIHtcbiAgICAgICAgICAgICAgcHBwLnJpZ2h0ID0gcFxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcHBwLmxlZnQgPSBwXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciB5ID0gcHAubGVmdFxuICAgICAgICBpZih5ICYmIHkuX2NvbG9yID09PSBSRUQpIHtcbiAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiUkxyXCIpXG4gICAgICAgICAgcC5fY29sb3IgPSBCTEFDS1xuICAgICAgICAgIHBwLmxlZnQgPSByZXBhaW50KEJMQUNLLCB5KVxuICAgICAgICAgIHBwLl9jb2xvciA9IFJFRFxuICAgICAgICAgIHMgLT0gMVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vY29uc29sZS5sb2coXCJSTGJcIilcbiAgICAgICAgICBwLmxlZnQgPSBuLnJpZ2h0XG4gICAgICAgICAgcHAuX2NvbG9yID0gUkVEXG4gICAgICAgICAgcHAucmlnaHQgPSBuLmxlZnRcbiAgICAgICAgICBuLl9jb2xvciA9IEJMQUNLXG4gICAgICAgICAgbi5yaWdodCA9IHBcbiAgICAgICAgICBuLmxlZnQgPSBwcFxuICAgICAgICAgIG5fc3RhY2tbcy0yXSA9IG5cbiAgICAgICAgICBuX3N0YWNrW3MtMV0gPSBwXG4gICAgICAgICAgcmVjb3VudChwcClcbiAgICAgICAgICByZWNvdW50KHApXG4gICAgICAgICAgcmVjb3VudChuKVxuICAgICAgICAgIGlmKHMgPj0gMykge1xuICAgICAgICAgICAgdmFyIHBwcCA9IG5fc3RhY2tbcy0zXVxuICAgICAgICAgICAgaWYocHBwLnJpZ2h0ID09PSBwcCkge1xuICAgICAgICAgICAgICBwcHAucmlnaHQgPSBuXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBwcHAubGVmdCA9IG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICAvL1JldHVybiBuZXcgdHJlZVxuICBuX3N0YWNrWzBdLl9jb2xvciA9IEJMQUNLXG4gIHJldHVybiBuZXcgUmVkQmxhY2tUcmVlKGNtcCwgbl9zdGFja1swXSlcbn1cblxuXG4vL1Zpc2l0IGFsbCBub2RlcyBpbm9yZGVyXG5mdW5jdGlvbiBkb1Zpc2l0RnVsbCh2aXNpdCwgbm9kZSkge1xuICBpZihub2RlLmxlZnQpIHtcbiAgICB2YXIgdiA9IGRvVmlzaXRGdWxsKHZpc2l0LCBub2RlLmxlZnQpXG4gICAgaWYodikgeyByZXR1cm4gdiB9XG4gIH1cbiAgdmFyIHYgPSB2aXNpdChub2RlLmtleSwgbm9kZS52YWx1ZSlcbiAgaWYodikgeyByZXR1cm4gdiB9XG4gIGlmKG5vZGUucmlnaHQpIHtcbiAgICByZXR1cm4gZG9WaXNpdEZ1bGwodmlzaXQsIG5vZGUucmlnaHQpXG4gIH1cbn1cblxuLy9WaXNpdCBoYWxmIG5vZGVzIGluIG9yZGVyXG5mdW5jdGlvbiBkb1Zpc2l0SGFsZihsbywgY29tcGFyZSwgdmlzaXQsIG5vZGUpIHtcbiAgdmFyIGwgPSBjb21wYXJlKGxvLCBub2RlLmtleSlcbiAgaWYobCA8PSAwKSB7XG4gICAgaWYobm9kZS5sZWZ0KSB7XG4gICAgICB2YXIgdiA9IGRvVmlzaXRIYWxmKGxvLCBjb21wYXJlLCB2aXNpdCwgbm9kZS5sZWZ0KVxuICAgICAgaWYodikgeyByZXR1cm4gdiB9XG4gICAgfVxuICAgIHZhciB2ID0gdmlzaXQobm9kZS5rZXksIG5vZGUudmFsdWUpXG4gICAgaWYodikgeyByZXR1cm4gdiB9XG4gIH1cbiAgaWYobm9kZS5yaWdodCkge1xuICAgIHJldHVybiBkb1Zpc2l0SGFsZihsbywgY29tcGFyZSwgdmlzaXQsIG5vZGUucmlnaHQpXG4gIH1cbn1cblxuLy9WaXNpdCBhbGwgbm9kZXMgd2l0aGluIGEgcmFuZ2VcbmZ1bmN0aW9uIGRvVmlzaXQobG8sIGhpLCBjb21wYXJlLCB2aXNpdCwgbm9kZSkge1xuICB2YXIgbCA9IGNvbXBhcmUobG8sIG5vZGUua2V5KVxuICB2YXIgaCA9IGNvbXBhcmUoaGksIG5vZGUua2V5KVxuICB2YXIgdlxuICBpZihsIDw9IDApIHtcbiAgICBpZihub2RlLmxlZnQpIHtcbiAgICAgIHYgPSBkb1Zpc2l0KGxvLCBoaSwgY29tcGFyZSwgdmlzaXQsIG5vZGUubGVmdClcbiAgICAgIGlmKHYpIHsgcmV0dXJuIHYgfVxuICAgIH1cbiAgICBpZihoID4gMCkge1xuICAgICAgdiA9IHZpc2l0KG5vZGUua2V5LCBub2RlLnZhbHVlKVxuICAgICAgaWYodikgeyByZXR1cm4gdiB9XG4gICAgfVxuICB9XG4gIGlmKGggPiAwICYmIG5vZGUucmlnaHQpIHtcbiAgICByZXR1cm4gZG9WaXNpdChsbywgaGksIGNvbXBhcmUsIHZpc2l0LCBub2RlLnJpZ2h0KVxuICB9XG59XG5cblxucHJvdG8uZm9yRWFjaCA9IGZ1bmN0aW9uIHJiVHJlZUZvckVhY2godmlzaXQsIGxvLCBoaSkge1xuICBpZighdGhpcy5yb290KSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgc3dpdGNoKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICBjYXNlIDE6XG4gICAgICByZXR1cm4gZG9WaXNpdEZ1bGwodmlzaXQsIHRoaXMucm9vdClcbiAgICBicmVha1xuXG4gICAgY2FzZSAyOlxuICAgICAgcmV0dXJuIGRvVmlzaXRIYWxmKGxvLCB0aGlzLl9jb21wYXJlLCB2aXNpdCwgdGhpcy5yb290KVxuICAgIGJyZWFrXG5cbiAgICBjYXNlIDM6XG4gICAgICBpZih0aGlzLl9jb21wYXJlKGxvLCBoaSkgPj0gMCkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIHJldHVybiBkb1Zpc2l0KGxvLCBoaSwgdGhpcy5fY29tcGFyZSwgdmlzaXQsIHRoaXMucm9vdClcbiAgICBicmVha1xuICB9XG59XG5cbi8vRmlyc3QgaXRlbSBpbiBsaXN0XG5PYmplY3QuZGVmaW5lUHJvcGVydHkocHJvdG8sIFwiYmVnaW5cIiwge1xuICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzdGFjayA9IFtdXG4gICAgdmFyIG4gPSB0aGlzLnJvb3RcbiAgICB3aGlsZShuKSB7XG4gICAgICBzdGFjay5wdXNoKG4pXG4gICAgICBuID0gbi5sZWZ0XG4gICAgfVxuICAgIHJldHVybiBuZXcgUmVkQmxhY2tUcmVlSXRlcmF0b3IodGhpcywgc3RhY2spXG4gIH1cbn0pXG5cbi8vTGFzdCBpdGVtIGluIGxpc3Rcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm90bywgXCJlbmRcIiwge1xuICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzdGFjayA9IFtdXG4gICAgdmFyIG4gPSB0aGlzLnJvb3RcbiAgICB3aGlsZShuKSB7XG4gICAgICBzdGFjay5wdXNoKG4pXG4gICAgICBuID0gbi5yaWdodFxuICAgIH1cbiAgICByZXR1cm4gbmV3IFJlZEJsYWNrVHJlZUl0ZXJhdG9yKHRoaXMsIHN0YWNrKVxuICB9XG59KVxuXG4vL0ZpbmQgdGhlIGl0aCBpdGVtIGluIHRoZSB0cmVlXG5wcm90by5hdCA9IGZ1bmN0aW9uKGlkeCkge1xuICBpZihpZHggPCAwKSB7XG4gICAgcmV0dXJuIG5ldyBSZWRCbGFja1RyZWVJdGVyYXRvcih0aGlzLCBbXSlcbiAgfVxuICB2YXIgbiA9IHRoaXMucm9vdFxuICB2YXIgc3RhY2sgPSBbXVxuICB3aGlsZSh0cnVlKSB7XG4gICAgc3RhY2sucHVzaChuKVxuICAgIGlmKG4ubGVmdCkge1xuICAgICAgaWYoaWR4IDwgbi5sZWZ0Ll9jb3VudCkge1xuICAgICAgICBuID0gbi5sZWZ0XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG4gICAgICBpZHggLT0gbi5sZWZ0Ll9jb3VudFxuICAgIH1cbiAgICBpZighaWR4KSB7XG4gICAgICByZXR1cm4gbmV3IFJlZEJsYWNrVHJlZUl0ZXJhdG9yKHRoaXMsIHN0YWNrKVxuICAgIH1cbiAgICBpZHggLT0gMVxuICAgIGlmKG4ucmlnaHQpIHtcbiAgICAgIGlmKGlkeCA+PSBuLnJpZ2h0Ll9jb3VudCkge1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgbiA9IG4ucmlnaHRcbiAgICB9IGVsc2Uge1xuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5ldyBSZWRCbGFja1RyZWVJdGVyYXRvcih0aGlzLCBbXSlcbn1cblxucHJvdG8uZ2UgPSBmdW5jdGlvbihrZXkpIHtcbiAgdmFyIGNtcCA9IHRoaXMuX2NvbXBhcmVcbiAgdmFyIG4gPSB0aGlzLnJvb3RcbiAgdmFyIHN0YWNrID0gW11cbiAgdmFyIGxhc3RfcHRyID0gMFxuICB3aGlsZShuKSB7XG4gICAgdmFyIGQgPSBjbXAoa2V5LCBuLmtleSlcbiAgICBzdGFjay5wdXNoKG4pXG4gICAgaWYoZCA8PSAwKSB7XG4gICAgICBsYXN0X3B0ciA9IHN0YWNrLmxlbmd0aFxuICAgIH1cbiAgICBpZihkIDw9IDApIHtcbiAgICAgIG4gPSBuLmxlZnRcbiAgICB9IGVsc2Uge1xuICAgICAgbiA9IG4ucmlnaHRcbiAgICB9XG4gIH1cbiAgc3RhY2subGVuZ3RoID0gbGFzdF9wdHJcbiAgcmV0dXJuIG5ldyBSZWRCbGFja1RyZWVJdGVyYXRvcih0aGlzLCBzdGFjaylcbn1cblxucHJvdG8uZ3QgPSBmdW5jdGlvbihrZXkpIHtcbiAgdmFyIGNtcCA9IHRoaXMuX2NvbXBhcmVcbiAgdmFyIG4gPSB0aGlzLnJvb3RcbiAgdmFyIHN0YWNrID0gW11cbiAgdmFyIGxhc3RfcHRyID0gMFxuICB3aGlsZShuKSB7XG4gICAgdmFyIGQgPSBjbXAoa2V5LCBuLmtleSlcbiAgICBzdGFjay5wdXNoKG4pXG4gICAgaWYoZCA8IDApIHtcbiAgICAgIGxhc3RfcHRyID0gc3RhY2subGVuZ3RoXG4gICAgfVxuICAgIGlmKGQgPCAwKSB7XG4gICAgICBuID0gbi5sZWZ0XG4gICAgfSBlbHNlIHtcbiAgICAgIG4gPSBuLnJpZ2h0XG4gICAgfVxuICB9XG4gIHN0YWNrLmxlbmd0aCA9IGxhc3RfcHRyXG4gIHJldHVybiBuZXcgUmVkQmxhY2tUcmVlSXRlcmF0b3IodGhpcywgc3RhY2spXG59XG5cbnByb3RvLmx0ID0gZnVuY3Rpb24oa2V5KSB7XG4gIHZhciBjbXAgPSB0aGlzLl9jb21wYXJlXG4gIHZhciBuID0gdGhpcy5yb290XG4gIHZhciBzdGFjayA9IFtdXG4gIHZhciBsYXN0X3B0ciA9IDBcbiAgd2hpbGUobikge1xuICAgIHZhciBkID0gY21wKGtleSwgbi5rZXkpXG4gICAgc3RhY2sucHVzaChuKVxuICAgIGlmKGQgPiAwKSB7XG4gICAgICBsYXN0X3B0ciA9IHN0YWNrLmxlbmd0aFxuICAgIH1cbiAgICBpZihkIDw9IDApIHtcbiAgICAgIG4gPSBuLmxlZnRcbiAgICB9IGVsc2Uge1xuICAgICAgbiA9IG4ucmlnaHRcbiAgICB9XG4gIH1cbiAgc3RhY2subGVuZ3RoID0gbGFzdF9wdHJcbiAgcmV0dXJuIG5ldyBSZWRCbGFja1RyZWVJdGVyYXRvcih0aGlzLCBzdGFjaylcbn1cblxucHJvdG8ubGUgPSBmdW5jdGlvbihrZXkpIHtcbiAgdmFyIGNtcCA9IHRoaXMuX2NvbXBhcmVcbiAgdmFyIG4gPSB0aGlzLnJvb3RcbiAgdmFyIHN0YWNrID0gW11cbiAgdmFyIGxhc3RfcHRyID0gMFxuICB3aGlsZShuKSB7XG4gICAgdmFyIGQgPSBjbXAoa2V5LCBuLmtleSlcbiAgICBzdGFjay5wdXNoKG4pXG4gICAgaWYoZCA+PSAwKSB7XG4gICAgICBsYXN0X3B0ciA9IHN0YWNrLmxlbmd0aFxuICAgIH1cbiAgICBpZihkIDwgMCkge1xuICAgICAgbiA9IG4ubGVmdFxuICAgIH0gZWxzZSB7XG4gICAgICBuID0gbi5yaWdodFxuICAgIH1cbiAgfVxuICBzdGFjay5sZW5ndGggPSBsYXN0X3B0clxuICByZXR1cm4gbmV3IFJlZEJsYWNrVHJlZUl0ZXJhdG9yKHRoaXMsIHN0YWNrKVxufVxuXG4vL0ZpbmRzIHRoZSBpdGVtIHdpdGgga2V5IGlmIGl0IGV4aXN0c1xucHJvdG8uZmluZCA9IGZ1bmN0aW9uKGtleSkge1xuICB2YXIgY21wID0gdGhpcy5fY29tcGFyZVxuICB2YXIgbiA9IHRoaXMucm9vdFxuICB2YXIgc3RhY2sgPSBbXVxuICB3aGlsZShuKSB7XG4gICAgdmFyIGQgPSBjbXAoa2V5LCBuLmtleSlcbiAgICBzdGFjay5wdXNoKG4pXG4gICAgaWYoZCA9PT0gMCkge1xuICAgICAgcmV0dXJuIG5ldyBSZWRCbGFja1RyZWVJdGVyYXRvcih0aGlzLCBzdGFjaylcbiAgICB9XG4gICAgaWYoZCA8PSAwKSB7XG4gICAgICBuID0gbi5sZWZ0XG4gICAgfSBlbHNlIHtcbiAgICAgIG4gPSBuLnJpZ2h0XG4gICAgfVxuICB9XG4gIHJldHVybiBuZXcgUmVkQmxhY2tUcmVlSXRlcmF0b3IodGhpcywgW10pXG59XG5cbi8vUmVtb3ZlcyBpdGVtIHdpdGgga2V5IGZyb20gdHJlZVxucHJvdG8ucmVtb3ZlID0gZnVuY3Rpb24oa2V5KSB7XG4gIHZhciBpdGVyID0gdGhpcy5maW5kKGtleSlcbiAgaWYoaXRlcikge1xuICAgIHJldHVybiBpdGVyLnJlbW92ZSgpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuLy9SZXR1cm5zIHRoZSBpdGVtIGF0IGBrZXlgXG5wcm90by5nZXQgPSBmdW5jdGlvbihrZXkpIHtcbiAgdmFyIGNtcCA9IHRoaXMuX2NvbXBhcmVcbiAgdmFyIG4gPSB0aGlzLnJvb3RcbiAgd2hpbGUobikge1xuICAgIHZhciBkID0gY21wKGtleSwgbi5rZXkpXG4gICAgaWYoZCA9PT0gMCkge1xuICAgICAgcmV0dXJuIG4udmFsdWVcbiAgICB9XG4gICAgaWYoZCA8PSAwKSB7XG4gICAgICBuID0gbi5sZWZ0XG4gICAgfSBlbHNlIHtcbiAgICAgIG4gPSBuLnJpZ2h0XG4gICAgfVxuICB9XG4gIHJldHVyblxufVxuXG4vL0l0ZXJhdG9yIGZvciByZWQgYmxhY2sgdHJlZVxuZnVuY3Rpb24gUmVkQmxhY2tUcmVlSXRlcmF0b3IodHJlZSwgc3RhY2spIHtcbiAgdGhpcy50cmVlID0gdHJlZVxuICB0aGlzLl9zdGFjayA9IHN0YWNrXG59XG5cbnZhciBpcHJvdG8gPSBSZWRCbGFja1RyZWVJdGVyYXRvci5wcm90b3R5cGVcblxuLy9UZXN0IGlmIGl0ZXJhdG9yIGlzIHZhbGlkXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoaXByb3RvLCBcInZhbGlkXCIsIHtcbiAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RhY2subGVuZ3RoID4gMFxuICB9XG59KVxuXG4vL05vZGUgb2YgdGhlIGl0ZXJhdG9yXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoaXByb3RvLCBcIm5vZGVcIiwge1xuICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIGlmKHRoaXMuX3N0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgIHJldHVybiB0aGlzLl9zdGFja1t0aGlzLl9zdGFjay5sZW5ndGgtMV1cbiAgICB9XG4gICAgcmV0dXJuIG51bGxcbiAgfSxcbiAgZW51bWVyYWJsZTogdHJ1ZVxufSlcblxuLy9NYWtlcyBhIGNvcHkgb2YgYW4gaXRlcmF0b3Jcbmlwcm90by5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFJlZEJsYWNrVHJlZUl0ZXJhdG9yKHRoaXMudHJlZSwgdGhpcy5fc3RhY2suc2xpY2UoKSlcbn1cblxuLy9Td2FwcyB0d28gbm9kZXNcbmZ1bmN0aW9uIHN3YXBOb2RlKG4sIHYpIHtcbiAgbi5rZXkgPSB2LmtleVxuICBuLnZhbHVlID0gdi52YWx1ZVxuICBuLmxlZnQgPSB2LmxlZnRcbiAgbi5yaWdodCA9IHYucmlnaHRcbiAgbi5fY29sb3IgPSB2Ll9jb2xvclxuICBuLl9jb3VudCA9IHYuX2NvdW50XG59XG5cbi8vRml4IHVwIGEgZG91YmxlIGJsYWNrIG5vZGUgaW4gYSB0cmVlXG5mdW5jdGlvbiBmaXhEb3VibGVCbGFjayhzdGFjaykge1xuICB2YXIgbiwgcCwgcywgelxuICBmb3IodmFyIGk9c3RhY2subGVuZ3RoLTE7IGk+PTA7IC0taSkge1xuICAgIG4gPSBzdGFja1tpXVxuICAgIGlmKGkgPT09IDApIHtcbiAgICAgIG4uX2NvbG9yID0gQkxBQ0tcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICAvL2NvbnNvbGUubG9nKFwidmlzaXQgbm9kZTpcIiwgbi5rZXksIGksIHN0YWNrW2ldLmtleSwgc3RhY2tbaS0xXS5rZXkpXG4gICAgcCA9IHN0YWNrW2ktMV1cbiAgICBpZihwLmxlZnQgPT09IG4pIHtcbiAgICAgIC8vY29uc29sZS5sb2coXCJsZWZ0IGNoaWxkXCIpXG4gICAgICBzID0gcC5yaWdodFxuICAgICAgaWYocy5yaWdodCAmJiBzLnJpZ2h0Ll9jb2xvciA9PT0gUkVEKSB7XG4gICAgICAgIC8vY29uc29sZS5sb2coXCJjYXNlIDE6IHJpZ2h0IHNpYmxpbmcgY2hpbGQgcmVkXCIpXG4gICAgICAgIHMgPSBwLnJpZ2h0ID0gY2xvbmVOb2RlKHMpXG4gICAgICAgIHogPSBzLnJpZ2h0ID0gY2xvbmVOb2RlKHMucmlnaHQpXG4gICAgICAgIHAucmlnaHQgPSBzLmxlZnRcbiAgICAgICAgcy5sZWZ0ID0gcFxuICAgICAgICBzLnJpZ2h0ID0gelxuICAgICAgICBzLl9jb2xvciA9IHAuX2NvbG9yXG4gICAgICAgIG4uX2NvbG9yID0gQkxBQ0tcbiAgICAgICAgcC5fY29sb3IgPSBCTEFDS1xuICAgICAgICB6Ll9jb2xvciA9IEJMQUNLXG4gICAgICAgIHJlY291bnQocClcbiAgICAgICAgcmVjb3VudChzKVxuICAgICAgICBpZihpID4gMSkge1xuICAgICAgICAgIHZhciBwcCA9IHN0YWNrW2ktMl1cbiAgICAgICAgICBpZihwcC5sZWZ0ID09PSBwKSB7XG4gICAgICAgICAgICBwcC5sZWZ0ID0gc1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwcC5yaWdodCA9IHNcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3RhY2tbaS0xXSA9IHNcbiAgICAgICAgcmV0dXJuXG4gICAgICB9IGVsc2UgaWYocy5sZWZ0ICYmIHMubGVmdC5fY29sb3IgPT09IFJFRCkge1xuICAgICAgICAvL2NvbnNvbGUubG9nKFwiY2FzZSAxOiBsZWZ0IHNpYmxpbmcgY2hpbGQgcmVkXCIpXG4gICAgICAgIHMgPSBwLnJpZ2h0ID0gY2xvbmVOb2RlKHMpXG4gICAgICAgIHogPSBzLmxlZnQgPSBjbG9uZU5vZGUocy5sZWZ0KVxuICAgICAgICBwLnJpZ2h0ID0gei5sZWZ0XG4gICAgICAgIHMubGVmdCA9IHoucmlnaHRcbiAgICAgICAgei5sZWZ0ID0gcFxuICAgICAgICB6LnJpZ2h0ID0gc1xuICAgICAgICB6Ll9jb2xvciA9IHAuX2NvbG9yXG4gICAgICAgIHAuX2NvbG9yID0gQkxBQ0tcbiAgICAgICAgcy5fY29sb3IgPSBCTEFDS1xuICAgICAgICBuLl9jb2xvciA9IEJMQUNLXG4gICAgICAgIHJlY291bnQocClcbiAgICAgICAgcmVjb3VudChzKVxuICAgICAgICByZWNvdW50KHopXG4gICAgICAgIGlmKGkgPiAxKSB7XG4gICAgICAgICAgdmFyIHBwID0gc3RhY2tbaS0yXVxuICAgICAgICAgIGlmKHBwLmxlZnQgPT09IHApIHtcbiAgICAgICAgICAgIHBwLmxlZnQgPSB6XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBwLnJpZ2h0ID0gelxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdGFja1tpLTFdID0gelxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIGlmKHMuX2NvbG9yID09PSBCTEFDSykge1xuICAgICAgICBpZihwLl9jb2xvciA9PT0gUkVEKSB7XG4gICAgICAgICAgLy9jb25zb2xlLmxvZyhcImNhc2UgMjogYmxhY2sgc2libGluZywgcmVkIHBhcmVudFwiLCBwLnJpZ2h0LnZhbHVlKVxuICAgICAgICAgIHAuX2NvbG9yID0gQkxBQ0tcbiAgICAgICAgICBwLnJpZ2h0ID0gcmVwYWludChSRUQsIHMpXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy9jb25zb2xlLmxvZyhcImNhc2UgMjogYmxhY2sgc2libGluZywgYmxhY2sgcGFyZW50XCIsIHAucmlnaHQudmFsdWUpXG4gICAgICAgICAgcC5yaWdodCA9IHJlcGFpbnQoUkVELCBzKVxuICAgICAgICAgIGNvbnRpbnVlICBcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy9jb25zb2xlLmxvZyhcImNhc2UgMzogcmVkIHNpYmxpbmdcIilcbiAgICAgICAgcyA9IGNsb25lTm9kZShzKVxuICAgICAgICBwLnJpZ2h0ID0gcy5sZWZ0XG4gICAgICAgIHMubGVmdCA9IHBcbiAgICAgICAgcy5fY29sb3IgPSBwLl9jb2xvclxuICAgICAgICBwLl9jb2xvciA9IFJFRFxuICAgICAgICByZWNvdW50KHApXG4gICAgICAgIHJlY291bnQocylcbiAgICAgICAgaWYoaSA+IDEpIHtcbiAgICAgICAgICB2YXIgcHAgPSBzdGFja1tpLTJdXG4gICAgICAgICAgaWYocHAubGVmdCA9PT0gcCkge1xuICAgICAgICAgICAgcHAubGVmdCA9IHNcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcHAucmlnaHQgPSBzXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN0YWNrW2ktMV0gPSBzXG4gICAgICAgIHN0YWNrW2ldID0gcFxuICAgICAgICBpZihpKzEgPCBzdGFjay5sZW5ndGgpIHtcbiAgICAgICAgICBzdGFja1tpKzFdID0gblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0YWNrLnB1c2gobilcbiAgICAgICAgfVxuICAgICAgICBpID0gaSsyXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vY29uc29sZS5sb2coXCJyaWdodCBjaGlsZFwiKVxuICAgICAgcyA9IHAubGVmdFxuICAgICAgaWYocy5sZWZ0ICYmIHMubGVmdC5fY29sb3IgPT09IFJFRCkge1xuICAgICAgICAvL2NvbnNvbGUubG9nKFwiY2FzZSAxOiBsZWZ0IHNpYmxpbmcgY2hpbGQgcmVkXCIsIHAudmFsdWUsIHAuX2NvbG9yKVxuICAgICAgICBzID0gcC5sZWZ0ID0gY2xvbmVOb2RlKHMpXG4gICAgICAgIHogPSBzLmxlZnQgPSBjbG9uZU5vZGUocy5sZWZ0KVxuICAgICAgICBwLmxlZnQgPSBzLnJpZ2h0XG4gICAgICAgIHMucmlnaHQgPSBwXG4gICAgICAgIHMubGVmdCA9IHpcbiAgICAgICAgcy5fY29sb3IgPSBwLl9jb2xvclxuICAgICAgICBuLl9jb2xvciA9IEJMQUNLXG4gICAgICAgIHAuX2NvbG9yID0gQkxBQ0tcbiAgICAgICAgei5fY29sb3IgPSBCTEFDS1xuICAgICAgICByZWNvdW50KHApXG4gICAgICAgIHJlY291bnQocylcbiAgICAgICAgaWYoaSA+IDEpIHtcbiAgICAgICAgICB2YXIgcHAgPSBzdGFja1tpLTJdXG4gICAgICAgICAgaWYocHAucmlnaHQgPT09IHApIHtcbiAgICAgICAgICAgIHBwLnJpZ2h0ID0gc1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwcC5sZWZ0ID0gc1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdGFja1tpLTFdID0gc1xuICAgICAgICByZXR1cm5cbiAgICAgIH0gZWxzZSBpZihzLnJpZ2h0ICYmIHMucmlnaHQuX2NvbG9yID09PSBSRUQpIHtcbiAgICAgICAgLy9jb25zb2xlLmxvZyhcImNhc2UgMTogcmlnaHQgc2libGluZyBjaGlsZCByZWRcIilcbiAgICAgICAgcyA9IHAubGVmdCA9IGNsb25lTm9kZShzKVxuICAgICAgICB6ID0gcy5yaWdodCA9IGNsb25lTm9kZShzLnJpZ2h0KVxuICAgICAgICBwLmxlZnQgPSB6LnJpZ2h0XG4gICAgICAgIHMucmlnaHQgPSB6LmxlZnRcbiAgICAgICAgei5yaWdodCA9IHBcbiAgICAgICAgei5sZWZ0ID0gc1xuICAgICAgICB6Ll9jb2xvciA9IHAuX2NvbG9yXG4gICAgICAgIHAuX2NvbG9yID0gQkxBQ0tcbiAgICAgICAgcy5fY29sb3IgPSBCTEFDS1xuICAgICAgICBuLl9jb2xvciA9IEJMQUNLXG4gICAgICAgIHJlY291bnQocClcbiAgICAgICAgcmVjb3VudChzKVxuICAgICAgICByZWNvdW50KHopXG4gICAgICAgIGlmKGkgPiAxKSB7XG4gICAgICAgICAgdmFyIHBwID0gc3RhY2tbaS0yXVxuICAgICAgICAgIGlmKHBwLnJpZ2h0ID09PSBwKSB7XG4gICAgICAgICAgICBwcC5yaWdodCA9IHpcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcHAubGVmdCA9IHpcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3RhY2tbaS0xXSA9IHpcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICBpZihzLl9jb2xvciA9PT0gQkxBQ0spIHtcbiAgICAgICAgaWYocC5fY29sb3IgPT09IFJFRCkge1xuICAgICAgICAgIC8vY29uc29sZS5sb2coXCJjYXNlIDI6IGJsYWNrIHNpYmxpbmcsIHJlZCBwYXJlbnRcIilcbiAgICAgICAgICBwLl9jb2xvciA9IEJMQUNLXG4gICAgICAgICAgcC5sZWZ0ID0gcmVwYWludChSRUQsIHMpXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy9jb25zb2xlLmxvZyhcImNhc2UgMjogYmxhY2sgc2libGluZywgYmxhY2sgcGFyZW50XCIpXG4gICAgICAgICAgcC5sZWZ0ID0gcmVwYWludChSRUQsIHMpXG4gICAgICAgICAgY29udGludWUgIFxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvL2NvbnNvbGUubG9nKFwiY2FzZSAzOiByZWQgc2libGluZ1wiKVxuICAgICAgICBzID0gY2xvbmVOb2RlKHMpXG4gICAgICAgIHAubGVmdCA9IHMucmlnaHRcbiAgICAgICAgcy5yaWdodCA9IHBcbiAgICAgICAgcy5fY29sb3IgPSBwLl9jb2xvclxuICAgICAgICBwLl9jb2xvciA9IFJFRFxuICAgICAgICByZWNvdW50KHApXG4gICAgICAgIHJlY291bnQocylcbiAgICAgICAgaWYoaSA+IDEpIHtcbiAgICAgICAgICB2YXIgcHAgPSBzdGFja1tpLTJdXG4gICAgICAgICAgaWYocHAucmlnaHQgPT09IHApIHtcbiAgICAgICAgICAgIHBwLnJpZ2h0ID0gc1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwcC5sZWZ0ID0gc1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdGFja1tpLTFdID0gc1xuICAgICAgICBzdGFja1tpXSA9IHBcbiAgICAgICAgaWYoaSsxIDwgc3RhY2subGVuZ3RoKSB7XG4gICAgICAgICAgc3RhY2tbaSsxXSA9IG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdGFjay5wdXNoKG4pXG4gICAgICAgIH1cbiAgICAgICAgaSA9IGkrMlxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vL1JlbW92ZXMgaXRlbSBhdCBpdGVyYXRvciBmcm9tIHRyZWVcbmlwcm90by5yZW1vdmUgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHN0YWNrID0gdGhpcy5fc3RhY2tcbiAgaWYoc3RhY2subGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHRoaXMudHJlZVxuICB9XG4gIC8vRmlyc3QgY29weSBwYXRoIHRvIG5vZGVcbiAgdmFyIGNzdGFjayA9IG5ldyBBcnJheShzdGFjay5sZW5ndGgpXG4gIHZhciBuID0gc3RhY2tbc3RhY2subGVuZ3RoLTFdXG4gIGNzdGFja1tjc3RhY2subGVuZ3RoLTFdID0gbmV3IFJCTm9kZShuLl9jb2xvciwgbi5rZXksIG4udmFsdWUsIG4ubGVmdCwgbi5yaWdodCwgbi5fY291bnQpXG4gIGZvcih2YXIgaT1zdGFjay5sZW5ndGgtMjsgaT49MDsgLS1pKSB7XG4gICAgdmFyIG4gPSBzdGFja1tpXVxuICAgIGlmKG4ubGVmdCA9PT0gc3RhY2tbaSsxXSkge1xuICAgICAgY3N0YWNrW2ldID0gbmV3IFJCTm9kZShuLl9jb2xvciwgbi5rZXksIG4udmFsdWUsIGNzdGFja1tpKzFdLCBuLnJpZ2h0LCBuLl9jb3VudClcbiAgICB9IGVsc2Uge1xuICAgICAgY3N0YWNrW2ldID0gbmV3IFJCTm9kZShuLl9jb2xvciwgbi5rZXksIG4udmFsdWUsIG4ubGVmdCwgY3N0YWNrW2krMV0sIG4uX2NvdW50KVxuICAgIH1cbiAgfVxuXG4gIC8vR2V0IG5vZGVcbiAgbiA9IGNzdGFja1tjc3RhY2subGVuZ3RoLTFdXG4gIC8vY29uc29sZS5sb2coXCJzdGFydCByZW1vdmU6IFwiLCBuLnZhbHVlKVxuXG4gIC8vSWYgbm90IGxlYWYsIHRoZW4gc3dhcCB3aXRoIHByZXZpb3VzIG5vZGVcbiAgaWYobi5sZWZ0ICYmIG4ucmlnaHQpIHtcbiAgICAvL2NvbnNvbGUubG9nKFwibW92aW5nIHRvIGxlYWZcIilcblxuICAgIC8vRmlyc3Qgd2FsayB0byBwcmV2aW91cyBsZWFmXG4gICAgdmFyIHNwbGl0ID0gY3N0YWNrLmxlbmd0aFxuICAgIG4gPSBuLmxlZnRcbiAgICB3aGlsZShuLnJpZ2h0KSB7XG4gICAgICBjc3RhY2sucHVzaChuKVxuICAgICAgbiA9IG4ucmlnaHRcbiAgICB9XG4gICAgLy9Db3B5IHBhdGggdG8gbGVhZlxuICAgIHZhciB2ID0gY3N0YWNrW3NwbGl0LTFdXG4gICAgY3N0YWNrLnB1c2gobmV3IFJCTm9kZShuLl9jb2xvciwgdi5rZXksIHYudmFsdWUsIG4ubGVmdCwgbi5yaWdodCwgbi5fY291bnQpKVxuICAgIGNzdGFja1tzcGxpdC0xXS5rZXkgPSBuLmtleVxuICAgIGNzdGFja1tzcGxpdC0xXS52YWx1ZSA9IG4udmFsdWVcblxuICAgIC8vRml4IHVwIHN0YWNrXG4gICAgZm9yKHZhciBpPWNzdGFjay5sZW5ndGgtMjsgaT49c3BsaXQ7IC0taSkge1xuICAgICAgbiA9IGNzdGFja1tpXVxuICAgICAgY3N0YWNrW2ldID0gbmV3IFJCTm9kZShuLl9jb2xvciwgbi5rZXksIG4udmFsdWUsIG4ubGVmdCwgY3N0YWNrW2krMV0sIG4uX2NvdW50KVxuICAgIH1cbiAgICBjc3RhY2tbc3BsaXQtMV0ubGVmdCA9IGNzdGFja1tzcGxpdF1cbiAgfVxuICAvL2NvbnNvbGUubG9nKFwic3RhY2s9XCIsIGNzdGFjay5tYXAoZnVuY3Rpb24odikgeyByZXR1cm4gdi52YWx1ZSB9KSlcblxuICAvL1JlbW92ZSBsZWFmIG5vZGVcbiAgbiA9IGNzdGFja1tjc3RhY2subGVuZ3RoLTFdXG4gIGlmKG4uX2NvbG9yID09PSBSRUQpIHtcbiAgICAvL0Vhc3kgY2FzZTogcmVtb3ZpbmcgcmVkIGxlYWZcbiAgICAvL2NvbnNvbGUubG9nKFwiUkVEIGxlYWZcIilcbiAgICB2YXIgcCA9IGNzdGFja1tjc3RhY2subGVuZ3RoLTJdXG4gICAgaWYocC5sZWZ0ID09PSBuKSB7XG4gICAgICBwLmxlZnQgPSBudWxsXG4gICAgfSBlbHNlIGlmKHAucmlnaHQgPT09IG4pIHtcbiAgICAgIHAucmlnaHQgPSBudWxsXG4gICAgfVxuICAgIGNzdGFjay5wb3AoKVxuICAgIGZvcih2YXIgaT0wOyBpPGNzdGFjay5sZW5ndGg7ICsraSkge1xuICAgICAgY3N0YWNrW2ldLl9jb3VudC0tXG4gICAgfVxuICAgIHJldHVybiBuZXcgUmVkQmxhY2tUcmVlKHRoaXMudHJlZS5fY29tcGFyZSwgY3N0YWNrWzBdKVxuICB9IGVsc2Uge1xuICAgIGlmKG4ubGVmdCB8fCBuLnJpZ2h0KSB7XG4gICAgICAvL1NlY29uZCBlYXN5IGNhc2U6ICBTaW5nbGUgY2hpbGQgYmxhY2sgcGFyZW50XG4gICAgICAvL2NvbnNvbGUubG9nKFwiQkxBQ0sgc2luZ2xlIGNoaWxkXCIpXG4gICAgICBpZihuLmxlZnQpIHtcbiAgICAgICAgc3dhcE5vZGUobiwgbi5sZWZ0KVxuICAgICAgfSBlbHNlIGlmKG4ucmlnaHQpIHtcbiAgICAgICAgc3dhcE5vZGUobiwgbi5yaWdodClcbiAgICAgIH1cbiAgICAgIC8vQ2hpbGQgbXVzdCBiZSByZWQsIHNvIHJlcGFpbnQgaXQgYmxhY2sgdG8gYmFsYW5jZSBjb2xvclxuICAgICAgbi5fY29sb3IgPSBCTEFDS1xuICAgICAgZm9yKHZhciBpPTA7IGk8Y3N0YWNrLmxlbmd0aC0xOyArK2kpIHtcbiAgICAgICAgY3N0YWNrW2ldLl9jb3VudC0tXG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IFJlZEJsYWNrVHJlZSh0aGlzLnRyZWUuX2NvbXBhcmUsIGNzdGFja1swXSlcbiAgICB9IGVsc2UgaWYoY3N0YWNrLmxlbmd0aCA9PT0gMSkge1xuICAgICAgLy9UaGlyZCBlYXN5IGNhc2U6IHJvb3RcbiAgICAgIC8vY29uc29sZS5sb2coXCJST09UXCIpXG4gICAgICByZXR1cm4gbmV3IFJlZEJsYWNrVHJlZSh0aGlzLnRyZWUuX2NvbXBhcmUsIG51bGwpXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vSGFyZCBjYXNlOiBSZXBhaW50IG4sIGFuZCB0aGVuIGRvIHNvbWUgbmFzdHkgc3R1ZmZcbiAgICAgIC8vY29uc29sZS5sb2coXCJCTEFDSyBsZWFmIG5vIGNoaWxkcmVuXCIpXG4gICAgICBmb3IodmFyIGk9MDsgaTxjc3RhY2subGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY3N0YWNrW2ldLl9jb3VudC0tXG4gICAgICB9XG4gICAgICB2YXIgcGFyZW50ID0gY3N0YWNrW2NzdGFjay5sZW5ndGgtMl1cbiAgICAgIGZpeERvdWJsZUJsYWNrKGNzdGFjaylcbiAgICAgIC8vRml4IHVwIGxpbmtzXG4gICAgICBpZihwYXJlbnQubGVmdCA9PT0gbikge1xuICAgICAgICBwYXJlbnQubGVmdCA9IG51bGxcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcmVudC5yaWdodCA9IG51bGxcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5ldyBSZWRCbGFja1RyZWUodGhpcy50cmVlLl9jb21wYXJlLCBjc3RhY2tbMF0pXG59XG5cbi8vUmV0dXJucyBrZXlcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShpcHJvdG8sIFwia2V5XCIsIHtcbiAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICBpZih0aGlzLl9zdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc3RhY2tbdGhpcy5fc3RhY2subGVuZ3RoLTFdLmtleVxuICAgIH1cbiAgICByZXR1cm5cbiAgfSxcbiAgZW51bWVyYWJsZTogdHJ1ZVxufSlcblxuLy9SZXR1cm5zIHZhbHVlXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoaXByb3RvLCBcInZhbHVlXCIsIHtcbiAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICBpZih0aGlzLl9zdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc3RhY2tbdGhpcy5fc3RhY2subGVuZ3RoLTFdLnZhbHVlXG4gICAgfVxuICAgIHJldHVyblxuICB9LFxuICBlbnVtZXJhYmxlOiB0cnVlXG59KVxuXG5cbi8vUmV0dXJucyB0aGUgcG9zaXRpb24gb2YgdGhpcyBpdGVyYXRvciBpbiB0aGUgc29ydGVkIGxpc3Rcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShpcHJvdG8sIFwiaW5kZXhcIiwge1xuICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBpZHggPSAwXG4gICAgdmFyIHN0YWNrID0gdGhpcy5fc3RhY2tcbiAgICBpZihzdGFjay5sZW5ndGggPT09IDApIHtcbiAgICAgIHZhciByID0gdGhpcy50cmVlLnJvb3RcbiAgICAgIGlmKHIpIHtcbiAgICAgICAgcmV0dXJuIHIuX2NvdW50XG4gICAgICB9XG4gICAgICByZXR1cm4gMFxuICAgIH0gZWxzZSBpZihzdGFja1tzdGFjay5sZW5ndGgtMV0ubGVmdCkge1xuICAgICAgaWR4ID0gc3RhY2tbc3RhY2subGVuZ3RoLTFdLmxlZnQuX2NvdW50XG4gICAgfVxuICAgIGZvcih2YXIgcz1zdGFjay5sZW5ndGgtMjsgcz49MDsgLS1zKSB7XG4gICAgICBpZihzdGFja1tzKzFdID09PSBzdGFja1tzXS5yaWdodCkge1xuICAgICAgICArK2lkeFxuICAgICAgICBpZihzdGFja1tzXS5sZWZ0KSB7XG4gICAgICAgICAgaWR4ICs9IHN0YWNrW3NdLmxlZnQuX2NvdW50XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGlkeFxuICB9LFxuICBlbnVtZXJhYmxlOiB0cnVlXG59KVxuXG4vL0FkdmFuY2VzIGl0ZXJhdG9yIHRvIG5leHQgZWxlbWVudCBpbiBsaXN0XG5pcHJvdG8ubmV4dCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgc3RhY2sgPSB0aGlzLl9zdGFja1xuICBpZihzdGFjay5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgbiA9IHN0YWNrW3N0YWNrLmxlbmd0aC0xXVxuICBpZihuLnJpZ2h0KSB7XG4gICAgbiA9IG4ucmlnaHRcbiAgICB3aGlsZShuKSB7XG4gICAgICBzdGFjay5wdXNoKG4pXG4gICAgICBuID0gbi5sZWZ0XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHN0YWNrLnBvcCgpXG4gICAgd2hpbGUoc3RhY2subGVuZ3RoID4gMCAmJiBzdGFja1tzdGFjay5sZW5ndGgtMV0ucmlnaHQgPT09IG4pIHtcbiAgICAgIG4gPSBzdGFja1tzdGFjay5sZW5ndGgtMV1cbiAgICAgIHN0YWNrLnBvcCgpXG4gICAgfVxuICB9XG59XG5cbi8vQ2hlY2tzIGlmIGl0ZXJhdG9yIGlzIGF0IGVuZCBvZiB0cmVlXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoaXByb3RvLCBcImhhc05leHRcIiwge1xuICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzdGFjayA9IHRoaXMuX3N0YWNrXG4gICAgaWYoc3RhY2subGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gICAgaWYoc3RhY2tbc3RhY2subGVuZ3RoLTFdLnJpZ2h0KSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICBmb3IodmFyIHM9c3RhY2subGVuZ3RoLTE7IHM+MDsgLS1zKSB7XG4gICAgICBpZihzdGFja1tzLTFdLmxlZnQgPT09IHN0YWNrW3NdKSB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9XG59KVxuXG4vL1VwZGF0ZSB2YWx1ZVxuaXByb3RvLnVwZGF0ZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHZhciBzdGFjayA9IHRoaXMuX3N0YWNrXG4gIGlmKHN0YWNrLmxlbmd0aCA9PT0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IHVwZGF0ZSBlbXB0eSBub2RlIVwiKVxuICB9XG4gIHZhciBjc3RhY2sgPSBuZXcgQXJyYXkoc3RhY2subGVuZ3RoKVxuICB2YXIgbiA9IHN0YWNrW3N0YWNrLmxlbmd0aC0xXVxuICBjc3RhY2tbY3N0YWNrLmxlbmd0aC0xXSA9IG5ldyBSQk5vZGUobi5fY29sb3IsIG4ua2V5LCB2YWx1ZSwgbi5sZWZ0LCBuLnJpZ2h0LCBuLl9jb3VudClcbiAgZm9yKHZhciBpPXN0YWNrLmxlbmd0aC0yOyBpPj0wOyAtLWkpIHtcbiAgICBuID0gc3RhY2tbaV1cbiAgICBpZihuLmxlZnQgPT09IHN0YWNrW2krMV0pIHtcbiAgICAgIGNzdGFja1tpXSA9IG5ldyBSQk5vZGUobi5fY29sb3IsIG4ua2V5LCBuLnZhbHVlLCBjc3RhY2tbaSsxXSwgbi5yaWdodCwgbi5fY291bnQpXG4gICAgfSBlbHNlIHtcbiAgICAgIGNzdGFja1tpXSA9IG5ldyBSQk5vZGUobi5fY29sb3IsIG4ua2V5LCBuLnZhbHVlLCBuLmxlZnQsIGNzdGFja1tpKzFdLCBuLl9jb3VudClcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5ldyBSZWRCbGFja1RyZWUodGhpcy50cmVlLl9jb21wYXJlLCBjc3RhY2tbMF0pXG59XG5cbi8vTW92ZXMgaXRlcmF0b3IgYmFja3dhcmQgb25lIGVsZW1lbnRcbmlwcm90by5wcmV2ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzdGFjayA9IHRoaXMuX3N0YWNrXG4gIGlmKHN0YWNrLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVyblxuICB9XG4gIHZhciBuID0gc3RhY2tbc3RhY2subGVuZ3RoLTFdXG4gIGlmKG4ubGVmdCkge1xuICAgIG4gPSBuLmxlZnRcbiAgICB3aGlsZShuKSB7XG4gICAgICBzdGFjay5wdXNoKG4pXG4gICAgICBuID0gbi5yaWdodFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBzdGFjay5wb3AoKVxuICAgIHdoaWxlKHN0YWNrLmxlbmd0aCA+IDAgJiYgc3RhY2tbc3RhY2subGVuZ3RoLTFdLmxlZnQgPT09IG4pIHtcbiAgICAgIG4gPSBzdGFja1tzdGFjay5sZW5ndGgtMV1cbiAgICAgIHN0YWNrLnBvcCgpXG4gICAgfVxuICB9XG59XG5cbi8vQ2hlY2tzIGlmIGl0ZXJhdG9yIGlzIGF0IHN0YXJ0IG9mIHRyZWVcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShpcHJvdG8sIFwiaGFzUHJldlwiLCB7XG4gIGdldDogZnVuY3Rpb24oKSB7XG4gICAgdmFyIHN0YWNrID0gdGhpcy5fc3RhY2tcbiAgICBpZihzdGFjay5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgICBpZihzdGFja1tzdGFjay5sZW5ndGgtMV0ubGVmdCkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgZm9yKHZhciBzPXN0YWNrLmxlbmd0aC0xOyBzPjA7IC0tcykge1xuICAgICAgaWYoc3RhY2tbcy0xXS5yaWdodCA9PT0gc3RhY2tbc10pIHtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn0pXG5cbi8vRGVmYXVsdCBjb21wYXJpc29uIGZ1bmN0aW9uXG5mdW5jdGlvbiBkZWZhdWx0Q29tcGFyZShhLCBiKSB7XG4gIGlmKGEgPCBiKSB7XG4gICAgcmV0dXJuIC0xXG4gIH1cbiAgaWYoYSA+IGIpIHtcbiAgICByZXR1cm4gMVxuICB9XG4gIHJldHVybiAwXG59XG5cbi8vQnVpbGQgYSB0cmVlXG5mdW5jdGlvbiBjcmVhdGVSQlRyZWUoY29tcGFyZSkge1xuICByZXR1cm4gbmV3IFJlZEJsYWNrVHJlZShjb21wYXJlIHx8IGRlZmF1bHRDb21wYXJlLCBudWxsKVxufSIsIi8vIHRyYW5zbGl0ZXJhdGVkIGZyb20gdGhlIHB5dGhvbiBzbmlwcGV0IGhlcmU6XG4vLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xhbmN6b3NfYXBwcm94aW1hdGlvblxuXG52YXIgZyA9IDc7XG52YXIgcCA9IFtcbiAgICAwLjk5OTk5OTk5OTk5OTgwOTkzLFxuICAgIDY3Ni41MjAzNjgxMjE4ODUxLFxuICAgIC0xMjU5LjEzOTIxNjcyMjQwMjgsXG4gICAgNzcxLjMyMzQyODc3NzY1MzEzLFxuICAgIC0xNzYuNjE1MDI5MTYyMTQwNTksXG4gICAgMTIuNTA3MzQzMjc4Njg2OTA1LFxuICAgIC0wLjEzODU3MTA5NTI2NTcyMDEyLFxuICAgIDkuOTg0MzY5NTc4MDE5NTcxNmUtNixcbiAgICAxLjUwNTYzMjczNTE0OTMxMTZlLTdcbl07XG5cbnZhciBnX2xuID0gNjA3LzEyODtcbnZhciBwX2xuID0gW1xuICAgIDAuOTk5OTk5OTk5OTk5OTk3MDkxODIsXG4gICAgNTcuMTU2MjM1NjY1ODYyOTIzNTE3LFxuICAgIC01OS41OTc5NjAzNTU0NzU0OTEyNDgsXG4gICAgMTQuMTM2MDk3OTc0NzQxNzQ3MTc0LFxuICAgIC0wLjQ5MTkxMzgxNjA5NzYyMDE5OTc4LFxuICAgIDAuMzM5OTQ2NDk5ODQ4MTE4ODg2OTllLTQsXG4gICAgMC40NjUyMzYyODkyNzA0ODU3NTY2NWUtNCxcbiAgICAtMC45ODM3NDQ3NTMwNDg3OTU2NDY3N2UtNCxcbiAgICAwLjE1ODA4ODcwMzIyNDkxMjQ4ODg0ZS0zLFxuICAgIC0wLjIxMDI2NDQ0MTcyNDEwNDg4MzE5ZS0zLFxuICAgIDAuMjE3NDM5NjE4MTE1MjEyNjQzMjBlLTMsXG4gICAgLTAuMTY0MzE4MTA2NTM2NzYzODkwMjJlLTMsXG4gICAgMC44NDQxODIyMzk4Mzg1Mjc0MzI5M2UtNCxcbiAgICAtMC4yNjE5MDgzODQwMTU4MTQwODY3MGUtNCxcbiAgICAwLjM2ODk5MTgyNjU5NTMxNjIyNzA0ZS01XG5dO1xuXG4vLyBTcG91Z2UgYXBwcm94aW1hdGlvbiAoc3VpdGFibGUgZm9yIGxhcmdlIGFyZ3VtZW50cylcbmZ1bmN0aW9uIGxuZ2FtbWEoeikge1xuXG4gICAgaWYoeiA8IDApIHJldHVybiBOdW1iZXIoJzAvMCcpO1xuICAgIHZhciB4ID0gcF9sblswXTtcbiAgICBmb3IodmFyIGkgPSBwX2xuLmxlbmd0aCAtIDE7IGkgPiAwOyAtLWkpIHggKz0gcF9sbltpXSAvICh6ICsgaSk7XG4gICAgdmFyIHQgPSB6ICsgZ19sbiArIDAuNTtcbiAgICByZXR1cm4gLjUqTWF0aC5sb2coMipNYXRoLlBJKSsoeisuNSkqTWF0aC5sb2codCktdCtNYXRoLmxvZyh4KS1NYXRoLmxvZyh6KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnYW1tYSAoeikge1xuICAgIGlmICh6IDwgMC41KSB7XG4gICAgICAgIHJldHVybiBNYXRoLlBJIC8gKE1hdGguc2luKE1hdGguUEkgKiB6KSAqIGdhbW1hKDEgLSB6KSk7XG4gICAgfVxuICAgIGVsc2UgaWYoeiA+IDEwMCkgcmV0dXJuIE1hdGguZXhwKGxuZ2FtbWEoeikpO1xuICAgIGVsc2Uge1xuICAgICAgICB6IC09IDE7XG4gICAgICAgIHZhciB4ID0gcFswXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBnICsgMjsgaSsrKSB7XG4gICAgICAgICAgICB4ICs9IHBbaV0gLyAoeiArIGkpO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0ID0geiArIGcgKyAwLjU7XG5cbiAgICAgICAgcmV0dXJuIE1hdGguc3FydCgyICogTWF0aC5QSSlcbiAgICAgICAgICAgICogTWF0aC5wb3codCwgeiArIDAuNSlcbiAgICAgICAgICAgICogTWF0aC5leHAoLXQpXG4gICAgICAgICAgICAqIHhcbiAgICAgICAgO1xuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzLmxvZyA9IGxuZ2FtbWE7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGFkam9pbnQ7XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgYWRqdWdhdGUgb2YgYSBtYXQ0XG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5mdW5jdGlvbiBhZGpvaW50KG91dCwgYSkge1xuICAgIHZhciBhMDAgPSBhWzBdLCBhMDEgPSBhWzFdLCBhMDIgPSBhWzJdLCBhMDMgPSBhWzNdLFxuICAgICAgICBhMTAgPSBhWzRdLCBhMTEgPSBhWzVdLCBhMTIgPSBhWzZdLCBhMTMgPSBhWzddLFxuICAgICAgICBhMjAgPSBhWzhdLCBhMjEgPSBhWzldLCBhMjIgPSBhWzEwXSwgYTIzID0gYVsxMV0sXG4gICAgICAgIGEzMCA9IGFbMTJdLCBhMzEgPSBhWzEzXSwgYTMyID0gYVsxNF0sIGEzMyA9IGFbMTVdO1xuXG4gICAgb3V0WzBdICA9ICAoYTExICogKGEyMiAqIGEzMyAtIGEyMyAqIGEzMikgLSBhMjEgKiAoYTEyICogYTMzIC0gYTEzICogYTMyKSArIGEzMSAqIChhMTIgKiBhMjMgLSBhMTMgKiBhMjIpKTtcbiAgICBvdXRbMV0gID0gLShhMDEgKiAoYTIyICogYTMzIC0gYTIzICogYTMyKSAtIGEyMSAqIChhMDIgKiBhMzMgLSBhMDMgKiBhMzIpICsgYTMxICogKGEwMiAqIGEyMyAtIGEwMyAqIGEyMikpO1xuICAgIG91dFsyXSAgPSAgKGEwMSAqIChhMTIgKiBhMzMgLSBhMTMgKiBhMzIpIC0gYTExICogKGEwMiAqIGEzMyAtIGEwMyAqIGEzMikgKyBhMzEgKiAoYTAyICogYTEzIC0gYTAzICogYTEyKSk7XG4gICAgb3V0WzNdICA9IC0oYTAxICogKGExMiAqIGEyMyAtIGExMyAqIGEyMikgLSBhMTEgKiAoYTAyICogYTIzIC0gYTAzICogYTIyKSArIGEyMSAqIChhMDIgKiBhMTMgLSBhMDMgKiBhMTIpKTtcbiAgICBvdXRbNF0gID0gLShhMTAgKiAoYTIyICogYTMzIC0gYTIzICogYTMyKSAtIGEyMCAqIChhMTIgKiBhMzMgLSBhMTMgKiBhMzIpICsgYTMwICogKGExMiAqIGEyMyAtIGExMyAqIGEyMikpO1xuICAgIG91dFs1XSAgPSAgKGEwMCAqIChhMjIgKiBhMzMgLSBhMjMgKiBhMzIpIC0gYTIwICogKGEwMiAqIGEzMyAtIGEwMyAqIGEzMikgKyBhMzAgKiAoYTAyICogYTIzIC0gYTAzICogYTIyKSk7XG4gICAgb3V0WzZdICA9IC0oYTAwICogKGExMiAqIGEzMyAtIGExMyAqIGEzMikgLSBhMTAgKiAoYTAyICogYTMzIC0gYTAzICogYTMyKSArIGEzMCAqIChhMDIgKiBhMTMgLSBhMDMgKiBhMTIpKTtcbiAgICBvdXRbN10gID0gIChhMDAgKiAoYTEyICogYTIzIC0gYTEzICogYTIyKSAtIGExMCAqIChhMDIgKiBhMjMgLSBhMDMgKiBhMjIpICsgYTIwICogKGEwMiAqIGExMyAtIGEwMyAqIGExMikpO1xuICAgIG91dFs4XSAgPSAgKGExMCAqIChhMjEgKiBhMzMgLSBhMjMgKiBhMzEpIC0gYTIwICogKGExMSAqIGEzMyAtIGExMyAqIGEzMSkgKyBhMzAgKiAoYTExICogYTIzIC0gYTEzICogYTIxKSk7XG4gICAgb3V0WzldICA9IC0oYTAwICogKGEyMSAqIGEzMyAtIGEyMyAqIGEzMSkgLSBhMjAgKiAoYTAxICogYTMzIC0gYTAzICogYTMxKSArIGEzMCAqIChhMDEgKiBhMjMgLSBhMDMgKiBhMjEpKTtcbiAgICBvdXRbMTBdID0gIChhMDAgKiAoYTExICogYTMzIC0gYTEzICogYTMxKSAtIGExMCAqIChhMDEgKiBhMzMgLSBhMDMgKiBhMzEpICsgYTMwICogKGEwMSAqIGExMyAtIGEwMyAqIGExMSkpO1xuICAgIG91dFsxMV0gPSAtKGEwMCAqIChhMTEgKiBhMjMgLSBhMTMgKiBhMjEpIC0gYTEwICogKGEwMSAqIGEyMyAtIGEwMyAqIGEyMSkgKyBhMjAgKiAoYTAxICogYTEzIC0gYTAzICogYTExKSk7XG4gICAgb3V0WzEyXSA9IC0oYTEwICogKGEyMSAqIGEzMiAtIGEyMiAqIGEzMSkgLSBhMjAgKiAoYTExICogYTMyIC0gYTEyICogYTMxKSArIGEzMCAqIChhMTEgKiBhMjIgLSBhMTIgKiBhMjEpKTtcbiAgICBvdXRbMTNdID0gIChhMDAgKiAoYTIxICogYTMyIC0gYTIyICogYTMxKSAtIGEyMCAqIChhMDEgKiBhMzIgLSBhMDIgKiBhMzEpICsgYTMwICogKGEwMSAqIGEyMiAtIGEwMiAqIGEyMSkpO1xuICAgIG91dFsxNF0gPSAtKGEwMCAqIChhMTEgKiBhMzIgLSBhMTIgKiBhMzEpIC0gYTEwICogKGEwMSAqIGEzMiAtIGEwMiAqIGEzMSkgKyBhMzAgKiAoYTAxICogYTEyIC0gYTAyICogYTExKSk7XG4gICAgb3V0WzE1XSA9ICAoYTAwICogKGExMSAqIGEyMiAtIGExMiAqIGEyMSkgLSBhMTAgKiAoYTAxICogYTIyIC0gYTAyICogYTIxKSArIGEyMCAqIChhMDEgKiBhMTIgLSBhMDIgKiBhMTEpKTtcbiAgICByZXR1cm4gb3V0O1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IGNsb25lO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgbWF0NCBpbml0aWFsaXplZCB3aXRoIHZhbHVlcyBmcm9tIGFuIGV4aXN0aW5nIG1hdHJpeFxuICpcbiAqIEBwYXJhbSB7bWF0NH0gYSBtYXRyaXggdG8gY2xvbmVcbiAqIEByZXR1cm5zIHttYXQ0fSBhIG5ldyA0eDQgbWF0cml4XG4gKi9cbmZ1bmN0aW9uIGNsb25lKGEpIHtcbiAgICB2YXIgb3V0ID0gbmV3IEZsb2F0MzJBcnJheSgxNik7XG4gICAgb3V0WzBdID0gYVswXTtcbiAgICBvdXRbMV0gPSBhWzFdO1xuICAgIG91dFsyXSA9IGFbMl07XG4gICAgb3V0WzNdID0gYVszXTtcbiAgICBvdXRbNF0gPSBhWzRdO1xuICAgIG91dFs1XSA9IGFbNV07XG4gICAgb3V0WzZdID0gYVs2XTtcbiAgICBvdXRbN10gPSBhWzddO1xuICAgIG91dFs4XSA9IGFbOF07XG4gICAgb3V0WzldID0gYVs5XTtcbiAgICBvdXRbMTBdID0gYVsxMF07XG4gICAgb3V0WzExXSA9IGFbMTFdO1xuICAgIG91dFsxMl0gPSBhWzEyXTtcbiAgICBvdXRbMTNdID0gYVsxM107XG4gICAgb3V0WzE0XSA9IGFbMTRdO1xuICAgIG91dFsxNV0gPSBhWzE1XTtcbiAgICByZXR1cm4gb3V0O1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IGNvcHk7XG5cbi8qKlxuICogQ29weSB0aGUgdmFsdWVzIGZyb20gb25lIG1hdDQgdG8gYW5vdGhlclxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuZnVuY3Rpb24gY29weShvdXQsIGEpIHtcbiAgICBvdXRbMF0gPSBhWzBdO1xuICAgIG91dFsxXSA9IGFbMV07XG4gICAgb3V0WzJdID0gYVsyXTtcbiAgICBvdXRbM10gPSBhWzNdO1xuICAgIG91dFs0XSA9IGFbNF07XG4gICAgb3V0WzVdID0gYVs1XTtcbiAgICBvdXRbNl0gPSBhWzZdO1xuICAgIG91dFs3XSA9IGFbN107XG4gICAgb3V0WzhdID0gYVs4XTtcbiAgICBvdXRbOV0gPSBhWzldO1xuICAgIG91dFsxMF0gPSBhWzEwXTtcbiAgICBvdXRbMTFdID0gYVsxMV07XG4gICAgb3V0WzEyXSA9IGFbMTJdO1xuICAgIG91dFsxM10gPSBhWzEzXTtcbiAgICBvdXRbMTRdID0gYVsxNF07XG4gICAgb3V0WzE1XSA9IGFbMTVdO1xuICAgIHJldHVybiBvdXQ7XG59OyIsIm1vZHVsZS5leHBvcnRzID0gY3JlYXRlO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgaWRlbnRpdHkgbWF0NFxuICpcbiAqIEByZXR1cm5zIHttYXQ0fSBhIG5ldyA0eDQgbWF0cml4XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZSgpIHtcbiAgICB2YXIgb3V0ID0gbmV3IEZsb2F0MzJBcnJheSgxNik7XG4gICAgb3V0WzBdID0gMTtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgb3V0WzNdID0gMDtcbiAgICBvdXRbNF0gPSAwO1xuICAgIG91dFs1XSA9IDE7XG4gICAgb3V0WzZdID0gMDtcbiAgICBvdXRbN10gPSAwO1xuICAgIG91dFs4XSA9IDA7XG4gICAgb3V0WzldID0gMDtcbiAgICBvdXRbMTBdID0gMTtcbiAgICBvdXRbMTFdID0gMDtcbiAgICBvdXRbMTJdID0gMDtcbiAgICBvdXRbMTNdID0gMDtcbiAgICBvdXRbMTRdID0gMDtcbiAgICBvdXRbMTVdID0gMTtcbiAgICByZXR1cm4gb3V0O1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IGRldGVybWluYW50O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGRldGVybWluYW50IG9mIGEgbWF0NFxuICpcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge051bWJlcn0gZGV0ZXJtaW5hbnQgb2YgYVxuICovXG5mdW5jdGlvbiBkZXRlcm1pbmFudChhKSB7XG4gICAgdmFyIGEwMCA9IGFbMF0sIGEwMSA9IGFbMV0sIGEwMiA9IGFbMl0sIGEwMyA9IGFbM10sXG4gICAgICAgIGExMCA9IGFbNF0sIGExMSA9IGFbNV0sIGExMiA9IGFbNl0sIGExMyA9IGFbN10sXG4gICAgICAgIGEyMCA9IGFbOF0sIGEyMSA9IGFbOV0sIGEyMiA9IGFbMTBdLCBhMjMgPSBhWzExXSxcbiAgICAgICAgYTMwID0gYVsxMl0sIGEzMSA9IGFbMTNdLCBhMzIgPSBhWzE0XSwgYTMzID0gYVsxNV0sXG5cbiAgICAgICAgYjAwID0gYTAwICogYTExIC0gYTAxICogYTEwLFxuICAgICAgICBiMDEgPSBhMDAgKiBhMTIgLSBhMDIgKiBhMTAsXG4gICAgICAgIGIwMiA9IGEwMCAqIGExMyAtIGEwMyAqIGExMCxcbiAgICAgICAgYjAzID0gYTAxICogYTEyIC0gYTAyICogYTExLFxuICAgICAgICBiMDQgPSBhMDEgKiBhMTMgLSBhMDMgKiBhMTEsXG4gICAgICAgIGIwNSA9IGEwMiAqIGExMyAtIGEwMyAqIGExMixcbiAgICAgICAgYjA2ID0gYTIwICogYTMxIC0gYTIxICogYTMwLFxuICAgICAgICBiMDcgPSBhMjAgKiBhMzIgLSBhMjIgKiBhMzAsXG4gICAgICAgIGIwOCA9IGEyMCAqIGEzMyAtIGEyMyAqIGEzMCxcbiAgICAgICAgYjA5ID0gYTIxICogYTMyIC0gYTIyICogYTMxLFxuICAgICAgICBiMTAgPSBhMjEgKiBhMzMgLSBhMjMgKiBhMzEsXG4gICAgICAgIGIxMSA9IGEyMiAqIGEzMyAtIGEyMyAqIGEzMjtcblxuICAgIC8vIENhbGN1bGF0ZSB0aGUgZGV0ZXJtaW5hbnRcbiAgICByZXR1cm4gYjAwICogYjExIC0gYjAxICogYjEwICsgYjAyICogYjA5ICsgYjAzICogYjA4IC0gYjA0ICogYjA3ICsgYjA1ICogYjA2O1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IGZyb21RdWF0O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSBhIHF1YXRlcm5pb24gcm90YXRpb24uXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHtxdWF0NH0gcSBSb3RhdGlvbiBxdWF0ZXJuaW9uXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbmZ1bmN0aW9uIGZyb21RdWF0KG91dCwgcSkge1xuICAgIHZhciB4ID0gcVswXSwgeSA9IHFbMV0sIHogPSBxWzJdLCB3ID0gcVszXSxcbiAgICAgICAgeDIgPSB4ICsgeCxcbiAgICAgICAgeTIgPSB5ICsgeSxcbiAgICAgICAgejIgPSB6ICsgeixcblxuICAgICAgICB4eCA9IHggKiB4MixcbiAgICAgICAgeXggPSB5ICogeDIsXG4gICAgICAgIHl5ID0geSAqIHkyLFxuICAgICAgICB6eCA9IHogKiB4MixcbiAgICAgICAgenkgPSB6ICogeTIsXG4gICAgICAgIHp6ID0geiAqIHoyLFxuICAgICAgICB3eCA9IHcgKiB4MixcbiAgICAgICAgd3kgPSB3ICogeTIsXG4gICAgICAgIHd6ID0gdyAqIHoyO1xuXG4gICAgb3V0WzBdID0gMSAtIHl5IC0geno7XG4gICAgb3V0WzFdID0geXggKyB3ejtcbiAgICBvdXRbMl0gPSB6eCAtIHd5O1xuICAgIG91dFszXSA9IDA7XG5cbiAgICBvdXRbNF0gPSB5eCAtIHd6O1xuICAgIG91dFs1XSA9IDEgLSB4eCAtIHp6O1xuICAgIG91dFs2XSA9IHp5ICsgd3g7XG4gICAgb3V0WzddID0gMDtcblxuICAgIG91dFs4XSA9IHp4ICsgd3k7XG4gICAgb3V0WzldID0genkgLSB3eDtcbiAgICBvdXRbMTBdID0gMSAtIHh4IC0geXk7XG4gICAgb3V0WzExXSA9IDA7XG5cbiAgICBvdXRbMTJdID0gMDtcbiAgICBvdXRbMTNdID0gMDtcbiAgICBvdXRbMTRdID0gMDtcbiAgICBvdXRbMTVdID0gMTtcblxuICAgIHJldHVybiBvdXQ7XG59OyIsIm1vZHVsZS5leHBvcnRzID0gZnJvbVJvdGF0aW9uXG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIGEgZ2l2ZW4gYW5nbGUgYXJvdW5kIGEgZ2l2ZW4gYXhpc1xuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XG4gKlxuICogICAgIG1hdDQuaWRlbnRpdHkoZGVzdClcbiAqICAgICBtYXQ0LnJvdGF0ZShkZXN0LCBkZXN0LCByYWQsIGF4aXMpXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcbiAqIEBwYXJhbSB7dmVjM30gYXhpcyB0aGUgYXhpcyB0byByb3RhdGUgYXJvdW5kXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbmZ1bmN0aW9uIGZyb21Sb3RhdGlvbihvdXQsIHJhZCwgYXhpcykge1xuICB2YXIgcywgYywgdFxuICB2YXIgeCA9IGF4aXNbMF1cbiAgdmFyIHkgPSBheGlzWzFdXG4gIHZhciB6ID0gYXhpc1syXVxuICB2YXIgbGVuID0gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkgKyB6ICogeilcblxuICBpZiAoTWF0aC5hYnMobGVuKSA8IDAuMDAwMDAxKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIGxlbiA9IDEgLyBsZW5cbiAgeCAqPSBsZW5cbiAgeSAqPSBsZW5cbiAgeiAqPSBsZW5cblxuICBzID0gTWF0aC5zaW4ocmFkKVxuICBjID0gTWF0aC5jb3MocmFkKVxuICB0ID0gMSAtIGNcblxuICAvLyBQZXJmb3JtIHJvdGF0aW9uLXNwZWNpZmljIG1hdHJpeCBtdWx0aXBsaWNhdGlvblxuICBvdXRbMF0gPSB4ICogeCAqIHQgKyBjXG4gIG91dFsxXSA9IHkgKiB4ICogdCArIHogKiBzXG4gIG91dFsyXSA9IHogKiB4ICogdCAtIHkgKiBzXG4gIG91dFszXSA9IDBcbiAgb3V0WzRdID0geCAqIHkgKiB0IC0geiAqIHNcbiAgb3V0WzVdID0geSAqIHkgKiB0ICsgY1xuICBvdXRbNl0gPSB6ICogeSAqIHQgKyB4ICogc1xuICBvdXRbN10gPSAwXG4gIG91dFs4XSA9IHggKiB6ICogdCArIHkgKiBzXG4gIG91dFs5XSA9IHkgKiB6ICogdCAtIHggKiBzXG4gIG91dFsxMF0gPSB6ICogeiAqIHQgKyBjXG4gIG91dFsxMV0gPSAwXG4gIG91dFsxMl0gPSAwXG4gIG91dFsxM10gPSAwXG4gIG91dFsxNF0gPSAwXG4gIG91dFsxNV0gPSAxXG4gIHJldHVybiBvdXRcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gZnJvbVJvdGF0aW9uVHJhbnNsYXRpb247XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIGEgcXVhdGVybmlvbiByb3RhdGlvbiBhbmQgdmVjdG9yIHRyYW5zbGF0aW9uXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcbiAqXG4gKiAgICAgbWF0NC5pZGVudGl0eShkZXN0KTtcbiAqICAgICBtYXQ0LnRyYW5zbGF0ZShkZXN0LCB2ZWMpO1xuICogICAgIHZhciBxdWF0TWF0ID0gbWF0NC5jcmVhdGUoKTtcbiAqICAgICBxdWF0NC50b01hdDQocXVhdCwgcXVhdE1hdCk7XG4gKiAgICAgbWF0NC5tdWx0aXBseShkZXN0LCBxdWF0TWF0KTtcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge3F1YXQ0fSBxIFJvdGF0aW9uIHF1YXRlcm5pb25cbiAqIEBwYXJhbSB7dmVjM30gdiBUcmFuc2xhdGlvbiB2ZWN0b3JcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuZnVuY3Rpb24gZnJvbVJvdGF0aW9uVHJhbnNsYXRpb24ob3V0LCBxLCB2KSB7XG4gICAgLy8gUXVhdGVybmlvbiBtYXRoXG4gICAgdmFyIHggPSBxWzBdLCB5ID0gcVsxXSwgeiA9IHFbMl0sIHcgPSBxWzNdLFxuICAgICAgICB4MiA9IHggKyB4LFxuICAgICAgICB5MiA9IHkgKyB5LFxuICAgICAgICB6MiA9IHogKyB6LFxuXG4gICAgICAgIHh4ID0geCAqIHgyLFxuICAgICAgICB4eSA9IHggKiB5MixcbiAgICAgICAgeHogPSB4ICogejIsXG4gICAgICAgIHl5ID0geSAqIHkyLFxuICAgICAgICB5eiA9IHkgKiB6MixcbiAgICAgICAgenogPSB6ICogejIsXG4gICAgICAgIHd4ID0gdyAqIHgyLFxuICAgICAgICB3eSA9IHcgKiB5MixcbiAgICAgICAgd3ogPSB3ICogejI7XG5cbiAgICBvdXRbMF0gPSAxIC0gKHl5ICsgenopO1xuICAgIG91dFsxXSA9IHh5ICsgd3o7XG4gICAgb3V0WzJdID0geHogLSB3eTtcbiAgICBvdXRbM10gPSAwO1xuICAgIG91dFs0XSA9IHh5IC0gd3o7XG4gICAgb3V0WzVdID0gMSAtICh4eCArIHp6KTtcbiAgICBvdXRbNl0gPSB5eiArIHd4O1xuICAgIG91dFs3XSA9IDA7XG4gICAgb3V0WzhdID0geHogKyB3eTtcbiAgICBvdXRbOV0gPSB5eiAtIHd4O1xuICAgIG91dFsxMF0gPSAxIC0gKHh4ICsgeXkpO1xuICAgIG91dFsxMV0gPSAwO1xuICAgIG91dFsxMl0gPSB2WzBdO1xuICAgIG91dFsxM10gPSB2WzFdO1xuICAgIG91dFsxNF0gPSB2WzJdO1xuICAgIG91dFsxNV0gPSAxO1xuICAgIFxuICAgIHJldHVybiBvdXQ7XG59OyIsIm1vZHVsZS5leHBvcnRzID0gZnJvbVNjYWxpbmdcblxuLyoqXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gYSB2ZWN0b3Igc2NhbGluZ1xuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XG4gKlxuICogICAgIG1hdDQuaWRlbnRpdHkoZGVzdClcbiAqICAgICBtYXQ0LnNjYWxlKGRlc3QsIGRlc3QsIHZlYylcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge3ZlYzN9IHYgU2NhbGluZyB2ZWN0b3JcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuZnVuY3Rpb24gZnJvbVNjYWxpbmcob3V0LCB2KSB7XG4gIG91dFswXSA9IHZbMF1cbiAgb3V0WzFdID0gMFxuICBvdXRbMl0gPSAwXG4gIG91dFszXSA9IDBcbiAgb3V0WzRdID0gMFxuICBvdXRbNV0gPSB2WzFdXG4gIG91dFs2XSA9IDBcbiAgb3V0WzddID0gMFxuICBvdXRbOF0gPSAwXG4gIG91dFs5XSA9IDBcbiAgb3V0WzEwXSA9IHZbMl1cbiAgb3V0WzExXSA9IDBcbiAgb3V0WzEyXSA9IDBcbiAgb3V0WzEzXSA9IDBcbiAgb3V0WzE0XSA9IDBcbiAgb3V0WzE1XSA9IDFcbiAgcmV0dXJuIG91dFxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBmcm9tVHJhbnNsYXRpb25cblxuLyoqXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gYSB2ZWN0b3IgdHJhbnNsYXRpb25cbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxuICpcbiAqICAgICBtYXQ0LmlkZW50aXR5KGRlc3QpXG4gKiAgICAgbWF0NC50cmFuc2xhdGUoZGVzdCwgZGVzdCwgdmVjKVxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7dmVjM30gdiBUcmFuc2xhdGlvbiB2ZWN0b3JcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuZnVuY3Rpb24gZnJvbVRyYW5zbGF0aW9uKG91dCwgdikge1xuICBvdXRbMF0gPSAxXG4gIG91dFsxXSA9IDBcbiAgb3V0WzJdID0gMFxuICBvdXRbM10gPSAwXG4gIG91dFs0XSA9IDBcbiAgb3V0WzVdID0gMVxuICBvdXRbNl0gPSAwXG4gIG91dFs3XSA9IDBcbiAgb3V0WzhdID0gMFxuICBvdXRbOV0gPSAwXG4gIG91dFsxMF0gPSAxXG4gIG91dFsxMV0gPSAwXG4gIG91dFsxMl0gPSB2WzBdXG4gIG91dFsxM10gPSB2WzFdXG4gIG91dFsxNF0gPSB2WzJdXG4gIG91dFsxNV0gPSAxXG4gIHJldHVybiBvdXRcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gZnJvbVhSb3RhdGlvblxuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSB0aGUgZ2l2ZW4gYW5nbGUgYXJvdW5kIHRoZSBYIGF4aXNcbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxuICpcbiAqICAgICBtYXQ0LmlkZW50aXR5KGRlc3QpXG4gKiAgICAgbWF0NC5yb3RhdGVYKGRlc3QsIGRlc3QsIHJhZClcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5mdW5jdGlvbiBmcm9tWFJvdGF0aW9uKG91dCwgcmFkKSB7XG4gICAgdmFyIHMgPSBNYXRoLnNpbihyYWQpLFxuICAgICAgICBjID0gTWF0aC5jb3MocmFkKVxuXG4gICAgLy8gUGVyZm9ybSBheGlzLXNwZWNpZmljIG1hdHJpeCBtdWx0aXBsaWNhdGlvblxuICAgIG91dFswXSA9IDFcbiAgICBvdXRbMV0gPSAwXG4gICAgb3V0WzJdID0gMFxuICAgIG91dFszXSA9IDBcbiAgICBvdXRbNF0gPSAwXG4gICAgb3V0WzVdID0gY1xuICAgIG91dFs2XSA9IHNcbiAgICBvdXRbN10gPSAwXG4gICAgb3V0WzhdID0gMFxuICAgIG91dFs5XSA9IC1zXG4gICAgb3V0WzEwXSA9IGNcbiAgICBvdXRbMTFdID0gMFxuICAgIG91dFsxMl0gPSAwXG4gICAgb3V0WzEzXSA9IDBcbiAgICBvdXRbMTRdID0gMFxuICAgIG91dFsxNV0gPSAxXG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gZnJvbVlSb3RhdGlvblxuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSB0aGUgZ2l2ZW4gYW5nbGUgYXJvdW5kIHRoZSBZIGF4aXNcbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxuICpcbiAqICAgICBtYXQ0LmlkZW50aXR5KGRlc3QpXG4gKiAgICAgbWF0NC5yb3RhdGVZKGRlc3QsIGRlc3QsIHJhZClcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5mdW5jdGlvbiBmcm9tWVJvdGF0aW9uKG91dCwgcmFkKSB7XG4gICAgdmFyIHMgPSBNYXRoLnNpbihyYWQpLFxuICAgICAgICBjID0gTWF0aC5jb3MocmFkKVxuXG4gICAgLy8gUGVyZm9ybSBheGlzLXNwZWNpZmljIG1hdHJpeCBtdWx0aXBsaWNhdGlvblxuICAgIG91dFswXSA9IGNcbiAgICBvdXRbMV0gPSAwXG4gICAgb3V0WzJdID0gLXNcbiAgICBvdXRbM10gPSAwXG4gICAgb3V0WzRdID0gMFxuICAgIG91dFs1XSA9IDFcbiAgICBvdXRbNl0gPSAwXG4gICAgb3V0WzddID0gMFxuICAgIG91dFs4XSA9IHNcbiAgICBvdXRbOV0gPSAwXG4gICAgb3V0WzEwXSA9IGNcbiAgICBvdXRbMTFdID0gMFxuICAgIG91dFsxMl0gPSAwXG4gICAgb3V0WzEzXSA9IDBcbiAgICBvdXRbMTRdID0gMFxuICAgIG91dFsxNV0gPSAxXG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gZnJvbVpSb3RhdGlvblxuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSB0aGUgZ2l2ZW4gYW5nbGUgYXJvdW5kIHRoZSBaIGF4aXNcbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxuICpcbiAqICAgICBtYXQ0LmlkZW50aXR5KGRlc3QpXG4gKiAgICAgbWF0NC5yb3RhdGVaKGRlc3QsIGRlc3QsIHJhZClcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5mdW5jdGlvbiBmcm9tWlJvdGF0aW9uKG91dCwgcmFkKSB7XG4gICAgdmFyIHMgPSBNYXRoLnNpbihyYWQpLFxuICAgICAgICBjID0gTWF0aC5jb3MocmFkKVxuXG4gICAgLy8gUGVyZm9ybSBheGlzLXNwZWNpZmljIG1hdHJpeCBtdWx0aXBsaWNhdGlvblxuICAgIG91dFswXSA9IGNcbiAgICBvdXRbMV0gPSBzXG4gICAgb3V0WzJdID0gMFxuICAgIG91dFszXSA9IDBcbiAgICBvdXRbNF0gPSAtc1xuICAgIG91dFs1XSA9IGNcbiAgICBvdXRbNl0gPSAwXG4gICAgb3V0WzddID0gMFxuICAgIG91dFs4XSA9IDBcbiAgICBvdXRbOV0gPSAwXG4gICAgb3V0WzEwXSA9IDFcbiAgICBvdXRbMTFdID0gMFxuICAgIG91dFsxMl0gPSAwXG4gICAgb3V0WzEzXSA9IDBcbiAgICBvdXRbMTRdID0gMFxuICAgIG91dFsxNV0gPSAxXG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gZnJ1c3R1bTtcblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSBmcnVzdHVtIG1hdHJpeCB3aXRoIHRoZSBnaXZlbiBib3VuZHNcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IGZydXN0dW0gbWF0cml4IHdpbGwgYmUgd3JpdHRlbiBpbnRvXG4gKiBAcGFyYW0ge051bWJlcn0gbGVmdCBMZWZ0IGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcGFyYW0ge051bWJlcn0gcmlnaHQgUmlnaHQgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEBwYXJhbSB7TnVtYmVyfSBib3R0b20gQm90dG9tIGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcGFyYW0ge051bWJlcn0gdG9wIFRvcCBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtOdW1iZXJ9IG5lYXIgTmVhciBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtOdW1iZXJ9IGZhciBGYXIgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuZnVuY3Rpb24gZnJ1c3R1bShvdXQsIGxlZnQsIHJpZ2h0LCBib3R0b20sIHRvcCwgbmVhciwgZmFyKSB7XG4gICAgdmFyIHJsID0gMSAvIChyaWdodCAtIGxlZnQpLFxuICAgICAgICB0YiA9IDEgLyAodG9wIC0gYm90dG9tKSxcbiAgICAgICAgbmYgPSAxIC8gKG5lYXIgLSBmYXIpO1xuICAgIG91dFswXSA9IChuZWFyICogMikgKiBybDtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgb3V0WzNdID0gMDtcbiAgICBvdXRbNF0gPSAwO1xuICAgIG91dFs1XSA9IChuZWFyICogMikgKiB0YjtcbiAgICBvdXRbNl0gPSAwO1xuICAgIG91dFs3XSA9IDA7XG4gICAgb3V0WzhdID0gKHJpZ2h0ICsgbGVmdCkgKiBybDtcbiAgICBvdXRbOV0gPSAodG9wICsgYm90dG9tKSAqIHRiO1xuICAgIG91dFsxMF0gPSAoZmFyICsgbmVhcikgKiBuZjtcbiAgICBvdXRbMTFdID0gLTE7XG4gICAgb3V0WzEyXSA9IDA7XG4gICAgb3V0WzEzXSA9IDA7XG4gICAgb3V0WzE0XSA9IChmYXIgKiBuZWFyICogMikgKiBuZjtcbiAgICBvdXRbMTVdID0gMDtcbiAgICByZXR1cm4gb3V0O1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IGlkZW50aXR5O1xuXG4vKipcbiAqIFNldCBhIG1hdDQgdG8gdGhlIGlkZW50aXR5IG1hdHJpeFxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbmZ1bmN0aW9uIGlkZW50aXR5KG91dCkge1xuICAgIG91dFswXSA9IDE7XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICAgIG91dFszXSA9IDA7XG4gICAgb3V0WzRdID0gMDtcbiAgICBvdXRbNV0gPSAxO1xuICAgIG91dFs2XSA9IDA7XG4gICAgb3V0WzddID0gMDtcbiAgICBvdXRbOF0gPSAwO1xuICAgIG91dFs5XSA9IDA7XG4gICAgb3V0WzEwXSA9IDE7XG4gICAgb3V0WzExXSA9IDA7XG4gICAgb3V0WzEyXSA9IDA7XG4gICAgb3V0WzEzXSA9IDA7XG4gICAgb3V0WzE0XSA9IDA7XG4gICAgb3V0WzE1XSA9IDE7XG4gICAgcmV0dXJuIG91dDtcbn07IiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gIGNyZWF0ZTogcmVxdWlyZSgnLi9jcmVhdGUnKVxuICAsIGNsb25lOiByZXF1aXJlKCcuL2Nsb25lJylcbiAgLCBjb3B5OiByZXF1aXJlKCcuL2NvcHknKVxuICAsIGlkZW50aXR5OiByZXF1aXJlKCcuL2lkZW50aXR5JylcbiAgLCB0cmFuc3Bvc2U6IHJlcXVpcmUoJy4vdHJhbnNwb3NlJylcbiAgLCBpbnZlcnQ6IHJlcXVpcmUoJy4vaW52ZXJ0JylcbiAgLCBhZGpvaW50OiByZXF1aXJlKCcuL2Fkam9pbnQnKVxuICAsIGRldGVybWluYW50OiByZXF1aXJlKCcuL2RldGVybWluYW50JylcbiAgLCBtdWx0aXBseTogcmVxdWlyZSgnLi9tdWx0aXBseScpXG4gICwgdHJhbnNsYXRlOiByZXF1aXJlKCcuL3RyYW5zbGF0ZScpXG4gICwgc2NhbGU6IHJlcXVpcmUoJy4vc2NhbGUnKVxuICAsIHJvdGF0ZTogcmVxdWlyZSgnLi9yb3RhdGUnKVxuICAsIHJvdGF0ZVg6IHJlcXVpcmUoJy4vcm90YXRlWCcpXG4gICwgcm90YXRlWTogcmVxdWlyZSgnLi9yb3RhdGVZJylcbiAgLCByb3RhdGVaOiByZXF1aXJlKCcuL3JvdGF0ZVonKVxuICAsIGZyb21Sb3RhdGlvbjogcmVxdWlyZSgnLi9mcm9tUm90YXRpb24nKVxuICAsIGZyb21Sb3RhdGlvblRyYW5zbGF0aW9uOiByZXF1aXJlKCcuL2Zyb21Sb3RhdGlvblRyYW5zbGF0aW9uJylcbiAgLCBmcm9tU2NhbGluZzogcmVxdWlyZSgnLi9mcm9tU2NhbGluZycpXG4gICwgZnJvbVRyYW5zbGF0aW9uOiByZXF1aXJlKCcuL2Zyb21UcmFuc2xhdGlvbicpXG4gICwgZnJvbVhSb3RhdGlvbjogcmVxdWlyZSgnLi9mcm9tWFJvdGF0aW9uJylcbiAgLCBmcm9tWVJvdGF0aW9uOiByZXF1aXJlKCcuL2Zyb21ZUm90YXRpb24nKVxuICAsIGZyb21aUm90YXRpb246IHJlcXVpcmUoJy4vZnJvbVpSb3RhdGlvbicpXG4gICwgZnJvbVF1YXQ6IHJlcXVpcmUoJy4vZnJvbVF1YXQnKVxuICAsIGZydXN0dW06IHJlcXVpcmUoJy4vZnJ1c3R1bScpXG4gICwgcGVyc3BlY3RpdmU6IHJlcXVpcmUoJy4vcGVyc3BlY3RpdmUnKVxuICAsIHBlcnNwZWN0aXZlRnJvbUZpZWxkT2ZWaWV3OiByZXF1aXJlKCcuL3BlcnNwZWN0aXZlRnJvbUZpZWxkT2ZWaWV3JylcbiAgLCBvcnRobzogcmVxdWlyZSgnLi9vcnRobycpXG4gICwgbG9va0F0OiByZXF1aXJlKCcuL2xvb2tBdCcpXG4gICwgc3RyOiByZXF1aXJlKCcuL3N0cicpXG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGludmVydDtcblxuLyoqXG4gKiBJbnZlcnRzIGEgbWF0NFxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuZnVuY3Rpb24gaW52ZXJ0KG91dCwgYSkge1xuICAgIHZhciBhMDAgPSBhWzBdLCBhMDEgPSBhWzFdLCBhMDIgPSBhWzJdLCBhMDMgPSBhWzNdLFxuICAgICAgICBhMTAgPSBhWzRdLCBhMTEgPSBhWzVdLCBhMTIgPSBhWzZdLCBhMTMgPSBhWzddLFxuICAgICAgICBhMjAgPSBhWzhdLCBhMjEgPSBhWzldLCBhMjIgPSBhWzEwXSwgYTIzID0gYVsxMV0sXG4gICAgICAgIGEzMCA9IGFbMTJdLCBhMzEgPSBhWzEzXSwgYTMyID0gYVsxNF0sIGEzMyA9IGFbMTVdLFxuXG4gICAgICAgIGIwMCA9IGEwMCAqIGExMSAtIGEwMSAqIGExMCxcbiAgICAgICAgYjAxID0gYTAwICogYTEyIC0gYTAyICogYTEwLFxuICAgICAgICBiMDIgPSBhMDAgKiBhMTMgLSBhMDMgKiBhMTAsXG4gICAgICAgIGIwMyA9IGEwMSAqIGExMiAtIGEwMiAqIGExMSxcbiAgICAgICAgYjA0ID0gYTAxICogYTEzIC0gYTAzICogYTExLFxuICAgICAgICBiMDUgPSBhMDIgKiBhMTMgLSBhMDMgKiBhMTIsXG4gICAgICAgIGIwNiA9IGEyMCAqIGEzMSAtIGEyMSAqIGEzMCxcbiAgICAgICAgYjA3ID0gYTIwICogYTMyIC0gYTIyICogYTMwLFxuICAgICAgICBiMDggPSBhMjAgKiBhMzMgLSBhMjMgKiBhMzAsXG4gICAgICAgIGIwOSA9IGEyMSAqIGEzMiAtIGEyMiAqIGEzMSxcbiAgICAgICAgYjEwID0gYTIxICogYTMzIC0gYTIzICogYTMxLFxuICAgICAgICBiMTEgPSBhMjIgKiBhMzMgLSBhMjMgKiBhMzIsXG5cbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBkZXRlcm1pbmFudFxuICAgICAgICBkZXQgPSBiMDAgKiBiMTEgLSBiMDEgKiBiMTAgKyBiMDIgKiBiMDkgKyBiMDMgKiBiMDggLSBiMDQgKiBiMDcgKyBiMDUgKiBiMDY7XG5cbiAgICBpZiAoIWRldCkgeyBcbiAgICAgICAgcmV0dXJuIG51bGw7IFxuICAgIH1cbiAgICBkZXQgPSAxLjAgLyBkZXQ7XG5cbiAgICBvdXRbMF0gPSAoYTExICogYjExIC0gYTEyICogYjEwICsgYTEzICogYjA5KSAqIGRldDtcbiAgICBvdXRbMV0gPSAoYTAyICogYjEwIC0gYTAxICogYjExIC0gYTAzICogYjA5KSAqIGRldDtcbiAgICBvdXRbMl0gPSAoYTMxICogYjA1IC0gYTMyICogYjA0ICsgYTMzICogYjAzKSAqIGRldDtcbiAgICBvdXRbM10gPSAoYTIyICogYjA0IC0gYTIxICogYjA1IC0gYTIzICogYjAzKSAqIGRldDtcbiAgICBvdXRbNF0gPSAoYTEyICogYjA4IC0gYTEwICogYjExIC0gYTEzICogYjA3KSAqIGRldDtcbiAgICBvdXRbNV0gPSAoYTAwICogYjExIC0gYTAyICogYjA4ICsgYTAzICogYjA3KSAqIGRldDtcbiAgICBvdXRbNl0gPSAoYTMyICogYjAyIC0gYTMwICogYjA1IC0gYTMzICogYjAxKSAqIGRldDtcbiAgICBvdXRbN10gPSAoYTIwICogYjA1IC0gYTIyICogYjAyICsgYTIzICogYjAxKSAqIGRldDtcbiAgICBvdXRbOF0gPSAoYTEwICogYjEwIC0gYTExICogYjA4ICsgYTEzICogYjA2KSAqIGRldDtcbiAgICBvdXRbOV0gPSAoYTAxICogYjA4IC0gYTAwICogYjEwIC0gYTAzICogYjA2KSAqIGRldDtcbiAgICBvdXRbMTBdID0gKGEzMCAqIGIwNCAtIGEzMSAqIGIwMiArIGEzMyAqIGIwMCkgKiBkZXQ7XG4gICAgb3V0WzExXSA9IChhMjEgKiBiMDIgLSBhMjAgKiBiMDQgLSBhMjMgKiBiMDApICogZGV0O1xuICAgIG91dFsxMl0gPSAoYTExICogYjA3IC0gYTEwICogYjA5IC0gYTEyICogYjA2KSAqIGRldDtcbiAgICBvdXRbMTNdID0gKGEwMCAqIGIwOSAtIGEwMSAqIGIwNyArIGEwMiAqIGIwNikgKiBkZXQ7XG4gICAgb3V0WzE0XSA9IChhMzEgKiBiMDEgLSBhMzAgKiBiMDMgLSBhMzIgKiBiMDApICogZGV0O1xuICAgIG91dFsxNV0gPSAoYTIwICogYjAzIC0gYTIxICogYjAxICsgYTIyICogYjAwKSAqIGRldDtcblxuICAgIHJldHVybiBvdXQ7XG59OyIsInZhciBpZGVudGl0eSA9IHJlcXVpcmUoJy4vaWRlbnRpdHknKTtcblxubW9kdWxlLmV4cG9ydHMgPSBsb29rQXQ7XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgbG9vay1hdCBtYXRyaXggd2l0aCB0aGUgZ2l2ZW4gZXllIHBvc2l0aW9uLCBmb2NhbCBwb2ludCwgYW5kIHVwIGF4aXNcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IGZydXN0dW0gbWF0cml4IHdpbGwgYmUgd3JpdHRlbiBpbnRvXG4gKiBAcGFyYW0ge3ZlYzN9IGV5ZSBQb3NpdGlvbiBvZiB0aGUgdmlld2VyXG4gKiBAcGFyYW0ge3ZlYzN9IGNlbnRlciBQb2ludCB0aGUgdmlld2VyIGlzIGxvb2tpbmcgYXRcbiAqIEBwYXJhbSB7dmVjM30gdXAgdmVjMyBwb2ludGluZyB1cFxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5mdW5jdGlvbiBsb29rQXQob3V0LCBleWUsIGNlbnRlciwgdXApIHtcbiAgICB2YXIgeDAsIHgxLCB4MiwgeTAsIHkxLCB5MiwgejAsIHoxLCB6MiwgbGVuLFxuICAgICAgICBleWV4ID0gZXllWzBdLFxuICAgICAgICBleWV5ID0gZXllWzFdLFxuICAgICAgICBleWV6ID0gZXllWzJdLFxuICAgICAgICB1cHggPSB1cFswXSxcbiAgICAgICAgdXB5ID0gdXBbMV0sXG4gICAgICAgIHVweiA9IHVwWzJdLFxuICAgICAgICBjZW50ZXJ4ID0gY2VudGVyWzBdLFxuICAgICAgICBjZW50ZXJ5ID0gY2VudGVyWzFdLFxuICAgICAgICBjZW50ZXJ6ID0gY2VudGVyWzJdO1xuXG4gICAgaWYgKE1hdGguYWJzKGV5ZXggLSBjZW50ZXJ4KSA8IDAuMDAwMDAxICYmXG4gICAgICAgIE1hdGguYWJzKGV5ZXkgLSBjZW50ZXJ5KSA8IDAuMDAwMDAxICYmXG4gICAgICAgIE1hdGguYWJzKGV5ZXogLSBjZW50ZXJ6KSA8IDAuMDAwMDAxKSB7XG4gICAgICAgIHJldHVybiBpZGVudGl0eShvdXQpO1xuICAgIH1cblxuICAgIHowID0gZXlleCAtIGNlbnRlcng7XG4gICAgejEgPSBleWV5IC0gY2VudGVyeTtcbiAgICB6MiA9IGV5ZXogLSBjZW50ZXJ6O1xuXG4gICAgbGVuID0gMSAvIE1hdGguc3FydCh6MCAqIHowICsgejEgKiB6MSArIHoyICogejIpO1xuICAgIHowICo9IGxlbjtcbiAgICB6MSAqPSBsZW47XG4gICAgejIgKj0gbGVuO1xuXG4gICAgeDAgPSB1cHkgKiB6MiAtIHVweiAqIHoxO1xuICAgIHgxID0gdXB6ICogejAgLSB1cHggKiB6MjtcbiAgICB4MiA9IHVweCAqIHoxIC0gdXB5ICogejA7XG4gICAgbGVuID0gTWF0aC5zcXJ0KHgwICogeDAgKyB4MSAqIHgxICsgeDIgKiB4Mik7XG4gICAgaWYgKCFsZW4pIHtcbiAgICAgICAgeDAgPSAwO1xuICAgICAgICB4MSA9IDA7XG4gICAgICAgIHgyID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgICBsZW4gPSAxIC8gbGVuO1xuICAgICAgICB4MCAqPSBsZW47XG4gICAgICAgIHgxICo9IGxlbjtcbiAgICAgICAgeDIgKj0gbGVuO1xuICAgIH1cblxuICAgIHkwID0gejEgKiB4MiAtIHoyICogeDE7XG4gICAgeTEgPSB6MiAqIHgwIC0gejAgKiB4MjtcbiAgICB5MiA9IHowICogeDEgLSB6MSAqIHgwO1xuXG4gICAgbGVuID0gTWF0aC5zcXJ0KHkwICogeTAgKyB5MSAqIHkxICsgeTIgKiB5Mik7XG4gICAgaWYgKCFsZW4pIHtcbiAgICAgICAgeTAgPSAwO1xuICAgICAgICB5MSA9IDA7XG4gICAgICAgIHkyID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgICBsZW4gPSAxIC8gbGVuO1xuICAgICAgICB5MCAqPSBsZW47XG4gICAgICAgIHkxICo9IGxlbjtcbiAgICAgICAgeTIgKj0gbGVuO1xuICAgIH1cblxuICAgIG91dFswXSA9IHgwO1xuICAgIG91dFsxXSA9IHkwO1xuICAgIG91dFsyXSA9IHowO1xuICAgIG91dFszXSA9IDA7XG4gICAgb3V0WzRdID0geDE7XG4gICAgb3V0WzVdID0geTE7XG4gICAgb3V0WzZdID0gejE7XG4gICAgb3V0WzddID0gMDtcbiAgICBvdXRbOF0gPSB4MjtcbiAgICBvdXRbOV0gPSB5MjtcbiAgICBvdXRbMTBdID0gejI7XG4gICAgb3V0WzExXSA9IDA7XG4gICAgb3V0WzEyXSA9IC0oeDAgKiBleWV4ICsgeDEgKiBleWV5ICsgeDIgKiBleWV6KTtcbiAgICBvdXRbMTNdID0gLSh5MCAqIGV5ZXggKyB5MSAqIGV5ZXkgKyB5MiAqIGV5ZXopO1xuICAgIG91dFsxNF0gPSAtKHowICogZXlleCArIHoxICogZXlleSArIHoyICogZXlleik7XG4gICAgb3V0WzE1XSA9IDE7XG5cbiAgICByZXR1cm4gb3V0O1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IG11bHRpcGx5O1xuXG4vKipcbiAqIE11bHRpcGxpZXMgdHdvIG1hdDQnc1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7bWF0NH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuZnVuY3Rpb24gbXVsdGlwbHkob3V0LCBhLCBiKSB7XG4gICAgdmFyIGEwMCA9IGFbMF0sIGEwMSA9IGFbMV0sIGEwMiA9IGFbMl0sIGEwMyA9IGFbM10sXG4gICAgICAgIGExMCA9IGFbNF0sIGExMSA9IGFbNV0sIGExMiA9IGFbNl0sIGExMyA9IGFbN10sXG4gICAgICAgIGEyMCA9IGFbOF0sIGEyMSA9IGFbOV0sIGEyMiA9IGFbMTBdLCBhMjMgPSBhWzExXSxcbiAgICAgICAgYTMwID0gYVsxMl0sIGEzMSA9IGFbMTNdLCBhMzIgPSBhWzE0XSwgYTMzID0gYVsxNV07XG5cbiAgICAvLyBDYWNoZSBvbmx5IHRoZSBjdXJyZW50IGxpbmUgb2YgdGhlIHNlY29uZCBtYXRyaXhcbiAgICB2YXIgYjAgID0gYlswXSwgYjEgPSBiWzFdLCBiMiA9IGJbMl0sIGIzID0gYlszXTsgIFxuICAgIG91dFswXSA9IGIwKmEwMCArIGIxKmExMCArIGIyKmEyMCArIGIzKmEzMDtcbiAgICBvdXRbMV0gPSBiMCphMDEgKyBiMSphMTEgKyBiMiphMjEgKyBiMyphMzE7XG4gICAgb3V0WzJdID0gYjAqYTAyICsgYjEqYTEyICsgYjIqYTIyICsgYjMqYTMyO1xuICAgIG91dFszXSA9IGIwKmEwMyArIGIxKmExMyArIGIyKmEyMyArIGIzKmEzMztcblxuICAgIGIwID0gYls0XTsgYjEgPSBiWzVdOyBiMiA9IGJbNl07IGIzID0gYls3XTtcbiAgICBvdXRbNF0gPSBiMCphMDAgKyBiMSphMTAgKyBiMiphMjAgKyBiMyphMzA7XG4gICAgb3V0WzVdID0gYjAqYTAxICsgYjEqYTExICsgYjIqYTIxICsgYjMqYTMxO1xuICAgIG91dFs2XSA9IGIwKmEwMiArIGIxKmExMiArIGIyKmEyMiArIGIzKmEzMjtcbiAgICBvdXRbN10gPSBiMCphMDMgKyBiMSphMTMgKyBiMiphMjMgKyBiMyphMzM7XG5cbiAgICBiMCA9IGJbOF07IGIxID0gYls5XTsgYjIgPSBiWzEwXTsgYjMgPSBiWzExXTtcbiAgICBvdXRbOF0gPSBiMCphMDAgKyBiMSphMTAgKyBiMiphMjAgKyBiMyphMzA7XG4gICAgb3V0WzldID0gYjAqYTAxICsgYjEqYTExICsgYjIqYTIxICsgYjMqYTMxO1xuICAgIG91dFsxMF0gPSBiMCphMDIgKyBiMSphMTIgKyBiMiphMjIgKyBiMyphMzI7XG4gICAgb3V0WzExXSA9IGIwKmEwMyArIGIxKmExMyArIGIyKmEyMyArIGIzKmEzMztcblxuICAgIGIwID0gYlsxMl07IGIxID0gYlsxM107IGIyID0gYlsxNF07IGIzID0gYlsxNV07XG4gICAgb3V0WzEyXSA9IGIwKmEwMCArIGIxKmExMCArIGIyKmEyMCArIGIzKmEzMDtcbiAgICBvdXRbMTNdID0gYjAqYTAxICsgYjEqYTExICsgYjIqYTIxICsgYjMqYTMxO1xuICAgIG91dFsxNF0gPSBiMCphMDIgKyBiMSphMTIgKyBiMiphMjIgKyBiMyphMzI7XG4gICAgb3V0WzE1XSA9IGIwKmEwMyArIGIxKmExMyArIGIyKmEyMyArIGIzKmEzMztcbiAgICByZXR1cm4gb3V0O1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IG9ydGhvO1xuXG4vKipcbiAqIEdlbmVyYXRlcyBhIG9ydGhvZ29uYWwgcHJvamVjdGlvbiBtYXRyaXggd2l0aCB0aGUgZ2l2ZW4gYm91bmRzXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCBmcnVzdHVtIG1hdHJpeCB3aWxsIGJlIHdyaXR0ZW4gaW50b1xuICogQHBhcmFtIHtudW1iZXJ9IGxlZnQgTGVmdCBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtudW1iZXJ9IHJpZ2h0IFJpZ2h0IGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcGFyYW0ge251bWJlcn0gYm90dG9tIEJvdHRvbSBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtudW1iZXJ9IHRvcCBUb3AgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEBwYXJhbSB7bnVtYmVyfSBuZWFyIE5lYXIgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEBwYXJhbSB7bnVtYmVyfSBmYXIgRmFyIGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbmZ1bmN0aW9uIG9ydGhvKG91dCwgbGVmdCwgcmlnaHQsIGJvdHRvbSwgdG9wLCBuZWFyLCBmYXIpIHtcbiAgICB2YXIgbHIgPSAxIC8gKGxlZnQgLSByaWdodCksXG4gICAgICAgIGJ0ID0gMSAvIChib3R0b20gLSB0b3ApLFxuICAgICAgICBuZiA9IDEgLyAobmVhciAtIGZhcik7XG4gICAgb3V0WzBdID0gLTIgKiBscjtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgb3V0WzNdID0gMDtcbiAgICBvdXRbNF0gPSAwO1xuICAgIG91dFs1XSA9IC0yICogYnQ7XG4gICAgb3V0WzZdID0gMDtcbiAgICBvdXRbN10gPSAwO1xuICAgIG91dFs4XSA9IDA7XG4gICAgb3V0WzldID0gMDtcbiAgICBvdXRbMTBdID0gMiAqIG5mO1xuICAgIG91dFsxMV0gPSAwO1xuICAgIG91dFsxMl0gPSAobGVmdCArIHJpZ2h0KSAqIGxyO1xuICAgIG91dFsxM10gPSAodG9wICsgYm90dG9tKSAqIGJ0O1xuICAgIG91dFsxNF0gPSAoZmFyICsgbmVhcikgKiBuZjtcbiAgICBvdXRbMTVdID0gMTtcbiAgICByZXR1cm4gb3V0O1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IHBlcnNwZWN0aXZlO1xuXG4vKipcbiAqIEdlbmVyYXRlcyBhIHBlcnNwZWN0aXZlIHByb2plY3Rpb24gbWF0cml4IHdpdGggdGhlIGdpdmVuIGJvdW5kc1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgZnJ1c3R1bSBtYXRyaXggd2lsbCBiZSB3cml0dGVuIGludG9cbiAqIEBwYXJhbSB7bnVtYmVyfSBmb3Z5IFZlcnRpY2FsIGZpZWxkIG9mIHZpZXcgaW4gcmFkaWFuc1xuICogQHBhcmFtIHtudW1iZXJ9IGFzcGVjdCBBc3BlY3QgcmF0aW8uIHR5cGljYWxseSB2aWV3cG9ydCB3aWR0aC9oZWlnaHRcbiAqIEBwYXJhbSB7bnVtYmVyfSBuZWFyIE5lYXIgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEBwYXJhbSB7bnVtYmVyfSBmYXIgRmFyIGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbmZ1bmN0aW9uIHBlcnNwZWN0aXZlKG91dCwgZm92eSwgYXNwZWN0LCBuZWFyLCBmYXIpIHtcbiAgICB2YXIgZiA9IDEuMCAvIE1hdGgudGFuKGZvdnkgLyAyKSxcbiAgICAgICAgbmYgPSAxIC8gKG5lYXIgLSBmYXIpO1xuICAgIG91dFswXSA9IGYgLyBhc3BlY3Q7XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICAgIG91dFszXSA9IDA7XG4gICAgb3V0WzRdID0gMDtcbiAgICBvdXRbNV0gPSBmO1xuICAgIG91dFs2XSA9IDA7XG4gICAgb3V0WzddID0gMDtcbiAgICBvdXRbOF0gPSAwO1xuICAgIG91dFs5XSA9IDA7XG4gICAgb3V0WzEwXSA9IChmYXIgKyBuZWFyKSAqIG5mO1xuICAgIG91dFsxMV0gPSAtMTtcbiAgICBvdXRbMTJdID0gMDtcbiAgICBvdXRbMTNdID0gMDtcbiAgICBvdXRbMTRdID0gKDIgKiBmYXIgKiBuZWFyKSAqIG5mO1xuICAgIG91dFsxNV0gPSAwO1xuICAgIHJldHVybiBvdXQ7XG59OyIsIm1vZHVsZS5leHBvcnRzID0gcGVyc3BlY3RpdmVGcm9tRmllbGRPZlZpZXc7XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgcGVyc3BlY3RpdmUgcHJvamVjdGlvbiBtYXRyaXggd2l0aCB0aGUgZ2l2ZW4gZmllbGQgb2Ygdmlldy5cbiAqIFRoaXMgaXMgcHJpbWFyaWx5IHVzZWZ1bCBmb3IgZ2VuZXJhdGluZyBwcm9qZWN0aW9uIG1hdHJpY2VzIHRvIGJlIHVzZWRcbiAqIHdpdGggdGhlIHN0aWxsIGV4cGVyaWVtZW50YWwgV2ViVlIgQVBJLlxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgZnJ1c3R1bSBtYXRyaXggd2lsbCBiZSB3cml0dGVuIGludG9cbiAqIEBwYXJhbSB7bnVtYmVyfSBmb3YgT2JqZWN0IGNvbnRhaW5pbmcgdGhlIGZvbGxvd2luZyB2YWx1ZXM6IHVwRGVncmVlcywgZG93bkRlZ3JlZXMsIGxlZnREZWdyZWVzLCByaWdodERlZ3JlZXNcbiAqIEBwYXJhbSB7bnVtYmVyfSBuZWFyIE5lYXIgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEBwYXJhbSB7bnVtYmVyfSBmYXIgRmFyIGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbmZ1bmN0aW9uIHBlcnNwZWN0aXZlRnJvbUZpZWxkT2ZWaWV3KG91dCwgZm92LCBuZWFyLCBmYXIpIHtcbiAgICB2YXIgdXBUYW4gPSBNYXRoLnRhbihmb3YudXBEZWdyZWVzICogTWF0aC5QSS8xODAuMCksXG4gICAgICAgIGRvd25UYW4gPSBNYXRoLnRhbihmb3YuZG93bkRlZ3JlZXMgKiBNYXRoLlBJLzE4MC4wKSxcbiAgICAgICAgbGVmdFRhbiA9IE1hdGgudGFuKGZvdi5sZWZ0RGVncmVlcyAqIE1hdGguUEkvMTgwLjApLFxuICAgICAgICByaWdodFRhbiA9IE1hdGgudGFuKGZvdi5yaWdodERlZ3JlZXMgKiBNYXRoLlBJLzE4MC4wKSxcbiAgICAgICAgeFNjYWxlID0gMi4wIC8gKGxlZnRUYW4gKyByaWdodFRhbiksXG4gICAgICAgIHlTY2FsZSA9IDIuMCAvICh1cFRhbiArIGRvd25UYW4pO1xuXG4gICAgb3V0WzBdID0geFNjYWxlO1xuICAgIG91dFsxXSA9IDAuMDtcbiAgICBvdXRbMl0gPSAwLjA7XG4gICAgb3V0WzNdID0gMC4wO1xuICAgIG91dFs0XSA9IDAuMDtcbiAgICBvdXRbNV0gPSB5U2NhbGU7XG4gICAgb3V0WzZdID0gMC4wO1xuICAgIG91dFs3XSA9IDAuMDtcbiAgICBvdXRbOF0gPSAtKChsZWZ0VGFuIC0gcmlnaHRUYW4pICogeFNjYWxlICogMC41KTtcbiAgICBvdXRbOV0gPSAoKHVwVGFuIC0gZG93blRhbikgKiB5U2NhbGUgKiAwLjUpO1xuICAgIG91dFsxMF0gPSBmYXIgLyAobmVhciAtIGZhcik7XG4gICAgb3V0WzExXSA9IC0xLjA7XG4gICAgb3V0WzEyXSA9IDAuMDtcbiAgICBvdXRbMTNdID0gMC4wO1xuICAgIG91dFsxNF0gPSAoZmFyICogbmVhcikgLyAobmVhciAtIGZhcik7XG4gICAgb3V0WzE1XSA9IDAuMDtcbiAgICByZXR1cm4gb3V0O1xufVxuXG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJvdGF0ZTtcblxuLyoqXG4gKiBSb3RhdGVzIGEgbWF0NCBieSB0aGUgZ2l2ZW4gYW5nbGVcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBtYXRyaXggdG8gcm90YXRlXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHBhcmFtIHt2ZWMzfSBheGlzIHRoZSBheGlzIHRvIHJvdGF0ZSBhcm91bmRcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuZnVuY3Rpb24gcm90YXRlKG91dCwgYSwgcmFkLCBheGlzKSB7XG4gICAgdmFyIHggPSBheGlzWzBdLCB5ID0gYXhpc1sxXSwgeiA9IGF4aXNbMl0sXG4gICAgICAgIGxlbiA9IE1hdGguc3FydCh4ICogeCArIHkgKiB5ICsgeiAqIHopLFxuICAgICAgICBzLCBjLCB0LFxuICAgICAgICBhMDAsIGEwMSwgYTAyLCBhMDMsXG4gICAgICAgIGExMCwgYTExLCBhMTIsIGExMyxcbiAgICAgICAgYTIwLCBhMjEsIGEyMiwgYTIzLFxuICAgICAgICBiMDAsIGIwMSwgYjAyLFxuICAgICAgICBiMTAsIGIxMSwgYjEyLFxuICAgICAgICBiMjAsIGIyMSwgYjIyO1xuXG4gICAgaWYgKE1hdGguYWJzKGxlbikgPCAwLjAwMDAwMSkgeyByZXR1cm4gbnVsbDsgfVxuICAgIFxuICAgIGxlbiA9IDEgLyBsZW47XG4gICAgeCAqPSBsZW47XG4gICAgeSAqPSBsZW47XG4gICAgeiAqPSBsZW47XG5cbiAgICBzID0gTWF0aC5zaW4ocmFkKTtcbiAgICBjID0gTWF0aC5jb3MocmFkKTtcbiAgICB0ID0gMSAtIGM7XG5cbiAgICBhMDAgPSBhWzBdOyBhMDEgPSBhWzFdOyBhMDIgPSBhWzJdOyBhMDMgPSBhWzNdO1xuICAgIGExMCA9IGFbNF07IGExMSA9IGFbNV07IGExMiA9IGFbNl07IGExMyA9IGFbN107XG4gICAgYTIwID0gYVs4XTsgYTIxID0gYVs5XTsgYTIyID0gYVsxMF07IGEyMyA9IGFbMTFdO1xuXG4gICAgLy8gQ29uc3RydWN0IHRoZSBlbGVtZW50cyBvZiB0aGUgcm90YXRpb24gbWF0cml4XG4gICAgYjAwID0geCAqIHggKiB0ICsgYzsgYjAxID0geSAqIHggKiB0ICsgeiAqIHM7IGIwMiA9IHogKiB4ICogdCAtIHkgKiBzO1xuICAgIGIxMCA9IHggKiB5ICogdCAtIHogKiBzOyBiMTEgPSB5ICogeSAqIHQgKyBjOyBiMTIgPSB6ICogeSAqIHQgKyB4ICogcztcbiAgICBiMjAgPSB4ICogeiAqIHQgKyB5ICogczsgYjIxID0geSAqIHogKiB0IC0geCAqIHM7IGIyMiA9IHogKiB6ICogdCArIGM7XG5cbiAgICAvLyBQZXJmb3JtIHJvdGF0aW9uLXNwZWNpZmljIG1hdHJpeCBtdWx0aXBsaWNhdGlvblxuICAgIG91dFswXSA9IGEwMCAqIGIwMCArIGExMCAqIGIwMSArIGEyMCAqIGIwMjtcbiAgICBvdXRbMV0gPSBhMDEgKiBiMDAgKyBhMTEgKiBiMDEgKyBhMjEgKiBiMDI7XG4gICAgb3V0WzJdID0gYTAyICogYjAwICsgYTEyICogYjAxICsgYTIyICogYjAyO1xuICAgIG91dFszXSA9IGEwMyAqIGIwMCArIGExMyAqIGIwMSArIGEyMyAqIGIwMjtcbiAgICBvdXRbNF0gPSBhMDAgKiBiMTAgKyBhMTAgKiBiMTEgKyBhMjAgKiBiMTI7XG4gICAgb3V0WzVdID0gYTAxICogYjEwICsgYTExICogYjExICsgYTIxICogYjEyO1xuICAgIG91dFs2XSA9IGEwMiAqIGIxMCArIGExMiAqIGIxMSArIGEyMiAqIGIxMjtcbiAgICBvdXRbN10gPSBhMDMgKiBiMTAgKyBhMTMgKiBiMTEgKyBhMjMgKiBiMTI7XG4gICAgb3V0WzhdID0gYTAwICogYjIwICsgYTEwICogYjIxICsgYTIwICogYjIyO1xuICAgIG91dFs5XSA9IGEwMSAqIGIyMCArIGExMSAqIGIyMSArIGEyMSAqIGIyMjtcbiAgICBvdXRbMTBdID0gYTAyICogYjIwICsgYTEyICogYjIxICsgYTIyICogYjIyO1xuICAgIG91dFsxMV0gPSBhMDMgKiBiMjAgKyBhMTMgKiBiMjEgKyBhMjMgKiBiMjI7XG5cbiAgICBpZiAoYSAhPT0gb3V0KSB7IC8vIElmIHRoZSBzb3VyY2UgYW5kIGRlc3RpbmF0aW9uIGRpZmZlciwgY29weSB0aGUgdW5jaGFuZ2VkIGxhc3Qgcm93XG4gICAgICAgIG91dFsxMl0gPSBhWzEyXTtcbiAgICAgICAgb3V0WzEzXSA9IGFbMTNdO1xuICAgICAgICBvdXRbMTRdID0gYVsxNF07XG4gICAgICAgIG91dFsxNV0gPSBhWzE1XTtcbiAgICB9XG4gICAgcmV0dXJuIG91dDtcbn07IiwibW9kdWxlLmV4cG9ydHMgPSByb3RhdGVYO1xuXG4vKipcbiAqIFJvdGF0ZXMgYSBtYXRyaXggYnkgdGhlIGdpdmVuIGFuZ2xlIGFyb3VuZCB0aGUgWCBheGlzXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgbWF0cml4IHRvIHJvdGF0ZVxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuZnVuY3Rpb24gcm90YXRlWChvdXQsIGEsIHJhZCkge1xuICAgIHZhciBzID0gTWF0aC5zaW4ocmFkKSxcbiAgICAgICAgYyA9IE1hdGguY29zKHJhZCksXG4gICAgICAgIGExMCA9IGFbNF0sXG4gICAgICAgIGExMSA9IGFbNV0sXG4gICAgICAgIGExMiA9IGFbNl0sXG4gICAgICAgIGExMyA9IGFbN10sXG4gICAgICAgIGEyMCA9IGFbOF0sXG4gICAgICAgIGEyMSA9IGFbOV0sXG4gICAgICAgIGEyMiA9IGFbMTBdLFxuICAgICAgICBhMjMgPSBhWzExXTtcblxuICAgIGlmIChhICE9PSBvdXQpIHsgLy8gSWYgdGhlIHNvdXJjZSBhbmQgZGVzdGluYXRpb24gZGlmZmVyLCBjb3B5IHRoZSB1bmNoYW5nZWQgcm93c1xuICAgICAgICBvdXRbMF0gID0gYVswXTtcbiAgICAgICAgb3V0WzFdICA9IGFbMV07XG4gICAgICAgIG91dFsyXSAgPSBhWzJdO1xuICAgICAgICBvdXRbM10gID0gYVszXTtcbiAgICAgICAgb3V0WzEyXSA9IGFbMTJdO1xuICAgICAgICBvdXRbMTNdID0gYVsxM107XG4gICAgICAgIG91dFsxNF0gPSBhWzE0XTtcbiAgICAgICAgb3V0WzE1XSA9IGFbMTVdO1xuICAgIH1cblxuICAgIC8vIFBlcmZvcm0gYXhpcy1zcGVjaWZpYyBtYXRyaXggbXVsdGlwbGljYXRpb25cbiAgICBvdXRbNF0gPSBhMTAgKiBjICsgYTIwICogcztcbiAgICBvdXRbNV0gPSBhMTEgKiBjICsgYTIxICogcztcbiAgICBvdXRbNl0gPSBhMTIgKiBjICsgYTIyICogcztcbiAgICBvdXRbN10gPSBhMTMgKiBjICsgYTIzICogcztcbiAgICBvdXRbOF0gPSBhMjAgKiBjIC0gYTEwICogcztcbiAgICBvdXRbOV0gPSBhMjEgKiBjIC0gYTExICogcztcbiAgICBvdXRbMTBdID0gYTIyICogYyAtIGExMiAqIHM7XG4gICAgb3V0WzExXSA9IGEyMyAqIGMgLSBhMTMgKiBzO1xuICAgIHJldHVybiBvdXQ7XG59OyIsIm1vZHVsZS5leHBvcnRzID0gcm90YXRlWTtcblxuLyoqXG4gKiBSb3RhdGVzIGEgbWF0cml4IGJ5IHRoZSBnaXZlbiBhbmdsZSBhcm91bmQgdGhlIFkgYXhpc1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIG1hdHJpeCB0byByb3RhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbmZ1bmN0aW9uIHJvdGF0ZVkob3V0LCBhLCByYWQpIHtcbiAgICB2YXIgcyA9IE1hdGguc2luKHJhZCksXG4gICAgICAgIGMgPSBNYXRoLmNvcyhyYWQpLFxuICAgICAgICBhMDAgPSBhWzBdLFxuICAgICAgICBhMDEgPSBhWzFdLFxuICAgICAgICBhMDIgPSBhWzJdLFxuICAgICAgICBhMDMgPSBhWzNdLFxuICAgICAgICBhMjAgPSBhWzhdLFxuICAgICAgICBhMjEgPSBhWzldLFxuICAgICAgICBhMjIgPSBhWzEwXSxcbiAgICAgICAgYTIzID0gYVsxMV07XG5cbiAgICBpZiAoYSAhPT0gb3V0KSB7IC8vIElmIHRoZSBzb3VyY2UgYW5kIGRlc3RpbmF0aW9uIGRpZmZlciwgY29weSB0aGUgdW5jaGFuZ2VkIHJvd3NcbiAgICAgICAgb3V0WzRdICA9IGFbNF07XG4gICAgICAgIG91dFs1XSAgPSBhWzVdO1xuICAgICAgICBvdXRbNl0gID0gYVs2XTtcbiAgICAgICAgb3V0WzddICA9IGFbN107XG4gICAgICAgIG91dFsxMl0gPSBhWzEyXTtcbiAgICAgICAgb3V0WzEzXSA9IGFbMTNdO1xuICAgICAgICBvdXRbMTRdID0gYVsxNF07XG4gICAgICAgIG91dFsxNV0gPSBhWzE1XTtcbiAgICB9XG5cbiAgICAvLyBQZXJmb3JtIGF4aXMtc3BlY2lmaWMgbWF0cml4IG11bHRpcGxpY2F0aW9uXG4gICAgb3V0WzBdID0gYTAwICogYyAtIGEyMCAqIHM7XG4gICAgb3V0WzFdID0gYTAxICogYyAtIGEyMSAqIHM7XG4gICAgb3V0WzJdID0gYTAyICogYyAtIGEyMiAqIHM7XG4gICAgb3V0WzNdID0gYTAzICogYyAtIGEyMyAqIHM7XG4gICAgb3V0WzhdID0gYTAwICogcyArIGEyMCAqIGM7XG4gICAgb3V0WzldID0gYTAxICogcyArIGEyMSAqIGM7XG4gICAgb3V0WzEwXSA9IGEwMiAqIHMgKyBhMjIgKiBjO1xuICAgIG91dFsxMV0gPSBhMDMgKiBzICsgYTIzICogYztcbiAgICByZXR1cm4gb3V0O1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJvdGF0ZVo7XG5cbi8qKlxuICogUm90YXRlcyBhIG1hdHJpeCBieSB0aGUgZ2l2ZW4gYW5nbGUgYXJvdW5kIHRoZSBaIGF4aXNcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBtYXRyaXggdG8gcm90YXRlXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5mdW5jdGlvbiByb3RhdGVaKG91dCwgYSwgcmFkKSB7XG4gICAgdmFyIHMgPSBNYXRoLnNpbihyYWQpLFxuICAgICAgICBjID0gTWF0aC5jb3MocmFkKSxcbiAgICAgICAgYTAwID0gYVswXSxcbiAgICAgICAgYTAxID0gYVsxXSxcbiAgICAgICAgYTAyID0gYVsyXSxcbiAgICAgICAgYTAzID0gYVszXSxcbiAgICAgICAgYTEwID0gYVs0XSxcbiAgICAgICAgYTExID0gYVs1XSxcbiAgICAgICAgYTEyID0gYVs2XSxcbiAgICAgICAgYTEzID0gYVs3XTtcblxuICAgIGlmIChhICE9PSBvdXQpIHsgLy8gSWYgdGhlIHNvdXJjZSBhbmQgZGVzdGluYXRpb24gZGlmZmVyLCBjb3B5IHRoZSB1bmNoYW5nZWQgbGFzdCByb3dcbiAgICAgICAgb3V0WzhdICA9IGFbOF07XG4gICAgICAgIG91dFs5XSAgPSBhWzldO1xuICAgICAgICBvdXRbMTBdID0gYVsxMF07XG4gICAgICAgIG91dFsxMV0gPSBhWzExXTtcbiAgICAgICAgb3V0WzEyXSA9IGFbMTJdO1xuICAgICAgICBvdXRbMTNdID0gYVsxM107XG4gICAgICAgIG91dFsxNF0gPSBhWzE0XTtcbiAgICAgICAgb3V0WzE1XSA9IGFbMTVdO1xuICAgIH1cblxuICAgIC8vIFBlcmZvcm0gYXhpcy1zcGVjaWZpYyBtYXRyaXggbXVsdGlwbGljYXRpb25cbiAgICBvdXRbMF0gPSBhMDAgKiBjICsgYTEwICogcztcbiAgICBvdXRbMV0gPSBhMDEgKiBjICsgYTExICogcztcbiAgICBvdXRbMl0gPSBhMDIgKiBjICsgYTEyICogcztcbiAgICBvdXRbM10gPSBhMDMgKiBjICsgYTEzICogcztcbiAgICBvdXRbNF0gPSBhMTAgKiBjIC0gYTAwICogcztcbiAgICBvdXRbNV0gPSBhMTEgKiBjIC0gYTAxICogcztcbiAgICBvdXRbNl0gPSBhMTIgKiBjIC0gYTAyICogcztcbiAgICBvdXRbN10gPSBhMTMgKiBjIC0gYTAzICogcztcbiAgICByZXR1cm4gb3V0O1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IHNjYWxlO1xuXG4vKipcbiAqIFNjYWxlcyB0aGUgbWF0NCBieSB0aGUgZGltZW5zaW9ucyBpbiB0aGUgZ2l2ZW4gdmVjM1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIG1hdHJpeCB0byBzY2FsZVxuICogQHBhcmFtIHt2ZWMzfSB2IHRoZSB2ZWMzIHRvIHNjYWxlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqKi9cbmZ1bmN0aW9uIHNjYWxlKG91dCwgYSwgdikge1xuICAgIHZhciB4ID0gdlswXSwgeSA9IHZbMV0sIHogPSB2WzJdO1xuXG4gICAgb3V0WzBdID0gYVswXSAqIHg7XG4gICAgb3V0WzFdID0gYVsxXSAqIHg7XG4gICAgb3V0WzJdID0gYVsyXSAqIHg7XG4gICAgb3V0WzNdID0gYVszXSAqIHg7XG4gICAgb3V0WzRdID0gYVs0XSAqIHk7XG4gICAgb3V0WzVdID0gYVs1XSAqIHk7XG4gICAgb3V0WzZdID0gYVs2XSAqIHk7XG4gICAgb3V0WzddID0gYVs3XSAqIHk7XG4gICAgb3V0WzhdID0gYVs4XSAqIHo7XG4gICAgb3V0WzldID0gYVs5XSAqIHo7XG4gICAgb3V0WzEwXSA9IGFbMTBdICogejtcbiAgICBvdXRbMTFdID0gYVsxMV0gKiB6O1xuICAgIG91dFsxMl0gPSBhWzEyXTtcbiAgICBvdXRbMTNdID0gYVsxM107XG4gICAgb3V0WzE0XSA9IGFbMTRdO1xuICAgIG91dFsxNV0gPSBhWzE1XTtcbiAgICByZXR1cm4gb3V0O1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IHN0cjtcblxuLyoqXG4gKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgbWF0NFxuICpcbiAqIEBwYXJhbSB7bWF0NH0gbWF0IG1hdHJpeCB0byByZXByZXNlbnQgYXMgYSBzdHJpbmdcbiAqIEByZXR1cm5zIHtTdHJpbmd9IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgbWF0cml4XG4gKi9cbmZ1bmN0aW9uIHN0cihhKSB7XG4gICAgcmV0dXJuICdtYXQ0KCcgKyBhWzBdICsgJywgJyArIGFbMV0gKyAnLCAnICsgYVsyXSArICcsICcgKyBhWzNdICsgJywgJyArXG4gICAgICAgICAgICAgICAgICAgIGFbNF0gKyAnLCAnICsgYVs1XSArICcsICcgKyBhWzZdICsgJywgJyArIGFbN10gKyAnLCAnICtcbiAgICAgICAgICAgICAgICAgICAgYVs4XSArICcsICcgKyBhWzldICsgJywgJyArIGFbMTBdICsgJywgJyArIGFbMTFdICsgJywgJyArIFxuICAgICAgICAgICAgICAgICAgICBhWzEyXSArICcsICcgKyBhWzEzXSArICcsICcgKyBhWzE0XSArICcsICcgKyBhWzE1XSArICcpJztcbn07IiwibW9kdWxlLmV4cG9ydHMgPSB0cmFuc2xhdGU7XG5cbi8qKlxuICogVHJhbnNsYXRlIGEgbWF0NCBieSB0aGUgZ2l2ZW4gdmVjdG9yXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgbWF0cml4IHRvIHRyYW5zbGF0ZVxuICogQHBhcmFtIHt2ZWMzfSB2IHZlY3RvciB0byB0cmFuc2xhdGUgYnlcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuZnVuY3Rpb24gdHJhbnNsYXRlKG91dCwgYSwgdikge1xuICAgIHZhciB4ID0gdlswXSwgeSA9IHZbMV0sIHogPSB2WzJdLFxuICAgICAgICBhMDAsIGEwMSwgYTAyLCBhMDMsXG4gICAgICAgIGExMCwgYTExLCBhMTIsIGExMyxcbiAgICAgICAgYTIwLCBhMjEsIGEyMiwgYTIzO1xuXG4gICAgaWYgKGEgPT09IG91dCkge1xuICAgICAgICBvdXRbMTJdID0gYVswXSAqIHggKyBhWzRdICogeSArIGFbOF0gKiB6ICsgYVsxMl07XG4gICAgICAgIG91dFsxM10gPSBhWzFdICogeCArIGFbNV0gKiB5ICsgYVs5XSAqIHogKyBhWzEzXTtcbiAgICAgICAgb3V0WzE0XSA9IGFbMl0gKiB4ICsgYVs2XSAqIHkgKyBhWzEwXSAqIHogKyBhWzE0XTtcbiAgICAgICAgb3V0WzE1XSA9IGFbM10gKiB4ICsgYVs3XSAqIHkgKyBhWzExXSAqIHogKyBhWzE1XTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBhMDAgPSBhWzBdOyBhMDEgPSBhWzFdOyBhMDIgPSBhWzJdOyBhMDMgPSBhWzNdO1xuICAgICAgICBhMTAgPSBhWzRdOyBhMTEgPSBhWzVdOyBhMTIgPSBhWzZdOyBhMTMgPSBhWzddO1xuICAgICAgICBhMjAgPSBhWzhdOyBhMjEgPSBhWzldOyBhMjIgPSBhWzEwXTsgYTIzID0gYVsxMV07XG5cbiAgICAgICAgb3V0WzBdID0gYTAwOyBvdXRbMV0gPSBhMDE7IG91dFsyXSA9IGEwMjsgb3V0WzNdID0gYTAzO1xuICAgICAgICBvdXRbNF0gPSBhMTA7IG91dFs1XSA9IGExMTsgb3V0WzZdID0gYTEyOyBvdXRbN10gPSBhMTM7XG4gICAgICAgIG91dFs4XSA9IGEyMDsgb3V0WzldID0gYTIxOyBvdXRbMTBdID0gYTIyOyBvdXRbMTFdID0gYTIzO1xuXG4gICAgICAgIG91dFsxMl0gPSBhMDAgKiB4ICsgYTEwICogeSArIGEyMCAqIHogKyBhWzEyXTtcbiAgICAgICAgb3V0WzEzXSA9IGEwMSAqIHggKyBhMTEgKiB5ICsgYTIxICogeiArIGFbMTNdO1xuICAgICAgICBvdXRbMTRdID0gYTAyICogeCArIGExMiAqIHkgKyBhMjIgKiB6ICsgYVsxNF07XG4gICAgICAgIG91dFsxNV0gPSBhMDMgKiB4ICsgYTEzICogeSArIGEyMyAqIHogKyBhWzE1XTtcbiAgICB9XG5cbiAgICByZXR1cm4gb3V0O1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IHRyYW5zcG9zZTtcblxuLyoqXG4gKiBUcmFuc3Bvc2UgdGhlIHZhbHVlcyBvZiBhIG1hdDRcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbmZ1bmN0aW9uIHRyYW5zcG9zZShvdXQsIGEpIHtcbiAgICAvLyBJZiB3ZSBhcmUgdHJhbnNwb3Npbmcgb3Vyc2VsdmVzIHdlIGNhbiBza2lwIGEgZmV3IHN0ZXBzIGJ1dCBoYXZlIHRvIGNhY2hlIHNvbWUgdmFsdWVzXG4gICAgaWYgKG91dCA9PT0gYSkge1xuICAgICAgICB2YXIgYTAxID0gYVsxXSwgYTAyID0gYVsyXSwgYTAzID0gYVszXSxcbiAgICAgICAgICAgIGExMiA9IGFbNl0sIGExMyA9IGFbN10sXG4gICAgICAgICAgICBhMjMgPSBhWzExXTtcblxuICAgICAgICBvdXRbMV0gPSBhWzRdO1xuICAgICAgICBvdXRbMl0gPSBhWzhdO1xuICAgICAgICBvdXRbM10gPSBhWzEyXTtcbiAgICAgICAgb3V0WzRdID0gYTAxO1xuICAgICAgICBvdXRbNl0gPSBhWzldO1xuICAgICAgICBvdXRbN10gPSBhWzEzXTtcbiAgICAgICAgb3V0WzhdID0gYTAyO1xuICAgICAgICBvdXRbOV0gPSBhMTI7XG4gICAgICAgIG91dFsxMV0gPSBhWzE0XTtcbiAgICAgICAgb3V0WzEyXSA9IGEwMztcbiAgICAgICAgb3V0WzEzXSA9IGExMztcbiAgICAgICAgb3V0WzE0XSA9IGEyMztcbiAgICB9IGVsc2Uge1xuICAgICAgICBvdXRbMF0gPSBhWzBdO1xuICAgICAgICBvdXRbMV0gPSBhWzRdO1xuICAgICAgICBvdXRbMl0gPSBhWzhdO1xuICAgICAgICBvdXRbM10gPSBhWzEyXTtcbiAgICAgICAgb3V0WzRdID0gYVsxXTtcbiAgICAgICAgb3V0WzVdID0gYVs1XTtcbiAgICAgICAgb3V0WzZdID0gYVs5XTtcbiAgICAgICAgb3V0WzddID0gYVsxM107XG4gICAgICAgIG91dFs4XSA9IGFbMl07XG4gICAgICAgIG91dFs5XSA9IGFbNl07XG4gICAgICAgIG91dFsxMF0gPSBhWzEwXTtcbiAgICAgICAgb3V0WzExXSA9IGFbMTRdO1xuICAgICAgICBvdXRbMTJdID0gYVszXTtcbiAgICAgICAgb3V0WzEzXSA9IGFbN107XG4gICAgICAgIG91dFsxNF0gPSBhWzExXTtcbiAgICAgICAgb3V0WzE1XSA9IGFbMTVdO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gb3V0O1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHN0cmluZ3MpIHtcbiAgaWYgKHR5cGVvZiBzdHJpbmdzID09PSAnc3RyaW5nJykgc3RyaW5ncyA9IFtzdHJpbmdzXVxuICB2YXIgZXhwcnMgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywxKVxuICB2YXIgcGFydHMgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0cmluZ3MubGVuZ3RoLTE7IGkrKykge1xuICAgIHBhcnRzLnB1c2goc3RyaW5nc1tpXSwgZXhwcnNbaV0gfHwgJycpXG4gIH1cbiAgcGFydHMucHVzaChzdHJpbmdzW2ldKVxuICByZXR1cm4gcGFydHMuam9pbignJylcbn1cbiIsIi8qISBpZWVlNzU0LiBCU0QtMy1DbGF1c2UgTGljZW5zZS4gRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnL29wZW5zb3VyY2U+ICovXG5leHBvcnRzLnJlYWQgPSBmdW5jdGlvbiAoYnVmZmVyLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbVxuICB2YXIgZUxlbiA9IChuQnl0ZXMgKiA4KSAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgbkJpdHMgPSAtN1xuICB2YXIgaSA9IGlzTEUgPyAobkJ5dGVzIC0gMSkgOiAwXG4gIHZhciBkID0gaXNMRSA/IC0xIDogMVxuICB2YXIgcyA9IGJ1ZmZlcltvZmZzZXQgKyBpXVxuXG4gIGkgKz0gZFxuXG4gIGUgPSBzICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIHMgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IGVMZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgZSA9IChlICogMjU2KSArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIG0gPSBlICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIGUgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IG1MZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgbSA9IChtICogMjU2KSArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIGlmIChlID09PSAwKSB7XG4gICAgZSA9IDEgLSBlQmlhc1xuICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHtcbiAgICByZXR1cm4gbSA/IE5hTiA6ICgocyA/IC0xIDogMSkgKiBJbmZpbml0eSlcbiAgfSBlbHNlIHtcbiAgICBtID0gbSArIE1hdGgucG93KDIsIG1MZW4pXG4gICAgZSA9IGUgLSBlQmlhc1xuICB9XG4gIHJldHVybiAocyA/IC0xIDogMSkgKiBtICogTWF0aC5wb3coMiwgZSAtIG1MZW4pXG59XG5cbmV4cG9ydHMud3JpdGUgPSBmdW5jdGlvbiAoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG0sIGNcbiAgdmFyIGVMZW4gPSAobkJ5dGVzICogOCkgLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIHJ0ID0gKG1MZW4gPT09IDIzID8gTWF0aC5wb3coMiwgLTI0KSAtIE1hdGgucG93KDIsIC03NykgOiAwKVxuICB2YXIgaSA9IGlzTEUgPyAwIDogKG5CeXRlcyAtIDEpXG4gIHZhciBkID0gaXNMRSA/IDEgOiAtMVxuICB2YXIgcyA9IHZhbHVlIDwgMCB8fCAodmFsdWUgPT09IDAgJiYgMSAvIHZhbHVlIDwgMCkgPyAxIDogMFxuXG4gIHZhbHVlID0gTWF0aC5hYnModmFsdWUpXG5cbiAgaWYgKGlzTmFOKHZhbHVlKSB8fCB2YWx1ZSA9PT0gSW5maW5pdHkpIHtcbiAgICBtID0gaXNOYU4odmFsdWUpID8gMSA6IDBcbiAgICBlID0gZU1heFxuICB9IGVsc2Uge1xuICAgIGUgPSBNYXRoLmZsb29yKE1hdGgubG9nKHZhbHVlKSAvIE1hdGguTE4yKVxuICAgIGlmICh2YWx1ZSAqIChjID0gTWF0aC5wb3coMiwgLWUpKSA8IDEpIHtcbiAgICAgIGUtLVxuICAgICAgYyAqPSAyXG4gICAgfVxuICAgIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgdmFsdWUgKz0gcnQgLyBjXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlICs9IHJ0ICogTWF0aC5wb3coMiwgMSAtIGVCaWFzKVxuICAgIH1cbiAgICBpZiAodmFsdWUgKiBjID49IDIpIHtcbiAgICAgIGUrK1xuICAgICAgYyAvPSAyXG4gICAgfVxuXG4gICAgaWYgKGUgKyBlQmlhcyA+PSBlTWF4KSB7XG4gICAgICBtID0gMFxuICAgICAgZSA9IGVNYXhcbiAgICB9IGVsc2UgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICBtID0gKCh2YWx1ZSAqIGMpIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IGUgKyBlQmlhc1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gdmFsdWUgKiBNYXRoLnBvdygyLCBlQmlhcyAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSAwXG4gICAgfVxuICB9XG5cbiAgZm9yICg7IG1MZW4gPj0gODsgYnVmZmVyW29mZnNldCArIGldID0gbSAmIDB4ZmYsIGkgKz0gZCwgbSAvPSAyNTYsIG1MZW4gLT0gOCkge31cblxuICBlID0gKGUgPDwgbUxlbikgfCBtXG4gIGVMZW4gKz0gbUxlblxuICBmb3IgKDsgZUxlbiA+IDA7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IGUgJiAweGZmLCBpICs9IGQsIGUgLz0gMjU2LCBlTGVuIC09IDgpIHt9XG5cbiAgYnVmZmVyW29mZnNldCArIGkgLSBkXSB8PSBzICogMTI4XG59XG4iLCJpZiAodHlwZW9mIE9iamVjdC5jcmVhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgLy8gaW1wbGVtZW50YXRpb24gZnJvbSBzdGFuZGFyZCBub2RlLmpzICd1dGlsJyBtb2R1bGVcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBpZiAoc3VwZXJDdG9yKSB7XG4gICAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgICAgY3Rvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ3Rvci5wcm90b3R5cGUsIHtcbiAgICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgICB2YWx1ZTogY3RvcixcbiAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG4gIH07XG59IGVsc2Uge1xuICAvLyBvbGQgc2Nob29sIHNoaW0gZm9yIG9sZCBicm93c2Vyc1xuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGlmIChzdXBlckN0b3IpIHtcbiAgICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgICB2YXIgVGVtcEN0b3IgPSBmdW5jdGlvbiAoKSB7fVxuICAgICAgVGVtcEN0b3IucHJvdG90eXBlID0gc3VwZXJDdG9yLnByb3RvdHlwZVxuICAgICAgY3Rvci5wcm90b3R5cGUgPSBuZXcgVGVtcEN0b3IoKVxuICAgICAgY3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjdG9yXG4gICAgfVxuICB9XG59XG4iLCJcInVzZSBzdHJpY3RcIlxuXG52YXIgYm91bmRzID0gcmVxdWlyZShcImJpbmFyeS1zZWFyY2gtYm91bmRzXCIpXG5cbnZhciBOT1RfRk9VTkQgPSAwXG52YXIgU1VDQ0VTUyA9IDFcbnZhciBFTVBUWSA9IDJcblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVXcmFwcGVyXG5cbmZ1bmN0aW9uIEludGVydmFsVHJlZU5vZGUobWlkLCBsZWZ0LCByaWdodCwgbGVmdFBvaW50cywgcmlnaHRQb2ludHMpIHtcbiAgdGhpcy5taWQgPSBtaWRcbiAgdGhpcy5sZWZ0ID0gbGVmdFxuICB0aGlzLnJpZ2h0ID0gcmlnaHRcbiAgdGhpcy5sZWZ0UG9pbnRzID0gbGVmdFBvaW50c1xuICB0aGlzLnJpZ2h0UG9pbnRzID0gcmlnaHRQb2ludHNcbiAgdGhpcy5jb3VudCA9IChsZWZ0ID8gbGVmdC5jb3VudCA6IDApICsgKHJpZ2h0ID8gcmlnaHQuY291bnQgOiAwKSArIGxlZnRQb2ludHMubGVuZ3RoXG59XG5cbnZhciBwcm90byA9IEludGVydmFsVHJlZU5vZGUucHJvdG90eXBlXG5cbmZ1bmN0aW9uIGNvcHkoYSwgYikge1xuICBhLm1pZCA9IGIubWlkXG4gIGEubGVmdCA9IGIubGVmdFxuICBhLnJpZ2h0ID0gYi5yaWdodFxuICBhLmxlZnRQb2ludHMgPSBiLmxlZnRQb2ludHNcbiAgYS5yaWdodFBvaW50cyA9IGIucmlnaHRQb2ludHNcbiAgYS5jb3VudCA9IGIuY291bnRcbn1cblxuZnVuY3Rpb24gcmVidWlsZChub2RlLCBpbnRlcnZhbHMpIHtcbiAgdmFyIG50cmVlID0gY3JlYXRlSW50ZXJ2YWxUcmVlKGludGVydmFscylcbiAgbm9kZS5taWQgPSBudHJlZS5taWRcbiAgbm9kZS5sZWZ0ID0gbnRyZWUubGVmdFxuICBub2RlLnJpZ2h0ID0gbnRyZWUucmlnaHRcbiAgbm9kZS5sZWZ0UG9pbnRzID0gbnRyZWUubGVmdFBvaW50c1xuICBub2RlLnJpZ2h0UG9pbnRzID0gbnRyZWUucmlnaHRQb2ludHNcbiAgbm9kZS5jb3VudCA9IG50cmVlLmNvdW50XG59XG5cbmZ1bmN0aW9uIHJlYnVpbGRXaXRoSW50ZXJ2YWwobm9kZSwgaW50ZXJ2YWwpIHtcbiAgdmFyIGludGVydmFscyA9IG5vZGUuaW50ZXJ2YWxzKFtdKVxuICBpbnRlcnZhbHMucHVzaChpbnRlcnZhbClcbiAgcmVidWlsZChub2RlLCBpbnRlcnZhbHMpICAgIFxufVxuXG5mdW5jdGlvbiByZWJ1aWxkV2l0aG91dEludGVydmFsKG5vZGUsIGludGVydmFsKSB7XG4gIHZhciBpbnRlcnZhbHMgPSBub2RlLmludGVydmFscyhbXSlcbiAgdmFyIGlkeCA9IGludGVydmFscy5pbmRleE9mKGludGVydmFsKVxuICBpZihpZHggPCAwKSB7XG4gICAgcmV0dXJuIE5PVF9GT1VORFxuICB9XG4gIGludGVydmFscy5zcGxpY2UoaWR4LCAxKVxuICByZWJ1aWxkKG5vZGUsIGludGVydmFscylcbiAgcmV0dXJuIFNVQ0NFU1Ncbn1cblxucHJvdG8uaW50ZXJ2YWxzID0gZnVuY3Rpb24ocmVzdWx0KSB7XG4gIHJlc3VsdC5wdXNoLmFwcGx5KHJlc3VsdCwgdGhpcy5sZWZ0UG9pbnRzKVxuICBpZih0aGlzLmxlZnQpIHtcbiAgICB0aGlzLmxlZnQuaW50ZXJ2YWxzKHJlc3VsdClcbiAgfVxuICBpZih0aGlzLnJpZ2h0KSB7XG4gICAgdGhpcy5yaWdodC5pbnRlcnZhbHMocmVzdWx0KVxuICB9XG4gIHJldHVybiByZXN1bHRcbn1cblxucHJvdG8uaW5zZXJ0ID0gZnVuY3Rpb24oaW50ZXJ2YWwpIHtcbiAgdmFyIHdlaWdodCA9IHRoaXMuY291bnQgLSB0aGlzLmxlZnRQb2ludHMubGVuZ3RoXG4gIHRoaXMuY291bnQgKz0gMVxuICBpZihpbnRlcnZhbFsxXSA8IHRoaXMubWlkKSB7XG4gICAgaWYodGhpcy5sZWZ0KSB7XG4gICAgICBpZig0Kih0aGlzLmxlZnQuY291bnQrMSkgPiAzKih3ZWlnaHQrMSkpIHtcbiAgICAgICAgcmVidWlsZFdpdGhJbnRlcnZhbCh0aGlzLCBpbnRlcnZhbClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubGVmdC5pbnNlcnQoaW50ZXJ2YWwpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubGVmdCA9IGNyZWF0ZUludGVydmFsVHJlZShbaW50ZXJ2YWxdKVxuICAgIH1cbiAgfSBlbHNlIGlmKGludGVydmFsWzBdID4gdGhpcy5taWQpIHtcbiAgICBpZih0aGlzLnJpZ2h0KSB7XG4gICAgICBpZig0Kih0aGlzLnJpZ2h0LmNvdW50KzEpID4gMyood2VpZ2h0KzEpKSB7XG4gICAgICAgIHJlYnVpbGRXaXRoSW50ZXJ2YWwodGhpcywgaW50ZXJ2YWwpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnJpZ2h0Lmluc2VydChpbnRlcnZhbClcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yaWdodCA9IGNyZWF0ZUludGVydmFsVHJlZShbaW50ZXJ2YWxdKVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgbCA9IGJvdW5kcy5nZSh0aGlzLmxlZnRQb2ludHMsIGludGVydmFsLCBjb21wYXJlQmVnaW4pXG4gICAgdmFyIHIgPSBib3VuZHMuZ2UodGhpcy5yaWdodFBvaW50cywgaW50ZXJ2YWwsIGNvbXBhcmVFbmQpXG4gICAgdGhpcy5sZWZ0UG9pbnRzLnNwbGljZShsLCAwLCBpbnRlcnZhbClcbiAgICB0aGlzLnJpZ2h0UG9pbnRzLnNwbGljZShyLCAwLCBpbnRlcnZhbClcbiAgfVxufVxuXG5wcm90by5yZW1vdmUgPSBmdW5jdGlvbihpbnRlcnZhbCkge1xuICB2YXIgd2VpZ2h0ID0gdGhpcy5jb3VudCAtIHRoaXMubGVmdFBvaW50c1xuICBpZihpbnRlcnZhbFsxXSA8IHRoaXMubWlkKSB7XG4gICAgaWYoIXRoaXMubGVmdCkge1xuICAgICAgcmV0dXJuIE5PVF9GT1VORFxuICAgIH1cbiAgICB2YXIgcncgPSB0aGlzLnJpZ2h0ID8gdGhpcy5yaWdodC5jb3VudCA6IDBcbiAgICBpZig0ICogcncgPiAzICogKHdlaWdodC0xKSkge1xuICAgICAgcmV0dXJuIHJlYnVpbGRXaXRob3V0SW50ZXJ2YWwodGhpcywgaW50ZXJ2YWwpXG4gICAgfVxuICAgIHZhciByID0gdGhpcy5sZWZ0LnJlbW92ZShpbnRlcnZhbClcbiAgICBpZihyID09PSBFTVBUWSkge1xuICAgICAgdGhpcy5sZWZ0ID0gbnVsbFxuICAgICAgdGhpcy5jb3VudCAtPSAxXG4gICAgICByZXR1cm4gU1VDQ0VTU1xuICAgIH0gZWxzZSBpZihyID09PSBTVUNDRVNTKSB7XG4gICAgICB0aGlzLmNvdW50IC09IDFcbiAgICB9XG4gICAgcmV0dXJuIHJcbiAgfSBlbHNlIGlmKGludGVydmFsWzBdID4gdGhpcy5taWQpIHtcbiAgICBpZighdGhpcy5yaWdodCkge1xuICAgICAgcmV0dXJuIE5PVF9GT1VORFxuICAgIH1cbiAgICB2YXIgbHcgPSB0aGlzLmxlZnQgPyB0aGlzLmxlZnQuY291bnQgOiAwXG4gICAgaWYoNCAqIGx3ID4gMyAqICh3ZWlnaHQtMSkpIHtcbiAgICAgIHJldHVybiByZWJ1aWxkV2l0aG91dEludGVydmFsKHRoaXMsIGludGVydmFsKVxuICAgIH1cbiAgICB2YXIgciA9IHRoaXMucmlnaHQucmVtb3ZlKGludGVydmFsKVxuICAgIGlmKHIgPT09IEVNUFRZKSB7XG4gICAgICB0aGlzLnJpZ2h0ID0gbnVsbFxuICAgICAgdGhpcy5jb3VudCAtPSAxXG4gICAgICByZXR1cm4gU1VDQ0VTU1xuICAgIH0gZWxzZSBpZihyID09PSBTVUNDRVNTKSB7XG4gICAgICB0aGlzLmNvdW50IC09IDFcbiAgICB9XG4gICAgcmV0dXJuIHJcbiAgfSBlbHNlIHtcbiAgICBpZih0aGlzLmNvdW50ID09PSAxKSB7XG4gICAgICBpZih0aGlzLmxlZnRQb2ludHNbMF0gPT09IGludGVydmFsKSB7XG4gICAgICAgIHJldHVybiBFTVBUWVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIE5PVF9GT1VORFxuICAgICAgfVxuICAgIH1cbiAgICBpZih0aGlzLmxlZnRQb2ludHMubGVuZ3RoID09PSAxICYmIHRoaXMubGVmdFBvaW50c1swXSA9PT0gaW50ZXJ2YWwpIHtcbiAgICAgIGlmKHRoaXMubGVmdCAmJiB0aGlzLnJpZ2h0KSB7XG4gICAgICAgIHZhciBwID0gdGhpc1xuICAgICAgICB2YXIgbiA9IHRoaXMubGVmdFxuICAgICAgICB3aGlsZShuLnJpZ2h0KSB7XG4gICAgICAgICAgcCA9IG5cbiAgICAgICAgICBuID0gbi5yaWdodFxuICAgICAgICB9XG4gICAgICAgIGlmKHAgPT09IHRoaXMpIHtcbiAgICAgICAgICBuLnJpZ2h0ID0gdGhpcy5yaWdodFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBsID0gdGhpcy5sZWZ0XG4gICAgICAgICAgdmFyIHIgPSB0aGlzLnJpZ2h0XG4gICAgICAgICAgcC5jb3VudCAtPSBuLmNvdW50XG4gICAgICAgICAgcC5yaWdodCA9IG4ubGVmdFxuICAgICAgICAgIG4ubGVmdCA9IGxcbiAgICAgICAgICBuLnJpZ2h0ID0gclxuICAgICAgICB9XG4gICAgICAgIGNvcHkodGhpcywgbilcbiAgICAgICAgdGhpcy5jb3VudCA9ICh0aGlzLmxlZnQ/dGhpcy5sZWZ0LmNvdW50OjApICsgKHRoaXMucmlnaHQ/dGhpcy5yaWdodC5jb3VudDowKSArIHRoaXMubGVmdFBvaW50cy5sZW5ndGhcbiAgICAgIH0gZWxzZSBpZih0aGlzLmxlZnQpIHtcbiAgICAgICAgY29weSh0aGlzLCB0aGlzLmxlZnQpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb3B5KHRoaXMsIHRoaXMucmlnaHQpXG4gICAgICB9XG4gICAgICByZXR1cm4gU1VDQ0VTU1xuICAgIH1cbiAgICBmb3IodmFyIGwgPSBib3VuZHMuZ2UodGhpcy5sZWZ0UG9pbnRzLCBpbnRlcnZhbCwgY29tcGFyZUJlZ2luKTsgbDx0aGlzLmxlZnRQb2ludHMubGVuZ3RoOyArK2wpIHtcbiAgICAgIGlmKHRoaXMubGVmdFBvaW50c1tsXVswXSAhPT0gaW50ZXJ2YWxbMF0pIHtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIGlmKHRoaXMubGVmdFBvaW50c1tsXSA9PT0gaW50ZXJ2YWwpIHtcbiAgICAgICAgdGhpcy5jb3VudCAtPSAxXG4gICAgICAgIHRoaXMubGVmdFBvaW50cy5zcGxpY2UobCwgMSlcbiAgICAgICAgZm9yKHZhciByID0gYm91bmRzLmdlKHRoaXMucmlnaHRQb2ludHMsIGludGVydmFsLCBjb21wYXJlRW5kKTsgcjx0aGlzLnJpZ2h0UG9pbnRzLmxlbmd0aDsgKytyKSB7XG4gICAgICAgICAgaWYodGhpcy5yaWdodFBvaW50c1tyXVsxXSAhPT0gaW50ZXJ2YWxbMV0pIHtcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfSBlbHNlIGlmKHRoaXMucmlnaHRQb2ludHNbcl0gPT09IGludGVydmFsKSB7XG4gICAgICAgICAgICB0aGlzLnJpZ2h0UG9pbnRzLnNwbGljZShyLCAxKVxuICAgICAgICAgICAgcmV0dXJuIFNVQ0NFU1NcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIE5PVF9GT1VORFxuICB9XG59XG5cbmZ1bmN0aW9uIHJlcG9ydExlZnRSYW5nZShhcnIsIGhpLCBjYikge1xuICBmb3IodmFyIGk9MDsgaTxhcnIubGVuZ3RoICYmIGFycltpXVswXSA8PSBoaTsgKytpKSB7XG4gICAgdmFyIHIgPSBjYihhcnJbaV0pXG4gICAgaWYocikgeyByZXR1cm4gciB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVwb3J0UmlnaHRSYW5nZShhcnIsIGxvLCBjYikge1xuICBmb3IodmFyIGk9YXJyLmxlbmd0aC0xOyBpPj0wICYmIGFycltpXVsxXSA+PSBsbzsgLS1pKSB7XG4gICAgdmFyIHIgPSBjYihhcnJbaV0pXG4gICAgaWYocikgeyByZXR1cm4gciB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVwb3J0UmFuZ2UoYXJyLCBjYikge1xuICBmb3IodmFyIGk9MDsgaTxhcnIubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgciA9IGNiKGFycltpXSlcbiAgICBpZihyKSB7IHJldHVybiByIH1cbiAgfVxufVxuXG5wcm90by5xdWVyeVBvaW50ID0gZnVuY3Rpb24oeCwgY2IpIHtcbiAgaWYoeCA8IHRoaXMubWlkKSB7XG4gICAgaWYodGhpcy5sZWZ0KSB7XG4gICAgICB2YXIgciA9IHRoaXMubGVmdC5xdWVyeVBvaW50KHgsIGNiKVxuICAgICAgaWYocikgeyByZXR1cm4gciB9XG4gICAgfVxuICAgIHJldHVybiByZXBvcnRMZWZ0UmFuZ2UodGhpcy5sZWZ0UG9pbnRzLCB4LCBjYilcbiAgfSBlbHNlIGlmKHggPiB0aGlzLm1pZCkge1xuICAgIGlmKHRoaXMucmlnaHQpIHtcbiAgICAgIHZhciByID0gdGhpcy5yaWdodC5xdWVyeVBvaW50KHgsIGNiKVxuICAgICAgaWYocikgeyByZXR1cm4gciB9XG4gICAgfVxuICAgIHJldHVybiByZXBvcnRSaWdodFJhbmdlKHRoaXMucmlnaHRQb2ludHMsIHgsIGNiKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiByZXBvcnRSYW5nZSh0aGlzLmxlZnRQb2ludHMsIGNiKVxuICB9XG59XG5cbnByb3RvLnF1ZXJ5SW50ZXJ2YWwgPSBmdW5jdGlvbihsbywgaGksIGNiKSB7XG4gIGlmKGxvIDwgdGhpcy5taWQgJiYgdGhpcy5sZWZ0KSB7XG4gICAgdmFyIHIgPSB0aGlzLmxlZnQucXVlcnlJbnRlcnZhbChsbywgaGksIGNiKVxuICAgIGlmKHIpIHsgcmV0dXJuIHIgfVxuICB9XG4gIGlmKGhpID4gdGhpcy5taWQgJiYgdGhpcy5yaWdodCkge1xuICAgIHZhciByID0gdGhpcy5yaWdodC5xdWVyeUludGVydmFsKGxvLCBoaSwgY2IpXG4gICAgaWYocikgeyByZXR1cm4gciB9XG4gIH1cbiAgaWYoaGkgPCB0aGlzLm1pZCkge1xuICAgIHJldHVybiByZXBvcnRMZWZ0UmFuZ2UodGhpcy5sZWZ0UG9pbnRzLCBoaSwgY2IpXG4gIH0gZWxzZSBpZihsbyA+IHRoaXMubWlkKSB7XG4gICAgcmV0dXJuIHJlcG9ydFJpZ2h0UmFuZ2UodGhpcy5yaWdodFBvaW50cywgbG8sIGNiKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiByZXBvcnRSYW5nZSh0aGlzLmxlZnRQb2ludHMsIGNiKVxuICB9XG59XG5cbmZ1bmN0aW9uIGNvbXBhcmVOdW1iZXJzKGEsIGIpIHtcbiAgcmV0dXJuIGEgLSBiXG59XG5cbmZ1bmN0aW9uIGNvbXBhcmVCZWdpbihhLCBiKSB7XG4gIHZhciBkID0gYVswXSAtIGJbMF1cbiAgaWYoZCkgeyByZXR1cm4gZCB9XG4gIHJldHVybiBhWzFdIC0gYlsxXVxufVxuXG5mdW5jdGlvbiBjb21wYXJlRW5kKGEsIGIpIHtcbiAgdmFyIGQgPSBhWzFdIC0gYlsxXVxuICBpZihkKSB7IHJldHVybiBkIH1cbiAgcmV0dXJuIGFbMF0gLSBiWzBdXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUludGVydmFsVHJlZShpbnRlcnZhbHMpIHtcbiAgaWYoaW50ZXJ2YWxzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBudWxsXG4gIH1cbiAgdmFyIHB0cyA9IFtdXG4gIGZvcih2YXIgaT0wOyBpPGludGVydmFscy5sZW5ndGg7ICsraSkge1xuICAgIHB0cy5wdXNoKGludGVydmFsc1tpXVswXSwgaW50ZXJ2YWxzW2ldWzFdKVxuICB9XG4gIHB0cy5zb3J0KGNvbXBhcmVOdW1iZXJzKVxuXG4gIHZhciBtaWQgPSBwdHNbcHRzLmxlbmd0aD4+MV1cblxuICB2YXIgbGVmdEludGVydmFscyA9IFtdXG4gIHZhciByaWdodEludGVydmFscyA9IFtdXG4gIHZhciBjZW50ZXJJbnRlcnZhbHMgPSBbXVxuICBmb3IodmFyIGk9MDsgaTxpbnRlcnZhbHMubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgcyA9IGludGVydmFsc1tpXVxuICAgIGlmKHNbMV0gPCBtaWQpIHtcbiAgICAgIGxlZnRJbnRlcnZhbHMucHVzaChzKVxuICAgIH0gZWxzZSBpZihtaWQgPCBzWzBdKSB7XG4gICAgICByaWdodEludGVydmFscy5wdXNoKHMpXG4gICAgfSBlbHNlIHtcbiAgICAgIGNlbnRlckludGVydmFscy5wdXNoKHMpXG4gICAgfVxuICB9XG5cbiAgLy9TcGxpdCBjZW50ZXIgaW50ZXJ2YWxzXG4gIHZhciBsZWZ0UG9pbnRzID0gY2VudGVySW50ZXJ2YWxzXG4gIHZhciByaWdodFBvaW50cyA9IGNlbnRlckludGVydmFscy5zbGljZSgpXG4gIGxlZnRQb2ludHMuc29ydChjb21wYXJlQmVnaW4pXG4gIHJpZ2h0UG9pbnRzLnNvcnQoY29tcGFyZUVuZClcblxuICByZXR1cm4gbmV3IEludGVydmFsVHJlZU5vZGUobWlkLCBcbiAgICBjcmVhdGVJbnRlcnZhbFRyZWUobGVmdEludGVydmFscyksXG4gICAgY3JlYXRlSW50ZXJ2YWxUcmVlKHJpZ2h0SW50ZXJ2YWxzKSxcbiAgICBsZWZ0UG9pbnRzLFxuICAgIHJpZ2h0UG9pbnRzKVxufVxuXG4vL1VzZXIgZnJpZW5kbHkgd3JhcHBlciB0aGF0IG1ha2VzIGl0IHBvc3NpYmxlIHRvIHN1cHBvcnQgZW1wdHkgdHJlZXNcbmZ1bmN0aW9uIEludGVydmFsVHJlZShyb290KSB7XG4gIHRoaXMucm9vdCA9IHJvb3Rcbn1cblxudmFyIHRwcm90byA9IEludGVydmFsVHJlZS5wcm90b3R5cGVcblxudHByb3RvLmluc2VydCA9IGZ1bmN0aW9uKGludGVydmFsKSB7XG4gIGlmKHRoaXMucm9vdCkge1xuICAgIHRoaXMucm9vdC5pbnNlcnQoaW50ZXJ2YWwpXG4gIH0gZWxzZSB7XG4gICAgdGhpcy5yb290ID0gbmV3IEludGVydmFsVHJlZU5vZGUoaW50ZXJ2YWxbMF0sIG51bGwsIG51bGwsIFtpbnRlcnZhbF0sIFtpbnRlcnZhbF0pXG4gIH1cbn1cblxudHByb3RvLnJlbW92ZSA9IGZ1bmN0aW9uKGludGVydmFsKSB7XG4gIGlmKHRoaXMucm9vdCkge1xuICAgIHZhciByID0gdGhpcy5yb290LnJlbW92ZShpbnRlcnZhbClcbiAgICBpZihyID09PSBFTVBUWSkge1xuICAgICAgdGhpcy5yb290ID0gbnVsbFxuICAgIH1cbiAgICByZXR1cm4gciAhPT0gTk9UX0ZPVU5EXG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbnRwcm90by5xdWVyeVBvaW50ID0gZnVuY3Rpb24ocCwgY2IpIHtcbiAgaWYodGhpcy5yb290KSB7XG4gICAgcmV0dXJuIHRoaXMucm9vdC5xdWVyeVBvaW50KHAsIGNiKVxuICB9XG59XG5cbnRwcm90by5xdWVyeUludGVydmFsID0gZnVuY3Rpb24obG8sIGhpLCBjYikge1xuICBpZihsbyA8PSBoaSAmJiB0aGlzLnJvb3QpIHtcbiAgICByZXR1cm4gdGhpcy5yb290LnF1ZXJ5SW50ZXJ2YWwobG8sIGhpLCBjYilcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkodHByb3RvLCBcImNvdW50XCIsIHtcbiAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICBpZih0aGlzLnJvb3QpIHtcbiAgICAgIHJldHVybiB0aGlzLnJvb3QuY291bnRcbiAgICB9XG4gICAgcmV0dXJuIDBcbiAgfVxufSlcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KHRwcm90bywgXCJpbnRlcnZhbHNcIiwge1xuICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIGlmKHRoaXMucm9vdCkge1xuICAgICAgcmV0dXJuIHRoaXMucm9vdC5pbnRlcnZhbHMoW10pXG4gICAgfVxuICAgIHJldHVybiBbXVxuICB9XG59KVxuXG5mdW5jdGlvbiBjcmVhdGVXcmFwcGVyKGludGVydmFscykge1xuICBpZighaW50ZXJ2YWxzIHx8IGludGVydmFscy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gbmV3IEludGVydmFsVHJlZShudWxsKVxuICB9XG4gIHJldHVybiBuZXcgSW50ZXJ2YWxUcmVlKGNyZWF0ZUludGVydmFsVHJlZShpbnRlcnZhbHMpKVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCJcblxuZnVuY3Rpb24gaW52ZXJ0UGVybXV0YXRpb24ocGksIHJlc3VsdCkge1xuICByZXN1bHQgPSByZXN1bHQgfHwgbmV3IEFycmF5KHBpLmxlbmd0aClcbiAgZm9yKHZhciBpPTA7IGk8cGkubGVuZ3RoOyArK2kpIHtcbiAgICByZXN1bHRbcGlbaV1dID0gaVxuICB9XG4gIHJldHVybiByZXN1bHRcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpbnZlcnRQZXJtdXRhdGlvbiIsIlwidXNlIHN0cmljdFwiXG5cbmZ1bmN0aW9uIGlvdGEobikge1xuICB2YXIgcmVzdWx0ID0gbmV3IEFycmF5KG4pXG4gIGZvcih2YXIgaT0wOyBpPG47ICsraSkge1xuICAgIHJlc3VsdFtpXSA9IGlcbiAgfVxuICByZXR1cm4gcmVzdWx0XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaW90YSIsIi8qIVxuICogRGV0ZXJtaW5lIGlmIGFuIG9iamVjdCBpcyBhIEJ1ZmZlclxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwczovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cblxuLy8gVGhlIF9pc0J1ZmZlciBjaGVjayBpcyBmb3IgU2FmYXJpIDUtNyBzdXBwb3J0LCBiZWNhdXNlIGl0J3MgbWlzc2luZ1xuLy8gT2JqZWN0LnByb3RvdHlwZS5jb25zdHJ1Y3Rvci4gUmVtb3ZlIHRoaXMgZXZlbnR1YWxseVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiBvYmogIT0gbnVsbCAmJiAoaXNCdWZmZXIob2JqKSB8fCBpc1Nsb3dCdWZmZXIob2JqKSB8fCAhIW9iai5faXNCdWZmZXIpXG59XG5cbmZ1bmN0aW9uIGlzQnVmZmVyIChvYmopIHtcbiAgcmV0dXJuICEhb2JqLmNvbnN0cnVjdG9yICYmIHR5cGVvZiBvYmouY29uc3RydWN0b3IuaXNCdWZmZXIgPT09ICdmdW5jdGlvbicgJiYgb2JqLmNvbnN0cnVjdG9yLmlzQnVmZmVyKG9iailcbn1cblxuLy8gRm9yIE5vZGUgdjAuMTAgc3VwcG9ydC4gUmVtb3ZlIHRoaXMgZXZlbnR1YWxseS5cbmZ1bmN0aW9uIGlzU2xvd0J1ZmZlciAob2JqKSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqLnJlYWRGbG9hdExFID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBvYmouc2xpY2UgPT09ICdmdW5jdGlvbicgJiYgaXNCdWZmZXIob2JqLnNsaWNlKDAsIDApKVxufVxuIiwiIWZ1bmN0aW9uKHIsdCl7XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHMmJlwidW5kZWZpbmVkXCIhPXR5cGVvZiBtb2R1bGU/bW9kdWxlLmV4cG9ydHM9dCgpOlwiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUodCk6KHI9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGdsb2JhbFRoaXM/Z2xvYmFsVGhpczpyfHxzZWxmKS5NZXlkYT10KCl9KHRoaXMsKGZ1bmN0aW9uKCl7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gcihyLHQsZSl7aWYoZXx8Mj09PWFyZ3VtZW50cy5sZW5ndGgpZm9yKHZhciBhLG49MCxvPXQubGVuZ3RoO248bztuKyspIWEmJm4gaW4gdHx8KGF8fChhPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHQsMCxuKSksYVtuXT10W25dKTtyZXR1cm4gci5jb25jYXQoYXx8QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodCkpfXZhciB0PU9iamVjdC5mcmVlemUoe19fcHJvdG9fXzpudWxsLGJsYWNrbWFuOmZ1bmN0aW9uKHIpe2Zvcih2YXIgdD1uZXcgRmxvYXQzMkFycmF5KHIpLGU9MipNYXRoLlBJLyhyLTEpLGE9MiplLG49MDtuPHIvMjtuKyspdFtuXT0uNDItLjUqTWF0aC5jb3MobiplKSsuMDgqTWF0aC5jb3MobiphKTtmb3Iobj1NYXRoLmNlaWwoci8yKTtuPjA7bi0tKXRbci1uXT10W24tMV07cmV0dXJuIHR9LHNpbmU6ZnVuY3Rpb24ocil7Zm9yKHZhciB0PU1hdGguUEkvKHItMSksZT1uZXcgRmxvYXQzMkFycmF5KHIpLGE9MDthPHI7YSsrKWVbYV09TWF0aC5zaW4odCphKTtyZXR1cm4gZX0saGFubmluZzpmdW5jdGlvbihyKXtmb3IodmFyIHQ9bmV3IEZsb2F0MzJBcnJheShyKSxlPTA7ZTxyO2UrKyl0W2VdPS41LS41Kk1hdGguY29zKDIqTWF0aC5QSSplLyhyLTEpKTtyZXR1cm4gdH0saGFtbWluZzpmdW5jdGlvbihyKXtmb3IodmFyIHQ9bmV3IEZsb2F0MzJBcnJheShyKSxlPTA7ZTxyO2UrKyl0W2VdPS41NC0uNDYqTWF0aC5jb3MoMipNYXRoLlBJKihlL3ItMSkpO3JldHVybiB0fX0pLGU9e307ZnVuY3Rpb24gYShyKXtmb3IoO3IlMj09MCYmcj4xOylyLz0yO3JldHVybiAxPT09cn1mdW5jdGlvbiBuKHIsYSl7aWYoXCJyZWN0XCIhPT1hKXtpZihcIlwiIT09YSYmYXx8KGE9XCJoYW5uaW5nXCIpLGVbYV18fChlW2FdPXt9KSwhZVthXVtyLmxlbmd0aF0pdHJ5e2VbYV1bci5sZW5ndGhdPXRbYV0oci5sZW5ndGgpfWNhdGNoKHIpe3Rocm93IG5ldyBFcnJvcihcIkludmFsaWQgd2luZG93aW5nIGZ1bmN0aW9uXCIpfXI9ZnVuY3Rpb24ocix0KXtmb3IodmFyIGU9W10sYT0wO2E8TWF0aC5taW4oci5sZW5ndGgsdC5sZW5ndGgpO2ErKyllW2FdPXJbYV0qdFthXTtyZXR1cm4gZX0ocixlW2FdW3IubGVuZ3RoXSl9cmV0dXJuIHJ9ZnVuY3Rpb24gbyhyLHQsZSl7Zm9yKHZhciBhPW5ldyBGbG9hdDMyQXJyYXkociksbj0wO248YS5sZW5ndGg7bisrKWFbbl09bip0L2UsYVtuXT0xMypNYXRoLmF0YW4oYVtuXS8xMzE1LjgpKzMuNSpNYXRoLmF0YW4oTWF0aC5wb3coYVtuXS83NTE4LDIpKTtyZXR1cm4gYX1mdW5jdGlvbiBpKHIpe3JldHVybiBGbG9hdDMyQXJyYXkuZnJvbShyKX1mdW5jdGlvbiB1KHIpe3JldHVybiAxMTI1Kk1hdGgubG9nKDErci83MDApfWZ1bmN0aW9uIGYocix0LGUpe2Zvcih2YXIgYSxuPW5ldyBGbG9hdDMyQXJyYXkocisyKSxvPW5ldyBGbG9hdDMyQXJyYXkocisyKSxpPXQvMixmPXUoMCksYz0odShpKS1mKS8ocisxKSxsPW5ldyBBcnJheShyKzIpLHM9MDtzPG4ubGVuZ3RoO3MrKyluW3NdPXMqYyxvW3NdPShhPW5bc10sNzAwKihNYXRoLmV4cChhLzExMjUpLTEpKSxsW3NdPU1hdGguZmxvb3IoKGUrMSkqb1tzXS90KTtmb3IodmFyIG09bmV3IEFycmF5KHIpLHA9MDtwPG0ubGVuZ3RoO3ArKyl7bVtwXT1uZXcgQXJyYXkoZS8yKzEpLmZpbGwoMCk7Zm9yKHM9bFtwXTtzPGxbcCsxXTtzKyspbVtwXVtzXT0ocy1sW3BdKS8obFtwKzFdLWxbcF0pO2ZvcihzPWxbcCsxXTtzPGxbcCsyXTtzKyspbVtwXVtzXT0obFtwKzJdLXMpLyhsW3ArMl0tbFtwKzFdKX1yZXR1cm4gbX1mdW5jdGlvbiBjKHQsZSxhLG4sbyxpLHUpe3ZvaWQgMD09PW4mJihuPTUpLHZvaWQgMD09PW8mJihvPTIpLHZvaWQgMD09PWkmJihpPSEwKSx2b2lkIDA9PT11JiYodT00NDApO3ZhciBmPU1hdGguZmxvb3IoYS8yKSsxLGM9bmV3IEFycmF5KGEpLmZpbGwoMCkubWFwKChmdW5jdGlvbihyLG4pe3JldHVybiB0KmZ1bmN0aW9uKHIsdCl7cmV0dXJuIE1hdGgubG9nMigxNipyL3QpfShlKm4vYSx1KX0pKTtjWzBdPWNbMV0tMS41KnQ7dmFyIGwscyxtLHA9Yy5zbGljZSgxKS5tYXAoKGZ1bmN0aW9uKHIsdCl7cmV0dXJuIE1hdGgubWF4KHItY1t0XSl9KSwxKS5jb25jYXQoWzFdKSxoPU1hdGgucm91bmQodC8yKSxnPW5ldyBBcnJheSh0KS5maWxsKDApLm1hcCgoZnVuY3Rpb24ocixlKXtyZXR1cm4gYy5tYXAoKGZ1bmN0aW9uKHIpe3JldHVybigxMCp0K2grci1lKSV0LWh9KSl9KSksdz1nLm1hcCgoZnVuY3Rpb24ocix0KXtyZXR1cm4gci5tYXAoKGZ1bmN0aW9uKHIsZSl7cmV0dXJuIE1hdGguZXhwKC0uNSpNYXRoLnBvdygyKmdbdF1bZV0vcFtlXSwyKSl9KSl9KSk7aWYocz0obD13KVswXS5tYXAoKGZ1bmN0aW9uKCl7cmV0dXJuIDB9KSksbT1sLnJlZHVjZSgoZnVuY3Rpb24ocix0KXtyZXR1cm4gdC5mb3JFYWNoKChmdW5jdGlvbih0LGUpe3JbZV0rPU1hdGgucG93KHQsMil9KSkscn0pLHMpLm1hcChNYXRoLnNxcnQpLHc9bC5tYXAoKGZ1bmN0aW9uKHIsdCl7cmV0dXJuIHIubWFwKChmdW5jdGlvbihyLHQpe3JldHVybiByLyhtW3RdfHwxKX0pKX0pKSxvKXt2YXIgdj1jLm1hcCgoZnVuY3Rpb24ocil7cmV0dXJuIE1hdGguZXhwKC0uNSpNYXRoLnBvdygoci90LW4pL28sMikpfSkpO3c9dy5tYXAoKGZ1bmN0aW9uKHIpe3JldHVybiByLm1hcCgoZnVuY3Rpb24ocix0KXtyZXR1cm4gcip2W3RdfSkpfSkpfXJldHVybiBpJiYodz1yKHIoW10sdy5zbGljZSgzKSwhMCksdy5zbGljZSgwLDMpLCEwKSksdy5tYXAoKGZ1bmN0aW9uKHIpe3JldHVybiByLnNsaWNlKDAsZil9KSl9ZnVuY3Rpb24gbChyLHQpe2Zvcih2YXIgZT0wLGE9MCxuPTA7bjx0Lmxlbmd0aDtuKyspZSs9TWF0aC5wb3cobixyKSpNYXRoLmFicyh0W25dKSxhKz10W25dO3JldHVybiBlL2F9ZnVuY3Rpb24gcyhyKXt2YXIgdD1yLmFtcFNwZWN0cnVtLGU9ci5iYXJrU2NhbGUsYT1yLm51bWJlck9mQmFya0JhbmRzLG49dm9pZCAwPT09YT8yNDphO2lmKFwib2JqZWN0XCIhPXR5cGVvZiB0fHxcIm9iamVjdFwiIT10eXBlb2YgZSl0aHJvdyBuZXcgVHlwZUVycm9yO3ZhciBvPW4saT1uZXcgRmxvYXQzMkFycmF5KG8pLHU9MCxmPXQsYz1uZXcgSW50MzJBcnJheShvKzEpO2NbMF09MDtmb3IodmFyIGw9ZVtmLmxlbmd0aC0xXS9vLHM9MSxtPTA7bTxmLmxlbmd0aDttKyspZm9yKDtlW21dPmw7KWNbcysrXT1tLGw9cyplW2YubGVuZ3RoLTFdL287Y1tvXT1mLmxlbmd0aC0xO2ZvcihtPTA7bTxvO20rKyl7Zm9yKHZhciBwPTAsaD1jW21dO2g8Y1ttKzFdO2grKylwKz1mW2hdO2lbbV09TWF0aC5wb3cocCwuMjMpfWZvcihtPTA7bTxpLmxlbmd0aDttKyspdSs9aVttXTtyZXR1cm57c3BlY2lmaWM6aSx0b3RhbDp1fX1mdW5jdGlvbiBtKHIpe3ZhciB0PXIuYW1wU3BlY3RydW07aWYoXCJvYmplY3RcIiE9dHlwZW9mIHQpdGhyb3cgbmV3IFR5cGVFcnJvcjtmb3IodmFyIGU9bmV3IEZsb2F0MzJBcnJheSh0Lmxlbmd0aCksYT0wO2E8ZS5sZW5ndGg7YSsrKWVbYV09TWF0aC5wb3codFthXSwyKTtyZXR1cm4gZX1mdW5jdGlvbiBwKHIpe3ZhciB0PXIuYW1wU3BlY3RydW0sZT1yLm1lbEZpbHRlckJhbmssYT1yLmJ1ZmZlclNpemU7aWYoXCJvYmplY3RcIiE9dHlwZW9mIHQpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlZhbGlkIGFtcFNwZWN0cnVtIGlzIHJlcXVpcmVkIHRvIGdlbmVyYXRlIG1lbEJhbmRzXCIpO2lmKFwib2JqZWN0XCIhPXR5cGVvZiBlKXRocm93IG5ldyBUeXBlRXJyb3IoXCJWYWxpZCBtZWxGaWx0ZXJCYW5rIGlzIHJlcXVpcmVkIHRvIGdlbmVyYXRlIG1lbEJhbmRzXCIpO2Zvcih2YXIgbj1tKHthbXBTcGVjdHJ1bTp0fSksbz1lLmxlbmd0aCxpPUFycmF5KG8pLHU9bmV3IEZsb2F0MzJBcnJheShvKSxmPTA7Zjx1Lmxlbmd0aDtmKyspe2lbZl09bmV3IEZsb2F0MzJBcnJheShhLzIpLHVbZl09MDtmb3IodmFyIGM9MDtjPGEvMjtjKyspaVtmXVtjXT1lW2ZdW2NdKm5bY10sdVtmXSs9aVtmXVtjXTt1W2ZdPU1hdGgubG9nKHVbZl0rMSl9cmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHUpfWZ1bmN0aW9uIGgocil7cmV0dXJuIHImJnIuX19lc01vZHVsZSYmT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHIsXCJkZWZhdWx0XCIpP3IuZGVmYXVsdDpyfXZhciBnPXtleHBvcnRzOnt9fSx3PW51bGw7dmFyIHY9ZnVuY3Rpb24ocix0KXt2YXIgZT1yLmxlbmd0aDtyZXR1cm4gdD10fHwyLHcmJndbZV18fGZ1bmN0aW9uKHIpeyh3PXd8fHt9KVtyXT1uZXcgQXJyYXkocipyKTtmb3IodmFyIHQ9TWF0aC5QSS9yLGU9MDtlPHI7ZSsrKWZvcih2YXIgYT0wO2E8cjthKyspd1tyXVthK2Uqcl09TWF0aC5jb3ModCooYSsuNSkqZSl9KGUpLHIubWFwKChmdW5jdGlvbigpe3JldHVybiAwfSkpLm1hcCgoZnVuY3Rpb24oYSxuKXtyZXR1cm4gdCpyLnJlZHVjZSgoZnVuY3Rpb24ocix0LGEsbyl7cmV0dXJuIHIrdCp3W2VdW2ErbiplXX0pLDApfSkpfTshZnVuY3Rpb24ocil7ci5leHBvcnRzPXZ9KGcpO3ZhciBkPWgoZy5leHBvcnRzKTt2YXIgeT1PYmplY3QuZnJlZXplKHtfX3Byb3RvX186bnVsbCxidWZmZXI6ZnVuY3Rpb24ocil7cmV0dXJuIHIuc2lnbmFsfSxybXM6ZnVuY3Rpb24ocil7dmFyIHQ9ci5zaWduYWw7aWYoXCJvYmplY3RcIiE9dHlwZW9mIHQpdGhyb3cgbmV3IFR5cGVFcnJvcjtmb3IodmFyIGU9MCxhPTA7YTx0Lmxlbmd0aDthKyspZSs9TWF0aC5wb3codFthXSwyKTtyZXR1cm4gZS89dC5sZW5ndGgsZT1NYXRoLnNxcnQoZSl9LGVuZXJneTpmdW5jdGlvbihyKXt2YXIgdD1yLnNpZ25hbDtpZihcIm9iamVjdFwiIT10eXBlb2YgdCl0aHJvdyBuZXcgVHlwZUVycm9yO2Zvcih2YXIgZT0wLGE9MDthPHQubGVuZ3RoO2ErKyllKz1NYXRoLnBvdyhNYXRoLmFicyh0W2FdKSwyKTtyZXR1cm4gZX0sY29tcGxleFNwZWN0cnVtOmZ1bmN0aW9uKHIpe3JldHVybiByLmNvbXBsZXhTcGVjdHJ1bX0sc3BlY3RyYWxTbG9wZTpmdW5jdGlvbihyKXt2YXIgdD1yLmFtcFNwZWN0cnVtLGU9ci5zYW1wbGVSYXRlLGE9ci5idWZmZXJTaXplO2lmKFwib2JqZWN0XCIhPXR5cGVvZiB0KXRocm93IG5ldyBUeXBlRXJyb3I7Zm9yKHZhciBuPTAsbz0wLGk9bmV3IEZsb2F0MzJBcnJheSh0Lmxlbmd0aCksdT0wLGY9MCxjPTA7Yzx0Lmxlbmd0aDtjKyspe24rPXRbY107dmFyIGw9YyplL2E7aVtjXT1sLHUrPWwqbCxvKz1sLGYrPWwqdFtjXX1yZXR1cm4odC5sZW5ndGgqZi1vKm4pLyhuKih1LU1hdGgucG93KG8sMikpKX0sc3BlY3RyYWxDZW50cm9pZDpmdW5jdGlvbihyKXt2YXIgdD1yLmFtcFNwZWN0cnVtO2lmKFwib2JqZWN0XCIhPXR5cGVvZiB0KXRocm93IG5ldyBUeXBlRXJyb3I7cmV0dXJuIGwoMSx0KX0sc3BlY3RyYWxSb2xsb2ZmOmZ1bmN0aW9uKHIpe3ZhciB0PXIuYW1wU3BlY3RydW0sZT1yLnNhbXBsZVJhdGU7aWYoXCJvYmplY3RcIiE9dHlwZW9mIHQpdGhyb3cgbmV3IFR5cGVFcnJvcjtmb3IodmFyIGE9dCxuPWUvKDIqKGEubGVuZ3RoLTEpKSxvPTAsaT0wO2k8YS5sZW5ndGg7aSsrKW8rPWFbaV07Zm9yKHZhciB1PS45OSpvLGY9YS5sZW5ndGgtMTtvPnUmJmY+PTA7KW8tPWFbZl0sLS1mO3JldHVybihmKzEpKm59LHNwZWN0cmFsRmxhdG5lc3M6ZnVuY3Rpb24ocil7dmFyIHQ9ci5hbXBTcGVjdHJ1bTtpZihcIm9iamVjdFwiIT10eXBlb2YgdCl0aHJvdyBuZXcgVHlwZUVycm9yO2Zvcih2YXIgZT0wLGE9MCxuPTA7bjx0Lmxlbmd0aDtuKyspZSs9TWF0aC5sb2codFtuXSksYSs9dFtuXTtyZXR1cm4gTWF0aC5leHAoZS90Lmxlbmd0aCkqdC5sZW5ndGgvYX0sc3BlY3RyYWxTcHJlYWQ6ZnVuY3Rpb24ocil7dmFyIHQ9ci5hbXBTcGVjdHJ1bTtpZihcIm9iamVjdFwiIT10eXBlb2YgdCl0aHJvdyBuZXcgVHlwZUVycm9yO3JldHVybiBNYXRoLnNxcnQobCgyLHQpLU1hdGgucG93KGwoMSx0KSwyKSl9LHNwZWN0cmFsU2tld25lc3M6ZnVuY3Rpb24ocil7dmFyIHQ9ci5hbXBTcGVjdHJ1bTtpZihcIm9iamVjdFwiIT10eXBlb2YgdCl0aHJvdyBuZXcgVHlwZUVycm9yO3ZhciBlPWwoMSx0KSxhPWwoMix0KSxuPWwoMyx0KTtyZXR1cm4oMipNYXRoLnBvdyhlLDMpLTMqZSphK24pL01hdGgucG93KE1hdGguc3FydChhLU1hdGgucG93KGUsMikpLDMpfSxzcGVjdHJhbEt1cnRvc2lzOmZ1bmN0aW9uKHIpe3ZhciB0PXIuYW1wU3BlY3RydW07aWYoXCJvYmplY3RcIiE9dHlwZW9mIHQpdGhyb3cgbmV3IFR5cGVFcnJvcjt2YXIgZT10LGE9bCgxLGUpLG49bCgyLGUpLG89bCgzLGUpLGk9bCg0LGUpO3JldHVybigtMypNYXRoLnBvdyhhLDQpKzYqYSpuLTQqYSpvK2kpL01hdGgucG93KE1hdGguc3FydChuLU1hdGgucG93KGEsMikpLDQpfSxhbXBsaXR1ZGVTcGVjdHJ1bTpmdW5jdGlvbihyKXtyZXR1cm4gci5hbXBTcGVjdHJ1bX0semNyOmZ1bmN0aW9uKHIpe3ZhciB0PXIuc2lnbmFsO2lmKFwib2JqZWN0XCIhPXR5cGVvZiB0KXRocm93IG5ldyBUeXBlRXJyb3I7Zm9yKHZhciBlPTAsYT0xO2E8dC5sZW5ndGg7YSsrKSh0W2EtMV0+PTAmJnRbYV08MHx8dFthLTFdPDAmJnRbYV0+PTApJiZlKys7cmV0dXJuIGV9LGxvdWRuZXNzOnMscGVyY2VwdHVhbFNwcmVhZDpmdW5jdGlvbihyKXtmb3IodmFyIHQ9cyh7YW1wU3BlY3RydW06ci5hbXBTcGVjdHJ1bSxiYXJrU2NhbGU6ci5iYXJrU2NhbGV9KSxlPTAsYT0wO2E8dC5zcGVjaWZpYy5sZW5ndGg7YSsrKXQuc3BlY2lmaWNbYV0+ZSYmKGU9dC5zcGVjaWZpY1thXSk7cmV0dXJuIE1hdGgucG93KCh0LnRvdGFsLWUpL3QudG90YWwsMil9LHBlcmNlcHR1YWxTaGFycG5lc3M6ZnVuY3Rpb24ocil7Zm9yKHZhciB0PXMoe2FtcFNwZWN0cnVtOnIuYW1wU3BlY3RydW0sYmFya1NjYWxlOnIuYmFya1NjYWxlfSksZT10LnNwZWNpZmljLGE9MCxuPTA7bjxlLmxlbmd0aDtuKyspYSs9bjwxNT8obisxKSplW24rMV06LjA2NipNYXRoLmV4cCguMTcxKihuKzEpKTtyZXR1cm4gYSo9LjExL3QudG90YWx9LHBvd2VyU3BlY3RydW06bSxtZmNjOmZ1bmN0aW9uKHIpe3ZhciB0PXIuYW1wU3BlY3RydW0sZT1yLm1lbEZpbHRlckJhbmssYT1yLm51bWJlck9mTUZDQ0NvZWZmaWNpZW50cyxuPXIuYnVmZmVyU2l6ZSxvPU1hdGgubWluKDQwLE1hdGgubWF4KDEsYXx8MTMpKTtpZihlLmxlbmd0aDxvKXRocm93IG5ldyBFcnJvcihcIkluc3VmZmljaWVudCBmaWx0ZXIgYmFuayBmb3IgcmVxdWVzdGVkIG51bWJlciBvZiBjb2VmZmljaWVudHNcIik7dmFyIGk9cCh7YW1wU3BlY3RydW06dCxtZWxGaWx0ZXJCYW5rOmUsYnVmZmVyU2l6ZTpufSk7cmV0dXJuIGQoaSkuc2xpY2UoMCxvKX0sY2hyb21hOmZ1bmN0aW9uKHIpe3ZhciB0PXIuYW1wU3BlY3RydW0sZT1yLmNocm9tYUZpbHRlckJhbms7aWYoXCJvYmplY3RcIiE9dHlwZW9mIHQpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlZhbGlkIGFtcFNwZWN0cnVtIGlzIHJlcXVpcmVkIHRvIGdlbmVyYXRlIGNocm9tYVwiKTtpZihcIm9iamVjdFwiIT10eXBlb2YgZSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiVmFsaWQgY2hyb21hRmlsdGVyQmFuayBpcyByZXF1aXJlZCB0byBnZW5lcmF0ZSBjaHJvbWFcIik7dmFyIGE9ZS5tYXAoKGZ1bmN0aW9uKHIsZSl7cmV0dXJuIHQucmVkdWNlKChmdW5jdGlvbih0LGUsYSl7cmV0dXJuIHQrZSpyW2FdfSksMCl9KSksbj1NYXRoLm1heC5hcHBseShNYXRoLGEpO3JldHVybiBuP2EubWFwKChmdW5jdGlvbihyKXtyZXR1cm4gci9ufSkpOmF9LHNwZWN0cmFsRmx1eDpmdW5jdGlvbihyKXt2YXIgdD1yLnNpZ25hbCxlPXIucHJldmlvdXNTaWduYWwsYT1yLmJ1ZmZlclNpemU7aWYoXCJvYmplY3RcIiE9dHlwZW9mIHR8fFwib2JqZWN0XCIhPXR5cGVvZiBlKXRocm93IG5ldyBUeXBlRXJyb3I7Zm9yKHZhciBuPTAsbz0tYS8yO288dC5sZW5ndGgvMi0xO28rKyl4PU1hdGguYWJzKHRbb10pLU1hdGguYWJzKGVbb10pLG4rPSh4K01hdGguYWJzKHgpKS8yO3JldHVybiBufSxzcGVjdHJhbENyZXN0OmZ1bmN0aW9uKHIpe3ZhciB0PXIuYW1wU3BlY3RydW07aWYoXCJvYmplY3RcIiE9dHlwZW9mIHQpdGhyb3cgbmV3IFR5cGVFcnJvcjt2YXIgZT0wLGE9LTEvMDtyZXR1cm4gdC5mb3JFYWNoKChmdW5jdGlvbihyKXtlKz1NYXRoLnBvdyhyLDIpLGE9cj5hP3I6YX0pKSxlLz10Lmxlbmd0aCxlPU1hdGguc3FydChlKSxhL2V9LG1lbEJhbmRzOnB9KTtmdW5jdGlvbiBTKHIpe2lmKEFycmF5LmlzQXJyYXkocikpe2Zvcih2YXIgdD0wLGU9QXJyYXkoci5sZW5ndGgpO3Q8ci5sZW5ndGg7dCsrKWVbdF09clt0XTtyZXR1cm4gZX1yZXR1cm4gQXJyYXkuZnJvbShyKX12YXIgXz17fSxiPXt9LE09e2JpdFJldmVyc2VBcnJheTpmdW5jdGlvbihyKXtpZih2b2lkIDA9PT1fW3JdKXtmb3IodmFyIHQ9KHItMSkudG9TdHJpbmcoMikubGVuZ3RoLGU9XCIwXCIucmVwZWF0KHQpLGE9e30sbj0wO248cjtuKyspe3ZhciBvPW4udG9TdHJpbmcoMik7bz1lLnN1YnN0cihvLmxlbmd0aCkrbyxvPVtdLmNvbmNhdChTKG8pKS5yZXZlcnNlKCkuam9pbihcIlwiKSxhW25dPXBhcnNlSW50KG8sMil9X1tyXT1hfXJldHVybiBfW3JdfSxtdWx0aXBseTpmdW5jdGlvbihyLHQpe3JldHVybntyZWFsOnIucmVhbCp0LnJlYWwtci5pbWFnKnQuaW1hZyxpbWFnOnIucmVhbCp0LmltYWcrci5pbWFnKnQucmVhbH19LGFkZDpmdW5jdGlvbihyLHQpe3JldHVybntyZWFsOnIucmVhbCt0LnJlYWwsaW1hZzpyLmltYWcrdC5pbWFnfX0sc3VidHJhY3Q6ZnVuY3Rpb24ocix0KXtyZXR1cm57cmVhbDpyLnJlYWwtdC5yZWFsLGltYWc6ci5pbWFnLXQuaW1hZ319LGV1bGVyOmZ1bmN0aW9uKHIsdCl7dmFyIGU9LTIqTWF0aC5QSSpyL3Q7cmV0dXJue3JlYWw6TWF0aC5jb3MoZSksaW1hZzpNYXRoLnNpbihlKX19LGNvbmo6ZnVuY3Rpb24ocil7cmV0dXJuIHIuaW1hZyo9LTEscn0sY29uc3RydWN0Q29tcGxleEFycmF5OmZ1bmN0aW9uKHIpe3ZhciB0PXt9O3QucmVhbD12b2lkIDA9PT1yLnJlYWw/ci5zbGljZSgpOnIucmVhbC5zbGljZSgpO3ZhciBlPXQucmVhbC5sZW5ndGg7cmV0dXJuIHZvaWQgMD09PWJbZV0mJihiW2VdPUFycmF5LmFwcGx5KG51bGwsQXJyYXkoZSkpLm1hcChOdW1iZXIucHJvdG90eXBlLnZhbHVlT2YsMCkpLHQuaW1hZz1iW2VdLnNsaWNlKCksdH19LEY9ZnVuY3Rpb24ocil7dmFyIHQ9e307dm9pZCAwPT09ci5yZWFsfHx2b2lkIDA9PT1yLmltYWc/dD1NLmNvbnN0cnVjdENvbXBsZXhBcnJheShyKToodC5yZWFsPXIucmVhbC5zbGljZSgpLHQuaW1hZz1yLmltYWcuc2xpY2UoKSk7dmFyIGU9dC5yZWFsLmxlbmd0aCxhPU1hdGgubG9nMihlKTtpZihNYXRoLnJvdW5kKGEpIT1hKXRocm93IG5ldyBFcnJvcihcIklucHV0IHNpemUgbXVzdCBiZSBhIHBvd2VyIG9mIDIuXCIpO2lmKHQucmVhbC5sZW5ndGghPXQuaW1hZy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiUmVhbCBhbmQgaW1hZ2luYXJ5IGNvbXBvbmVudHMgbXVzdCBoYXZlIHRoZSBzYW1lIGxlbmd0aC5cIik7Zm9yKHZhciBuPU0uYml0UmV2ZXJzZUFycmF5KGUpLG89e3JlYWw6W10saW1hZzpbXX0saT0wO2k8ZTtpKyspby5yZWFsW25baV1dPXQucmVhbFtpXSxvLmltYWdbbltpXV09dC5pbWFnW2ldO2Zvcih2YXIgdT0wO3U8ZTt1KyspdC5yZWFsW3VdPW8ucmVhbFt1XSx0LmltYWdbdV09by5pbWFnW3VdO2Zvcih2YXIgZj0xO2Y8PWE7ZisrKWZvcih2YXIgYz1NYXRoLnBvdygyLGYpLGw9MDtsPGMvMjtsKyspZm9yKHZhciBzPU0uZXVsZXIobCxjKSxtPTA7bTxlL2M7bSsrKXt2YXIgcD1jKm0rbCxoPWMqbStsK2MvMixnPXtyZWFsOnQucmVhbFtwXSxpbWFnOnQuaW1hZ1twXX0sdz17cmVhbDp0LnJlYWxbaF0saW1hZzp0LmltYWdbaF19LHY9TS5tdWx0aXBseShzLHcpLGQ9TS5zdWJ0cmFjdChnLHYpO3QucmVhbFtoXT1kLnJlYWwsdC5pbWFnW2hdPWQuaW1hZzt2YXIgeT1NLmFkZCh2LGcpO3QucmVhbFtwXT15LnJlYWwsdC5pbWFnW3BdPXkuaW1hZ31yZXR1cm4gdH0sQT1GLEU9ZnVuY3Rpb24oKXtmdW5jdGlvbiByKHIsdCl7dmFyIGU9dGhpcztpZih0aGlzLl9tPXQsIXIuYXVkaW9Db250ZXh0KXRocm93IHRoaXMuX20uZXJyb3JzLm5vQUM7aWYoci5idWZmZXJTaXplJiYhYShyLmJ1ZmZlclNpemUpKXRocm93IHRoaXMuX20uX2Vycm9ycy5ub3RQb3cyO2lmKCFyLnNvdXJjZSl0aHJvdyB0aGlzLl9tLl9lcnJvcnMubm9Tb3VyY2U7dGhpcy5fbS5hdWRpb0NvbnRleHQ9ci5hdWRpb0NvbnRleHQsdGhpcy5fbS5idWZmZXJTaXplPXIuYnVmZmVyU2l6ZXx8dGhpcy5fbS5idWZmZXJTaXplfHwyNTYsdGhpcy5fbS5ob3BTaXplPXIuaG9wU2l6ZXx8dGhpcy5fbS5ob3BTaXplfHx0aGlzLl9tLmJ1ZmZlclNpemUsdGhpcy5fbS5zYW1wbGVSYXRlPXIuc2FtcGxlUmF0ZXx8dGhpcy5fbS5hdWRpb0NvbnRleHQuc2FtcGxlUmF0ZXx8NDQxMDAsdGhpcy5fbS5jYWxsYmFjaz1yLmNhbGxiYWNrLHRoaXMuX20ud2luZG93aW5nRnVuY3Rpb249ci53aW5kb3dpbmdGdW5jdGlvbnx8XCJoYW5uaW5nXCIsdGhpcy5fbS5mZWF0dXJlRXh0cmFjdG9ycz15LHRoaXMuX20uRVhUUkFDVElPTl9TVEFSVEVEPXIuc3RhcnRJbW1lZGlhdGVseXx8ITEsdGhpcy5fbS5jaGFubmVsPVwibnVtYmVyXCI9PXR5cGVvZiByLmNoYW5uZWw/ci5jaGFubmVsOjAsdGhpcy5fbS5pbnB1dHM9ci5pbnB1dHN8fDEsdGhpcy5fbS5vdXRwdXRzPXIub3V0cHV0c3x8MSx0aGlzLl9tLm51bWJlck9mTUZDQ0NvZWZmaWNpZW50cz1yLm51bWJlck9mTUZDQ0NvZWZmaWNpZW50c3x8dGhpcy5fbS5udW1iZXJPZk1GQ0NDb2VmZmljaWVudHN8fDEzLHRoaXMuX20ubnVtYmVyT2ZCYXJrQmFuZHM9ci5udW1iZXJPZkJhcmtCYW5kc3x8dGhpcy5fbS5udW1iZXJPZkJhcmtCYW5kc3x8MjQsdGhpcy5fbS5zcG49dGhpcy5fbS5hdWRpb0NvbnRleHQuY3JlYXRlU2NyaXB0UHJvY2Vzc29yKHRoaXMuX20uYnVmZmVyU2l6ZSx0aGlzLl9tLmlucHV0cyx0aGlzLl9tLm91dHB1dHMpLHRoaXMuX20uc3BuLmNvbm5lY3QodGhpcy5fbS5hdWRpb0NvbnRleHQuZGVzdGluYXRpb24pLHRoaXMuX20uX2ZlYXR1cmVzVG9FeHRyYWN0PXIuZmVhdHVyZUV4dHJhY3RvcnN8fFtdLHRoaXMuX20uYmFya1NjYWxlPW8odGhpcy5fbS5idWZmZXJTaXplLHRoaXMuX20uc2FtcGxlUmF0ZSx0aGlzLl9tLmJ1ZmZlclNpemUpLHRoaXMuX20ubWVsRmlsdGVyQmFuaz1mKE1hdGgubWF4KHRoaXMuX20ubWVsQmFuZHMsdGhpcy5fbS5udW1iZXJPZk1GQ0NDb2VmZmljaWVudHMpLHRoaXMuX20uc2FtcGxlUmF0ZSx0aGlzLl9tLmJ1ZmZlclNpemUpLHRoaXMuX20uaW5wdXREYXRhPW51bGwsdGhpcy5fbS5wcmV2aW91c0lucHV0RGF0YT1udWxsLHRoaXMuX20uZnJhbWU9bnVsbCx0aGlzLl9tLnByZXZpb3VzRnJhbWU9bnVsbCx0aGlzLnNldFNvdXJjZShyLnNvdXJjZSksdGhpcy5fbS5zcG4ub25hdWRpb3Byb2Nlc3M9ZnVuY3Rpb24ocil7dmFyIHQ7bnVsbCE9PWUuX20uaW5wdXREYXRhJiYoZS5fbS5wcmV2aW91c0lucHV0RGF0YT1lLl9tLmlucHV0RGF0YSksZS5fbS5pbnB1dERhdGE9ci5pbnB1dEJ1ZmZlci5nZXRDaGFubmVsRGF0YShlLl9tLmNoYW5uZWwpLGUuX20ucHJldmlvdXNJbnB1dERhdGE/KCh0PW5ldyBGbG9hdDMyQXJyYXkoZS5fbS5wcmV2aW91c0lucHV0RGF0YS5sZW5ndGgrZS5fbS5pbnB1dERhdGEubGVuZ3RoLWUuX20uaG9wU2l6ZSkpLnNldChlLl9tLnByZXZpb3VzSW5wdXREYXRhLnNsaWNlKGUuX20uaG9wU2l6ZSkpLHQuc2V0KGUuX20uaW5wdXREYXRhLGUuX20ucHJldmlvdXNJbnB1dERhdGEubGVuZ3RoLWUuX20uaG9wU2l6ZSkpOnQ9ZS5fbS5pbnB1dERhdGEsZnVuY3Rpb24ocix0LGUpe2lmKHIubGVuZ3RoPHQpdGhyb3cgbmV3IEVycm9yKFwiQnVmZmVyIGlzIHRvbyBzaG9ydCBmb3IgZnJhbWUgbGVuZ3RoXCIpO2lmKGU8MSl0aHJvdyBuZXcgRXJyb3IoXCJIb3AgbGVuZ3RoIGNhbm5vdCBiZSBsZXNzIHRoYXQgMVwiKTtpZih0PDEpdGhyb3cgbmV3IEVycm9yKFwiRnJhbWUgbGVuZ3RoIGNhbm5vdCBiZSBsZXNzIHRoYXQgMVwiKTt2YXIgYT0xK01hdGguZmxvb3IoKHIubGVuZ3RoLXQpL2UpO3JldHVybiBuZXcgQXJyYXkoYSkuZmlsbCgwKS5tYXAoKGZ1bmN0aW9uKGEsbil7cmV0dXJuIHIuc2xpY2UobiplLG4qZSt0KX0pKX0odCxlLl9tLmJ1ZmZlclNpemUsZS5fbS5ob3BTaXplKS5mb3JFYWNoKChmdW5jdGlvbihyKXtlLl9tLmZyYW1lPXI7dmFyIHQ9ZS5fbS5leHRyYWN0KGUuX20uX2ZlYXR1cmVzVG9FeHRyYWN0LGUuX20uZnJhbWUsZS5fbS5wcmV2aW91c0ZyYW1lKTtcImZ1bmN0aW9uXCI9PXR5cGVvZiBlLl9tLmNhbGxiYWNrJiZlLl9tLkVYVFJBQ1RJT05fU1RBUlRFRCYmZS5fbS5jYWxsYmFjayh0KSxlLl9tLnByZXZpb3VzRnJhbWU9ZS5fbS5mcmFtZX0pKX19cmV0dXJuIHIucHJvdG90eXBlLnN0YXJ0PWZ1bmN0aW9uKHIpe3RoaXMuX20uX2ZlYXR1cmVzVG9FeHRyYWN0PXJ8fHRoaXMuX20uX2ZlYXR1cmVzVG9FeHRyYWN0LHRoaXMuX20uRVhUUkFDVElPTl9TVEFSVEVEPSEwfSxyLnByb3RvdHlwZS5zdG9wPWZ1bmN0aW9uKCl7dGhpcy5fbS5FWFRSQUNUSU9OX1NUQVJURUQ9ITF9LHIucHJvdG90eXBlLnNldFNvdXJjZT1mdW5jdGlvbihyKXt0aGlzLl9tLnNvdXJjZSYmdGhpcy5fbS5zb3VyY2UuZGlzY29ubmVjdCh0aGlzLl9tLnNwbiksdGhpcy5fbS5zb3VyY2U9cix0aGlzLl9tLnNvdXJjZS5jb25uZWN0KHRoaXMuX20uc3BuKX0sci5wcm90b3R5cGUuc2V0Q2hhbm5lbD1mdW5jdGlvbihyKXtyPD10aGlzLl9tLmlucHV0cz90aGlzLl9tLmNoYW5uZWw9cjpjb25zb2xlLmVycm9yKFwiQ2hhbm5lbCBcIi5jb25jYXQocixcIiBkb2VzIG5vdCBleGlzdC4gTWFrZSBzdXJlIHlvdSd2ZSBwcm92aWRlZCBhIHZhbHVlIGZvciAnaW5wdXRzJyB0aGF0IGlzIGdyZWF0ZXIgdGhhbiBcIikuY29uY2F0KHIsXCIgd2hlbiBpbnN0YW50aWF0aW5nIHRoZSBNZXlkYUFuYWx5emVyXCIpKX0sci5wcm90b3R5cGUuZ2V0PWZ1bmN0aW9uKHIpe3JldHVybiB0aGlzLl9tLmlucHV0RGF0YT90aGlzLl9tLmV4dHJhY3Qocnx8dGhpcy5fbS5fZmVhdHVyZXNUb0V4dHJhY3QsdGhpcy5fbS5pbnB1dERhdGEsdGhpcy5fbS5wcmV2aW91c0lucHV0RGF0YSk6bnVsbH0scn0oKSxDPXthdWRpb0NvbnRleHQ6bnVsbCxzcG46bnVsbCxidWZmZXJTaXplOjUxMixzYW1wbGVSYXRlOjQ0MTAwLG1lbEJhbmRzOjI2LGNocm9tYUJhbmRzOjEyLGNhbGxiYWNrOm51bGwsd2luZG93aW5nRnVuY3Rpb246XCJoYW5uaW5nXCIsZmVhdHVyZUV4dHJhY3RvcnM6eSxFWFRSQUNUSU9OX1NUQVJURUQ6ITEsbnVtYmVyT2ZNRkNDQ29lZmZpY2llbnRzOjEzLG51bWJlck9mQmFya0JhbmRzOjI0LF9mZWF0dXJlc1RvRXh0cmFjdDpbXSx3aW5kb3dpbmc6bixfZXJyb3JzOntub3RQb3cyOm5ldyBFcnJvcihcIk1leWRhOiBCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgcG93ZXIgb2YgMiwgZS5nLiA2NCBvciA1MTJcIiksZmVhdHVyZVVuZGVmOm5ldyBFcnJvcihcIk1leWRhOiBObyBmZWF0dXJlcyBkZWZpbmVkLlwiKSxpbnZhbGlkRmVhdHVyZUZtdDpuZXcgRXJyb3IoXCJNZXlkYTogSW52YWxpZCBmZWF0dXJlIGZvcm1hdFwiKSxpbnZhbGlkSW5wdXQ6bmV3IEVycm9yKFwiTWV5ZGE6IEludmFsaWQgaW5wdXQuXCIpLG5vQUM6bmV3IEVycm9yKFwiTWV5ZGE6IE5vIEF1ZGlvQ29udGV4dCBzcGVjaWZpZWQuXCIpLG5vU291cmNlOm5ldyBFcnJvcihcIk1leWRhOiBObyBzb3VyY2Ugbm9kZSBzcGVjaWZpZWQuXCIpfSxjcmVhdGVNZXlkYUFuYWx5emVyOmZ1bmN0aW9uKHIpe3JldHVybiBuZXcgRShyLE9iamVjdC5hc3NpZ24oe30sQykpfSxsaXN0QXZhaWxhYmxlRmVhdHVyZUV4dHJhY3RvcnM6ZnVuY3Rpb24oKXtyZXR1cm4gT2JqZWN0LmtleXModGhpcy5mZWF0dXJlRXh0cmFjdG9ycyl9LGV4dHJhY3Q6ZnVuY3Rpb24ocix0LGUpe3ZhciBuPXRoaXM7aWYoIXQpdGhyb3cgdGhpcy5fZXJyb3JzLmludmFsaWRJbnB1dDtpZihcIm9iamVjdFwiIT10eXBlb2YgdCl0aHJvdyB0aGlzLl9lcnJvcnMuaW52YWxpZElucHV0O2lmKCFyKXRocm93IHRoaXMuX2Vycm9ycy5mZWF0dXJlVW5kZWY7aWYoIWEodC5sZW5ndGgpKXRocm93IHRoaXMuX2Vycm9ycy5ub3RQb3cyO3ZvaWQgMCE9PXRoaXMuYmFya1NjYWxlJiZ0aGlzLmJhcmtTY2FsZS5sZW5ndGg9PXRoaXMuYnVmZmVyU2l6ZXx8KHRoaXMuYmFya1NjYWxlPW8odGhpcy5idWZmZXJTaXplLHRoaXMuc2FtcGxlUmF0ZSx0aGlzLmJ1ZmZlclNpemUpKSx2b2lkIDAhPT10aGlzLm1lbEZpbHRlckJhbmsmJnRoaXMuYmFya1NjYWxlLmxlbmd0aD09dGhpcy5idWZmZXJTaXplJiZ0aGlzLm1lbEZpbHRlckJhbmsubGVuZ3RoPT10aGlzLm1lbEJhbmRzfHwodGhpcy5tZWxGaWx0ZXJCYW5rPWYoTWF0aC5tYXgodGhpcy5tZWxCYW5kcyx0aGlzLm51bWJlck9mTUZDQ0NvZWZmaWNpZW50cyksdGhpcy5zYW1wbGVSYXRlLHRoaXMuYnVmZmVyU2l6ZSkpLHZvaWQgMCE9PXRoaXMuY2hyb21hRmlsdGVyQmFuayYmdGhpcy5jaHJvbWFGaWx0ZXJCYW5rLmxlbmd0aD09dGhpcy5jaHJvbWFCYW5kc3x8KHRoaXMuY2hyb21hRmlsdGVyQmFuaz1jKHRoaXMuY2hyb21hQmFuZHMsdGhpcy5zYW1wbGVSYXRlLHRoaXMuYnVmZmVyU2l6ZSkpLFwiYnVmZmVyXCJpbiB0JiZ2b2lkIDA9PT10LmJ1ZmZlcj90aGlzLnNpZ25hbD1pKHQpOnRoaXMuc2lnbmFsPXQ7dmFyIHU9ayh0LHRoaXMud2luZG93aW5nRnVuY3Rpb24sdGhpcy5idWZmZXJTaXplKTtpZih0aGlzLnNpZ25hbD11LndpbmRvd2VkU2lnbmFsLHRoaXMuY29tcGxleFNwZWN0cnVtPXUuY29tcGxleFNwZWN0cnVtLHRoaXMuYW1wU3BlY3RydW09dS5hbXBTcGVjdHJ1bSxlKXt2YXIgbD1rKGUsdGhpcy53aW5kb3dpbmdGdW5jdGlvbix0aGlzLmJ1ZmZlclNpemUpO3RoaXMucHJldmlvdXNTaWduYWw9bC53aW5kb3dlZFNpZ25hbCx0aGlzLnByZXZpb3VzQ29tcGxleFNwZWN0cnVtPWwuY29tcGxleFNwZWN0cnVtLHRoaXMucHJldmlvdXNBbXBTcGVjdHJ1bT1sLmFtcFNwZWN0cnVtfXZhciBzPWZ1bmN0aW9uKHIpe3JldHVybiBuLmZlYXR1cmVFeHRyYWN0b3JzW3JdKHthbXBTcGVjdHJ1bTpuLmFtcFNwZWN0cnVtLGNocm9tYUZpbHRlckJhbms6bi5jaHJvbWFGaWx0ZXJCYW5rLGNvbXBsZXhTcGVjdHJ1bTpuLmNvbXBsZXhTcGVjdHJ1bSxzaWduYWw6bi5zaWduYWwsYnVmZmVyU2l6ZTpuLmJ1ZmZlclNpemUsc2FtcGxlUmF0ZTpuLnNhbXBsZVJhdGUsYmFya1NjYWxlOm4uYmFya1NjYWxlLG1lbEZpbHRlckJhbms6bi5tZWxGaWx0ZXJCYW5rLHByZXZpb3VzU2lnbmFsOm4ucHJldmlvdXNTaWduYWwscHJldmlvdXNBbXBTcGVjdHJ1bTpuLnByZXZpb3VzQW1wU3BlY3RydW0scHJldmlvdXNDb21wbGV4U3BlY3RydW06bi5wcmV2aW91c0NvbXBsZXhTcGVjdHJ1bSxudW1iZXJPZk1GQ0NDb2VmZmljaWVudHM6bi5udW1iZXJPZk1GQ0NDb2VmZmljaWVudHMsbnVtYmVyT2ZCYXJrQmFuZHM6bi5udW1iZXJPZkJhcmtCYW5kc30pfTtpZihcIm9iamVjdFwiPT10eXBlb2YgcilyZXR1cm4gci5yZWR1Y2UoKGZ1bmN0aW9uKHIsdCl7dmFyIGU7cmV0dXJuIE9iamVjdC5hc3NpZ24oe30sciwoKGU9e30pW3RdPXModCksZSkpfSkse30pO2lmKFwic3RyaW5nXCI9PXR5cGVvZiByKXJldHVybiBzKHIpO3Rocm93IHRoaXMuX2Vycm9ycy5pbnZhbGlkRmVhdHVyZUZtdH19LGs9ZnVuY3Rpb24ocix0LGUpe3ZhciBhPXt9O3ZvaWQgMD09PXIuYnVmZmVyP2Euc2lnbmFsPWkocik6YS5zaWduYWw9cixhLndpbmRvd2VkU2lnbmFsPW4oYS5zaWduYWwsdCksYS5jb21wbGV4U3BlY3RydW09QShhLndpbmRvd2VkU2lnbmFsKSxhLmFtcFNwZWN0cnVtPW5ldyBGbG9hdDMyQXJyYXkoZS8yKTtmb3IodmFyIG89MDtvPGUvMjtvKyspYS5hbXBTcGVjdHJ1bVtvXT1NYXRoLnNxcnQoTWF0aC5wb3coYS5jb21wbGV4U3BlY3RydW0ucmVhbFtvXSwyKStNYXRoLnBvdyhhLmNvbXBsZXhTcGVjdHJ1bS5pbWFnW29dLDIpKTtyZXR1cm4gYX07cmV0dXJuXCJ1bmRlZmluZWRcIiE9dHlwZW9mIHdpbmRvdyYmKHdpbmRvdy5NZXlkYT1DKSxDfSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWV5ZGEubWluLmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCJcblxudmFyIHBvb2wgPSByZXF1aXJlKFwidHlwZWRhcnJheS1wb29sXCIpXG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlU3VyZmFjZUV4dHJhY3RvclxuXG4vL0hlbHBlciBtYWNyb3NcbmZ1bmN0aW9uIGFycmF5KGkpIHtcbiAgcmV0dXJuIFwiYVwiICsgaVxufVxuZnVuY3Rpb24gZGF0YShpKSB7XG4gIHJldHVybiBcImRcIiArIGlcbn1cbmZ1bmN0aW9uIGN1YmUoaSxiaXRtYXNrKSB7XG4gIHJldHVybiBcImNcIiArIGkgKyBcIl9cIiArIGJpdG1hc2tcbn1cbmZ1bmN0aW9uIHNoYXBlKGkpIHtcbiAgcmV0dXJuIFwic1wiICsgaVxufVxuZnVuY3Rpb24gc3RyaWRlKGksaikge1xuICByZXR1cm4gXCJ0XCIgKyBpICsgXCJfXCIgKyBqXG59XG5mdW5jdGlvbiBvZmZzZXQoaSkge1xuICByZXR1cm4gXCJvXCIgKyBpXG59XG5mdW5jdGlvbiBzY2FsYXIoaSkge1xuICByZXR1cm4gXCJ4XCIgKyBpXG59XG5mdW5jdGlvbiBwb2ludGVyKGkpIHtcbiAgcmV0dXJuIFwicFwiICsgaVxufVxuZnVuY3Rpb24gZGVsdGEoaSxiaXRtYXNrKSB7XG4gIHJldHVybiBcImRcIiArIGkgKyBcIl9cIiArIGJpdG1hc2tcbn1cbmZ1bmN0aW9uIGluZGV4KGkpIHtcbiAgcmV0dXJuIFwiaVwiICsgaVxufVxuZnVuY3Rpb24gc3RlcChpLGopIHtcbiAgcmV0dXJuIFwidVwiICsgaSArIFwiX1wiICsgalxufVxuZnVuY3Rpb24gcGN1YmUoYml0bWFzaykge1xuICByZXR1cm4gXCJiXCIgKyBiaXRtYXNrXG59XG5mdW5jdGlvbiBxY3ViZShiaXRtYXNrKSB7XG4gIHJldHVybiBcInlcIiArIGJpdG1hc2tcbn1cbmZ1bmN0aW9uIHBkZWx0YShiaXRtYXNrKSB7XG4gIHJldHVybiBcImVcIiArIGJpdG1hc2tcbn1cbmZ1bmN0aW9uIHZlcnQoaSkge1xuICByZXR1cm4gXCJ2XCIgKyBpXG59XG52YXIgVkVSVEVYX0lEUyA9IFwiVlwiXG52YXIgUEhBU0VTID0gXCJQXCJcbnZhciBWRVJURVhfQ09VTlQgPSBcIk5cIlxudmFyIFBPT0xfU0laRSA9IFwiUVwiXG52YXIgUE9JTlRFUiA9IFwiWFwiXG52YXIgVEVNUE9SQVJZID0gXCJUXCJcblxuZnVuY3Rpb24gcGVybUJpdG1hc2soZGltZW5zaW9uLCBtYXNrLCBvcmRlcikge1xuICB2YXIgciA9IDBcbiAgZm9yKHZhciBpPTA7IGk8ZGltZW5zaW9uOyArK2kpIHtcbiAgICBpZihtYXNrICYgKDE8PGkpKSB7XG4gICAgICByIHw9ICgxPDxvcmRlcltpXSlcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJcbn1cblxuLy9HZW5lcmF0ZXMgdGhlIHN1cmZhY2UgcHJvY2VkdXJlXG5mdW5jdGlvbiBjb21waWxlU3VyZmFjZVByb2NlZHVyZSh2ZXJ0ZXhGdW5jLCBmYWNlRnVuYywgcGhhc2VGdW5jLCBzY2FsYXJBcmdzLCBvcmRlciwgdHlwZXNpZykge1xuICB2YXIgYXJyYXlBcmdzID0gdHlwZXNpZy5sZW5ndGhcbiAgdmFyIGRpbWVuc2lvbiA9IG9yZGVyLmxlbmd0aFxuXG4gIGlmKGRpbWVuc2lvbiA8IDIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJuZGFycmF5LWV4dHJhY3QtY29udG91cjogRGltZW5zaW9uIG11c3QgYmUgYXQgbGVhc3QgMlwiKVxuICB9XG5cbiAgdmFyIGZ1bmNOYW1lID0gXCJleHRyYWN0Q29udG91clwiICsgb3JkZXIuam9pbihcIl9cIilcbiAgdmFyIGNvZGUgPSBbXVxuICB2YXIgdmFycyA9IFtdXG4gIHZhciBhcmdzID0gW11cblxuICAvL0Fzc2VtYmxlIGFyZ3VtZW50c1xuICBmb3IodmFyIGk9MDsgaTxhcnJheUFyZ3M7ICsraSkge1xuICAgIGFyZ3MucHVzaChhcnJheShpKSkgIFxuICB9XG4gIGZvcih2YXIgaT0wOyBpPHNjYWxhckFyZ3M7ICsraSkge1xuICAgIGFyZ3MucHVzaChzY2FsYXIoaSkpXG4gIH1cblxuICAvL1NoYXBlXG4gIGZvcih2YXIgaT0wOyBpPGRpbWVuc2lvbjsgKytpKSB7XG4gICAgdmFycy5wdXNoKHNoYXBlKGkpICsgXCI9XCIgKyBhcnJheSgwKSArIFwiLnNoYXBlW1wiICsgaSArIFwiXXwwXCIpXG4gIH1cbiAgLy9EYXRhLCBzdHJpZGUsIG9mZnNldCBwb2ludGVyc1xuICBmb3IodmFyIGk9MDsgaTxhcnJheUFyZ3M7ICsraSkge1xuICAgIHZhcnMucHVzaChkYXRhKGkpICsgXCI9XCIgKyBhcnJheShpKSArIFwiLmRhdGFcIixcbiAgICAgICAgICAgICAgb2Zmc2V0KGkpICsgXCI9XCIgKyBhcnJheShpKSArIFwiLm9mZnNldHwwXCIpXG4gICAgZm9yKHZhciBqPTA7IGo8ZGltZW5zaW9uOyArK2opIHtcbiAgICAgIHZhcnMucHVzaChzdHJpZGUoaSxqKSArIFwiPVwiICsgYXJyYXkoaSkgKyBcIi5zdHJpZGVbXCIgKyBqICsgXCJdfDBcIilcbiAgICB9XG4gIH1cbiAgLy9Qb2ludGVyLCBkZWx0YSBhbmQgY3ViZSB2YXJpYWJsZXNcbiAgZm9yKHZhciBpPTA7IGk8YXJyYXlBcmdzOyArK2kpIHtcbiAgICB2YXJzLnB1c2gocG9pbnRlcihpKSArIFwiPVwiICsgb2Zmc2V0KGkpKVxuICAgIHZhcnMucHVzaChjdWJlKGksMCkpXG4gICAgZm9yKHZhciBqPTE7IGo8KDE8PGRpbWVuc2lvbik7ICsraikge1xuICAgICAgdmFyIHB0clN0ciA9IFtdXG4gICAgICBmb3IodmFyIGs9MDsgazxkaW1lbnNpb247ICsraykge1xuICAgICAgICBpZihqICYgKDE8PGspKSB7XG4gICAgICAgICAgcHRyU3RyLnB1c2goXCItXCIgKyBzdHJpZGUoaSxrKSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFycy5wdXNoKGRlbHRhKGksaikgKyBcIj0oXCIgKyBwdHJTdHIuam9pbihcIlwiKSArIFwiKXwwXCIpXG4gICAgICB2YXJzLnB1c2goY3ViZShpLGopICsgXCI9MFwiKVxuICAgIH1cbiAgfVxuICAvL0NyZWF0ZSBzdGVwIHZhcmlhYmxlc1xuICBmb3IodmFyIGk9MDsgaTxhcnJheUFyZ3M7ICsraSkge1xuICAgIGZvcih2YXIgaj0wOyBqPGRpbWVuc2lvbjsgKytqKSB7XG4gICAgICB2YXIgc3RlcFZhbCA9IFsgc3RyaWRlKGksb3JkZXJbal0pIF1cbiAgICAgIGlmKGogPiAwKSB7XG4gICAgICAgIHN0ZXBWYWwucHVzaChzdHJpZGUoaSwgb3JkZXJbai0xXSkgKyBcIipcIiArIHNoYXBlKG9yZGVyW2otMV0pIClcbiAgICAgIH1cbiAgICAgIHZhcnMucHVzaChzdGVwKGksb3JkZXJbal0pICsgXCI9KFwiICsgc3RlcFZhbC5qb2luKFwiLVwiKSArIFwiKXwwXCIpXG4gICAgfVxuICB9XG4gIC8vQ3JlYXRlIGluZGV4IHZhcmlhYmxlc1xuICBmb3IodmFyIGk9MDsgaTxkaW1lbnNpb247ICsraSkge1xuICAgIHZhcnMucHVzaChpbmRleChpKSArIFwiPTBcIilcbiAgfVxuICAvL1ZlcnRleCBjb3VudFxuICB2YXJzLnB1c2goVkVSVEVYX0NPVU5UICsgXCI9MFwiKVxuICAvL0NvbXB1dGUgcG9vbCBzaXplLCBpbml0aWFsaXplIHBvb2wgc3RlcFxuICB2YXIgc2l6ZVZhcmlhYmxlID0gW1wiMlwiXVxuICBmb3IodmFyIGk9ZGltZW5zaW9uLTI7IGk+PTA7IC0taSkge1xuICAgIHNpemVWYXJpYWJsZS5wdXNoKHNoYXBlKG9yZGVyW2ldKSlcbiAgfVxuICAvL1ByZXZpb3VzIHBoYXNlcyBhbmQgdmVydGV4X2lkc1xuICB2YXJzLnB1c2goUE9PTF9TSVpFICsgXCI9KFwiICsgc2l6ZVZhcmlhYmxlLmpvaW4oXCIqXCIpICsgXCIpfDBcIixcbiAgICAgICAgICAgIFBIQVNFUyArIFwiPW1hbGxvY1VpbnQzMihcIiArIFBPT0xfU0laRSArIFwiKVwiLFxuICAgICAgICAgICAgVkVSVEVYX0lEUyArIFwiPW1hbGxvY1VpbnQzMihcIiArIFBPT0xfU0laRSArIFwiKVwiLFxuICAgICAgICAgICAgUE9JTlRFUiArIFwiPTBcIilcbiAgLy9DcmVhdGUgY3ViZSB2YXJpYWJsZXMgZm9yIHBoYXNlc1xuICB2YXJzLnB1c2gocGN1YmUoMCkgKyBcIj0wXCIpXG4gIGZvcih2YXIgaj0xOyBqPCgxPDxkaW1lbnNpb24pOyArK2opIHtcbiAgICB2YXIgY3ViZURlbHRhID0gW11cbiAgICB2YXIgY3ViZVN0ZXAgPSBbIF1cbiAgICBmb3IodmFyIGs9MDsgazxkaW1lbnNpb247ICsraykge1xuICAgICAgaWYoaiAmICgxPDxrKSkge1xuICAgICAgICBpZihjdWJlU3RlcC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBjdWJlRGVsdGEucHVzaChcIjFcIilcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjdWJlRGVsdGEudW5zaGlmdChjdWJlU3RlcC5qb2luKFwiKlwiKSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY3ViZVN0ZXAucHVzaChzaGFwZShvcmRlcltrXSkpXG4gICAgfVxuICAgIHZhciBzaWduRmxhZyA9IFwiXCJcbiAgICBpZihjdWJlRGVsdGFbMF0uaW5kZXhPZihzaGFwZShvcmRlcltkaW1lbnNpb24tMl0pKSA8IDApIHtcbiAgICAgIHNpZ25GbGFnID0gXCItXCJcbiAgICB9XG4gICAgdmFyIGpwZXJtID0gcGVybUJpdG1hc2soZGltZW5zaW9uLCBqLCBvcmRlcilcbiAgICB2YXJzLnB1c2gocGRlbHRhKGpwZXJtKSArIFwiPSgtXCIgKyBjdWJlRGVsdGEuam9pbihcIi1cIikgKyBcIil8MFwiLFxuICAgICAgICAgICAgICBxY3ViZShqcGVybSkgKyBcIj0oXCIgKyBzaWduRmxhZyArIGN1YmVEZWx0YS5qb2luKFwiLVwiKSArIFwiKXwwXCIsXG4gICAgICAgICAgICAgIHBjdWJlKGpwZXJtKSArIFwiPTBcIilcbiAgfVxuICB2YXJzLnB1c2godmVydCgwKSArIFwiPTBcIiwgVEVNUE9SQVJZICsgXCI9MFwiKVxuXG4gIGZ1bmN0aW9uIGZvckxvb3BCZWdpbihpLCBzdGFydCkge1xuICAgIGNvZGUucHVzaChcImZvcihcIiwgaW5kZXgob3JkZXJbaV0pLCBcIj1cIiwgc3RhcnQsIFwiO1wiLFxuICAgICAgaW5kZXgob3JkZXJbaV0pLCBcIjxcIiwgc2hhcGUob3JkZXJbaV0pLCBcIjtcIixcbiAgICAgIFwiKytcIiwgaW5kZXgob3JkZXJbaV0pLCBcIil7XCIpXG4gIH1cblxuICBmdW5jdGlvbiBmb3JMb29wRW5kKGkpIHtcbiAgICBmb3IodmFyIGo9MDsgajxhcnJheUFyZ3M7ICsraikge1xuICAgICAgY29kZS5wdXNoKHBvaW50ZXIoaiksIFwiKz1cIiwgc3RlcChqLG9yZGVyW2ldKSwgXCI7XCIpXG4gICAgfVxuICAgIGNvZGUucHVzaChcIn1cIilcbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbGxFbXB0eVNsaWNlKGspIHtcbiAgICBmb3IodmFyIGk9ay0xOyBpPj0wOyAtLWkpIHtcbiAgICAgIGZvckxvb3BCZWdpbihpLCAwKSBcbiAgICB9XG4gICAgdmFyIHBoYXNlRnVuY0FyZ3MgPSBbXVxuICAgIGZvcih2YXIgaT0wOyBpPGFycmF5QXJnczsgKytpKSB7XG4gICAgICBpZih0eXBlc2lnW2ldKSB7XG4gICAgICAgIHBoYXNlRnVuY0FyZ3MucHVzaChkYXRhKGkpICsgXCIuZ2V0KFwiICsgcG9pbnRlcihpKSArIFwiKVwiKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGhhc2VGdW5jQXJncy5wdXNoKGRhdGEoaSkgKyBcIltcIiArIHBvaW50ZXIoaSkgKyBcIl1cIilcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yKHZhciBpPTA7IGk8c2NhbGFyQXJnczsgKytpKSB7XG4gICAgICBwaGFzZUZ1bmNBcmdzLnB1c2goc2NhbGFyKGkpKVxuICAgIH1cbiAgICBjb2RlLnB1c2goUEhBU0VTLCBcIltcIiwgUE9JTlRFUiwgXCIrK109cGhhc2UoXCIsIHBoYXNlRnVuY0FyZ3Muam9pbigpLCBcIik7XCIpXG4gICAgZm9yKHZhciBpPTA7IGk8azsgKytpKSB7XG4gICAgICBmb3JMb29wRW5kKGkpXG4gICAgfVxuICAgIGZvcih2YXIgaj0wOyBqPGFycmF5QXJnczsgKytqKSB7XG4gICAgICBjb2RlLnB1c2gocG9pbnRlcihqKSwgXCIrPVwiLCBzdGVwKGosb3JkZXJba10pLCBcIjtcIilcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwcm9jZXNzR3JpZENlbGwobWFzaykge1xuICAgIC8vUmVhZCBpbiBsb2NhbCBkYXRhXG4gICAgZm9yKHZhciBpPTA7IGk8YXJyYXlBcmdzOyArK2kpIHtcbiAgICAgIGlmKHR5cGVzaWdbaV0pIHtcbiAgICAgICAgY29kZS5wdXNoKGN1YmUoaSwwKSwgXCI9XCIsIGRhdGEoaSksIFwiLmdldChcIiwgcG9pbnRlcihpKSwgXCIpO1wiKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29kZS5wdXNoKGN1YmUoaSwwKSwgXCI9XCIsIGRhdGEoaSksIFwiW1wiLCBwb2ludGVyKGkpLCBcIl07XCIpXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy9SZWFkIGluIHBoYXNlXG4gICAgdmFyIHBoYXNlRnVuY0FyZ3MgPSBbXVxuICAgIGZvcih2YXIgaT0wOyBpPGFycmF5QXJnczsgKytpKSB7XG4gICAgICBwaGFzZUZ1bmNBcmdzLnB1c2goY3ViZShpLDApKVxuICAgIH1cbiAgICBmb3IodmFyIGk9MDsgaTxzY2FsYXJBcmdzOyArK2kpIHtcbiAgICAgIHBoYXNlRnVuY0FyZ3MucHVzaChzY2FsYXIoaSkpXG4gICAgfVxuICAgIFxuICAgIGNvZGUucHVzaChwY3ViZSgwKSwgXCI9XCIsIFBIQVNFUywgXCJbXCIsIFBPSU5URVIsIFwiXT1waGFzZShcIiwgcGhhc2VGdW5jQXJncy5qb2luKCksIFwiKTtcIilcbiAgICBcbiAgICAvL1JlYWQgaW4gb3RoZXIgY3ViZSBkYXRhXG4gICAgZm9yKHZhciBqPTE7IGo8KDE8PGRpbWVuc2lvbik7ICsraikge1xuICAgICAgY29kZS5wdXNoKHBjdWJlKGopLCBcIj1cIiwgUEhBU0VTLCBcIltcIiwgUE9JTlRFUiwgXCIrXCIsIHBkZWx0YShqKSwgXCJdO1wiKVxuICAgIH1cblxuICAgIC8vQ2hlY2sgZm9yIGJvdW5kYXJ5IGNyb3NzaW5nXG4gICAgdmFyIHZlcnRleFByZWRpY2F0ZSA9IFtdXG4gICAgZm9yKHZhciBqPTE7IGo8KDE8PGRpbWVuc2lvbik7ICsraikge1xuICAgICAgdmVydGV4UHJlZGljYXRlLnB1c2goXCIoXCIgKyBwY3ViZSgwKSArIFwiIT09XCIgKyBwY3ViZShqKSArIFwiKVwiKVxuICAgIH1cbiAgICBjb2RlLnB1c2goXCJpZihcIiwgdmVydGV4UHJlZGljYXRlLmpvaW4oXCJ8fFwiKSwgXCIpe1wiKVxuXG4gICAgLy9SZWFkIGluIGJvdW5kYXJ5IGRhdGFcbiAgICB2YXIgdmVydGV4QXJncyA9IFtdXG4gICAgZm9yKHZhciBpPTA7IGk8ZGltZW5zaW9uOyArK2kpIHtcbiAgICAgIHZlcnRleEFyZ3MucHVzaChpbmRleChpKSlcbiAgICB9XG4gICAgZm9yKHZhciBpPTA7IGk8YXJyYXlBcmdzOyArK2kpIHtcbiAgICAgIHZlcnRleEFyZ3MucHVzaChjdWJlKGksMCkpXG4gICAgICBmb3IodmFyIGo9MTsgajwoMTw8ZGltZW5zaW9uKTsgKytqKSB7XG4gICAgICAgIGlmKHR5cGVzaWdbaV0pIHtcbiAgICAgICAgICBjb2RlLnB1c2goY3ViZShpLGopLCBcIj1cIiwgZGF0YShpKSwgXCIuZ2V0KFwiLCBwb2ludGVyKGkpLCBcIitcIiwgZGVsdGEoaSxqKSwgXCIpO1wiKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvZGUucHVzaChjdWJlKGksaiksIFwiPVwiLCBkYXRhKGkpLCBcIltcIiwgcG9pbnRlcihpKSwgXCIrXCIsIGRlbHRhKGksaiksIFwiXTtcIilcbiAgICAgICAgfVxuICAgICAgICB2ZXJ0ZXhBcmdzLnB1c2goY3ViZShpLGopKVxuICAgICAgfVxuICAgIH1cbiAgICBmb3IodmFyIGk9MDsgaTwoMTw8ZGltZW5zaW9uKTsgKytpKSB7XG4gICAgICB2ZXJ0ZXhBcmdzLnB1c2gocGN1YmUoaSkpXG4gICAgfVxuICAgIGZvcih2YXIgaT0wOyBpPHNjYWxhckFyZ3M7ICsraSkge1xuICAgICAgdmVydGV4QXJncy5wdXNoKHNjYWxhcihpKSlcbiAgICB9XG5cbiAgICAvL0dlbmVyYXRlIHZlcnRleFxuICAgIGNvZGUucHVzaChcInZlcnRleChcIiwgdmVydGV4QXJncy5qb2luKCksIFwiKTtcIixcbiAgICAgIHZlcnQoMCksIFwiPVwiLCBWRVJURVhfSURTLCBcIltcIiwgUE9JTlRFUiwgXCJdPVwiLCBWRVJURVhfQ09VTlQsIFwiKys7XCIpXG5cbiAgICAvL0NoZWNrIGZvciBmYWNlIGNyb3NzaW5nc1xuICAgIHZhciBiYXNlID0gKDE8PGRpbWVuc2lvbiktMVxuICAgIHZhciBjb3JuZXIgPSBwY3ViZShiYXNlKVxuICAgIGZvcih2YXIgaj0wOyBqPGRpbWVuc2lvbjsgKytqKSB7XG4gICAgICBpZigobWFzayAmIH4oMTw8aikpPT09MCkge1xuICAgICAgICAvL0NoZWNrIGZhY2VcbiAgICAgICAgdmFyIHN1YnNldCA9IGJhc2VeKDE8PGopXG4gICAgICAgIHZhciBlZGdlID0gcGN1YmUoc3Vic2V0KVxuICAgICAgICB2YXIgZmFjZUFyZ3MgPSBbIF1cbiAgICAgICAgZm9yKHZhciBrPXN1YnNldDsgaz4wOyBrPShrLTEpJnN1YnNldCkge1xuICAgICAgICAgIGZhY2VBcmdzLnB1c2goVkVSVEVYX0lEUyArIFwiW1wiICsgUE9JTlRFUiArIFwiK1wiICsgcGRlbHRhKGspICsgXCJdXCIpXG4gICAgICAgIH1cbiAgICAgICAgZmFjZUFyZ3MucHVzaCh2ZXJ0KDApKVxuICAgICAgICBmb3IodmFyIGs9MDsgazxhcnJheUFyZ3M7ICsraykge1xuICAgICAgICAgIGlmKGomMSkge1xuICAgICAgICAgICAgZmFjZUFyZ3MucHVzaChjdWJlKGssYmFzZSksIGN1YmUoayxzdWJzZXQpKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmYWNlQXJncy5wdXNoKGN1YmUoayxzdWJzZXQpLCBjdWJlKGssYmFzZSkpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmKGomMSkge1xuICAgICAgICAgIGZhY2VBcmdzLnB1c2goY29ybmVyLCBlZGdlKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZhY2VBcmdzLnB1c2goZWRnZSwgY29ybmVyKVxuICAgICAgICB9XG4gICAgICAgIGZvcih2YXIgaz0wOyBrPHNjYWxhckFyZ3M7ICsraykge1xuICAgICAgICAgIGZhY2VBcmdzLnB1c2goc2NhbGFyKGspKVxuICAgICAgICB9XG4gICAgICAgIGNvZGUucHVzaChcImlmKFwiLCBjb3JuZXIsIFwiIT09XCIsIGVkZ2UsIFwiKXtcIixcbiAgICAgICAgICBcImZhY2UoXCIsIGZhY2VBcmdzLmpvaW4oKSwgXCIpfVwiKVxuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICAvL0luY3JlbWVudCBwb2ludGVyLCBjbG9zZSBvZmYgaWYgc3RhdGVtZW50XG4gICAgY29kZS5wdXNoKFwifVwiLFxuICAgICAgUE9JTlRFUiwgXCIrPTE7XCIpXG4gIH1cblxuICBmdW5jdGlvbiBmbGlwKCkge1xuICAgIGZvcih2YXIgaj0xOyBqPCgxPDxkaW1lbnNpb24pOyArK2opIHtcbiAgICAgIGNvZGUucHVzaChURU1QT1JBUlksIFwiPVwiLCBwZGVsdGEoaiksIFwiO1wiLFxuICAgICAgICAgICAgICAgIHBkZWx0YShqKSwgXCI9XCIsIHFjdWJlKGopLCBcIjtcIixcbiAgICAgICAgICAgICAgICBxY3ViZShqKSwgXCI9XCIsIFRFTVBPUkFSWSwgXCI7XCIpXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlTG9vcChpLCBtYXNrKSB7XG4gICAgaWYoaSA8IDApIHtcbiAgICAgIHByb2Nlc3NHcmlkQ2VsbChtYXNrKVxuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGZpbGxFbXB0eVNsaWNlKGkpXG4gICAgY29kZS5wdXNoKFwiaWYoXCIsIHNoYXBlKG9yZGVyW2ldKSwgXCI+MCl7XCIsXG4gICAgICBpbmRleChvcmRlcltpXSksIFwiPTE7XCIpXG4gICAgY3JlYXRlTG9vcChpLTEsIG1hc2t8KDE8PG9yZGVyW2ldKSlcblxuICAgIGZvcih2YXIgaj0wOyBqPGFycmF5QXJnczsgKytqKSB7XG4gICAgICBjb2RlLnB1c2gocG9pbnRlcihqKSwgXCIrPVwiLCBzdGVwKGosb3JkZXJbaV0pLCBcIjtcIilcbiAgICB9XG4gICAgaWYoaSA9PT0gZGltZW5zaW9uLTEpIHtcbiAgICAgIGNvZGUucHVzaChQT0lOVEVSLCBcIj0wO1wiKVxuICAgICAgZmxpcCgpXG4gICAgfVxuICAgIGZvckxvb3BCZWdpbihpLCAyKVxuICAgIGNyZWF0ZUxvb3AoaS0xLCBtYXNrKVxuICAgIGlmKGkgPT09IGRpbWVuc2lvbi0xKSB7XG4gICAgICBjb2RlLnB1c2goXCJpZihcIiwgaW5kZXgob3JkZXJbZGltZW5zaW9uLTFdKSwgXCImMSl7XCIsXG4gICAgICAgIFBPSU5URVIsIFwiPTA7fVwiKVxuICAgICAgZmxpcCgpXG4gICAgfVxuICAgIGZvckxvb3BFbmQoaSlcbiAgICBjb2RlLnB1c2goXCJ9XCIpXG4gIH1cblxuICBjcmVhdGVMb29wKGRpbWVuc2lvbi0xLCAwKVxuXG4gIC8vUmVsZWFzZSBzY3JhdGNoIG1lbW9yeVxuICBjb2RlLnB1c2goXCJmcmVlVWludDMyKFwiLCBWRVJURVhfSURTLCBcIik7ZnJlZVVpbnQzMihcIiwgUEhBU0VTLCBcIik7XCIpXG5cbiAgLy9Db21waWxlIGFuZCBsaW5rIHByb2NlZHVyZVxuICB2YXIgcHJvY2VkdXJlQ29kZSA9IFtcbiAgICBcIid1c2Ugc3RyaWN0JztcIixcbiAgICBcImZ1bmN0aW9uIFwiLCBmdW5jTmFtZSwgXCIoXCIsIGFyZ3Muam9pbigpLCBcIil7XCIsXG4gICAgICBcInZhciBcIiwgdmFycy5qb2luKCksIFwiO1wiLFxuICAgICAgY29kZS5qb2luKFwiXCIpLFxuICAgIFwifVwiLFxuICAgIFwicmV0dXJuIFwiLCBmdW5jTmFtZSBdLmpvaW4oXCJcIilcblxuICB2YXIgcHJvYyA9IG5ldyBGdW5jdGlvbihcbiAgICBcInZlcnRleFwiLCBcbiAgICBcImZhY2VcIiwgXG4gICAgXCJwaGFzZVwiLCBcbiAgICBcIm1hbGxvY1VpbnQzMlwiLCBcbiAgICBcImZyZWVVaW50MzJcIixcbiAgICBwcm9jZWR1cmVDb2RlKVxuICByZXR1cm4gcHJvYyhcbiAgICB2ZXJ0ZXhGdW5jLCBcbiAgICBmYWNlRnVuYywgXG4gICAgcGhhc2VGdW5jLCBcbiAgICBwb29sLm1hbGxvY1VpbnQzMiwgXG4gICAgcG9vbC5mcmVlVWludDMyKVxufVxuXG5mdW5jdGlvbiBjcmVhdGVTdXJmYWNlRXh0cmFjdG9yKGFyZ3MpIHtcbiAgZnVuY3Rpb24gZXJyb3IobXNnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwibmRhcnJheS1leHRyYWN0LWNvbnRvdXI6IFwiICsgbXNnKVxuICB9XG4gIGlmKHR5cGVvZiBhcmdzICE9PSBcIm9iamVjdFwiKSB7XG4gICAgZXJyb3IoXCJNdXN0IHNwZWNpZnkgYXJndW1lbnRzXCIpXG4gIH1cbiAgdmFyIG9yZGVyID0gYXJncy5vcmRlclxuICBpZighQXJyYXkuaXNBcnJheShvcmRlcikpIHtcbiAgICBlcnJvcihcIk11c3Qgc3BlY2lmeSBvcmRlclwiKVxuICB9XG4gIHZhciBhcnJheXMgPSBhcmdzLmFycmF5QXJndW1lbnRzfHwxXG4gIGlmKGFycmF5cyA8IDEpIHtcbiAgICBlcnJvcihcIk11c3QgaGF2ZSBhdCBsZWFzdCBvbmUgYXJyYXkgYXJndW1lbnRcIilcbiAgfVxuICB2YXIgc2NhbGFycyA9IGFyZ3Muc2NhbGFyQXJndW1lbnRzfHwwXG4gIGlmKHNjYWxhcnMgPCAwKSB7XG4gICAgZXJyb3IoXCJTY2FsYXIgYXJnIGNvdW50IG11c3QgYmUgPiAwXCIpXG4gIH1cbiAgaWYodHlwZW9mIGFyZ3MudmVydGV4ICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBlcnJvcihcIk11c3Qgc3BlY2lmeSB2ZXJ0ZXggY3JlYXRpb24gZnVuY3Rpb25cIilcbiAgfVxuICBpZih0eXBlb2YgYXJncy5jZWxsICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBlcnJvcihcIk11c3Qgc3BlY2lmeSBjZWxsIGNyZWF0aW9uIGZ1bmN0aW9uXCIpXG4gIH1cbiAgaWYodHlwZW9mIGFyZ3MucGhhc2UgIT09IFwiZnVuY3Rpb25cIikge1xuICAgIGVycm9yKFwiTXVzdCBzcGVjaWZ5IHBoYXNlIGZ1bmN0aW9uXCIpXG4gIH1cbiAgdmFyIGdldHRlcnMgPSBhcmdzLmdldHRlcnMgfHwgW11cbiAgdmFyIHR5cGVzaWcgPSBuZXcgQXJyYXkoYXJyYXlzKVxuICBmb3IodmFyIGk9MDsgaTxhcnJheXM7ICsraSkge1xuICAgIGlmKGdldHRlcnMuaW5kZXhPZihpKSA+PSAwKSB7XG4gICAgICB0eXBlc2lnW2ldID0gdHJ1ZVxuICAgIH0gZWxzZSB7XG4gICAgICB0eXBlc2lnW2ldID0gZmFsc2VcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNvbXBpbGVTdXJmYWNlUHJvY2VkdXJlKFxuICAgIGFyZ3MudmVydGV4LFxuICAgIGFyZ3MuY2VsbCxcbiAgICBhcmdzLnBoYXNlLFxuICAgIHNjYWxhcnMsXG4gICAgb3JkZXIsXG4gICAgdHlwZXNpZylcbn0iLCJ2YXIgaW90YSA9IHJlcXVpcmUoXCJpb3RhLWFycmF5XCIpXG52YXIgaXNCdWZmZXIgPSByZXF1aXJlKFwiaXMtYnVmZmVyXCIpXG5cbnZhciBoYXNUeXBlZEFycmF5cyAgPSAoKHR5cGVvZiBGbG9hdDY0QXJyYXkpICE9PSBcInVuZGVmaW5lZFwiKVxuXG5mdW5jdGlvbiBjb21wYXJlMXN0KGEsIGIpIHtcbiAgcmV0dXJuIGFbMF0gLSBiWzBdXG59XG5cbmZ1bmN0aW9uIG9yZGVyKCkge1xuICB2YXIgc3RyaWRlID0gdGhpcy5zdHJpZGVcbiAgdmFyIHRlcm1zID0gbmV3IEFycmF5KHN0cmlkZS5sZW5ndGgpXG4gIHZhciBpXG4gIGZvcihpPTA7IGk8dGVybXMubGVuZ3RoOyArK2kpIHtcbiAgICB0ZXJtc1tpXSA9IFtNYXRoLmFicyhzdHJpZGVbaV0pLCBpXVxuICB9XG4gIHRlcm1zLnNvcnQoY29tcGFyZTFzdClcbiAgdmFyIHJlc3VsdCA9IG5ldyBBcnJheSh0ZXJtcy5sZW5ndGgpXG4gIGZvcihpPTA7IGk8cmVzdWx0Lmxlbmd0aDsgKytpKSB7XG4gICAgcmVzdWx0W2ldID0gdGVybXNbaV1bMV1cbiAgfVxuICByZXR1cm4gcmVzdWx0XG59XG5cbmZ1bmN0aW9uIGNvbXBpbGVDb25zdHJ1Y3RvcihkdHlwZSwgZGltZW5zaW9uKSB7XG4gIHZhciBjbGFzc05hbWUgPSBbXCJWaWV3XCIsIGRpbWVuc2lvbiwgXCJkXCIsIGR0eXBlXS5qb2luKFwiXCIpXG4gIGlmKGRpbWVuc2lvbiA8IDApIHtcbiAgICBjbGFzc05hbWUgPSBcIlZpZXdfTmlsXCIgKyBkdHlwZVxuICB9XG4gIHZhciB1c2VHZXR0ZXJzID0gKGR0eXBlID09PSBcImdlbmVyaWNcIilcblxuICBpZihkaW1lbnNpb24gPT09IC0xKSB7XG4gICAgLy9TcGVjaWFsIGNhc2UgZm9yIHRyaXZpYWwgYXJyYXlzXG4gICAgdmFyIGNvZGUgPVxuICAgICAgXCJmdW5jdGlvbiBcIitjbGFzc05hbWUrXCIoYSl7dGhpcy5kYXRhPWE7fTtcXFxudmFyIHByb3RvPVwiK2NsYXNzTmFtZStcIi5wcm90b3R5cGU7XFxcbnByb3RvLmR0eXBlPSdcIitkdHlwZStcIic7XFxcbnByb3RvLmluZGV4PWZ1bmN0aW9uKCl7cmV0dXJuIC0xfTtcXFxucHJvdG8uc2l6ZT0wO1xcXG5wcm90by5kaW1lbnNpb249LTE7XFxcbnByb3RvLnNoYXBlPXByb3RvLnN0cmlkZT1wcm90by5vcmRlcj1bXTtcXFxucHJvdG8ubG89cHJvdG8uaGk9cHJvdG8udHJhbnNwb3NlPXByb3RvLnN0ZXA9XFxcbmZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBcIitjbGFzc05hbWUrXCIodGhpcy5kYXRhKTt9O1xcXG5wcm90by5nZXQ9cHJvdG8uc2V0PWZ1bmN0aW9uKCl7fTtcXFxucHJvdG8ucGljaz1mdW5jdGlvbigpe3JldHVybiBudWxsfTtcXFxucmV0dXJuIGZ1bmN0aW9uIGNvbnN0cnVjdF9cIitjbGFzc05hbWUrXCIoYSl7cmV0dXJuIG5ldyBcIitjbGFzc05hbWUrXCIoYSk7fVwiXG4gICAgdmFyIHByb2NlZHVyZSA9IG5ldyBGdW5jdGlvbihjb2RlKVxuICAgIHJldHVybiBwcm9jZWR1cmUoKVxuICB9IGVsc2UgaWYoZGltZW5zaW9uID09PSAwKSB7XG4gICAgLy9TcGVjaWFsIGNhc2UgZm9yIDBkIGFycmF5c1xuICAgIHZhciBjb2RlID1cbiAgICAgIFwiZnVuY3Rpb24gXCIrY2xhc3NOYW1lK1wiKGEsZCkge1xcXG50aGlzLmRhdGEgPSBhO1xcXG50aGlzLm9mZnNldCA9IGRcXFxufTtcXFxudmFyIHByb3RvPVwiK2NsYXNzTmFtZStcIi5wcm90b3R5cGU7XFxcbnByb3RvLmR0eXBlPSdcIitkdHlwZStcIic7XFxcbnByb3RvLmluZGV4PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMub2Zmc2V0fTtcXFxucHJvdG8uZGltZW5zaW9uPTA7XFxcbnByb3RvLnNpemU9MTtcXFxucHJvdG8uc2hhcGU9XFxcbnByb3RvLnN0cmlkZT1cXFxucHJvdG8ub3JkZXI9W107XFxcbnByb3RvLmxvPVxcXG5wcm90by5oaT1cXFxucHJvdG8udHJhbnNwb3NlPVxcXG5wcm90by5zdGVwPWZ1bmN0aW9uIFwiK2NsYXNzTmFtZStcIl9jb3B5KCkge1xcXG5yZXR1cm4gbmV3IFwiK2NsYXNzTmFtZStcIih0aGlzLmRhdGEsdGhpcy5vZmZzZXQpXFxcbn07XFxcbnByb3RvLnBpY2s9ZnVuY3Rpb24gXCIrY2xhc3NOYW1lK1wiX3BpY2soKXtcXFxucmV0dXJuIFRyaXZpYWxBcnJheSh0aGlzLmRhdGEpO1xcXG59O1xcXG5wcm90by52YWx1ZU9mPXByb3RvLmdldD1mdW5jdGlvbiBcIitjbGFzc05hbWUrXCJfZ2V0KCl7XFxcbnJldHVybiBcIisodXNlR2V0dGVycyA/IFwidGhpcy5kYXRhLmdldCh0aGlzLm9mZnNldClcIiA6IFwidGhpcy5kYXRhW3RoaXMub2Zmc2V0XVwiKStcblwifTtcXFxucHJvdG8uc2V0PWZ1bmN0aW9uIFwiK2NsYXNzTmFtZStcIl9zZXQodil7XFxcbnJldHVybiBcIisodXNlR2V0dGVycyA/IFwidGhpcy5kYXRhLnNldCh0aGlzLm9mZnNldCx2KVwiIDogXCJ0aGlzLmRhdGFbdGhpcy5vZmZzZXRdPXZcIikrXCJcXFxufTtcXFxucmV0dXJuIGZ1bmN0aW9uIGNvbnN0cnVjdF9cIitjbGFzc05hbWUrXCIoYSxiLGMsZCl7cmV0dXJuIG5ldyBcIitjbGFzc05hbWUrXCIoYSxkKX1cIlxuICAgIHZhciBwcm9jZWR1cmUgPSBuZXcgRnVuY3Rpb24oXCJUcml2aWFsQXJyYXlcIiwgY29kZSlcbiAgICByZXR1cm4gcHJvY2VkdXJlKENBQ0hFRF9DT05TVFJVQ1RPUlNbZHR5cGVdWzBdKVxuICB9XG5cbiAgdmFyIGNvZGUgPSBbXCIndXNlIHN0cmljdCdcIl1cblxuICAvL0NyZWF0ZSBjb25zdHJ1Y3RvciBmb3Igdmlld1xuICB2YXIgaW5kaWNlcyA9IGlvdGEoZGltZW5zaW9uKVxuICB2YXIgYXJncyA9IGluZGljZXMubWFwKGZ1bmN0aW9uKGkpIHsgcmV0dXJuIFwiaVwiK2kgfSlcbiAgdmFyIGluZGV4X3N0ciA9IFwidGhpcy5vZmZzZXQrXCIgKyBpbmRpY2VzLm1hcChmdW5jdGlvbihpKSB7XG4gICAgICAgIHJldHVybiBcInRoaXMuc3RyaWRlW1wiICsgaSArIFwiXSppXCIgKyBpXG4gICAgICB9KS5qb2luKFwiK1wiKVxuICB2YXIgc2hhcGVBcmcgPSBpbmRpY2VzLm1hcChmdW5jdGlvbihpKSB7XG4gICAgICByZXR1cm4gXCJiXCIraVxuICAgIH0pLmpvaW4oXCIsXCIpXG4gIHZhciBzdHJpZGVBcmcgPSBpbmRpY2VzLm1hcChmdW5jdGlvbihpKSB7XG4gICAgICByZXR1cm4gXCJjXCIraVxuICAgIH0pLmpvaW4oXCIsXCIpXG4gIGNvZGUucHVzaChcbiAgICBcImZ1bmN0aW9uIFwiK2NsYXNzTmFtZStcIihhLFwiICsgc2hhcGVBcmcgKyBcIixcIiArIHN0cmlkZUFyZyArIFwiLGQpe3RoaXMuZGF0YT1hXCIsXG4gICAgICBcInRoaXMuc2hhcGU9W1wiICsgc2hhcGVBcmcgKyBcIl1cIixcbiAgICAgIFwidGhpcy5zdHJpZGU9W1wiICsgc3RyaWRlQXJnICsgXCJdXCIsXG4gICAgICBcInRoaXMub2Zmc2V0PWR8MH1cIixcbiAgICBcInZhciBwcm90bz1cIitjbGFzc05hbWUrXCIucHJvdG90eXBlXCIsXG4gICAgXCJwcm90by5kdHlwZT0nXCIrZHR5cGUrXCInXCIsXG4gICAgXCJwcm90by5kaW1lbnNpb249XCIrZGltZW5zaW9uKVxuXG4gIC8vdmlldy5zaXplOlxuICBjb2RlLnB1c2goXCJPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvdG8sJ3NpemUnLHtnZXQ6ZnVuY3Rpb24gXCIrY2xhc3NOYW1lK1wiX3NpemUoKXtcXFxucmV0dXJuIFwiK2luZGljZXMubWFwKGZ1bmN0aW9uKGkpIHsgcmV0dXJuIFwidGhpcy5zaGFwZVtcIitpK1wiXVwiIH0pLmpvaW4oXCIqXCIpLFxuXCJ9fSlcIilcblxuICAvL3ZpZXcub3JkZXI6XG4gIGlmKGRpbWVuc2lvbiA9PT0gMSkge1xuICAgIGNvZGUucHVzaChcInByb3RvLm9yZGVyPVswXVwiKVxuICB9IGVsc2Uge1xuICAgIGNvZGUucHVzaChcIk9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm90bywnb3JkZXInLHtnZXQ6XCIpXG4gICAgaWYoZGltZW5zaW9uIDwgNCkge1xuICAgICAgY29kZS5wdXNoKFwiZnVuY3Rpb24gXCIrY2xhc3NOYW1lK1wiX29yZGVyKCl7XCIpXG4gICAgICBpZihkaW1lbnNpb24gPT09IDIpIHtcbiAgICAgICAgY29kZS5wdXNoKFwicmV0dXJuIChNYXRoLmFicyh0aGlzLnN0cmlkZVswXSk+TWF0aC5hYnModGhpcy5zdHJpZGVbMV0pKT9bMSwwXTpbMCwxXX19KVwiKVxuICAgICAgfSBlbHNlIGlmKGRpbWVuc2lvbiA9PT0gMykge1xuICAgICAgICBjb2RlLnB1c2goXG5cInZhciBzMD1NYXRoLmFicyh0aGlzLnN0cmlkZVswXSksczE9TWF0aC5hYnModGhpcy5zdHJpZGVbMV0pLHMyPU1hdGguYWJzKHRoaXMuc3RyaWRlWzJdKTtcXFxuaWYoczA+czEpe1xcXG5pZihzMT5zMil7XFxcbnJldHVybiBbMiwxLDBdO1xcXG59ZWxzZSBpZihzMD5zMil7XFxcbnJldHVybiBbMSwyLDBdO1xcXG59ZWxzZXtcXFxucmV0dXJuIFsxLDAsMl07XFxcbn1cXFxufWVsc2UgaWYoczA+czIpe1xcXG5yZXR1cm4gWzIsMCwxXTtcXFxufWVsc2UgaWYoczI+czEpe1xcXG5yZXR1cm4gWzAsMSwyXTtcXFxufWVsc2V7XFxcbnJldHVybiBbMCwyLDFdO1xcXG59fX0pXCIpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvZGUucHVzaChcIk9SREVSfSlcIilcbiAgICB9XG4gIH1cblxuICAvL3ZpZXcuc2V0KGkwLCAuLi4sIHYpOlxuICBjb2RlLnB1c2goXG5cInByb3RvLnNldD1mdW5jdGlvbiBcIitjbGFzc05hbWUrXCJfc2V0KFwiK2FyZ3Muam9pbihcIixcIikrXCIsdil7XCIpXG4gIGlmKHVzZUdldHRlcnMpIHtcbiAgICBjb2RlLnB1c2goXCJyZXR1cm4gdGhpcy5kYXRhLnNldChcIitpbmRleF9zdHIrXCIsdil9XCIpXG4gIH0gZWxzZSB7XG4gICAgY29kZS5wdXNoKFwicmV0dXJuIHRoaXMuZGF0YVtcIitpbmRleF9zdHIrXCJdPXZ9XCIpXG4gIH1cblxuICAvL3ZpZXcuZ2V0KGkwLCAuLi4pOlxuICBjb2RlLnB1c2goXCJwcm90by5nZXQ9ZnVuY3Rpb24gXCIrY2xhc3NOYW1lK1wiX2dldChcIithcmdzLmpvaW4oXCIsXCIpK1wiKXtcIilcbiAgaWYodXNlR2V0dGVycykge1xuICAgIGNvZGUucHVzaChcInJldHVybiB0aGlzLmRhdGEuZ2V0KFwiK2luZGV4X3N0citcIil9XCIpXG4gIH0gZWxzZSB7XG4gICAgY29kZS5wdXNoKFwicmV0dXJuIHRoaXMuZGF0YVtcIitpbmRleF9zdHIrXCJdfVwiKVxuICB9XG5cbiAgLy92aWV3LmluZGV4OlxuICBjb2RlLnB1c2goXG4gICAgXCJwcm90by5pbmRleD1mdW5jdGlvbiBcIitjbGFzc05hbWUrXCJfaW5kZXgoXCIsIGFyZ3Muam9pbigpLCBcIil7cmV0dXJuIFwiK2luZGV4X3N0citcIn1cIilcblxuICAvL3ZpZXcuaGkoKTpcbiAgY29kZS5wdXNoKFwicHJvdG8uaGk9ZnVuY3Rpb24gXCIrY2xhc3NOYW1lK1wiX2hpKFwiK2FyZ3Muam9pbihcIixcIikrXCIpe3JldHVybiBuZXcgXCIrY2xhc3NOYW1lK1wiKHRoaXMuZGF0YSxcIitcbiAgICBpbmRpY2VzLm1hcChmdW5jdGlvbihpKSB7XG4gICAgICByZXR1cm4gW1wiKHR5cGVvZiBpXCIsaSxcIiE9PSdudW1iZXInfHxpXCIsaSxcIjwwKT90aGlzLnNoYXBlW1wiLCBpLCBcIl06aVwiLCBpLFwifDBcIl0uam9pbihcIlwiKVxuICAgIH0pLmpvaW4oXCIsXCIpK1wiLFwiK1xuICAgIGluZGljZXMubWFwKGZ1bmN0aW9uKGkpIHtcbiAgICAgIHJldHVybiBcInRoaXMuc3RyaWRlW1wiK2kgKyBcIl1cIlxuICAgIH0pLmpvaW4oXCIsXCIpK1wiLHRoaXMub2Zmc2V0KX1cIilcblxuICAvL3ZpZXcubG8oKTpcbiAgdmFyIGFfdmFycyA9IGluZGljZXMubWFwKGZ1bmN0aW9uKGkpIHsgcmV0dXJuIFwiYVwiK2krXCI9dGhpcy5zaGFwZVtcIitpK1wiXVwiIH0pXG4gIHZhciBjX3ZhcnMgPSBpbmRpY2VzLm1hcChmdW5jdGlvbihpKSB7IHJldHVybiBcImNcIitpK1wiPXRoaXMuc3RyaWRlW1wiK2krXCJdXCIgfSlcbiAgY29kZS5wdXNoKFwicHJvdG8ubG89ZnVuY3Rpb24gXCIrY2xhc3NOYW1lK1wiX2xvKFwiK2FyZ3Muam9pbihcIixcIikrXCIpe3ZhciBiPXRoaXMub2Zmc2V0LGQ9MCxcIithX3ZhcnMuam9pbihcIixcIikrXCIsXCIrY192YXJzLmpvaW4oXCIsXCIpKVxuICBmb3IodmFyIGk9MDsgaTxkaW1lbnNpb247ICsraSkge1xuICAgIGNvZGUucHVzaChcblwiaWYodHlwZW9mIGlcIitpK1wiPT09J251bWJlcicmJmlcIitpK1wiPj0wKXtcXFxuZD1pXCIraStcInwwO1xcXG5iKz1jXCIraStcIipkO1xcXG5hXCIraStcIi09ZH1cIilcbiAgfVxuICBjb2RlLnB1c2goXCJyZXR1cm4gbmV3IFwiK2NsYXNzTmFtZStcIih0aGlzLmRhdGEsXCIrXG4gICAgaW5kaWNlcy5tYXAoZnVuY3Rpb24oaSkge1xuICAgICAgcmV0dXJuIFwiYVwiK2lcbiAgICB9KS5qb2luKFwiLFwiKStcIixcIitcbiAgICBpbmRpY2VzLm1hcChmdW5jdGlvbihpKSB7XG4gICAgICByZXR1cm4gXCJjXCIraVxuICAgIH0pLmpvaW4oXCIsXCIpK1wiLGIpfVwiKVxuXG4gIC8vdmlldy5zdGVwKCk6XG4gIGNvZGUucHVzaChcInByb3RvLnN0ZXA9ZnVuY3Rpb24gXCIrY2xhc3NOYW1lK1wiX3N0ZXAoXCIrYXJncy5qb2luKFwiLFwiKStcIil7dmFyIFwiK1xuICAgIGluZGljZXMubWFwKGZ1bmN0aW9uKGkpIHtcbiAgICAgIHJldHVybiBcImFcIitpK1wiPXRoaXMuc2hhcGVbXCIraStcIl1cIlxuICAgIH0pLmpvaW4oXCIsXCIpK1wiLFwiK1xuICAgIGluZGljZXMubWFwKGZ1bmN0aW9uKGkpIHtcbiAgICAgIHJldHVybiBcImJcIitpK1wiPXRoaXMuc3RyaWRlW1wiK2krXCJdXCJcbiAgICB9KS5qb2luKFwiLFwiKStcIixjPXRoaXMub2Zmc2V0LGQ9MCxjZWlsPU1hdGguY2VpbFwiKVxuICBmb3IodmFyIGk9MDsgaTxkaW1lbnNpb247ICsraSkge1xuICAgIGNvZGUucHVzaChcblwiaWYodHlwZW9mIGlcIitpK1wiPT09J251bWJlcicpe1xcXG5kPWlcIitpK1wifDA7XFxcbmlmKGQ8MCl7XFxcbmMrPWJcIitpK1wiKihhXCIraStcIi0xKTtcXFxuYVwiK2krXCI9Y2VpbCgtYVwiK2krXCIvZClcXFxufWVsc2V7XFxcbmFcIitpK1wiPWNlaWwoYVwiK2krXCIvZClcXFxufVxcXG5iXCIraStcIio9ZFxcXG59XCIpXG4gIH1cbiAgY29kZS5wdXNoKFwicmV0dXJuIG5ldyBcIitjbGFzc05hbWUrXCIodGhpcy5kYXRhLFwiK1xuICAgIGluZGljZXMubWFwKGZ1bmN0aW9uKGkpIHtcbiAgICAgIHJldHVybiBcImFcIiArIGlcbiAgICB9KS5qb2luKFwiLFwiKStcIixcIitcbiAgICBpbmRpY2VzLm1hcChmdW5jdGlvbihpKSB7XG4gICAgICByZXR1cm4gXCJiXCIgKyBpXG4gICAgfSkuam9pbihcIixcIikrXCIsYyl9XCIpXG5cbiAgLy92aWV3LnRyYW5zcG9zZSgpOlxuICB2YXIgdFNoYXBlID0gbmV3IEFycmF5KGRpbWVuc2lvbilcbiAgdmFyIHRTdHJpZGUgPSBuZXcgQXJyYXkoZGltZW5zaW9uKVxuICBmb3IodmFyIGk9MDsgaTxkaW1lbnNpb247ICsraSkge1xuICAgIHRTaGFwZVtpXSA9IFwiYVtpXCIraStcIl1cIlxuICAgIHRTdHJpZGVbaV0gPSBcImJbaVwiK2krXCJdXCJcbiAgfVxuICBjb2RlLnB1c2goXCJwcm90by50cmFuc3Bvc2U9ZnVuY3Rpb24gXCIrY2xhc3NOYW1lK1wiX3RyYW5zcG9zZShcIithcmdzK1wiKXtcIitcbiAgICBhcmdzLm1hcChmdW5jdGlvbihuLGlkeCkgeyByZXR1cm4gbiArIFwiPShcIiArIG4gKyBcIj09PXVuZGVmaW5lZD9cIiArIGlkeCArIFwiOlwiICsgbiArIFwifDApXCJ9KS5qb2luKFwiO1wiKSxcbiAgICBcInZhciBhPXRoaXMuc2hhcGUsYj10aGlzLnN0cmlkZTtyZXR1cm4gbmV3IFwiK2NsYXNzTmFtZStcIih0aGlzLmRhdGEsXCIrdFNoYXBlLmpvaW4oXCIsXCIpK1wiLFwiK3RTdHJpZGUuam9pbihcIixcIikrXCIsdGhpcy5vZmZzZXQpfVwiKVxuXG4gIC8vdmlldy5waWNrKCk6XG4gIGNvZGUucHVzaChcInByb3RvLnBpY2s9ZnVuY3Rpb24gXCIrY2xhc3NOYW1lK1wiX3BpY2soXCIrYXJncytcIil7dmFyIGE9W10sYj1bXSxjPXRoaXMub2Zmc2V0XCIpXG4gIGZvcih2YXIgaT0wOyBpPGRpbWVuc2lvbjsgKytpKSB7XG4gICAgY29kZS5wdXNoKFwiaWYodHlwZW9mIGlcIitpK1wiPT09J251bWJlcicmJmlcIitpK1wiPj0wKXtjPShjK3RoaXMuc3RyaWRlW1wiK2krXCJdKmlcIitpK1wiKXwwfWVsc2V7YS5wdXNoKHRoaXMuc2hhcGVbXCIraStcIl0pO2IucHVzaCh0aGlzLnN0cmlkZVtcIitpK1wiXSl9XCIpXG4gIH1cbiAgY29kZS5wdXNoKFwidmFyIGN0b3I9Q1RPUl9MSVNUW2EubGVuZ3RoKzFdO3JldHVybiBjdG9yKHRoaXMuZGF0YSxhLGIsYyl9XCIpXG5cbiAgLy9BZGQgcmV0dXJuIHN0YXRlbWVudFxuICBjb2RlLnB1c2goXCJyZXR1cm4gZnVuY3Rpb24gY29uc3RydWN0X1wiK2NsYXNzTmFtZStcIihkYXRhLHNoYXBlLHN0cmlkZSxvZmZzZXQpe3JldHVybiBuZXcgXCIrY2xhc3NOYW1lK1wiKGRhdGEsXCIrXG4gICAgaW5kaWNlcy5tYXAoZnVuY3Rpb24oaSkge1xuICAgICAgcmV0dXJuIFwic2hhcGVbXCIraStcIl1cIlxuICAgIH0pLmpvaW4oXCIsXCIpK1wiLFwiK1xuICAgIGluZGljZXMubWFwKGZ1bmN0aW9uKGkpIHtcbiAgICAgIHJldHVybiBcInN0cmlkZVtcIitpK1wiXVwiXG4gICAgfSkuam9pbihcIixcIikrXCIsb2Zmc2V0KX1cIilcblxuICAvL0NvbXBpbGUgcHJvY2VkdXJlXG4gIHZhciBwcm9jZWR1cmUgPSBuZXcgRnVuY3Rpb24oXCJDVE9SX0xJU1RcIiwgXCJPUkRFUlwiLCBjb2RlLmpvaW4oXCJcXG5cIikpXG4gIHJldHVybiBwcm9jZWR1cmUoQ0FDSEVEX0NPTlNUUlVDVE9SU1tkdHlwZV0sIG9yZGVyKVxufVxuXG5mdW5jdGlvbiBhcnJheURUeXBlKGRhdGEpIHtcbiAgaWYoaXNCdWZmZXIoZGF0YSkpIHtcbiAgICByZXR1cm4gXCJidWZmZXJcIlxuICB9XG4gIGlmKGhhc1R5cGVkQXJyYXlzKSB7XG4gICAgc3dpdGNoKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChkYXRhKSkge1xuICAgICAgY2FzZSBcIltvYmplY3QgRmxvYXQ2NEFycmF5XVwiOlxuICAgICAgICByZXR1cm4gXCJmbG9hdDY0XCJcbiAgICAgIGNhc2UgXCJbb2JqZWN0IEZsb2F0MzJBcnJheV1cIjpcbiAgICAgICAgcmV0dXJuIFwiZmxvYXQzMlwiXG4gICAgICBjYXNlIFwiW29iamVjdCBJbnQ4QXJyYXldXCI6XG4gICAgICAgIHJldHVybiBcImludDhcIlxuICAgICAgY2FzZSBcIltvYmplY3QgSW50MTZBcnJheV1cIjpcbiAgICAgICAgcmV0dXJuIFwiaW50MTZcIlxuICAgICAgY2FzZSBcIltvYmplY3QgSW50MzJBcnJheV1cIjpcbiAgICAgICAgcmV0dXJuIFwiaW50MzJcIlxuICAgICAgY2FzZSBcIltvYmplY3QgVWludDhBcnJheV1cIjpcbiAgICAgICAgcmV0dXJuIFwidWludDhcIlxuICAgICAgY2FzZSBcIltvYmplY3QgVWludDE2QXJyYXldXCI6XG4gICAgICAgIHJldHVybiBcInVpbnQxNlwiXG4gICAgICBjYXNlIFwiW29iamVjdCBVaW50MzJBcnJheV1cIjpcbiAgICAgICAgcmV0dXJuIFwidWludDMyXCJcbiAgICAgIGNhc2UgXCJbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XVwiOlxuICAgICAgICByZXR1cm4gXCJ1aW50OF9jbGFtcGVkXCJcbiAgICAgIGNhc2UgXCJbb2JqZWN0IEJpZ0ludDY0QXJyYXldXCI6XG4gICAgICAgIHJldHVybiBcImJpZ2ludDY0XCJcbiAgICAgIGNhc2UgXCJbb2JqZWN0IEJpZ1VpbnQ2NEFycmF5XVwiOlxuICAgICAgICByZXR1cm4gXCJiaWd1aW50NjRcIlxuICAgIH1cbiAgfVxuICBpZihBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgcmV0dXJuIFwiYXJyYXlcIlxuICB9XG4gIHJldHVybiBcImdlbmVyaWNcIlxufVxuXG52YXIgQ0FDSEVEX0NPTlNUUlVDVE9SUyA9IHtcbiAgXCJmbG9hdDMyXCI6W10sXG4gIFwiZmxvYXQ2NFwiOltdLFxuICBcImludDhcIjpbXSxcbiAgXCJpbnQxNlwiOltdLFxuICBcImludDMyXCI6W10sXG4gIFwidWludDhcIjpbXSxcbiAgXCJ1aW50MTZcIjpbXSxcbiAgXCJ1aW50MzJcIjpbXSxcbiAgXCJhcnJheVwiOltdLFxuICBcInVpbnQ4X2NsYW1wZWRcIjpbXSxcbiAgXCJiaWdpbnQ2NFwiOiBbXSxcbiAgXCJiaWd1aW50NjRcIjogW10sXG4gIFwiYnVmZmVyXCI6W10sXG4gIFwiZ2VuZXJpY1wiOltdXG59XG5cbjsoZnVuY3Rpb24oKSB7XG4gIGZvcih2YXIgaWQgaW4gQ0FDSEVEX0NPTlNUUlVDVE9SUykge1xuICAgIENBQ0hFRF9DT05TVFJVQ1RPUlNbaWRdLnB1c2goY29tcGlsZUNvbnN0cnVjdG9yKGlkLCAtMSkpXG4gIH1cbn0pO1xuXG5mdW5jdGlvbiB3cmFwcGVkTkRBcnJheUN0b3IoZGF0YSwgc2hhcGUsIHN0cmlkZSwgb2Zmc2V0KSB7XG4gIGlmKGRhdGEgPT09IHVuZGVmaW5lZCkge1xuICAgIHZhciBjdG9yID0gQ0FDSEVEX0NPTlNUUlVDVE9SUy5hcnJheVswXVxuICAgIHJldHVybiBjdG9yKFtdKVxuICB9IGVsc2UgaWYodHlwZW9mIGRhdGEgPT09IFwibnVtYmVyXCIpIHtcbiAgICBkYXRhID0gW2RhdGFdXG4gIH1cbiAgaWYoc2hhcGUgPT09IHVuZGVmaW5lZCkge1xuICAgIHNoYXBlID0gWyBkYXRhLmxlbmd0aCBdXG4gIH1cbiAgdmFyIGQgPSBzaGFwZS5sZW5ndGhcbiAgaWYoc3RyaWRlID09PSB1bmRlZmluZWQpIHtcbiAgICBzdHJpZGUgPSBuZXcgQXJyYXkoZClcbiAgICBmb3IodmFyIGk9ZC0xLCBzej0xOyBpPj0wOyAtLWkpIHtcbiAgICAgIHN0cmlkZVtpXSA9IHN6XG4gICAgICBzeiAqPSBzaGFwZVtpXVxuICAgIH1cbiAgfVxuICBpZihvZmZzZXQgPT09IHVuZGVmaW5lZCkge1xuICAgIG9mZnNldCA9IDBcbiAgICBmb3IodmFyIGk9MDsgaTxkOyArK2kpIHtcbiAgICAgIGlmKHN0cmlkZVtpXSA8IDApIHtcbiAgICAgICAgb2Zmc2V0IC09IChzaGFwZVtpXS0xKSpzdHJpZGVbaV1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgdmFyIGR0eXBlID0gYXJyYXlEVHlwZShkYXRhKVxuICB2YXIgY3Rvcl9saXN0ID0gQ0FDSEVEX0NPTlNUUlVDVE9SU1tkdHlwZV1cbiAgd2hpbGUoY3Rvcl9saXN0Lmxlbmd0aCA8PSBkKzEpIHtcbiAgICBjdG9yX2xpc3QucHVzaChjb21waWxlQ29uc3RydWN0b3IoZHR5cGUsIGN0b3JfbGlzdC5sZW5ndGgtMSkpXG4gIH1cbiAgdmFyIGN0b3IgPSBjdG9yX2xpc3RbZCsxXVxuICByZXR1cm4gY3RvcihkYXRhLCBzaGFwZSwgc3RyaWRlLCBvZmZzZXQpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gd3JhcHBlZE5EQXJyYXlDdG9yXG4iLCJcInVzZSBzdHJpY3RcIlxuXG52YXIgZG91YmxlQml0cyA9IHJlcXVpcmUoXCJkb3VibGUtYml0c1wiKVxuXG52YXIgU01BTExFU1RfREVOT1JNID0gTWF0aC5wb3coMiwgLTEwNzQpXG52YXIgVUlOVF9NQVggPSAoLTEpPj4+MFxuXG5tb2R1bGUuZXhwb3J0cyA9IG5leHRhZnRlclxuXG5mdW5jdGlvbiBuZXh0YWZ0ZXIoeCwgeSkge1xuICBpZihpc05hTih4KSB8fCBpc05hTih5KSkge1xuICAgIHJldHVybiBOYU5cbiAgfVxuICBpZih4ID09PSB5KSB7XG4gICAgcmV0dXJuIHhcbiAgfVxuICBpZih4ID09PSAwKSB7XG4gICAgaWYoeSA8IDApIHtcbiAgICAgIHJldHVybiAtU01BTExFU1RfREVOT1JNXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBTTUFMTEVTVF9ERU5PUk1cbiAgICB9XG4gIH1cbiAgdmFyIGhpID0gZG91YmxlQml0cy5oaSh4KVxuICB2YXIgbG8gPSBkb3VibGVCaXRzLmxvKHgpXG4gIGlmKCh5ID4geCkgPT09ICh4ID4gMCkpIHtcbiAgICBpZihsbyA9PT0gVUlOVF9NQVgpIHtcbiAgICAgIGhpICs9IDFcbiAgICAgIGxvID0gMFxuICAgIH0gZWxzZSB7XG4gICAgICBsbyArPSAxXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmKGxvID09PSAwKSB7XG4gICAgICBsbyA9IFVJTlRfTUFYXG4gICAgICBoaSAtPSAxXG4gICAgfSBlbHNlIHtcbiAgICAgIGxvIC09IDFcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRvdWJsZUJpdHMucGFjayhsbywgaGkpXG59IiwiLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjEyLjJcbihmdW5jdGlvbigpIHtcbiAgdmFyIGdldE5hbm9TZWNvbmRzLCBocnRpbWUsIGxvYWRUaW1lLCBtb2R1bGVMb2FkVGltZSwgbm9kZUxvYWRUaW1lLCB1cFRpbWU7XG5cbiAgaWYgKCh0eXBlb2YgcGVyZm9ybWFuY2UgIT09IFwidW5kZWZpbmVkXCIgJiYgcGVyZm9ybWFuY2UgIT09IG51bGwpICYmIHBlcmZvcm1hbmNlLm5vdykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgfTtcbiAgfSBlbHNlIGlmICgodHlwZW9mIHByb2Nlc3MgIT09IFwidW5kZWZpbmVkXCIgJiYgcHJvY2VzcyAhPT0gbnVsbCkgJiYgcHJvY2Vzcy5ocnRpbWUpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIChnZXROYW5vU2Vjb25kcygpIC0gbm9kZUxvYWRUaW1lKSAvIDFlNjtcbiAgICB9O1xuICAgIGhydGltZSA9IHByb2Nlc3MuaHJ0aW1lO1xuICAgIGdldE5hbm9TZWNvbmRzID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgaHI7XG4gICAgICBociA9IGhydGltZSgpO1xuICAgICAgcmV0dXJuIGhyWzBdICogMWU5ICsgaHJbMV07XG4gICAgfTtcbiAgICBtb2R1bGVMb2FkVGltZSA9IGdldE5hbm9TZWNvbmRzKCk7XG4gICAgdXBUaW1lID0gcHJvY2Vzcy51cHRpbWUoKSAqIDFlOTtcbiAgICBub2RlTG9hZFRpbWUgPSBtb2R1bGVMb2FkVGltZSAtIHVwVGltZTtcbiAgfSBlbHNlIGlmIChEYXRlLm5vdykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gRGF0ZS5ub3coKSAtIGxvYWRUaW1lO1xuICAgIH07XG4gICAgbG9hZFRpbWUgPSBEYXRlLm5vdygpO1xuICB9IGVsc2Uge1xuICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCkgLSBsb2FkVGltZTtcbiAgICB9O1xuICAgIGxvYWRUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gIH1cblxufSkuY2FsbCh0aGlzKTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGVyZm9ybWFuY2Utbm93LmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCJcblxubW9kdWxlLmV4cG9ydHMgPSBwZXJtdXRhdGlvblNpZ25cblxudmFyIEJSVVRFX0ZPUkNFX0NVVE9GRiA9IDMyXG5cbnZhciBwb29sID0gcmVxdWlyZShcInR5cGVkYXJyYXktcG9vbFwiKVxuXG5mdW5jdGlvbiBwZXJtdXRhdGlvblNpZ24ocCkge1xuICB2YXIgbiA9IHAubGVuZ3RoXG4gIGlmKG4gPCBCUlVURV9GT1JDRV9DVVRPRkYpIHtcbiAgICAvL1VzZSBxdWFkcmF0aWMgYWxnb3JpdGhtIGZvciBzbWFsbCBuXG4gICAgdmFyIHNnbiA9IDFcbiAgICBmb3IodmFyIGk9MDsgaTxuOyArK2kpIHtcbiAgICAgIGZvcih2YXIgaj0wOyBqPGk7ICsraikge1xuICAgICAgICBpZihwW2ldIDwgcFtqXSkge1xuICAgICAgICAgIHNnbiA9IC1zZ25cbiAgICAgICAgfSBlbHNlIGlmKHBbaV0gPT09IHBbal0pIHtcbiAgICAgICAgICByZXR1cm4gMFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzZ25cbiAgfSBlbHNlIHtcbiAgICAvL090aGVyd2lzZSB1c2UgbGluZWFyIHRpbWUgYWxnb3JpdGhtXG4gICAgdmFyIHZpc2l0ZWQgPSBwb29sLm1hbGxvY1VpbnQ4KG4pXG4gICAgZm9yKHZhciBpPTA7IGk8bjsgKytpKSB7XG4gICAgICB2aXNpdGVkW2ldID0gMFxuICAgIH1cbiAgICB2YXIgc2duID0gMVxuICAgIGZvcih2YXIgaT0wOyBpPG47ICsraSkge1xuICAgICAgaWYoIXZpc2l0ZWRbaV0pIHtcbiAgICAgICAgdmFyIGNvdW50ID0gMVxuICAgICAgICB2aXNpdGVkW2ldID0gMVxuICAgICAgICBmb3IodmFyIGo9cFtpXTsgaiE9PWk7IGo9cFtqXSkge1xuICAgICAgICAgIGlmKHZpc2l0ZWRbal0pIHtcbiAgICAgICAgICAgIHBvb2wuZnJlZVVpbnQ4KHZpc2l0ZWQpXG4gICAgICAgICAgICByZXR1cm4gMFxuICAgICAgICAgIH1cbiAgICAgICAgICBjb3VudCArPSAxXG4gICAgICAgICAgdmlzaXRlZFtqXSA9IDFcbiAgICAgICAgfVxuICAgICAgICBpZighKGNvdW50ICYgMSkpIHtcbiAgICAgICAgICBzZ24gPSAtc2duXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcG9vbC5mcmVlVWludDgodmlzaXRlZClcbiAgICByZXR1cm4gc2duXG4gIH1cbn0iLCJcInVzZSBzdHJpY3RcIlxuXG52YXIgcG9vbCA9IHJlcXVpcmUoXCJ0eXBlZGFycmF5LXBvb2xcIilcbnZhciBpbnZlcnNlID0gcmVxdWlyZShcImludmVydC1wZXJtdXRhdGlvblwiKVxuXG5mdW5jdGlvbiByYW5rKHBlcm11dGF0aW9uKSB7XG4gIHZhciBuID0gcGVybXV0YXRpb24ubGVuZ3RoXG4gIHN3aXRjaChuKSB7XG4gICAgY2FzZSAwOlxuICAgIGNhc2UgMTpcbiAgICAgIHJldHVybiAwXG4gICAgY2FzZSAyOlxuICAgICAgcmV0dXJuIHBlcm11dGF0aW9uWzFdXG4gICAgZGVmYXVsdDpcbiAgICAgIGJyZWFrXG4gIH1cbiAgdmFyIHAgPSBwb29sLm1hbGxvY1VpbnQzMihuKVxuICB2YXIgcGludiA9IHBvb2wubWFsbG9jVWludDMyKG4pXG4gIHZhciByID0gMCwgcywgdCwgaVxuICBpbnZlcnNlKHBlcm11dGF0aW9uLCBwaW52KVxuICBmb3IoaT0wOyBpPG47ICsraSkge1xuICAgIHBbaV0gPSBwZXJtdXRhdGlvbltpXVxuICB9XG4gIGZvcihpPW4tMTsgaT4wOyAtLWkpIHtcbiAgICB0ID0gcGludltpXVxuICAgIHMgPSBwW2ldXG4gICAgcFtpXSA9IHBbdF1cbiAgICBwW3RdID0gc1xuICAgIHBpbnZbaV0gPSBwaW52W3NdXG4gICAgcGludltzXSA9IHRcbiAgICByID0gKHIgKyBzKSAqIGlcbiAgfVxuICBwb29sLmZyZWVVaW50MzIocGludilcbiAgcG9vbC5mcmVlVWludDMyKHApXG4gIHJldHVybiByXG59XG5cbmZ1bmN0aW9uIHVucmFuayhuLCByLCBwKSB7XG4gIHN3aXRjaChuKSB7XG4gICAgY2FzZSAwOlxuICAgICAgaWYocCkgeyByZXR1cm4gcCB9XG4gICAgICByZXR1cm4gW11cbiAgICBjYXNlIDE6XG4gICAgICBpZihwKSB7XG4gICAgICAgIHBbMF0gPSAwXG4gICAgICAgIHJldHVybiBwXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gWzBdXG4gICAgICB9XG4gICAgY2FzZSAyOlxuICAgICAgaWYocCkge1xuICAgICAgICBpZihyKSB7XG4gICAgICAgICAgcFswXSA9IDBcbiAgICAgICAgICBwWzFdID0gMVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBbMF0gPSAxXG4gICAgICAgICAgcFsxXSA9IDBcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHIgPyBbMCwxXSA6IFsxLDBdXG4gICAgICB9XG4gICAgZGVmYXVsdDpcbiAgICAgIGJyZWFrXG4gIH1cbiAgcCA9IHAgfHwgbmV3IEFycmF5KG4pXG4gIHZhciBzLCB0LCBpLCBuZj0xXG4gIHBbMF0gPSAwXG4gIGZvcihpPTE7IGk8bjsgKytpKSB7XG4gICAgcFtpXSA9IGlcbiAgICBuZiA9IChuZippKXwwXG4gIH1cbiAgZm9yKGk9bi0xOyBpPjA7IC0taSkge1xuICAgIHMgPSAociAvIG5mKXwwXG4gICAgciA9IChyIC0gcyAqIG5mKXwwXG4gICAgbmYgPSAobmYgLyBpKXwwXG4gICAgdCA9IHBbaV18MFxuICAgIHBbaV0gPSBwW3NdfDBcbiAgICBwW3NdID0gdHwwXG4gIH1cbiAgcmV0dXJuIHBcbn1cblxuZXhwb3J0cy5yYW5rID0gcmFua1xuZXhwb3J0cy51bnJhbmsgPSB1bnJhbmtcbiIsIlwidXNlIHN0cmljdFwiXG5cbm1vZHVsZS5leHBvcnRzID0gcGxhbmFyRHVhbFxuXG52YXIgY29tcGFyZUFuZ2xlID0gcmVxdWlyZShcImNvbXBhcmUtYW5nbGVcIilcblxuZnVuY3Rpb24gcGxhbmFyRHVhbChjZWxscywgcG9zaXRpb25zKSB7XG5cbiAgdmFyIG51bVZlcnRpY2VzID0gcG9zaXRpb25zLmxlbmd0aHwwXG4gIHZhciBudW1FZGdlcyA9IGNlbGxzLmxlbmd0aFxuICB2YXIgYWRqID0gW25ldyBBcnJheShudW1WZXJ0aWNlcyksIG5ldyBBcnJheShudW1WZXJ0aWNlcyldXG4gIGZvcih2YXIgaT0wOyBpPG51bVZlcnRpY2VzOyArK2kpIHtcbiAgICBhZGpbMF1baV0gPSBbXVxuICAgIGFkalsxXVtpXSA9IFtdXG4gIH1cbiAgZm9yKHZhciBpPTA7IGk8bnVtRWRnZXM7ICsraSkge1xuICAgIHZhciBjID0gY2VsbHNbaV1cbiAgICBhZGpbMF1bY1swXV0ucHVzaChjKVxuICAgIGFkalsxXVtjWzFdXS5wdXNoKGMpXG4gIH1cblxuICB2YXIgY3ljbGVzID0gW11cblxuICAvL0FkZCBpc29sYXRlZCB2ZXJ0aWNlcyBhcyB0cml2aWFsIGNhc2VcbiAgZm9yKHZhciBpPTA7IGk8bnVtVmVydGljZXM7ICsraSkge1xuICAgIGlmKGFkalswXVtpXS5sZW5ndGggKyBhZGpbMV1baV0ubGVuZ3RoID09PSAwKSB7XG4gICAgICBjeWNsZXMucHVzaCggW2ldIClcbiAgICB9XG4gIH1cblxuICAvL1JlbW92ZSBhIGhhbGYgZWRnZVxuICBmdW5jdGlvbiBjdXQoYywgaSkge1xuICAgIHZhciBhID0gYWRqW2ldW2NbaV1dXG4gICAgYS5zcGxpY2UoYS5pbmRleE9mKGMpLCAxKVxuICB9XG5cbiAgLy9GaW5kIG5leHQgdmVydGV4IGFuZCBjdXQgZWRnZVxuICBmdW5jdGlvbiBuZXh0KGEsIGIsIG5vQ3V0KSB7XG4gICAgdmFyIG5leHRDZWxsLCBuZXh0VmVydGV4LCBuZXh0RGlyXG4gICAgZm9yKHZhciBpPTA7IGk8MjsgKytpKSB7XG4gICAgICBpZihhZGpbaV1bYl0ubGVuZ3RoID4gMCkge1xuICAgICAgICBuZXh0Q2VsbCA9IGFkaltpXVtiXVswXVxuICAgICAgICBuZXh0RGlyID0gaVxuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgICBuZXh0VmVydGV4ID0gbmV4dENlbGxbbmV4dERpcl4xXVxuXG4gICAgZm9yKHZhciBkaXI9MDsgZGlyPDI7ICsrZGlyKSB7XG4gICAgICB2YXIgbmJoZCA9IGFkaltkaXJdW2JdXG4gICAgICBmb3IodmFyIGs9MDsgazxuYmhkLmxlbmd0aDsgKytrKSB7XG4gICAgICAgIHZhciBlID0gbmJoZFtrXVxuICAgICAgICB2YXIgcCA9IGVbZGlyXjFdXG4gICAgICAgIHZhciBjbXAgPSBjb21wYXJlQW5nbGUoXG4gICAgICAgICAgICBwb3NpdGlvbnNbYV0sIFxuICAgICAgICAgICAgcG9zaXRpb25zW2JdLCBcbiAgICAgICAgICAgIHBvc2l0aW9uc1tuZXh0VmVydGV4XSxcbiAgICAgICAgICAgIHBvc2l0aW9uc1twXSlcbiAgICAgICAgaWYoY21wID4gMCkge1xuICAgICAgICAgIG5leHRDZWxsID0gZVxuICAgICAgICAgIG5leHRWZXJ0ZXggPSBwXG4gICAgICAgICAgbmV4dERpciA9IGRpclxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmKG5vQ3V0KSB7XG4gICAgICByZXR1cm4gbmV4dFZlcnRleFxuICAgIH1cbiAgICBpZihuZXh0Q2VsbCkge1xuICAgICAgY3V0KG5leHRDZWxsLCBuZXh0RGlyKVxuICAgIH1cbiAgICByZXR1cm4gbmV4dFZlcnRleFxuICB9XG5cbiAgZnVuY3Rpb24gZXh0cmFjdEN5Y2xlKHYsIGRpcikge1xuICAgIHZhciBlMCA9IGFkaltkaXJdW3ZdWzBdXG4gICAgdmFyIGN5Y2xlID0gW3ZdXG4gICAgY3V0KGUwLCBkaXIpXG4gICAgdmFyIHUgPSBlMFtkaXJeMV1cbiAgICB2YXIgZDAgPSBkaXJcbiAgICB3aGlsZSh0cnVlKSB7XG4gICAgICB3aGlsZSh1ICE9PSB2KSB7XG4gICAgICAgIGN5Y2xlLnB1c2godSlcbiAgICAgICAgdSA9IG5leHQoY3ljbGVbY3ljbGUubGVuZ3RoLTJdLCB1LCBmYWxzZSlcbiAgICAgIH1cbiAgICAgIGlmKGFkalswXVt2XS5sZW5ndGggKyBhZGpbMV1bdl0ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICB2YXIgYSA9IGN5Y2xlW2N5Y2xlLmxlbmd0aC0xXVxuICAgICAgdmFyIGIgPSB2XG4gICAgICB2YXIgYyA9IGN5Y2xlWzFdXG4gICAgICB2YXIgZCA9IG5leHQoYSwgYiwgdHJ1ZSlcbiAgICAgIGlmKGNvbXBhcmVBbmdsZShwb3NpdGlvbnNbYV0sIHBvc2l0aW9uc1tiXSwgcG9zaXRpb25zW2NdLCBwb3NpdGlvbnNbZF0pIDwgMCkge1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgY3ljbGUucHVzaCh2KVxuICAgICAgdSA9IG5leHQoYSwgYilcbiAgICB9XG4gICAgcmV0dXJuIGN5Y2xlXG4gIH1cblxuICBmdW5jdGlvbiBzaG91bGRHbHVlKHBjeWNsZSwgbmN5Y2xlKSB7XG4gICAgcmV0dXJuIChuY3ljbGVbMV0gPT09IG5jeWNsZVtuY3ljbGUubGVuZ3RoLTFdKVxuICB9XG5cbiAgZm9yKHZhciBpPTA7IGk8bnVtVmVydGljZXM7ICsraSkge1xuICAgIGZvcih2YXIgaj0wOyBqPDI7ICsraikge1xuICAgICAgdmFyIHBjeWNsZSA9IFtdXG4gICAgICB3aGlsZShhZGpbal1baV0ubGVuZ3RoID4gMCkge1xuICAgICAgICB2YXIgbmkgPSBhZGpbMF1baV0ubGVuZ3RoXG4gICAgICAgIHZhciBuY3ljbGUgPSBleHRyYWN0Q3ljbGUoaSxqKVxuICAgICAgICBpZihzaG91bGRHbHVlKHBjeWNsZSwgbmN5Y2xlKSkge1xuICAgICAgICAgIC8vR2x1ZSB0b2dldGhlciB0cml2aWFsIGN5Y2xlc1xuICAgICAgICAgIHBjeWNsZS5wdXNoLmFwcGx5KHBjeWNsZSwgbmN5Y2xlKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmKHBjeWNsZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjeWNsZXMucHVzaChwY3ljbGUpXG4gICAgICAgICAgfVxuICAgICAgICAgIHBjeWNsZSA9IG5jeWNsZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZihwY3ljbGUubGVuZ3RoID4gMCkge1xuICAgICAgICBjeWNsZXMucHVzaChwY3ljbGUpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy9Db21iaW5lIHBhdGhzIGFuZCBsb29wcyB0b2dldGhlclxuICByZXR1cm4gY3ljbGVzXG59IiwiJ3VzZSBzdHJpY3QnXG5cbm1vZHVsZS5leHBvcnRzID0gdHJpbUxlYXZlc1xuXG52YXIgZTJhID0gcmVxdWlyZSgnZWRnZXMtdG8tYWRqYWNlbmN5LWxpc3QnKVxuXG5mdW5jdGlvbiB0cmltTGVhdmVzKGVkZ2VzLCBwb3NpdGlvbnMpIHtcbiAgdmFyIGFkaiA9IGUyYShlZGdlcywgcG9zaXRpb25zLmxlbmd0aClcbiAgdmFyIGxpdmUgPSBuZXcgQXJyYXkocG9zaXRpb25zLmxlbmd0aClcbiAgdmFyIG5iaGQgPSBuZXcgQXJyYXkocG9zaXRpb25zLmxlbmd0aClcblxuICB2YXIgZGVhZCA9IFtdXG4gIGZvcih2YXIgaT0wOyBpPHBvc2l0aW9ucy5sZW5ndGg7ICsraSkge1xuICAgIHZhciBjb3VudCA9IGFkaltpXS5sZW5ndGhcbiAgICBuYmhkW2ldID0gY291bnRcbiAgICBsaXZlW2ldID0gdHJ1ZVxuICAgIGlmKGNvdW50IDw9IDEpIHtcbiAgICAgIGRlYWQucHVzaChpKVxuICAgIH1cbiAgfVxuXG4gIHdoaWxlKGRlYWQubGVuZ3RoID4gMCkge1xuICAgIHZhciB2ID0gZGVhZC5wb3AoKVxuICAgIGxpdmVbdl0gPSBmYWxzZVxuICAgIHZhciBuID0gYWRqW3ZdXG4gICAgZm9yKHZhciBpPTA7IGk8bi5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIHUgPSBuW2ldXG4gICAgICBpZigtLW5iaGRbdV0gPT09IDApIHtcbiAgICAgICAgZGVhZC5wdXNoKHUpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIG5ld0luZGV4ID0gbmV3IEFycmF5KHBvc2l0aW9ucy5sZW5ndGgpXG4gIHZhciBucG9zaXRpb25zID0gW11cbiAgZm9yKHZhciBpPTA7IGk8cG9zaXRpb25zLmxlbmd0aDsgKytpKSB7XG4gICAgaWYobGl2ZVtpXSkge1xuICAgICAgdmFyIHYgPSBucG9zaXRpb25zLmxlbmd0aFxuICAgICAgbmV3SW5kZXhbaV0gPSB2XG4gICAgICBucG9zaXRpb25zLnB1c2gocG9zaXRpb25zW2ldKVxuICAgIH0gZWxzZSB7XG4gICAgICBuZXdJbmRleFtpXSA9IC0xXG4gICAgfVxuICB9XG5cbiAgdmFyIG5lZGdlcyA9IFtdXG4gIGZvcih2YXIgaT0wOyBpPGVkZ2VzLmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGUgPSBlZGdlc1tpXVxuICAgIGlmKGxpdmVbZVswXV0gJiYgbGl2ZVtlWzFdXSkge1xuICAgICAgbmVkZ2VzLnB1c2goWyBuZXdJbmRleFtlWzBdXSwgbmV3SW5kZXhbZVsxXV0gXSlcbiAgICB9XG4gIH1cbiAgXG4gIHJldHVybiBbIG5lZGdlcywgbnBvc2l0aW9ucyBdXG59IiwiJ3VzZSBzdHJpY3QnXG5cbm1vZHVsZS5leHBvcnRzID0gcGxhbmFyR3JhcGhUb1BvbHlsaW5lXG5cbnZhciBlMmEgPSByZXF1aXJlKCdlZGdlcy10by1hZGphY2VuY3ktbGlzdCcpXG52YXIgcGxhbmFyRHVhbCA9IHJlcXVpcmUoJ3BsYW5hci1kdWFsJylcbnZhciBwcmVwcm9jZXNzUG9seWdvbiA9IHJlcXVpcmUoJ3BvaW50LWluLWJpZy1wb2x5Z29uJylcbnZhciB0d29Qcm9kdWN0ID0gcmVxdWlyZSgndHdvLXByb2R1Y3QnKVxudmFyIHJvYnVzdFN1bSA9IHJlcXVpcmUoJ3JvYnVzdC1zdW0nKVxudmFyIHVuaXEgPSByZXF1aXJlKCd1bmlxJylcbnZhciB0cmltTGVhdmVzID0gcmVxdWlyZSgnLi9saWIvdHJpbS1sZWF2ZXMnKVxuXG5mdW5jdGlvbiBtYWtlQXJyYXkobGVuZ3RoLCBmaWxsKSB7XG4gIHZhciByZXN1bHQgPSBuZXcgQXJyYXkobGVuZ3RoKVxuICBmb3IodmFyIGk9MDsgaTxsZW5ndGg7ICsraSkge1xuICAgIHJlc3VsdFtpXSA9IGZpbGxcbiAgfVxuICByZXR1cm4gcmVzdWx0XG59XG5cbmZ1bmN0aW9uIG1ha2VBcnJheU9mQXJyYXlzKGxlbmd0aCkge1xuICB2YXIgcmVzdWx0ID0gbmV3IEFycmF5KGxlbmd0aClcbiAgZm9yKHZhciBpPTA7IGk8bGVuZ3RoOyArK2kpIHtcbiAgICByZXN1bHRbaV0gPSBbXVxuICB9XG4gIHJldHVybiByZXN1bHRcbn1cblxuXG5mdW5jdGlvbiBwbGFuYXJHcmFwaFRvUG9seWxpbmUoZWRnZXMsIHBvc2l0aW9ucykge1xuXG4gIC8vVHJpbSBsZWF2ZXNcbiAgdmFyIHJlc3VsdCA9IHRyaW1MZWF2ZXMoZWRnZXMsIHBvc2l0aW9ucylcbiAgZWRnZXMgPSByZXN1bHRbMF1cbiAgcG9zaXRpb25zID0gcmVzdWx0WzFdXG5cbiAgdmFyIG51bVZlcnRpY2VzID0gcG9zaXRpb25zLmxlbmd0aFxuICB2YXIgbnVtRWRnZXMgPSBlZGdlcy5sZW5ndGhcblxuICAvL0NhbGN1bGF0ZSBhZGphY2VuY3kgbGlzdCwgY2hlY2sgbWFuaWZvbGRcbiAgdmFyIGFkaiA9IGUyYShlZGdlcywgcG9zaXRpb25zLmxlbmd0aClcbiAgZm9yKHZhciBpPTA7IGk8bnVtVmVydGljZXM7ICsraSkge1xuICAgIGlmKGFkaltpXS5sZW5ndGggJSAyID09PSAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BsYW5hci1ncmFwaC10by1wb2x5bGluZTogZ3JhcGggbXVzdCBiZSBtYW5pZm9sZCcpXG4gICAgfVxuICB9XG5cbiAgLy9HZXQgZmFjZXNcbiAgdmFyIGZhY2VzID0gcGxhbmFyRHVhbChlZGdlcywgcG9zaXRpb25zKVxuXG4gIC8vQ2hlY2sgb3JpZW50YXRpb24gb2YgYSBwb2x5Z29uIHVzaW5nIGV4YWN0IGFyaXRobWV0aWNcbiAgZnVuY3Rpb24gY2N3KGMpIHtcbiAgICB2YXIgbiA9IGMubGVuZ3RoXG4gICAgdmFyIGFyZWEgPSBbMF1cbiAgICBmb3IodmFyIGo9MDsgajxuOyArK2opIHtcbiAgICAgIHZhciBhID0gcG9zaXRpb25zW2Nbal1dXG4gICAgICB2YXIgYiA9IHBvc2l0aW9uc1tjWyhqKzEpJW5dXVxuICAgICAgdmFyIHQwMCA9IHR3b1Byb2R1Y3QoLWFbMF0sIGFbMV0pXG4gICAgICB2YXIgdDAxID0gdHdvUHJvZHVjdCgtYVswXSwgYlsxXSlcbiAgICAgIHZhciB0MTAgPSB0d29Qcm9kdWN0KCBiWzBdLCBhWzFdKVxuICAgICAgdmFyIHQxMSA9IHR3b1Byb2R1Y3QoIGJbMF0sIGJbMV0pXG4gICAgICBhcmVhID0gcm9idXN0U3VtKGFyZWEsIHJvYnVzdFN1bShyb2J1c3RTdW0odDAwLCB0MDEpLCByb2J1c3RTdW0odDEwLCB0MTEpKSlcbiAgICB9XG4gICAgcmV0dXJuIGFyZWFbYXJlYS5sZW5ndGgtMV0gPiAwXG4gIH1cblxuICAvL0V4dHJhY3QgYWxsIGNsb2Nrd2lzZSBmYWNlc1xuICBmYWNlcyA9IGZhY2VzLmZpbHRlcihjY3cpXG5cbiAgLy9EZXRlY3Qgd2hpY2ggbG9vcHMgYXJlIGNvbnRhaW5lZCBpbiBvbmUgYW5vdGhlciB0byBoYW5kbGUgcGFyZW50LW9mIHJlbGF0aW9uXG4gIHZhciBudW1GYWNlcyA9IGZhY2VzLmxlbmd0aFxuICB2YXIgcGFyZW50ID0gbmV3IEFycmF5KG51bUZhY2VzKVxuICB2YXIgY29udGFpbm1lbnQgPSBuZXcgQXJyYXkobnVtRmFjZXMpXG4gIGZvcih2YXIgaT0wOyBpPG51bUZhY2VzOyArK2kpIHtcbiAgICBwYXJlbnRbaV0gPSBpXG4gICAgdmFyIHJvdyA9IG5ldyBBcnJheShudW1GYWNlcylcbiAgICB2YXIgbG9vcFZlcnRpY2VzID0gZmFjZXNbaV0ubWFwKGZ1bmN0aW9uKHYpIHtcbiAgICAgIHJldHVybiBwb3NpdGlvbnNbdl1cbiAgICB9KVxuICAgIHZhciBwbWMgPSBwcmVwcm9jZXNzUG9seWdvbihbbG9vcFZlcnRpY2VzXSlcbiAgICB2YXIgY291bnQgPSAwXG4gICAgb3V0ZXI6XG4gICAgZm9yKHZhciBqPTA7IGo8bnVtRmFjZXM7ICsraikge1xuICAgICAgcm93W2pdID0gMFxuICAgICAgaWYoaSA9PT0gaikge1xuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuICAgICAgdmFyIGMgPSBmYWNlc1tqXVxuICAgICAgdmFyIG4gPSBjLmxlbmd0aFxuICAgICAgZm9yKHZhciBrPTA7IGs8bjsgKytrKSB7XG4gICAgICAgIHZhciBkID0gcG1jKHBvc2l0aW9uc1tjW2tdXSlcbiAgICAgICAgaWYoZCAhPT0gMCkge1xuICAgICAgICAgIGlmKGQgPCAwKSB7XG4gICAgICAgICAgICByb3dbal0gPSAxXG4gICAgICAgICAgICBjb3VudCArPSAxXG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlIG91dGVyXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJvd1tqXSA9IDFcbiAgICAgIGNvdW50ICs9IDFcbiAgICB9XG4gICAgY29udGFpbm1lbnRbaV0gPSBbY291bnQsIGksIHJvd11cbiAgfVxuICBjb250YWlubWVudC5zb3J0KGZ1bmN0aW9uKGEsYikge1xuICAgIHJldHVybiBiWzBdIC0gYVswXVxuICB9KVxuICBmb3IodmFyIGk9MDsgaTxudW1GYWNlczsgKytpKSB7XG4gICAgdmFyIHJvdyA9IGNvbnRhaW5tZW50W2ldXG4gICAgdmFyIGlkeCA9IHJvd1sxXVxuICAgIHZhciBjaGlsZHJlbiA9IHJvd1syXVxuICAgIGZvcih2YXIgaj0wOyBqPG51bUZhY2VzOyArK2opIHtcbiAgICAgIGlmKGNoaWxkcmVuW2pdKSB7XG4gICAgICAgIHBhcmVudFtqXSA9IGlkeFxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vSW5pdGlhbGl6ZSBmYWNlIGFkamFjZW5jeSBsaXN0XG4gIHZhciBmYWRqID0gbWFrZUFycmF5T2ZBcnJheXMobnVtRmFjZXMpXG4gIGZvcih2YXIgaT0wOyBpPG51bUZhY2VzOyArK2kpIHtcbiAgICBmYWRqW2ldLnB1c2gocGFyZW50W2ldKVxuICAgIGZhZGpbcGFyZW50W2ldXS5wdXNoKGkpXG4gIH1cblxuICAvL0J1aWxkIGFkamFjZW5jeSBtYXRyaXggZm9yIGVkZ2VzXG4gIHZhciBlZGdlQWRqYWNlbmN5ID0ge31cbiAgdmFyIGludGVybmFsVmVydGljZXMgPSBtYWtlQXJyYXkobnVtVmVydGljZXMsIGZhbHNlKVxuICBmb3IodmFyIGk9MDsgaTxudW1GYWNlczsgKytpKSB7XG4gICAgdmFyIGMgPSBmYWNlc1tpXVxuICAgIHZhciBuID0gYy5sZW5ndGhcbiAgICBmb3IodmFyIGo9MDsgajxuOyArK2opIHtcbiAgICAgIHZhciBhID0gY1tqXVxuICAgICAgdmFyIGIgPSBjWyhqKzEpJW5dXG4gICAgICB2YXIga2V5ID0gTWF0aC5taW4oYSxiKSArIFwiOlwiICsgTWF0aC5tYXgoYSxiKVxuICAgICAgaWYoa2V5IGluIGVkZ2VBZGphY2VuY3kpIHtcbiAgICAgICAgdmFyIG5laWdoYm9yID0gZWRnZUFkamFjZW5jeVtrZXldXG4gICAgICAgIGZhZGpbbmVpZ2hib3JdLnB1c2goaSlcbiAgICAgICAgZmFkaltpXS5wdXNoKG5laWdoYm9yKVxuICAgICAgICBpbnRlcm5hbFZlcnRpY2VzW2FdID0gaW50ZXJuYWxWZXJ0aWNlc1tiXSA9IHRydWVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVkZ2VBZGphY2VuY3lba2V5XSA9IGlcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzaGFyZWRCb3VuZGFyeShjKSB7XG4gICAgdmFyIG4gPSBjLmxlbmd0aFxuICAgIGZvcih2YXIgaT0wOyBpPG47ICsraSkge1xuICAgICAgaWYoIWludGVybmFsVmVydGljZXNbY1tpXV0pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICB2YXIgdG9WaXNpdCA9IFtdXG4gIHZhciBwYXJpdHkgPSBtYWtlQXJyYXkobnVtRmFjZXMsIC0xKVxuICBmb3IodmFyIGk9MDsgaTxudW1GYWNlczsgKytpKSB7XG4gICAgaWYocGFyZW50W2ldID09PSBpICYmICFzaGFyZWRCb3VuZGFyeShmYWNlc1tpXSkpIHtcbiAgICAgIHRvVmlzaXQucHVzaChpKVxuICAgICAgcGFyaXR5W2ldID0gMFxuICAgIH0gZWxzZSB7XG4gICAgICBwYXJpdHlbaV0gPSAtMVxuICAgIH1cbiAgfVxuXG4gIC8vVXNpbmcgZmFjZSBhZGphY2VuY3ksIGNsYXNzaWZ5IGZhY2VzIGFzIGluL291dFxuICB2YXIgcmVzdWx0ID0gW11cbiAgd2hpbGUodG9WaXNpdC5sZW5ndGggPiAwKSB7XG4gICAgdmFyIHRvcCA9IHRvVmlzaXQucG9wKClcbiAgICB2YXIgbmJoZCA9IGZhZGpbdG9wXVxuICAgIHVuaXEobmJoZCwgZnVuY3Rpb24oYSxiKSB7XG4gICAgICByZXR1cm4gYS1iXG4gICAgfSlcbiAgICB2YXIgbm5iaHIgPSBuYmhkLmxlbmd0aFxuICAgIHZhciBwID0gcGFyaXR5W3RvcF1cbiAgICB2YXIgcG9seWxpbmVcbiAgICBpZihwID09PSAwKSB7XG4gICAgICB2YXIgYyA9IGZhY2VzW3RvcF1cbiAgICAgIHBvbHlsaW5lID0gW2NdXG4gICAgfVxuICAgIGZvcih2YXIgaT0wOyBpPG5uYmhyOyArK2kpIHtcbiAgICAgIHZhciBmID0gbmJoZFtpXVxuICAgICAgaWYocGFyaXR5W2ZdID49IDApIHtcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cbiAgICAgIHBhcml0eVtmXSA9IHBeMVxuICAgICAgdG9WaXNpdC5wdXNoKGYpXG4gICAgICBpZihwID09PSAwKSB7XG4gICAgICAgIHZhciBjID0gZmFjZXNbZl1cbiAgICAgICAgaWYoIXNoYXJlZEJvdW5kYXJ5KGMpKSB7XG4gICAgICAgICAgYy5yZXZlcnNlKClcbiAgICAgICAgICBwb2x5bGluZS5wdXNoKGMpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYocCA9PT0gMCkge1xuICAgICAgcmVzdWx0LnB1c2gocG9seWxpbmUpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdFxufSIsIm1vZHVsZS5leHBvcnRzID0gcHJlcHJvY2Vzc1BvbHlnb25cblxudmFyIG9yaWVudCA9IHJlcXVpcmUoJ3JvYnVzdC1vcmllbnRhdGlvbicpWzNdXG52YXIgbWFrZVNsYWJzID0gcmVxdWlyZSgnc2xhYi1kZWNvbXBvc2l0aW9uJylcbnZhciBtYWtlSW50ZXJ2YWxUcmVlID0gcmVxdWlyZSgnaW50ZXJ2YWwtdHJlZS0xZCcpXG52YXIgYnNlYXJjaCA9IHJlcXVpcmUoJ2JpbmFyeS1zZWFyY2gtYm91bmRzJylcblxuZnVuY3Rpb24gdmlzaXRJbnRlcnZhbCgpIHtcbiAgcmV0dXJuIHRydWVcbn1cblxuZnVuY3Rpb24gaW50ZXJ2YWxTZWFyY2godGFibGUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHgsIHkpIHtcbiAgICB2YXIgdHJlZSA9IHRhYmxlW3hdXG4gICAgaWYodHJlZSkge1xuICAgICAgcmV0dXJuICEhdHJlZS5xdWVyeVBvaW50KHksIHZpc2l0SW50ZXJ2YWwpXG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbmZ1bmN0aW9uIGJ1aWxkVmVydGljYWxJbmRleChzZWdtZW50cykge1xuICB2YXIgdGFibGUgPSB7fVxuICBmb3IodmFyIGk9MDsgaTxzZWdtZW50cy5sZW5ndGg7ICsraSkge1xuICAgIHZhciBzID0gc2VnbWVudHNbaV1cbiAgICB2YXIgeCA9IHNbMF1bMF1cbiAgICB2YXIgeTAgPSBzWzBdWzFdXG4gICAgdmFyIHkxID0gc1sxXVsxXVxuICAgIHZhciBwID0gWyBNYXRoLm1pbih5MCwgeTEpLCBNYXRoLm1heCh5MCwgeTEpIF1cbiAgICBpZih4IGluIHRhYmxlKSB7XG4gICAgICB0YWJsZVt4XS5wdXNoKHApXG4gICAgfSBlbHNlIHtcbiAgICAgIHRhYmxlW3hdID0gWyBwIF1cbiAgICB9XG4gIH1cbiAgdmFyIGludGVydmFsVGFibGUgPSB7fVxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHRhYmxlKVxuICBmb3IodmFyIGk9MDsgaTxrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIHNlZ3MgPSB0YWJsZVtrZXlzW2ldXVxuICAgIGludGVydmFsVGFibGVba2V5c1tpXV0gPSBtYWtlSW50ZXJ2YWxUcmVlKHNlZ3MpXG4gIH1cbiAgcmV0dXJuIGludGVydmFsU2VhcmNoKGludGVydmFsVGFibGUpXG59XG5cbmZ1bmN0aW9uIGJ1aWxkU2xhYlNlYXJjaChzbGFicywgY29vcmRpbmF0ZXMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHApIHtcbiAgICB2YXIgYnVja2V0ID0gYnNlYXJjaC5sZShjb29yZGluYXRlcywgcFswXSlcbiAgICBpZihidWNrZXQgPCAwKSB7XG4gICAgICByZXR1cm4gMVxuICAgIH1cbiAgICB2YXIgcm9vdCA9IHNsYWJzW2J1Y2tldF1cbiAgICBpZighcm9vdCkge1xuICAgICAgaWYoYnVja2V0ID4gMCAmJiBjb29yZGluYXRlc1tidWNrZXRdID09PSBwWzBdKSB7XG4gICAgICAgIHJvb3QgPSBzbGFic1tidWNrZXQtMV1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAxXG4gICAgICB9XG4gICAgfVxuICAgIHZhciBsYXN0T3JpZW50YXRpb24gPSAxXG4gICAgd2hpbGUocm9vdCkge1xuICAgICAgdmFyIHMgPSByb290LmtleVxuICAgICAgdmFyIG8gPSBvcmllbnQocCwgc1swXSwgc1sxXSlcbiAgICAgIGlmKHNbMF1bMF0gPCBzWzFdWzBdKSB7XG4gICAgICAgIGlmKG8gPCAwKSB7XG4gICAgICAgICAgcm9vdCA9IHJvb3QubGVmdFxuICAgICAgICB9IGVsc2UgaWYobyA+IDApIHtcbiAgICAgICAgICBsYXN0T3JpZW50YXRpb24gPSAtMVxuICAgICAgICAgIHJvb3QgPSByb290LnJpZ2h0XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIDBcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYobyA+IDApIHtcbiAgICAgICAgICByb290ID0gcm9vdC5sZWZ0XG4gICAgICAgIH0gZWxzZSBpZihvIDwgMCkge1xuICAgICAgICAgIGxhc3RPcmllbnRhdGlvbiA9IDFcbiAgICAgICAgICByb290ID0gcm9vdC5yaWdodFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiAwXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGxhc3RPcmllbnRhdGlvblxuICB9XG59XG5cbmZ1bmN0aW9uIGNsYXNzaWZ5RW1wdHkocCkge1xuICByZXR1cm4gMVxufVxuXG5mdW5jdGlvbiBjcmVhdGVDbGFzc2lmeVZlcnRpY2FsKHRlc3RWZXJ0aWNhbCkge1xuICByZXR1cm4gZnVuY3Rpb24gY2xhc3NpZnkocCkge1xuICAgIGlmKHRlc3RWZXJ0aWNhbChwWzBdLCBwWzFdKSkge1xuICAgICAgcmV0dXJuIDBcbiAgICB9XG4gICAgcmV0dXJuIDFcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVDbGFzc2lmeVBvaW50RGVnZW4odGVzdFZlcnRpY2FsLCB0ZXN0Tm9ybWFsKSB7XG4gIHJldHVybiBmdW5jdGlvbiBjbGFzc2lmeShwKSB7XG4gICAgaWYodGVzdFZlcnRpY2FsKHBbMF0sIHBbMV0pKSB7XG4gICAgICByZXR1cm4gMFxuICAgIH1cbiAgICByZXR1cm4gdGVzdE5vcm1hbChwKVxuICB9XG59XG5cbmZ1bmN0aW9uIHByZXByb2Nlc3NQb2x5Z29uKGxvb3BzKSB7XG4gIC8vQ29tcHV0ZSBudW1iZXIgb2YgbG9vcHNcbiAgdmFyIG51bUxvb3BzID0gbG9vcHMubGVuZ3RoXG5cbiAgLy9VbnBhY2sgc2VnbWVudHNcbiAgdmFyIHNlZ21lbnRzID0gW11cbiAgdmFyIHZzZWdtZW50cyA9IFtdXG4gIHZhciBwdHIgPSAwXG4gIGZvcih2YXIgaT0wOyBpPG51bUxvb3BzOyArK2kpIHtcbiAgICB2YXIgbG9vcCA9IGxvb3BzW2ldXG4gICAgdmFyIG51bVZlcnRpY2VzID0gbG9vcC5sZW5ndGhcbiAgICBmb3IodmFyIHM9bnVtVmVydGljZXMtMSx0PTA7IHQ8bnVtVmVydGljZXM7IHM9KHQrKykpIHtcbiAgICAgIHZhciBhID0gbG9vcFtzXVxuICAgICAgdmFyIGIgPSBsb29wW3RdXG4gICAgICBpZihhWzBdID09PSBiWzBdKSB7XG4gICAgICAgIHZzZWdtZW50cy5wdXNoKFthLGJdKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VnbWVudHMucHVzaChbYSxiXSlcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvL0RlZ2VuZXJhdGUgY2FzZTogQWxsIGxvb3BzIGFyZSBlbXB0eVxuICBpZihzZWdtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICBpZih2c2VnbWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gY2xhc3NpZnlFbXB0eVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gY3JlYXRlQ2xhc3NpZnlWZXJ0aWNhbChidWlsZFZlcnRpY2FsSW5kZXgodnNlZ21lbnRzKSlcbiAgICB9XG4gIH1cblxuICAvL0J1aWxkIHNsYWIgZGVjb21wb3NpdGlvblxuICB2YXIgc2xhYnMgPSBtYWtlU2xhYnMoc2VnbWVudHMpXG4gIHZhciB0ZXN0U2xhYiA9IGJ1aWxkU2xhYlNlYXJjaChzbGFicy5zbGFicywgc2xhYnMuY29vcmRpbmF0ZXMpXG5cbiAgaWYodnNlZ21lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiB0ZXN0U2xhYlxuICB9IGVsc2Uge1xuICAgIHJldHVybiBjcmVhdGVDbGFzc2lmeVBvaW50RGVnZW4oXG4gICAgICBidWlsZFZlcnRpY2FsSW5kZXgodnNlZ21lbnRzKSxcbiAgICAgIHRlc3RTbGFiKVxuICB9XG59IiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcblxucHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW10gfVxuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcbiIsInZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcbnZhciBub3cgPSByZXF1aXJlKCdyaWdodC1ub3cnKVxudmFyIHJhZiA9IHJlcXVpcmUoJ3JhZicpXG5cbm1vZHVsZS5leHBvcnRzID0gRW5naW5lXG5mdW5jdGlvbiBFbmdpbmUoZm4pIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgRW5naW5lKSkgXG4gICAgICAgIHJldHVybiBuZXcgRW5naW5lKGZuKVxuICAgIHRoaXMucnVubmluZyA9IGZhbHNlXG4gICAgdGhpcy5sYXN0ID0gbm93KClcbiAgICB0aGlzLl9mcmFtZSA9IDBcbiAgICB0aGlzLl90aWNrID0gdGhpcy50aWNrLmJpbmQodGhpcylcblxuICAgIGlmIChmbilcbiAgICAgICAgdGhpcy5vbigndGljaycsIGZuKVxufVxuXG5pbmhlcml0cyhFbmdpbmUsIEV2ZW50RW1pdHRlcilcblxuRW5naW5lLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLnJ1bm5pbmcpIFxuICAgICAgICByZXR1cm5cbiAgICB0aGlzLnJ1bm5pbmcgPSB0cnVlXG4gICAgdGhpcy5sYXN0ID0gbm93KClcbiAgICB0aGlzLl9mcmFtZSA9IHJhZih0aGlzLl90aWNrKVxuICAgIHJldHVybiB0aGlzXG59XG5cbkVuZ2luZS5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMucnVubmluZyA9IGZhbHNlXG4gICAgaWYgKHRoaXMuX2ZyYW1lICE9PSAwKVxuICAgICAgICByYWYuY2FuY2VsKHRoaXMuX2ZyYW1lKVxuICAgIHRoaXMuX2ZyYW1lID0gMFxuICAgIHJldHVybiB0aGlzXG59XG5cbkVuZ2luZS5wcm90b3R5cGUudGljayA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2ZyYW1lID0gcmFmKHRoaXMuX3RpY2spXG4gICAgdmFyIHRpbWUgPSBub3coKVxuICAgIHZhciBkdCA9IHRpbWUgLSB0aGlzLmxhc3RcbiAgICB0aGlzLmVtaXQoJ3RpY2snLCBkdClcbiAgICB0aGlzLmxhc3QgPSB0aW1lXG59IiwidmFyIG5vdyA9IHJlcXVpcmUoJ3BlcmZvcm1hbmNlLW5vdycpXG4gICwgcm9vdCA9IHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnID8gZ2xvYmFsIDogd2luZG93XG4gICwgdmVuZG9ycyA9IFsnbW96JywgJ3dlYmtpdCddXG4gICwgc3VmZml4ID0gJ0FuaW1hdGlvbkZyYW1lJ1xuICAsIHJhZiA9IHJvb3RbJ3JlcXVlc3QnICsgc3VmZml4XVxuICAsIGNhZiA9IHJvb3RbJ2NhbmNlbCcgKyBzdWZmaXhdIHx8IHJvb3RbJ2NhbmNlbFJlcXVlc3QnICsgc3VmZml4XVxuXG5mb3IodmFyIGkgPSAwOyAhcmFmICYmIGkgPCB2ZW5kb3JzLmxlbmd0aDsgaSsrKSB7XG4gIHJhZiA9IHJvb3RbdmVuZG9yc1tpXSArICdSZXF1ZXN0JyArIHN1ZmZpeF1cbiAgY2FmID0gcm9vdFt2ZW5kb3JzW2ldICsgJ0NhbmNlbCcgKyBzdWZmaXhdXG4gICAgICB8fCByb290W3ZlbmRvcnNbaV0gKyAnQ2FuY2VsUmVxdWVzdCcgKyBzdWZmaXhdXG59XG5cbi8vIFNvbWUgdmVyc2lvbnMgb2YgRkYgaGF2ZSByQUYgYnV0IG5vdCBjQUZcbmlmKCFyYWYgfHwgIWNhZikge1xuICB2YXIgbGFzdCA9IDBcbiAgICAsIGlkID0gMFxuICAgICwgcXVldWUgPSBbXVxuICAgICwgZnJhbWVEdXJhdGlvbiA9IDEwMDAgLyA2MFxuXG4gIHJhZiA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgaWYocXVldWUubGVuZ3RoID09PSAwKSB7XG4gICAgICB2YXIgX25vdyA9IG5vdygpXG4gICAgICAgICwgbmV4dCA9IE1hdGgubWF4KDAsIGZyYW1lRHVyYXRpb24gLSAoX25vdyAtIGxhc3QpKVxuICAgICAgbGFzdCA9IG5leHQgKyBfbm93XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY3AgPSBxdWV1ZS5zbGljZSgwKVxuICAgICAgICAvLyBDbGVhciBxdWV1ZSBoZXJlIHRvIHByZXZlbnRcbiAgICAgICAgLy8gY2FsbGJhY2tzIGZyb20gYXBwZW5kaW5nIGxpc3RlbmVyc1xuICAgICAgICAvLyB0byB0aGUgY3VycmVudCBmcmFtZSdzIHF1ZXVlXG4gICAgICAgIHF1ZXVlLmxlbmd0aCA9IDBcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGNwLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYoIWNwW2ldLmNhbmNlbGxlZCkge1xuICAgICAgICAgICAgdHJ5e1xuICAgICAgICAgICAgICBjcFtpXS5jYWxsYmFjayhsYXN0KVxuICAgICAgICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IHRocm93IGUgfSwgMClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIE1hdGgucm91bmQobmV4dCkpXG4gICAgfVxuICAgIHF1ZXVlLnB1c2goe1xuICAgICAgaGFuZGxlOiArK2lkLFxuICAgICAgY2FsbGJhY2s6IGNhbGxiYWNrLFxuICAgICAgY2FuY2VsbGVkOiBmYWxzZVxuICAgIH0pXG4gICAgcmV0dXJuIGlkXG4gIH1cblxuICBjYWYgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmKHF1ZXVlW2ldLmhhbmRsZSA9PT0gaGFuZGxlKSB7XG4gICAgICAgIHF1ZXVlW2ldLmNhbmNlbGxlZCA9IHRydWVcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihmbikge1xuICAvLyBXcmFwIGluIGEgbmV3IGZ1bmN0aW9uIHRvIHByZXZlbnRcbiAgLy8gYGNhbmNlbGAgcG90ZW50aWFsbHkgYmVpbmcgYXNzaWduZWRcbiAgLy8gdG8gdGhlIG5hdGl2ZSByQUYgZnVuY3Rpb25cbiAgcmV0dXJuIHJhZi5jYWxsKHJvb3QsIGZuKVxufVxubW9kdWxlLmV4cG9ydHMuY2FuY2VsID0gZnVuY3Rpb24oKSB7XG4gIGNhZi5hcHBseShyb290LCBhcmd1bWVudHMpXG59XG5tb2R1bGUuZXhwb3J0cy5wb2x5ZmlsbCA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICBpZiAoIW9iamVjdCkge1xuICAgIG9iamVjdCA9IHJvb3Q7XG4gIH1cbiAgb2JqZWN0LnJlcXVlc3RBbmltYXRpb25GcmFtZSA9IHJhZlxuICBvYmplY3QuY2FuY2VsQW5pbWF0aW9uRnJhbWUgPSBjYWZcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG52YXIgYm5hZGQgPSByZXF1aXJlKCdiaWctcmF0L2FkZCcpXG5cbm1vZHVsZS5leHBvcnRzID0gYWRkXG5cbmZ1bmN0aW9uIGFkZCAoYSwgYikge1xuICB2YXIgbiA9IGEubGVuZ3RoXG4gIHZhciByID0gbmV3IEFycmF5KG4pXG4gIGZvciAodmFyIGk9MDsgaTxuOyArK2kpIHtcbiAgICByW2ldID0gYm5hZGQoYVtpXSwgYltpXSlcbiAgfVxuICByZXR1cm4gclxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbm1vZHVsZS5leHBvcnRzID0gZmxvYXQycmF0XG5cbnZhciByYXQgPSByZXF1aXJlKCdiaWctcmF0JylcblxuZnVuY3Rpb24gZmxvYXQycmF0KHYpIHtcbiAgdmFyIHJlc3VsdCA9IG5ldyBBcnJheSh2Lmxlbmd0aClcbiAgZm9yKHZhciBpPTA7IGk8di5sZW5ndGg7ICsraSkge1xuICAgIHJlc3VsdFtpXSA9IHJhdCh2W2ldKVxuICB9XG4gIHJldHVybiByZXN1bHRcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG52YXIgcmF0ID0gcmVxdWlyZSgnYmlnLXJhdCcpXG52YXIgbXVsID0gcmVxdWlyZSgnYmlnLXJhdC9tdWwnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IG11bHNcblxuZnVuY3Rpb24gbXVscyhhLCB4KSB7XG4gIHZhciBzID0gcmF0KHgpXG4gIHZhciBuID0gYS5sZW5ndGhcbiAgdmFyIHIgPSBuZXcgQXJyYXkobilcbiAgZm9yKHZhciBpPTA7IGk8bjsgKytpKSB7XG4gICAgcltpXSA9IG11bChhW2ldLCBzKVxuICB9XG4gIHJldHVybiByXG59XG4iLCIndXNlIHN0cmljdCdcblxudmFyIGJuc3ViID0gcmVxdWlyZSgnYmlnLXJhdC9zdWInKVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN1YlxuXG5mdW5jdGlvbiBzdWIoYSwgYikge1xuICB2YXIgbiA9IGEubGVuZ3RoXG4gIHZhciByID0gbmV3IEFycmF5KG4pXG4gICAgZm9yKHZhciBpPTA7IGk8bjsgKytpKSB7XG4gICAgcltpXSA9IGJuc3ViKGFbaV0sIGJbaV0pXG4gIH1cbiAgcmV0dXJuIHJcbn1cbiIsIihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCkgOlxuICAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShmYWN0b3J5KSA6XG4gICAgKGdsb2JhbC5jcmVhdGVSRUdMID0gZmFjdG9yeSgpKTtcbn0odGhpcywgKGZ1bmN0aW9uICgpIHsgJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXNUeXBlZEFycmF5ID0gZnVuY3Rpb24gKHgpIHtcbiAgcmV0dXJuIChcbiAgICB4IGluc3RhbmNlb2YgVWludDhBcnJheSB8fFxuICAgIHggaW5zdGFuY2VvZiBVaW50MTZBcnJheSB8fFxuICAgIHggaW5zdGFuY2VvZiBVaW50MzJBcnJheSB8fFxuICAgIHggaW5zdGFuY2VvZiBJbnQ4QXJyYXkgfHxcbiAgICB4IGluc3RhbmNlb2YgSW50MTZBcnJheSB8fFxuICAgIHggaW5zdGFuY2VvZiBJbnQzMkFycmF5IHx8XG4gICAgeCBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheSB8fFxuICAgIHggaW5zdGFuY2VvZiBGbG9hdDY0QXJyYXkgfHxcbiAgICB4IGluc3RhbmNlb2YgVWludDhDbGFtcGVkQXJyYXlcbiAgKVxufVxuXG52YXIgZXh0ZW5kID0gZnVuY3Rpb24gKGJhc2UsIG9wdHMpIHtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvcHRzKVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICBiYXNlW2tleXNbaV1dID0gb3B0c1trZXlzW2ldXVxuICB9XG4gIHJldHVybiBiYXNlXG59XG5cbi8vIEVycm9yIGNoZWNraW5nIGFuZCBwYXJhbWV0ZXIgdmFsaWRhdGlvbi5cbi8vXG4vLyBTdGF0ZW1lbnRzIGZvciB0aGUgZm9ybSBgY2hlY2suc29tZVByb2NlZHVyZSguLi4pYCBnZXQgcmVtb3ZlZCBieVxuLy8gYSBicm93c2VyaWZ5IHRyYW5zZm9ybSBmb3Igb3B0aW1pemVkL21pbmlmaWVkIGJ1bmRsZXMuXG4vL1xuLyogZ2xvYmFscyBhdG9iICovXG52YXIgZW5kbCA9ICdcXG4nXG5cbi8vIG9ubHkgdXNlZCBmb3IgZXh0cmFjdGluZyBzaGFkZXIgbmFtZXMuICBpZiBhdG9iIG5vdCBwcmVzZW50LCB0aGVuIGVycm9yc1xuLy8gd2lsbCBiZSBzbGlnaHRseSBjcmFwcGllclxuZnVuY3Rpb24gZGVjb2RlQjY0IChzdHIpIHtcbiAgaWYgKHR5cGVvZiBhdG9iICE9PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBhdG9iKHN0cilcbiAgfVxuICByZXR1cm4gJ2Jhc2U2NDonICsgc3RyXG59XG5cbmZ1bmN0aW9uIHJhaXNlIChtZXNzYWdlKSB7XG4gIHZhciBlcnJvciA9IG5ldyBFcnJvcignKHJlZ2wpICcgKyBtZXNzYWdlKVxuICBjb25zb2xlLmVycm9yKGVycm9yKVxuICB0aHJvdyBlcnJvclxufVxuXG5mdW5jdGlvbiBjaGVjayAocHJlZCwgbWVzc2FnZSkge1xuICBpZiAoIXByZWQpIHtcbiAgICByYWlzZShtZXNzYWdlKVxuICB9XG59XG5cbmZ1bmN0aW9uIGVuY29sb24gKG1lc3NhZ2UpIHtcbiAgaWYgKG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gJzogJyArIG1lc3NhZ2VcbiAgfVxuICByZXR1cm4gJydcbn1cblxuZnVuY3Rpb24gY2hlY2tQYXJhbWV0ZXIgKHBhcmFtLCBwb3NzaWJpbGl0aWVzLCBtZXNzYWdlKSB7XG4gIGlmICghKHBhcmFtIGluIHBvc3NpYmlsaXRpZXMpKSB7XG4gICAgcmFpc2UoJ3Vua25vd24gcGFyYW1ldGVyICgnICsgcGFyYW0gKyAnKScgKyBlbmNvbG9uKG1lc3NhZ2UpICtcbiAgICAgICAgICAnLiBwb3NzaWJsZSB2YWx1ZXM6ICcgKyBPYmplY3Qua2V5cyhwb3NzaWJpbGl0aWVzKS5qb2luKCkpXG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tJc1R5cGVkQXJyYXkgKGRhdGEsIG1lc3NhZ2UpIHtcbiAgaWYgKCFpc1R5cGVkQXJyYXkoZGF0YSkpIHtcbiAgICByYWlzZShcbiAgICAgICdpbnZhbGlkIHBhcmFtZXRlciB0eXBlJyArIGVuY29sb24obWVzc2FnZSkgK1xuICAgICAgJy4gbXVzdCBiZSBhIHR5cGVkIGFycmF5JylcbiAgfVxufVxuXG5mdW5jdGlvbiBzdGFuZGFyZFR5cGVFaCAodmFsdWUsIHR5cGUpIHtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAnbnVtYmVyJzogcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcidcbiAgICBjYXNlICdvYmplY3QnOiByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0J1xuICAgIGNhc2UgJ3N0cmluZyc6IHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnXG4gICAgY2FzZSAnYm9vbGVhbic6IHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJ1xuICAgIGNhc2UgJ2Z1bmN0aW9uJzogcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJ1xuICAgIGNhc2UgJ3VuZGVmaW5lZCc6IHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnXG4gICAgY2FzZSAnc3ltYm9sJzogcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N5bWJvbCdcbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja1R5cGVPZiAodmFsdWUsIHR5cGUsIG1lc3NhZ2UpIHtcbiAgaWYgKCFzdGFuZGFyZFR5cGVFaCh2YWx1ZSwgdHlwZSkpIHtcbiAgICByYWlzZShcbiAgICAgICdpbnZhbGlkIHBhcmFtZXRlciB0eXBlJyArIGVuY29sb24obWVzc2FnZSkgK1xuICAgICAgJy4gZXhwZWN0ZWQgJyArIHR5cGUgKyAnLCBnb3QgJyArICh0eXBlb2YgdmFsdWUpKVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrTm9uTmVnYXRpdmVJbnQgKHZhbHVlLCBtZXNzYWdlKSB7XG4gIGlmICghKCh2YWx1ZSA+PSAwKSAmJlxuICAgICAgICAoKHZhbHVlIHwgMCkgPT09IHZhbHVlKSkpIHtcbiAgICByYWlzZSgnaW52YWxpZCBwYXJhbWV0ZXIgdHlwZSwgKCcgKyB2YWx1ZSArICcpJyArIGVuY29sb24obWVzc2FnZSkgK1xuICAgICAgICAgICcuIG11c3QgYmUgYSBub25uZWdhdGl2ZSBpbnRlZ2VyJylcbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja09uZU9mICh2YWx1ZSwgbGlzdCwgbWVzc2FnZSkge1xuICBpZiAobGlzdC5pbmRleE9mKHZhbHVlKSA8IDApIHtcbiAgICByYWlzZSgnaW52YWxpZCB2YWx1ZScgKyBlbmNvbG9uKG1lc3NhZ2UpICsgJy4gbXVzdCBiZSBvbmUgb2Y6ICcgKyBsaXN0KVxuICB9XG59XG5cbnZhciBjb25zdHJ1Y3RvcktleXMgPSBbXG4gICdnbCcsXG4gICdjYW52YXMnLFxuICAnY29udGFpbmVyJyxcbiAgJ2F0dHJpYnV0ZXMnLFxuICAncGl4ZWxSYXRpbycsXG4gICdleHRlbnNpb25zJyxcbiAgJ29wdGlvbmFsRXh0ZW5zaW9ucycsXG4gICdwcm9maWxlJyxcbiAgJ29uRG9uZSdcbl1cblxuZnVuY3Rpb24gY2hlY2tDb25zdHJ1Y3RvciAob2JqKSB7XG4gIE9iamVjdC5rZXlzKG9iaikuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgaWYgKGNvbnN0cnVjdG9yS2V5cy5pbmRleE9mKGtleSkgPCAwKSB7XG4gICAgICByYWlzZSgnaW52YWxpZCByZWdsIGNvbnN0cnVjdG9yIGFyZ3VtZW50IFwiJyArIGtleSArICdcIi4gbXVzdCBiZSBvbmUgb2YgJyArIGNvbnN0cnVjdG9yS2V5cylcbiAgICB9XG4gIH0pXG59XG5cbmZ1bmN0aW9uIGxlZnRQYWQgKHN0ciwgbikge1xuICBzdHIgPSBzdHIgKyAnJ1xuICB3aGlsZSAoc3RyLmxlbmd0aCA8IG4pIHtcbiAgICBzdHIgPSAnICcgKyBzdHJcbiAgfVxuICByZXR1cm4gc3RyXG59XG5cbmZ1bmN0aW9uIFNoYWRlckZpbGUgKCkge1xuICB0aGlzLm5hbWUgPSAndW5rbm93bidcbiAgdGhpcy5saW5lcyA9IFtdXG4gIHRoaXMuaW5kZXggPSB7fVxuICB0aGlzLmhhc0Vycm9ycyA9IGZhbHNlXG59XG5cbmZ1bmN0aW9uIFNoYWRlckxpbmUgKG51bWJlciwgbGluZSkge1xuICB0aGlzLm51bWJlciA9IG51bWJlclxuICB0aGlzLmxpbmUgPSBsaW5lXG4gIHRoaXMuZXJyb3JzID0gW11cbn1cblxuZnVuY3Rpb24gU2hhZGVyRXJyb3IgKGZpbGVOdW1iZXIsIGxpbmVOdW1iZXIsIG1lc3NhZ2UpIHtcbiAgdGhpcy5maWxlID0gZmlsZU51bWJlclxuICB0aGlzLmxpbmUgPSBsaW5lTnVtYmVyXG4gIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2Vcbn1cblxuZnVuY3Rpb24gZ3Vlc3NDb21tYW5kICgpIHtcbiAgdmFyIGVycm9yID0gbmV3IEVycm9yKClcbiAgdmFyIHN0YWNrID0gKGVycm9yLnN0YWNrIHx8IGVycm9yKS50b1N0cmluZygpXG4gIHZhciBwYXQgPSAvY29tcGlsZVByb2NlZHVyZS4qXFxuXFxzKmF0LipcXCgoLiopXFwpLy5leGVjKHN0YWNrKVxuICBpZiAocGF0KSB7XG4gICAgcmV0dXJuIHBhdFsxXVxuICB9XG4gIHZhciBwYXQyID0gL2NvbXBpbGVQcm9jZWR1cmUuKlxcblxccyphdFxccysoLiopKFxcbnwkKS8uZXhlYyhzdGFjaylcbiAgaWYgKHBhdDIpIHtcbiAgICByZXR1cm4gcGF0MlsxXVxuICB9XG4gIHJldHVybiAndW5rbm93bidcbn1cblxuZnVuY3Rpb24gZ3Vlc3NDYWxsU2l0ZSAoKSB7XG4gIHZhciBlcnJvciA9IG5ldyBFcnJvcigpXG4gIHZhciBzdGFjayA9IChlcnJvci5zdGFjayB8fCBlcnJvcikudG9TdHJpbmcoKVxuICB2YXIgcGF0ID0gL2F0IFJFR0xDb21tYW5kLipcXG5cXHMrYXQuKlxcKCguKilcXCkvLmV4ZWMoc3RhY2spXG4gIGlmIChwYXQpIHtcbiAgICByZXR1cm4gcGF0WzFdXG4gIH1cbiAgdmFyIHBhdDIgPSAvYXQgUkVHTENvbW1hbmQuKlxcblxccythdFxccysoLiopXFxuLy5leGVjKHN0YWNrKVxuICBpZiAocGF0Mikge1xuICAgIHJldHVybiBwYXQyWzFdXG4gIH1cbiAgcmV0dXJuICd1bmtub3duJ1xufVxuXG5mdW5jdGlvbiBwYXJzZVNvdXJjZSAoc291cmNlLCBjb21tYW5kKSB7XG4gIHZhciBsaW5lcyA9IHNvdXJjZS5zcGxpdCgnXFxuJylcbiAgdmFyIGxpbmVOdW1iZXIgPSAxXG4gIHZhciBmaWxlTnVtYmVyID0gMFxuICB2YXIgZmlsZXMgPSB7XG4gICAgdW5rbm93bjogbmV3IFNoYWRlckZpbGUoKSxcbiAgICAwOiBuZXcgU2hhZGVyRmlsZSgpXG4gIH1cbiAgZmlsZXMudW5rbm93bi5uYW1lID0gZmlsZXNbMF0ubmFtZSA9IGNvbW1hbmQgfHwgZ3Vlc3NDb21tYW5kKClcbiAgZmlsZXMudW5rbm93bi5saW5lcy5wdXNoKG5ldyBTaGFkZXJMaW5lKDAsICcnKSlcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7ICsraSkge1xuICAgIHZhciBsaW5lID0gbGluZXNbaV1cbiAgICB2YXIgcGFydHMgPSAvXlxccyojXFxzKihcXHcrKVxccysoLispXFxzKiQvLmV4ZWMobGluZSlcbiAgICBpZiAocGFydHMpIHtcbiAgICAgIHN3aXRjaCAocGFydHNbMV0pIHtcbiAgICAgICAgY2FzZSAnbGluZSc6XG4gICAgICAgICAgdmFyIGxpbmVOdW1iZXJJbmZvID0gLyhcXGQrKShcXHMrXFxkKyk/Ly5leGVjKHBhcnRzWzJdKVxuICAgICAgICAgIGlmIChsaW5lTnVtYmVySW5mbykge1xuICAgICAgICAgICAgbGluZU51bWJlciA9IGxpbmVOdW1iZXJJbmZvWzFdIHwgMFxuICAgICAgICAgICAgaWYgKGxpbmVOdW1iZXJJbmZvWzJdKSB7XG4gICAgICAgICAgICAgIGZpbGVOdW1iZXIgPSBsaW5lTnVtYmVySW5mb1syXSB8IDBcbiAgICAgICAgICAgICAgaWYgKCEoZmlsZU51bWJlciBpbiBmaWxlcykpIHtcbiAgICAgICAgICAgICAgICBmaWxlc1tmaWxlTnVtYmVyXSA9IG5ldyBTaGFkZXJGaWxlKClcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlICdkZWZpbmUnOlxuICAgICAgICAgIHZhciBuYW1lSW5mbyA9IC9TSEFERVJfTkFNRShfQjY0KT9cXHMrKC4qKSQvLmV4ZWMocGFydHNbMl0pXG4gICAgICAgICAgaWYgKG5hbWVJbmZvKSB7XG4gICAgICAgICAgICBmaWxlc1tmaWxlTnVtYmVyXS5uYW1lID0gKG5hbWVJbmZvWzFdXG4gICAgICAgICAgICAgID8gZGVjb2RlQjY0KG5hbWVJbmZvWzJdKVxuICAgICAgICAgICAgICA6IG5hbWVJbmZvWzJdKVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgICBmaWxlc1tmaWxlTnVtYmVyXS5saW5lcy5wdXNoKG5ldyBTaGFkZXJMaW5lKGxpbmVOdW1iZXIrKywgbGluZSkpXG4gIH1cbiAgT2JqZWN0LmtleXMoZmlsZXMpLmZvckVhY2goZnVuY3Rpb24gKGZpbGVOdW1iZXIpIHtcbiAgICB2YXIgZmlsZSA9IGZpbGVzW2ZpbGVOdW1iZXJdXG4gICAgZmlsZS5saW5lcy5mb3JFYWNoKGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICBmaWxlLmluZGV4W2xpbmUubnVtYmVyXSA9IGxpbmVcbiAgICB9KVxuICB9KVxuICByZXR1cm4gZmlsZXNcbn1cblxuZnVuY3Rpb24gcGFyc2VFcnJvckxvZyAoZXJyTG9nKSB7XG4gIHZhciByZXN1bHQgPSBbXVxuICBlcnJMb2cuc3BsaXQoJ1xcbicpLmZvckVhY2goZnVuY3Rpb24gKGVyck1zZykge1xuICAgIGlmIChlcnJNc2cubGVuZ3RoIDwgNSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHZhciBwYXJ0cyA9IC9eRVJST1I6XFxzKyhcXGQrKTooXFxkKyk6XFxzKiguKikkLy5leGVjKGVyck1zZylcbiAgICBpZiAocGFydHMpIHtcbiAgICAgIHJlc3VsdC5wdXNoKG5ldyBTaGFkZXJFcnJvcihcbiAgICAgICAgcGFydHNbMV0gfCAwLFxuICAgICAgICBwYXJ0c1syXSB8IDAsXG4gICAgICAgIHBhcnRzWzNdLnRyaW0oKSkpXG4gICAgfSBlbHNlIGlmIChlcnJNc2cubGVuZ3RoID4gMCkge1xuICAgICAgcmVzdWx0LnB1c2gobmV3IFNoYWRlckVycm9yKCd1bmtub3duJywgMCwgZXJyTXNnKSlcbiAgICB9XG4gIH0pXG4gIHJldHVybiByZXN1bHRcbn1cblxuZnVuY3Rpb24gYW5ub3RhdGVGaWxlcyAoZmlsZXMsIGVycm9ycykge1xuICBlcnJvcnMuZm9yRWFjaChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICB2YXIgZmlsZSA9IGZpbGVzW2Vycm9yLmZpbGVdXG4gICAgaWYgKGZpbGUpIHtcbiAgICAgIHZhciBsaW5lID0gZmlsZS5pbmRleFtlcnJvci5saW5lXVxuICAgICAgaWYgKGxpbmUpIHtcbiAgICAgICAgbGluZS5lcnJvcnMucHVzaChlcnJvcilcbiAgICAgICAgZmlsZS5oYXNFcnJvcnMgPSB0cnVlXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgIH1cbiAgICBmaWxlcy51bmtub3duLmhhc0Vycm9ycyA9IHRydWVcbiAgICBmaWxlcy51bmtub3duLmxpbmVzWzBdLmVycm9ycy5wdXNoKGVycm9yKVxuICB9KVxufVxuXG5mdW5jdGlvbiBjaGVja1NoYWRlckVycm9yIChnbCwgc2hhZGVyLCBzb3VyY2UsIHR5cGUsIGNvbW1hbmQpIHtcbiAgaWYgKCFnbC5nZXRTaGFkZXJQYXJhbWV0ZXIoc2hhZGVyLCBnbC5DT01QSUxFX1NUQVRVUykpIHtcbiAgICB2YXIgZXJyTG9nID0gZ2wuZ2V0U2hhZGVySW5mb0xvZyhzaGFkZXIpXG4gICAgdmFyIHR5cGVOYW1lID0gdHlwZSA9PT0gZ2wuRlJBR01FTlRfU0hBREVSID8gJ2ZyYWdtZW50JyA6ICd2ZXJ0ZXgnXG4gICAgY2hlY2tDb21tYW5kVHlwZShzb3VyY2UsICdzdHJpbmcnLCB0eXBlTmFtZSArICcgc2hhZGVyIHNvdXJjZSBtdXN0IGJlIGEgc3RyaW5nJywgY29tbWFuZClcbiAgICB2YXIgZmlsZXMgPSBwYXJzZVNvdXJjZShzb3VyY2UsIGNvbW1hbmQpXG4gICAgdmFyIGVycm9ycyA9IHBhcnNlRXJyb3JMb2coZXJyTG9nKVxuICAgIGFubm90YXRlRmlsZXMoZmlsZXMsIGVycm9ycylcblxuICAgIE9iamVjdC5rZXlzKGZpbGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChmaWxlTnVtYmVyKSB7XG4gICAgICB2YXIgZmlsZSA9IGZpbGVzW2ZpbGVOdW1iZXJdXG4gICAgICBpZiAoIWZpbGUuaGFzRXJyb3JzKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICB2YXIgc3RyaW5ncyA9IFsnJ11cbiAgICAgIHZhciBzdHlsZXMgPSBbJyddXG5cbiAgICAgIGZ1bmN0aW9uIHB1c2ggKHN0ciwgc3R5bGUpIHtcbiAgICAgICAgc3RyaW5ncy5wdXNoKHN0cilcbiAgICAgICAgc3R5bGVzLnB1c2goc3R5bGUgfHwgJycpXG4gICAgICB9XG5cbiAgICAgIHB1c2goJ2ZpbGUgbnVtYmVyICcgKyBmaWxlTnVtYmVyICsgJzogJyArIGZpbGUubmFtZSArICdcXG4nLCAnY29sb3I6cmVkO3RleHQtZGVjb3JhdGlvbjp1bmRlcmxpbmU7Zm9udC13ZWlnaHQ6Ym9sZCcpXG5cbiAgICAgIGZpbGUubGluZXMuZm9yRWFjaChmdW5jdGlvbiAobGluZSkge1xuICAgICAgICBpZiAobGluZS5lcnJvcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHB1c2gobGVmdFBhZChsaW5lLm51bWJlciwgNCkgKyAnfCAgJywgJ2JhY2tncm91bmQtY29sb3I6eWVsbG93OyBmb250LXdlaWdodDpib2xkJylcbiAgICAgICAgICBwdXNoKGxpbmUubGluZSArIGVuZGwsICdjb2xvcjpyZWQ7IGJhY2tncm91bmQtY29sb3I6eWVsbG93OyBmb250LXdlaWdodDpib2xkJylcblxuICAgICAgICAgIC8vIHRyeSB0byBndWVzcyB0b2tlblxuICAgICAgICAgIHZhciBvZmZzZXQgPSAwXG4gICAgICAgICAgbGluZS5lcnJvcnMuZm9yRWFjaChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgIHZhciBtZXNzYWdlID0gZXJyb3IubWVzc2FnZVxuICAgICAgICAgICAgdmFyIHRva2VuID0gL15cXHMqJyguKiknXFxzKjpcXHMqKC4qKSQvLmV4ZWMobWVzc2FnZSlcbiAgICAgICAgICAgIGlmICh0b2tlbikge1xuICAgICAgICAgICAgICB2YXIgdG9rZW5QYXQgPSB0b2tlblsxXVxuICAgICAgICAgICAgICBtZXNzYWdlID0gdG9rZW5bMl1cbiAgICAgICAgICAgICAgc3dpdGNoICh0b2tlblBhdCkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2Fzc2lnbic6XG4gICAgICAgICAgICAgICAgICB0b2tlblBhdCA9ICc9J1xuICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBvZmZzZXQgPSBNYXRoLm1heChsaW5lLmxpbmUuaW5kZXhPZih0b2tlblBhdCwgb2Zmc2V0KSwgMClcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG9mZnNldCA9IDBcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcHVzaChsZWZ0UGFkKCd8ICcsIDYpKVxuICAgICAgICAgICAgcHVzaChsZWZ0UGFkKCdeXl4nLCBvZmZzZXQgKyAzKSArIGVuZGwsICdmb250LXdlaWdodDpib2xkJylcbiAgICAgICAgICAgIHB1c2gobGVmdFBhZCgnfCAnLCA2KSlcbiAgICAgICAgICAgIHB1c2gobWVzc2FnZSArIGVuZGwsICdmb250LXdlaWdodDpib2xkJylcbiAgICAgICAgICB9KVxuICAgICAgICAgIHB1c2gobGVmdFBhZCgnfCAnLCA2KSArIGVuZGwpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHVzaChsZWZ0UGFkKGxpbmUubnVtYmVyLCA0KSArICd8ICAnKVxuICAgICAgICAgIHB1c2gobGluZS5saW5lICsgZW5kbCwgJ2NvbG9yOnJlZCcpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICBpZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiAhd2luZG93LmNocm9tZSkge1xuICAgICAgICBzdHlsZXNbMF0gPSBzdHJpbmdzLmpvaW4oJyVjJylcbiAgICAgICAgY29uc29sZS5sb2cuYXBwbHkoY29uc29sZSwgc3R5bGVzKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5sb2coc3RyaW5ncy5qb2luKCcnKSlcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgY2hlY2sucmFpc2UoJ0Vycm9yIGNvbXBpbGluZyAnICsgdHlwZU5hbWUgKyAnIHNoYWRlciwgJyArIGZpbGVzWzBdLm5hbWUpXG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tMaW5rRXJyb3IgKGdsLCBwcm9ncmFtLCBmcmFnU2hhZGVyLCB2ZXJ0U2hhZGVyLCBjb21tYW5kKSB7XG4gIGlmICghZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlcihwcm9ncmFtLCBnbC5MSU5LX1NUQVRVUykpIHtcbiAgICB2YXIgZXJyTG9nID0gZ2wuZ2V0UHJvZ3JhbUluZm9Mb2cocHJvZ3JhbSlcbiAgICB2YXIgZnJhZ1BhcnNlID0gcGFyc2VTb3VyY2UoZnJhZ1NoYWRlciwgY29tbWFuZClcbiAgICB2YXIgdmVydFBhcnNlID0gcGFyc2VTb3VyY2UodmVydFNoYWRlciwgY29tbWFuZClcblxuICAgIHZhciBoZWFkZXIgPSAnRXJyb3IgbGlua2luZyBwcm9ncmFtIHdpdGggdmVydGV4IHNoYWRlciwgXCInICtcbiAgICAgIHZlcnRQYXJzZVswXS5uYW1lICsgJ1wiLCBhbmQgZnJhZ21lbnQgc2hhZGVyIFwiJyArIGZyYWdQYXJzZVswXS5uYW1lICsgJ1wiJ1xuXG4gICAgaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbnNvbGUubG9nKCclYycgKyBoZWFkZXIgKyBlbmRsICsgJyVjJyArIGVyckxvZyxcbiAgICAgICAgJ2NvbG9yOnJlZDt0ZXh0LWRlY29yYXRpb246dW5kZXJsaW5lO2ZvbnQtd2VpZ2h0OmJvbGQnLFxuICAgICAgICAnY29sb3I6cmVkJylcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS5sb2coaGVhZGVyICsgZW5kbCArIGVyckxvZylcbiAgICB9XG4gICAgY2hlY2sucmFpc2UoaGVhZGVyKVxuICB9XG59XG5cbmZ1bmN0aW9uIHNhdmVDb21tYW5kUmVmIChvYmplY3QpIHtcbiAgb2JqZWN0Ll9jb21tYW5kUmVmID0gZ3Vlc3NDb21tYW5kKClcbn1cblxuZnVuY3Rpb24gc2F2ZURyYXdDb21tYW5kSW5mbyAob3B0cywgdW5pZm9ybXMsIGF0dHJpYnV0ZXMsIHN0cmluZ1N0b3JlKSB7XG4gIHNhdmVDb21tYW5kUmVmKG9wdHMpXG5cbiAgZnVuY3Rpb24gaWQgKHN0cikge1xuICAgIGlmIChzdHIpIHtcbiAgICAgIHJldHVybiBzdHJpbmdTdG9yZS5pZChzdHIpXG4gICAgfVxuICAgIHJldHVybiAwXG4gIH1cbiAgb3B0cy5fZnJhZ0lkID0gaWQob3B0cy5zdGF0aWMuZnJhZylcbiAgb3B0cy5fdmVydElkID0gaWQob3B0cy5zdGF0aWMudmVydClcblxuICBmdW5jdGlvbiBhZGRQcm9wcyAoZGljdCwgc2V0KSB7XG4gICAgT2JqZWN0LmtleXMoc2V0KS5mb3JFYWNoKGZ1bmN0aW9uICh1KSB7XG4gICAgICBkaWN0W3N0cmluZ1N0b3JlLmlkKHUpXSA9IHRydWVcbiAgICB9KVxuICB9XG5cbiAgdmFyIHVuaWZvcm1TZXQgPSBvcHRzLl91bmlmb3JtU2V0ID0ge31cbiAgYWRkUHJvcHModW5pZm9ybVNldCwgdW5pZm9ybXMuc3RhdGljKVxuICBhZGRQcm9wcyh1bmlmb3JtU2V0LCB1bmlmb3Jtcy5keW5hbWljKVxuXG4gIHZhciBhdHRyaWJ1dGVTZXQgPSBvcHRzLl9hdHRyaWJ1dGVTZXQgPSB7fVxuICBhZGRQcm9wcyhhdHRyaWJ1dGVTZXQsIGF0dHJpYnV0ZXMuc3RhdGljKVxuICBhZGRQcm9wcyhhdHRyaWJ1dGVTZXQsIGF0dHJpYnV0ZXMuZHluYW1pYylcblxuICBvcHRzLl9oYXNDb3VudCA9IChcbiAgICAnY291bnQnIGluIG9wdHMuc3RhdGljIHx8XG4gICAgJ2NvdW50JyBpbiBvcHRzLmR5bmFtaWMgfHxcbiAgICAnZWxlbWVudHMnIGluIG9wdHMuc3RhdGljIHx8XG4gICAgJ2VsZW1lbnRzJyBpbiBvcHRzLmR5bmFtaWMpXG59XG5cbmZ1bmN0aW9uIGNvbW1hbmRSYWlzZSAobWVzc2FnZSwgY29tbWFuZCkge1xuICB2YXIgY2FsbFNpdGUgPSBndWVzc0NhbGxTaXRlKClcbiAgcmFpc2UobWVzc2FnZSArXG4gICAgJyBpbiBjb21tYW5kICcgKyAoY29tbWFuZCB8fCBndWVzc0NvbW1hbmQoKSkgK1xuICAgIChjYWxsU2l0ZSA9PT0gJ3Vua25vd24nID8gJycgOiAnIGNhbGxlZCBmcm9tICcgKyBjYWxsU2l0ZSkpXG59XG5cbmZ1bmN0aW9uIGNoZWNrQ29tbWFuZCAocHJlZCwgbWVzc2FnZSwgY29tbWFuZCkge1xuICBpZiAoIXByZWQpIHtcbiAgICBjb21tYW5kUmFpc2UobWVzc2FnZSwgY29tbWFuZCB8fCBndWVzc0NvbW1hbmQoKSlcbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja1BhcmFtZXRlckNvbW1hbmQgKHBhcmFtLCBwb3NzaWJpbGl0aWVzLCBtZXNzYWdlLCBjb21tYW5kKSB7XG4gIGlmICghKHBhcmFtIGluIHBvc3NpYmlsaXRpZXMpKSB7XG4gICAgY29tbWFuZFJhaXNlKFxuICAgICAgJ3Vua25vd24gcGFyYW1ldGVyICgnICsgcGFyYW0gKyAnKScgKyBlbmNvbG9uKG1lc3NhZ2UpICtcbiAgICAgICcuIHBvc3NpYmxlIHZhbHVlczogJyArIE9iamVjdC5rZXlzKHBvc3NpYmlsaXRpZXMpLmpvaW4oKSxcbiAgICAgIGNvbW1hbmQgfHwgZ3Vlc3NDb21tYW5kKCkpXG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tDb21tYW5kVHlwZSAodmFsdWUsIHR5cGUsIG1lc3NhZ2UsIGNvbW1hbmQpIHtcbiAgaWYgKCFzdGFuZGFyZFR5cGVFaCh2YWx1ZSwgdHlwZSkpIHtcbiAgICBjb21tYW5kUmFpc2UoXG4gICAgICAnaW52YWxpZCBwYXJhbWV0ZXIgdHlwZScgKyBlbmNvbG9uKG1lc3NhZ2UpICtcbiAgICAgICcuIGV4cGVjdGVkICcgKyB0eXBlICsgJywgZ290ICcgKyAodHlwZW9mIHZhbHVlKSxcbiAgICAgIGNvbW1hbmQgfHwgZ3Vlc3NDb21tYW5kKCkpXG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tPcHRpb25hbCAoYmxvY2spIHtcbiAgYmxvY2soKVxufVxuXG5mdW5jdGlvbiBjaGVja0ZyYW1lYnVmZmVyRm9ybWF0IChhdHRhY2htZW50LCB0ZXhGb3JtYXRzLCByYkZvcm1hdHMpIHtcbiAgaWYgKGF0dGFjaG1lbnQudGV4dHVyZSkge1xuICAgIGNoZWNrT25lT2YoXG4gICAgICBhdHRhY2htZW50LnRleHR1cmUuX3RleHR1cmUuaW50ZXJuYWxmb3JtYXQsXG4gICAgICB0ZXhGb3JtYXRzLFxuICAgICAgJ3Vuc3VwcG9ydGVkIHRleHR1cmUgZm9ybWF0IGZvciBhdHRhY2htZW50JylcbiAgfSBlbHNlIHtcbiAgICBjaGVja09uZU9mKFxuICAgICAgYXR0YWNobWVudC5yZW5kZXJidWZmZXIuX3JlbmRlcmJ1ZmZlci5mb3JtYXQsXG4gICAgICByYkZvcm1hdHMsXG4gICAgICAndW5zdXBwb3J0ZWQgcmVuZGVyYnVmZmVyIGZvcm1hdCBmb3IgYXR0YWNobWVudCcpXG4gIH1cbn1cblxudmFyIEdMX0NMQU1QX1RPX0VER0UgPSAweDgxMkZcblxudmFyIEdMX05FQVJFU1QgPSAweDI2MDBcbnZhciBHTF9ORUFSRVNUX01JUE1BUF9ORUFSRVNUID0gMHgyNzAwXG52YXIgR0xfTElORUFSX01JUE1BUF9ORUFSRVNUID0gMHgyNzAxXG52YXIgR0xfTkVBUkVTVF9NSVBNQVBfTElORUFSID0gMHgyNzAyXG52YXIgR0xfTElORUFSX01JUE1BUF9MSU5FQVIgPSAweDI3MDNcblxudmFyIEdMX0JZVEUgPSA1MTIwXG52YXIgR0xfVU5TSUdORURfQllURSA9IDUxMjFcbnZhciBHTF9TSE9SVCA9IDUxMjJcbnZhciBHTF9VTlNJR05FRF9TSE9SVCA9IDUxMjNcbnZhciBHTF9JTlQgPSA1MTI0XG52YXIgR0xfVU5TSUdORURfSU5UID0gNTEyNVxudmFyIEdMX0ZMT0FUID0gNTEyNlxuXG52YXIgR0xfVU5TSUdORURfU0hPUlRfNF80XzRfNCA9IDB4ODAzM1xudmFyIEdMX1VOU0lHTkVEX1NIT1JUXzVfNV81XzEgPSAweDgwMzRcbnZhciBHTF9VTlNJR05FRF9TSE9SVF81XzZfNSA9IDB4ODM2M1xudmFyIEdMX1VOU0lHTkVEX0lOVF8yNF84X1dFQkdMID0gMHg4NEZBXG5cbnZhciBHTF9IQUxGX0ZMT0FUX09FUyA9IDB4OEQ2MVxuXG52YXIgVFlQRV9TSVpFID0ge31cblxuVFlQRV9TSVpFW0dMX0JZVEVdID1cblRZUEVfU0laRVtHTF9VTlNJR05FRF9CWVRFXSA9IDFcblxuVFlQRV9TSVpFW0dMX1NIT1JUXSA9XG5UWVBFX1NJWkVbR0xfVU5TSUdORURfU0hPUlRdID1cblRZUEVfU0laRVtHTF9IQUxGX0ZMT0FUX09FU10gPVxuVFlQRV9TSVpFW0dMX1VOU0lHTkVEX1NIT1JUXzVfNl81XSA9XG5UWVBFX1NJWkVbR0xfVU5TSUdORURfU0hPUlRfNF80XzRfNF0gPVxuVFlQRV9TSVpFW0dMX1VOU0lHTkVEX1NIT1JUXzVfNV81XzFdID0gMlxuXG5UWVBFX1NJWkVbR0xfSU5UXSA9XG5UWVBFX1NJWkVbR0xfVU5TSUdORURfSU5UXSA9XG5UWVBFX1NJWkVbR0xfRkxPQVRdID1cblRZUEVfU0laRVtHTF9VTlNJR05FRF9JTlRfMjRfOF9XRUJHTF0gPSA0XG5cbmZ1bmN0aW9uIHBpeGVsU2l6ZSAodHlwZSwgY2hhbm5lbHMpIHtcbiAgaWYgKHR5cGUgPT09IEdMX1VOU0lHTkVEX1NIT1JUXzVfNV81XzEgfHxcbiAgICAgIHR5cGUgPT09IEdMX1VOU0lHTkVEX1NIT1JUXzRfNF80XzQgfHxcbiAgICAgIHR5cGUgPT09IEdMX1VOU0lHTkVEX1NIT1JUXzVfNl81KSB7XG4gICAgcmV0dXJuIDJcbiAgfSBlbHNlIGlmICh0eXBlID09PSBHTF9VTlNJR05FRF9JTlRfMjRfOF9XRUJHTCkge1xuICAgIHJldHVybiA0XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFRZUEVfU0laRVt0eXBlXSAqIGNoYW5uZWxzXG4gIH1cbn1cblxuZnVuY3Rpb24gaXNQb3cyICh2KSB7XG4gIHJldHVybiAhKHYgJiAodiAtIDEpKSAmJiAoISF2KVxufVxuXG5mdW5jdGlvbiBjaGVja1RleHR1cmUyRCAoaW5mbywgbWlwRGF0YSwgbGltaXRzKSB7XG4gIHZhciBpXG4gIHZhciB3ID0gbWlwRGF0YS53aWR0aFxuICB2YXIgaCA9IG1pcERhdGEuaGVpZ2h0XG4gIHZhciBjID0gbWlwRGF0YS5jaGFubmVsc1xuXG4gIC8vIENoZWNrIHRleHR1cmUgc2hhcGVcbiAgY2hlY2sodyA+IDAgJiYgdyA8PSBsaW1pdHMubWF4VGV4dHVyZVNpemUgJiZcbiAgICAgICAgaCA+IDAgJiYgaCA8PSBsaW1pdHMubWF4VGV4dHVyZVNpemUsXG4gICdpbnZhbGlkIHRleHR1cmUgc2hhcGUnKVxuXG4gIC8vIGNoZWNrIHdyYXAgbW9kZVxuICBpZiAoaW5mby53cmFwUyAhPT0gR0xfQ0xBTVBfVE9fRURHRSB8fCBpbmZvLndyYXBUICE9PSBHTF9DTEFNUF9UT19FREdFKSB7XG4gICAgY2hlY2soaXNQb3cyKHcpICYmIGlzUG93MihoKSxcbiAgICAgICdpbmNvbXBhdGlibGUgd3JhcCBtb2RlIGZvciB0ZXh0dXJlLCBib3RoIHdpZHRoIGFuZCBoZWlnaHQgbXVzdCBiZSBwb3dlciBvZiAyJylcbiAgfVxuXG4gIGlmIChtaXBEYXRhLm1pcG1hc2sgPT09IDEpIHtcbiAgICBpZiAodyAhPT0gMSAmJiBoICE9PSAxKSB7XG4gICAgICBjaGVjayhcbiAgICAgICAgaW5mby5taW5GaWx0ZXIgIT09IEdMX05FQVJFU1RfTUlQTUFQX05FQVJFU1QgJiZcbiAgICAgICAgaW5mby5taW5GaWx0ZXIgIT09IEdMX05FQVJFU1RfTUlQTUFQX0xJTkVBUiAmJlxuICAgICAgICBpbmZvLm1pbkZpbHRlciAhPT0gR0xfTElORUFSX01JUE1BUF9ORUFSRVNUICYmXG4gICAgICAgIGluZm8ubWluRmlsdGVyICE9PSBHTF9MSU5FQVJfTUlQTUFQX0xJTkVBUixcbiAgICAgICAgJ21pbiBmaWx0ZXIgcmVxdWlyZXMgbWlwbWFwJylcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gdGV4dHVyZSBtdXN0IGJlIHBvd2VyIG9mIDJcbiAgICBjaGVjayhpc1BvdzIodykgJiYgaXNQb3cyKGgpLFxuICAgICAgJ3RleHR1cmUgbXVzdCBiZSBhIHNxdWFyZSBwb3dlciBvZiAyIHRvIHN1cHBvcnQgbWlwbWFwcGluZycpXG4gICAgY2hlY2sobWlwRGF0YS5taXBtYXNrID09PSAodyA8PCAxKSAtIDEsXG4gICAgICAnbWlzc2luZyBvciBpbmNvbXBsZXRlIG1pcG1hcCBkYXRhJylcbiAgfVxuXG4gIGlmIChtaXBEYXRhLnR5cGUgPT09IEdMX0ZMT0FUKSB7XG4gICAgaWYgKGxpbWl0cy5leHRlbnNpb25zLmluZGV4T2YoJ29lc190ZXh0dXJlX2Zsb2F0X2xpbmVhcicpIDwgMCkge1xuICAgICAgY2hlY2soaW5mby5taW5GaWx0ZXIgPT09IEdMX05FQVJFU1QgJiYgaW5mby5tYWdGaWx0ZXIgPT09IEdMX05FQVJFU1QsXG4gICAgICAgICdmaWx0ZXIgbm90IHN1cHBvcnRlZCwgbXVzdCBlbmFibGUgb2VzX3RleHR1cmVfZmxvYXRfbGluZWFyJylcbiAgICB9XG4gICAgY2hlY2soIWluZm8uZ2VuTWlwbWFwcyxcbiAgICAgICdtaXBtYXAgZ2VuZXJhdGlvbiBub3Qgc3VwcG9ydGVkIHdpdGggZmxvYXQgdGV4dHVyZXMnKVxuICB9XG5cbiAgLy8gY2hlY2sgaW1hZ2UgY29tcGxldGVcbiAgdmFyIG1pcGltYWdlcyA9IG1pcERhdGEuaW1hZ2VzXG4gIGZvciAoaSA9IDA7IGkgPCAxNjsgKytpKSB7XG4gICAgaWYgKG1pcGltYWdlc1tpXSkge1xuICAgICAgdmFyIG13ID0gdyA+PiBpXG4gICAgICB2YXIgbWggPSBoID4+IGlcbiAgICAgIGNoZWNrKG1pcERhdGEubWlwbWFzayAmICgxIDw8IGkpLCAnbWlzc2luZyBtaXBtYXAgZGF0YScpXG5cbiAgICAgIHZhciBpbWcgPSBtaXBpbWFnZXNbaV1cblxuICAgICAgY2hlY2soXG4gICAgICAgIGltZy53aWR0aCA9PT0gbXcgJiZcbiAgICAgICAgaW1nLmhlaWdodCA9PT0gbWgsXG4gICAgICAgICdpbnZhbGlkIHNoYXBlIGZvciBtaXAgaW1hZ2VzJylcblxuICAgICAgY2hlY2soXG4gICAgICAgIGltZy5mb3JtYXQgPT09IG1pcERhdGEuZm9ybWF0ICYmXG4gICAgICAgIGltZy5pbnRlcm5hbGZvcm1hdCA9PT0gbWlwRGF0YS5pbnRlcm5hbGZvcm1hdCAmJlxuICAgICAgICBpbWcudHlwZSA9PT0gbWlwRGF0YS50eXBlLFxuICAgICAgICAnaW5jb21wYXRpYmxlIHR5cGUgZm9yIG1pcCBpbWFnZScpXG5cbiAgICAgIGlmIChpbWcuY29tcHJlc3NlZCkge1xuICAgICAgICAvLyBUT0RPOiBjaGVjayBzaXplIGZvciBjb21wcmVzc2VkIGltYWdlc1xuICAgICAgfSBlbHNlIGlmIChpbWcuZGF0YSkge1xuICAgICAgICAvLyBjaGVjayhpbWcuZGF0YS5ieXRlTGVuZ3RoID09PSBtdyAqIG1oICpcbiAgICAgICAgLy8gTWF0aC5tYXgocGl4ZWxTaXplKGltZy50eXBlLCBjKSwgaW1nLnVucGFja0FsaWdubWVudCksXG4gICAgICAgIHZhciByb3dTaXplID0gTWF0aC5jZWlsKHBpeGVsU2l6ZShpbWcudHlwZSwgYykgKiBtdyAvIGltZy51bnBhY2tBbGlnbm1lbnQpICogaW1nLnVucGFja0FsaWdubWVudFxuICAgICAgICBjaGVjayhpbWcuZGF0YS5ieXRlTGVuZ3RoID09PSByb3dTaXplICogbWgsXG4gICAgICAgICAgJ2ludmFsaWQgZGF0YSBmb3IgaW1hZ2UsIGJ1ZmZlciBzaXplIGlzIGluY29uc2lzdGVudCB3aXRoIGltYWdlIGZvcm1hdCcpXG4gICAgICB9IGVsc2UgaWYgKGltZy5lbGVtZW50KSB7XG4gICAgICAgIC8vIFRPRE86IGNoZWNrIGVsZW1lbnQgY2FuIGJlIGxvYWRlZFxuICAgICAgfSBlbHNlIGlmIChpbWcuY29weSkge1xuICAgICAgICAvLyBUT0RPOiBjaGVjayBjb21wYXRpYmxlIGZvcm1hdCBhbmQgdHlwZVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIWluZm8uZ2VuTWlwbWFwcykge1xuICAgICAgY2hlY2soKG1pcERhdGEubWlwbWFzayAmICgxIDw8IGkpKSA9PT0gMCwgJ2V4dHJhIG1pcG1hcCBkYXRhJylcbiAgICB9XG4gIH1cblxuICBpZiAobWlwRGF0YS5jb21wcmVzc2VkKSB7XG4gICAgY2hlY2soIWluZm8uZ2VuTWlwbWFwcyxcbiAgICAgICdtaXBtYXAgZ2VuZXJhdGlvbiBmb3IgY29tcHJlc3NlZCBpbWFnZXMgbm90IHN1cHBvcnRlZCcpXG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tUZXh0dXJlQ3ViZSAodGV4dHVyZSwgaW5mbywgZmFjZXMsIGxpbWl0cykge1xuICB2YXIgdyA9IHRleHR1cmUud2lkdGhcbiAgdmFyIGggPSB0ZXh0dXJlLmhlaWdodFxuICB2YXIgYyA9IHRleHR1cmUuY2hhbm5lbHNcblxuICAvLyBDaGVjayB0ZXh0dXJlIHNoYXBlXG4gIGNoZWNrKFxuICAgIHcgPiAwICYmIHcgPD0gbGltaXRzLm1heFRleHR1cmVTaXplICYmIGggPiAwICYmIGggPD0gbGltaXRzLm1heFRleHR1cmVTaXplLFxuICAgICdpbnZhbGlkIHRleHR1cmUgc2hhcGUnKVxuICBjaGVjayhcbiAgICB3ID09PSBoLFxuICAgICdjdWJlIG1hcCBtdXN0IGJlIHNxdWFyZScpXG4gIGNoZWNrKFxuICAgIGluZm8ud3JhcFMgPT09IEdMX0NMQU1QX1RPX0VER0UgJiYgaW5mby53cmFwVCA9PT0gR0xfQ0xBTVBfVE9fRURHRSxcbiAgICAnd3JhcCBtb2RlIG5vdCBzdXBwb3J0ZWQgYnkgY3ViZSBtYXAnKVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZmFjZXMubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgZmFjZSA9IGZhY2VzW2ldXG4gICAgY2hlY2soXG4gICAgICBmYWNlLndpZHRoID09PSB3ICYmIGZhY2UuaGVpZ2h0ID09PSBoLFxuICAgICAgJ2luY29uc2lzdGVudCBjdWJlIG1hcCBmYWNlIHNoYXBlJylcblxuICAgIGlmIChpbmZvLmdlbk1pcG1hcHMpIHtcbiAgICAgIGNoZWNrKCFmYWNlLmNvbXByZXNzZWQsXG4gICAgICAgICdjYW4gbm90IGdlbmVyYXRlIG1pcG1hcCBmb3IgY29tcHJlc3NlZCB0ZXh0dXJlcycpXG4gICAgICBjaGVjayhmYWNlLm1pcG1hc2sgPT09IDEsXG4gICAgICAgICdjYW4gbm90IHNwZWNpZnkgbWlwbWFwcyBhbmQgZ2VuZXJhdGUgbWlwbWFwcycpXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRPRE86IGNoZWNrIG1pcCBhbmQgZmlsdGVyIG1vZGVcbiAgICB9XG5cbiAgICB2YXIgbWlwbWFwcyA9IGZhY2UuaW1hZ2VzXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCAxNjsgKytqKSB7XG4gICAgICB2YXIgaW1nID0gbWlwbWFwc1tqXVxuICAgICAgaWYgKGltZykge1xuICAgICAgICB2YXIgbXcgPSB3ID4+IGpcbiAgICAgICAgdmFyIG1oID0gaCA+PiBqXG4gICAgICAgIGNoZWNrKGZhY2UubWlwbWFzayAmICgxIDw8IGopLCAnbWlzc2luZyBtaXBtYXAgZGF0YScpXG4gICAgICAgIGNoZWNrKFxuICAgICAgICAgIGltZy53aWR0aCA9PT0gbXcgJiZcbiAgICAgICAgICBpbWcuaGVpZ2h0ID09PSBtaCxcbiAgICAgICAgICAnaW52YWxpZCBzaGFwZSBmb3IgbWlwIGltYWdlcycpXG4gICAgICAgIGNoZWNrKFxuICAgICAgICAgIGltZy5mb3JtYXQgPT09IHRleHR1cmUuZm9ybWF0ICYmXG4gICAgICAgICAgaW1nLmludGVybmFsZm9ybWF0ID09PSB0ZXh0dXJlLmludGVybmFsZm9ybWF0ICYmXG4gICAgICAgICAgaW1nLnR5cGUgPT09IHRleHR1cmUudHlwZSxcbiAgICAgICAgICAnaW5jb21wYXRpYmxlIHR5cGUgZm9yIG1pcCBpbWFnZScpXG5cbiAgICAgICAgaWYgKGltZy5jb21wcmVzc2VkKSB7XG4gICAgICAgICAgLy8gVE9ETzogY2hlY2sgc2l6ZSBmb3IgY29tcHJlc3NlZCBpbWFnZXNcbiAgICAgICAgfSBlbHNlIGlmIChpbWcuZGF0YSkge1xuICAgICAgICAgIGNoZWNrKGltZy5kYXRhLmJ5dGVMZW5ndGggPT09IG13ICogbWggKlxuICAgICAgICAgICAgTWF0aC5tYXgocGl4ZWxTaXplKGltZy50eXBlLCBjKSwgaW1nLnVucGFja0FsaWdubWVudCksXG4gICAgICAgICAgJ2ludmFsaWQgZGF0YSBmb3IgaW1hZ2UsIGJ1ZmZlciBzaXplIGlzIGluY29uc2lzdGVudCB3aXRoIGltYWdlIGZvcm1hdCcpXG4gICAgICAgIH0gZWxzZSBpZiAoaW1nLmVsZW1lbnQpIHtcbiAgICAgICAgICAvLyBUT0RPOiBjaGVjayBlbGVtZW50IGNhbiBiZSBsb2FkZWRcbiAgICAgICAgfSBlbHNlIGlmIChpbWcuY29weSkge1xuICAgICAgICAgIC8vIFRPRE86IGNoZWNrIGNvbXBhdGlibGUgZm9ybWF0IGFuZCB0eXBlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxudmFyIGNoZWNrJDEgPSBleHRlbmQoY2hlY2ssIHtcbiAgb3B0aW9uYWw6IGNoZWNrT3B0aW9uYWwsXG4gIHJhaXNlOiByYWlzZSxcbiAgY29tbWFuZFJhaXNlOiBjb21tYW5kUmFpc2UsXG4gIGNvbW1hbmQ6IGNoZWNrQ29tbWFuZCxcbiAgcGFyYW1ldGVyOiBjaGVja1BhcmFtZXRlcixcbiAgY29tbWFuZFBhcmFtZXRlcjogY2hlY2tQYXJhbWV0ZXJDb21tYW5kLFxuICBjb25zdHJ1Y3RvcjogY2hlY2tDb25zdHJ1Y3RvcixcbiAgdHlwZTogY2hlY2tUeXBlT2YsXG4gIGNvbW1hbmRUeXBlOiBjaGVja0NvbW1hbmRUeXBlLFxuICBpc1R5cGVkQXJyYXk6IGNoZWNrSXNUeXBlZEFycmF5LFxuICBubmk6IGNoZWNrTm9uTmVnYXRpdmVJbnQsXG4gIG9uZU9mOiBjaGVja09uZU9mLFxuICBzaGFkZXJFcnJvcjogY2hlY2tTaGFkZXJFcnJvcixcbiAgbGlua0Vycm9yOiBjaGVja0xpbmtFcnJvcixcbiAgY2FsbFNpdGU6IGd1ZXNzQ2FsbFNpdGUsXG4gIHNhdmVDb21tYW5kUmVmOiBzYXZlQ29tbWFuZFJlZixcbiAgc2F2ZURyYXdJbmZvOiBzYXZlRHJhd0NvbW1hbmRJbmZvLFxuICBmcmFtZWJ1ZmZlckZvcm1hdDogY2hlY2tGcmFtZWJ1ZmZlckZvcm1hdCxcbiAgZ3Vlc3NDb21tYW5kOiBndWVzc0NvbW1hbmQsXG4gIHRleHR1cmUyRDogY2hlY2tUZXh0dXJlMkQsXG4gIHRleHR1cmVDdWJlOiBjaGVja1RleHR1cmVDdWJlXG59KTtcblxudmFyIFZBUklBQkxFX0NPVU5URVIgPSAwXG5cbnZhciBEWU5fRlVOQyA9IDBcbnZhciBEWU5fQ09OU1RBTlQgPSA1XG52YXIgRFlOX0FSUkFZID0gNlxuXG5mdW5jdGlvbiBEeW5hbWljVmFyaWFibGUgKHR5cGUsIGRhdGEpIHtcbiAgdGhpcy5pZCA9IChWQVJJQUJMRV9DT1VOVEVSKyspXG4gIHRoaXMudHlwZSA9IHR5cGVcbiAgdGhpcy5kYXRhID0gZGF0YVxufVxuXG5mdW5jdGlvbiBlc2NhcGVTdHIgKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoL1xcXFwvZywgJ1xcXFxcXFxcJykucmVwbGFjZSgvXCIvZywgJ1xcXFxcIicpXG59XG5cbmZ1bmN0aW9uIHNwbGl0UGFydHMgKHN0cikge1xuICBpZiAoc3RyLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBbXVxuICB9XG5cbiAgdmFyIGZpcnN0Q2hhciA9IHN0ci5jaGFyQXQoMClcbiAgdmFyIGxhc3RDaGFyID0gc3RyLmNoYXJBdChzdHIubGVuZ3RoIC0gMSlcblxuICBpZiAoc3RyLmxlbmd0aCA+IDEgJiZcbiAgICAgIGZpcnN0Q2hhciA9PT0gbGFzdENoYXIgJiZcbiAgICAgIChmaXJzdENoYXIgPT09ICdcIicgfHwgZmlyc3RDaGFyID09PSBcIidcIikpIHtcbiAgICByZXR1cm4gWydcIicgKyBlc2NhcGVTdHIoc3RyLnN1YnN0cigxLCBzdHIubGVuZ3RoIC0gMikpICsgJ1wiJ11cbiAgfVxuXG4gIHZhciBwYXJ0cyA9IC9cXFsoZmFsc2V8dHJ1ZXxudWxsfFxcZCt8J1teJ10qJ3xcIlteXCJdKlwiKVxcXS8uZXhlYyhzdHIpXG4gIGlmIChwYXJ0cykge1xuICAgIHJldHVybiAoXG4gICAgICBzcGxpdFBhcnRzKHN0ci5zdWJzdHIoMCwgcGFydHMuaW5kZXgpKVxuICAgICAgICAuY29uY2F0KHNwbGl0UGFydHMocGFydHNbMV0pKVxuICAgICAgICAuY29uY2F0KHNwbGl0UGFydHMoc3RyLnN1YnN0cihwYXJ0cy5pbmRleCArIHBhcnRzWzBdLmxlbmd0aCkpKVxuICAgIClcbiAgfVxuXG4gIHZhciBzdWJwYXJ0cyA9IHN0ci5zcGxpdCgnLicpXG4gIGlmIChzdWJwYXJ0cy5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gWydcIicgKyBlc2NhcGVTdHIoc3RyKSArICdcIiddXG4gIH1cblxuICB2YXIgcmVzdWx0ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdWJwYXJ0cy5sZW5ndGg7ICsraSkge1xuICAgIHJlc3VsdCA9IHJlc3VsdC5jb25jYXQoc3BsaXRQYXJ0cyhzdWJwYXJ0c1tpXSkpXG4gIH1cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG5mdW5jdGlvbiB0b0FjY2Vzc29yU3RyaW5nIChzdHIpIHtcbiAgcmV0dXJuICdbJyArIHNwbGl0UGFydHMoc3RyKS5qb2luKCddWycpICsgJ10nXG59XG5cbmZ1bmN0aW9uIGRlZmluZUR5bmFtaWMgKHR5cGUsIGRhdGEpIHtcbiAgcmV0dXJuIG5ldyBEeW5hbWljVmFyaWFibGUodHlwZSwgdG9BY2Nlc3NvclN0cmluZyhkYXRhICsgJycpKVxufVxuXG5mdW5jdGlvbiBpc0R5bmFtaWMgKHgpIHtcbiAgcmV0dXJuICh0eXBlb2YgeCA9PT0gJ2Z1bmN0aW9uJyAmJiAheC5fcmVnbFR5cGUpIHx8ICh4IGluc3RhbmNlb2YgRHluYW1pY1ZhcmlhYmxlKVxufVxuXG5mdW5jdGlvbiB1bmJveCAoeCwgcGF0aCkge1xuICBpZiAodHlwZW9mIHggPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gbmV3IER5bmFtaWNWYXJpYWJsZShEWU5fRlVOQywgeClcbiAgfSBlbHNlIGlmICh0eXBlb2YgeCA9PT0gJ251bWJlcicgfHwgdHlwZW9mIHggPT09ICdib29sZWFuJykge1xuICAgIHJldHVybiBuZXcgRHluYW1pY1ZhcmlhYmxlKERZTl9DT05TVEFOVCwgeClcbiAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHgpKSB7XG4gICAgcmV0dXJuIG5ldyBEeW5hbWljVmFyaWFibGUoRFlOX0FSUkFZLCB4Lm1hcCgoeSwgaSkgPT4gdW5ib3goeSwgcGF0aCArICdbJyArIGkgKyAnXScpKSlcbiAgfSBlbHNlIGlmICh4IGluc3RhbmNlb2YgRHluYW1pY1ZhcmlhYmxlKSB7XG4gICAgcmV0dXJuIHhcbiAgfVxuICBjaGVjayQxKGZhbHNlLCAnaW52YWxpZCBvcHRpb24gdHlwZSBpbiB1bmlmb3JtICcgKyBwYXRoKVxufVxuXG52YXIgZHluYW1pYyA9IHtcbiAgRHluYW1pY1ZhcmlhYmxlOiBEeW5hbWljVmFyaWFibGUsXG4gIGRlZmluZTogZGVmaW5lRHluYW1pYyxcbiAgaXNEeW5hbWljOiBpc0R5bmFtaWMsXG4gIHVuYm94OiB1bmJveCxcbiAgYWNjZXNzb3I6IHRvQWNjZXNzb3JTdHJpbmdcbn07XG5cbi8qIGdsb2JhbHMgcmVxdWVzdEFuaW1hdGlvbkZyYW1lLCBjYW5jZWxBbmltYXRpb25GcmFtZSAqL1xudmFyIHJhZiA9IHtcbiAgbmV4dDogdHlwZW9mIHJlcXVlc3RBbmltYXRpb25GcmFtZSA9PT0gJ2Z1bmN0aW9uJ1xuICAgID8gZnVuY3Rpb24gKGNiKSB7IHJldHVybiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoY2IpIH1cbiAgICA6IGZ1bmN0aW9uIChjYikgeyByZXR1cm4gc2V0VGltZW91dChjYiwgMTYpIH0sXG4gIGNhbmNlbDogdHlwZW9mIGNhbmNlbEFuaW1hdGlvbkZyYW1lID09PSAnZnVuY3Rpb24nXG4gICAgPyBmdW5jdGlvbiAocmFmKSB7IHJldHVybiBjYW5jZWxBbmltYXRpb25GcmFtZShyYWYpIH1cbiAgICA6IGNsZWFyVGltZW91dFxufTtcblxuLyogZ2xvYmFscyBwZXJmb3JtYW5jZSAqL1xudmFyIGNsb2NrID0gKHR5cGVvZiBwZXJmb3JtYW5jZSAhPT0gJ3VuZGVmaW5lZCcgJiYgcGVyZm9ybWFuY2Uubm93KVxuICAgID8gZnVuY3Rpb24gKCkgeyByZXR1cm4gcGVyZm9ybWFuY2Uubm93KCkgfVxuICAgIDogZnVuY3Rpb24gKCkgeyByZXR1cm4gKyhuZXcgRGF0ZSgpKSB9O1xuXG5mdW5jdGlvbiBjcmVhdGVTdHJpbmdTdG9yZSAoKSB7XG4gIHZhciBzdHJpbmdJZHMgPSB7ICcnOiAwIH1cbiAgdmFyIHN0cmluZ1ZhbHVlcyA9IFsnJ11cbiAgcmV0dXJuIHtcbiAgICBpZDogZnVuY3Rpb24gKHN0cikge1xuICAgICAgdmFyIHJlc3VsdCA9IHN0cmluZ0lkc1tzdHJdXG4gICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgIHJldHVybiByZXN1bHRcbiAgICAgIH1cbiAgICAgIHJlc3VsdCA9IHN0cmluZ0lkc1tzdHJdID0gc3RyaW5nVmFsdWVzLmxlbmd0aFxuICAgICAgc3RyaW5nVmFsdWVzLnB1c2goc3RyKVxuICAgICAgcmV0dXJuIHJlc3VsdFxuICAgIH0sXG5cbiAgICBzdHI6IGZ1bmN0aW9uIChpZCkge1xuICAgICAgcmV0dXJuIHN0cmluZ1ZhbHVlc1tpZF1cbiAgICB9XG4gIH1cbn1cblxuLy8gQ29udGV4dCBhbmQgY2FudmFzIGNyZWF0aW9uIGhlbHBlciBmdW5jdGlvbnNcbmZ1bmN0aW9uIGNyZWF0ZUNhbnZhcyAoZWxlbWVudCwgb25Eb25lLCBwaXhlbFJhdGlvKSB7XG4gIHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKVxuICBleHRlbmQoY2FudmFzLnN0eWxlLCB7XG4gICAgYm9yZGVyOiAwLFxuICAgIG1hcmdpbjogMCxcbiAgICBwYWRkaW5nOiAwLFxuICAgIHRvcDogMCxcbiAgICBsZWZ0OiAwXG4gIH0pXG4gIGVsZW1lbnQuYXBwZW5kQ2hpbGQoY2FudmFzKVxuXG4gIGlmIChlbGVtZW50ID09PSBkb2N1bWVudC5ib2R5KSB7XG4gICAgY2FudmFzLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJ1xuICAgIGV4dGVuZChlbGVtZW50LnN0eWxlLCB7XG4gICAgICBtYXJnaW46IDAsXG4gICAgICBwYWRkaW5nOiAwXG4gICAgfSlcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc2l6ZSAoKSB7XG4gICAgdmFyIHcgPSB3aW5kb3cuaW5uZXJXaWR0aFxuICAgIHZhciBoID0gd2luZG93LmlubmVySGVpZ2h0XG4gICAgaWYgKGVsZW1lbnQgIT09IGRvY3VtZW50LmJvZHkpIHtcbiAgICAgIHZhciBib3VuZHMgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG4gICAgICB3ID0gYm91bmRzLnJpZ2h0IC0gYm91bmRzLmxlZnRcbiAgICAgIGggPSBib3VuZHMuYm90dG9tIC0gYm91bmRzLnRvcFxuICAgIH1cbiAgICBjYW52YXMud2lkdGggPSBwaXhlbFJhdGlvICogd1xuICAgIGNhbnZhcy5oZWlnaHQgPSBwaXhlbFJhdGlvICogaFxuICAgIGV4dGVuZChjYW52YXMuc3R5bGUsIHtcbiAgICAgIHdpZHRoOiB3ICsgJ3B4JyxcbiAgICAgIGhlaWdodDogaCArICdweCdcbiAgICB9KVxuICB9XG5cbiAgdmFyIHJlc2l6ZU9ic2VydmVyXG4gIGlmIChlbGVtZW50ICE9PSBkb2N1bWVudC5ib2R5ICYmIHR5cGVvZiBSZXNpemVPYnNlcnZlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIGlnbm9yZSAnUmVzaXplT2JzZXJ2ZXInIGlzIG5vdCBkZWZpbmVkXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgcmVzaXplT2JzZXJ2ZXIgPSBuZXcgUmVzaXplT2JzZXJ2ZXIoZnVuY3Rpb24gKCkge1xuICAgICAgLy8gc2V0VGltZW91dCB0byBhdm9pZCBmbGlja2VyXG4gICAgICBzZXRUaW1lb3V0KHJlc2l6ZSlcbiAgICB9KVxuICAgIHJlc2l6ZU9ic2VydmVyLm9ic2VydmUoZWxlbWVudClcbiAgfSBlbHNlIHtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgcmVzaXplLCBmYWxzZSlcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uRGVzdHJveSAoKSB7XG4gICAgaWYgKHJlc2l6ZU9ic2VydmVyKSB7XG4gICAgICByZXNpemVPYnNlcnZlci5kaXNjb25uZWN0KClcbiAgICB9IGVsc2Uge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHJlc2l6ZSlcbiAgICB9XG4gICAgZWxlbWVudC5yZW1vdmVDaGlsZChjYW52YXMpXG4gIH1cblxuICByZXNpemUoKVxuXG4gIHJldHVybiB7XG4gICAgY2FudmFzOiBjYW52YXMsXG4gICAgb25EZXN0cm95OiBvbkRlc3Ryb3lcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVDb250ZXh0IChjYW52YXMsIGNvbnRleHRBdHRyaWJ1dGVzKSB7XG4gIGZ1bmN0aW9uIGdldCAobmFtZSkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gY2FudmFzLmdldENvbnRleHQobmFtZSwgY29udGV4dEF0dHJpYnV0ZXMpXG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG4gIH1cbiAgcmV0dXJuIChcbiAgICBnZXQoJ3dlYmdsJykgfHxcbiAgICBnZXQoJ2V4cGVyaW1lbnRhbC13ZWJnbCcpIHx8XG4gICAgZ2V0KCd3ZWJnbC1leHBlcmltZW50YWwnKVxuICApXG59XG5cbmZ1bmN0aW9uIGlzSFRNTEVsZW1lbnQgKG9iaikge1xuICByZXR1cm4gKFxuICAgIHR5cGVvZiBvYmoubm9kZU5hbWUgPT09ICdzdHJpbmcnICYmXG4gICAgdHlwZW9mIG9iai5hcHBlbmRDaGlsZCA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgIHR5cGVvZiBvYmouZ2V0Qm91bmRpbmdDbGllbnRSZWN0ID09PSAnZnVuY3Rpb24nXG4gIClcbn1cblxuZnVuY3Rpb24gaXNXZWJHTENvbnRleHQgKG9iaikge1xuICByZXR1cm4gKFxuICAgIHR5cGVvZiBvYmouZHJhd0FycmF5cyA9PT0gJ2Z1bmN0aW9uJyB8fFxuICAgIHR5cGVvZiBvYmouZHJhd0VsZW1lbnRzID09PSAnZnVuY3Rpb24nXG4gIClcbn1cblxuZnVuY3Rpb24gcGFyc2VFeHRlbnNpb25zIChpbnB1dCkge1xuICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBpbnB1dC5zcGxpdCgpXG4gIH1cbiAgY2hlY2skMShBcnJheS5pc0FycmF5KGlucHV0KSwgJ2ludmFsaWQgZXh0ZW5zaW9uIGFycmF5JylcbiAgcmV0dXJuIGlucHV0XG59XG5cbmZ1bmN0aW9uIGdldEVsZW1lbnQgKGRlc2MpIHtcbiAgaWYgKHR5cGVvZiBkZXNjID09PSAnc3RyaW5nJykge1xuICAgIGNoZWNrJDEodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJywgJ25vdCBzdXBwb3J0ZWQgb3V0c2lkZSBvZiBET00nKVxuICAgIHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGRlc2MpXG4gIH1cbiAgcmV0dXJuIGRlc2Ncbn1cblxuZnVuY3Rpb24gcGFyc2VBcmdzIChhcmdzXykge1xuICB2YXIgYXJncyA9IGFyZ3NfIHx8IHt9XG4gIHZhciBlbGVtZW50LCBjb250YWluZXIsIGNhbnZhcywgZ2xcbiAgdmFyIGNvbnRleHRBdHRyaWJ1dGVzID0ge31cbiAgdmFyIGV4dGVuc2lvbnMgPSBbXVxuICB2YXIgb3B0aW9uYWxFeHRlbnNpb25zID0gW11cbiAgdmFyIHBpeGVsUmF0aW8gPSAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgPyAxIDogd2luZG93LmRldmljZVBpeGVsUmF0aW8pXG4gIHZhciBwcm9maWxlID0gZmFsc2VcbiAgdmFyIG9uRG9uZSA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICBpZiAoZXJyKSB7XG4gICAgICBjaGVjayQxLnJhaXNlKGVycilcbiAgICB9XG4gIH1cbiAgdmFyIG9uRGVzdHJveSA9IGZ1bmN0aW9uICgpIHt9XG4gIGlmICh0eXBlb2YgYXJncyA9PT0gJ3N0cmluZycpIHtcbiAgICBjaGVjayQxKFxuICAgICAgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyxcbiAgICAgICdzZWxlY3RvciBxdWVyaWVzIG9ubHkgc3VwcG9ydGVkIGluIERPTSBlbnZpcm9tZW50cycpXG4gICAgZWxlbWVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoYXJncylcbiAgICBjaGVjayQxKGVsZW1lbnQsICdpbnZhbGlkIHF1ZXJ5IHN0cmluZyBmb3IgZWxlbWVudCcpXG4gIH0gZWxzZSBpZiAodHlwZW9mIGFyZ3MgPT09ICdvYmplY3QnKSB7XG4gICAgaWYgKGlzSFRNTEVsZW1lbnQoYXJncykpIHtcbiAgICAgIGVsZW1lbnQgPSBhcmdzXG4gICAgfSBlbHNlIGlmIChpc1dlYkdMQ29udGV4dChhcmdzKSkge1xuICAgICAgZ2wgPSBhcmdzXG4gICAgICBjYW52YXMgPSBnbC5jYW52YXNcbiAgICB9IGVsc2Uge1xuICAgICAgY2hlY2skMS5jb25zdHJ1Y3RvcihhcmdzKVxuICAgICAgaWYgKCdnbCcgaW4gYXJncykge1xuICAgICAgICBnbCA9IGFyZ3MuZ2xcbiAgICAgIH0gZWxzZSBpZiAoJ2NhbnZhcycgaW4gYXJncykge1xuICAgICAgICBjYW52YXMgPSBnZXRFbGVtZW50KGFyZ3MuY2FudmFzKVxuICAgICAgfSBlbHNlIGlmICgnY29udGFpbmVyJyBpbiBhcmdzKSB7XG4gICAgICAgIGNvbnRhaW5lciA9IGdldEVsZW1lbnQoYXJncy5jb250YWluZXIpXG4gICAgICB9XG4gICAgICBpZiAoJ2F0dHJpYnV0ZXMnIGluIGFyZ3MpIHtcbiAgICAgICAgY29udGV4dEF0dHJpYnV0ZXMgPSBhcmdzLmF0dHJpYnV0ZXNcbiAgICAgICAgY2hlY2skMS50eXBlKGNvbnRleHRBdHRyaWJ1dGVzLCAnb2JqZWN0JywgJ2ludmFsaWQgY29udGV4dCBhdHRyaWJ1dGVzJylcbiAgICAgIH1cbiAgICAgIGlmICgnZXh0ZW5zaW9ucycgaW4gYXJncykge1xuICAgICAgICBleHRlbnNpb25zID0gcGFyc2VFeHRlbnNpb25zKGFyZ3MuZXh0ZW5zaW9ucylcbiAgICAgIH1cbiAgICAgIGlmICgnb3B0aW9uYWxFeHRlbnNpb25zJyBpbiBhcmdzKSB7XG4gICAgICAgIG9wdGlvbmFsRXh0ZW5zaW9ucyA9IHBhcnNlRXh0ZW5zaW9ucyhhcmdzLm9wdGlvbmFsRXh0ZW5zaW9ucylcbiAgICAgIH1cbiAgICAgIGlmICgnb25Eb25lJyBpbiBhcmdzKSB7XG4gICAgICAgIGNoZWNrJDEudHlwZShcbiAgICAgICAgICBhcmdzLm9uRG9uZSwgJ2Z1bmN0aW9uJyxcbiAgICAgICAgICAnaW52YWxpZCBvciBtaXNzaW5nIG9uRG9uZSBjYWxsYmFjaycpXG4gICAgICAgIG9uRG9uZSA9IGFyZ3Mub25Eb25lXG4gICAgICB9XG4gICAgICBpZiAoJ3Byb2ZpbGUnIGluIGFyZ3MpIHtcbiAgICAgICAgcHJvZmlsZSA9ICEhYXJncy5wcm9maWxlXG4gICAgICB9XG4gICAgICBpZiAoJ3BpeGVsUmF0aW8nIGluIGFyZ3MpIHtcbiAgICAgICAgcGl4ZWxSYXRpbyA9ICthcmdzLnBpeGVsUmF0aW9cbiAgICAgICAgY2hlY2skMShwaXhlbFJhdGlvID4gMCwgJ2ludmFsaWQgcGl4ZWwgcmF0aW8nKVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBjaGVjayQxLnJhaXNlKCdpbnZhbGlkIGFyZ3VtZW50cyB0byByZWdsJylcbiAgfVxuXG4gIGlmIChlbGVtZW50KSB7XG4gICAgaWYgKGVsZW1lbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2NhbnZhcycpIHtcbiAgICAgIGNhbnZhcyA9IGVsZW1lbnRcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGFpbmVyID0gZWxlbWVudFxuICAgIH1cbiAgfVxuXG4gIGlmICghZ2wpIHtcbiAgICBpZiAoIWNhbnZhcykge1xuICAgICAgY2hlY2skMShcbiAgICAgICAgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyxcbiAgICAgICAgJ211c3QgbWFudWFsbHkgc3BlY2lmeSB3ZWJnbCBjb250ZXh0IG91dHNpZGUgb2YgRE9NIGVudmlyb25tZW50cycpXG4gICAgICB2YXIgcmVzdWx0ID0gY3JlYXRlQ2FudmFzKGNvbnRhaW5lciB8fCBkb2N1bWVudC5ib2R5LCBvbkRvbmUsIHBpeGVsUmF0aW8pXG4gICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgfVxuICAgICAgY2FudmFzID0gcmVzdWx0LmNhbnZhc1xuICAgICAgb25EZXN0cm95ID0gcmVzdWx0Lm9uRGVzdHJveVxuICAgIH1cbiAgICAvLyB3b3JrYXJvdW5kIGZvciBjaHJvbWl1bSBidWcsIHByZW11bHRpcGxpZWQgYWxwaGEgdmFsdWUgaXMgcGxhdGZvcm0gZGVwZW5kZW50XG4gICAgaWYgKGNvbnRleHRBdHRyaWJ1dGVzLnByZW11bHRpcGxpZWRBbHBoYSA9PT0gdW5kZWZpbmVkKSBjb250ZXh0QXR0cmlidXRlcy5wcmVtdWx0aXBsaWVkQWxwaGEgPSB0cnVlXG4gICAgZ2wgPSBjcmVhdGVDb250ZXh0KGNhbnZhcywgY29udGV4dEF0dHJpYnV0ZXMpXG4gIH1cblxuICBpZiAoIWdsKSB7XG4gICAgb25EZXN0cm95KClcbiAgICBvbkRvbmUoJ3dlYmdsIG5vdCBzdXBwb3J0ZWQsIHRyeSB1cGdyYWRpbmcgeW91ciBicm93c2VyIG9yIGdyYXBoaWNzIGRyaXZlcnMgaHR0cDovL2dldC53ZWJnbC5vcmcnKVxuICAgIHJldHVybiBudWxsXG4gIH1cblxuICByZXR1cm4ge1xuICAgIGdsOiBnbCxcbiAgICBjYW52YXM6IGNhbnZhcyxcbiAgICBjb250YWluZXI6IGNvbnRhaW5lcixcbiAgICBleHRlbnNpb25zOiBleHRlbnNpb25zLFxuICAgIG9wdGlvbmFsRXh0ZW5zaW9uczogb3B0aW9uYWxFeHRlbnNpb25zLFxuICAgIHBpeGVsUmF0aW86IHBpeGVsUmF0aW8sXG4gICAgcHJvZmlsZTogcHJvZmlsZSxcbiAgICBvbkRvbmU6IG9uRG9uZSxcbiAgICBvbkRlc3Ryb3k6IG9uRGVzdHJveVxuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUV4dGVuc2lvbkNhY2hlIChnbCwgY29uZmlnKSB7XG4gIHZhciBleHRlbnNpb25zID0ge31cblxuICBmdW5jdGlvbiB0cnlMb2FkRXh0ZW5zaW9uIChuYW1lXykge1xuICAgIGNoZWNrJDEudHlwZShuYW1lXywgJ3N0cmluZycsICdleHRlbnNpb24gbmFtZSBtdXN0IGJlIHN0cmluZycpXG4gICAgdmFyIG5hbWUgPSBuYW1lXy50b0xvd2VyQ2FzZSgpXG4gICAgdmFyIGV4dFxuICAgIHRyeSB7XG4gICAgICBleHQgPSBleHRlbnNpb25zW25hbWVdID0gZ2wuZ2V0RXh0ZW5zaW9uKG5hbWUpXG4gICAgfSBjYXRjaCAoZSkge31cbiAgICByZXR1cm4gISFleHRcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY29uZmlnLmV4dGVuc2lvbnMubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgbmFtZSA9IGNvbmZpZy5leHRlbnNpb25zW2ldXG4gICAgaWYgKCF0cnlMb2FkRXh0ZW5zaW9uKG5hbWUpKSB7XG4gICAgICBjb25maWcub25EZXN0cm95KClcbiAgICAgIGNvbmZpZy5vbkRvbmUoJ1wiJyArIG5hbWUgKyAnXCIgZXh0ZW5zaW9uIGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhlIGN1cnJlbnQgV2ViR0wgY29udGV4dCwgdHJ5IHVwZ3JhZGluZyB5b3VyIHN5c3RlbSBvciBhIGRpZmZlcmVudCBicm93c2VyJylcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuICB9XG5cbiAgY29uZmlnLm9wdGlvbmFsRXh0ZW5zaW9ucy5mb3JFYWNoKHRyeUxvYWRFeHRlbnNpb24pXG5cbiAgcmV0dXJuIHtcbiAgICBleHRlbnNpb25zOiBleHRlbnNpb25zLFxuICAgIHJlc3RvcmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIE9iamVjdC5rZXlzKGV4dGVuc2lvbnMpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgaWYgKGV4dGVuc2lvbnNbbmFtZV0gJiYgIXRyeUxvYWRFeHRlbnNpb24obmFtZSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJyhyZWdsKTogZXJyb3IgcmVzdG9yaW5nIGV4dGVuc2lvbiAnICsgbmFtZSlcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gbG9vcCAobiwgZikge1xuICB2YXIgcmVzdWx0ID0gQXJyYXkobilcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICByZXN1bHRbaV0gPSBmKGkpXG4gIH1cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG52YXIgR0xfQllURSQxID0gNTEyMFxudmFyIEdMX1VOU0lHTkVEX0JZVEUkMiA9IDUxMjFcbnZhciBHTF9TSE9SVCQxID0gNTEyMlxudmFyIEdMX1VOU0lHTkVEX1NIT1JUJDEgPSA1MTIzXG52YXIgR0xfSU5UJDEgPSA1MTI0XG52YXIgR0xfVU5TSUdORURfSU5UJDEgPSA1MTI1XG52YXIgR0xfRkxPQVQkMiA9IDUxMjZcblxuZnVuY3Rpb24gbmV4dFBvdzE2ICh2KSB7XG4gIGZvciAodmFyIGkgPSAxNjsgaSA8PSAoMSA8PCAyOCk7IGkgKj0gMTYpIHtcbiAgICBpZiAodiA8PSBpKSB7XG4gICAgICByZXR1cm4gaVxuICAgIH1cbiAgfVxuICByZXR1cm4gMFxufVxuXG5mdW5jdGlvbiBsb2cyICh2KSB7XG4gIHZhciByLCBzaGlmdFxuICByID0gKHYgPiAweEZGRkYpIDw8IDRcbiAgdiA+Pj49IHJcbiAgc2hpZnQgPSAodiA+IDB4RkYpIDw8IDNcbiAgdiA+Pj49IHNoaWZ0OyByIHw9IHNoaWZ0XG4gIHNoaWZ0ID0gKHYgPiAweEYpIDw8IDJcbiAgdiA+Pj49IHNoaWZ0OyByIHw9IHNoaWZ0XG4gIHNoaWZ0ID0gKHYgPiAweDMpIDw8IDFcbiAgdiA+Pj49IHNoaWZ0OyByIHw9IHNoaWZ0XG4gIHJldHVybiByIHwgKHYgPj4gMSlcbn1cblxuZnVuY3Rpb24gY3JlYXRlUG9vbCAoKSB7XG4gIHZhciBidWZmZXJQb29sID0gbG9vcCg4LCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFtdXG4gIH0pXG5cbiAgZnVuY3Rpb24gYWxsb2MgKG4pIHtcbiAgICB2YXIgc3ogPSBuZXh0UG93MTYobilcbiAgICB2YXIgYmluID0gYnVmZmVyUG9vbFtsb2cyKHN6KSA+PiAyXVxuICAgIGlmIChiaW4ubGVuZ3RoID4gMCkge1xuICAgICAgcmV0dXJuIGJpbi5wb3AoKVxuICAgIH1cbiAgICByZXR1cm4gbmV3IEFycmF5QnVmZmVyKHN6KVxuICB9XG5cbiAgZnVuY3Rpb24gZnJlZSAoYnVmKSB7XG4gICAgYnVmZmVyUG9vbFtsb2cyKGJ1Zi5ieXRlTGVuZ3RoKSA+PiAyXS5wdXNoKGJ1ZilcbiAgfVxuXG4gIGZ1bmN0aW9uIGFsbG9jVHlwZSAodHlwZSwgbikge1xuICAgIHZhciByZXN1bHQgPSBudWxsXG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlIEdMX0JZVEUkMTpcbiAgICAgICAgcmVzdWx0ID0gbmV3IEludDhBcnJheShhbGxvYyhuKSwgMCwgbilcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgR0xfVU5TSUdORURfQllURSQyOlxuICAgICAgICByZXN1bHQgPSBuZXcgVWludDhBcnJheShhbGxvYyhuKSwgMCwgbilcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgR0xfU0hPUlQkMTpcbiAgICAgICAgcmVzdWx0ID0gbmV3IEludDE2QXJyYXkoYWxsb2MoMiAqIG4pLCAwLCBuKVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSBHTF9VTlNJR05FRF9TSE9SVCQxOlxuICAgICAgICByZXN1bHQgPSBuZXcgVWludDE2QXJyYXkoYWxsb2MoMiAqIG4pLCAwLCBuKVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSBHTF9JTlQkMTpcbiAgICAgICAgcmVzdWx0ID0gbmV3IEludDMyQXJyYXkoYWxsb2MoNCAqIG4pLCAwLCBuKVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSBHTF9VTlNJR05FRF9JTlQkMTpcbiAgICAgICAgcmVzdWx0ID0gbmV3IFVpbnQzMkFycmF5KGFsbG9jKDQgKiBuKSwgMCwgbilcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgR0xfRkxPQVQkMjpcbiAgICAgICAgcmVzdWx0ID0gbmV3IEZsb2F0MzJBcnJheShhbGxvYyg0ICogbiksIDAsIG4pXG4gICAgICAgIGJyZWFrXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gbnVsbFxuICAgIH1cbiAgICBpZiAocmVzdWx0Lmxlbmd0aCAhPT0gbikge1xuICAgICAgcmV0dXJuIHJlc3VsdC5zdWJhcnJheSgwLCBuKVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cblxuICBmdW5jdGlvbiBmcmVlVHlwZSAoYXJyYXkpIHtcbiAgICBmcmVlKGFycmF5LmJ1ZmZlcilcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgYWxsb2M6IGFsbG9jLFxuICAgIGZyZWU6IGZyZWUsXG4gICAgYWxsb2NUeXBlOiBhbGxvY1R5cGUsXG4gICAgZnJlZVR5cGU6IGZyZWVUeXBlXG4gIH1cbn1cblxudmFyIHBvb2wgPSBjcmVhdGVQb29sKClcblxuLy8gemVybyBwb29sIGZvciBpbml0aWFsIHplcm8gZGF0YVxucG9vbC56ZXJvID0gY3JlYXRlUG9vbCgpXG5cbnZhciBHTF9TVUJQSVhFTF9CSVRTID0gMHgwRDUwXG52YXIgR0xfUkVEX0JJVFMgPSAweDBENTJcbnZhciBHTF9HUkVFTl9CSVRTID0gMHgwRDUzXG52YXIgR0xfQkxVRV9CSVRTID0gMHgwRDU0XG52YXIgR0xfQUxQSEFfQklUUyA9IDB4MEQ1NVxudmFyIEdMX0RFUFRIX0JJVFMgPSAweDBENTZcbnZhciBHTF9TVEVOQ0lMX0JJVFMgPSAweDBENTdcblxudmFyIEdMX0FMSUFTRURfUE9JTlRfU0laRV9SQU5HRSA9IDB4ODQ2RFxudmFyIEdMX0FMSUFTRURfTElORV9XSURUSF9SQU5HRSA9IDB4ODQ2RVxuXG52YXIgR0xfTUFYX1RFWFRVUkVfU0laRSA9IDB4MEQzM1xudmFyIEdMX01BWF9WSUVXUE9SVF9ESU1TID0gMHgwRDNBXG52YXIgR0xfTUFYX1ZFUlRFWF9BVFRSSUJTID0gMHg4ODY5XG52YXIgR0xfTUFYX1ZFUlRFWF9VTklGT1JNX1ZFQ1RPUlMgPSAweDhERkJcbnZhciBHTF9NQVhfVkFSWUlOR19WRUNUT1JTID0gMHg4REZDXG52YXIgR0xfTUFYX0NPTUJJTkVEX1RFWFRVUkVfSU1BR0VfVU5JVFMgPSAweDhCNERcbnZhciBHTF9NQVhfVkVSVEVYX1RFWFRVUkVfSU1BR0VfVU5JVFMgPSAweDhCNENcbnZhciBHTF9NQVhfVEVYVFVSRV9JTUFHRV9VTklUUyA9IDB4ODg3MlxudmFyIEdMX01BWF9GUkFHTUVOVF9VTklGT1JNX1ZFQ1RPUlMgPSAweDhERkRcbnZhciBHTF9NQVhfQ1VCRV9NQVBfVEVYVFVSRV9TSVpFID0gMHg4NTFDXG52YXIgR0xfTUFYX1JFTkRFUkJVRkZFUl9TSVpFID0gMHg4NEU4XG5cbnZhciBHTF9WRU5ET1IgPSAweDFGMDBcbnZhciBHTF9SRU5ERVJFUiA9IDB4MUYwMVxudmFyIEdMX1ZFUlNJT04gPSAweDFGMDJcbnZhciBHTF9TSEFESU5HX0xBTkdVQUdFX1ZFUlNJT04gPSAweDhCOENcblxudmFyIEdMX01BWF9URVhUVVJFX01BWF9BTklTT1RST1BZX0VYVCA9IDB4ODRGRlxuXG52YXIgR0xfTUFYX0NPTE9SX0FUVEFDSE1FTlRTX1dFQkdMID0gMHg4Q0RGXG52YXIgR0xfTUFYX0RSQVdfQlVGRkVSU19XRUJHTCA9IDB4ODgyNFxuXG52YXIgR0xfVEVYVFVSRV8yRCA9IDB4MERFMVxudmFyIEdMX1RFWFRVUkVfQ1VCRV9NQVAgPSAweDg1MTNcbnZhciBHTF9URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1ggPSAweDg1MTVcbnZhciBHTF9URVhUVVJFMCA9IDB4ODRDMFxudmFyIEdMX1JHQkEgPSAweDE5MDhcbnZhciBHTF9GTE9BVCQxID0gMHgxNDA2XG52YXIgR0xfVU5TSUdORURfQllURSQxID0gMHgxNDAxXG52YXIgR0xfRlJBTUVCVUZGRVIgPSAweDhENDBcbnZhciBHTF9GUkFNRUJVRkZFUl9DT01QTEVURSA9IDB4OENENVxudmFyIEdMX0NPTE9SX0FUVEFDSE1FTlQwID0gMHg4Q0UwXG52YXIgR0xfQ09MT1JfQlVGRkVSX0JJVCQxID0gMHg0MDAwXG5cbnZhciB3cmFwTGltaXRzID0gZnVuY3Rpb24gKGdsLCBleHRlbnNpb25zKSB7XG4gIHZhciBtYXhBbmlzb3Ryb3BpYyA9IDFcbiAgaWYgKGV4dGVuc2lvbnMuZXh0X3RleHR1cmVfZmlsdGVyX2FuaXNvdHJvcGljKSB7XG4gICAgbWF4QW5pc290cm9waWMgPSBnbC5nZXRQYXJhbWV0ZXIoR0xfTUFYX1RFWFRVUkVfTUFYX0FOSVNPVFJPUFlfRVhUKVxuICB9XG5cbiAgdmFyIG1heERyYXdidWZmZXJzID0gMVxuICB2YXIgbWF4Q29sb3JBdHRhY2htZW50cyA9IDFcbiAgaWYgKGV4dGVuc2lvbnMud2ViZ2xfZHJhd19idWZmZXJzKSB7XG4gICAgbWF4RHJhd2J1ZmZlcnMgPSBnbC5nZXRQYXJhbWV0ZXIoR0xfTUFYX0RSQVdfQlVGRkVSU19XRUJHTClcbiAgICBtYXhDb2xvckF0dGFjaG1lbnRzID0gZ2wuZ2V0UGFyYW1ldGVyKEdMX01BWF9DT0xPUl9BVFRBQ0hNRU5UU19XRUJHTClcbiAgfVxuXG4gIC8vIGRldGVjdCBpZiByZWFkaW5nIGZsb2F0IHRleHR1cmVzIGlzIGF2YWlsYWJsZSAoU2FmYXJpIGRvZXNuJ3Qgc3VwcG9ydClcbiAgdmFyIHJlYWRGbG9hdCA9ICEhZXh0ZW5zaW9ucy5vZXNfdGV4dHVyZV9mbG9hdFxuICBpZiAocmVhZEZsb2F0KSB7XG4gICAgdmFyIHJlYWRGbG9hdFRleHR1cmUgPSBnbC5jcmVhdGVUZXh0dXJlKClcbiAgICBnbC5iaW5kVGV4dHVyZShHTF9URVhUVVJFXzJELCByZWFkRmxvYXRUZXh0dXJlKVxuICAgIGdsLnRleEltYWdlMkQoR0xfVEVYVFVSRV8yRCwgMCwgR0xfUkdCQSwgMSwgMSwgMCwgR0xfUkdCQSwgR0xfRkxPQVQkMSwgbnVsbClcblxuICAgIHZhciBmYm8gPSBnbC5jcmVhdGVGcmFtZWJ1ZmZlcigpXG4gICAgZ2wuYmluZEZyYW1lYnVmZmVyKEdMX0ZSQU1FQlVGRkVSLCBmYm8pXG4gICAgZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoR0xfRlJBTUVCVUZGRVIsIEdMX0NPTE9SX0FUVEFDSE1FTlQwLCBHTF9URVhUVVJFXzJELCByZWFkRmxvYXRUZXh0dXJlLCAwKVxuICAgIGdsLmJpbmRUZXh0dXJlKEdMX1RFWFRVUkVfMkQsIG51bGwpXG5cbiAgICBpZiAoZ2wuY2hlY2tGcmFtZWJ1ZmZlclN0YXR1cyhHTF9GUkFNRUJVRkZFUikgIT09IEdMX0ZSQU1FQlVGRkVSX0NPTVBMRVRFKSByZWFkRmxvYXQgPSBmYWxzZVxuXG4gICAgZWxzZSB7XG4gICAgICBnbC52aWV3cG9ydCgwLCAwLCAxLCAxKVxuICAgICAgZ2wuY2xlYXJDb2xvcigxLjAsIDAuMCwgMC4wLCAxLjApXG4gICAgICBnbC5jbGVhcihHTF9DT0xPUl9CVUZGRVJfQklUJDEpXG4gICAgICB2YXIgcGl4ZWxzID0gcG9vbC5hbGxvY1R5cGUoR0xfRkxPQVQkMSwgNClcbiAgICAgIGdsLnJlYWRQaXhlbHMoMCwgMCwgMSwgMSwgR0xfUkdCQSwgR0xfRkxPQVQkMSwgcGl4ZWxzKVxuXG4gICAgICBpZiAoZ2wuZ2V0RXJyb3IoKSkgcmVhZEZsb2F0ID0gZmFsc2VcbiAgICAgIGVsc2Uge1xuICAgICAgICBnbC5kZWxldGVGcmFtZWJ1ZmZlcihmYm8pXG4gICAgICAgIGdsLmRlbGV0ZVRleHR1cmUocmVhZEZsb2F0VGV4dHVyZSlcblxuICAgICAgICByZWFkRmxvYXQgPSBwaXhlbHNbMF0gPT09IDEuMFxuICAgICAgfVxuXG4gICAgICBwb29sLmZyZWVUeXBlKHBpeGVscylcbiAgICB9XG4gIH1cblxuICAvLyBkZXRlY3Qgbm9uIHBvd2VyIG9mIHR3byBjdWJlIHRleHR1cmVzIHN1cHBvcnQgKElFIGRvZXNuJ3Qgc3VwcG9ydClcbiAgdmFyIGlzSUUgPSB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiAoL01TSUUvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgfHwgL1RyaWRlbnRcXC8vLnRlc3QobmF2aWdhdG9yLmFwcFZlcnNpb24pIHx8IC9FZGdlLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpKVxuXG4gIHZhciBucG90VGV4dHVyZUN1YmUgPSB0cnVlXG5cbiAgaWYgKCFpc0lFKSB7XG4gICAgdmFyIGN1YmVUZXh0dXJlID0gZ2wuY3JlYXRlVGV4dHVyZSgpXG4gICAgdmFyIGRhdGEgPSBwb29sLmFsbG9jVHlwZShHTF9VTlNJR05FRF9CWVRFJDEsIDM2KVxuICAgIGdsLmFjdGl2ZVRleHR1cmUoR0xfVEVYVFVSRTApXG4gICAgZ2wuYmluZFRleHR1cmUoR0xfVEVYVFVSRV9DVUJFX01BUCwgY3ViZVRleHR1cmUpXG4gICAgZ2wudGV4SW1hZ2UyRChHTF9URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1gsIDAsIEdMX1JHQkEsIDMsIDMsIDAsIEdMX1JHQkEsIEdMX1VOU0lHTkVEX0JZVEUkMSwgZGF0YSlcbiAgICBwb29sLmZyZWVUeXBlKGRhdGEpXG4gICAgZ2wuYmluZFRleHR1cmUoR0xfVEVYVFVSRV9DVUJFX01BUCwgbnVsbClcbiAgICBnbC5kZWxldGVUZXh0dXJlKGN1YmVUZXh0dXJlKVxuICAgIG5wb3RUZXh0dXJlQ3ViZSA9ICFnbC5nZXRFcnJvcigpXG4gIH1cblxuICByZXR1cm4ge1xuICAgIC8vIGRyYXdpbmcgYnVmZmVyIGJpdCBkZXB0aFxuICAgIGNvbG9yQml0czogW1xuICAgICAgZ2wuZ2V0UGFyYW1ldGVyKEdMX1JFRF9CSVRTKSxcbiAgICAgIGdsLmdldFBhcmFtZXRlcihHTF9HUkVFTl9CSVRTKSxcbiAgICAgIGdsLmdldFBhcmFtZXRlcihHTF9CTFVFX0JJVFMpLFxuICAgICAgZ2wuZ2V0UGFyYW1ldGVyKEdMX0FMUEhBX0JJVFMpXG4gICAgXSxcbiAgICBkZXB0aEJpdHM6IGdsLmdldFBhcmFtZXRlcihHTF9ERVBUSF9CSVRTKSxcbiAgICBzdGVuY2lsQml0czogZ2wuZ2V0UGFyYW1ldGVyKEdMX1NURU5DSUxfQklUUyksXG4gICAgc3VicGl4ZWxCaXRzOiBnbC5nZXRQYXJhbWV0ZXIoR0xfU1VCUElYRUxfQklUUyksXG5cbiAgICAvLyBzdXBwb3J0ZWQgZXh0ZW5zaW9uc1xuICAgIGV4dGVuc2lvbnM6IE9iamVjdC5rZXlzKGV4dGVuc2lvbnMpLmZpbHRlcihmdW5jdGlvbiAoZXh0KSB7XG4gICAgICByZXR1cm4gISFleHRlbnNpb25zW2V4dF1cbiAgICB9KSxcblxuICAgIC8vIG1heCBhbmlzbyBzYW1wbGVzXG4gICAgbWF4QW5pc290cm9waWM6IG1heEFuaXNvdHJvcGljLFxuXG4gICAgLy8gbWF4IGRyYXcgYnVmZmVyc1xuICAgIG1heERyYXdidWZmZXJzOiBtYXhEcmF3YnVmZmVycyxcbiAgICBtYXhDb2xvckF0dGFjaG1lbnRzOiBtYXhDb2xvckF0dGFjaG1lbnRzLFxuXG4gICAgLy8gcG9pbnQgYW5kIGxpbmUgc2l6ZSByYW5nZXNcbiAgICBwb2ludFNpemVEaW1zOiBnbC5nZXRQYXJhbWV0ZXIoR0xfQUxJQVNFRF9QT0lOVF9TSVpFX1JBTkdFKSxcbiAgICBsaW5lV2lkdGhEaW1zOiBnbC5nZXRQYXJhbWV0ZXIoR0xfQUxJQVNFRF9MSU5FX1dJRFRIX1JBTkdFKSxcbiAgICBtYXhWaWV3cG9ydERpbXM6IGdsLmdldFBhcmFtZXRlcihHTF9NQVhfVklFV1BPUlRfRElNUyksXG4gICAgbWF4Q29tYmluZWRUZXh0dXJlVW5pdHM6IGdsLmdldFBhcmFtZXRlcihHTF9NQVhfQ09NQklORURfVEVYVFVSRV9JTUFHRV9VTklUUyksXG4gICAgbWF4Q3ViZU1hcFNpemU6IGdsLmdldFBhcmFtZXRlcihHTF9NQVhfQ1VCRV9NQVBfVEVYVFVSRV9TSVpFKSxcbiAgICBtYXhSZW5kZXJidWZmZXJTaXplOiBnbC5nZXRQYXJhbWV0ZXIoR0xfTUFYX1JFTkRFUkJVRkZFUl9TSVpFKSxcbiAgICBtYXhUZXh0dXJlVW5pdHM6IGdsLmdldFBhcmFtZXRlcihHTF9NQVhfVEVYVFVSRV9JTUFHRV9VTklUUyksXG4gICAgbWF4VGV4dHVyZVNpemU6IGdsLmdldFBhcmFtZXRlcihHTF9NQVhfVEVYVFVSRV9TSVpFKSxcbiAgICBtYXhBdHRyaWJ1dGVzOiBnbC5nZXRQYXJhbWV0ZXIoR0xfTUFYX1ZFUlRFWF9BVFRSSUJTKSxcbiAgICBtYXhWZXJ0ZXhVbmlmb3JtczogZ2wuZ2V0UGFyYW1ldGVyKEdMX01BWF9WRVJURVhfVU5JRk9STV9WRUNUT1JTKSxcbiAgICBtYXhWZXJ0ZXhUZXh0dXJlVW5pdHM6IGdsLmdldFBhcmFtZXRlcihHTF9NQVhfVkVSVEVYX1RFWFRVUkVfSU1BR0VfVU5JVFMpLFxuICAgIG1heFZhcnlpbmdWZWN0b3JzOiBnbC5nZXRQYXJhbWV0ZXIoR0xfTUFYX1ZBUllJTkdfVkVDVE9SUyksXG4gICAgbWF4RnJhZ21lbnRVbmlmb3JtczogZ2wuZ2V0UGFyYW1ldGVyKEdMX01BWF9GUkFHTUVOVF9VTklGT1JNX1ZFQ1RPUlMpLFxuXG4gICAgLy8gdmVuZG9yIGluZm9cbiAgICBnbHNsOiBnbC5nZXRQYXJhbWV0ZXIoR0xfU0hBRElOR19MQU5HVUFHRV9WRVJTSU9OKSxcbiAgICByZW5kZXJlcjogZ2wuZ2V0UGFyYW1ldGVyKEdMX1JFTkRFUkVSKSxcbiAgICB2ZW5kb3I6IGdsLmdldFBhcmFtZXRlcihHTF9WRU5ET1IpLFxuICAgIHZlcnNpb246IGdsLmdldFBhcmFtZXRlcihHTF9WRVJTSU9OKSxcblxuICAgIC8vIHF1aXJrc1xuICAgIHJlYWRGbG9hdDogcmVhZEZsb2F0LFxuICAgIG5wb3RUZXh0dXJlQ3ViZTogbnBvdFRleHR1cmVDdWJlXG4gIH1cbn1cblxuZnVuY3Rpb24gaXNOREFycmF5TGlrZSAob2JqKSB7XG4gIHJldHVybiAoXG4gICAgISFvYmogJiZcbiAgICB0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJlxuICAgIEFycmF5LmlzQXJyYXkob2JqLnNoYXBlKSAmJlxuICAgIEFycmF5LmlzQXJyYXkob2JqLnN0cmlkZSkgJiZcbiAgICB0eXBlb2Ygb2JqLm9mZnNldCA9PT0gJ251bWJlcicgJiZcbiAgICBvYmouc2hhcGUubGVuZ3RoID09PSBvYmouc3RyaWRlLmxlbmd0aCAmJlxuICAgIChBcnJheS5pc0FycmF5KG9iai5kYXRhKSB8fFxuICAgICAgaXNUeXBlZEFycmF5KG9iai5kYXRhKSkpXG59XG5cbnZhciB2YWx1ZXMgPSBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyhvYmopLm1hcChmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBvYmpba2V5XSB9KVxufVxuXG52YXIgZmxhdHRlblV0aWxzID0ge1xuICBzaGFwZTogYXJyYXlTaGFwZSQxLFxuICBmbGF0dGVuOiBmbGF0dGVuQXJyYXlcbn07XG5cbmZ1bmN0aW9uIGZsYXR0ZW4xRCAoYXJyYXksIG54LCBvdXQpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBueDsgKytpKSB7XG4gICAgb3V0W2ldID0gYXJyYXlbaV1cbiAgfVxufVxuXG5mdW5jdGlvbiBmbGF0dGVuMkQgKGFycmF5LCBueCwgbnksIG91dCkge1xuICB2YXIgcHRyID0gMFxuICBmb3IgKHZhciBpID0gMDsgaSA8IG54OyArK2kpIHtcbiAgICB2YXIgcm93ID0gYXJyYXlbaV1cbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IG55OyArK2opIHtcbiAgICAgIG91dFtwdHIrK10gPSByb3dbal1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZmxhdHRlbjNEIChhcnJheSwgbngsIG55LCBueiwgb3V0LCBwdHJfKSB7XG4gIHZhciBwdHIgPSBwdHJfXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbng7ICsraSkge1xuICAgIHZhciByb3cgPSBhcnJheVtpXVxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgbnk7ICsraikge1xuICAgICAgdmFyIGNvbCA9IHJvd1tqXVxuICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBuejsgKytrKSB7XG4gICAgICAgIG91dFtwdHIrK10gPSBjb2xba11cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZmxhdHRlblJlYyAoYXJyYXksIHNoYXBlLCBsZXZlbCwgb3V0LCBwdHIpIHtcbiAgdmFyIHN0cmlkZSA9IDFcbiAgZm9yICh2YXIgaSA9IGxldmVsICsgMTsgaSA8IHNoYXBlLmxlbmd0aDsgKytpKSB7XG4gICAgc3RyaWRlICo9IHNoYXBlW2ldXG4gIH1cbiAgdmFyIG4gPSBzaGFwZVtsZXZlbF1cbiAgaWYgKHNoYXBlLmxlbmd0aCAtIGxldmVsID09PSA0KSB7XG4gICAgdmFyIG54ID0gc2hhcGVbbGV2ZWwgKyAxXVxuICAgIHZhciBueSA9IHNoYXBlW2xldmVsICsgMl1cbiAgICB2YXIgbnogPSBzaGFwZVtsZXZlbCArIDNdXG4gICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgZmxhdHRlbjNEKGFycmF5W2ldLCBueCwgbnksIG56LCBvdXQsIHB0cilcbiAgICAgIHB0ciArPSBzdHJpZGVcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgZmxhdHRlblJlYyhhcnJheVtpXSwgc2hhcGUsIGxldmVsICsgMSwgb3V0LCBwdHIpXG4gICAgICBwdHIgKz0gc3RyaWRlXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGZsYXR0ZW5BcnJheSAoYXJyYXksIHNoYXBlLCB0eXBlLCBvdXRfKSB7XG4gIHZhciBzeiA9IDFcbiAgaWYgKHNoYXBlLmxlbmd0aCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2hhcGUubGVuZ3RoOyArK2kpIHtcbiAgICAgIHN6ICo9IHNoYXBlW2ldXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHN6ID0gMFxuICB9XG4gIHZhciBvdXQgPSBvdXRfIHx8IHBvb2wuYWxsb2NUeXBlKHR5cGUsIHN6KVxuICBzd2l0Y2ggKHNoYXBlLmxlbmd0aCkge1xuICAgIGNhc2UgMDpcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAxOlxuICAgICAgZmxhdHRlbjFEKGFycmF5LCBzaGFwZVswXSwgb3V0KVxuICAgICAgYnJlYWtcbiAgICBjYXNlIDI6XG4gICAgICBmbGF0dGVuMkQoYXJyYXksIHNoYXBlWzBdLCBzaGFwZVsxXSwgb3V0KVxuICAgICAgYnJlYWtcbiAgICBjYXNlIDM6XG4gICAgICBmbGF0dGVuM0QoYXJyYXksIHNoYXBlWzBdLCBzaGFwZVsxXSwgc2hhcGVbMl0sIG91dCwgMClcbiAgICAgIGJyZWFrXG4gICAgZGVmYXVsdDpcbiAgICAgIGZsYXR0ZW5SZWMoYXJyYXksIHNoYXBlLCAwLCBvdXQsIDApXG4gIH1cbiAgcmV0dXJuIG91dFxufVxuXG5mdW5jdGlvbiBhcnJheVNoYXBlJDEgKGFycmF5Xykge1xuICB2YXIgc2hhcGUgPSBbXVxuICBmb3IgKHZhciBhcnJheSA9IGFycmF5XzsgYXJyYXkubGVuZ3RoOyBhcnJheSA9IGFycmF5WzBdKSB7XG4gICAgc2hhcGUucHVzaChhcnJheS5sZW5ndGgpXG4gIH1cbiAgcmV0dXJuIHNoYXBlXG59XG5cbnZhciBhcnJheVR5cGVzID0gIHtcblx0XCJbb2JqZWN0IEludDhBcnJheV1cIjogNTEyMCxcblx0XCJbb2JqZWN0IEludDE2QXJyYXldXCI6IDUxMjIsXG5cdFwiW29iamVjdCBJbnQzMkFycmF5XVwiOiA1MTI0LFxuXHRcIltvYmplY3QgVWludDhBcnJheV1cIjogNTEyMSxcblx0XCJbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XVwiOiA1MTIxLFxuXHRcIltvYmplY3QgVWludDE2QXJyYXldXCI6IDUxMjMsXG5cdFwiW29iamVjdCBVaW50MzJBcnJheV1cIjogNTEyNSxcblx0XCJbb2JqZWN0IEZsb2F0MzJBcnJheV1cIjogNTEyNixcblx0XCJbb2JqZWN0IEZsb2F0NjRBcnJheV1cIjogNTEyMSxcblx0XCJbb2JqZWN0IEFycmF5QnVmZmVyXVwiOiA1MTIxXG59O1xuXG52YXIgaW50OCA9IDUxMjA7XG52YXIgaW50MTYgPSA1MTIyO1xudmFyIGludDMyID0gNTEyNDtcbnZhciB1aW50OCA9IDUxMjE7XG52YXIgdWludDE2ID0gNTEyMztcbnZhciB1aW50MzIgPSA1MTI1O1xudmFyIGZsb2F0ID0gNTEyNjtcbnZhciBmbG9hdDMyID0gNTEyNjtcbnZhciBnbFR5cGVzID0ge1xuXHRpbnQ4OiBpbnQ4LFxuXHRpbnQxNjogaW50MTYsXG5cdGludDMyOiBpbnQzMixcblx0dWludDg6IHVpbnQ4LFxuXHR1aW50MTY6IHVpbnQxNixcblx0dWludDMyOiB1aW50MzIsXG5cdGZsb2F0OiBmbG9hdCxcblx0ZmxvYXQzMjogZmxvYXQzMlxufTtcblxudmFyIGR5bmFtaWMkMSA9IDM1MDQ4O1xudmFyIHN0cmVhbSA9IDM1MDQwO1xudmFyIHVzYWdlVHlwZXMgPSB7XG5cdGR5bmFtaWM6IGR5bmFtaWMkMSxcblx0c3RyZWFtOiBzdHJlYW0sXG5cdFwic3RhdGljXCI6IDM1MDQ0XG59O1xuXG52YXIgYXJyYXlGbGF0dGVuID0gZmxhdHRlblV0aWxzLmZsYXR0ZW5cbnZhciBhcnJheVNoYXBlID0gZmxhdHRlblV0aWxzLnNoYXBlXG5cbnZhciBHTF9TVEFUSUNfRFJBVyA9IDB4ODhFNFxudmFyIEdMX1NUUkVBTV9EUkFXID0gMHg4OEUwXG5cbnZhciBHTF9VTlNJR05FRF9CWVRFJDMgPSA1MTIxXG52YXIgR0xfRkxPQVQkMyA9IDUxMjZcblxudmFyIERUWVBFU19TSVpFUyA9IFtdXG5EVFlQRVNfU0laRVNbNTEyMF0gPSAxIC8vIGludDhcbkRUWVBFU19TSVpFU1s1MTIyXSA9IDIgLy8gaW50MTZcbkRUWVBFU19TSVpFU1s1MTI0XSA9IDQgLy8gaW50MzJcbkRUWVBFU19TSVpFU1s1MTIxXSA9IDEgLy8gdWludDhcbkRUWVBFU19TSVpFU1s1MTIzXSA9IDIgLy8gdWludDE2XG5EVFlQRVNfU0laRVNbNTEyNV0gPSA0IC8vIHVpbnQzMlxuRFRZUEVTX1NJWkVTWzUxMjZdID0gNCAvLyBmbG9hdDMyXG5cbmZ1bmN0aW9uIHR5cGVkQXJyYXlDb2RlIChkYXRhKSB7XG4gIHJldHVybiBhcnJheVR5cGVzW09iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChkYXRhKV0gfCAwXG59XG5cbmZ1bmN0aW9uIGNvcHlBcnJheSAob3V0LCBpbnApIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbnAubGVuZ3RoOyArK2kpIHtcbiAgICBvdXRbaV0gPSBpbnBbaV1cbiAgfVxufVxuXG5mdW5jdGlvbiB0cmFuc3Bvc2UgKFxuICByZXN1bHQsIGRhdGEsIHNoYXBlWCwgc2hhcGVZLCBzdHJpZGVYLCBzdHJpZGVZLCBvZmZzZXQpIHtcbiAgdmFyIHB0ciA9IDBcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaGFwZVg7ICsraSkge1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgc2hhcGVZOyArK2opIHtcbiAgICAgIHJlc3VsdFtwdHIrK10gPSBkYXRhW3N0cmlkZVggKiBpICsgc3RyaWRlWSAqIGogKyBvZmZzZXRdXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHdyYXBCdWZmZXJTdGF0ZSAoZ2wsIHN0YXRzLCBjb25maWcsIGRlc3Ryb3lCdWZmZXIpIHtcbiAgdmFyIGJ1ZmZlckNvdW50ID0gMFxuICB2YXIgYnVmZmVyU2V0ID0ge31cblxuICBmdW5jdGlvbiBSRUdMQnVmZmVyICh0eXBlKSB7XG4gICAgdGhpcy5pZCA9IGJ1ZmZlckNvdW50KytcbiAgICB0aGlzLmJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpXG4gICAgdGhpcy50eXBlID0gdHlwZVxuICAgIHRoaXMudXNhZ2UgPSBHTF9TVEFUSUNfRFJBV1xuICAgIHRoaXMuYnl0ZUxlbmd0aCA9IDBcbiAgICB0aGlzLmRpbWVuc2lvbiA9IDFcbiAgICB0aGlzLmR0eXBlID0gR0xfVU5TSUdORURfQllURSQzXG5cbiAgICB0aGlzLnBlcnNpc3RlbnREYXRhID0gbnVsbFxuXG4gICAgaWYgKGNvbmZpZy5wcm9maWxlKSB7XG4gICAgICB0aGlzLnN0YXRzID0geyBzaXplOiAwIH1cbiAgICB9XG4gIH1cblxuICBSRUdMQnVmZmVyLnByb3RvdHlwZS5iaW5kID0gZnVuY3Rpb24gKCkge1xuICAgIGdsLmJpbmRCdWZmZXIodGhpcy50eXBlLCB0aGlzLmJ1ZmZlcilcbiAgfVxuXG4gIFJFR0xCdWZmZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgZGVzdHJveSh0aGlzKVxuICB9XG5cbiAgdmFyIHN0cmVhbVBvb2wgPSBbXVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVN0cmVhbSAodHlwZSwgZGF0YSkge1xuICAgIHZhciBidWZmZXIgPSBzdHJlYW1Qb29sLnBvcCgpXG4gICAgaWYgKCFidWZmZXIpIHtcbiAgICAgIGJ1ZmZlciA9IG5ldyBSRUdMQnVmZmVyKHR5cGUpXG4gICAgfVxuICAgIGJ1ZmZlci5iaW5kKClcbiAgICBpbml0QnVmZmVyRnJvbURhdGEoYnVmZmVyLCBkYXRhLCBHTF9TVFJFQU1fRFJBVywgMCwgMSwgZmFsc2UpXG4gICAgcmV0dXJuIGJ1ZmZlclxuICB9XG5cbiAgZnVuY3Rpb24gZGVzdHJveVN0cmVhbSAoc3RyZWFtJCQxKSB7XG4gICAgc3RyZWFtUG9vbC5wdXNoKHN0cmVhbSQkMSlcbiAgfVxuXG4gIGZ1bmN0aW9uIGluaXRCdWZmZXJGcm9tVHlwZWRBcnJheSAoYnVmZmVyLCBkYXRhLCB1c2FnZSkge1xuICAgIGJ1ZmZlci5ieXRlTGVuZ3RoID0gZGF0YS5ieXRlTGVuZ3RoXG4gICAgZ2wuYnVmZmVyRGF0YShidWZmZXIudHlwZSwgZGF0YSwgdXNhZ2UpXG4gIH1cblxuICBmdW5jdGlvbiBpbml0QnVmZmVyRnJvbURhdGEgKGJ1ZmZlciwgZGF0YSwgdXNhZ2UsIGR0eXBlLCBkaW1lbnNpb24sIHBlcnNpc3QpIHtcbiAgICB2YXIgc2hhcGVcbiAgICBidWZmZXIudXNhZ2UgPSB1c2FnZVxuICAgIGlmIChBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgICBidWZmZXIuZHR5cGUgPSBkdHlwZSB8fCBHTF9GTE9BVCQzXG4gICAgICBpZiAoZGF0YS5sZW5ndGggPiAwKSB7XG4gICAgICAgIHZhciBmbGF0RGF0YVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShkYXRhWzBdKSkge1xuICAgICAgICAgIHNoYXBlID0gYXJyYXlTaGFwZShkYXRhKVxuICAgICAgICAgIHZhciBkaW0gPSAxXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBzaGFwZS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgZGltICo9IHNoYXBlW2ldXG4gICAgICAgICAgfVxuICAgICAgICAgIGJ1ZmZlci5kaW1lbnNpb24gPSBkaW1cbiAgICAgICAgICBmbGF0RGF0YSA9IGFycmF5RmxhdHRlbihkYXRhLCBzaGFwZSwgYnVmZmVyLmR0eXBlKVxuICAgICAgICAgIGluaXRCdWZmZXJGcm9tVHlwZWRBcnJheShidWZmZXIsIGZsYXREYXRhLCB1c2FnZSlcbiAgICAgICAgICBpZiAocGVyc2lzdCkge1xuICAgICAgICAgICAgYnVmZmVyLnBlcnNpc3RlbnREYXRhID0gZmxhdERhdGFcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcG9vbC5mcmVlVHlwZShmbGF0RGF0YSlcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGRhdGFbMF0gPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgYnVmZmVyLmRpbWVuc2lvbiA9IGRpbWVuc2lvblxuICAgICAgICAgIHZhciB0eXBlZERhdGEgPSBwb29sLmFsbG9jVHlwZShidWZmZXIuZHR5cGUsIGRhdGEubGVuZ3RoKVxuICAgICAgICAgIGNvcHlBcnJheSh0eXBlZERhdGEsIGRhdGEpXG4gICAgICAgICAgaW5pdEJ1ZmZlckZyb21UeXBlZEFycmF5KGJ1ZmZlciwgdHlwZWREYXRhLCB1c2FnZSlcbiAgICAgICAgICBpZiAocGVyc2lzdCkge1xuICAgICAgICAgICAgYnVmZmVyLnBlcnNpc3RlbnREYXRhID0gdHlwZWREYXRhXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBvb2wuZnJlZVR5cGUodHlwZWREYXRhKVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChpc1R5cGVkQXJyYXkoZGF0YVswXSkpIHtcbiAgICAgICAgICBidWZmZXIuZGltZW5zaW9uID0gZGF0YVswXS5sZW5ndGhcbiAgICAgICAgICBidWZmZXIuZHR5cGUgPSBkdHlwZSB8fCB0eXBlZEFycmF5Q29kZShkYXRhWzBdKSB8fCBHTF9GTE9BVCQzXG4gICAgICAgICAgZmxhdERhdGEgPSBhcnJheUZsYXR0ZW4oXG4gICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgW2RhdGEubGVuZ3RoLCBkYXRhWzBdLmxlbmd0aF0sXG4gICAgICAgICAgICBidWZmZXIuZHR5cGUpXG4gICAgICAgICAgaW5pdEJ1ZmZlckZyb21UeXBlZEFycmF5KGJ1ZmZlciwgZmxhdERhdGEsIHVzYWdlKVxuICAgICAgICAgIGlmIChwZXJzaXN0KSB7XG4gICAgICAgICAgICBidWZmZXIucGVyc2lzdGVudERhdGEgPSBmbGF0RGF0YVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwb29sLmZyZWVUeXBlKGZsYXREYXRhKVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjaGVjayQxLnJhaXNlKCdpbnZhbGlkIGJ1ZmZlciBkYXRhJylcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNUeXBlZEFycmF5KGRhdGEpKSB7XG4gICAgICBidWZmZXIuZHR5cGUgPSBkdHlwZSB8fCB0eXBlZEFycmF5Q29kZShkYXRhKVxuICAgICAgYnVmZmVyLmRpbWVuc2lvbiA9IGRpbWVuc2lvblxuICAgICAgaW5pdEJ1ZmZlckZyb21UeXBlZEFycmF5KGJ1ZmZlciwgZGF0YSwgdXNhZ2UpXG4gICAgICBpZiAocGVyc2lzdCkge1xuICAgICAgICBidWZmZXIucGVyc2lzdGVudERhdGEgPSBuZXcgVWludDhBcnJheShuZXcgVWludDhBcnJheShkYXRhLmJ1ZmZlcikpXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc05EQXJyYXlMaWtlKGRhdGEpKSB7XG4gICAgICBzaGFwZSA9IGRhdGEuc2hhcGVcbiAgICAgIHZhciBzdHJpZGUgPSBkYXRhLnN0cmlkZVxuICAgICAgdmFyIG9mZnNldCA9IGRhdGEub2Zmc2V0XG5cbiAgICAgIHZhciBzaGFwZVggPSAwXG4gICAgICB2YXIgc2hhcGVZID0gMFxuICAgICAgdmFyIHN0cmlkZVggPSAwXG4gICAgICB2YXIgc3RyaWRlWSA9IDBcbiAgICAgIGlmIChzaGFwZS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgc2hhcGVYID0gc2hhcGVbMF1cbiAgICAgICAgc2hhcGVZID0gMVxuICAgICAgICBzdHJpZGVYID0gc3RyaWRlWzBdXG4gICAgICAgIHN0cmlkZVkgPSAwXG4gICAgICB9IGVsc2UgaWYgKHNoYXBlLmxlbmd0aCA9PT0gMikge1xuICAgICAgICBzaGFwZVggPSBzaGFwZVswXVxuICAgICAgICBzaGFwZVkgPSBzaGFwZVsxXVxuICAgICAgICBzdHJpZGVYID0gc3RyaWRlWzBdXG4gICAgICAgIHN0cmlkZVkgPSBzdHJpZGVbMV1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNoZWNrJDEucmFpc2UoJ2ludmFsaWQgc2hhcGUnKVxuICAgICAgfVxuXG4gICAgICBidWZmZXIuZHR5cGUgPSBkdHlwZSB8fCB0eXBlZEFycmF5Q29kZShkYXRhLmRhdGEpIHx8IEdMX0ZMT0FUJDNcbiAgICAgIGJ1ZmZlci5kaW1lbnNpb24gPSBzaGFwZVlcblxuICAgICAgdmFyIHRyYW5zcG9zZURhdGEgPSBwb29sLmFsbG9jVHlwZShidWZmZXIuZHR5cGUsIHNoYXBlWCAqIHNoYXBlWSlcbiAgICAgIHRyYW5zcG9zZSh0cmFuc3Bvc2VEYXRhLFxuICAgICAgICBkYXRhLmRhdGEsXG4gICAgICAgIHNoYXBlWCwgc2hhcGVZLFxuICAgICAgICBzdHJpZGVYLCBzdHJpZGVZLFxuICAgICAgICBvZmZzZXQpXG4gICAgICBpbml0QnVmZmVyRnJvbVR5cGVkQXJyYXkoYnVmZmVyLCB0cmFuc3Bvc2VEYXRhLCB1c2FnZSlcbiAgICAgIGlmIChwZXJzaXN0KSB7XG4gICAgICAgIGJ1ZmZlci5wZXJzaXN0ZW50RGF0YSA9IHRyYW5zcG9zZURhdGFcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBvb2wuZnJlZVR5cGUodHJhbnNwb3NlRGF0YSlcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGRhdGEgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgYnVmZmVyLmR0eXBlID0gR0xfVU5TSUdORURfQllURSQzXG4gICAgICBidWZmZXIuZGltZW5zaW9uID0gZGltZW5zaW9uXG4gICAgICBpbml0QnVmZmVyRnJvbVR5cGVkQXJyYXkoYnVmZmVyLCBkYXRhLCB1c2FnZSlcbiAgICAgIGlmIChwZXJzaXN0KSB7XG4gICAgICAgIGJ1ZmZlci5wZXJzaXN0ZW50RGF0YSA9IG5ldyBVaW50OEFycmF5KG5ldyBVaW50OEFycmF5KGRhdGEpKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjaGVjayQxLnJhaXNlKCdpbnZhbGlkIGJ1ZmZlciBkYXRhJylcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBkZXN0cm95IChidWZmZXIpIHtcbiAgICBzdGF0cy5idWZmZXJDb3VudC0tXG5cbiAgICAvLyByZW1vdmUgYXR0cmlidXRlIGxpbmtcbiAgICBkZXN0cm95QnVmZmVyKGJ1ZmZlcilcblxuICAgIHZhciBoYW5kbGUgPSBidWZmZXIuYnVmZmVyXG4gICAgY2hlY2skMShoYW5kbGUsICdidWZmZXIgbXVzdCBub3QgYmUgZGVsZXRlZCBhbHJlYWR5JylcbiAgICBnbC5kZWxldGVCdWZmZXIoaGFuZGxlKVxuICAgIGJ1ZmZlci5idWZmZXIgPSBudWxsXG4gICAgZGVsZXRlIGJ1ZmZlclNldFtidWZmZXIuaWRdXG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVCdWZmZXIgKG9wdGlvbnMsIHR5cGUsIGRlZmVySW5pdCwgcGVyc2lzdGVudCkge1xuICAgIHN0YXRzLmJ1ZmZlckNvdW50KytcblxuICAgIHZhciBidWZmZXIgPSBuZXcgUkVHTEJ1ZmZlcih0eXBlKVxuICAgIGJ1ZmZlclNldFtidWZmZXIuaWRdID0gYnVmZmVyXG5cbiAgICBmdW5jdGlvbiByZWdsQnVmZmVyIChvcHRpb25zKSB7XG4gICAgICB2YXIgdXNhZ2UgPSBHTF9TVEFUSUNfRFJBV1xuICAgICAgdmFyIGRhdGEgPSBudWxsXG4gICAgICB2YXIgYnl0ZUxlbmd0aCA9IDBcbiAgICAgIHZhciBkdHlwZSA9IDBcbiAgICAgIHZhciBkaW1lbnNpb24gPSAxXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShvcHRpb25zKSB8fFxuICAgICAgICAgIGlzVHlwZWRBcnJheShvcHRpb25zKSB8fFxuICAgICAgICAgIGlzTkRBcnJheUxpa2Uob3B0aW9ucykgfHxcbiAgICAgICAgICBvcHRpb25zIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgZGF0YSA9IG9wdGlvbnNcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGJ5dGVMZW5ndGggPSBvcHRpb25zIHwgMFxuICAgICAgfSBlbHNlIGlmIChvcHRpb25zKSB7XG4gICAgICAgIGNoZWNrJDEudHlwZShcbiAgICAgICAgICBvcHRpb25zLCAnb2JqZWN0JyxcbiAgICAgICAgICAnYnVmZmVyIGFyZ3VtZW50cyBtdXN0IGJlIGFuIG9iamVjdCwgYSBudW1iZXIgb3IgYW4gYXJyYXknKVxuXG4gICAgICAgIGlmICgnZGF0YScgaW4gb3B0aW9ucykge1xuICAgICAgICAgIGNoZWNrJDEoXG4gICAgICAgICAgICBkYXRhID09PSBudWxsIHx8XG4gICAgICAgICAgICBBcnJheS5pc0FycmF5KGRhdGEpIHx8XG4gICAgICAgICAgICBpc1R5cGVkQXJyYXkoZGF0YSkgfHxcbiAgICAgICAgICAgIGlzTkRBcnJheUxpa2UoZGF0YSksXG4gICAgICAgICAgICAnaW52YWxpZCBkYXRhIGZvciBidWZmZXInKVxuICAgICAgICAgIGRhdGEgPSBvcHRpb25zLmRhdGFcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgndXNhZ2UnIGluIG9wdGlvbnMpIHtcbiAgICAgICAgICBjaGVjayQxLnBhcmFtZXRlcihvcHRpb25zLnVzYWdlLCB1c2FnZVR5cGVzLCAnaW52YWxpZCBidWZmZXIgdXNhZ2UnKVxuICAgICAgICAgIHVzYWdlID0gdXNhZ2VUeXBlc1tvcHRpb25zLnVzYWdlXVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCd0eXBlJyBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgY2hlY2skMS5wYXJhbWV0ZXIob3B0aW9ucy50eXBlLCBnbFR5cGVzLCAnaW52YWxpZCBidWZmZXIgdHlwZScpXG4gICAgICAgICAgZHR5cGUgPSBnbFR5cGVzW29wdGlvbnMudHlwZV1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgnZGltZW5zaW9uJyBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgY2hlY2skMS50eXBlKG9wdGlvbnMuZGltZW5zaW9uLCAnbnVtYmVyJywgJ2ludmFsaWQgZGltZW5zaW9uJylcbiAgICAgICAgICBkaW1lbnNpb24gPSBvcHRpb25zLmRpbWVuc2lvbiB8IDBcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgnbGVuZ3RoJyBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgY2hlY2skMS5ubmkoYnl0ZUxlbmd0aCwgJ2J1ZmZlciBsZW5ndGggbXVzdCBiZSBhIG5vbm5lZ2F0aXZlIGludGVnZXInKVxuICAgICAgICAgIGJ5dGVMZW5ndGggPSBvcHRpb25zLmxlbmd0aCB8IDBcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBidWZmZXIuYmluZCgpXG4gICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgLy8gIzQ3NVxuICAgICAgICBpZiAoYnl0ZUxlbmd0aCkgZ2wuYnVmZmVyRGF0YShidWZmZXIudHlwZSwgYnl0ZUxlbmd0aCwgdXNhZ2UpXG4gICAgICAgIGJ1ZmZlci5kdHlwZSA9IGR0eXBlIHx8IEdMX1VOU0lHTkVEX0JZVEUkM1xuICAgICAgICBidWZmZXIudXNhZ2UgPSB1c2FnZVxuICAgICAgICBidWZmZXIuZGltZW5zaW9uID0gZGltZW5zaW9uXG4gICAgICAgIGJ1ZmZlci5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5pdEJ1ZmZlckZyb21EYXRhKGJ1ZmZlciwgZGF0YSwgdXNhZ2UsIGR0eXBlLCBkaW1lbnNpb24sIHBlcnNpc3RlbnQpXG4gICAgICB9XG5cbiAgICAgIGlmIChjb25maWcucHJvZmlsZSkge1xuICAgICAgICBidWZmZXIuc3RhdHMuc2l6ZSA9IGJ1ZmZlci5ieXRlTGVuZ3RoICogRFRZUEVTX1NJWkVTW2J1ZmZlci5kdHlwZV1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlZ2xCdWZmZXJcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRTdWJEYXRhIChkYXRhLCBvZmZzZXQpIHtcbiAgICAgIGNoZWNrJDEob2Zmc2V0ICsgZGF0YS5ieXRlTGVuZ3RoIDw9IGJ1ZmZlci5ieXRlTGVuZ3RoLFxuICAgICAgICAnaW52YWxpZCBidWZmZXIgc3ViZGF0YSBjYWxsLCBidWZmZXIgaXMgdG9vIHNtYWxsLiAnICsgJyBDYW5cXCd0IHdyaXRlIGRhdGEgb2Ygc2l6ZSAnICsgZGF0YS5ieXRlTGVuZ3RoICsgJyBzdGFydGluZyBmcm9tIG9mZnNldCAnICsgb2Zmc2V0ICsgJyB0byBhIGJ1ZmZlciBvZiBzaXplICcgKyBidWZmZXIuYnl0ZUxlbmd0aClcblxuICAgICAgZ2wuYnVmZmVyU3ViRGF0YShidWZmZXIudHlwZSwgb2Zmc2V0LCBkYXRhKVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHN1YmRhdGEgKGRhdGEsIG9mZnNldF8pIHtcbiAgICAgIHZhciBvZmZzZXQgPSAob2Zmc2V0XyB8fCAwKSB8IDBcbiAgICAgIHZhciBzaGFwZVxuICAgICAgYnVmZmVyLmJpbmQoKVxuICAgICAgaWYgKGlzVHlwZWRBcnJheShkYXRhKSB8fCBkYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgc2V0U3ViRGF0YShkYXRhLCBvZmZzZXQpXG4gICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkpIHtcbiAgICAgICAgaWYgKGRhdGEubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGlmICh0eXBlb2YgZGF0YVswXSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHZhciBjb252ZXJ0ZWQgPSBwb29sLmFsbG9jVHlwZShidWZmZXIuZHR5cGUsIGRhdGEubGVuZ3RoKVxuICAgICAgICAgICAgY29weUFycmF5KGNvbnZlcnRlZCwgZGF0YSlcbiAgICAgICAgICAgIHNldFN1YkRhdGEoY29udmVydGVkLCBvZmZzZXQpXG4gICAgICAgICAgICBwb29sLmZyZWVUeXBlKGNvbnZlcnRlZClcbiAgICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoZGF0YVswXSkgfHwgaXNUeXBlZEFycmF5KGRhdGFbMF0pKSB7XG4gICAgICAgICAgICBzaGFwZSA9IGFycmF5U2hhcGUoZGF0YSlcbiAgICAgICAgICAgIHZhciBmbGF0RGF0YSA9IGFycmF5RmxhdHRlbihkYXRhLCBzaGFwZSwgYnVmZmVyLmR0eXBlKVxuICAgICAgICAgICAgc2V0U3ViRGF0YShmbGF0RGF0YSwgb2Zmc2V0KVxuICAgICAgICAgICAgcG9vbC5mcmVlVHlwZShmbGF0RGF0YSlcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2hlY2skMS5yYWlzZSgnaW52YWxpZCBidWZmZXIgZGF0YScpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGlzTkRBcnJheUxpa2UoZGF0YSkpIHtcbiAgICAgICAgc2hhcGUgPSBkYXRhLnNoYXBlXG4gICAgICAgIHZhciBzdHJpZGUgPSBkYXRhLnN0cmlkZVxuXG4gICAgICAgIHZhciBzaGFwZVggPSAwXG4gICAgICAgIHZhciBzaGFwZVkgPSAwXG4gICAgICAgIHZhciBzdHJpZGVYID0gMFxuICAgICAgICB2YXIgc3RyaWRlWSA9IDBcbiAgICAgICAgaWYgKHNoYXBlLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIHNoYXBlWCA9IHNoYXBlWzBdXG4gICAgICAgICAgc2hhcGVZID0gMVxuICAgICAgICAgIHN0cmlkZVggPSBzdHJpZGVbMF1cbiAgICAgICAgICBzdHJpZGVZID0gMFxuICAgICAgICB9IGVsc2UgaWYgKHNoYXBlLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgIHNoYXBlWCA9IHNoYXBlWzBdXG4gICAgICAgICAgc2hhcGVZID0gc2hhcGVbMV1cbiAgICAgICAgICBzdHJpZGVYID0gc3RyaWRlWzBdXG4gICAgICAgICAgc3RyaWRlWSA9IHN0cmlkZVsxXVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNoZWNrJDEucmFpc2UoJ2ludmFsaWQgc2hhcGUnKVxuICAgICAgICB9XG4gICAgICAgIHZhciBkdHlwZSA9IEFycmF5LmlzQXJyYXkoZGF0YS5kYXRhKVxuICAgICAgICAgID8gYnVmZmVyLmR0eXBlXG4gICAgICAgICAgOiB0eXBlZEFycmF5Q29kZShkYXRhLmRhdGEpXG5cbiAgICAgICAgdmFyIHRyYW5zcG9zZURhdGEgPSBwb29sLmFsbG9jVHlwZShkdHlwZSwgc2hhcGVYICogc2hhcGVZKVxuICAgICAgICB0cmFuc3Bvc2UodHJhbnNwb3NlRGF0YSxcbiAgICAgICAgICBkYXRhLmRhdGEsXG4gICAgICAgICAgc2hhcGVYLCBzaGFwZVksXG4gICAgICAgICAgc3RyaWRlWCwgc3RyaWRlWSxcbiAgICAgICAgICBkYXRhLm9mZnNldClcbiAgICAgICAgc2V0U3ViRGF0YSh0cmFuc3Bvc2VEYXRhLCBvZmZzZXQpXG4gICAgICAgIHBvb2wuZnJlZVR5cGUodHJhbnNwb3NlRGF0YSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNoZWNrJDEucmFpc2UoJ2ludmFsaWQgZGF0YSBmb3IgYnVmZmVyIHN1YmRhdGEnKVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlZ2xCdWZmZXJcbiAgICB9XG5cbiAgICBpZiAoIWRlZmVySW5pdCkge1xuICAgICAgcmVnbEJ1ZmZlcihvcHRpb25zKVxuICAgIH1cblxuICAgIHJlZ2xCdWZmZXIuX3JlZ2xUeXBlID0gJ2J1ZmZlcidcbiAgICByZWdsQnVmZmVyLl9idWZmZXIgPSBidWZmZXJcbiAgICByZWdsQnVmZmVyLnN1YmRhdGEgPSBzdWJkYXRhXG4gICAgaWYgKGNvbmZpZy5wcm9maWxlKSB7XG4gICAgICByZWdsQnVmZmVyLnN0YXRzID0gYnVmZmVyLnN0YXRzXG4gICAgfVxuICAgIHJlZ2xCdWZmZXIuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHsgZGVzdHJveShidWZmZXIpIH1cblxuICAgIHJldHVybiByZWdsQnVmZmVyXG4gIH1cblxuICBmdW5jdGlvbiByZXN0b3JlQnVmZmVycyAoKSB7XG4gICAgdmFsdWVzKGJ1ZmZlclNldCkuZm9yRWFjaChmdW5jdGlvbiAoYnVmZmVyKSB7XG4gICAgICBidWZmZXIuYnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKClcbiAgICAgIGdsLmJpbmRCdWZmZXIoYnVmZmVyLnR5cGUsIGJ1ZmZlci5idWZmZXIpXG4gICAgICBnbC5idWZmZXJEYXRhKFxuICAgICAgICBidWZmZXIudHlwZSwgYnVmZmVyLnBlcnNpc3RlbnREYXRhIHx8IGJ1ZmZlci5ieXRlTGVuZ3RoLCBidWZmZXIudXNhZ2UpXG4gICAgfSlcbiAgfVxuXG4gIGlmIChjb25maWcucHJvZmlsZSkge1xuICAgIHN0YXRzLmdldFRvdGFsQnVmZmVyU2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB0b3RhbCA9IDBcbiAgICAgIC8vIFRPRE86IFJpZ2h0IG5vdywgdGhlIHN0cmVhbXMgYXJlIG5vdCBwYXJ0IG9mIHRoZSB0b3RhbCBjb3VudC5cbiAgICAgIE9iamVjdC5rZXlzKGJ1ZmZlclNldCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHRvdGFsICs9IGJ1ZmZlclNldFtrZXldLnN0YXRzLnNpemVcbiAgICAgIH0pXG4gICAgICByZXR1cm4gdG90YWxcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGNyZWF0ZTogY3JlYXRlQnVmZmVyLFxuXG4gICAgY3JlYXRlU3RyZWFtOiBjcmVhdGVTdHJlYW0sXG4gICAgZGVzdHJveVN0cmVhbTogZGVzdHJveVN0cmVhbSxcblxuICAgIGNsZWFyOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YWx1ZXMoYnVmZmVyU2V0KS5mb3JFYWNoKGRlc3Ryb3kpXG4gICAgICBzdHJlYW1Qb29sLmZvckVhY2goZGVzdHJveSlcbiAgICB9LFxuXG4gICAgZ2V0QnVmZmVyOiBmdW5jdGlvbiAod3JhcHBlcikge1xuICAgICAgaWYgKHdyYXBwZXIgJiYgd3JhcHBlci5fYnVmZmVyIGluc3RhbmNlb2YgUkVHTEJ1ZmZlcikge1xuICAgICAgICByZXR1cm4gd3JhcHBlci5fYnVmZmVyXG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH0sXG5cbiAgICByZXN0b3JlOiByZXN0b3JlQnVmZmVycyxcblxuICAgIF9pbml0QnVmZmVyOiBpbml0QnVmZmVyRnJvbURhdGFcbiAgfVxufVxuXG52YXIgcG9pbnRzID0gMDtcbnZhciBwb2ludCA9IDA7XG52YXIgbGluZXMgPSAxO1xudmFyIGxpbmUgPSAxO1xudmFyIHRyaWFuZ2xlcyA9IDQ7XG52YXIgdHJpYW5nbGUgPSA0O1xudmFyIHByaW1UeXBlcyA9IHtcblx0cG9pbnRzOiBwb2ludHMsXG5cdHBvaW50OiBwb2ludCxcblx0bGluZXM6IGxpbmVzLFxuXHRsaW5lOiBsaW5lLFxuXHR0cmlhbmdsZXM6IHRyaWFuZ2xlcyxcblx0dHJpYW5nbGU6IHRyaWFuZ2xlLFxuXHRcImxpbmUgbG9vcFwiOiAyLFxuXHRcImxpbmUgc3RyaXBcIjogMyxcblx0XCJ0cmlhbmdsZSBzdHJpcFwiOiA1LFxuXHRcInRyaWFuZ2xlIGZhblwiOiA2XG59O1xuXG52YXIgR0xfUE9JTlRTID0gMFxudmFyIEdMX0xJTkVTID0gMVxudmFyIEdMX1RSSUFOR0xFUyA9IDRcblxudmFyIEdMX0JZVEUkMiA9IDUxMjBcbnZhciBHTF9VTlNJR05FRF9CWVRFJDQgPSA1MTIxXG52YXIgR0xfU0hPUlQkMiA9IDUxMjJcbnZhciBHTF9VTlNJR05FRF9TSE9SVCQyID0gNTEyM1xudmFyIEdMX0lOVCQyID0gNTEyNFxudmFyIEdMX1VOU0lHTkVEX0lOVCQyID0gNTEyNVxuXG52YXIgR0xfRUxFTUVOVF9BUlJBWV9CVUZGRVIgPSAzNDk2M1xuXG52YXIgR0xfU1RSRUFNX0RSQVckMSA9IDB4ODhFMFxudmFyIEdMX1NUQVRJQ19EUkFXJDEgPSAweDg4RTRcblxuZnVuY3Rpb24gd3JhcEVsZW1lbnRzU3RhdGUgKGdsLCBleHRlbnNpb25zLCBidWZmZXJTdGF0ZSwgc3RhdHMpIHtcbiAgdmFyIGVsZW1lbnRTZXQgPSB7fVxuICB2YXIgZWxlbWVudENvdW50ID0gMFxuXG4gIHZhciBlbGVtZW50VHlwZXMgPSB7XG4gICAgJ3VpbnQ4JzogR0xfVU5TSUdORURfQllURSQ0LFxuICAgICd1aW50MTYnOiBHTF9VTlNJR05FRF9TSE9SVCQyXG4gIH1cblxuICBpZiAoZXh0ZW5zaW9ucy5vZXNfZWxlbWVudF9pbmRleF91aW50KSB7XG4gICAgZWxlbWVudFR5cGVzLnVpbnQzMiA9IEdMX1VOU0lHTkVEX0lOVCQyXG4gIH1cblxuICBmdW5jdGlvbiBSRUdMRWxlbWVudEJ1ZmZlciAoYnVmZmVyKSB7XG4gICAgdGhpcy5pZCA9IGVsZW1lbnRDb3VudCsrXG4gICAgZWxlbWVudFNldFt0aGlzLmlkXSA9IHRoaXNcbiAgICB0aGlzLmJ1ZmZlciA9IGJ1ZmZlclxuICAgIHRoaXMucHJpbVR5cGUgPSBHTF9UUklBTkdMRVNcbiAgICB0aGlzLnZlcnRDb3VudCA9IDBcbiAgICB0aGlzLnR5cGUgPSAwXG4gIH1cblxuICBSRUdMRWxlbWVudEJ1ZmZlci5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmJ1ZmZlci5iaW5kKClcbiAgfVxuXG4gIHZhciBidWZmZXJQb29sID0gW11cblxuICBmdW5jdGlvbiBjcmVhdGVFbGVtZW50U3RyZWFtIChkYXRhKSB7XG4gICAgdmFyIHJlc3VsdCA9IGJ1ZmZlclBvb2wucG9wKClcbiAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgcmVzdWx0ID0gbmV3IFJFR0xFbGVtZW50QnVmZmVyKGJ1ZmZlclN0YXRlLmNyZWF0ZShcbiAgICAgICAgbnVsbCxcbiAgICAgICAgR0xfRUxFTUVOVF9BUlJBWV9CVUZGRVIsXG4gICAgICAgIHRydWUsXG4gICAgICAgIGZhbHNlKS5fYnVmZmVyKVxuICAgIH1cbiAgICBpbml0RWxlbWVudHMocmVzdWx0LCBkYXRhLCBHTF9TVFJFQU1fRFJBVyQxLCAtMSwgLTEsIDAsIDApXG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG5cbiAgZnVuY3Rpb24gZGVzdHJveUVsZW1lbnRTdHJlYW0gKGVsZW1lbnRzKSB7XG4gICAgYnVmZmVyUG9vbC5wdXNoKGVsZW1lbnRzKVxuICB9XG5cbiAgZnVuY3Rpb24gaW5pdEVsZW1lbnRzIChcbiAgICBlbGVtZW50cyxcbiAgICBkYXRhLFxuICAgIHVzYWdlLFxuICAgIHByaW0sXG4gICAgY291bnQsXG4gICAgYnl0ZUxlbmd0aCxcbiAgICB0eXBlKSB7XG4gICAgZWxlbWVudHMuYnVmZmVyLmJpbmQoKVxuICAgIHZhciBkdHlwZVxuICAgIGlmIChkYXRhKSB7XG4gICAgICB2YXIgcHJlZGljdGVkVHlwZSA9IHR5cGVcbiAgICAgIGlmICghdHlwZSAmJiAoXG4gICAgICAgICFpc1R5cGVkQXJyYXkoZGF0YSkgfHxcbiAgICAgICAgIChpc05EQXJyYXlMaWtlKGRhdGEpICYmICFpc1R5cGVkQXJyYXkoZGF0YS5kYXRhKSkpKSB7XG4gICAgICAgIHByZWRpY3RlZFR5cGUgPSBleHRlbnNpb25zLm9lc19lbGVtZW50X2luZGV4X3VpbnRcbiAgICAgICAgICA/IEdMX1VOU0lHTkVEX0lOVCQyXG4gICAgICAgICAgOiBHTF9VTlNJR05FRF9TSE9SVCQyXG4gICAgICB9XG4gICAgICBidWZmZXJTdGF0ZS5faW5pdEJ1ZmZlcihcbiAgICAgICAgZWxlbWVudHMuYnVmZmVyLFxuICAgICAgICBkYXRhLFxuICAgICAgICB1c2FnZSxcbiAgICAgICAgcHJlZGljdGVkVHlwZSxcbiAgICAgICAgMylcbiAgICB9IGVsc2Uge1xuICAgICAgZ2wuYnVmZmVyRGF0YShHTF9FTEVNRU5UX0FSUkFZX0JVRkZFUiwgYnl0ZUxlbmd0aCwgdXNhZ2UpXG4gICAgICBlbGVtZW50cy5idWZmZXIuZHR5cGUgPSBkdHlwZSB8fCBHTF9VTlNJR05FRF9CWVRFJDRcbiAgICAgIGVsZW1lbnRzLmJ1ZmZlci51c2FnZSA9IHVzYWdlXG4gICAgICBlbGVtZW50cy5idWZmZXIuZGltZW5zaW9uID0gM1xuICAgICAgZWxlbWVudHMuYnVmZmVyLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXG4gICAgfVxuXG4gICAgZHR5cGUgPSB0eXBlXG4gICAgaWYgKCF0eXBlKSB7XG4gICAgICBzd2l0Y2ggKGVsZW1lbnRzLmJ1ZmZlci5kdHlwZSkge1xuICAgICAgICBjYXNlIEdMX1VOU0lHTkVEX0JZVEUkNDpcbiAgICAgICAgY2FzZSBHTF9CWVRFJDI6XG4gICAgICAgICAgZHR5cGUgPSBHTF9VTlNJR05FRF9CWVRFJDRcbiAgICAgICAgICBicmVha1xuXG4gICAgICAgIGNhc2UgR0xfVU5TSUdORURfU0hPUlQkMjpcbiAgICAgICAgY2FzZSBHTF9TSE9SVCQyOlxuICAgICAgICAgIGR0eXBlID0gR0xfVU5TSUdORURfU0hPUlQkMlxuICAgICAgICAgIGJyZWFrXG5cbiAgICAgICAgY2FzZSBHTF9VTlNJR05FRF9JTlQkMjpcbiAgICAgICAgY2FzZSBHTF9JTlQkMjpcbiAgICAgICAgICBkdHlwZSA9IEdMX1VOU0lHTkVEX0lOVCQyXG4gICAgICAgICAgYnJlYWtcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGNoZWNrJDEucmFpc2UoJ3Vuc3VwcG9ydGVkIHR5cGUgZm9yIGVsZW1lbnQgYXJyYXknKVxuICAgICAgfVxuICAgICAgZWxlbWVudHMuYnVmZmVyLmR0eXBlID0gZHR5cGVcbiAgICB9XG4gICAgZWxlbWVudHMudHlwZSA9IGR0eXBlXG5cbiAgICAvLyBDaGVjayBvZXNfZWxlbWVudF9pbmRleF91aW50IGV4dGVuc2lvblxuICAgIGNoZWNrJDEoXG4gICAgICBkdHlwZSAhPT0gR0xfVU5TSUdORURfSU5UJDIgfHxcbiAgICAgICEhZXh0ZW5zaW9ucy5vZXNfZWxlbWVudF9pbmRleF91aW50LFxuICAgICAgJzMyIGJpdCBlbGVtZW50IGJ1ZmZlcnMgbm90IHN1cHBvcnRlZCwgZW5hYmxlIG9lc19lbGVtZW50X2luZGV4X3VpbnQgZmlyc3QnKVxuXG4gICAgLy8gdHJ5IHRvIGd1ZXNzIGRlZmF1bHQgcHJpbWl0aXZlIHR5cGUgYW5kIGFyZ3VtZW50c1xuICAgIHZhciB2ZXJ0Q291bnQgPSBjb3VudFxuICAgIGlmICh2ZXJ0Q291bnQgPCAwKSB7XG4gICAgICB2ZXJ0Q291bnQgPSBlbGVtZW50cy5idWZmZXIuYnl0ZUxlbmd0aFxuICAgICAgaWYgKGR0eXBlID09PSBHTF9VTlNJR05FRF9TSE9SVCQyKSB7XG4gICAgICAgIHZlcnRDb3VudCA+Pj0gMVxuICAgICAgfSBlbHNlIGlmIChkdHlwZSA9PT0gR0xfVU5TSUdORURfSU5UJDIpIHtcbiAgICAgICAgdmVydENvdW50ID4+PSAyXG4gICAgICB9XG4gICAgfVxuICAgIGVsZW1lbnRzLnZlcnRDb3VudCA9IHZlcnRDb3VudFxuXG4gICAgLy8gdHJ5IHRvIGd1ZXNzIHByaW1pdGl2ZSB0eXBlIGZyb20gY2VsbCBkaW1lbnNpb25cbiAgICB2YXIgcHJpbVR5cGUgPSBwcmltXG4gICAgaWYgKHByaW0gPCAwKSB7XG4gICAgICBwcmltVHlwZSA9IEdMX1RSSUFOR0xFU1xuICAgICAgdmFyIGRpbWVuc2lvbiA9IGVsZW1lbnRzLmJ1ZmZlci5kaW1lbnNpb25cbiAgICAgIGlmIChkaW1lbnNpb24gPT09IDEpIHByaW1UeXBlID0gR0xfUE9JTlRTXG4gICAgICBpZiAoZGltZW5zaW9uID09PSAyKSBwcmltVHlwZSA9IEdMX0xJTkVTXG4gICAgICBpZiAoZGltZW5zaW9uID09PSAzKSBwcmltVHlwZSA9IEdMX1RSSUFOR0xFU1xuICAgIH1cbiAgICBlbGVtZW50cy5wcmltVHlwZSA9IHByaW1UeXBlXG4gIH1cblxuICBmdW5jdGlvbiBkZXN0cm95RWxlbWVudHMgKGVsZW1lbnRzKSB7XG4gICAgc3RhdHMuZWxlbWVudHNDb3VudC0tXG5cbiAgICBjaGVjayQxKGVsZW1lbnRzLmJ1ZmZlciAhPT0gbnVsbCwgJ211c3Qgbm90IGRvdWJsZSBkZXN0cm95IGVsZW1lbnRzJylcbiAgICBkZWxldGUgZWxlbWVudFNldFtlbGVtZW50cy5pZF1cbiAgICBlbGVtZW50cy5idWZmZXIuZGVzdHJveSgpXG4gICAgZWxlbWVudHMuYnVmZmVyID0gbnVsbFxuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlRWxlbWVudHMgKG9wdGlvbnMsIHBlcnNpc3RlbnQpIHtcbiAgICB2YXIgYnVmZmVyID0gYnVmZmVyU3RhdGUuY3JlYXRlKG51bGwsIEdMX0VMRU1FTlRfQVJSQVlfQlVGRkVSLCB0cnVlKVxuICAgIHZhciBlbGVtZW50cyA9IG5ldyBSRUdMRWxlbWVudEJ1ZmZlcihidWZmZXIuX2J1ZmZlcilcbiAgICBzdGF0cy5lbGVtZW50c0NvdW50KytcblxuICAgIGZ1bmN0aW9uIHJlZ2xFbGVtZW50cyAob3B0aW9ucykge1xuICAgICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICAgIGJ1ZmZlcigpXG4gICAgICAgIGVsZW1lbnRzLnByaW1UeXBlID0gR0xfVFJJQU5HTEVTXG4gICAgICAgIGVsZW1lbnRzLnZlcnRDb3VudCA9IDBcbiAgICAgICAgZWxlbWVudHMudHlwZSA9IEdMX1VOU0lHTkVEX0JZVEUkNFxuICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgYnVmZmVyKG9wdGlvbnMpXG4gICAgICAgIGVsZW1lbnRzLnByaW1UeXBlID0gR0xfVFJJQU5HTEVTXG4gICAgICAgIGVsZW1lbnRzLnZlcnRDb3VudCA9IG9wdGlvbnMgfCAwXG4gICAgICAgIGVsZW1lbnRzLnR5cGUgPSBHTF9VTlNJR05FRF9CWVRFJDRcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBkYXRhID0gbnVsbFxuICAgICAgICB2YXIgdXNhZ2UgPSBHTF9TVEFUSUNfRFJBVyQxXG4gICAgICAgIHZhciBwcmltVHlwZSA9IC0xXG4gICAgICAgIHZhciB2ZXJ0Q291bnQgPSAtMVxuICAgICAgICB2YXIgYnl0ZUxlbmd0aCA9IDBcbiAgICAgICAgdmFyIGR0eXBlID0gMFxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvcHRpb25zKSB8fFxuICAgICAgICAgICAgaXNUeXBlZEFycmF5KG9wdGlvbnMpIHx8XG4gICAgICAgICAgICBpc05EQXJyYXlMaWtlKG9wdGlvbnMpKSB7XG4gICAgICAgICAgZGF0YSA9IG9wdGlvbnNcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjaGVjayQxLnR5cGUob3B0aW9ucywgJ29iamVjdCcsICdpbnZhbGlkIGFyZ3VtZW50cyBmb3IgZWxlbWVudHMnKVxuICAgICAgICAgIGlmICgnZGF0YScgaW4gb3B0aW9ucykge1xuICAgICAgICAgICAgZGF0YSA9IG9wdGlvbnMuZGF0YVxuICAgICAgICAgICAgY2hlY2skMShcbiAgICAgICAgICAgICAgQXJyYXkuaXNBcnJheShkYXRhKSB8fFxuICAgICAgICAgICAgICAgIGlzVHlwZWRBcnJheShkYXRhKSB8fFxuICAgICAgICAgICAgICAgIGlzTkRBcnJheUxpa2UoZGF0YSksXG4gICAgICAgICAgICAgICdpbnZhbGlkIGRhdGEgZm9yIGVsZW1lbnQgYnVmZmVyJylcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCd1c2FnZScgaW4gb3B0aW9ucykge1xuICAgICAgICAgICAgY2hlY2skMS5wYXJhbWV0ZXIoXG4gICAgICAgICAgICAgIG9wdGlvbnMudXNhZ2UsXG4gICAgICAgICAgICAgIHVzYWdlVHlwZXMsXG4gICAgICAgICAgICAgICdpbnZhbGlkIGVsZW1lbnQgYnVmZmVyIHVzYWdlJylcbiAgICAgICAgICAgIHVzYWdlID0gdXNhZ2VUeXBlc1tvcHRpb25zLnVzYWdlXVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoJ3ByaW1pdGl2ZScgaW4gb3B0aW9ucykge1xuICAgICAgICAgICAgY2hlY2skMS5wYXJhbWV0ZXIoXG4gICAgICAgICAgICAgIG9wdGlvbnMucHJpbWl0aXZlLFxuICAgICAgICAgICAgICBwcmltVHlwZXMsXG4gICAgICAgICAgICAgICdpbnZhbGlkIGVsZW1lbnQgYnVmZmVyIHByaW1pdGl2ZScpXG4gICAgICAgICAgICBwcmltVHlwZSA9IHByaW1UeXBlc1tvcHRpb25zLnByaW1pdGl2ZV1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCdjb3VudCcgaW4gb3B0aW9ucykge1xuICAgICAgICAgICAgY2hlY2skMShcbiAgICAgICAgICAgICAgdHlwZW9mIG9wdGlvbnMuY291bnQgPT09ICdudW1iZXInICYmIG9wdGlvbnMuY291bnQgPj0gMCxcbiAgICAgICAgICAgICAgJ2ludmFsaWQgdmVydGV4IGNvdW50IGZvciBlbGVtZW50cycpXG4gICAgICAgICAgICB2ZXJ0Q291bnQgPSBvcHRpb25zLmNvdW50IHwgMFxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoJ3R5cGUnIGluIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGNoZWNrJDEucGFyYW1ldGVyKFxuICAgICAgICAgICAgICBvcHRpb25zLnR5cGUsXG4gICAgICAgICAgICAgIGVsZW1lbnRUeXBlcyxcbiAgICAgICAgICAgICAgJ2ludmFsaWQgYnVmZmVyIHR5cGUnKVxuICAgICAgICAgICAgZHR5cGUgPSBlbGVtZW50VHlwZXNbb3B0aW9ucy50eXBlXVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoJ2xlbmd0aCcgaW4gb3B0aW9ucykge1xuICAgICAgICAgICAgYnl0ZUxlbmd0aCA9IG9wdGlvbnMubGVuZ3RoIHwgMFxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBieXRlTGVuZ3RoID0gdmVydENvdW50XG4gICAgICAgICAgICBpZiAoZHR5cGUgPT09IEdMX1VOU0lHTkVEX1NIT1JUJDIgfHwgZHR5cGUgPT09IEdMX1NIT1JUJDIpIHtcbiAgICAgICAgICAgICAgYnl0ZUxlbmd0aCAqPSAyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGR0eXBlID09PSBHTF9VTlNJR05FRF9JTlQkMiB8fCBkdHlwZSA9PT0gR0xfSU5UJDIpIHtcbiAgICAgICAgICAgICAgYnl0ZUxlbmd0aCAqPSA0XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGluaXRFbGVtZW50cyhcbiAgICAgICAgICBlbGVtZW50cyxcbiAgICAgICAgICBkYXRhLFxuICAgICAgICAgIHVzYWdlLFxuICAgICAgICAgIHByaW1UeXBlLFxuICAgICAgICAgIHZlcnRDb3VudCxcbiAgICAgICAgICBieXRlTGVuZ3RoLFxuICAgICAgICAgIGR0eXBlKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVnbEVsZW1lbnRzXG4gICAgfVxuXG4gICAgcmVnbEVsZW1lbnRzKG9wdGlvbnMpXG5cbiAgICByZWdsRWxlbWVudHMuX3JlZ2xUeXBlID0gJ2VsZW1lbnRzJ1xuICAgIHJlZ2xFbGVtZW50cy5fZWxlbWVudHMgPSBlbGVtZW50c1xuICAgIHJlZ2xFbGVtZW50cy5zdWJkYXRhID0gZnVuY3Rpb24gKGRhdGEsIG9mZnNldCkge1xuICAgICAgYnVmZmVyLnN1YmRhdGEoZGF0YSwgb2Zmc2V0KVxuICAgICAgcmV0dXJuIHJlZ2xFbGVtZW50c1xuICAgIH1cbiAgICByZWdsRWxlbWVudHMuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGRlc3Ryb3lFbGVtZW50cyhlbGVtZW50cylcbiAgICB9XG5cbiAgICByZXR1cm4gcmVnbEVsZW1lbnRzXG4gIH1cblxuICByZXR1cm4ge1xuICAgIGNyZWF0ZTogY3JlYXRlRWxlbWVudHMsXG4gICAgY3JlYXRlU3RyZWFtOiBjcmVhdGVFbGVtZW50U3RyZWFtLFxuICAgIGRlc3Ryb3lTdHJlYW06IGRlc3Ryb3lFbGVtZW50U3RyZWFtLFxuICAgIGdldEVsZW1lbnRzOiBmdW5jdGlvbiAoZWxlbWVudHMpIHtcbiAgICAgIGlmICh0eXBlb2YgZWxlbWVudHMgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgICBlbGVtZW50cy5fZWxlbWVudHMgaW5zdGFuY2VvZiBSRUdMRWxlbWVudEJ1ZmZlcikge1xuICAgICAgICByZXR1cm4gZWxlbWVudHMuX2VsZW1lbnRzXG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH0sXG4gICAgY2xlYXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhbHVlcyhlbGVtZW50U2V0KS5mb3JFYWNoKGRlc3Ryb3lFbGVtZW50cylcbiAgICB9XG4gIH1cbn1cblxudmFyIEZMT0FUID0gbmV3IEZsb2F0MzJBcnJheSgxKVxudmFyIElOVCA9IG5ldyBVaW50MzJBcnJheShGTE9BVC5idWZmZXIpXG5cbnZhciBHTF9VTlNJR05FRF9TSE9SVCQ0ID0gNTEyM1xuXG5mdW5jdGlvbiBjb252ZXJ0VG9IYWxmRmxvYXQgKGFycmF5KSB7XG4gIHZhciB1c2hvcnRzID0gcG9vbC5hbGxvY1R5cGUoR0xfVU5TSUdORURfU0hPUlQkNCwgYXJyYXkubGVuZ3RoKVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoaXNOYU4oYXJyYXlbaV0pKSB7XG4gICAgICB1c2hvcnRzW2ldID0gMHhmZmZmXG4gICAgfSBlbHNlIGlmIChhcnJheVtpXSA9PT0gSW5maW5pdHkpIHtcbiAgICAgIHVzaG9ydHNbaV0gPSAweDdjMDBcbiAgICB9IGVsc2UgaWYgKGFycmF5W2ldID09PSAtSW5maW5pdHkpIHtcbiAgICAgIHVzaG9ydHNbaV0gPSAweGZjMDBcbiAgICB9IGVsc2Uge1xuICAgICAgRkxPQVRbMF0gPSBhcnJheVtpXVxuICAgICAgdmFyIHggPSBJTlRbMF1cblxuICAgICAgdmFyIHNnbiA9ICh4ID4+PiAzMSkgPDwgMTVcbiAgICAgIHZhciBleHAgPSAoKHggPDwgMSkgPj4+IDI0KSAtIDEyN1xuICAgICAgdmFyIGZyYWMgPSAoeCA+PiAxMykgJiAoKDEgPDwgMTApIC0gMSlcblxuICAgICAgaWYgKGV4cCA8IC0yNCkge1xuICAgICAgICAvLyByb3VuZCBub24tcmVwcmVzZW50YWJsZSBkZW5vcm1hbHMgdG8gMFxuICAgICAgICB1c2hvcnRzW2ldID0gc2duXG4gICAgICB9IGVsc2UgaWYgKGV4cCA8IC0xNCkge1xuICAgICAgICAvLyBoYW5kbGUgZGVub3JtYWxzXG4gICAgICAgIHZhciBzID0gLTE0IC0gZXhwXG4gICAgICAgIHVzaG9ydHNbaV0gPSBzZ24gKyAoKGZyYWMgKyAoMSA8PCAxMCkpID4+IHMpXG4gICAgICB9IGVsc2UgaWYgKGV4cCA+IDE1KSB7XG4gICAgICAgIC8vIHJvdW5kIG92ZXJmbG93IHRvICsvLSBJbmZpbml0eVxuICAgICAgICB1c2hvcnRzW2ldID0gc2duICsgMHg3YzAwXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBvdGhlcndpc2UgY29udmVydCBkaXJlY3RseVxuICAgICAgICB1c2hvcnRzW2ldID0gc2duICsgKChleHAgKyAxNSkgPDwgMTApICsgZnJhY1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB1c2hvcnRzXG59XG5cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlIChzKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KHMpIHx8IGlzVHlwZWRBcnJheShzKVxufVxuXG52YXIgaXNQb3cyJDEgPSBmdW5jdGlvbiAodikge1xuICByZXR1cm4gISh2ICYgKHYgLSAxKSkgJiYgKCEhdilcbn1cblxudmFyIEdMX0NPTVBSRVNTRURfVEVYVFVSRV9GT1JNQVRTID0gMHg4NkEzXG5cbnZhciBHTF9URVhUVVJFXzJEJDEgPSAweDBERTFcbnZhciBHTF9URVhUVVJFX0NVQkVfTUFQJDEgPSAweDg1MTNcbnZhciBHTF9URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1gkMSA9IDB4ODUxNVxuXG52YXIgR0xfUkdCQSQxID0gMHgxOTA4XG52YXIgR0xfQUxQSEEgPSAweDE5MDZcbnZhciBHTF9SR0IgPSAweDE5MDdcbnZhciBHTF9MVU1JTkFOQ0UgPSAweDE5MDlcbnZhciBHTF9MVU1JTkFOQ0VfQUxQSEEgPSAweDE5MEFcblxudmFyIEdMX1JHQkE0ID0gMHg4MDU2XG52YXIgR0xfUkdCNV9BMSA9IDB4ODA1N1xudmFyIEdMX1JHQjU2NSA9IDB4OEQ2MlxuXG52YXIgR0xfVU5TSUdORURfU0hPUlRfNF80XzRfNCQxID0gMHg4MDMzXG52YXIgR0xfVU5TSUdORURfU0hPUlRfNV81XzVfMSQxID0gMHg4MDM0XG52YXIgR0xfVU5TSUdORURfU0hPUlRfNV82XzUkMSA9IDB4ODM2M1xudmFyIEdMX1VOU0lHTkVEX0lOVF8yNF84X1dFQkdMJDEgPSAweDg0RkFcblxudmFyIEdMX0RFUFRIX0NPTVBPTkVOVCA9IDB4MTkwMlxudmFyIEdMX0RFUFRIX1NURU5DSUwgPSAweDg0RjlcblxudmFyIEdMX1NSR0JfRVhUID0gMHg4QzQwXG52YXIgR0xfU1JHQl9BTFBIQV9FWFQgPSAweDhDNDJcblxudmFyIEdMX0hBTEZfRkxPQVRfT0VTJDEgPSAweDhENjFcblxudmFyIEdMX0NPTVBSRVNTRURfUkdCX1MzVENfRFhUMV9FWFQgPSAweDgzRjBcbnZhciBHTF9DT01QUkVTU0VEX1JHQkFfUzNUQ19EWFQxX0VYVCA9IDB4ODNGMVxudmFyIEdMX0NPTVBSRVNTRURfUkdCQV9TM1RDX0RYVDNfRVhUID0gMHg4M0YyXG52YXIgR0xfQ09NUFJFU1NFRF9SR0JBX1MzVENfRFhUNV9FWFQgPSAweDgzRjNcblxudmFyIEdMX0NPTVBSRVNTRURfUkdCX0FUQ19XRUJHTCA9IDB4OEM5MlxudmFyIEdMX0NPTVBSRVNTRURfUkdCQV9BVENfRVhQTElDSVRfQUxQSEFfV0VCR0wgPSAweDhDOTNcbnZhciBHTF9DT01QUkVTU0VEX1JHQkFfQVRDX0lOVEVSUE9MQVRFRF9BTFBIQV9XRUJHTCA9IDB4ODdFRVxuXG52YXIgR0xfQ09NUFJFU1NFRF9SR0JfUFZSVENfNEJQUFYxX0lNRyA9IDB4OEMwMFxudmFyIEdMX0NPTVBSRVNTRURfUkdCX1BWUlRDXzJCUFBWMV9JTUcgPSAweDhDMDFcbnZhciBHTF9DT01QUkVTU0VEX1JHQkFfUFZSVENfNEJQUFYxX0lNRyA9IDB4OEMwMlxudmFyIEdMX0NPTVBSRVNTRURfUkdCQV9QVlJUQ18yQlBQVjFfSU1HID0gMHg4QzAzXG5cbnZhciBHTF9DT01QUkVTU0VEX1JHQl9FVEMxX1dFQkdMID0gMHg4RDY0XG5cbnZhciBHTF9VTlNJR05FRF9CWVRFJDUgPSAweDE0MDFcbnZhciBHTF9VTlNJR05FRF9TSE9SVCQzID0gMHgxNDAzXG52YXIgR0xfVU5TSUdORURfSU5UJDMgPSAweDE0MDVcbnZhciBHTF9GTE9BVCQ0ID0gMHgxNDA2XG5cbnZhciBHTF9URVhUVVJFX1dSQVBfUyA9IDB4MjgwMlxudmFyIEdMX1RFWFRVUkVfV1JBUF9UID0gMHgyODAzXG5cbnZhciBHTF9SRVBFQVQgPSAweDI5MDFcbnZhciBHTF9DTEFNUF9UT19FREdFJDEgPSAweDgxMkZcbnZhciBHTF9NSVJST1JFRF9SRVBFQVQgPSAweDgzNzBcblxudmFyIEdMX1RFWFRVUkVfTUFHX0ZJTFRFUiA9IDB4MjgwMFxudmFyIEdMX1RFWFRVUkVfTUlOX0ZJTFRFUiA9IDB4MjgwMVxuXG52YXIgR0xfTkVBUkVTVCQxID0gMHgyNjAwXG52YXIgR0xfTElORUFSID0gMHgyNjAxXG52YXIgR0xfTkVBUkVTVF9NSVBNQVBfTkVBUkVTVCQxID0gMHgyNzAwXG52YXIgR0xfTElORUFSX01JUE1BUF9ORUFSRVNUJDEgPSAweDI3MDFcbnZhciBHTF9ORUFSRVNUX01JUE1BUF9MSU5FQVIkMSA9IDB4MjcwMlxudmFyIEdMX0xJTkVBUl9NSVBNQVBfTElORUFSJDEgPSAweDI3MDNcblxudmFyIEdMX0dFTkVSQVRFX01JUE1BUF9ISU5UID0gMHg4MTkyXG52YXIgR0xfRE9OVF9DQVJFID0gMHgxMTAwXG52YXIgR0xfRkFTVEVTVCA9IDB4MTEwMVxudmFyIEdMX05JQ0VTVCA9IDB4MTEwMlxuXG52YXIgR0xfVEVYVFVSRV9NQVhfQU5JU09UUk9QWV9FWFQgPSAweDg0RkVcblxudmFyIEdMX1VOUEFDS19BTElHTk1FTlQgPSAweDBDRjVcbnZhciBHTF9VTlBBQ0tfRkxJUF9ZX1dFQkdMID0gMHg5MjQwXG52YXIgR0xfVU5QQUNLX1BSRU1VTFRJUExZX0FMUEhBX1dFQkdMID0gMHg5MjQxXG52YXIgR0xfVU5QQUNLX0NPTE9SU1BBQ0VfQ09OVkVSU0lPTl9XRUJHTCA9IDB4OTI0M1xuXG52YXIgR0xfQlJPV1NFUl9ERUZBVUxUX1dFQkdMID0gMHg5MjQ0XG5cbnZhciBHTF9URVhUVVJFMCQxID0gMHg4NEMwXG5cbnZhciBNSVBNQVBfRklMVEVSUyA9IFtcbiAgR0xfTkVBUkVTVF9NSVBNQVBfTkVBUkVTVCQxLFxuICBHTF9ORUFSRVNUX01JUE1BUF9MSU5FQVIkMSxcbiAgR0xfTElORUFSX01JUE1BUF9ORUFSRVNUJDEsXG4gIEdMX0xJTkVBUl9NSVBNQVBfTElORUFSJDFcbl1cblxudmFyIENIQU5ORUxTX0ZPUk1BVCA9IFtcbiAgMCxcbiAgR0xfTFVNSU5BTkNFLFxuICBHTF9MVU1JTkFOQ0VfQUxQSEEsXG4gIEdMX1JHQixcbiAgR0xfUkdCQSQxXG5dXG5cbnZhciBGT1JNQVRfQ0hBTk5FTFMgPSB7fVxuRk9STUFUX0NIQU5ORUxTW0dMX0xVTUlOQU5DRV0gPVxuRk9STUFUX0NIQU5ORUxTW0dMX0FMUEhBXSA9XG5GT1JNQVRfQ0hBTk5FTFNbR0xfREVQVEhfQ09NUE9ORU5UXSA9IDFcbkZPUk1BVF9DSEFOTkVMU1tHTF9ERVBUSF9TVEVOQ0lMXSA9XG5GT1JNQVRfQ0hBTk5FTFNbR0xfTFVNSU5BTkNFX0FMUEhBXSA9IDJcbkZPUk1BVF9DSEFOTkVMU1tHTF9SR0JdID1cbkZPUk1BVF9DSEFOTkVMU1tHTF9TUkdCX0VYVF0gPSAzXG5GT1JNQVRfQ0hBTk5FTFNbR0xfUkdCQSQxXSA9XG5GT1JNQVRfQ0hBTk5FTFNbR0xfU1JHQl9BTFBIQV9FWFRdID0gNFxuXG5mdW5jdGlvbiBvYmplY3ROYW1lIChzdHIpIHtcbiAgcmV0dXJuICdbb2JqZWN0ICcgKyBzdHIgKyAnXSdcbn1cblxudmFyIENBTlZBU19DTEFTUyA9IG9iamVjdE5hbWUoJ0hUTUxDYW52YXNFbGVtZW50JylcbnZhciBPRkZTQ1JFRU5DQU5WQVNfQ0xBU1MgPSBvYmplY3ROYW1lKCdPZmZzY3JlZW5DYW52YXMnKVxudmFyIENPTlRFWFQyRF9DTEFTUyA9IG9iamVjdE5hbWUoJ0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCcpXG52YXIgQklUTUFQX0NMQVNTID0gb2JqZWN0TmFtZSgnSW1hZ2VCaXRtYXAnKVxudmFyIElNQUdFX0NMQVNTID0gb2JqZWN0TmFtZSgnSFRNTEltYWdlRWxlbWVudCcpXG52YXIgVklERU9fQ0xBU1MgPSBvYmplY3ROYW1lKCdIVE1MVmlkZW9FbGVtZW50JylcblxudmFyIFBJWEVMX0NMQVNTRVMgPSBPYmplY3Qua2V5cyhhcnJheVR5cGVzKS5jb25jYXQoW1xuICBDQU5WQVNfQ0xBU1MsXG4gIE9GRlNDUkVFTkNBTlZBU19DTEFTUyxcbiAgQ09OVEVYVDJEX0NMQVNTLFxuICBCSVRNQVBfQ0xBU1MsXG4gIElNQUdFX0NMQVNTLFxuICBWSURFT19DTEFTU1xuXSlcblxuLy8gZm9yIGV2ZXJ5IHRleHR1cmUgdHlwZSwgc3RvcmVcbi8vIHRoZSBzaXplIGluIGJ5dGVzLlxudmFyIFRZUEVfU0laRVMgPSBbXVxuVFlQRV9TSVpFU1tHTF9VTlNJR05FRF9CWVRFJDVdID0gMVxuVFlQRV9TSVpFU1tHTF9GTE9BVCQ0XSA9IDRcblRZUEVfU0laRVNbR0xfSEFMRl9GTE9BVF9PRVMkMV0gPSAyXG5cblRZUEVfU0laRVNbR0xfVU5TSUdORURfU0hPUlQkM10gPSAyXG5UWVBFX1NJWkVTW0dMX1VOU0lHTkVEX0lOVCQzXSA9IDRcblxudmFyIEZPUk1BVF9TSVpFU19TUEVDSUFMID0gW11cbkZPUk1BVF9TSVpFU19TUEVDSUFMW0dMX1JHQkE0XSA9IDJcbkZPUk1BVF9TSVpFU19TUEVDSUFMW0dMX1JHQjVfQTFdID0gMlxuRk9STUFUX1NJWkVTX1NQRUNJQUxbR0xfUkdCNTY1XSA9IDJcbkZPUk1BVF9TSVpFU19TUEVDSUFMW0dMX0RFUFRIX1NURU5DSUxdID0gNFxuXG5GT1JNQVRfU0laRVNfU1BFQ0lBTFtHTF9DT01QUkVTU0VEX1JHQl9TM1RDX0RYVDFfRVhUXSA9IDAuNVxuRk9STUFUX1NJWkVTX1NQRUNJQUxbR0xfQ09NUFJFU1NFRF9SR0JBX1MzVENfRFhUMV9FWFRdID0gMC41XG5GT1JNQVRfU0laRVNfU1BFQ0lBTFtHTF9DT01QUkVTU0VEX1JHQkFfUzNUQ19EWFQzX0VYVF0gPSAxXG5GT1JNQVRfU0laRVNfU1BFQ0lBTFtHTF9DT01QUkVTU0VEX1JHQkFfUzNUQ19EWFQ1X0VYVF0gPSAxXG5cbkZPUk1BVF9TSVpFU19TUEVDSUFMW0dMX0NPTVBSRVNTRURfUkdCX0FUQ19XRUJHTF0gPSAwLjVcbkZPUk1BVF9TSVpFU19TUEVDSUFMW0dMX0NPTVBSRVNTRURfUkdCQV9BVENfRVhQTElDSVRfQUxQSEFfV0VCR0xdID0gMVxuRk9STUFUX1NJWkVTX1NQRUNJQUxbR0xfQ09NUFJFU1NFRF9SR0JBX0FUQ19JTlRFUlBPTEFURURfQUxQSEFfV0VCR0xdID0gMVxuXG5GT1JNQVRfU0laRVNfU1BFQ0lBTFtHTF9DT01QUkVTU0VEX1JHQl9QVlJUQ180QlBQVjFfSU1HXSA9IDAuNVxuRk9STUFUX1NJWkVTX1NQRUNJQUxbR0xfQ09NUFJFU1NFRF9SR0JfUFZSVENfMkJQUFYxX0lNR10gPSAwLjI1XG5GT1JNQVRfU0laRVNfU1BFQ0lBTFtHTF9DT01QUkVTU0VEX1JHQkFfUFZSVENfNEJQUFYxX0lNR10gPSAwLjVcbkZPUk1BVF9TSVpFU19TUEVDSUFMW0dMX0NPTVBSRVNTRURfUkdCQV9QVlJUQ18yQlBQVjFfSU1HXSA9IDAuMjVcblxuRk9STUFUX1NJWkVTX1NQRUNJQUxbR0xfQ09NUFJFU1NFRF9SR0JfRVRDMV9XRUJHTF0gPSAwLjVcblxuZnVuY3Rpb24gaXNOdW1lcmljQXJyYXkgKGFycikge1xuICByZXR1cm4gKFxuICAgIEFycmF5LmlzQXJyYXkoYXJyKSAmJlxuICAgIChhcnIubGVuZ3RoID09PSAwIHx8XG4gICAgdHlwZW9mIGFyclswXSA9PT0gJ251bWJlcicpKVxufVxuXG5mdW5jdGlvbiBpc1JlY3RBcnJheSAoYXJyKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShhcnIpKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgdmFyIHdpZHRoID0gYXJyLmxlbmd0aFxuICBpZiAod2lkdGggPT09IDAgfHwgIWlzQXJyYXlMaWtlKGFyclswXSkpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICByZXR1cm4gdHJ1ZVxufVxuXG5mdW5jdGlvbiBjbGFzc1N0cmluZyAoeCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHgpXG59XG5cbmZ1bmN0aW9uIGlzQ2FudmFzRWxlbWVudCAob2JqZWN0KSB7XG4gIHJldHVybiBjbGFzc1N0cmluZyhvYmplY3QpID09PSBDQU5WQVNfQ0xBU1Ncbn1cblxuZnVuY3Rpb24gaXNPZmZzY3JlZW5DYW52YXMgKG9iamVjdCkge1xuICByZXR1cm4gY2xhc3NTdHJpbmcob2JqZWN0KSA9PT0gT0ZGU0NSRUVOQ0FOVkFTX0NMQVNTXG59XG5cbmZ1bmN0aW9uIGlzQ29udGV4dDJEIChvYmplY3QpIHtcbiAgcmV0dXJuIGNsYXNzU3RyaW5nKG9iamVjdCkgPT09IENPTlRFWFQyRF9DTEFTU1xufVxuXG5mdW5jdGlvbiBpc0JpdG1hcCAob2JqZWN0KSB7XG4gIHJldHVybiBjbGFzc1N0cmluZyhvYmplY3QpID09PSBCSVRNQVBfQ0xBU1Ncbn1cblxuZnVuY3Rpb24gaXNJbWFnZUVsZW1lbnQgKG9iamVjdCkge1xuICByZXR1cm4gY2xhc3NTdHJpbmcob2JqZWN0KSA9PT0gSU1BR0VfQ0xBU1Ncbn1cblxuZnVuY3Rpb24gaXNWaWRlb0VsZW1lbnQgKG9iamVjdCkge1xuICByZXR1cm4gY2xhc3NTdHJpbmcob2JqZWN0KSA9PT0gVklERU9fQ0xBU1Ncbn1cblxuZnVuY3Rpb24gaXNQaXhlbERhdGEgKG9iamVjdCkge1xuICBpZiAoIW9iamVjdCkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIHZhciBjbGFzc05hbWUgPSBjbGFzc1N0cmluZyhvYmplY3QpXG4gIGlmIChQSVhFTF9DTEFTU0VTLmluZGV4T2YoY2xhc3NOYW1lKSA+PSAwKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICByZXR1cm4gKFxuICAgIGlzTnVtZXJpY0FycmF5KG9iamVjdCkgfHxcbiAgICBpc1JlY3RBcnJheShvYmplY3QpIHx8XG4gICAgaXNOREFycmF5TGlrZShvYmplY3QpKVxufVxuXG5mdW5jdGlvbiB0eXBlZEFycmF5Q29kZSQxIChkYXRhKSB7XG4gIHJldHVybiBhcnJheVR5cGVzW09iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChkYXRhKV0gfCAwXG59XG5cbmZ1bmN0aW9uIGNvbnZlcnREYXRhIChyZXN1bHQsIGRhdGEpIHtcbiAgdmFyIG4gPSBkYXRhLmxlbmd0aFxuICBzd2l0Y2ggKHJlc3VsdC50eXBlKSB7XG4gICAgY2FzZSBHTF9VTlNJR05FRF9CWVRFJDU6XG4gICAgY2FzZSBHTF9VTlNJR05FRF9TSE9SVCQzOlxuICAgIGNhc2UgR0xfVU5TSUdORURfSU5UJDM6XG4gICAgY2FzZSBHTF9GTE9BVCQ0OlxuICAgICAgdmFyIGNvbnZlcnRlZCA9IHBvb2wuYWxsb2NUeXBlKHJlc3VsdC50eXBlLCBuKVxuICAgICAgY29udmVydGVkLnNldChkYXRhKVxuICAgICAgcmVzdWx0LmRhdGEgPSBjb252ZXJ0ZWRcbiAgICAgIGJyZWFrXG5cbiAgICBjYXNlIEdMX0hBTEZfRkxPQVRfT0VTJDE6XG4gICAgICByZXN1bHQuZGF0YSA9IGNvbnZlcnRUb0hhbGZGbG9hdChkYXRhKVxuICAgICAgYnJlYWtcblxuICAgIGRlZmF1bHQ6XG4gICAgICBjaGVjayQxLnJhaXNlKCd1bnN1cHBvcnRlZCB0ZXh0dXJlIHR5cGUsIG11c3Qgc3BlY2lmeSBhIHR5cGVkIGFycmF5JylcbiAgfVxufVxuXG5mdW5jdGlvbiBwcmVDb252ZXJ0IChpbWFnZSwgbikge1xuICByZXR1cm4gcG9vbC5hbGxvY1R5cGUoXG4gICAgaW1hZ2UudHlwZSA9PT0gR0xfSEFMRl9GTE9BVF9PRVMkMVxuICAgICAgPyBHTF9GTE9BVCQ0XG4gICAgICA6IGltYWdlLnR5cGUsIG4pXG59XG5cbmZ1bmN0aW9uIHBvc3RDb252ZXJ0IChpbWFnZSwgZGF0YSkge1xuICBpZiAoaW1hZ2UudHlwZSA9PT0gR0xfSEFMRl9GTE9BVF9PRVMkMSkge1xuICAgIGltYWdlLmRhdGEgPSBjb252ZXJ0VG9IYWxmRmxvYXQoZGF0YSlcbiAgICBwb29sLmZyZWVUeXBlKGRhdGEpXG4gIH0gZWxzZSB7XG4gICAgaW1hZ2UuZGF0YSA9IGRhdGFcbiAgfVxufVxuXG5mdW5jdGlvbiB0cmFuc3Bvc2VEYXRhIChpbWFnZSwgYXJyYXksIHN0cmlkZVgsIHN0cmlkZVksIHN0cmlkZUMsIG9mZnNldCkge1xuICB2YXIgdyA9IGltYWdlLndpZHRoXG4gIHZhciBoID0gaW1hZ2UuaGVpZ2h0XG4gIHZhciBjID0gaW1hZ2UuY2hhbm5lbHNcbiAgdmFyIG4gPSB3ICogaCAqIGNcbiAgdmFyIGRhdGEgPSBwcmVDb252ZXJ0KGltYWdlLCBuKVxuXG4gIHZhciBwID0gMFxuICBmb3IgKHZhciBpID0gMDsgaSA8IGg7ICsraSkge1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgdzsgKytqKSB7XG4gICAgICBmb3IgKHZhciBrID0gMDsgayA8IGM7ICsraykge1xuICAgICAgICBkYXRhW3ArK10gPSBhcnJheVtzdHJpZGVYICogaiArIHN0cmlkZVkgKiBpICsgc3RyaWRlQyAqIGsgKyBvZmZzZXRdXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcG9zdENvbnZlcnQoaW1hZ2UsIGRhdGEpXG59XG5cbmZ1bmN0aW9uIGdldFRleHR1cmVTaXplIChmb3JtYXQsIHR5cGUsIHdpZHRoLCBoZWlnaHQsIGlzTWlwbWFwLCBpc0N1YmUpIHtcbiAgdmFyIHNcbiAgaWYgKHR5cGVvZiBGT1JNQVRfU0laRVNfU1BFQ0lBTFtmb3JtYXRdICE9PSAndW5kZWZpbmVkJykge1xuICAgIC8vIHdlIGhhdmUgYSBzcGVjaWFsIGFycmF5IGZvciBkZWFsaW5nIHdpdGggd2VpcmQgY29sb3IgZm9ybWF0cyBzdWNoIGFzIFJHQjVBMVxuICAgIHMgPSBGT1JNQVRfU0laRVNfU1BFQ0lBTFtmb3JtYXRdXG4gIH0gZWxzZSB7XG4gICAgcyA9IEZPUk1BVF9DSEFOTkVMU1tmb3JtYXRdICogVFlQRV9TSVpFU1t0eXBlXVxuICB9XG5cbiAgaWYgKGlzQ3ViZSkge1xuICAgIHMgKj0gNlxuICB9XG5cbiAgaWYgKGlzTWlwbWFwKSB7XG4gICAgLy8gY29tcHV0ZSB0aGUgdG90YWwgc2l6ZSBvZiBhbGwgdGhlIG1pcG1hcHMuXG4gICAgdmFyIHRvdGFsID0gMFxuXG4gICAgdmFyIHcgPSB3aWR0aFxuICAgIHdoaWxlICh3ID49IDEpIHtcbiAgICAgIC8vIHdlIGNhbiBvbmx5IHVzZSBtaXBtYXBzIG9uIGEgc3F1YXJlIGltYWdlLFxuICAgICAgLy8gc28gd2UgY2FuIHNpbXBseSB1c2UgdGhlIHdpZHRoIGFuZCBpZ25vcmUgdGhlIGhlaWdodDpcbiAgICAgIHRvdGFsICs9IHMgKiB3ICogd1xuICAgICAgdyAvPSAyXG4gICAgfVxuICAgIHJldHVybiB0b3RhbFxuICB9IGVsc2Uge1xuICAgIHJldHVybiBzICogd2lkdGggKiBoZWlnaHRcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVUZXh0dXJlU2V0IChcbiAgZ2wsIGV4dGVuc2lvbnMsIGxpbWl0cywgcmVnbFBvbGwsIGNvbnRleHRTdGF0ZSwgc3RhdHMsIGNvbmZpZykge1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIEluaXRpYWxpemUgY29uc3RhbnRzIGFuZCBwYXJhbWV0ZXIgdGFibGVzIGhlcmVcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICB2YXIgbWlwbWFwSGludCA9IHtcbiAgICBcImRvbid0IGNhcmVcIjogR0xfRE9OVF9DQVJFLFxuICAgICdkb250IGNhcmUnOiBHTF9ET05UX0NBUkUsXG4gICAgJ25pY2UnOiBHTF9OSUNFU1QsXG4gICAgJ2Zhc3QnOiBHTF9GQVNURVNUXG4gIH1cblxuICB2YXIgd3JhcE1vZGVzID0ge1xuICAgICdyZXBlYXQnOiBHTF9SRVBFQVQsXG4gICAgJ2NsYW1wJzogR0xfQ0xBTVBfVE9fRURHRSQxLFxuICAgICdtaXJyb3InOiBHTF9NSVJST1JFRF9SRVBFQVRcbiAgfVxuXG4gIHZhciBtYWdGaWx0ZXJzID0ge1xuICAgICduZWFyZXN0JzogR0xfTkVBUkVTVCQxLFxuICAgICdsaW5lYXInOiBHTF9MSU5FQVJcbiAgfVxuXG4gIHZhciBtaW5GaWx0ZXJzID0gZXh0ZW5kKHtcbiAgICAnbWlwbWFwJzogR0xfTElORUFSX01JUE1BUF9MSU5FQVIkMSxcbiAgICAnbmVhcmVzdCBtaXBtYXAgbmVhcmVzdCc6IEdMX05FQVJFU1RfTUlQTUFQX05FQVJFU1QkMSxcbiAgICAnbGluZWFyIG1pcG1hcCBuZWFyZXN0JzogR0xfTElORUFSX01JUE1BUF9ORUFSRVNUJDEsXG4gICAgJ25lYXJlc3QgbWlwbWFwIGxpbmVhcic6IEdMX05FQVJFU1RfTUlQTUFQX0xJTkVBUiQxLFxuICAgICdsaW5lYXIgbWlwbWFwIGxpbmVhcic6IEdMX0xJTkVBUl9NSVBNQVBfTElORUFSJDFcbiAgfSwgbWFnRmlsdGVycylcblxuICB2YXIgY29sb3JTcGFjZSA9IHtcbiAgICAnbm9uZSc6IDAsXG4gICAgJ2Jyb3dzZXInOiBHTF9CUk9XU0VSX0RFRkFVTFRfV0VCR0xcbiAgfVxuXG4gIHZhciB0ZXh0dXJlVHlwZXMgPSB7XG4gICAgJ3VpbnQ4JzogR0xfVU5TSUdORURfQllURSQ1LFxuICAgICdyZ2JhNCc6IEdMX1VOU0lHTkVEX1NIT1JUXzRfNF80XzQkMSxcbiAgICAncmdiNTY1JzogR0xfVU5TSUdORURfU0hPUlRfNV82XzUkMSxcbiAgICAncmdiNSBhMSc6IEdMX1VOU0lHTkVEX1NIT1JUXzVfNV81XzEkMVxuICB9XG5cbiAgdmFyIHRleHR1cmVGb3JtYXRzID0ge1xuICAgICdhbHBoYSc6IEdMX0FMUEhBLFxuICAgICdsdW1pbmFuY2UnOiBHTF9MVU1JTkFOQ0UsXG4gICAgJ2x1bWluYW5jZSBhbHBoYSc6IEdMX0xVTUlOQU5DRV9BTFBIQSxcbiAgICAncmdiJzogR0xfUkdCLFxuICAgICdyZ2JhJzogR0xfUkdCQSQxLFxuICAgICdyZ2JhNCc6IEdMX1JHQkE0LFxuICAgICdyZ2I1IGExJzogR0xfUkdCNV9BMSxcbiAgICAncmdiNTY1JzogR0xfUkdCNTY1XG4gIH1cblxuICB2YXIgY29tcHJlc3NlZFRleHR1cmVGb3JtYXRzID0ge31cblxuICBpZiAoZXh0ZW5zaW9ucy5leHRfc3JnYikge1xuICAgIHRleHR1cmVGb3JtYXRzLnNyZ2IgPSBHTF9TUkdCX0VYVFxuICAgIHRleHR1cmVGb3JtYXRzLnNyZ2JhID0gR0xfU1JHQl9BTFBIQV9FWFRcbiAgfVxuXG4gIGlmIChleHRlbnNpb25zLm9lc190ZXh0dXJlX2Zsb2F0KSB7XG4gICAgdGV4dHVyZVR5cGVzLmZsb2F0MzIgPSB0ZXh0dXJlVHlwZXMuZmxvYXQgPSBHTF9GTE9BVCQ0XG4gIH1cblxuICBpZiAoZXh0ZW5zaW9ucy5vZXNfdGV4dHVyZV9oYWxmX2Zsb2F0KSB7XG4gICAgdGV4dHVyZVR5cGVzWydmbG9hdDE2J10gPSB0ZXh0dXJlVHlwZXNbJ2hhbGYgZmxvYXQnXSA9IEdMX0hBTEZfRkxPQVRfT0VTJDFcbiAgfVxuXG4gIGlmIChleHRlbnNpb25zLndlYmdsX2RlcHRoX3RleHR1cmUpIHtcbiAgICBleHRlbmQodGV4dHVyZUZvcm1hdHMsIHtcbiAgICAgICdkZXB0aCc6IEdMX0RFUFRIX0NPTVBPTkVOVCxcbiAgICAgICdkZXB0aCBzdGVuY2lsJzogR0xfREVQVEhfU1RFTkNJTFxuICAgIH0pXG5cbiAgICBleHRlbmQodGV4dHVyZVR5cGVzLCB7XG4gICAgICAndWludDE2JzogR0xfVU5TSUdORURfU0hPUlQkMyxcbiAgICAgICd1aW50MzInOiBHTF9VTlNJR05FRF9JTlQkMyxcbiAgICAgICdkZXB0aCBzdGVuY2lsJzogR0xfVU5TSUdORURfSU5UXzI0XzhfV0VCR0wkMVxuICAgIH0pXG4gIH1cblxuICBpZiAoZXh0ZW5zaW9ucy53ZWJnbF9jb21wcmVzc2VkX3RleHR1cmVfczN0Yykge1xuICAgIGV4dGVuZChjb21wcmVzc2VkVGV4dHVyZUZvcm1hdHMsIHtcbiAgICAgICdyZ2IgczN0YyBkeHQxJzogR0xfQ09NUFJFU1NFRF9SR0JfUzNUQ19EWFQxX0VYVCxcbiAgICAgICdyZ2JhIHMzdGMgZHh0MSc6IEdMX0NPTVBSRVNTRURfUkdCQV9TM1RDX0RYVDFfRVhULFxuICAgICAgJ3JnYmEgczN0YyBkeHQzJzogR0xfQ09NUFJFU1NFRF9SR0JBX1MzVENfRFhUM19FWFQsXG4gICAgICAncmdiYSBzM3RjIGR4dDUnOiBHTF9DT01QUkVTU0VEX1JHQkFfUzNUQ19EWFQ1X0VYVFxuICAgIH0pXG4gIH1cblxuICBpZiAoZXh0ZW5zaW9ucy53ZWJnbF9jb21wcmVzc2VkX3RleHR1cmVfYXRjKSB7XG4gICAgZXh0ZW5kKGNvbXByZXNzZWRUZXh0dXJlRm9ybWF0cywge1xuICAgICAgJ3JnYiBhdGMnOiBHTF9DT01QUkVTU0VEX1JHQl9BVENfV0VCR0wsXG4gICAgICAncmdiYSBhdGMgZXhwbGljaXQgYWxwaGEnOiBHTF9DT01QUkVTU0VEX1JHQkFfQVRDX0VYUExJQ0lUX0FMUEhBX1dFQkdMLFxuICAgICAgJ3JnYmEgYXRjIGludGVycG9sYXRlZCBhbHBoYSc6IEdMX0NPTVBSRVNTRURfUkdCQV9BVENfSU5URVJQT0xBVEVEX0FMUEhBX1dFQkdMXG4gICAgfSlcbiAgfVxuXG4gIGlmIChleHRlbnNpb25zLndlYmdsX2NvbXByZXNzZWRfdGV4dHVyZV9wdnJ0Yykge1xuICAgIGV4dGVuZChjb21wcmVzc2VkVGV4dHVyZUZvcm1hdHMsIHtcbiAgICAgICdyZ2IgcHZydGMgNGJwcHYxJzogR0xfQ09NUFJFU1NFRF9SR0JfUFZSVENfNEJQUFYxX0lNRyxcbiAgICAgICdyZ2IgcHZydGMgMmJwcHYxJzogR0xfQ09NUFJFU1NFRF9SR0JfUFZSVENfMkJQUFYxX0lNRyxcbiAgICAgICdyZ2JhIHB2cnRjIDRicHB2MSc6IEdMX0NPTVBSRVNTRURfUkdCQV9QVlJUQ180QlBQVjFfSU1HLFxuICAgICAgJ3JnYmEgcHZydGMgMmJwcHYxJzogR0xfQ09NUFJFU1NFRF9SR0JBX1BWUlRDXzJCUFBWMV9JTUdcbiAgICB9KVxuICB9XG5cbiAgaWYgKGV4dGVuc2lvbnMud2ViZ2xfY29tcHJlc3NlZF90ZXh0dXJlX2V0YzEpIHtcbiAgICBjb21wcmVzc2VkVGV4dHVyZUZvcm1hdHNbJ3JnYiBldGMxJ10gPSBHTF9DT01QUkVTU0VEX1JHQl9FVEMxX1dFQkdMXG4gIH1cblxuICAvLyBDb3B5IG92ZXIgYWxsIHRleHR1cmUgZm9ybWF0c1xuICB2YXIgc3VwcG9ydGVkQ29tcHJlc3NlZEZvcm1hdHMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChcbiAgICBnbC5nZXRQYXJhbWV0ZXIoR0xfQ09NUFJFU1NFRF9URVhUVVJFX0ZPUk1BVFMpKVxuICBPYmplY3Qua2V5cyhjb21wcmVzc2VkVGV4dHVyZUZvcm1hdHMpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB2YXIgZm9ybWF0ID0gY29tcHJlc3NlZFRleHR1cmVGb3JtYXRzW25hbWVdXG4gICAgaWYgKHN1cHBvcnRlZENvbXByZXNzZWRGb3JtYXRzLmluZGV4T2YoZm9ybWF0KSA+PSAwKSB7XG4gICAgICB0ZXh0dXJlRm9ybWF0c1tuYW1lXSA9IGZvcm1hdFxuICAgIH1cbiAgfSlcblxuICB2YXIgc3VwcG9ydGVkRm9ybWF0cyA9IE9iamVjdC5rZXlzKHRleHR1cmVGb3JtYXRzKVxuICBsaW1pdHMudGV4dHVyZUZvcm1hdHMgPSBzdXBwb3J0ZWRGb3JtYXRzXG5cbiAgLy8gYXNzb2NpYXRlIHdpdGggZXZlcnkgZm9ybWF0IHN0cmluZyBpdHNcbiAgLy8gY29ycmVzcG9uZGluZyBHTC12YWx1ZS5cbiAgdmFyIHRleHR1cmVGb3JtYXRzSW52ZXJ0ID0gW11cbiAgT2JqZWN0LmtleXModGV4dHVyZUZvcm1hdHMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIHZhciB2YWwgPSB0ZXh0dXJlRm9ybWF0c1trZXldXG4gICAgdGV4dHVyZUZvcm1hdHNJbnZlcnRbdmFsXSA9IGtleVxuICB9KVxuXG4gIC8vIGFzc29jaWF0ZSB3aXRoIGV2ZXJ5IHR5cGUgc3RyaW5nIGl0c1xuICAvLyBjb3JyZXNwb25kaW5nIEdMLXZhbHVlLlxuICB2YXIgdGV4dHVyZVR5cGVzSW52ZXJ0ID0gW11cbiAgT2JqZWN0LmtleXModGV4dHVyZVR5cGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICB2YXIgdmFsID0gdGV4dHVyZVR5cGVzW2tleV1cbiAgICB0ZXh0dXJlVHlwZXNJbnZlcnRbdmFsXSA9IGtleVxuICB9KVxuXG4gIHZhciBtYWdGaWx0ZXJzSW52ZXJ0ID0gW11cbiAgT2JqZWN0LmtleXMobWFnRmlsdGVycykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgdmFyIHZhbCA9IG1hZ0ZpbHRlcnNba2V5XVxuICAgIG1hZ0ZpbHRlcnNJbnZlcnRbdmFsXSA9IGtleVxuICB9KVxuXG4gIHZhciBtaW5GaWx0ZXJzSW52ZXJ0ID0gW11cbiAgT2JqZWN0LmtleXMobWluRmlsdGVycykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgdmFyIHZhbCA9IG1pbkZpbHRlcnNba2V5XVxuICAgIG1pbkZpbHRlcnNJbnZlcnRbdmFsXSA9IGtleVxuICB9KVxuXG4gIHZhciB3cmFwTW9kZXNJbnZlcnQgPSBbXVxuICBPYmplY3Qua2V5cyh3cmFwTW9kZXMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIHZhciB2YWwgPSB3cmFwTW9kZXNba2V5XVxuICAgIHdyYXBNb2Rlc0ludmVydFt2YWxdID0ga2V5XG4gIH0pXG5cbiAgLy8gY29sb3JGb3JtYXRzW10gZ2l2ZXMgdGhlIGZvcm1hdCAoY2hhbm5lbHMpIGFzc29jaWF0ZWQgdG8gYW5cbiAgLy8gaW50ZXJuYWxmb3JtYXRcbiAgdmFyIGNvbG9yRm9ybWF0cyA9IHN1cHBvcnRlZEZvcm1hdHMucmVkdWNlKGZ1bmN0aW9uIChjb2xvciwga2V5KSB7XG4gICAgdmFyIGdsZW51bSA9IHRleHR1cmVGb3JtYXRzW2tleV1cbiAgICBpZiAoZ2xlbnVtID09PSBHTF9MVU1JTkFOQ0UgfHxcbiAgICAgICAgZ2xlbnVtID09PSBHTF9BTFBIQSB8fFxuICAgICAgICBnbGVudW0gPT09IEdMX0xVTUlOQU5DRSB8fFxuICAgICAgICBnbGVudW0gPT09IEdMX0xVTUlOQU5DRV9BTFBIQSB8fFxuICAgICAgICBnbGVudW0gPT09IEdMX0RFUFRIX0NPTVBPTkVOVCB8fFxuICAgICAgICBnbGVudW0gPT09IEdMX0RFUFRIX1NURU5DSUwgfHxcbiAgICAgICAgKGV4dGVuc2lvbnMuZXh0X3NyZ2IgJiZcbiAgICAgICAgICAgICAgICAoZ2xlbnVtID09PSBHTF9TUkdCX0VYVCB8fFxuICAgICAgICAgICAgICAgICBnbGVudW0gPT09IEdMX1NSR0JfQUxQSEFfRVhUKSkpIHtcbiAgICAgIGNvbG9yW2dsZW51bV0gPSBnbGVudW1cbiAgICB9IGVsc2UgaWYgKGdsZW51bSA9PT0gR0xfUkdCNV9BMSB8fCBrZXkuaW5kZXhPZigncmdiYScpID49IDApIHtcbiAgICAgIGNvbG9yW2dsZW51bV0gPSBHTF9SR0JBJDFcbiAgICB9IGVsc2Uge1xuICAgICAgY29sb3JbZ2xlbnVtXSA9IEdMX1JHQlxuICAgIH1cbiAgICByZXR1cm4gY29sb3JcbiAgfSwge30pXG5cbiAgZnVuY3Rpb24gVGV4RmxhZ3MgKCkge1xuICAgIC8vIGZvcm1hdCBpbmZvXG4gICAgdGhpcy5pbnRlcm5hbGZvcm1hdCA9IEdMX1JHQkEkMVxuICAgIHRoaXMuZm9ybWF0ID0gR0xfUkdCQSQxXG4gICAgdGhpcy50eXBlID0gR0xfVU5TSUdORURfQllURSQ1XG4gICAgdGhpcy5jb21wcmVzc2VkID0gZmFsc2VcblxuICAgIC8vIHBpeGVsIHN0b3JhZ2VcbiAgICB0aGlzLnByZW11bHRpcGx5QWxwaGEgPSBmYWxzZVxuICAgIHRoaXMuZmxpcFkgPSBmYWxzZVxuICAgIHRoaXMudW5wYWNrQWxpZ25tZW50ID0gMVxuICAgIHRoaXMuY29sb3JTcGFjZSA9IEdMX0JST1dTRVJfREVGQVVMVF9XRUJHTFxuXG4gICAgLy8gc2hhcGUgaW5mb1xuICAgIHRoaXMud2lkdGggPSAwXG4gICAgdGhpcy5oZWlnaHQgPSAwXG4gICAgdGhpcy5jaGFubmVscyA9IDBcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvcHlGbGFncyAocmVzdWx0LCBvdGhlcikge1xuICAgIHJlc3VsdC5pbnRlcm5hbGZvcm1hdCA9IG90aGVyLmludGVybmFsZm9ybWF0XG4gICAgcmVzdWx0LmZvcm1hdCA9IG90aGVyLmZvcm1hdFxuICAgIHJlc3VsdC50eXBlID0gb3RoZXIudHlwZVxuICAgIHJlc3VsdC5jb21wcmVzc2VkID0gb3RoZXIuY29tcHJlc3NlZFxuXG4gICAgcmVzdWx0LnByZW11bHRpcGx5QWxwaGEgPSBvdGhlci5wcmVtdWx0aXBseUFscGhhXG4gICAgcmVzdWx0LmZsaXBZID0gb3RoZXIuZmxpcFlcbiAgICByZXN1bHQudW5wYWNrQWxpZ25tZW50ID0gb3RoZXIudW5wYWNrQWxpZ25tZW50XG4gICAgcmVzdWx0LmNvbG9yU3BhY2UgPSBvdGhlci5jb2xvclNwYWNlXG5cbiAgICByZXN1bHQud2lkdGggPSBvdGhlci53aWR0aFxuICAgIHJlc3VsdC5oZWlnaHQgPSBvdGhlci5oZWlnaHRcbiAgICByZXN1bHQuY2hhbm5lbHMgPSBvdGhlci5jaGFubmVsc1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VGbGFncyAoZmxhZ3MsIG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgIT09ICdvYmplY3QnIHx8ICFvcHRpb25zKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAoJ3ByZW11bHRpcGx5QWxwaGEnIGluIG9wdGlvbnMpIHtcbiAgICAgIGNoZWNrJDEudHlwZShvcHRpb25zLnByZW11bHRpcGx5QWxwaGEsICdib29sZWFuJyxcbiAgICAgICAgJ2ludmFsaWQgcHJlbXVsdGlwbHlBbHBoYScpXG4gICAgICBmbGFncy5wcmVtdWx0aXBseUFscGhhID0gb3B0aW9ucy5wcmVtdWx0aXBseUFscGhhXG4gICAgfVxuXG4gICAgaWYgKCdmbGlwWScgaW4gb3B0aW9ucykge1xuICAgICAgY2hlY2skMS50eXBlKG9wdGlvbnMuZmxpcFksICdib29sZWFuJyxcbiAgICAgICAgJ2ludmFsaWQgdGV4dHVyZSBmbGlwJylcbiAgICAgIGZsYWdzLmZsaXBZID0gb3B0aW9ucy5mbGlwWVxuICAgIH1cblxuICAgIGlmICgnYWxpZ25tZW50JyBpbiBvcHRpb25zKSB7XG4gICAgICBjaGVjayQxLm9uZU9mKG9wdGlvbnMuYWxpZ25tZW50LCBbMSwgMiwgNCwgOF0sXG4gICAgICAgICdpbnZhbGlkIHRleHR1cmUgdW5wYWNrIGFsaWdubWVudCcpXG4gICAgICBmbGFncy51bnBhY2tBbGlnbm1lbnQgPSBvcHRpb25zLmFsaWdubWVudFxuICAgIH1cblxuICAgIGlmICgnY29sb3JTcGFjZScgaW4gb3B0aW9ucykge1xuICAgICAgY2hlY2skMS5wYXJhbWV0ZXIob3B0aW9ucy5jb2xvclNwYWNlLCBjb2xvclNwYWNlLFxuICAgICAgICAnaW52YWxpZCBjb2xvclNwYWNlJylcbiAgICAgIGZsYWdzLmNvbG9yU3BhY2UgPSBjb2xvclNwYWNlW29wdGlvbnMuY29sb3JTcGFjZV1cbiAgICB9XG5cbiAgICBpZiAoJ3R5cGUnIGluIG9wdGlvbnMpIHtcbiAgICAgIHZhciB0eXBlID0gb3B0aW9ucy50eXBlXG4gICAgICBjaGVjayQxKGV4dGVuc2lvbnMub2VzX3RleHR1cmVfZmxvYXQgfHxcbiAgICAgICAgISh0eXBlID09PSAnZmxvYXQnIHx8IHR5cGUgPT09ICdmbG9hdDMyJyksXG4gICAgICAneW91IG11c3QgZW5hYmxlIHRoZSBPRVNfdGV4dHVyZV9mbG9hdCBleHRlbnNpb24gaW4gb3JkZXIgdG8gdXNlIGZsb2F0aW5nIHBvaW50IHRleHR1cmVzLicpXG4gICAgICBjaGVjayQxKGV4dGVuc2lvbnMub2VzX3RleHR1cmVfaGFsZl9mbG9hdCB8fFxuICAgICAgICAhKHR5cGUgPT09ICdoYWxmIGZsb2F0JyB8fCB0eXBlID09PSAnZmxvYXQxNicpLFxuICAgICAgJ3lvdSBtdXN0IGVuYWJsZSB0aGUgT0VTX3RleHR1cmVfaGFsZl9mbG9hdCBleHRlbnNpb24gaW4gb3JkZXIgdG8gdXNlIDE2LWJpdCBmbG9hdGluZyBwb2ludCB0ZXh0dXJlcy4nKVxuICAgICAgY2hlY2skMShleHRlbnNpb25zLndlYmdsX2RlcHRoX3RleHR1cmUgfHxcbiAgICAgICAgISh0eXBlID09PSAndWludDE2JyB8fCB0eXBlID09PSAndWludDMyJyB8fCB0eXBlID09PSAnZGVwdGggc3RlbmNpbCcpLFxuICAgICAgJ3lvdSBtdXN0IGVuYWJsZSB0aGUgV0VCR0xfZGVwdGhfdGV4dHVyZSBleHRlbnNpb24gaW4gb3JkZXIgdG8gdXNlIGRlcHRoL3N0ZW5jaWwgdGV4dHVyZXMuJylcbiAgICAgIGNoZWNrJDEucGFyYW1ldGVyKHR5cGUsIHRleHR1cmVUeXBlcyxcbiAgICAgICAgJ2ludmFsaWQgdGV4dHVyZSB0eXBlJylcbiAgICAgIGZsYWdzLnR5cGUgPSB0ZXh0dXJlVHlwZXNbdHlwZV1cbiAgICB9XG5cbiAgICB2YXIgdyA9IGZsYWdzLndpZHRoXG4gICAgdmFyIGggPSBmbGFncy5oZWlnaHRcbiAgICB2YXIgYyA9IGZsYWdzLmNoYW5uZWxzXG4gICAgdmFyIGhhc0NoYW5uZWxzID0gZmFsc2VcbiAgICBpZiAoJ3NoYXBlJyBpbiBvcHRpb25zKSB7XG4gICAgICBjaGVjayQxKEFycmF5LmlzQXJyYXkob3B0aW9ucy5zaGFwZSkgJiYgb3B0aW9ucy5zaGFwZS5sZW5ndGggPj0gMixcbiAgICAgICAgJ3NoYXBlIG11c3QgYmUgYW4gYXJyYXknKVxuICAgICAgdyA9IG9wdGlvbnMuc2hhcGVbMF1cbiAgICAgIGggPSBvcHRpb25zLnNoYXBlWzFdXG4gICAgICBpZiAob3B0aW9ucy5zaGFwZS5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgYyA9IG9wdGlvbnMuc2hhcGVbMl1cbiAgICAgICAgY2hlY2skMShjID4gMCAmJiBjIDw9IDQsICdpbnZhbGlkIG51bWJlciBvZiBjaGFubmVscycpXG4gICAgICAgIGhhc0NoYW5uZWxzID0gdHJ1ZVxuICAgICAgfVxuICAgICAgY2hlY2skMSh3ID49IDAgJiYgdyA8PSBsaW1pdHMubWF4VGV4dHVyZVNpemUsICdpbnZhbGlkIHdpZHRoJylcbiAgICAgIGNoZWNrJDEoaCA+PSAwICYmIGggPD0gbGltaXRzLm1heFRleHR1cmVTaXplLCAnaW52YWxpZCBoZWlnaHQnKVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoJ3JhZGl1cycgaW4gb3B0aW9ucykge1xuICAgICAgICB3ID0gaCA9IG9wdGlvbnMucmFkaXVzXG4gICAgICAgIGNoZWNrJDEodyA+PSAwICYmIHcgPD0gbGltaXRzLm1heFRleHR1cmVTaXplLCAnaW52YWxpZCByYWRpdXMnKVxuICAgICAgfVxuICAgICAgaWYgKCd3aWR0aCcgaW4gb3B0aW9ucykge1xuICAgICAgICB3ID0gb3B0aW9ucy53aWR0aFxuICAgICAgICBjaGVjayQxKHcgPj0gMCAmJiB3IDw9IGxpbWl0cy5tYXhUZXh0dXJlU2l6ZSwgJ2ludmFsaWQgd2lkdGgnKVxuICAgICAgfVxuICAgICAgaWYgKCdoZWlnaHQnIGluIG9wdGlvbnMpIHtcbiAgICAgICAgaCA9IG9wdGlvbnMuaGVpZ2h0XG4gICAgICAgIGNoZWNrJDEoaCA+PSAwICYmIGggPD0gbGltaXRzLm1heFRleHR1cmVTaXplLCAnaW52YWxpZCBoZWlnaHQnKVxuICAgICAgfVxuICAgICAgaWYgKCdjaGFubmVscycgaW4gb3B0aW9ucykge1xuICAgICAgICBjID0gb3B0aW9ucy5jaGFubmVsc1xuICAgICAgICBjaGVjayQxKGMgPiAwICYmIGMgPD0gNCwgJ2ludmFsaWQgbnVtYmVyIG9mIGNoYW5uZWxzJylcbiAgICAgICAgaGFzQ2hhbm5lbHMgPSB0cnVlXG4gICAgICB9XG4gICAgfVxuICAgIGZsYWdzLndpZHRoID0gdyB8IDBcbiAgICBmbGFncy5oZWlnaHQgPSBoIHwgMFxuICAgIGZsYWdzLmNoYW5uZWxzID0gYyB8IDBcblxuICAgIHZhciBoYXNGb3JtYXQgPSBmYWxzZVxuICAgIGlmICgnZm9ybWF0JyBpbiBvcHRpb25zKSB7XG4gICAgICB2YXIgZm9ybWF0U3RyID0gb3B0aW9ucy5mb3JtYXRcbiAgICAgIGNoZWNrJDEoZXh0ZW5zaW9ucy53ZWJnbF9kZXB0aF90ZXh0dXJlIHx8XG4gICAgICAgICEoZm9ybWF0U3RyID09PSAnZGVwdGgnIHx8IGZvcm1hdFN0ciA9PT0gJ2RlcHRoIHN0ZW5jaWwnKSxcbiAgICAgICd5b3UgbXVzdCBlbmFibGUgdGhlIFdFQkdMX2RlcHRoX3RleHR1cmUgZXh0ZW5zaW9uIGluIG9yZGVyIHRvIHVzZSBkZXB0aC9zdGVuY2lsIHRleHR1cmVzLicpXG4gICAgICBjaGVjayQxLnBhcmFtZXRlcihmb3JtYXRTdHIsIHRleHR1cmVGb3JtYXRzLFxuICAgICAgICAnaW52YWxpZCB0ZXh0dXJlIGZvcm1hdCcpXG4gICAgICB2YXIgaW50ZXJuYWxmb3JtYXQgPSBmbGFncy5pbnRlcm5hbGZvcm1hdCA9IHRleHR1cmVGb3JtYXRzW2Zvcm1hdFN0cl1cbiAgICAgIGZsYWdzLmZvcm1hdCA9IGNvbG9yRm9ybWF0c1tpbnRlcm5hbGZvcm1hdF1cbiAgICAgIGlmIChmb3JtYXRTdHIgaW4gdGV4dHVyZVR5cGVzKSB7XG4gICAgICAgIGlmICghKCd0eXBlJyBpbiBvcHRpb25zKSkge1xuICAgICAgICAgIGZsYWdzLnR5cGUgPSB0ZXh0dXJlVHlwZXNbZm9ybWF0U3RyXVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZm9ybWF0U3RyIGluIGNvbXByZXNzZWRUZXh0dXJlRm9ybWF0cykge1xuICAgICAgICBmbGFncy5jb21wcmVzc2VkID0gdHJ1ZVxuICAgICAgfVxuICAgICAgaGFzRm9ybWF0ID0gdHJ1ZVxuICAgIH1cblxuICAgIC8vIFJlY29uY2lsZSBjaGFubmVscyBhbmQgZm9ybWF0XG4gICAgaWYgKCFoYXNDaGFubmVscyAmJiBoYXNGb3JtYXQpIHtcbiAgICAgIGZsYWdzLmNoYW5uZWxzID0gRk9STUFUX0NIQU5ORUxTW2ZsYWdzLmZvcm1hdF1cbiAgICB9IGVsc2UgaWYgKGhhc0NoYW5uZWxzICYmICFoYXNGb3JtYXQpIHtcbiAgICAgIGlmIChmbGFncy5jaGFubmVscyAhPT0gQ0hBTk5FTFNfRk9STUFUW2ZsYWdzLmZvcm1hdF0pIHtcbiAgICAgICAgZmxhZ3MuZm9ybWF0ID0gZmxhZ3MuaW50ZXJuYWxmb3JtYXQgPSBDSEFOTkVMU19GT1JNQVRbZmxhZ3MuY2hhbm5lbHNdXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChoYXNGb3JtYXQgJiYgaGFzQ2hhbm5lbHMpIHtcbiAgICAgIGNoZWNrJDEoXG4gICAgICAgIGZsYWdzLmNoYW5uZWxzID09PSBGT1JNQVRfQ0hBTk5FTFNbZmxhZ3MuZm9ybWF0XSxcbiAgICAgICAgJ251bWJlciBvZiBjaGFubmVscyBpbmNvbnNpc3RlbnQgd2l0aCBzcGVjaWZpZWQgZm9ybWF0JylcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzZXRGbGFncyAoZmxhZ3MpIHtcbiAgICBnbC5waXhlbFN0b3JlaShHTF9VTlBBQ0tfRkxJUF9ZX1dFQkdMLCBmbGFncy5mbGlwWSlcbiAgICBnbC5waXhlbFN0b3JlaShHTF9VTlBBQ0tfUFJFTVVMVElQTFlfQUxQSEFfV0VCR0wsIGZsYWdzLnByZW11bHRpcGx5QWxwaGEpXG4gICAgZ2wucGl4ZWxTdG9yZWkoR0xfVU5QQUNLX0NPTE9SU1BBQ0VfQ09OVkVSU0lPTl9XRUJHTCwgZmxhZ3MuY29sb3JTcGFjZSlcbiAgICBnbC5waXhlbFN0b3JlaShHTF9VTlBBQ0tfQUxJR05NRU5ULCBmbGFncy51bnBhY2tBbGlnbm1lbnQpXG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIFRleCBpbWFnZSBkYXRhXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgZnVuY3Rpb24gVGV4SW1hZ2UgKCkge1xuICAgIFRleEZsYWdzLmNhbGwodGhpcylcblxuICAgIHRoaXMueE9mZnNldCA9IDBcbiAgICB0aGlzLnlPZmZzZXQgPSAwXG5cbiAgICAvLyBkYXRhXG4gICAgdGhpcy5kYXRhID0gbnVsbFxuICAgIHRoaXMubmVlZHNGcmVlID0gZmFsc2VcblxuICAgIC8vIGh0bWwgZWxlbWVudFxuICAgIHRoaXMuZWxlbWVudCA9IG51bGxcblxuICAgIC8vIGNvcHlUZXhJbWFnZSBpbmZvXG4gICAgdGhpcy5uZWVkc0NvcHkgPSBmYWxzZVxuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VJbWFnZSAoaW1hZ2UsIG9wdGlvbnMpIHtcbiAgICB2YXIgZGF0YSA9IG51bGxcbiAgICBpZiAoaXNQaXhlbERhdGEob3B0aW9ucykpIHtcbiAgICAgIGRhdGEgPSBvcHRpb25zXG4gICAgfSBlbHNlIGlmIChvcHRpb25zKSB7XG4gICAgICBjaGVjayQxLnR5cGUob3B0aW9ucywgJ29iamVjdCcsICdpbnZhbGlkIHBpeGVsIGRhdGEgdHlwZScpXG4gICAgICBwYXJzZUZsYWdzKGltYWdlLCBvcHRpb25zKVxuICAgICAgaWYgKCd4JyBpbiBvcHRpb25zKSB7XG4gICAgICAgIGltYWdlLnhPZmZzZXQgPSBvcHRpb25zLnggfCAwXG4gICAgICB9XG4gICAgICBpZiAoJ3knIGluIG9wdGlvbnMpIHtcbiAgICAgICAgaW1hZ2UueU9mZnNldCA9IG9wdGlvbnMueSB8IDBcbiAgICAgIH1cbiAgICAgIGlmIChpc1BpeGVsRGF0YShvcHRpb25zLmRhdGEpKSB7XG4gICAgICAgIGRhdGEgPSBvcHRpb25zLmRhdGFcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjaGVjayQxKFxuICAgICAgIWltYWdlLmNvbXByZXNzZWQgfHxcbiAgICAgIGRhdGEgaW5zdGFuY2VvZiBVaW50OEFycmF5LFxuICAgICAgJ2NvbXByZXNzZWQgdGV4dHVyZSBkYXRhIG11c3QgYmUgc3RvcmVkIGluIGEgdWludDhhcnJheScpXG5cbiAgICBpZiAob3B0aW9ucy5jb3B5KSB7XG4gICAgICBjaGVjayQxKCFkYXRhLCAnY2FuIG5vdCBzcGVjaWZ5IGNvcHkgYW5kIGRhdGEgZmllbGQgZm9yIHRoZSBzYW1lIHRleHR1cmUnKVxuICAgICAgdmFyIHZpZXdXID0gY29udGV4dFN0YXRlLnZpZXdwb3J0V2lkdGhcbiAgICAgIHZhciB2aWV3SCA9IGNvbnRleHRTdGF0ZS52aWV3cG9ydEhlaWdodFxuICAgICAgaW1hZ2Uud2lkdGggPSBpbWFnZS53aWR0aCB8fCAodmlld1cgLSBpbWFnZS54T2Zmc2V0KVxuICAgICAgaW1hZ2UuaGVpZ2h0ID0gaW1hZ2UuaGVpZ2h0IHx8ICh2aWV3SCAtIGltYWdlLnlPZmZzZXQpXG4gICAgICBpbWFnZS5uZWVkc0NvcHkgPSB0cnVlXG4gICAgICBjaGVjayQxKGltYWdlLnhPZmZzZXQgPj0gMCAmJiBpbWFnZS54T2Zmc2V0IDwgdmlld1cgJiZcbiAgICAgICAgICAgIGltYWdlLnlPZmZzZXQgPj0gMCAmJiBpbWFnZS55T2Zmc2V0IDwgdmlld0ggJiZcbiAgICAgICAgICAgIGltYWdlLndpZHRoID4gMCAmJiBpbWFnZS53aWR0aCA8PSB2aWV3VyAmJlxuICAgICAgICAgICAgaW1hZ2UuaGVpZ2h0ID4gMCAmJiBpbWFnZS5oZWlnaHQgPD0gdmlld0gsXG4gICAgICAnY29weSB0ZXh0dXJlIHJlYWQgb3V0IG9mIGJvdW5kcycpXG4gICAgfSBlbHNlIGlmICghZGF0YSkge1xuICAgICAgaW1hZ2Uud2lkdGggPSBpbWFnZS53aWR0aCB8fCAxXG4gICAgICBpbWFnZS5oZWlnaHQgPSBpbWFnZS5oZWlnaHQgfHwgMVxuICAgICAgaW1hZ2UuY2hhbm5lbHMgPSBpbWFnZS5jaGFubmVscyB8fCA0XG4gICAgfSBlbHNlIGlmIChpc1R5cGVkQXJyYXkoZGF0YSkpIHtcbiAgICAgIGltYWdlLmNoYW5uZWxzID0gaW1hZ2UuY2hhbm5lbHMgfHwgNFxuICAgICAgaW1hZ2UuZGF0YSA9IGRhdGFcbiAgICAgIGlmICghKCd0eXBlJyBpbiBvcHRpb25zKSAmJiBpbWFnZS50eXBlID09PSBHTF9VTlNJR05FRF9CWVRFJDUpIHtcbiAgICAgICAgaW1hZ2UudHlwZSA9IHR5cGVkQXJyYXlDb2RlJDEoZGF0YSlcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzTnVtZXJpY0FycmF5KGRhdGEpKSB7XG4gICAgICBpbWFnZS5jaGFubmVscyA9IGltYWdlLmNoYW5uZWxzIHx8IDRcbiAgICAgIGNvbnZlcnREYXRhKGltYWdlLCBkYXRhKVxuICAgICAgaW1hZ2UuYWxpZ25tZW50ID0gMVxuICAgICAgaW1hZ2UubmVlZHNGcmVlID0gdHJ1ZVxuICAgIH0gZWxzZSBpZiAoaXNOREFycmF5TGlrZShkYXRhKSkge1xuICAgICAgdmFyIGFycmF5ID0gZGF0YS5kYXRhXG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkoYXJyYXkpICYmIGltYWdlLnR5cGUgPT09IEdMX1VOU0lHTkVEX0JZVEUkNSkge1xuICAgICAgICBpbWFnZS50eXBlID0gdHlwZWRBcnJheUNvZGUkMShhcnJheSlcbiAgICAgIH1cbiAgICAgIHZhciBzaGFwZSA9IGRhdGEuc2hhcGVcbiAgICAgIHZhciBzdHJpZGUgPSBkYXRhLnN0cmlkZVxuICAgICAgdmFyIHNoYXBlWCwgc2hhcGVZLCBzaGFwZUMsIHN0cmlkZVgsIHN0cmlkZVksIHN0cmlkZUNcbiAgICAgIGlmIChzaGFwZS5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgc2hhcGVDID0gc2hhcGVbMl1cbiAgICAgICAgc3RyaWRlQyA9IHN0cmlkZVsyXVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2hlY2skMShzaGFwZS5sZW5ndGggPT09IDIsICdpbnZhbGlkIG5kYXJyYXkgcGl4ZWwgZGF0YSwgbXVzdCBiZSAyIG9yIDNEJylcbiAgICAgICAgc2hhcGVDID0gMVxuICAgICAgICBzdHJpZGVDID0gMVxuICAgICAgfVxuICAgICAgc2hhcGVYID0gc2hhcGVbMF1cbiAgICAgIHNoYXBlWSA9IHNoYXBlWzFdXG4gICAgICBzdHJpZGVYID0gc3RyaWRlWzBdXG4gICAgICBzdHJpZGVZID0gc3RyaWRlWzFdXG4gICAgICBpbWFnZS5hbGlnbm1lbnQgPSAxXG4gICAgICBpbWFnZS53aWR0aCA9IHNoYXBlWFxuICAgICAgaW1hZ2UuaGVpZ2h0ID0gc2hhcGVZXG4gICAgICBpbWFnZS5jaGFubmVscyA9IHNoYXBlQ1xuICAgICAgaW1hZ2UuZm9ybWF0ID0gaW1hZ2UuaW50ZXJuYWxmb3JtYXQgPSBDSEFOTkVMU19GT1JNQVRbc2hhcGVDXVxuICAgICAgaW1hZ2UubmVlZHNGcmVlID0gdHJ1ZVxuICAgICAgdHJhbnNwb3NlRGF0YShpbWFnZSwgYXJyYXksIHN0cmlkZVgsIHN0cmlkZVksIHN0cmlkZUMsIGRhdGEub2Zmc2V0KVxuICAgIH0gZWxzZSBpZiAoaXNDYW52YXNFbGVtZW50KGRhdGEpIHx8IGlzT2Zmc2NyZWVuQ2FudmFzKGRhdGEpIHx8IGlzQ29udGV4dDJEKGRhdGEpKSB7XG4gICAgICBpZiAoaXNDYW52YXNFbGVtZW50KGRhdGEpIHx8IGlzT2Zmc2NyZWVuQ2FudmFzKGRhdGEpKSB7XG4gICAgICAgIGltYWdlLmVsZW1lbnQgPSBkYXRhXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbWFnZS5lbGVtZW50ID0gZGF0YS5jYW52YXNcbiAgICAgIH1cbiAgICAgIGltYWdlLndpZHRoID0gaW1hZ2UuZWxlbWVudC53aWR0aFxuICAgICAgaW1hZ2UuaGVpZ2h0ID0gaW1hZ2UuZWxlbWVudC5oZWlnaHRcbiAgICAgIGltYWdlLmNoYW5uZWxzID0gNFxuICAgIH0gZWxzZSBpZiAoaXNCaXRtYXAoZGF0YSkpIHtcbiAgICAgIGltYWdlLmVsZW1lbnQgPSBkYXRhXG4gICAgICBpbWFnZS53aWR0aCA9IGRhdGEud2lkdGhcbiAgICAgIGltYWdlLmhlaWdodCA9IGRhdGEuaGVpZ2h0XG4gICAgICBpbWFnZS5jaGFubmVscyA9IDRcbiAgICB9IGVsc2UgaWYgKGlzSW1hZ2VFbGVtZW50KGRhdGEpKSB7XG4gICAgICBpbWFnZS5lbGVtZW50ID0gZGF0YVxuICAgICAgaW1hZ2Uud2lkdGggPSBkYXRhLm5hdHVyYWxXaWR0aFxuICAgICAgaW1hZ2UuaGVpZ2h0ID0gZGF0YS5uYXR1cmFsSGVpZ2h0XG4gICAgICBpbWFnZS5jaGFubmVscyA9IDRcbiAgICB9IGVsc2UgaWYgKGlzVmlkZW9FbGVtZW50KGRhdGEpKSB7XG4gICAgICBpbWFnZS5lbGVtZW50ID0gZGF0YVxuICAgICAgaW1hZ2Uud2lkdGggPSBkYXRhLnZpZGVvV2lkdGhcbiAgICAgIGltYWdlLmhlaWdodCA9IGRhdGEudmlkZW9IZWlnaHRcbiAgICAgIGltYWdlLmNoYW5uZWxzID0gNFxuICAgIH0gZWxzZSBpZiAoaXNSZWN0QXJyYXkoZGF0YSkpIHtcbiAgICAgIHZhciB3ID0gaW1hZ2Uud2lkdGggfHwgZGF0YVswXS5sZW5ndGhcbiAgICAgIHZhciBoID0gaW1hZ2UuaGVpZ2h0IHx8IGRhdGEubGVuZ3RoXG4gICAgICB2YXIgYyA9IGltYWdlLmNoYW5uZWxzXG4gICAgICBpZiAoaXNBcnJheUxpa2UoZGF0YVswXVswXSkpIHtcbiAgICAgICAgYyA9IGMgfHwgZGF0YVswXVswXS5sZW5ndGhcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGMgPSBjIHx8IDFcbiAgICAgIH1cbiAgICAgIHZhciBhcnJheVNoYXBlID0gZmxhdHRlblV0aWxzLnNoYXBlKGRhdGEpXG4gICAgICB2YXIgbiA9IDFcbiAgICAgIGZvciAodmFyIGRkID0gMDsgZGQgPCBhcnJheVNoYXBlLmxlbmd0aDsgKytkZCkge1xuICAgICAgICBuICo9IGFycmF5U2hhcGVbZGRdXG4gICAgICB9XG4gICAgICB2YXIgYWxsb2NEYXRhID0gcHJlQ29udmVydChpbWFnZSwgbilcbiAgICAgIGZsYXR0ZW5VdGlscy5mbGF0dGVuKGRhdGEsIGFycmF5U2hhcGUsICcnLCBhbGxvY0RhdGEpXG4gICAgICBwb3N0Q29udmVydChpbWFnZSwgYWxsb2NEYXRhKVxuICAgICAgaW1hZ2UuYWxpZ25tZW50ID0gMVxuICAgICAgaW1hZ2Uud2lkdGggPSB3XG4gICAgICBpbWFnZS5oZWlnaHQgPSBoXG4gICAgICBpbWFnZS5jaGFubmVscyA9IGNcbiAgICAgIGltYWdlLmZvcm1hdCA9IGltYWdlLmludGVybmFsZm9ybWF0ID0gQ0hBTk5FTFNfRk9STUFUW2NdXG4gICAgICBpbWFnZS5uZWVkc0ZyZWUgPSB0cnVlXG4gICAgfVxuXG4gICAgaWYgKGltYWdlLnR5cGUgPT09IEdMX0ZMT0FUJDQpIHtcbiAgICAgIGNoZWNrJDEobGltaXRzLmV4dGVuc2lvbnMuaW5kZXhPZignb2VzX3RleHR1cmVfZmxvYXQnKSA+PSAwLFxuICAgICAgICAnb2VzX3RleHR1cmVfZmxvYXQgZXh0ZW5zaW9uIG5vdCBlbmFibGVkJylcbiAgICB9IGVsc2UgaWYgKGltYWdlLnR5cGUgPT09IEdMX0hBTEZfRkxPQVRfT0VTJDEpIHtcbiAgICAgIGNoZWNrJDEobGltaXRzLmV4dGVuc2lvbnMuaW5kZXhPZignb2VzX3RleHR1cmVfaGFsZl9mbG9hdCcpID49IDAsXG4gICAgICAgICdvZXNfdGV4dHVyZV9oYWxmX2Zsb2F0IGV4dGVuc2lvbiBub3QgZW5hYmxlZCcpXG4gICAgfVxuXG4gICAgLy8gZG8gY29tcHJlc3NlZCB0ZXh0dXJlICB2YWxpZGF0aW9uIGhlcmUuXG4gIH1cblxuICBmdW5jdGlvbiBzZXRJbWFnZSAoaW5mbywgdGFyZ2V0LCBtaXBsZXZlbCkge1xuICAgIHZhciBlbGVtZW50ID0gaW5mby5lbGVtZW50XG4gICAgdmFyIGRhdGEgPSBpbmZvLmRhdGFcbiAgICB2YXIgaW50ZXJuYWxmb3JtYXQgPSBpbmZvLmludGVybmFsZm9ybWF0XG4gICAgdmFyIGZvcm1hdCA9IGluZm8uZm9ybWF0XG4gICAgdmFyIHR5cGUgPSBpbmZvLnR5cGVcbiAgICB2YXIgd2lkdGggPSBpbmZvLndpZHRoXG4gICAgdmFyIGhlaWdodCA9IGluZm8uaGVpZ2h0XG5cbiAgICBzZXRGbGFncyhpbmZvKVxuXG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIGdsLnRleEltYWdlMkQodGFyZ2V0LCBtaXBsZXZlbCwgZm9ybWF0LCBmb3JtYXQsIHR5cGUsIGVsZW1lbnQpXG4gICAgfSBlbHNlIGlmIChpbmZvLmNvbXByZXNzZWQpIHtcbiAgICAgIGdsLmNvbXByZXNzZWRUZXhJbWFnZTJEKHRhcmdldCwgbWlwbGV2ZWwsIGludGVybmFsZm9ybWF0LCB3aWR0aCwgaGVpZ2h0LCAwLCBkYXRhKVxuICAgIH0gZWxzZSBpZiAoaW5mby5uZWVkc0NvcHkpIHtcbiAgICAgIHJlZ2xQb2xsKClcbiAgICAgIGdsLmNvcHlUZXhJbWFnZTJEKFxuICAgICAgICB0YXJnZXQsIG1pcGxldmVsLCBmb3JtYXQsIGluZm8ueE9mZnNldCwgaW5mby55T2Zmc2V0LCB3aWR0aCwgaGVpZ2h0LCAwKVxuICAgIH0gZWxzZSB7XG4gICAgICBnbC50ZXhJbWFnZTJEKHRhcmdldCwgbWlwbGV2ZWwsIGZvcm1hdCwgd2lkdGgsIGhlaWdodCwgMCwgZm9ybWF0LCB0eXBlLCBkYXRhIHx8IG51bGwpXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2V0U3ViSW1hZ2UgKGluZm8sIHRhcmdldCwgeCwgeSwgbWlwbGV2ZWwpIHtcbiAgICB2YXIgZWxlbWVudCA9IGluZm8uZWxlbWVudFxuICAgIHZhciBkYXRhID0gaW5mby5kYXRhXG4gICAgdmFyIGludGVybmFsZm9ybWF0ID0gaW5mby5pbnRlcm5hbGZvcm1hdFxuICAgIHZhciBmb3JtYXQgPSBpbmZvLmZvcm1hdFxuICAgIHZhciB0eXBlID0gaW5mby50eXBlXG4gICAgdmFyIHdpZHRoID0gaW5mby53aWR0aFxuICAgIHZhciBoZWlnaHQgPSBpbmZvLmhlaWdodFxuXG4gICAgc2V0RmxhZ3MoaW5mbylcblxuICAgIGlmIChlbGVtZW50KSB7XG4gICAgICBnbC50ZXhTdWJJbWFnZTJEKFxuICAgICAgICB0YXJnZXQsIG1pcGxldmVsLCB4LCB5LCBmb3JtYXQsIHR5cGUsIGVsZW1lbnQpXG4gICAgfSBlbHNlIGlmIChpbmZvLmNvbXByZXNzZWQpIHtcbiAgICAgIGdsLmNvbXByZXNzZWRUZXhTdWJJbWFnZTJEKFxuICAgICAgICB0YXJnZXQsIG1pcGxldmVsLCB4LCB5LCBpbnRlcm5hbGZvcm1hdCwgd2lkdGgsIGhlaWdodCwgZGF0YSlcbiAgICB9IGVsc2UgaWYgKGluZm8ubmVlZHNDb3B5KSB7XG4gICAgICByZWdsUG9sbCgpXG4gICAgICBnbC5jb3B5VGV4U3ViSW1hZ2UyRChcbiAgICAgICAgdGFyZ2V0LCBtaXBsZXZlbCwgeCwgeSwgaW5mby54T2Zmc2V0LCBpbmZvLnlPZmZzZXQsIHdpZHRoLCBoZWlnaHQpXG4gICAgfSBlbHNlIHtcbiAgICAgIGdsLnRleFN1YkltYWdlMkQoXG4gICAgICAgIHRhcmdldCwgbWlwbGV2ZWwsIHgsIHksIHdpZHRoLCBoZWlnaHQsIGZvcm1hdCwgdHlwZSwgZGF0YSlcbiAgICB9XG4gIH1cblxuICAvLyB0ZXhJbWFnZSBwb29sXG4gIHZhciBpbWFnZVBvb2wgPSBbXVxuXG4gIGZ1bmN0aW9uIGFsbG9jSW1hZ2UgKCkge1xuICAgIHJldHVybiBpbWFnZVBvb2wucG9wKCkgfHwgbmV3IFRleEltYWdlKClcbiAgfVxuXG4gIGZ1bmN0aW9uIGZyZWVJbWFnZSAoaW1hZ2UpIHtcbiAgICBpZiAoaW1hZ2UubmVlZHNGcmVlKSB7XG4gICAgICBwb29sLmZyZWVUeXBlKGltYWdlLmRhdGEpXG4gICAgfVxuICAgIFRleEltYWdlLmNhbGwoaW1hZ2UpXG4gICAgaW1hZ2VQb29sLnB1c2goaW1hZ2UpXG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIE1pcCBtYXBcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICBmdW5jdGlvbiBNaXBNYXAgKCkge1xuICAgIFRleEZsYWdzLmNhbGwodGhpcylcblxuICAgIHRoaXMuZ2VuTWlwbWFwcyA9IGZhbHNlXG4gICAgdGhpcy5taXBtYXBIaW50ID0gR0xfRE9OVF9DQVJFXG4gICAgdGhpcy5taXBtYXNrID0gMFxuICAgIHRoaXMuaW1hZ2VzID0gQXJyYXkoMTYpXG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZU1pcE1hcEZyb21TaGFwZSAobWlwbWFwLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgdmFyIGltZyA9IG1pcG1hcC5pbWFnZXNbMF0gPSBhbGxvY0ltYWdlKClcbiAgICBtaXBtYXAubWlwbWFzayA9IDFcbiAgICBpbWcud2lkdGggPSBtaXBtYXAud2lkdGggPSB3aWR0aFxuICAgIGltZy5oZWlnaHQgPSBtaXBtYXAuaGVpZ2h0ID0gaGVpZ2h0XG4gICAgaW1nLmNoYW5uZWxzID0gbWlwbWFwLmNoYW5uZWxzID0gNFxuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VNaXBNYXBGcm9tT2JqZWN0IChtaXBtYXAsIG9wdGlvbnMpIHtcbiAgICB2YXIgaW1nRGF0YSA9IG51bGxcbiAgICBpZiAoaXNQaXhlbERhdGEob3B0aW9ucykpIHtcbiAgICAgIGltZ0RhdGEgPSBtaXBtYXAuaW1hZ2VzWzBdID0gYWxsb2NJbWFnZSgpXG4gICAgICBjb3B5RmxhZ3MoaW1nRGF0YSwgbWlwbWFwKVxuICAgICAgcGFyc2VJbWFnZShpbWdEYXRhLCBvcHRpb25zKVxuICAgICAgbWlwbWFwLm1pcG1hc2sgPSAxXG4gICAgfSBlbHNlIHtcbiAgICAgIHBhcnNlRmxhZ3MobWlwbWFwLCBvcHRpb25zKVxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkob3B0aW9ucy5taXBtYXApKSB7XG4gICAgICAgIHZhciBtaXBEYXRhID0gb3B0aW9ucy5taXBtYXBcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtaXBEYXRhLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgaW1nRGF0YSA9IG1pcG1hcC5pbWFnZXNbaV0gPSBhbGxvY0ltYWdlKClcbiAgICAgICAgICBjb3B5RmxhZ3MoaW1nRGF0YSwgbWlwbWFwKVxuICAgICAgICAgIGltZ0RhdGEud2lkdGggPj49IGlcbiAgICAgICAgICBpbWdEYXRhLmhlaWdodCA+Pj0gaVxuICAgICAgICAgIHBhcnNlSW1hZ2UoaW1nRGF0YSwgbWlwRGF0YVtpXSlcbiAgICAgICAgICBtaXBtYXAubWlwbWFzayB8PSAoMSA8PCBpKVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbWdEYXRhID0gbWlwbWFwLmltYWdlc1swXSA9IGFsbG9jSW1hZ2UoKVxuICAgICAgICBjb3B5RmxhZ3MoaW1nRGF0YSwgbWlwbWFwKVxuICAgICAgICBwYXJzZUltYWdlKGltZ0RhdGEsIG9wdGlvbnMpXG4gICAgICAgIG1pcG1hcC5taXBtYXNrID0gMVxuICAgICAgfVxuICAgIH1cbiAgICBjb3B5RmxhZ3MobWlwbWFwLCBtaXBtYXAuaW1hZ2VzWzBdKVxuXG4gICAgLy8gRm9yIHRleHR1cmVzIG9mIHRoZSBjb21wcmVzc2VkIGZvcm1hdCBXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfczN0Y1xuICAgIC8vIHdlIG11c3QgaGF2ZSB0aGF0XG4gICAgLy9cbiAgICAvLyBcIldoZW4gbGV2ZWwgZXF1YWxzIHplcm8gd2lkdGggYW5kIGhlaWdodCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNC5cbiAgICAvLyBXaGVuIGxldmVsIGlzIGdyZWF0ZXIgdGhhbiAwIHdpZHRoIGFuZCBoZWlnaHQgbXVzdCBiZSAwLCAxLCAyIG9yIGEgbXVsdGlwbGUgb2YgNC4gXCJcbiAgICAvL1xuICAgIC8vIGJ1dCB3ZSBkbyBub3QgeWV0IHN1cHBvcnQgaGF2aW5nIG11bHRpcGxlIG1pcG1hcCBsZXZlbHMgZm9yIGNvbXByZXNzZWQgdGV4dHVyZXMsXG4gICAgLy8gc28gd2Ugb25seSB0ZXN0IGZvciBsZXZlbCB6ZXJvLlxuXG4gICAgaWYgKFxuICAgICAgbWlwbWFwLmNvbXByZXNzZWQgJiZcbiAgICAgIChcbiAgICAgICAgbWlwbWFwLmludGVybmFsZm9ybWF0ID09PSBHTF9DT01QUkVTU0VEX1JHQl9TM1RDX0RYVDFfRVhUIHx8XG4gICAgICAgIG1pcG1hcC5pbnRlcm5hbGZvcm1hdCA9PT0gR0xfQ09NUFJFU1NFRF9SR0JBX1MzVENfRFhUMV9FWFQgfHxcbiAgICAgICAgbWlwbWFwLmludGVybmFsZm9ybWF0ID09PSBHTF9DT01QUkVTU0VEX1JHQkFfUzNUQ19EWFQzX0VYVCB8fFxuICAgICAgICBtaXBtYXAuaW50ZXJuYWxmb3JtYXQgPT09IEdMX0NPTVBSRVNTRURfUkdCQV9TM1RDX0RYVDVfRVhUXG4gICAgICApXG4gICAgKSB7XG4gICAgICBjaGVjayQxKG1pcG1hcC53aWR0aCAlIDQgPT09IDAgJiYgbWlwbWFwLmhlaWdodCAlIDQgPT09IDAsXG4gICAgICAgICdmb3IgY29tcHJlc3NlZCB0ZXh0dXJlIGZvcm1hdHMsIG1pcG1hcCBsZXZlbCAwIG11c3QgaGF2ZSB3aWR0aCBhbmQgaGVpZ2h0IHRoYXQgYXJlIGEgbXVsdGlwbGUgb2YgNCcpXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2V0TWlwTWFwIChtaXBtYXAsIHRhcmdldCkge1xuICAgIHZhciBpbWFnZXMgPSBtaXBtYXAuaW1hZ2VzXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbWFnZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGlmICghaW1hZ2VzW2ldKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgc2V0SW1hZ2UoaW1hZ2VzW2ldLCB0YXJnZXQsIGkpXG4gICAgfVxuICB9XG5cbiAgdmFyIG1pcFBvb2wgPSBbXVxuXG4gIGZ1bmN0aW9uIGFsbG9jTWlwTWFwICgpIHtcbiAgICB2YXIgcmVzdWx0ID0gbWlwUG9vbC5wb3AoKSB8fCBuZXcgTWlwTWFwKClcbiAgICBUZXhGbGFncy5jYWxsKHJlc3VsdClcbiAgICByZXN1bHQubWlwbWFzayA9IDBcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDE2OyArK2kpIHtcbiAgICAgIHJlc3VsdC5pbWFnZXNbaV0gPSBudWxsXG4gICAgfVxuICAgIHJldHVybiByZXN1bHRcbiAgfVxuXG4gIGZ1bmN0aW9uIGZyZWVNaXBNYXAgKG1pcG1hcCkge1xuICAgIHZhciBpbWFnZXMgPSBtaXBtYXAuaW1hZ2VzXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbWFnZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGlmIChpbWFnZXNbaV0pIHtcbiAgICAgICAgZnJlZUltYWdlKGltYWdlc1tpXSlcbiAgICAgIH1cbiAgICAgIGltYWdlc1tpXSA9IG51bGxcbiAgICB9XG4gICAgbWlwUG9vbC5wdXNoKG1pcG1hcClcbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gVGV4IGluZm9cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICBmdW5jdGlvbiBUZXhJbmZvICgpIHtcbiAgICB0aGlzLm1pbkZpbHRlciA9IEdMX05FQVJFU1QkMVxuICAgIHRoaXMubWFnRmlsdGVyID0gR0xfTkVBUkVTVCQxXG5cbiAgICB0aGlzLndyYXBTID0gR0xfQ0xBTVBfVE9fRURHRSQxXG4gICAgdGhpcy53cmFwVCA9IEdMX0NMQU1QX1RPX0VER0UkMVxuXG4gICAgdGhpcy5hbmlzb3Ryb3BpYyA9IDFcblxuICAgIHRoaXMuZ2VuTWlwbWFwcyA9IGZhbHNlXG4gICAgdGhpcy5taXBtYXBIaW50ID0gR0xfRE9OVF9DQVJFXG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZVRleEluZm8gKGluZm8sIG9wdGlvbnMpIHtcbiAgICBpZiAoJ21pbicgaW4gb3B0aW9ucykge1xuICAgICAgdmFyIG1pbkZpbHRlciA9IG9wdGlvbnMubWluXG4gICAgICBjaGVjayQxLnBhcmFtZXRlcihtaW5GaWx0ZXIsIG1pbkZpbHRlcnMpXG4gICAgICBpbmZvLm1pbkZpbHRlciA9IG1pbkZpbHRlcnNbbWluRmlsdGVyXVxuICAgICAgaWYgKE1JUE1BUF9GSUxURVJTLmluZGV4T2YoaW5mby5taW5GaWx0ZXIpID49IDAgJiYgISgnZmFjZXMnIGluIG9wdGlvbnMpKSB7XG4gICAgICAgIGluZm8uZ2VuTWlwbWFwcyA9IHRydWVcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoJ21hZycgaW4gb3B0aW9ucykge1xuICAgICAgdmFyIG1hZ0ZpbHRlciA9IG9wdGlvbnMubWFnXG4gICAgICBjaGVjayQxLnBhcmFtZXRlcihtYWdGaWx0ZXIsIG1hZ0ZpbHRlcnMpXG4gICAgICBpbmZvLm1hZ0ZpbHRlciA9IG1hZ0ZpbHRlcnNbbWFnRmlsdGVyXVxuICAgIH1cblxuICAgIHZhciB3cmFwUyA9IGluZm8ud3JhcFNcbiAgICB2YXIgd3JhcFQgPSBpbmZvLndyYXBUXG4gICAgaWYgKCd3cmFwJyBpbiBvcHRpb25zKSB7XG4gICAgICB2YXIgd3JhcCA9IG9wdGlvbnMud3JhcFxuICAgICAgaWYgKHR5cGVvZiB3cmFwID09PSAnc3RyaW5nJykge1xuICAgICAgICBjaGVjayQxLnBhcmFtZXRlcih3cmFwLCB3cmFwTW9kZXMpXG4gICAgICAgIHdyYXBTID0gd3JhcFQgPSB3cmFwTW9kZXNbd3JhcF1cbiAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh3cmFwKSkge1xuICAgICAgICBjaGVjayQxLnBhcmFtZXRlcih3cmFwWzBdLCB3cmFwTW9kZXMpXG4gICAgICAgIGNoZWNrJDEucGFyYW1ldGVyKHdyYXBbMV0sIHdyYXBNb2RlcylcbiAgICAgICAgd3JhcFMgPSB3cmFwTW9kZXNbd3JhcFswXV1cbiAgICAgICAgd3JhcFQgPSB3cmFwTW9kZXNbd3JhcFsxXV1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCd3cmFwUycgaW4gb3B0aW9ucykge1xuICAgICAgICB2YXIgb3B0V3JhcFMgPSBvcHRpb25zLndyYXBTXG4gICAgICAgIGNoZWNrJDEucGFyYW1ldGVyKG9wdFdyYXBTLCB3cmFwTW9kZXMpXG4gICAgICAgIHdyYXBTID0gd3JhcE1vZGVzW29wdFdyYXBTXVxuICAgICAgfVxuICAgICAgaWYgKCd3cmFwVCcgaW4gb3B0aW9ucykge1xuICAgICAgICB2YXIgb3B0V3JhcFQgPSBvcHRpb25zLndyYXBUXG4gICAgICAgIGNoZWNrJDEucGFyYW1ldGVyKG9wdFdyYXBULCB3cmFwTW9kZXMpXG4gICAgICAgIHdyYXBUID0gd3JhcE1vZGVzW29wdFdyYXBUXVxuICAgICAgfVxuICAgIH1cbiAgICBpbmZvLndyYXBTID0gd3JhcFNcbiAgICBpbmZvLndyYXBUID0gd3JhcFRcblxuICAgIGlmICgnYW5pc290cm9waWMnIGluIG9wdGlvbnMpIHtcbiAgICAgIHZhciBhbmlzb3Ryb3BpYyA9IG9wdGlvbnMuYW5pc290cm9waWNcbiAgICAgIGNoZWNrJDEodHlwZW9mIGFuaXNvdHJvcGljID09PSAnbnVtYmVyJyAmJlxuICAgICAgICAgYW5pc290cm9waWMgPj0gMSAmJiBhbmlzb3Ryb3BpYyA8PSBsaW1pdHMubWF4QW5pc290cm9waWMsXG4gICAgICAnYW5pc28gc2FtcGxlcyBtdXN0IGJlIGJldHdlZW4gMSBhbmQgJylcbiAgICAgIGluZm8uYW5pc290cm9waWMgPSBvcHRpb25zLmFuaXNvdHJvcGljXG4gICAgfVxuXG4gICAgaWYgKCdtaXBtYXAnIGluIG9wdGlvbnMpIHtcbiAgICAgIHZhciBoYXNNaXBNYXAgPSBmYWxzZVxuICAgICAgc3dpdGNoICh0eXBlb2Ygb3B0aW9ucy5taXBtYXApIHtcbiAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICBjaGVjayQxLnBhcmFtZXRlcihvcHRpb25zLm1pcG1hcCwgbWlwbWFwSGludCxcbiAgICAgICAgICAgICdpbnZhbGlkIG1pcG1hcCBoaW50JylcbiAgICAgICAgICBpbmZvLm1pcG1hcEhpbnQgPSBtaXBtYXBIaW50W29wdGlvbnMubWlwbWFwXVxuICAgICAgICAgIGluZm8uZ2VuTWlwbWFwcyA9IHRydWVcbiAgICAgICAgICBoYXNNaXBNYXAgPSB0cnVlXG4gICAgICAgICAgYnJlYWtcblxuICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICBoYXNNaXBNYXAgPSBpbmZvLmdlbk1pcG1hcHMgPSBvcHRpb25zLm1pcG1hcFxuICAgICAgICAgIGJyZWFrXG5cbiAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICBjaGVjayQxKEFycmF5LmlzQXJyYXkob3B0aW9ucy5taXBtYXApLCAnaW52YWxpZCBtaXBtYXAgdHlwZScpXG4gICAgICAgICAgaW5mby5nZW5NaXBtYXBzID0gZmFsc2VcbiAgICAgICAgICBoYXNNaXBNYXAgPSB0cnVlXG4gICAgICAgICAgYnJlYWtcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGNoZWNrJDEucmFpc2UoJ2ludmFsaWQgbWlwbWFwIHR5cGUnKVxuICAgICAgfVxuICAgICAgaWYgKGhhc01pcE1hcCAmJiAhKCdtaW4nIGluIG9wdGlvbnMpKSB7XG4gICAgICAgIGluZm8ubWluRmlsdGVyID0gR0xfTkVBUkVTVF9NSVBNQVBfTkVBUkVTVCQxXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2V0VGV4SW5mbyAoaW5mbywgdGFyZ2V0KSB7XG4gICAgZ2wudGV4UGFyYW1ldGVyaSh0YXJnZXQsIEdMX1RFWFRVUkVfTUlOX0ZJTFRFUiwgaW5mby5taW5GaWx0ZXIpXG4gICAgZ2wudGV4UGFyYW1ldGVyaSh0YXJnZXQsIEdMX1RFWFRVUkVfTUFHX0ZJTFRFUiwgaW5mby5tYWdGaWx0ZXIpXG4gICAgZ2wudGV4UGFyYW1ldGVyaSh0YXJnZXQsIEdMX1RFWFRVUkVfV1JBUF9TLCBpbmZvLndyYXBTKVxuICAgIGdsLnRleFBhcmFtZXRlcmkodGFyZ2V0LCBHTF9URVhUVVJFX1dSQVBfVCwgaW5mby53cmFwVClcbiAgICBpZiAoZXh0ZW5zaW9ucy5leHRfdGV4dHVyZV9maWx0ZXJfYW5pc290cm9waWMpIHtcbiAgICAgIGdsLnRleFBhcmFtZXRlcmkodGFyZ2V0LCBHTF9URVhUVVJFX01BWF9BTklTT1RST1BZX0VYVCwgaW5mby5hbmlzb3Ryb3BpYylcbiAgICB9XG4gICAgaWYgKGluZm8uZ2VuTWlwbWFwcykge1xuICAgICAgZ2wuaGludChHTF9HRU5FUkFURV9NSVBNQVBfSElOVCwgaW5mby5taXBtYXBIaW50KVxuICAgICAgZ2wuZ2VuZXJhdGVNaXBtYXAodGFyZ2V0KVxuICAgIH1cbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gRnVsbCB0ZXh0dXJlIG9iamVjdFxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIHZhciB0ZXh0dXJlQ291bnQgPSAwXG4gIHZhciB0ZXh0dXJlU2V0ID0ge31cbiAgdmFyIG51bVRleFVuaXRzID0gbGltaXRzLm1heFRleHR1cmVVbml0c1xuICB2YXIgdGV4dHVyZVVuaXRzID0gQXJyYXkobnVtVGV4VW5pdHMpLm1hcChmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfSlcblxuICBmdW5jdGlvbiBSRUdMVGV4dHVyZSAodGFyZ2V0KSB7XG4gICAgVGV4RmxhZ3MuY2FsbCh0aGlzKVxuICAgIHRoaXMubWlwbWFzayA9IDBcbiAgICB0aGlzLmludGVybmFsZm9ybWF0ID0gR0xfUkdCQSQxXG5cbiAgICB0aGlzLmlkID0gdGV4dHVyZUNvdW50KytcblxuICAgIHRoaXMucmVmQ291bnQgPSAxXG5cbiAgICB0aGlzLnRhcmdldCA9IHRhcmdldFxuICAgIHRoaXMudGV4dHVyZSA9IGdsLmNyZWF0ZVRleHR1cmUoKVxuXG4gICAgdGhpcy51bml0ID0gLTFcbiAgICB0aGlzLmJpbmRDb3VudCA9IDBcblxuICAgIHRoaXMudGV4SW5mbyA9IG5ldyBUZXhJbmZvKClcblxuICAgIGlmIChjb25maWcucHJvZmlsZSkge1xuICAgICAgdGhpcy5zdGF0cyA9IHsgc2l6ZTogMCB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdGVtcEJpbmQgKHRleHR1cmUpIHtcbiAgICBnbC5hY3RpdmVUZXh0dXJlKEdMX1RFWFRVUkUwJDEpXG4gICAgZ2wuYmluZFRleHR1cmUodGV4dHVyZS50YXJnZXQsIHRleHR1cmUudGV4dHVyZSlcbiAgfVxuXG4gIGZ1bmN0aW9uIHRlbXBSZXN0b3JlICgpIHtcbiAgICB2YXIgcHJldiA9IHRleHR1cmVVbml0c1swXVxuICAgIGlmIChwcmV2KSB7XG4gICAgICBnbC5iaW5kVGV4dHVyZShwcmV2LnRhcmdldCwgcHJldi50ZXh0dXJlKVxuICAgIH0gZWxzZSB7XG4gICAgICBnbC5iaW5kVGV4dHVyZShHTF9URVhUVVJFXzJEJDEsIG51bGwpXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZGVzdHJveSAodGV4dHVyZSkge1xuICAgIHZhciBoYW5kbGUgPSB0ZXh0dXJlLnRleHR1cmVcbiAgICBjaGVjayQxKGhhbmRsZSwgJ211c3Qgbm90IGRvdWJsZSBkZXN0cm95IHRleHR1cmUnKVxuICAgIHZhciB1bml0ID0gdGV4dHVyZS51bml0XG4gICAgdmFyIHRhcmdldCA9IHRleHR1cmUudGFyZ2V0XG4gICAgaWYgKHVuaXQgPj0gMCkge1xuICAgICAgZ2wuYWN0aXZlVGV4dHVyZShHTF9URVhUVVJFMCQxICsgdW5pdClcbiAgICAgIGdsLmJpbmRUZXh0dXJlKHRhcmdldCwgbnVsbClcbiAgICAgIHRleHR1cmVVbml0c1t1bml0XSA9IG51bGxcbiAgICB9XG4gICAgZ2wuZGVsZXRlVGV4dHVyZShoYW5kbGUpXG4gICAgdGV4dHVyZS50ZXh0dXJlID0gbnVsbFxuICAgIHRleHR1cmUucGFyYW1zID0gbnVsbFxuICAgIHRleHR1cmUucGl4ZWxzID0gbnVsbFxuICAgIHRleHR1cmUucmVmQ291bnQgPSAwXG4gICAgZGVsZXRlIHRleHR1cmVTZXRbdGV4dHVyZS5pZF1cbiAgICBzdGF0cy50ZXh0dXJlQ291bnQtLVxuICB9XG5cbiAgZXh0ZW5kKFJFR0xUZXh0dXJlLnByb3RvdHlwZSwge1xuICAgIGJpbmQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB0ZXh0dXJlID0gdGhpc1xuICAgICAgdGV4dHVyZS5iaW5kQ291bnQgKz0gMVxuICAgICAgdmFyIHVuaXQgPSB0ZXh0dXJlLnVuaXRcbiAgICAgIGlmICh1bml0IDwgMCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bVRleFVuaXRzOyArK2kpIHtcbiAgICAgICAgICB2YXIgb3RoZXIgPSB0ZXh0dXJlVW5pdHNbaV1cbiAgICAgICAgICBpZiAob3RoZXIpIHtcbiAgICAgICAgICAgIGlmIChvdGhlci5iaW5kQ291bnQgPiAwKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvdGhlci51bml0ID0gLTFcbiAgICAgICAgICB9XG4gICAgICAgICAgdGV4dHVyZVVuaXRzW2ldID0gdGV4dHVyZVxuICAgICAgICAgIHVuaXQgPSBpXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgICBpZiAodW5pdCA+PSBudW1UZXhVbml0cykge1xuICAgICAgICAgIGNoZWNrJDEucmFpc2UoJ2luc3VmZmljaWVudCBudW1iZXIgb2YgdGV4dHVyZSB1bml0cycpXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbmZpZy5wcm9maWxlICYmIHN0YXRzLm1heFRleHR1cmVVbml0cyA8ICh1bml0ICsgMSkpIHtcbiAgICAgICAgICBzdGF0cy5tYXhUZXh0dXJlVW5pdHMgPSB1bml0ICsgMSAvLyArMSwgc2luY2UgdGhlIHVuaXRzIGFyZSB6ZXJvLWJhc2VkXG4gICAgICAgIH1cbiAgICAgICAgdGV4dHVyZS51bml0ID0gdW5pdFxuICAgICAgICBnbC5hY3RpdmVUZXh0dXJlKEdMX1RFWFRVUkUwJDEgKyB1bml0KVxuICAgICAgICBnbC5iaW5kVGV4dHVyZSh0ZXh0dXJlLnRhcmdldCwgdGV4dHVyZS50ZXh0dXJlKVxuICAgICAgfVxuICAgICAgcmV0dXJuIHVuaXRcbiAgICB9LFxuXG4gICAgdW5iaW5kOiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLmJpbmRDb3VudCAtPSAxXG4gICAgfSxcblxuICAgIGRlY1JlZjogZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKC0tdGhpcy5yZWZDb3VudCA8PSAwKSB7XG4gICAgICAgIGRlc3Ryb3kodGhpcylcbiAgICAgIH1cbiAgICB9XG4gIH0pXG5cbiAgZnVuY3Rpb24gY3JlYXRlVGV4dHVyZTJEIChhLCBiKSB7XG4gICAgdmFyIHRleHR1cmUgPSBuZXcgUkVHTFRleHR1cmUoR0xfVEVYVFVSRV8yRCQxKVxuICAgIHRleHR1cmVTZXRbdGV4dHVyZS5pZF0gPSB0ZXh0dXJlXG4gICAgc3RhdHMudGV4dHVyZUNvdW50KytcblxuICAgIGZ1bmN0aW9uIHJlZ2xUZXh0dXJlMkQgKGEsIGIpIHtcbiAgICAgIHZhciB0ZXhJbmZvID0gdGV4dHVyZS50ZXhJbmZvXG4gICAgICBUZXhJbmZvLmNhbGwodGV4SW5mbylcbiAgICAgIHZhciBtaXBEYXRhID0gYWxsb2NNaXBNYXAoKVxuXG4gICAgICBpZiAodHlwZW9mIGEgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYiA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICBwYXJzZU1pcE1hcEZyb21TaGFwZShtaXBEYXRhLCBhIHwgMCwgYiB8IDApXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGFyc2VNaXBNYXBGcm9tU2hhcGUobWlwRGF0YSwgYSB8IDAsIGEgfCAwKVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGEpIHtcbiAgICAgICAgY2hlY2skMS50eXBlKGEsICdvYmplY3QnLCAnaW52YWxpZCBhcmd1bWVudHMgdG8gcmVnbC50ZXh0dXJlJylcbiAgICAgICAgcGFyc2VUZXhJbmZvKHRleEluZm8sIGEpXG4gICAgICAgIHBhcnNlTWlwTWFwRnJvbU9iamVjdChtaXBEYXRhLCBhKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZW1wdHkgdGV4dHVyZXMgZ2V0IGFzc2lnbmVkIGEgZGVmYXVsdCBzaGFwZSBvZiAxeDFcbiAgICAgICAgcGFyc2VNaXBNYXBGcm9tU2hhcGUobWlwRGF0YSwgMSwgMSlcbiAgICAgIH1cblxuICAgICAgaWYgKHRleEluZm8uZ2VuTWlwbWFwcykge1xuICAgICAgICBtaXBEYXRhLm1pcG1hc2sgPSAobWlwRGF0YS53aWR0aCA8PCAxKSAtIDFcbiAgICAgIH1cbiAgICAgIHRleHR1cmUubWlwbWFzayA9IG1pcERhdGEubWlwbWFza1xuXG4gICAgICBjb3B5RmxhZ3ModGV4dHVyZSwgbWlwRGF0YSlcblxuICAgICAgY2hlY2skMS50ZXh0dXJlMkQodGV4SW5mbywgbWlwRGF0YSwgbGltaXRzKVxuICAgICAgdGV4dHVyZS5pbnRlcm5hbGZvcm1hdCA9IG1pcERhdGEuaW50ZXJuYWxmb3JtYXRcblxuICAgICAgcmVnbFRleHR1cmUyRC53aWR0aCA9IG1pcERhdGEud2lkdGhcbiAgICAgIHJlZ2xUZXh0dXJlMkQuaGVpZ2h0ID0gbWlwRGF0YS5oZWlnaHRcblxuICAgICAgdGVtcEJpbmQodGV4dHVyZSlcbiAgICAgIHNldE1pcE1hcChtaXBEYXRhLCBHTF9URVhUVVJFXzJEJDEpXG4gICAgICBzZXRUZXhJbmZvKHRleEluZm8sIEdMX1RFWFRVUkVfMkQkMSlcbiAgICAgIHRlbXBSZXN0b3JlKClcblxuICAgICAgZnJlZU1pcE1hcChtaXBEYXRhKVxuXG4gICAgICBpZiAoY29uZmlnLnByb2ZpbGUpIHtcbiAgICAgICAgdGV4dHVyZS5zdGF0cy5zaXplID0gZ2V0VGV4dHVyZVNpemUoXG4gICAgICAgICAgdGV4dHVyZS5pbnRlcm5hbGZvcm1hdCxcbiAgICAgICAgICB0ZXh0dXJlLnR5cGUsXG4gICAgICAgICAgbWlwRGF0YS53aWR0aCxcbiAgICAgICAgICBtaXBEYXRhLmhlaWdodCxcbiAgICAgICAgICB0ZXhJbmZvLmdlbk1pcG1hcHMsXG4gICAgICAgICAgZmFsc2UpXG4gICAgICB9XG4gICAgICByZWdsVGV4dHVyZTJELmZvcm1hdCA9IHRleHR1cmVGb3JtYXRzSW52ZXJ0W3RleHR1cmUuaW50ZXJuYWxmb3JtYXRdXG4gICAgICByZWdsVGV4dHVyZTJELnR5cGUgPSB0ZXh0dXJlVHlwZXNJbnZlcnRbdGV4dHVyZS50eXBlXVxuXG4gICAgICByZWdsVGV4dHVyZTJELm1hZyA9IG1hZ0ZpbHRlcnNJbnZlcnRbdGV4SW5mby5tYWdGaWx0ZXJdXG4gICAgICByZWdsVGV4dHVyZTJELm1pbiA9IG1pbkZpbHRlcnNJbnZlcnRbdGV4SW5mby5taW5GaWx0ZXJdXG5cbiAgICAgIHJlZ2xUZXh0dXJlMkQud3JhcFMgPSB3cmFwTW9kZXNJbnZlcnRbdGV4SW5mby53cmFwU11cbiAgICAgIHJlZ2xUZXh0dXJlMkQud3JhcFQgPSB3cmFwTW9kZXNJbnZlcnRbdGV4SW5mby53cmFwVF1cblxuICAgICAgcmV0dXJuIHJlZ2xUZXh0dXJlMkRcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzdWJpbWFnZSAoaW1hZ2UsIHhfLCB5XywgbGV2ZWxfKSB7XG4gICAgICBjaGVjayQxKCEhaW1hZ2UsICdtdXN0IHNwZWNpZnkgaW1hZ2UgZGF0YScpXG5cbiAgICAgIHZhciB4ID0geF8gfCAwXG4gICAgICB2YXIgeSA9IHlfIHwgMFxuICAgICAgdmFyIGxldmVsID0gbGV2ZWxfIHwgMFxuXG4gICAgICB2YXIgaW1hZ2VEYXRhID0gYWxsb2NJbWFnZSgpXG4gICAgICBjb3B5RmxhZ3MoaW1hZ2VEYXRhLCB0ZXh0dXJlKVxuICAgICAgaW1hZ2VEYXRhLndpZHRoID0gMFxuICAgICAgaW1hZ2VEYXRhLmhlaWdodCA9IDBcbiAgICAgIHBhcnNlSW1hZ2UoaW1hZ2VEYXRhLCBpbWFnZSlcbiAgICAgIGltYWdlRGF0YS53aWR0aCA9IGltYWdlRGF0YS53aWR0aCB8fCAoKHRleHR1cmUud2lkdGggPj4gbGV2ZWwpIC0geClcbiAgICAgIGltYWdlRGF0YS5oZWlnaHQgPSBpbWFnZURhdGEuaGVpZ2h0IHx8ICgodGV4dHVyZS5oZWlnaHQgPj4gbGV2ZWwpIC0geSlcblxuICAgICAgY2hlY2skMShcbiAgICAgICAgdGV4dHVyZS50eXBlID09PSBpbWFnZURhdGEudHlwZSAmJlxuICAgICAgICB0ZXh0dXJlLmZvcm1hdCA9PT0gaW1hZ2VEYXRhLmZvcm1hdCAmJlxuICAgICAgICB0ZXh0dXJlLmludGVybmFsZm9ybWF0ID09PSBpbWFnZURhdGEuaW50ZXJuYWxmb3JtYXQsXG4gICAgICAgICdpbmNvbXBhdGlibGUgZm9ybWF0IGZvciB0ZXh0dXJlLnN1YmltYWdlJylcbiAgICAgIGNoZWNrJDEoXG4gICAgICAgIHggPj0gMCAmJiB5ID49IDAgJiZcbiAgICAgICAgeCArIGltYWdlRGF0YS53aWR0aCA8PSB0ZXh0dXJlLndpZHRoICYmXG4gICAgICAgIHkgKyBpbWFnZURhdGEuaGVpZ2h0IDw9IHRleHR1cmUuaGVpZ2h0LFxuICAgICAgICAndGV4dHVyZS5zdWJpbWFnZSB3cml0ZSBvdXQgb2YgYm91bmRzJylcbiAgICAgIGNoZWNrJDEoXG4gICAgICAgIHRleHR1cmUubWlwbWFzayAmICgxIDw8IGxldmVsKSxcbiAgICAgICAgJ21pc3NpbmcgbWlwbWFwIGRhdGEnKVxuICAgICAgY2hlY2skMShcbiAgICAgICAgaW1hZ2VEYXRhLmRhdGEgfHwgaW1hZ2VEYXRhLmVsZW1lbnQgfHwgaW1hZ2VEYXRhLm5lZWRzQ29weSxcbiAgICAgICAgJ21pc3NpbmcgaW1hZ2UgZGF0YScpXG5cbiAgICAgIHRlbXBCaW5kKHRleHR1cmUpXG4gICAgICBzZXRTdWJJbWFnZShpbWFnZURhdGEsIEdMX1RFWFRVUkVfMkQkMSwgeCwgeSwgbGV2ZWwpXG4gICAgICB0ZW1wUmVzdG9yZSgpXG5cbiAgICAgIGZyZWVJbWFnZShpbWFnZURhdGEpXG5cbiAgICAgIHJldHVybiByZWdsVGV4dHVyZTJEXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVzaXplICh3XywgaF8pIHtcbiAgICAgIHZhciB3ID0gd18gfCAwXG4gICAgICB2YXIgaCA9IChoXyB8IDApIHx8IHdcbiAgICAgIGlmICh3ID09PSB0ZXh0dXJlLndpZHRoICYmIGggPT09IHRleHR1cmUuaGVpZ2h0KSB7XG4gICAgICAgIHJldHVybiByZWdsVGV4dHVyZTJEXG4gICAgICB9XG5cbiAgICAgIHJlZ2xUZXh0dXJlMkQud2lkdGggPSB0ZXh0dXJlLndpZHRoID0gd1xuICAgICAgcmVnbFRleHR1cmUyRC5oZWlnaHQgPSB0ZXh0dXJlLmhlaWdodCA9IGhcblxuICAgICAgdGVtcEJpbmQodGV4dHVyZSlcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IHRleHR1cmUubWlwbWFzayA+PiBpOyArK2kpIHtcbiAgICAgICAgdmFyIF93ID0gdyA+PiBpXG4gICAgICAgIHZhciBfaCA9IGggPj4gaVxuICAgICAgICBpZiAoIV93IHx8ICFfaCkgYnJlYWtcbiAgICAgICAgZ2wudGV4SW1hZ2UyRChcbiAgICAgICAgICBHTF9URVhUVVJFXzJEJDEsXG4gICAgICAgICAgaSxcbiAgICAgICAgICB0ZXh0dXJlLmZvcm1hdCxcbiAgICAgICAgICBfdyxcbiAgICAgICAgICBfaCxcbiAgICAgICAgICAwLFxuICAgICAgICAgIHRleHR1cmUuZm9ybWF0LFxuICAgICAgICAgIHRleHR1cmUudHlwZSxcbiAgICAgICAgICBudWxsKVxuICAgICAgfVxuICAgICAgdGVtcFJlc3RvcmUoKVxuXG4gICAgICAvLyBhbHNvLCByZWNvbXB1dGUgdGhlIHRleHR1cmUgc2l6ZS5cbiAgICAgIGlmIChjb25maWcucHJvZmlsZSkge1xuICAgICAgICB0ZXh0dXJlLnN0YXRzLnNpemUgPSBnZXRUZXh0dXJlU2l6ZShcbiAgICAgICAgICB0ZXh0dXJlLmludGVybmFsZm9ybWF0LFxuICAgICAgICAgIHRleHR1cmUudHlwZSxcbiAgICAgICAgICB3LFxuICAgICAgICAgIGgsXG4gICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgZmFsc2UpXG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZWdsVGV4dHVyZTJEXG4gICAgfVxuXG4gICAgcmVnbFRleHR1cmUyRChhLCBiKVxuXG4gICAgcmVnbFRleHR1cmUyRC5zdWJpbWFnZSA9IHN1YmltYWdlXG4gICAgcmVnbFRleHR1cmUyRC5yZXNpemUgPSByZXNpemVcbiAgICByZWdsVGV4dHVyZTJELl9yZWdsVHlwZSA9ICd0ZXh0dXJlMmQnXG4gICAgcmVnbFRleHR1cmUyRC5fdGV4dHVyZSA9IHRleHR1cmVcbiAgICBpZiAoY29uZmlnLnByb2ZpbGUpIHtcbiAgICAgIHJlZ2xUZXh0dXJlMkQuc3RhdHMgPSB0ZXh0dXJlLnN0YXRzXG4gICAgfVxuICAgIHJlZ2xUZXh0dXJlMkQuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRleHR1cmUuZGVjUmVmKClcbiAgICB9XG5cbiAgICByZXR1cm4gcmVnbFRleHR1cmUyRFxuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlVGV4dHVyZUN1YmUgKGEwLCBhMSwgYTIsIGEzLCBhNCwgYTUpIHtcbiAgICB2YXIgdGV4dHVyZSA9IG5ldyBSRUdMVGV4dHVyZShHTF9URVhUVVJFX0NVQkVfTUFQJDEpXG4gICAgdGV4dHVyZVNldFt0ZXh0dXJlLmlkXSA9IHRleHR1cmVcbiAgICBzdGF0cy5jdWJlQ291bnQrK1xuXG4gICAgdmFyIGZhY2VzID0gbmV3IEFycmF5KDYpXG5cbiAgICBmdW5jdGlvbiByZWdsVGV4dHVyZUN1YmUgKGEwLCBhMSwgYTIsIGEzLCBhNCwgYTUpIHtcbiAgICAgIHZhciBpXG4gICAgICB2YXIgdGV4SW5mbyA9IHRleHR1cmUudGV4SW5mb1xuICAgICAgVGV4SW5mby5jYWxsKHRleEluZm8pXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgNjsgKytpKSB7XG4gICAgICAgIGZhY2VzW2ldID0gYWxsb2NNaXBNYXAoKVxuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGEwID09PSAnbnVtYmVyJyB8fCAhYTApIHtcbiAgICAgICAgdmFyIHMgPSAoYTAgfCAwKSB8fCAxXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCA2OyArK2kpIHtcbiAgICAgICAgICBwYXJzZU1pcE1hcEZyb21TaGFwZShmYWNlc1tpXSwgcywgcylcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgYTAgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGlmIChhMSkge1xuICAgICAgICAgIHBhcnNlTWlwTWFwRnJvbU9iamVjdChmYWNlc1swXSwgYTApXG4gICAgICAgICAgcGFyc2VNaXBNYXBGcm9tT2JqZWN0KGZhY2VzWzFdLCBhMSlcbiAgICAgICAgICBwYXJzZU1pcE1hcEZyb21PYmplY3QoZmFjZXNbMl0sIGEyKVxuICAgICAgICAgIHBhcnNlTWlwTWFwRnJvbU9iamVjdChmYWNlc1szXSwgYTMpXG4gICAgICAgICAgcGFyc2VNaXBNYXBGcm9tT2JqZWN0KGZhY2VzWzRdLCBhNClcbiAgICAgICAgICBwYXJzZU1pcE1hcEZyb21PYmplY3QoZmFjZXNbNV0sIGE1KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhcnNlVGV4SW5mbyh0ZXhJbmZvLCBhMClcbiAgICAgICAgICBwYXJzZUZsYWdzKHRleHR1cmUsIGEwKVxuICAgICAgICAgIGlmICgnZmFjZXMnIGluIGEwKSB7XG4gICAgICAgICAgICB2YXIgZmFjZUlucHV0ID0gYTAuZmFjZXNcbiAgICAgICAgICAgIGNoZWNrJDEoQXJyYXkuaXNBcnJheShmYWNlSW5wdXQpICYmIGZhY2VJbnB1dC5sZW5ndGggPT09IDYsXG4gICAgICAgICAgICAgICdjdWJlIGZhY2VzIG11c3QgYmUgYSBsZW5ndGggNiBhcnJheScpXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgNjsgKytpKSB7XG4gICAgICAgICAgICAgIGNoZWNrJDEodHlwZW9mIGZhY2VJbnB1dFtpXSA9PT0gJ29iamVjdCcgJiYgISFmYWNlSW5wdXRbaV0sXG4gICAgICAgICAgICAgICAgJ2ludmFsaWQgaW5wdXQgZm9yIGN1YmUgbWFwIGZhY2UnKVxuICAgICAgICAgICAgICBjb3B5RmxhZ3MoZmFjZXNbaV0sIHRleHR1cmUpXG4gICAgICAgICAgICAgIHBhcnNlTWlwTWFwRnJvbU9iamVjdChmYWNlc1tpXSwgZmFjZUlucHV0W2ldKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgNjsgKytpKSB7XG4gICAgICAgICAgICAgIHBhcnNlTWlwTWFwRnJvbU9iamVjdChmYWNlc1tpXSwgYTApXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjaGVjayQxLnJhaXNlKCdpbnZhbGlkIGFyZ3VtZW50cyB0byBjdWJlIG1hcCcpXG4gICAgICB9XG5cbiAgICAgIGNvcHlGbGFncyh0ZXh0dXJlLCBmYWNlc1swXSlcblxuICAgICAgaWYgKCFsaW1pdHMubnBvdFRleHR1cmVDdWJlKSB7XG4gICAgICAgIGNoZWNrJDEoaXNQb3cyJDEodGV4dHVyZS53aWR0aCkgJiYgaXNQb3cyJDEodGV4dHVyZS5oZWlnaHQpLCAneW91ciBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgbm9uIHBvd2VyIG9yIHR3byB0ZXh0dXJlIGRpbWVuc2lvbnMnKVxuICAgICAgfVxuXG4gICAgICBpZiAodGV4SW5mby5nZW5NaXBtYXBzKSB7XG4gICAgICAgIHRleHR1cmUubWlwbWFzayA9IChmYWNlc1swXS53aWR0aCA8PCAxKSAtIDFcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRleHR1cmUubWlwbWFzayA9IGZhY2VzWzBdLm1pcG1hc2tcbiAgICAgIH1cblxuICAgICAgY2hlY2skMS50ZXh0dXJlQ3ViZSh0ZXh0dXJlLCB0ZXhJbmZvLCBmYWNlcywgbGltaXRzKVxuICAgICAgdGV4dHVyZS5pbnRlcm5hbGZvcm1hdCA9IGZhY2VzWzBdLmludGVybmFsZm9ybWF0XG5cbiAgICAgIHJlZ2xUZXh0dXJlQ3ViZS53aWR0aCA9IGZhY2VzWzBdLndpZHRoXG4gICAgICByZWdsVGV4dHVyZUN1YmUuaGVpZ2h0ID0gZmFjZXNbMF0uaGVpZ2h0XG5cbiAgICAgIHRlbXBCaW5kKHRleHR1cmUpXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgNjsgKytpKSB7XG4gICAgICAgIHNldE1pcE1hcChmYWNlc1tpXSwgR0xfVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YJDEgKyBpKVxuICAgICAgfVxuICAgICAgc2V0VGV4SW5mbyh0ZXhJbmZvLCBHTF9URVhUVVJFX0NVQkVfTUFQJDEpXG4gICAgICB0ZW1wUmVzdG9yZSgpXG5cbiAgICAgIGlmIChjb25maWcucHJvZmlsZSkge1xuICAgICAgICB0ZXh0dXJlLnN0YXRzLnNpemUgPSBnZXRUZXh0dXJlU2l6ZShcbiAgICAgICAgICB0ZXh0dXJlLmludGVybmFsZm9ybWF0LFxuICAgICAgICAgIHRleHR1cmUudHlwZSxcbiAgICAgICAgICByZWdsVGV4dHVyZUN1YmUud2lkdGgsXG4gICAgICAgICAgcmVnbFRleHR1cmVDdWJlLmhlaWdodCxcbiAgICAgICAgICB0ZXhJbmZvLmdlbk1pcG1hcHMsXG4gICAgICAgICAgdHJ1ZSlcbiAgICAgIH1cblxuICAgICAgcmVnbFRleHR1cmVDdWJlLmZvcm1hdCA9IHRleHR1cmVGb3JtYXRzSW52ZXJ0W3RleHR1cmUuaW50ZXJuYWxmb3JtYXRdXG4gICAgICByZWdsVGV4dHVyZUN1YmUudHlwZSA9IHRleHR1cmVUeXBlc0ludmVydFt0ZXh0dXJlLnR5cGVdXG5cbiAgICAgIHJlZ2xUZXh0dXJlQ3ViZS5tYWcgPSBtYWdGaWx0ZXJzSW52ZXJ0W3RleEluZm8ubWFnRmlsdGVyXVxuICAgICAgcmVnbFRleHR1cmVDdWJlLm1pbiA9IG1pbkZpbHRlcnNJbnZlcnRbdGV4SW5mby5taW5GaWx0ZXJdXG5cbiAgICAgIHJlZ2xUZXh0dXJlQ3ViZS53cmFwUyA9IHdyYXBNb2Rlc0ludmVydFt0ZXhJbmZvLndyYXBTXVxuICAgICAgcmVnbFRleHR1cmVDdWJlLndyYXBUID0gd3JhcE1vZGVzSW52ZXJ0W3RleEluZm8ud3JhcFRdXG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCA2OyArK2kpIHtcbiAgICAgICAgZnJlZU1pcE1hcChmYWNlc1tpXSlcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlZ2xUZXh0dXJlQ3ViZVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHN1YmltYWdlIChmYWNlLCBpbWFnZSwgeF8sIHlfLCBsZXZlbF8pIHtcbiAgICAgIGNoZWNrJDEoISFpbWFnZSwgJ211c3Qgc3BlY2lmeSBpbWFnZSBkYXRhJylcbiAgICAgIGNoZWNrJDEodHlwZW9mIGZhY2UgPT09ICdudW1iZXInICYmIGZhY2UgPT09IChmYWNlIHwgMCkgJiZcbiAgICAgICAgZmFjZSA+PSAwICYmIGZhY2UgPCA2LCAnaW52YWxpZCBmYWNlJylcblxuICAgICAgdmFyIHggPSB4XyB8IDBcbiAgICAgIHZhciB5ID0geV8gfCAwXG4gICAgICB2YXIgbGV2ZWwgPSBsZXZlbF8gfCAwXG5cbiAgICAgIHZhciBpbWFnZURhdGEgPSBhbGxvY0ltYWdlKClcbiAgICAgIGNvcHlGbGFncyhpbWFnZURhdGEsIHRleHR1cmUpXG4gICAgICBpbWFnZURhdGEud2lkdGggPSAwXG4gICAgICBpbWFnZURhdGEuaGVpZ2h0ID0gMFxuICAgICAgcGFyc2VJbWFnZShpbWFnZURhdGEsIGltYWdlKVxuICAgICAgaW1hZ2VEYXRhLndpZHRoID0gaW1hZ2VEYXRhLndpZHRoIHx8ICgodGV4dHVyZS53aWR0aCA+PiBsZXZlbCkgLSB4KVxuICAgICAgaW1hZ2VEYXRhLmhlaWdodCA9IGltYWdlRGF0YS5oZWlnaHQgfHwgKCh0ZXh0dXJlLmhlaWdodCA+PiBsZXZlbCkgLSB5KVxuXG4gICAgICBjaGVjayQxKFxuICAgICAgICB0ZXh0dXJlLnR5cGUgPT09IGltYWdlRGF0YS50eXBlICYmXG4gICAgICAgIHRleHR1cmUuZm9ybWF0ID09PSBpbWFnZURhdGEuZm9ybWF0ICYmXG4gICAgICAgIHRleHR1cmUuaW50ZXJuYWxmb3JtYXQgPT09IGltYWdlRGF0YS5pbnRlcm5hbGZvcm1hdCxcbiAgICAgICAgJ2luY29tcGF0aWJsZSBmb3JtYXQgZm9yIHRleHR1cmUuc3ViaW1hZ2UnKVxuICAgICAgY2hlY2skMShcbiAgICAgICAgeCA+PSAwICYmIHkgPj0gMCAmJlxuICAgICAgICB4ICsgaW1hZ2VEYXRhLndpZHRoIDw9IHRleHR1cmUud2lkdGggJiZcbiAgICAgICAgeSArIGltYWdlRGF0YS5oZWlnaHQgPD0gdGV4dHVyZS5oZWlnaHQsXG4gICAgICAgICd0ZXh0dXJlLnN1YmltYWdlIHdyaXRlIG91dCBvZiBib3VuZHMnKVxuICAgICAgY2hlY2skMShcbiAgICAgICAgdGV4dHVyZS5taXBtYXNrICYgKDEgPDwgbGV2ZWwpLFxuICAgICAgICAnbWlzc2luZyBtaXBtYXAgZGF0YScpXG4gICAgICBjaGVjayQxKFxuICAgICAgICBpbWFnZURhdGEuZGF0YSB8fCBpbWFnZURhdGEuZWxlbWVudCB8fCBpbWFnZURhdGEubmVlZHNDb3B5LFxuICAgICAgICAnbWlzc2luZyBpbWFnZSBkYXRhJylcblxuICAgICAgdGVtcEJpbmQodGV4dHVyZSlcbiAgICAgIHNldFN1YkltYWdlKGltYWdlRGF0YSwgR0xfVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YJDEgKyBmYWNlLCB4LCB5LCBsZXZlbClcbiAgICAgIHRlbXBSZXN0b3JlKClcblxuICAgICAgZnJlZUltYWdlKGltYWdlRGF0YSlcblxuICAgICAgcmV0dXJuIHJlZ2xUZXh0dXJlQ3ViZVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlc2l6ZSAocmFkaXVzXykge1xuICAgICAgdmFyIHJhZGl1cyA9IHJhZGl1c18gfCAwXG4gICAgICBpZiAocmFkaXVzID09PSB0ZXh0dXJlLndpZHRoKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICByZWdsVGV4dHVyZUN1YmUud2lkdGggPSB0ZXh0dXJlLndpZHRoID0gcmFkaXVzXG4gICAgICByZWdsVGV4dHVyZUN1YmUuaGVpZ2h0ID0gdGV4dHVyZS5oZWlnaHQgPSByYWRpdXNcblxuICAgICAgdGVtcEJpbmQodGV4dHVyZSlcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNjsgKytpKSB7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyB0ZXh0dXJlLm1pcG1hc2sgPj4gajsgKytqKSB7XG4gICAgICAgICAgZ2wudGV4SW1hZ2UyRChcbiAgICAgICAgICAgIEdMX1RFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCQxICsgaSxcbiAgICAgICAgICAgIGosXG4gICAgICAgICAgICB0ZXh0dXJlLmZvcm1hdCxcbiAgICAgICAgICAgIHJhZGl1cyA+PiBqLFxuICAgICAgICAgICAgcmFkaXVzID4+IGosXG4gICAgICAgICAgICAwLFxuICAgICAgICAgICAgdGV4dHVyZS5mb3JtYXQsXG4gICAgICAgICAgICB0ZXh0dXJlLnR5cGUsXG4gICAgICAgICAgICBudWxsKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0ZW1wUmVzdG9yZSgpXG5cbiAgICAgIGlmIChjb25maWcucHJvZmlsZSkge1xuICAgICAgICB0ZXh0dXJlLnN0YXRzLnNpemUgPSBnZXRUZXh0dXJlU2l6ZShcbiAgICAgICAgICB0ZXh0dXJlLmludGVybmFsZm9ybWF0LFxuICAgICAgICAgIHRleHR1cmUudHlwZSxcbiAgICAgICAgICByZWdsVGV4dHVyZUN1YmUud2lkdGgsXG4gICAgICAgICAgcmVnbFRleHR1cmVDdWJlLmhlaWdodCxcbiAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICB0cnVlKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVnbFRleHR1cmVDdWJlXG4gICAgfVxuXG4gICAgcmVnbFRleHR1cmVDdWJlKGEwLCBhMSwgYTIsIGEzLCBhNCwgYTUpXG5cbiAgICByZWdsVGV4dHVyZUN1YmUuc3ViaW1hZ2UgPSBzdWJpbWFnZVxuICAgIHJlZ2xUZXh0dXJlQ3ViZS5yZXNpemUgPSByZXNpemVcbiAgICByZWdsVGV4dHVyZUN1YmUuX3JlZ2xUeXBlID0gJ3RleHR1cmVDdWJlJ1xuICAgIHJlZ2xUZXh0dXJlQ3ViZS5fdGV4dHVyZSA9IHRleHR1cmVcbiAgICBpZiAoY29uZmlnLnByb2ZpbGUpIHtcbiAgICAgIHJlZ2xUZXh0dXJlQ3ViZS5zdGF0cyA9IHRleHR1cmUuc3RhdHNcbiAgICB9XG4gICAgcmVnbFRleHR1cmVDdWJlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0ZXh0dXJlLmRlY1JlZigpXG4gICAgfVxuXG4gICAgcmV0dXJuIHJlZ2xUZXh0dXJlQ3ViZVxuICB9XG5cbiAgLy8gQ2FsbGVkIHdoZW4gcmVnbCBpcyBkZXN0cm95ZWRcbiAgZnVuY3Rpb24gZGVzdHJveVRleHR1cmVzICgpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bVRleFVuaXRzOyArK2kpIHtcbiAgICAgIGdsLmFjdGl2ZVRleHR1cmUoR0xfVEVYVFVSRTAkMSArIGkpXG4gICAgICBnbC5iaW5kVGV4dHVyZShHTF9URVhUVVJFXzJEJDEsIG51bGwpXG4gICAgICB0ZXh0dXJlVW5pdHNbaV0gPSBudWxsXG4gICAgfVxuICAgIHZhbHVlcyh0ZXh0dXJlU2V0KS5mb3JFYWNoKGRlc3Ryb3kpXG5cbiAgICBzdGF0cy5jdWJlQ291bnQgPSAwXG4gICAgc3RhdHMudGV4dHVyZUNvdW50ID0gMFxuICB9XG5cbiAgaWYgKGNvbmZpZy5wcm9maWxlKSB7XG4gICAgc3RhdHMuZ2V0VG90YWxUZXh0dXJlU2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB0b3RhbCA9IDBcbiAgICAgIE9iamVjdC5rZXlzKHRleHR1cmVTZXQpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICB0b3RhbCArPSB0ZXh0dXJlU2V0W2tleV0uc3RhdHMuc2l6ZVxuICAgICAgfSlcbiAgICAgIHJldHVybiB0b3RhbFxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc3RvcmVUZXh0dXJlcyAoKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1UZXhVbml0czsgKytpKSB7XG4gICAgICB2YXIgdGV4ID0gdGV4dHVyZVVuaXRzW2ldXG4gICAgICBpZiAodGV4KSB7XG4gICAgICAgIHRleC5iaW5kQ291bnQgPSAwXG4gICAgICAgIHRleC51bml0ID0gLTFcbiAgICAgICAgdGV4dHVyZVVuaXRzW2ldID0gbnVsbFxuICAgICAgfVxuICAgIH1cblxuICAgIHZhbHVlcyh0ZXh0dXJlU2V0KS5mb3JFYWNoKGZ1bmN0aW9uICh0ZXh0dXJlKSB7XG4gICAgICB0ZXh0dXJlLnRleHR1cmUgPSBnbC5jcmVhdGVUZXh0dXJlKClcbiAgICAgIGdsLmJpbmRUZXh0dXJlKHRleHR1cmUudGFyZ2V0LCB0ZXh0dXJlLnRleHR1cmUpXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDMyOyArK2kpIHtcbiAgICAgICAgaWYgKCh0ZXh0dXJlLm1pcG1hc2sgJiAoMSA8PCBpKSkgPT09IDApIHtcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG4gICAgICAgIGlmICh0ZXh0dXJlLnRhcmdldCA9PT0gR0xfVEVYVFVSRV8yRCQxKSB7XG4gICAgICAgICAgZ2wudGV4SW1hZ2UyRChHTF9URVhUVVJFXzJEJDEsXG4gICAgICAgICAgICBpLFxuICAgICAgICAgICAgdGV4dHVyZS5pbnRlcm5hbGZvcm1hdCxcbiAgICAgICAgICAgIHRleHR1cmUud2lkdGggPj4gaSxcbiAgICAgICAgICAgIHRleHR1cmUuaGVpZ2h0ID4+IGksXG4gICAgICAgICAgICAwLFxuICAgICAgICAgICAgdGV4dHVyZS5pbnRlcm5hbGZvcm1hdCxcbiAgICAgICAgICAgIHRleHR1cmUudHlwZSxcbiAgICAgICAgICAgIG51bGwpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCA2OyArK2opIHtcbiAgICAgICAgICAgIGdsLnRleEltYWdlMkQoR0xfVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YJDEgKyBqLFxuICAgICAgICAgICAgICBpLFxuICAgICAgICAgICAgICB0ZXh0dXJlLmludGVybmFsZm9ybWF0LFxuICAgICAgICAgICAgICB0ZXh0dXJlLndpZHRoID4+IGksXG4gICAgICAgICAgICAgIHRleHR1cmUuaGVpZ2h0ID4+IGksXG4gICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgIHRleHR1cmUuaW50ZXJuYWxmb3JtYXQsXG4gICAgICAgICAgICAgIHRleHR1cmUudHlwZSxcbiAgICAgICAgICAgICAgbnVsbClcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHNldFRleEluZm8odGV4dHVyZS50ZXhJbmZvLCB0ZXh0dXJlLnRhcmdldClcbiAgICB9KVxuICB9XG5cbiAgZnVuY3Rpb24gcmVmcmVzaFRleHR1cmVzICgpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bVRleFVuaXRzOyArK2kpIHtcbiAgICAgIHZhciB0ZXggPSB0ZXh0dXJlVW5pdHNbaV1cbiAgICAgIGlmICh0ZXgpIHtcbiAgICAgICAgdGV4LmJpbmRDb3VudCA9IDBcbiAgICAgICAgdGV4LnVuaXQgPSAtMVxuICAgICAgICB0ZXh0dXJlVW5pdHNbaV0gPSBudWxsXG4gICAgICB9XG4gICAgICBnbC5hY3RpdmVUZXh0dXJlKEdMX1RFWFRVUkUwJDEgKyBpKVxuICAgICAgZ2wuYmluZFRleHR1cmUoR0xfVEVYVFVSRV8yRCQxLCBudWxsKVxuICAgICAgZ2wuYmluZFRleHR1cmUoR0xfVEVYVFVSRV9DVUJFX01BUCQxLCBudWxsKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgY3JlYXRlMkQ6IGNyZWF0ZVRleHR1cmUyRCxcbiAgICBjcmVhdGVDdWJlOiBjcmVhdGVUZXh0dXJlQ3ViZSxcbiAgICBjbGVhcjogZGVzdHJveVRleHR1cmVzLFxuICAgIGdldFRleHR1cmU6IGZ1bmN0aW9uICh3cmFwcGVyKSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH0sXG4gICAgcmVzdG9yZTogcmVzdG9yZVRleHR1cmVzLFxuICAgIHJlZnJlc2g6IHJlZnJlc2hUZXh0dXJlc1xuICB9XG59XG5cbnZhciBHTF9SRU5ERVJCVUZGRVIgPSAweDhENDFcblxudmFyIEdMX1JHQkE0JDEgPSAweDgwNTZcbnZhciBHTF9SR0I1X0ExJDEgPSAweDgwNTdcbnZhciBHTF9SR0I1NjUkMSA9IDB4OEQ2MlxudmFyIEdMX0RFUFRIX0NPTVBPTkVOVDE2ID0gMHg4MUE1XG52YXIgR0xfU1RFTkNJTF9JTkRFWDggPSAweDhENDhcbnZhciBHTF9ERVBUSF9TVEVOQ0lMJDEgPSAweDg0RjlcblxudmFyIEdMX1NSR0I4X0FMUEhBOF9FWFQgPSAweDhDNDNcblxudmFyIEdMX1JHQkEzMkZfRVhUID0gMHg4ODE0XG5cbnZhciBHTF9SR0JBMTZGX0VYVCA9IDB4ODgxQVxudmFyIEdMX1JHQjE2Rl9FWFQgPSAweDg4MUJcblxudmFyIEZPUk1BVF9TSVpFUyA9IFtdXG5cbkZPUk1BVF9TSVpFU1tHTF9SR0JBNCQxXSA9IDJcbkZPUk1BVF9TSVpFU1tHTF9SR0I1X0ExJDFdID0gMlxuRk9STUFUX1NJWkVTW0dMX1JHQjU2NSQxXSA9IDJcblxuRk9STUFUX1NJWkVTW0dMX0RFUFRIX0NPTVBPTkVOVDE2XSA9IDJcbkZPUk1BVF9TSVpFU1tHTF9TVEVOQ0lMX0lOREVYOF0gPSAxXG5GT1JNQVRfU0laRVNbR0xfREVQVEhfU1RFTkNJTCQxXSA9IDRcblxuRk9STUFUX1NJWkVTW0dMX1NSR0I4X0FMUEhBOF9FWFRdID0gNFxuRk9STUFUX1NJWkVTW0dMX1JHQkEzMkZfRVhUXSA9IDE2XG5GT1JNQVRfU0laRVNbR0xfUkdCQTE2Rl9FWFRdID0gOFxuRk9STUFUX1NJWkVTW0dMX1JHQjE2Rl9FWFRdID0gNlxuXG5mdW5jdGlvbiBnZXRSZW5kZXJidWZmZXJTaXplIChmb3JtYXQsIHdpZHRoLCBoZWlnaHQpIHtcbiAgcmV0dXJuIEZPUk1BVF9TSVpFU1tmb3JtYXRdICogd2lkdGggKiBoZWlnaHRcbn1cblxudmFyIHdyYXBSZW5kZXJidWZmZXJzID0gZnVuY3Rpb24gKGdsLCBleHRlbnNpb25zLCBsaW1pdHMsIHN0YXRzLCBjb25maWcpIHtcbiAgdmFyIGZvcm1hdFR5cGVzID0ge1xuICAgICdyZ2JhNCc6IEdMX1JHQkE0JDEsXG4gICAgJ3JnYjU2NSc6IEdMX1JHQjU2NSQxLFxuICAgICdyZ2I1IGExJzogR0xfUkdCNV9BMSQxLFxuICAgICdkZXB0aCc6IEdMX0RFUFRIX0NPTVBPTkVOVDE2LFxuICAgICdzdGVuY2lsJzogR0xfU1RFTkNJTF9JTkRFWDgsXG4gICAgJ2RlcHRoIHN0ZW5jaWwnOiBHTF9ERVBUSF9TVEVOQ0lMJDFcbiAgfVxuXG4gIGlmIChleHRlbnNpb25zLmV4dF9zcmdiKSB7XG4gICAgZm9ybWF0VHlwZXNbJ3NyZ2JhJ10gPSBHTF9TUkdCOF9BTFBIQThfRVhUXG4gIH1cblxuICBpZiAoZXh0ZW5zaW9ucy5leHRfY29sb3JfYnVmZmVyX2hhbGZfZmxvYXQpIHtcbiAgICBmb3JtYXRUeXBlc1sncmdiYTE2ZiddID0gR0xfUkdCQTE2Rl9FWFRcbiAgICBmb3JtYXRUeXBlc1sncmdiMTZmJ10gPSBHTF9SR0IxNkZfRVhUXG4gIH1cblxuICBpZiAoZXh0ZW5zaW9ucy53ZWJnbF9jb2xvcl9idWZmZXJfZmxvYXQpIHtcbiAgICBmb3JtYXRUeXBlc1sncmdiYTMyZiddID0gR0xfUkdCQTMyRl9FWFRcbiAgfVxuXG4gIHZhciBmb3JtYXRUeXBlc0ludmVydCA9IFtdXG4gIE9iamVjdC5rZXlzKGZvcm1hdFR5cGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICB2YXIgdmFsID0gZm9ybWF0VHlwZXNba2V5XVxuICAgIGZvcm1hdFR5cGVzSW52ZXJ0W3ZhbF0gPSBrZXlcbiAgfSlcblxuICB2YXIgcmVuZGVyYnVmZmVyQ291bnQgPSAwXG4gIHZhciByZW5kZXJidWZmZXJTZXQgPSB7fVxuXG4gIGZ1bmN0aW9uIFJFR0xSZW5kZXJidWZmZXIgKHJlbmRlcmJ1ZmZlcikge1xuICAgIHRoaXMuaWQgPSByZW5kZXJidWZmZXJDb3VudCsrXG4gICAgdGhpcy5yZWZDb3VudCA9IDFcblxuICAgIHRoaXMucmVuZGVyYnVmZmVyID0gcmVuZGVyYnVmZmVyXG5cbiAgICB0aGlzLmZvcm1hdCA9IEdMX1JHQkE0JDFcbiAgICB0aGlzLndpZHRoID0gMFxuICAgIHRoaXMuaGVpZ2h0ID0gMFxuXG4gICAgaWYgKGNvbmZpZy5wcm9maWxlKSB7XG4gICAgICB0aGlzLnN0YXRzID0geyBzaXplOiAwIH1cbiAgICB9XG4gIH1cblxuICBSRUdMUmVuZGVyYnVmZmVyLnByb3RvdHlwZS5kZWNSZWYgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKC0tdGhpcy5yZWZDb3VudCA8PSAwKSB7XG4gICAgICBkZXN0cm95KHRoaXMpXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZGVzdHJveSAocmIpIHtcbiAgICB2YXIgaGFuZGxlID0gcmIucmVuZGVyYnVmZmVyXG4gICAgY2hlY2skMShoYW5kbGUsICdtdXN0IG5vdCBkb3VibGUgZGVzdHJveSByZW5kZXJidWZmZXInKVxuICAgIGdsLmJpbmRSZW5kZXJidWZmZXIoR0xfUkVOREVSQlVGRkVSLCBudWxsKVxuICAgIGdsLmRlbGV0ZVJlbmRlcmJ1ZmZlcihoYW5kbGUpXG4gICAgcmIucmVuZGVyYnVmZmVyID0gbnVsbFxuICAgIHJiLnJlZkNvdW50ID0gMFxuICAgIGRlbGV0ZSByZW5kZXJidWZmZXJTZXRbcmIuaWRdXG4gICAgc3RhdHMucmVuZGVyYnVmZmVyQ291bnQtLVxuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlUmVuZGVyYnVmZmVyIChhLCBiKSB7XG4gICAgdmFyIHJlbmRlcmJ1ZmZlciA9IG5ldyBSRUdMUmVuZGVyYnVmZmVyKGdsLmNyZWF0ZVJlbmRlcmJ1ZmZlcigpKVxuICAgIHJlbmRlcmJ1ZmZlclNldFtyZW5kZXJidWZmZXIuaWRdID0gcmVuZGVyYnVmZmVyXG4gICAgc3RhdHMucmVuZGVyYnVmZmVyQ291bnQrK1xuXG4gICAgZnVuY3Rpb24gcmVnbFJlbmRlcmJ1ZmZlciAoYSwgYikge1xuICAgICAgdmFyIHcgPSAwXG4gICAgICB2YXIgaCA9IDBcbiAgICAgIHZhciBmb3JtYXQgPSBHTF9SR0JBNCQxXG5cbiAgICAgIGlmICh0eXBlb2YgYSA9PT0gJ29iamVjdCcgJiYgYSkge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IGFcbiAgICAgICAgaWYgKCdzaGFwZScgaW4gb3B0aW9ucykge1xuICAgICAgICAgIHZhciBzaGFwZSA9IG9wdGlvbnMuc2hhcGVcbiAgICAgICAgICBjaGVjayQxKEFycmF5LmlzQXJyYXkoc2hhcGUpICYmIHNoYXBlLmxlbmd0aCA+PSAyLFxuICAgICAgICAgICAgJ2ludmFsaWQgcmVuZGVyYnVmZmVyIHNoYXBlJylcbiAgICAgICAgICB3ID0gc2hhcGVbMF0gfCAwXG4gICAgICAgICAgaCA9IHNoYXBlWzFdIHwgMFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICgncmFkaXVzJyBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgICB3ID0gaCA9IG9wdGlvbnMucmFkaXVzIHwgMFxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoJ3dpZHRoJyBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgICB3ID0gb3B0aW9ucy53aWR0aCB8IDBcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCdoZWlnaHQnIGluIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGggPSBvcHRpb25zLmhlaWdodCB8IDBcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCdmb3JtYXQnIGluIG9wdGlvbnMpIHtcbiAgICAgICAgICBjaGVjayQxLnBhcmFtZXRlcihvcHRpb25zLmZvcm1hdCwgZm9ybWF0VHlwZXMsXG4gICAgICAgICAgICAnaW52YWxpZCByZW5kZXJidWZmZXIgZm9ybWF0JylcbiAgICAgICAgICBmb3JtYXQgPSBmb3JtYXRUeXBlc1tvcHRpb25zLmZvcm1hdF1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgYSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgdyA9IGEgfCAwXG4gICAgICAgIGlmICh0eXBlb2YgYiA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICBoID0gYiB8IDBcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBoID0gd1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKCFhKSB7XG4gICAgICAgIHcgPSBoID0gMVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2hlY2skMS5yYWlzZSgnaW52YWxpZCBhcmd1bWVudHMgdG8gcmVuZGVyYnVmZmVyIGNvbnN0cnVjdG9yJylcbiAgICAgIH1cblxuICAgICAgLy8gY2hlY2sgc2hhcGVcbiAgICAgIGNoZWNrJDEoXG4gICAgICAgIHcgPiAwICYmIGggPiAwICYmXG4gICAgICAgIHcgPD0gbGltaXRzLm1heFJlbmRlcmJ1ZmZlclNpemUgJiYgaCA8PSBsaW1pdHMubWF4UmVuZGVyYnVmZmVyU2l6ZSxcbiAgICAgICAgJ2ludmFsaWQgcmVuZGVyYnVmZmVyIHNpemUnKVxuXG4gICAgICBpZiAodyA9PT0gcmVuZGVyYnVmZmVyLndpZHRoICYmXG4gICAgICAgICAgaCA9PT0gcmVuZGVyYnVmZmVyLmhlaWdodCAmJlxuICAgICAgICAgIGZvcm1hdCA9PT0gcmVuZGVyYnVmZmVyLmZvcm1hdCkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgcmVnbFJlbmRlcmJ1ZmZlci53aWR0aCA9IHJlbmRlcmJ1ZmZlci53aWR0aCA9IHdcbiAgICAgIHJlZ2xSZW5kZXJidWZmZXIuaGVpZ2h0ID0gcmVuZGVyYnVmZmVyLmhlaWdodCA9IGhcbiAgICAgIHJlbmRlcmJ1ZmZlci5mb3JtYXQgPSBmb3JtYXRcblxuICAgICAgZ2wuYmluZFJlbmRlcmJ1ZmZlcihHTF9SRU5ERVJCVUZGRVIsIHJlbmRlcmJ1ZmZlci5yZW5kZXJidWZmZXIpXG4gICAgICBnbC5yZW5kZXJidWZmZXJTdG9yYWdlKEdMX1JFTkRFUkJVRkZFUiwgZm9ybWF0LCB3LCBoKVxuXG4gICAgICBjaGVjayQxKFxuICAgICAgICBnbC5nZXRFcnJvcigpID09PSAwLFxuICAgICAgICAnaW52YWxpZCByZW5kZXIgYnVmZmVyIGZvcm1hdCcpXG5cbiAgICAgIGlmIChjb25maWcucHJvZmlsZSkge1xuICAgICAgICByZW5kZXJidWZmZXIuc3RhdHMuc2l6ZSA9IGdldFJlbmRlcmJ1ZmZlclNpemUocmVuZGVyYnVmZmVyLmZvcm1hdCwgcmVuZGVyYnVmZmVyLndpZHRoLCByZW5kZXJidWZmZXIuaGVpZ2h0KVxuICAgICAgfVxuICAgICAgcmVnbFJlbmRlcmJ1ZmZlci5mb3JtYXQgPSBmb3JtYXRUeXBlc0ludmVydFtyZW5kZXJidWZmZXIuZm9ybWF0XVxuXG4gICAgICByZXR1cm4gcmVnbFJlbmRlcmJ1ZmZlclxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlc2l6ZSAod18sIGhfKSB7XG4gICAgICB2YXIgdyA9IHdfIHwgMFxuICAgICAgdmFyIGggPSAoaF8gfCAwKSB8fCB3XG5cbiAgICAgIGlmICh3ID09PSByZW5kZXJidWZmZXIud2lkdGggJiYgaCA9PT0gcmVuZGVyYnVmZmVyLmhlaWdodCkge1xuICAgICAgICByZXR1cm4gcmVnbFJlbmRlcmJ1ZmZlclxuICAgICAgfVxuXG4gICAgICAvLyBjaGVjayBzaGFwZVxuICAgICAgY2hlY2skMShcbiAgICAgICAgdyA+IDAgJiYgaCA+IDAgJiZcbiAgICAgICAgdyA8PSBsaW1pdHMubWF4UmVuZGVyYnVmZmVyU2l6ZSAmJiBoIDw9IGxpbWl0cy5tYXhSZW5kZXJidWZmZXJTaXplLFxuICAgICAgICAnaW52YWxpZCByZW5kZXJidWZmZXIgc2l6ZScpXG5cbiAgICAgIHJlZ2xSZW5kZXJidWZmZXIud2lkdGggPSByZW5kZXJidWZmZXIud2lkdGggPSB3XG4gICAgICByZWdsUmVuZGVyYnVmZmVyLmhlaWdodCA9IHJlbmRlcmJ1ZmZlci5oZWlnaHQgPSBoXG5cbiAgICAgIGdsLmJpbmRSZW5kZXJidWZmZXIoR0xfUkVOREVSQlVGRkVSLCByZW5kZXJidWZmZXIucmVuZGVyYnVmZmVyKVxuICAgICAgZ2wucmVuZGVyYnVmZmVyU3RvcmFnZShHTF9SRU5ERVJCVUZGRVIsIHJlbmRlcmJ1ZmZlci5mb3JtYXQsIHcsIGgpXG5cbiAgICAgIGNoZWNrJDEoXG4gICAgICAgIGdsLmdldEVycm9yKCkgPT09IDAsXG4gICAgICAgICdpbnZhbGlkIHJlbmRlciBidWZmZXIgZm9ybWF0JylcblxuICAgICAgLy8gYWxzbywgcmVjb21wdXRlIHNpemUuXG4gICAgICBpZiAoY29uZmlnLnByb2ZpbGUpIHtcbiAgICAgICAgcmVuZGVyYnVmZmVyLnN0YXRzLnNpemUgPSBnZXRSZW5kZXJidWZmZXJTaXplKFxuICAgICAgICAgIHJlbmRlcmJ1ZmZlci5mb3JtYXQsIHJlbmRlcmJ1ZmZlci53aWR0aCwgcmVuZGVyYnVmZmVyLmhlaWdodClcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlZ2xSZW5kZXJidWZmZXJcbiAgICB9XG5cbiAgICByZWdsUmVuZGVyYnVmZmVyKGEsIGIpXG5cbiAgICByZWdsUmVuZGVyYnVmZmVyLnJlc2l6ZSA9IHJlc2l6ZVxuICAgIHJlZ2xSZW5kZXJidWZmZXIuX3JlZ2xUeXBlID0gJ3JlbmRlcmJ1ZmZlcidcbiAgICByZWdsUmVuZGVyYnVmZmVyLl9yZW5kZXJidWZmZXIgPSByZW5kZXJidWZmZXJcbiAgICBpZiAoY29uZmlnLnByb2ZpbGUpIHtcbiAgICAgIHJlZ2xSZW5kZXJidWZmZXIuc3RhdHMgPSByZW5kZXJidWZmZXIuc3RhdHNcbiAgICB9XG4gICAgcmVnbFJlbmRlcmJ1ZmZlci5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmVuZGVyYnVmZmVyLmRlY1JlZigpXG4gICAgfVxuXG4gICAgcmV0dXJuIHJlZ2xSZW5kZXJidWZmZXJcbiAgfVxuXG4gIGlmIChjb25maWcucHJvZmlsZSkge1xuICAgIHN0YXRzLmdldFRvdGFsUmVuZGVyYnVmZmVyU2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB0b3RhbCA9IDBcbiAgICAgIE9iamVjdC5rZXlzKHJlbmRlcmJ1ZmZlclNldCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHRvdGFsICs9IHJlbmRlcmJ1ZmZlclNldFtrZXldLnN0YXRzLnNpemVcbiAgICAgIH0pXG4gICAgICByZXR1cm4gdG90YWxcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZXN0b3JlUmVuZGVyYnVmZmVycyAoKSB7XG4gICAgdmFsdWVzKHJlbmRlcmJ1ZmZlclNldCkuZm9yRWFjaChmdW5jdGlvbiAocmIpIHtcbiAgICAgIHJiLnJlbmRlcmJ1ZmZlciA9IGdsLmNyZWF0ZVJlbmRlcmJ1ZmZlcigpXG4gICAgICBnbC5iaW5kUmVuZGVyYnVmZmVyKEdMX1JFTkRFUkJVRkZFUiwgcmIucmVuZGVyYnVmZmVyKVxuICAgICAgZ2wucmVuZGVyYnVmZmVyU3RvcmFnZShHTF9SRU5ERVJCVUZGRVIsIHJiLmZvcm1hdCwgcmIud2lkdGgsIHJiLmhlaWdodClcbiAgICB9KVxuICAgIGdsLmJpbmRSZW5kZXJidWZmZXIoR0xfUkVOREVSQlVGRkVSLCBudWxsKVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBjcmVhdGU6IGNyZWF0ZVJlbmRlcmJ1ZmZlcixcbiAgICBjbGVhcjogZnVuY3Rpb24gKCkge1xuICAgICAgdmFsdWVzKHJlbmRlcmJ1ZmZlclNldCkuZm9yRWFjaChkZXN0cm95KVxuICAgIH0sXG4gICAgcmVzdG9yZTogcmVzdG9yZVJlbmRlcmJ1ZmZlcnNcbiAgfVxufVxuXG4vLyBXZSBzdG9yZSB0aGVzZSBjb25zdGFudHMgc28gdGhhdCB0aGUgbWluaWZpZXIgY2FuIGlubGluZSB0aGVtXG52YXIgR0xfRlJBTUVCVUZGRVIkMSA9IDB4OEQ0MFxudmFyIEdMX1JFTkRFUkJVRkZFUiQxID0gMHg4RDQxXG5cbnZhciBHTF9URVhUVVJFXzJEJDIgPSAweDBERTFcbnZhciBHTF9URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1gkMiA9IDB4ODUxNVxuXG52YXIgR0xfQ09MT1JfQVRUQUNITUVOVDAkMSA9IDB4OENFMFxudmFyIEdMX0RFUFRIX0FUVEFDSE1FTlQgPSAweDhEMDBcbnZhciBHTF9TVEVOQ0lMX0FUVEFDSE1FTlQgPSAweDhEMjBcbnZhciBHTF9ERVBUSF9TVEVOQ0lMX0FUVEFDSE1FTlQgPSAweDgyMUFcblxudmFyIEdMX0ZSQU1FQlVGRkVSX0NPTVBMRVRFJDEgPSAweDhDRDVcbnZhciBHTF9GUkFNRUJVRkZFUl9JTkNPTVBMRVRFX0FUVEFDSE1FTlQgPSAweDhDRDZcbnZhciBHTF9GUkFNRUJVRkZFUl9JTkNPTVBMRVRFX01JU1NJTkdfQVRUQUNITUVOVCA9IDB4OENEN1xudmFyIEdMX0ZSQU1FQlVGRkVSX0lOQ09NUExFVEVfRElNRU5TSU9OUyA9IDB4OENEOVxudmFyIEdMX0ZSQU1FQlVGRkVSX1VOU1VQUE9SVEVEID0gMHg4Q0REXG5cbnZhciBHTF9IQUxGX0ZMT0FUX09FUyQyID0gMHg4RDYxXG52YXIgR0xfVU5TSUdORURfQllURSQ2ID0gMHgxNDAxXG52YXIgR0xfRkxPQVQkNSA9IDB4MTQwNlxuXG52YXIgR0xfUkdCJDEgPSAweDE5MDdcbnZhciBHTF9SR0JBJDIgPSAweDE5MDhcblxudmFyIEdMX0RFUFRIX0NPTVBPTkVOVCQxID0gMHgxOTAyXG5cbnZhciBjb2xvclRleHR1cmVGb3JtYXRFbnVtcyA9IFtcbiAgR0xfUkdCJDEsXG4gIEdMX1JHQkEkMlxuXVxuXG4vLyBmb3IgZXZlcnkgdGV4dHVyZSBmb3JtYXQsIHN0b3JlXG4vLyB0aGUgbnVtYmVyIG9mIGNoYW5uZWxzXG52YXIgdGV4dHVyZUZvcm1hdENoYW5uZWxzID0gW11cbnRleHR1cmVGb3JtYXRDaGFubmVsc1tHTF9SR0JBJDJdID0gNFxudGV4dHVyZUZvcm1hdENoYW5uZWxzW0dMX1JHQiQxXSA9IDNcblxuLy8gZm9yIGV2ZXJ5IHRleHR1cmUgdHlwZSwgc3RvcmVcbi8vIHRoZSBzaXplIGluIGJ5dGVzLlxudmFyIHRleHR1cmVUeXBlU2l6ZXMgPSBbXVxudGV4dHVyZVR5cGVTaXplc1tHTF9VTlNJR05FRF9CWVRFJDZdID0gMVxudGV4dHVyZVR5cGVTaXplc1tHTF9GTE9BVCQ1XSA9IDRcbnRleHR1cmVUeXBlU2l6ZXNbR0xfSEFMRl9GTE9BVF9PRVMkMl0gPSAyXG5cbnZhciBHTF9SR0JBNCQyID0gMHg4MDU2XG52YXIgR0xfUkdCNV9BMSQyID0gMHg4MDU3XG52YXIgR0xfUkdCNTY1JDIgPSAweDhENjJcbnZhciBHTF9ERVBUSF9DT01QT05FTlQxNiQxID0gMHg4MUE1XG52YXIgR0xfU1RFTkNJTF9JTkRFWDgkMSA9IDB4OEQ0OFxudmFyIEdMX0RFUFRIX1NURU5DSUwkMiA9IDB4ODRGOVxuXG52YXIgR0xfU1JHQjhfQUxQSEE4X0VYVCQxID0gMHg4QzQzXG5cbnZhciBHTF9SR0JBMzJGX0VYVCQxID0gMHg4ODE0XG5cbnZhciBHTF9SR0JBMTZGX0VYVCQxID0gMHg4ODFBXG52YXIgR0xfUkdCMTZGX0VYVCQxID0gMHg4ODFCXG5cbnZhciBjb2xvclJlbmRlcmJ1ZmZlckZvcm1hdEVudW1zID0gW1xuICBHTF9SR0JBNCQyLFxuICBHTF9SR0I1X0ExJDIsXG4gIEdMX1JHQjU2NSQyLFxuICBHTF9TUkdCOF9BTFBIQThfRVhUJDEsXG4gIEdMX1JHQkExNkZfRVhUJDEsXG4gIEdMX1JHQjE2Rl9FWFQkMSxcbiAgR0xfUkdCQTMyRl9FWFQkMVxuXVxuXG52YXIgc3RhdHVzQ29kZSA9IHt9XG5zdGF0dXNDb2RlW0dMX0ZSQU1FQlVGRkVSX0NPTVBMRVRFJDFdID0gJ2NvbXBsZXRlJ1xuc3RhdHVzQ29kZVtHTF9GUkFNRUJVRkZFUl9JTkNPTVBMRVRFX0FUVEFDSE1FTlRdID0gJ2luY29tcGxldGUgYXR0YWNobWVudCdcbnN0YXR1c0NvZGVbR0xfRlJBTUVCVUZGRVJfSU5DT01QTEVURV9ESU1FTlNJT05TXSA9ICdpbmNvbXBsZXRlIGRpbWVuc2lvbnMnXG5zdGF0dXNDb2RlW0dMX0ZSQU1FQlVGRkVSX0lOQ09NUExFVEVfTUlTU0lOR19BVFRBQ0hNRU5UXSA9ICdpbmNvbXBsZXRlLCBtaXNzaW5nIGF0dGFjaG1lbnQnXG5zdGF0dXNDb2RlW0dMX0ZSQU1FQlVGRkVSX1VOU1VQUE9SVEVEXSA9ICd1bnN1cHBvcnRlZCdcblxuZnVuY3Rpb24gd3JhcEZCT1N0YXRlIChcbiAgZ2wsXG4gIGV4dGVuc2lvbnMsXG4gIGxpbWl0cyxcbiAgdGV4dHVyZVN0YXRlLFxuICByZW5kZXJidWZmZXJTdGF0ZSxcbiAgc3RhdHMpIHtcbiAgdmFyIGZyYW1lYnVmZmVyU3RhdGUgPSB7XG4gICAgY3VyOiBudWxsLFxuICAgIG5leHQ6IG51bGwsXG4gICAgZGlydHk6IGZhbHNlLFxuICAgIHNldEZCTzogbnVsbFxuICB9XG5cbiAgdmFyIGNvbG9yVGV4dHVyZUZvcm1hdHMgPSBbJ3JnYmEnXVxuICB2YXIgY29sb3JSZW5kZXJidWZmZXJGb3JtYXRzID0gWydyZ2JhNCcsICdyZ2I1NjUnLCAncmdiNSBhMSddXG5cbiAgaWYgKGV4dGVuc2lvbnMuZXh0X3NyZ2IpIHtcbiAgICBjb2xvclJlbmRlcmJ1ZmZlckZvcm1hdHMucHVzaCgnc3JnYmEnKVxuICB9XG5cbiAgaWYgKGV4dGVuc2lvbnMuZXh0X2NvbG9yX2J1ZmZlcl9oYWxmX2Zsb2F0KSB7XG4gICAgY29sb3JSZW5kZXJidWZmZXJGb3JtYXRzLnB1c2goJ3JnYmExNmYnLCAncmdiMTZmJylcbiAgfVxuXG4gIGlmIChleHRlbnNpb25zLndlYmdsX2NvbG9yX2J1ZmZlcl9mbG9hdCkge1xuICAgIGNvbG9yUmVuZGVyYnVmZmVyRm9ybWF0cy5wdXNoKCdyZ2JhMzJmJylcbiAgfVxuXG4gIHZhciBjb2xvclR5cGVzID0gWyd1aW50OCddXG4gIGlmIChleHRlbnNpb25zLm9lc190ZXh0dXJlX2hhbGZfZmxvYXQpIHtcbiAgICBjb2xvclR5cGVzLnB1c2goJ2hhbGYgZmxvYXQnLCAnZmxvYXQxNicpXG4gIH1cbiAgaWYgKGV4dGVuc2lvbnMub2VzX3RleHR1cmVfZmxvYXQpIHtcbiAgICBjb2xvclR5cGVzLnB1c2goJ2Zsb2F0JywgJ2Zsb2F0MzInKVxuICB9XG5cbiAgZnVuY3Rpb24gRnJhbWVidWZmZXJBdHRhY2htZW50ICh0YXJnZXQsIHRleHR1cmUsIHJlbmRlcmJ1ZmZlcikge1xuICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0XG4gICAgdGhpcy50ZXh0dXJlID0gdGV4dHVyZVxuICAgIHRoaXMucmVuZGVyYnVmZmVyID0gcmVuZGVyYnVmZmVyXG5cbiAgICB2YXIgdyA9IDBcbiAgICB2YXIgaCA9IDBcbiAgICBpZiAodGV4dHVyZSkge1xuICAgICAgdyA9IHRleHR1cmUud2lkdGhcbiAgICAgIGggPSB0ZXh0dXJlLmhlaWdodFxuICAgIH0gZWxzZSBpZiAocmVuZGVyYnVmZmVyKSB7XG4gICAgICB3ID0gcmVuZGVyYnVmZmVyLndpZHRoXG4gICAgICBoID0gcmVuZGVyYnVmZmVyLmhlaWdodFxuICAgIH1cbiAgICB0aGlzLndpZHRoID0gd1xuICAgIHRoaXMuaGVpZ2h0ID0gaFxuICB9XG5cbiAgZnVuY3Rpb24gZGVjUmVmIChhdHRhY2htZW50KSB7XG4gICAgaWYgKGF0dGFjaG1lbnQpIHtcbiAgICAgIGlmIChhdHRhY2htZW50LnRleHR1cmUpIHtcbiAgICAgICAgYXR0YWNobWVudC50ZXh0dXJlLl90ZXh0dXJlLmRlY1JlZigpXG4gICAgICB9XG4gICAgICBpZiAoYXR0YWNobWVudC5yZW5kZXJidWZmZXIpIHtcbiAgICAgICAgYXR0YWNobWVudC5yZW5kZXJidWZmZXIuX3JlbmRlcmJ1ZmZlci5kZWNSZWYoKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGluY1JlZkFuZENoZWNrU2hhcGUgKGF0dGFjaG1lbnQsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICBpZiAoIWF0dGFjaG1lbnQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBpZiAoYXR0YWNobWVudC50ZXh0dXJlKSB7XG4gICAgICB2YXIgdGV4dHVyZSA9IGF0dGFjaG1lbnQudGV4dHVyZS5fdGV4dHVyZVxuICAgICAgdmFyIHR3ID0gTWF0aC5tYXgoMSwgdGV4dHVyZS53aWR0aClcbiAgICAgIHZhciB0aCA9IE1hdGgubWF4KDEsIHRleHR1cmUuaGVpZ2h0KVxuICAgICAgY2hlY2skMSh0dyA9PT0gd2lkdGggJiYgdGggPT09IGhlaWdodCxcbiAgICAgICAgJ2luY29uc2lzdGVudCB3aWR0aC9oZWlnaHQgZm9yIHN1cHBsaWVkIHRleHR1cmUnKVxuICAgICAgdGV4dHVyZS5yZWZDb3VudCArPSAxXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciByZW5kZXJidWZmZXIgPSBhdHRhY2htZW50LnJlbmRlcmJ1ZmZlci5fcmVuZGVyYnVmZmVyXG4gICAgICBjaGVjayQxKFxuICAgICAgICByZW5kZXJidWZmZXIud2lkdGggPT09IHdpZHRoICYmIHJlbmRlcmJ1ZmZlci5oZWlnaHQgPT09IGhlaWdodCxcbiAgICAgICAgJ2luY29uc2lzdGVudCB3aWR0aC9oZWlnaHQgZm9yIHJlbmRlcmJ1ZmZlcicpXG4gICAgICByZW5kZXJidWZmZXIucmVmQ291bnQgKz0gMVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGF0dGFjaCAobG9jYXRpb24sIGF0dGFjaG1lbnQpIHtcbiAgICBpZiAoYXR0YWNobWVudCkge1xuICAgICAgaWYgKGF0dGFjaG1lbnQudGV4dHVyZSkge1xuICAgICAgICBnbC5mcmFtZWJ1ZmZlclRleHR1cmUyRChcbiAgICAgICAgICBHTF9GUkFNRUJVRkZFUiQxLFxuICAgICAgICAgIGxvY2F0aW9uLFxuICAgICAgICAgIGF0dGFjaG1lbnQudGFyZ2V0LFxuICAgICAgICAgIGF0dGFjaG1lbnQudGV4dHVyZS5fdGV4dHVyZS50ZXh0dXJlLFxuICAgICAgICAgIDApXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBnbC5mcmFtZWJ1ZmZlclJlbmRlcmJ1ZmZlcihcbiAgICAgICAgICBHTF9GUkFNRUJVRkZFUiQxLFxuICAgICAgICAgIGxvY2F0aW9uLFxuICAgICAgICAgIEdMX1JFTkRFUkJVRkZFUiQxLFxuICAgICAgICAgIGF0dGFjaG1lbnQucmVuZGVyYnVmZmVyLl9yZW5kZXJidWZmZXIucmVuZGVyYnVmZmVyKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlQXR0YWNobWVudCAoYXR0YWNobWVudCkge1xuICAgIHZhciB0YXJnZXQgPSBHTF9URVhUVVJFXzJEJDJcbiAgICB2YXIgdGV4dHVyZSA9IG51bGxcbiAgICB2YXIgcmVuZGVyYnVmZmVyID0gbnVsbFxuXG4gICAgdmFyIGRhdGEgPSBhdHRhY2htZW50XG4gICAgaWYgKHR5cGVvZiBhdHRhY2htZW50ID09PSAnb2JqZWN0Jykge1xuICAgICAgZGF0YSA9IGF0dGFjaG1lbnQuZGF0YVxuICAgICAgaWYgKCd0YXJnZXQnIGluIGF0dGFjaG1lbnQpIHtcbiAgICAgICAgdGFyZ2V0ID0gYXR0YWNobWVudC50YXJnZXQgfCAwXG4gICAgICB9XG4gICAgfVxuXG4gICAgY2hlY2skMS50eXBlKGRhdGEsICdmdW5jdGlvbicsICdpbnZhbGlkIGF0dGFjaG1lbnQgZGF0YScpXG5cbiAgICB2YXIgdHlwZSA9IGRhdGEuX3JlZ2xUeXBlXG4gICAgaWYgKHR5cGUgPT09ICd0ZXh0dXJlMmQnKSB7XG4gICAgICB0ZXh0dXJlID0gZGF0YVxuICAgICAgY2hlY2skMSh0YXJnZXQgPT09IEdMX1RFWFRVUkVfMkQkMilcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICd0ZXh0dXJlQ3ViZScpIHtcbiAgICAgIHRleHR1cmUgPSBkYXRhXG4gICAgICBjaGVjayQxKFxuICAgICAgICB0YXJnZXQgPj0gR0xfVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YJDIgJiZcbiAgICAgICAgdGFyZ2V0IDwgR0xfVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YJDIgKyA2LFxuICAgICAgICAnaW52YWxpZCBjdWJlIG1hcCB0YXJnZXQnKVxuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ3JlbmRlcmJ1ZmZlcicpIHtcbiAgICAgIHJlbmRlcmJ1ZmZlciA9IGRhdGFcbiAgICAgIHRhcmdldCA9IEdMX1JFTkRFUkJVRkZFUiQxXG4gICAgfSBlbHNlIHtcbiAgICAgIGNoZWNrJDEucmFpc2UoJ2ludmFsaWQgcmVnbCBvYmplY3QgZm9yIGF0dGFjaG1lbnQnKVxuICAgIH1cblxuICAgIHJldHVybiBuZXcgRnJhbWVidWZmZXJBdHRhY2htZW50KHRhcmdldCwgdGV4dHVyZSwgcmVuZGVyYnVmZmVyKVxuICB9XG5cbiAgZnVuY3Rpb24gYWxsb2NBdHRhY2htZW50IChcbiAgICB3aWR0aCxcbiAgICBoZWlnaHQsXG4gICAgaXNUZXh0dXJlLFxuICAgIGZvcm1hdCxcbiAgICB0eXBlKSB7XG4gICAgaWYgKGlzVGV4dHVyZSkge1xuICAgICAgdmFyIHRleHR1cmUgPSB0ZXh0dXJlU3RhdGUuY3JlYXRlMkQoe1xuICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgICBmb3JtYXQ6IGZvcm1hdCxcbiAgICAgICAgdHlwZTogdHlwZVxuICAgICAgfSlcbiAgICAgIHRleHR1cmUuX3RleHR1cmUucmVmQ291bnQgPSAwXG4gICAgICByZXR1cm4gbmV3IEZyYW1lYnVmZmVyQXR0YWNobWVudChHTF9URVhUVVJFXzJEJDIsIHRleHR1cmUsIG51bGwpXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciByYiA9IHJlbmRlcmJ1ZmZlclN0YXRlLmNyZWF0ZSh7XG4gICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgICAgIGZvcm1hdDogZm9ybWF0XG4gICAgICB9KVxuICAgICAgcmIuX3JlbmRlcmJ1ZmZlci5yZWZDb3VudCA9IDBcbiAgICAgIHJldHVybiBuZXcgRnJhbWVidWZmZXJBdHRhY2htZW50KEdMX1JFTkRFUkJVRkZFUiQxLCBudWxsLCByYilcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1bndyYXBBdHRhY2htZW50IChhdHRhY2htZW50KSB7XG4gICAgcmV0dXJuIGF0dGFjaG1lbnQgJiYgKGF0dGFjaG1lbnQudGV4dHVyZSB8fCBhdHRhY2htZW50LnJlbmRlcmJ1ZmZlcilcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc2l6ZUF0dGFjaG1lbnQgKGF0dGFjaG1lbnQsIHcsIGgpIHtcbiAgICBpZiAoYXR0YWNobWVudCkge1xuICAgICAgaWYgKGF0dGFjaG1lbnQudGV4dHVyZSkge1xuICAgICAgICBhdHRhY2htZW50LnRleHR1cmUucmVzaXplKHcsIGgpXG4gICAgICB9IGVsc2UgaWYgKGF0dGFjaG1lbnQucmVuZGVyYnVmZmVyKSB7XG4gICAgICAgIGF0dGFjaG1lbnQucmVuZGVyYnVmZmVyLnJlc2l6ZSh3LCBoKVxuICAgICAgfVxuICAgICAgYXR0YWNobWVudC53aWR0aCA9IHdcbiAgICAgIGF0dGFjaG1lbnQuaGVpZ2h0ID0gaFxuICAgIH1cbiAgfVxuXG4gIHZhciBmcmFtZWJ1ZmZlckNvdW50ID0gMFxuICB2YXIgZnJhbWVidWZmZXJTZXQgPSB7fVxuXG4gIGZ1bmN0aW9uIFJFR0xGcmFtZWJ1ZmZlciAoKSB7XG4gICAgdGhpcy5pZCA9IGZyYW1lYnVmZmVyQ291bnQrK1xuICAgIGZyYW1lYnVmZmVyU2V0W3RoaXMuaWRdID0gdGhpc1xuXG4gICAgdGhpcy5mcmFtZWJ1ZmZlciA9IGdsLmNyZWF0ZUZyYW1lYnVmZmVyKClcbiAgICB0aGlzLndpZHRoID0gMFxuICAgIHRoaXMuaGVpZ2h0ID0gMFxuXG4gICAgdGhpcy5jb2xvckF0dGFjaG1lbnRzID0gW11cbiAgICB0aGlzLmRlcHRoQXR0YWNobWVudCA9IG51bGxcbiAgICB0aGlzLnN0ZW5jaWxBdHRhY2htZW50ID0gbnVsbFxuICAgIHRoaXMuZGVwdGhTdGVuY2lsQXR0YWNobWVudCA9IG51bGxcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlY0ZCT1JlZnMgKGZyYW1lYnVmZmVyKSB7XG4gICAgZnJhbWVidWZmZXIuY29sb3JBdHRhY2htZW50cy5mb3JFYWNoKGRlY1JlZilcbiAgICBkZWNSZWYoZnJhbWVidWZmZXIuZGVwdGhBdHRhY2htZW50KVxuICAgIGRlY1JlZihmcmFtZWJ1ZmZlci5zdGVuY2lsQXR0YWNobWVudClcbiAgICBkZWNSZWYoZnJhbWVidWZmZXIuZGVwdGhTdGVuY2lsQXR0YWNobWVudClcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlc3Ryb3kgKGZyYW1lYnVmZmVyKSB7XG4gICAgdmFyIGhhbmRsZSA9IGZyYW1lYnVmZmVyLmZyYW1lYnVmZmVyXG4gICAgY2hlY2skMShoYW5kbGUsICdtdXN0IG5vdCBkb3VibGUgZGVzdHJveSBmcmFtZWJ1ZmZlcicpXG4gICAgZ2wuZGVsZXRlRnJhbWVidWZmZXIoaGFuZGxlKVxuICAgIGZyYW1lYnVmZmVyLmZyYW1lYnVmZmVyID0gbnVsbFxuICAgIHN0YXRzLmZyYW1lYnVmZmVyQ291bnQtLVxuICAgIGRlbGV0ZSBmcmFtZWJ1ZmZlclNldFtmcmFtZWJ1ZmZlci5pZF1cbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUZyYW1lYnVmZmVyIChmcmFtZWJ1ZmZlcikge1xuICAgIHZhciBpXG5cbiAgICBnbC5iaW5kRnJhbWVidWZmZXIoR0xfRlJBTUVCVUZGRVIkMSwgZnJhbWVidWZmZXIuZnJhbWVidWZmZXIpXG4gICAgdmFyIGNvbG9yQXR0YWNobWVudHMgPSBmcmFtZWJ1ZmZlci5jb2xvckF0dGFjaG1lbnRzXG4gICAgZm9yIChpID0gMDsgaSA8IGNvbG9yQXR0YWNobWVudHMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGF0dGFjaChHTF9DT0xPUl9BVFRBQ0hNRU5UMCQxICsgaSwgY29sb3JBdHRhY2htZW50c1tpXSlcbiAgICB9XG4gICAgZm9yIChpID0gY29sb3JBdHRhY2htZW50cy5sZW5ndGg7IGkgPCBsaW1pdHMubWF4Q29sb3JBdHRhY2htZW50czsgKytpKSB7XG4gICAgICBnbC5mcmFtZWJ1ZmZlclRleHR1cmUyRChcbiAgICAgICAgR0xfRlJBTUVCVUZGRVIkMSxcbiAgICAgICAgR0xfQ09MT1JfQVRUQUNITUVOVDAkMSArIGksXG4gICAgICAgIEdMX1RFWFRVUkVfMkQkMixcbiAgICAgICAgbnVsbCxcbiAgICAgICAgMClcbiAgICB9XG5cbiAgICBnbC5mcmFtZWJ1ZmZlclRleHR1cmUyRChcbiAgICAgIEdMX0ZSQU1FQlVGRkVSJDEsXG4gICAgICBHTF9ERVBUSF9TVEVOQ0lMX0FUVEFDSE1FTlQsXG4gICAgICBHTF9URVhUVVJFXzJEJDIsXG4gICAgICBudWxsLFxuICAgICAgMClcbiAgICBnbC5mcmFtZWJ1ZmZlclRleHR1cmUyRChcbiAgICAgIEdMX0ZSQU1FQlVGRkVSJDEsXG4gICAgICBHTF9ERVBUSF9BVFRBQ0hNRU5ULFxuICAgICAgR0xfVEVYVFVSRV8yRCQyLFxuICAgICAgbnVsbCxcbiAgICAgIDApXG4gICAgZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoXG4gICAgICBHTF9GUkFNRUJVRkZFUiQxLFxuICAgICAgR0xfU1RFTkNJTF9BVFRBQ0hNRU5ULFxuICAgICAgR0xfVEVYVFVSRV8yRCQyLFxuICAgICAgbnVsbCxcbiAgICAgIDApXG5cbiAgICBhdHRhY2goR0xfREVQVEhfQVRUQUNITUVOVCwgZnJhbWVidWZmZXIuZGVwdGhBdHRhY2htZW50KVxuICAgIGF0dGFjaChHTF9TVEVOQ0lMX0FUVEFDSE1FTlQsIGZyYW1lYnVmZmVyLnN0ZW5jaWxBdHRhY2htZW50KVxuICAgIGF0dGFjaChHTF9ERVBUSF9TVEVOQ0lMX0FUVEFDSE1FTlQsIGZyYW1lYnVmZmVyLmRlcHRoU3RlbmNpbEF0dGFjaG1lbnQpXG5cbiAgICAvLyBDaGVjayBzdGF0dXMgY29kZVxuICAgIHZhciBzdGF0dXMgPSBnbC5jaGVja0ZyYW1lYnVmZmVyU3RhdHVzKEdMX0ZSQU1FQlVGRkVSJDEpXG4gICAgaWYgKCFnbC5pc0NvbnRleHRMb3N0KCkgJiYgc3RhdHVzICE9PSBHTF9GUkFNRUJVRkZFUl9DT01QTEVURSQxKSB7XG4gICAgICBjaGVjayQxLnJhaXNlKCdmcmFtZWJ1ZmZlciBjb25maWd1cmF0aW9uIG5vdCBzdXBwb3J0ZWQsIHN0YXR1cyA9ICcgK1xuICAgICAgICBzdGF0dXNDb2RlW3N0YXR1c10pXG4gICAgfVxuXG4gICAgZ2wuYmluZEZyYW1lYnVmZmVyKEdMX0ZSQU1FQlVGRkVSJDEsIGZyYW1lYnVmZmVyU3RhdGUubmV4dCA/IGZyYW1lYnVmZmVyU3RhdGUubmV4dC5mcmFtZWJ1ZmZlciA6IG51bGwpXG4gICAgZnJhbWVidWZmZXJTdGF0ZS5jdXIgPSBmcmFtZWJ1ZmZlclN0YXRlLm5leHRcblxuICAgIC8vIEZJWE1FOiBDbGVhciBlcnJvciBjb2RlIGhlcmUuICBUaGlzIGlzIGEgd29yayBhcm91bmQgZm9yIGEgYnVnIGluXG4gICAgLy8gaGVhZGxlc3MtZ2xcbiAgICBnbC5nZXRFcnJvcigpXG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVGQk8gKGEwLCBhMSkge1xuICAgIHZhciBmcmFtZWJ1ZmZlciA9IG5ldyBSRUdMRnJhbWVidWZmZXIoKVxuICAgIHN0YXRzLmZyYW1lYnVmZmVyQ291bnQrK1xuXG4gICAgZnVuY3Rpb24gcmVnbEZyYW1lYnVmZmVyIChhLCBiKSB7XG4gICAgICB2YXIgaVxuXG4gICAgICBjaGVjayQxKGZyYW1lYnVmZmVyU3RhdGUubmV4dCAhPT0gZnJhbWVidWZmZXIsXG4gICAgICAgICdjYW4gbm90IHVwZGF0ZSBmcmFtZWJ1ZmZlciB3aGljaCBpcyBjdXJyZW50bHkgaW4gdXNlJylcblxuICAgICAgdmFyIHdpZHRoID0gMFxuICAgICAgdmFyIGhlaWdodCA9IDBcblxuICAgICAgdmFyIG5lZWRzRGVwdGggPSB0cnVlXG4gICAgICB2YXIgbmVlZHNTdGVuY2lsID0gdHJ1ZVxuXG4gICAgICB2YXIgY29sb3JCdWZmZXIgPSBudWxsXG4gICAgICB2YXIgY29sb3JUZXh0dXJlID0gdHJ1ZVxuICAgICAgdmFyIGNvbG9yRm9ybWF0ID0gJ3JnYmEnXG4gICAgICB2YXIgY29sb3JUeXBlID0gJ3VpbnQ4J1xuICAgICAgdmFyIGNvbG9yQ291bnQgPSAxXG5cbiAgICAgIHZhciBkZXB0aEJ1ZmZlciA9IG51bGxcbiAgICAgIHZhciBzdGVuY2lsQnVmZmVyID0gbnVsbFxuICAgICAgdmFyIGRlcHRoU3RlbmNpbEJ1ZmZlciA9IG51bGxcbiAgICAgIHZhciBkZXB0aFN0ZW5jaWxUZXh0dXJlID0gZmFsc2VcblxuICAgICAgaWYgKHR5cGVvZiBhID09PSAnbnVtYmVyJykge1xuICAgICAgICB3aWR0aCA9IGEgfCAwXG4gICAgICAgIGhlaWdodCA9IChiIHwgMCkgfHwgd2lkdGhcbiAgICAgIH0gZWxzZSBpZiAoIWEpIHtcbiAgICAgICAgd2lkdGggPSBoZWlnaHQgPSAxXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjaGVjayQxLnR5cGUoYSwgJ29iamVjdCcsICdpbnZhbGlkIGFyZ3VtZW50cyBmb3IgZnJhbWVidWZmZXInKVxuICAgICAgICB2YXIgb3B0aW9ucyA9IGFcblxuICAgICAgICBpZiAoJ3NoYXBlJyBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgdmFyIHNoYXBlID0gb3B0aW9ucy5zaGFwZVxuICAgICAgICAgIGNoZWNrJDEoQXJyYXkuaXNBcnJheShzaGFwZSkgJiYgc2hhcGUubGVuZ3RoID49IDIsXG4gICAgICAgICAgICAnaW52YWxpZCBzaGFwZSBmb3IgZnJhbWVidWZmZXInKVxuICAgICAgICAgIHdpZHRoID0gc2hhcGVbMF1cbiAgICAgICAgICBoZWlnaHQgPSBzaGFwZVsxXVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICgncmFkaXVzJyBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgICB3aWR0aCA9IGhlaWdodCA9IG9wdGlvbnMucmFkaXVzXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICgnd2lkdGgnIGluIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHdpZHRoID0gb3B0aW9ucy53aWR0aFxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoJ2hlaWdodCcgaW4gb3B0aW9ucykge1xuICAgICAgICAgICAgaGVpZ2h0ID0gb3B0aW9ucy5oZWlnaHRcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoJ2NvbG9yJyBpbiBvcHRpb25zIHx8XG4gICAgICAgICAgICAnY29sb3JzJyBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgY29sb3JCdWZmZXIgPVxuICAgICAgICAgICAgb3B0aW9ucy5jb2xvciB8fFxuICAgICAgICAgICAgb3B0aW9ucy5jb2xvcnNcbiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShjb2xvckJ1ZmZlcikpIHtcbiAgICAgICAgICAgIGNoZWNrJDEoXG4gICAgICAgICAgICAgIGNvbG9yQnVmZmVyLmxlbmd0aCA9PT0gMSB8fCBleHRlbnNpb25zLndlYmdsX2RyYXdfYnVmZmVycyxcbiAgICAgICAgICAgICAgJ211bHRpcGxlIHJlbmRlciB0YXJnZXRzIG5vdCBzdXBwb3J0ZWQnKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghY29sb3JCdWZmZXIpIHtcbiAgICAgICAgICBpZiAoJ2NvbG9yQ291bnQnIGluIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbG9yQ291bnQgPSBvcHRpb25zLmNvbG9yQ291bnQgfCAwXG4gICAgICAgICAgICBjaGVjayQxKGNvbG9yQ291bnQgPiAwLCAnaW52YWxpZCBjb2xvciBidWZmZXIgY291bnQnKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICgnY29sb3JUZXh0dXJlJyBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgICBjb2xvclRleHR1cmUgPSAhIW9wdGlvbnMuY29sb3JUZXh0dXJlXG4gICAgICAgICAgICBjb2xvckZvcm1hdCA9ICdyZ2JhNCdcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoJ2NvbG9yVHlwZScgaW4gb3B0aW9ucykge1xuICAgICAgICAgICAgY29sb3JUeXBlID0gb3B0aW9ucy5jb2xvclR5cGVcbiAgICAgICAgICAgIGlmICghY29sb3JUZXh0dXJlKSB7XG4gICAgICAgICAgICAgIGlmIChjb2xvclR5cGUgPT09ICdoYWxmIGZsb2F0JyB8fCBjb2xvclR5cGUgPT09ICdmbG9hdDE2Jykge1xuICAgICAgICAgICAgICAgIGNoZWNrJDEoZXh0ZW5zaW9ucy5leHRfY29sb3JfYnVmZmVyX2hhbGZfZmxvYXQsXG4gICAgICAgICAgICAgICAgICAneW91IG11c3QgZW5hYmxlIEVYVF9jb2xvcl9idWZmZXJfaGFsZl9mbG9hdCB0byB1c2UgMTYtYml0IHJlbmRlciBidWZmZXJzJylcbiAgICAgICAgICAgICAgICBjb2xvckZvcm1hdCA9ICdyZ2JhMTZmJ1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNvbG9yVHlwZSA9PT0gJ2Zsb2F0JyB8fCBjb2xvclR5cGUgPT09ICdmbG9hdDMyJykge1xuICAgICAgICAgICAgICAgIGNoZWNrJDEoZXh0ZW5zaW9ucy53ZWJnbF9jb2xvcl9idWZmZXJfZmxvYXQsXG4gICAgICAgICAgICAgICAgICAneW91IG11c3QgZW5hYmxlIFdFQkdMX2NvbG9yX2J1ZmZlcl9mbG9hdCBpbiBvcmRlciB0byB1c2UgMzItYml0IGZsb2F0aW5nIHBvaW50IHJlbmRlcmJ1ZmZlcnMnKVxuICAgICAgICAgICAgICAgIGNvbG9yRm9ybWF0ID0gJ3JnYmEzMmYnXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNoZWNrJDEoZXh0ZW5zaW9ucy5vZXNfdGV4dHVyZV9mbG9hdCB8fFxuICAgICAgICAgICAgICAgICEoY29sb3JUeXBlID09PSAnZmxvYXQnIHx8IGNvbG9yVHlwZSA9PT0gJ2Zsb2F0MzInKSxcbiAgICAgICAgICAgICAgJ3lvdSBtdXN0IGVuYWJsZSBPRVNfdGV4dHVyZV9mbG9hdCBpbiBvcmRlciB0byB1c2UgZmxvYXRpbmcgcG9pbnQgZnJhbWVidWZmZXIgb2JqZWN0cycpXG4gICAgICAgICAgICAgIGNoZWNrJDEoZXh0ZW5zaW9ucy5vZXNfdGV4dHVyZV9oYWxmX2Zsb2F0IHx8XG4gICAgICAgICAgICAgICAgIShjb2xvclR5cGUgPT09ICdoYWxmIGZsb2F0JyB8fCBjb2xvclR5cGUgPT09ICdmbG9hdDE2JyksXG4gICAgICAgICAgICAgICd5b3UgbXVzdCBlbmFibGUgT0VTX3RleHR1cmVfaGFsZl9mbG9hdCBpbiBvcmRlciB0byB1c2UgMTYtYml0IGZsb2F0aW5nIHBvaW50IGZyYW1lYnVmZmVyIG9iamVjdHMnKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2hlY2skMS5vbmVPZihjb2xvclR5cGUsIGNvbG9yVHlwZXMsICdpbnZhbGlkIGNvbG9yIHR5cGUnKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICgnY29sb3JGb3JtYXQnIGluIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbG9yRm9ybWF0ID0gb3B0aW9ucy5jb2xvckZvcm1hdFxuICAgICAgICAgICAgaWYgKGNvbG9yVGV4dHVyZUZvcm1hdHMuaW5kZXhPZihjb2xvckZvcm1hdCkgPj0gMCkge1xuICAgICAgICAgICAgICBjb2xvclRleHR1cmUgPSB0cnVlXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNvbG9yUmVuZGVyYnVmZmVyRm9ybWF0cy5pbmRleE9mKGNvbG9yRm9ybWF0KSA+PSAwKSB7XG4gICAgICAgICAgICAgIGNvbG9yVGV4dHVyZSA9IGZhbHNlXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAoY29sb3JUZXh0dXJlKSB7XG4gICAgICAgICAgICAgICAgY2hlY2skMS5vbmVPZihcbiAgICAgICAgICAgICAgICAgIG9wdGlvbnMuY29sb3JGb3JtYXQsIGNvbG9yVGV4dHVyZUZvcm1hdHMsXG4gICAgICAgICAgICAgICAgICAnaW52YWxpZCBjb2xvciBmb3JtYXQgZm9yIHRleHR1cmUnKVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNoZWNrJDEub25lT2YoXG4gICAgICAgICAgICAgICAgICBvcHRpb25zLmNvbG9yRm9ybWF0LCBjb2xvclJlbmRlcmJ1ZmZlckZvcm1hdHMsXG4gICAgICAgICAgICAgICAgICAnaW52YWxpZCBjb2xvciBmb3JtYXQgZm9yIHJlbmRlcmJ1ZmZlcicpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoJ2RlcHRoVGV4dHVyZScgaW4gb3B0aW9ucyB8fCAnZGVwdGhTdGVuY2lsVGV4dHVyZScgaW4gb3B0aW9ucykge1xuICAgICAgICAgIGRlcHRoU3RlbmNpbFRleHR1cmUgPSAhIShvcHRpb25zLmRlcHRoVGV4dHVyZSB8fFxuICAgICAgICAgICAgb3B0aW9ucy5kZXB0aFN0ZW5jaWxUZXh0dXJlKVxuICAgICAgICAgIGNoZWNrJDEoIWRlcHRoU3RlbmNpbFRleHR1cmUgfHwgZXh0ZW5zaW9ucy53ZWJnbF9kZXB0aF90ZXh0dXJlLFxuICAgICAgICAgICAgJ3dlYmdsX2RlcHRoX3RleHR1cmUgZXh0ZW5zaW9uIG5vdCBzdXBwb3J0ZWQnKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCdkZXB0aCcgaW4gb3B0aW9ucykge1xuICAgICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5kZXB0aCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICBuZWVkc0RlcHRoID0gb3B0aW9ucy5kZXB0aFxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkZXB0aEJ1ZmZlciA9IG9wdGlvbnMuZGVwdGhcbiAgICAgICAgICAgIG5lZWRzU3RlbmNpbCA9IGZhbHNlXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCdzdGVuY2lsJyBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLnN0ZW5jaWwgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgbmVlZHNTdGVuY2lsID0gb3B0aW9ucy5zdGVuY2lsXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0ZW5jaWxCdWZmZXIgPSBvcHRpb25zLnN0ZW5jaWxcbiAgICAgICAgICAgIG5lZWRzRGVwdGggPSBmYWxzZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgnZGVwdGhTdGVuY2lsJyBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmRlcHRoU3RlbmNpbCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICBuZWVkc0RlcHRoID0gbmVlZHNTdGVuY2lsID0gb3B0aW9ucy5kZXB0aFN0ZW5jaWxcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGVwdGhTdGVuY2lsQnVmZmVyID0gb3B0aW9ucy5kZXB0aFN0ZW5jaWxcbiAgICAgICAgICAgIG5lZWRzRGVwdGggPSBmYWxzZVxuICAgICAgICAgICAgbmVlZHNTdGVuY2lsID0gZmFsc2VcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gcGFyc2UgYXR0YWNobWVudHNcbiAgICAgIHZhciBjb2xvckF0dGFjaG1lbnRzID0gbnVsbFxuICAgICAgdmFyIGRlcHRoQXR0YWNobWVudCA9IG51bGxcbiAgICAgIHZhciBzdGVuY2lsQXR0YWNobWVudCA9IG51bGxcbiAgICAgIHZhciBkZXB0aFN0ZW5jaWxBdHRhY2htZW50ID0gbnVsbFxuXG4gICAgICAvLyBTZXQgdXAgY29sb3IgYXR0YWNobWVudHNcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGNvbG9yQnVmZmVyKSkge1xuICAgICAgICBjb2xvckF0dGFjaG1lbnRzID0gY29sb3JCdWZmZXIubWFwKHBhcnNlQXR0YWNobWVudClcbiAgICAgIH0gZWxzZSBpZiAoY29sb3JCdWZmZXIpIHtcbiAgICAgICAgY29sb3JBdHRhY2htZW50cyA9IFtwYXJzZUF0dGFjaG1lbnQoY29sb3JCdWZmZXIpXVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29sb3JBdHRhY2htZW50cyA9IG5ldyBBcnJheShjb2xvckNvdW50KVxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY29sb3JDb3VudDsgKytpKSB7XG4gICAgICAgICAgY29sb3JBdHRhY2htZW50c1tpXSA9IGFsbG9jQXR0YWNobWVudChcbiAgICAgICAgICAgIHdpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0LFxuICAgICAgICAgICAgY29sb3JUZXh0dXJlLFxuICAgICAgICAgICAgY29sb3JGb3JtYXQsXG4gICAgICAgICAgICBjb2xvclR5cGUpXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY2hlY2skMShleHRlbnNpb25zLndlYmdsX2RyYXdfYnVmZmVycyB8fCBjb2xvckF0dGFjaG1lbnRzLmxlbmd0aCA8PSAxLFxuICAgICAgICAneW91IG11c3QgZW5hYmxlIHRoZSBXRUJHTF9kcmF3X2J1ZmZlcnMgZXh0ZW5zaW9uIGluIG9yZGVyIHRvIHVzZSBtdWx0aXBsZSBjb2xvciBidWZmZXJzLicpXG4gICAgICBjaGVjayQxKGNvbG9yQXR0YWNobWVudHMubGVuZ3RoIDw9IGxpbWl0cy5tYXhDb2xvckF0dGFjaG1lbnRzLFxuICAgICAgICAndG9vIG1hbnkgY29sb3IgYXR0YWNobWVudHMsIG5vdCBzdXBwb3J0ZWQnKVxuXG4gICAgICB3aWR0aCA9IHdpZHRoIHx8IGNvbG9yQXR0YWNobWVudHNbMF0ud2lkdGhcbiAgICAgIGhlaWdodCA9IGhlaWdodCB8fCBjb2xvckF0dGFjaG1lbnRzWzBdLmhlaWdodFxuXG4gICAgICBpZiAoZGVwdGhCdWZmZXIpIHtcbiAgICAgICAgZGVwdGhBdHRhY2htZW50ID0gcGFyc2VBdHRhY2htZW50KGRlcHRoQnVmZmVyKVxuICAgICAgfSBlbHNlIGlmIChuZWVkc0RlcHRoICYmICFuZWVkc1N0ZW5jaWwpIHtcbiAgICAgICAgZGVwdGhBdHRhY2htZW50ID0gYWxsb2NBdHRhY2htZW50KFxuICAgICAgICAgIHdpZHRoLFxuICAgICAgICAgIGhlaWdodCxcbiAgICAgICAgICBkZXB0aFN0ZW5jaWxUZXh0dXJlLFxuICAgICAgICAgICdkZXB0aCcsXG4gICAgICAgICAgJ3VpbnQzMicpXG4gICAgICB9XG5cbiAgICAgIGlmIChzdGVuY2lsQnVmZmVyKSB7XG4gICAgICAgIHN0ZW5jaWxBdHRhY2htZW50ID0gcGFyc2VBdHRhY2htZW50KHN0ZW5jaWxCdWZmZXIpXG4gICAgICB9IGVsc2UgaWYgKG5lZWRzU3RlbmNpbCAmJiAhbmVlZHNEZXB0aCkge1xuICAgICAgICBzdGVuY2lsQXR0YWNobWVudCA9IGFsbG9jQXR0YWNobWVudChcbiAgICAgICAgICB3aWR0aCxcbiAgICAgICAgICBoZWlnaHQsXG4gICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgJ3N0ZW5jaWwnLFxuICAgICAgICAgICd1aW50OCcpXG4gICAgICB9XG5cbiAgICAgIGlmIChkZXB0aFN0ZW5jaWxCdWZmZXIpIHtcbiAgICAgICAgZGVwdGhTdGVuY2lsQXR0YWNobWVudCA9IHBhcnNlQXR0YWNobWVudChkZXB0aFN0ZW5jaWxCdWZmZXIpXG4gICAgICB9IGVsc2UgaWYgKCFkZXB0aEJ1ZmZlciAmJiAhc3RlbmNpbEJ1ZmZlciAmJiBuZWVkc1N0ZW5jaWwgJiYgbmVlZHNEZXB0aCkge1xuICAgICAgICBkZXB0aFN0ZW5jaWxBdHRhY2htZW50ID0gYWxsb2NBdHRhY2htZW50KFxuICAgICAgICAgIHdpZHRoLFxuICAgICAgICAgIGhlaWdodCxcbiAgICAgICAgICBkZXB0aFN0ZW5jaWxUZXh0dXJlLFxuICAgICAgICAgICdkZXB0aCBzdGVuY2lsJyxcbiAgICAgICAgICAnZGVwdGggc3RlbmNpbCcpXG4gICAgICB9XG5cbiAgICAgIGNoZWNrJDEoXG4gICAgICAgICghIWRlcHRoQnVmZmVyKSArICghIXN0ZW5jaWxCdWZmZXIpICsgKCEhZGVwdGhTdGVuY2lsQnVmZmVyKSA8PSAxLFxuICAgICAgICAnaW52YWxpZCBmcmFtZWJ1ZmZlciBjb25maWd1cmF0aW9uLCBjYW4gc3BlY2lmeSBleGFjdGx5IG9uZSBkZXB0aC9zdGVuY2lsIGF0dGFjaG1lbnQnKVxuXG4gICAgICB2YXIgY29tbW9uQ29sb3JBdHRhY2htZW50U2l6ZSA9IG51bGxcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGNvbG9yQXR0YWNobWVudHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaW5jUmVmQW5kQ2hlY2tTaGFwZShjb2xvckF0dGFjaG1lbnRzW2ldLCB3aWR0aCwgaGVpZ2h0KVxuICAgICAgICBjaGVjayQxKCFjb2xvckF0dGFjaG1lbnRzW2ldIHx8XG4gICAgICAgICAgKGNvbG9yQXR0YWNobWVudHNbaV0udGV4dHVyZSAmJlxuICAgICAgICAgICAgY29sb3JUZXh0dXJlRm9ybWF0RW51bXMuaW5kZXhPZihjb2xvckF0dGFjaG1lbnRzW2ldLnRleHR1cmUuX3RleHR1cmUuZm9ybWF0KSA+PSAwKSB8fFxuICAgICAgICAgIChjb2xvckF0dGFjaG1lbnRzW2ldLnJlbmRlcmJ1ZmZlciAmJlxuICAgICAgICAgICAgY29sb3JSZW5kZXJidWZmZXJGb3JtYXRFbnVtcy5pbmRleE9mKGNvbG9yQXR0YWNobWVudHNbaV0ucmVuZGVyYnVmZmVyLl9yZW5kZXJidWZmZXIuZm9ybWF0KSA+PSAwKSxcbiAgICAgICAgJ2ZyYW1lYnVmZmVyIGNvbG9yIGF0dGFjaG1lbnQgJyArIGkgKyAnIGlzIGludmFsaWQnKVxuXG4gICAgICAgIGlmIChjb2xvckF0dGFjaG1lbnRzW2ldICYmIGNvbG9yQXR0YWNobWVudHNbaV0udGV4dHVyZSkge1xuICAgICAgICAgIHZhciBjb2xvckF0dGFjaG1lbnRTaXplID1cbiAgICAgICAgICAgICAgdGV4dHVyZUZvcm1hdENoYW5uZWxzW2NvbG9yQXR0YWNobWVudHNbaV0udGV4dHVyZS5fdGV4dHVyZS5mb3JtYXRdICpcbiAgICAgICAgICAgICAgdGV4dHVyZVR5cGVTaXplc1tjb2xvckF0dGFjaG1lbnRzW2ldLnRleHR1cmUuX3RleHR1cmUudHlwZV1cblxuICAgICAgICAgIGlmIChjb21tb25Db2xvckF0dGFjaG1lbnRTaXplID09PSBudWxsKSB7XG4gICAgICAgICAgICBjb21tb25Db2xvckF0dGFjaG1lbnRTaXplID0gY29sb3JBdHRhY2htZW50U2l6ZVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBXZSBuZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IGFsbCBjb2xvciBhdHRhY2htZW50cyBoYXZlIHRoZSBzYW1lIG51bWJlciBvZiBiaXRwbGFuZXNcbiAgICAgICAgICAgIC8vICh0aGF0IGlzLCB0aGUgc2FtZSBudW1lciBvZiBiaXRzIHBlciBwaXhlbClcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgcmVxdWlyZWQgYnkgdGhlIEdMRVMyLjAgc3RhbmRhcmQuIFNlZSB0aGUgYmVnaW5uaW5nIG9mIENoYXB0ZXIgNCBpbiB0aGF0IGRvY3VtZW50LlxuICAgICAgICAgICAgY2hlY2skMShjb21tb25Db2xvckF0dGFjaG1lbnRTaXplID09PSBjb2xvckF0dGFjaG1lbnRTaXplLFxuICAgICAgICAgICAgICAnYWxsIGNvbG9yIGF0dGFjaG1lbnRzIG11Y2ggaGF2ZSB0aGUgc2FtZSBudW1iZXIgb2YgYml0cyBwZXIgcGl4ZWwuJylcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGluY1JlZkFuZENoZWNrU2hhcGUoZGVwdGhBdHRhY2htZW50LCB3aWR0aCwgaGVpZ2h0KVxuICAgICAgY2hlY2skMSghZGVwdGhBdHRhY2htZW50IHx8XG4gICAgICAgIChkZXB0aEF0dGFjaG1lbnQudGV4dHVyZSAmJlxuICAgICAgICAgIGRlcHRoQXR0YWNobWVudC50ZXh0dXJlLl90ZXh0dXJlLmZvcm1hdCA9PT0gR0xfREVQVEhfQ09NUE9ORU5UJDEpIHx8XG4gICAgICAgIChkZXB0aEF0dGFjaG1lbnQucmVuZGVyYnVmZmVyICYmXG4gICAgICAgICAgZGVwdGhBdHRhY2htZW50LnJlbmRlcmJ1ZmZlci5fcmVuZGVyYnVmZmVyLmZvcm1hdCA9PT0gR0xfREVQVEhfQ09NUE9ORU5UMTYkMSksXG4gICAgICAnaW52YWxpZCBkZXB0aCBhdHRhY2htZW50IGZvciBmcmFtZWJ1ZmZlciBvYmplY3QnKVxuICAgICAgaW5jUmVmQW5kQ2hlY2tTaGFwZShzdGVuY2lsQXR0YWNobWVudCwgd2lkdGgsIGhlaWdodClcbiAgICAgIGNoZWNrJDEoIXN0ZW5jaWxBdHRhY2htZW50IHx8XG4gICAgICAgIChzdGVuY2lsQXR0YWNobWVudC5yZW5kZXJidWZmZXIgJiZcbiAgICAgICAgICBzdGVuY2lsQXR0YWNobWVudC5yZW5kZXJidWZmZXIuX3JlbmRlcmJ1ZmZlci5mb3JtYXQgPT09IEdMX1NURU5DSUxfSU5ERVg4JDEpLFxuICAgICAgJ2ludmFsaWQgc3RlbmNpbCBhdHRhY2htZW50IGZvciBmcmFtZWJ1ZmZlciBvYmplY3QnKVxuICAgICAgaW5jUmVmQW5kQ2hlY2tTaGFwZShkZXB0aFN0ZW5jaWxBdHRhY2htZW50LCB3aWR0aCwgaGVpZ2h0KVxuICAgICAgY2hlY2skMSghZGVwdGhTdGVuY2lsQXR0YWNobWVudCB8fFxuICAgICAgICAoZGVwdGhTdGVuY2lsQXR0YWNobWVudC50ZXh0dXJlICYmXG4gICAgICAgICAgZGVwdGhTdGVuY2lsQXR0YWNobWVudC50ZXh0dXJlLl90ZXh0dXJlLmZvcm1hdCA9PT0gR0xfREVQVEhfU1RFTkNJTCQyKSB8fFxuICAgICAgICAoZGVwdGhTdGVuY2lsQXR0YWNobWVudC5yZW5kZXJidWZmZXIgJiZcbiAgICAgICAgICBkZXB0aFN0ZW5jaWxBdHRhY2htZW50LnJlbmRlcmJ1ZmZlci5fcmVuZGVyYnVmZmVyLmZvcm1hdCA9PT0gR0xfREVQVEhfU1RFTkNJTCQyKSxcbiAgICAgICdpbnZhbGlkIGRlcHRoLXN0ZW5jaWwgYXR0YWNobWVudCBmb3IgZnJhbWVidWZmZXIgb2JqZWN0JylcblxuICAgICAgLy8gZGVjcmVtZW50IHJlZmVyZW5jZXNcbiAgICAgIGRlY0ZCT1JlZnMoZnJhbWVidWZmZXIpXG5cbiAgICAgIGZyYW1lYnVmZmVyLndpZHRoID0gd2lkdGhcbiAgICAgIGZyYW1lYnVmZmVyLmhlaWdodCA9IGhlaWdodFxuXG4gICAgICBmcmFtZWJ1ZmZlci5jb2xvckF0dGFjaG1lbnRzID0gY29sb3JBdHRhY2htZW50c1xuICAgICAgZnJhbWVidWZmZXIuZGVwdGhBdHRhY2htZW50ID0gZGVwdGhBdHRhY2htZW50XG4gICAgICBmcmFtZWJ1ZmZlci5zdGVuY2lsQXR0YWNobWVudCA9IHN0ZW5jaWxBdHRhY2htZW50XG4gICAgICBmcmFtZWJ1ZmZlci5kZXB0aFN0ZW5jaWxBdHRhY2htZW50ID0gZGVwdGhTdGVuY2lsQXR0YWNobWVudFxuXG4gICAgICByZWdsRnJhbWVidWZmZXIuY29sb3IgPSBjb2xvckF0dGFjaG1lbnRzLm1hcCh1bndyYXBBdHRhY2htZW50KVxuICAgICAgcmVnbEZyYW1lYnVmZmVyLmRlcHRoID0gdW53cmFwQXR0YWNobWVudChkZXB0aEF0dGFjaG1lbnQpXG4gICAgICByZWdsRnJhbWVidWZmZXIuc3RlbmNpbCA9IHVud3JhcEF0dGFjaG1lbnQoc3RlbmNpbEF0dGFjaG1lbnQpXG4gICAgICByZWdsRnJhbWVidWZmZXIuZGVwdGhTdGVuY2lsID0gdW53cmFwQXR0YWNobWVudChkZXB0aFN0ZW5jaWxBdHRhY2htZW50KVxuXG4gICAgICByZWdsRnJhbWVidWZmZXIud2lkdGggPSBmcmFtZWJ1ZmZlci53aWR0aFxuICAgICAgcmVnbEZyYW1lYnVmZmVyLmhlaWdodCA9IGZyYW1lYnVmZmVyLmhlaWdodFxuXG4gICAgICB1cGRhdGVGcmFtZWJ1ZmZlcihmcmFtZWJ1ZmZlcilcblxuICAgICAgcmV0dXJuIHJlZ2xGcmFtZWJ1ZmZlclxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlc2l6ZSAod18sIGhfKSB7XG4gICAgICBjaGVjayQxKGZyYW1lYnVmZmVyU3RhdGUubmV4dCAhPT0gZnJhbWVidWZmZXIsXG4gICAgICAgICdjYW4gbm90IHJlc2l6ZSBhIGZyYW1lYnVmZmVyIHdoaWNoIGlzIGN1cnJlbnRseSBpbiB1c2UnKVxuXG4gICAgICB2YXIgdyA9IE1hdGgubWF4KHdfIHwgMCwgMSlcbiAgICAgIHZhciBoID0gTWF0aC5tYXgoKGhfIHwgMCkgfHwgdywgMSlcbiAgICAgIGlmICh3ID09PSBmcmFtZWJ1ZmZlci53aWR0aCAmJiBoID09PSBmcmFtZWJ1ZmZlci5oZWlnaHQpIHtcbiAgICAgICAgcmV0dXJuIHJlZ2xGcmFtZWJ1ZmZlclxuICAgICAgfVxuXG4gICAgICAvLyByZXNpemUgYWxsIGJ1ZmZlcnNcbiAgICAgIHZhciBjb2xvckF0dGFjaG1lbnRzID0gZnJhbWVidWZmZXIuY29sb3JBdHRhY2htZW50c1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb2xvckF0dGFjaG1lbnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHJlc2l6ZUF0dGFjaG1lbnQoY29sb3JBdHRhY2htZW50c1tpXSwgdywgaClcbiAgICAgIH1cbiAgICAgIHJlc2l6ZUF0dGFjaG1lbnQoZnJhbWVidWZmZXIuZGVwdGhBdHRhY2htZW50LCB3LCBoKVxuICAgICAgcmVzaXplQXR0YWNobWVudChmcmFtZWJ1ZmZlci5zdGVuY2lsQXR0YWNobWVudCwgdywgaClcbiAgICAgIHJlc2l6ZUF0dGFjaG1lbnQoZnJhbWVidWZmZXIuZGVwdGhTdGVuY2lsQXR0YWNobWVudCwgdywgaClcblxuICAgICAgZnJhbWVidWZmZXIud2lkdGggPSByZWdsRnJhbWVidWZmZXIud2lkdGggPSB3XG4gICAgICBmcmFtZWJ1ZmZlci5oZWlnaHQgPSByZWdsRnJhbWVidWZmZXIuaGVpZ2h0ID0gaFxuXG4gICAgICB1cGRhdGVGcmFtZWJ1ZmZlcihmcmFtZWJ1ZmZlcilcblxuICAgICAgcmV0dXJuIHJlZ2xGcmFtZWJ1ZmZlclxuICAgIH1cblxuICAgIHJlZ2xGcmFtZWJ1ZmZlcihhMCwgYTEpXG5cbiAgICByZXR1cm4gZXh0ZW5kKHJlZ2xGcmFtZWJ1ZmZlciwge1xuICAgICAgcmVzaXplOiByZXNpemUsXG4gICAgICBfcmVnbFR5cGU6ICdmcmFtZWJ1ZmZlcicsXG4gICAgICBfZnJhbWVidWZmZXI6IGZyYW1lYnVmZmVyLFxuICAgICAgZGVzdHJveTogZnVuY3Rpb24gKCkge1xuICAgICAgICBkZXN0cm95KGZyYW1lYnVmZmVyKVxuICAgICAgICBkZWNGQk9SZWZzKGZyYW1lYnVmZmVyKVxuICAgICAgfSxcbiAgICAgIHVzZTogZnVuY3Rpb24gKGJsb2NrKSB7XG4gICAgICAgIGZyYW1lYnVmZmVyU3RhdGUuc2V0RkJPKHtcbiAgICAgICAgICBmcmFtZWJ1ZmZlcjogcmVnbEZyYW1lYnVmZmVyXG4gICAgICAgIH0sIGJsb2NrKVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVDdWJlRkJPIChvcHRpb25zKSB7XG4gICAgdmFyIGZhY2VzID0gQXJyYXkoNilcblxuICAgIGZ1bmN0aW9uIHJlZ2xGcmFtZWJ1ZmZlckN1YmUgKGEpIHtcbiAgICAgIHZhciBpXG5cbiAgICAgIGNoZWNrJDEoZmFjZXMuaW5kZXhPZihmcmFtZWJ1ZmZlclN0YXRlLm5leHQpIDwgMCxcbiAgICAgICAgJ2NhbiBub3QgdXBkYXRlIGZyYW1lYnVmZmVyIHdoaWNoIGlzIGN1cnJlbnRseSBpbiB1c2UnKVxuXG4gICAgICB2YXIgcGFyYW1zID0ge1xuICAgICAgICBjb2xvcjogbnVsbFxuICAgICAgfVxuXG4gICAgICB2YXIgcmFkaXVzID0gMFxuXG4gICAgICB2YXIgY29sb3JCdWZmZXIgPSBudWxsXG4gICAgICB2YXIgY29sb3JGb3JtYXQgPSAncmdiYSdcbiAgICAgIHZhciBjb2xvclR5cGUgPSAndWludDgnXG4gICAgICB2YXIgY29sb3JDb3VudCA9IDFcblxuICAgICAgaWYgKHR5cGVvZiBhID09PSAnbnVtYmVyJykge1xuICAgICAgICByYWRpdXMgPSBhIHwgMFxuICAgICAgfSBlbHNlIGlmICghYSkge1xuICAgICAgICByYWRpdXMgPSAxXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjaGVjayQxLnR5cGUoYSwgJ29iamVjdCcsICdpbnZhbGlkIGFyZ3VtZW50cyBmb3IgZnJhbWVidWZmZXInKVxuICAgICAgICB2YXIgb3B0aW9ucyA9IGFcblxuICAgICAgICBpZiAoJ3NoYXBlJyBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgdmFyIHNoYXBlID0gb3B0aW9ucy5zaGFwZVxuICAgICAgICAgIGNoZWNrJDEoXG4gICAgICAgICAgICBBcnJheS5pc0FycmF5KHNoYXBlKSAmJiBzaGFwZS5sZW5ndGggPj0gMixcbiAgICAgICAgICAgICdpbnZhbGlkIHNoYXBlIGZvciBmcmFtZWJ1ZmZlcicpXG4gICAgICAgICAgY2hlY2skMShcbiAgICAgICAgICAgIHNoYXBlWzBdID09PSBzaGFwZVsxXSxcbiAgICAgICAgICAgICdjdWJlIGZyYW1lYnVmZmVyIG11c3QgYmUgc3F1YXJlJylcbiAgICAgICAgICByYWRpdXMgPSBzaGFwZVswXVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICgncmFkaXVzJyBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgICByYWRpdXMgPSBvcHRpb25zLnJhZGl1cyB8IDBcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCd3aWR0aCcgaW4gb3B0aW9ucykge1xuICAgICAgICAgICAgcmFkaXVzID0gb3B0aW9ucy53aWR0aCB8IDBcbiAgICAgICAgICAgIGlmICgnaGVpZ2h0JyBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgICAgIGNoZWNrJDEob3B0aW9ucy5oZWlnaHQgPT09IHJhZGl1cywgJ211c3QgYmUgc3F1YXJlJylcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKCdoZWlnaHQnIGluIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJhZGl1cyA9IG9wdGlvbnMuaGVpZ2h0IHwgMFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgnY29sb3InIGluIG9wdGlvbnMgfHxcbiAgICAgICAgICAgICdjb2xvcnMnIGluIG9wdGlvbnMpIHtcbiAgICAgICAgICBjb2xvckJ1ZmZlciA9XG4gICAgICAgICAgICBvcHRpb25zLmNvbG9yIHx8XG4gICAgICAgICAgICBvcHRpb25zLmNvbG9yc1xuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGNvbG9yQnVmZmVyKSkge1xuICAgICAgICAgICAgY2hlY2skMShcbiAgICAgICAgICAgICAgY29sb3JCdWZmZXIubGVuZ3RoID09PSAxIHx8IGV4dGVuc2lvbnMud2ViZ2xfZHJhd19idWZmZXJzLFxuICAgICAgICAgICAgICAnbXVsdGlwbGUgcmVuZGVyIHRhcmdldHMgbm90IHN1cHBvcnRlZCcpXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFjb2xvckJ1ZmZlcikge1xuICAgICAgICAgIGlmICgnY29sb3JDb3VudCcgaW4gb3B0aW9ucykge1xuICAgICAgICAgICAgY29sb3JDb3VudCA9IG9wdGlvbnMuY29sb3JDb3VudCB8IDBcbiAgICAgICAgICAgIGNoZWNrJDEoY29sb3JDb3VudCA+IDAsICdpbnZhbGlkIGNvbG9yIGJ1ZmZlciBjb3VudCcpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCdjb2xvclR5cGUnIGluIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGNoZWNrJDEub25lT2YoXG4gICAgICAgICAgICAgIG9wdGlvbnMuY29sb3JUeXBlLCBjb2xvclR5cGVzLFxuICAgICAgICAgICAgICAnaW52YWxpZCBjb2xvciB0eXBlJylcbiAgICAgICAgICAgIGNvbG9yVHlwZSA9IG9wdGlvbnMuY29sb3JUeXBlXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCdjb2xvckZvcm1hdCcgaW4gb3B0aW9ucykge1xuICAgICAgICAgICAgY29sb3JGb3JtYXQgPSBvcHRpb25zLmNvbG9yRm9ybWF0XG4gICAgICAgICAgICBjaGVjayQxLm9uZU9mKFxuICAgICAgICAgICAgICBvcHRpb25zLmNvbG9yRm9ybWF0LCBjb2xvclRleHR1cmVGb3JtYXRzLFxuICAgICAgICAgICAgICAnaW52YWxpZCBjb2xvciBmb3JtYXQgZm9yIHRleHR1cmUnKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgnZGVwdGgnIGluIG9wdGlvbnMpIHtcbiAgICAgICAgICBwYXJhbXMuZGVwdGggPSBvcHRpb25zLmRlcHRoXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoJ3N0ZW5jaWwnIGluIG9wdGlvbnMpIHtcbiAgICAgICAgICBwYXJhbXMuc3RlbmNpbCA9IG9wdGlvbnMuc3RlbmNpbFxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCdkZXB0aFN0ZW5jaWwnIGluIG9wdGlvbnMpIHtcbiAgICAgICAgICBwYXJhbXMuZGVwdGhTdGVuY2lsID0gb3B0aW9ucy5kZXB0aFN0ZW5jaWxcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgY29sb3JDdWJlc1xuICAgICAgaWYgKGNvbG9yQnVmZmVyKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGNvbG9yQnVmZmVyKSkge1xuICAgICAgICAgIGNvbG9yQ3ViZXMgPSBbXVxuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb2xvckJ1ZmZlci5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgY29sb3JDdWJlc1tpXSA9IGNvbG9yQnVmZmVyW2ldXG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbG9yQ3ViZXMgPSBbIGNvbG9yQnVmZmVyIF1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29sb3JDdWJlcyA9IEFycmF5KGNvbG9yQ291bnQpXG4gICAgICAgIHZhciBjdWJlTWFwUGFyYW1zID0ge1xuICAgICAgICAgIHJhZGl1czogcmFkaXVzLFxuICAgICAgICAgIGZvcm1hdDogY29sb3JGb3JtYXQsXG4gICAgICAgICAgdHlwZTogY29sb3JUeXBlXG4gICAgICAgIH1cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGNvbG9yQ291bnQ7ICsraSkge1xuICAgICAgICAgIGNvbG9yQ3ViZXNbaV0gPSB0ZXh0dXJlU3RhdGUuY3JlYXRlQ3ViZShjdWJlTWFwUGFyYW1zKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIENoZWNrIGNvbG9yIGN1YmVzXG4gICAgICBwYXJhbXMuY29sb3IgPSBBcnJheShjb2xvckN1YmVzLmxlbmd0aClcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBjb2xvckN1YmVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBjdWJlID0gY29sb3JDdWJlc1tpXVxuICAgICAgICBjaGVjayQxKFxuICAgICAgICAgIHR5cGVvZiBjdWJlID09PSAnZnVuY3Rpb24nICYmIGN1YmUuX3JlZ2xUeXBlID09PSAndGV4dHVyZUN1YmUnLFxuICAgICAgICAgICdpbnZhbGlkIGN1YmUgbWFwJylcbiAgICAgICAgcmFkaXVzID0gcmFkaXVzIHx8IGN1YmUud2lkdGhcbiAgICAgICAgY2hlY2skMShcbiAgICAgICAgICBjdWJlLndpZHRoID09PSByYWRpdXMgJiYgY3ViZS5oZWlnaHQgPT09IHJhZGl1cyxcbiAgICAgICAgICAnaW52YWxpZCBjdWJlIG1hcCBzaGFwZScpXG4gICAgICAgIHBhcmFtcy5jb2xvcltpXSA9IHtcbiAgICAgICAgICB0YXJnZXQ6IEdMX1RFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCQyLFxuICAgICAgICAgIGRhdGE6IGNvbG9yQ3ViZXNbaV1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgNjsgKytpKSB7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgY29sb3JDdWJlcy5sZW5ndGg7ICsraikge1xuICAgICAgICAgIHBhcmFtcy5jb2xvcltqXS50YXJnZXQgPSBHTF9URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1gkMiArIGlcbiAgICAgICAgfVxuICAgICAgICAvLyByZXVzZSBkZXB0aC1zdGVuY2lsIGF0dGFjaG1lbnRzIGFjcm9zcyBhbGwgY3ViZSBtYXBzXG4gICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgIHBhcmFtcy5kZXB0aCA9IGZhY2VzWzBdLmRlcHRoXG4gICAgICAgICAgcGFyYW1zLnN0ZW5jaWwgPSBmYWNlc1swXS5zdGVuY2lsXG4gICAgICAgICAgcGFyYW1zLmRlcHRoU3RlbmNpbCA9IGZhY2VzWzBdLmRlcHRoU3RlbmNpbFxuICAgICAgICB9XG4gICAgICAgIGlmIChmYWNlc1tpXSkge1xuICAgICAgICAgIChmYWNlc1tpXSkocGFyYW1zKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZhY2VzW2ldID0gY3JlYXRlRkJPKHBhcmFtcylcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZXh0ZW5kKHJlZ2xGcmFtZWJ1ZmZlckN1YmUsIHtcbiAgICAgICAgd2lkdGg6IHJhZGl1cyxcbiAgICAgICAgaGVpZ2h0OiByYWRpdXMsXG4gICAgICAgIGNvbG9yOiBjb2xvckN1YmVzXG4gICAgICB9KVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlc2l6ZSAocmFkaXVzXykge1xuICAgICAgdmFyIGlcbiAgICAgIHZhciByYWRpdXMgPSByYWRpdXNfIHwgMFxuICAgICAgY2hlY2skMShyYWRpdXMgPiAwICYmIHJhZGl1cyA8PSBsaW1pdHMubWF4Q3ViZU1hcFNpemUsXG4gICAgICAgICdpbnZhbGlkIHJhZGl1cyBmb3IgY3ViZSBmYm8nKVxuXG4gICAgICBpZiAocmFkaXVzID09PSByZWdsRnJhbWVidWZmZXJDdWJlLndpZHRoKSB7XG4gICAgICAgIHJldHVybiByZWdsRnJhbWVidWZmZXJDdWJlXG4gICAgICB9XG5cbiAgICAgIHZhciBjb2xvcnMgPSByZWdsRnJhbWVidWZmZXJDdWJlLmNvbG9yXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgY29sb3JzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbG9yc1tpXS5yZXNpemUocmFkaXVzKVxuICAgICAgfVxuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgNjsgKytpKSB7XG4gICAgICAgIGZhY2VzW2ldLnJlc2l6ZShyYWRpdXMpXG4gICAgICB9XG5cbiAgICAgIHJlZ2xGcmFtZWJ1ZmZlckN1YmUud2lkdGggPSByZWdsRnJhbWVidWZmZXJDdWJlLmhlaWdodCA9IHJhZGl1c1xuXG4gICAgICByZXR1cm4gcmVnbEZyYW1lYnVmZmVyQ3ViZVxuICAgIH1cblxuICAgIHJlZ2xGcmFtZWJ1ZmZlckN1YmUob3B0aW9ucylcblxuICAgIHJldHVybiBleHRlbmQocmVnbEZyYW1lYnVmZmVyQ3ViZSwge1xuICAgICAgZmFjZXM6IGZhY2VzLFxuICAgICAgcmVzaXplOiByZXNpemUsXG4gICAgICBfcmVnbFR5cGU6ICdmcmFtZWJ1ZmZlckN1YmUnLFxuICAgICAgZGVzdHJveTogZnVuY3Rpb24gKCkge1xuICAgICAgICBmYWNlcy5mb3JFYWNoKGZ1bmN0aW9uIChmKSB7XG4gICAgICAgICAgZi5kZXN0cm95KClcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgZnVuY3Rpb24gcmVzdG9yZUZyYW1lYnVmZmVycyAoKSB7XG4gICAgZnJhbWVidWZmZXJTdGF0ZS5jdXIgPSBudWxsXG4gICAgZnJhbWVidWZmZXJTdGF0ZS5uZXh0ID0gbnVsbFxuICAgIGZyYW1lYnVmZmVyU3RhdGUuZGlydHkgPSB0cnVlXG4gICAgdmFsdWVzKGZyYW1lYnVmZmVyU2V0KS5mb3JFYWNoKGZ1bmN0aW9uIChmYikge1xuICAgICAgZmIuZnJhbWVidWZmZXIgPSBnbC5jcmVhdGVGcmFtZWJ1ZmZlcigpXG4gICAgICB1cGRhdGVGcmFtZWJ1ZmZlcihmYilcbiAgICB9KVxuICB9XG5cbiAgcmV0dXJuIGV4dGVuZChmcmFtZWJ1ZmZlclN0YXRlLCB7XG4gICAgZ2V0RnJhbWVidWZmZXI6IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICAgIGlmICh0eXBlb2Ygb2JqZWN0ID09PSAnZnVuY3Rpb24nICYmIG9iamVjdC5fcmVnbFR5cGUgPT09ICdmcmFtZWJ1ZmZlcicpIHtcbiAgICAgICAgdmFyIGZibyA9IG9iamVjdC5fZnJhbWVidWZmZXJcbiAgICAgICAgaWYgKGZibyBpbnN0YW5jZW9mIFJFR0xGcmFtZWJ1ZmZlcikge1xuICAgICAgICAgIHJldHVybiBmYm9cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGxcbiAgICB9LFxuICAgIGNyZWF0ZTogY3JlYXRlRkJPLFxuICAgIGNyZWF0ZUN1YmU6IGNyZWF0ZUN1YmVGQk8sXG4gICAgY2xlYXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhbHVlcyhmcmFtZWJ1ZmZlclNldCkuZm9yRWFjaChkZXN0cm95KVxuICAgIH0sXG4gICAgcmVzdG9yZTogcmVzdG9yZUZyYW1lYnVmZmVyc1xuICB9KVxufVxuXG52YXIgR0xfRkxPQVQkNiA9IDUxMjZcbnZhciBHTF9BUlJBWV9CVUZGRVIkMSA9IDM0OTYyXG5cbmZ1bmN0aW9uIEF0dHJpYnV0ZVJlY29yZCAoKSB7XG4gIHRoaXMuc3RhdGUgPSAwXG5cbiAgdGhpcy54ID0gMC4wXG4gIHRoaXMueSA9IDAuMFxuICB0aGlzLnogPSAwLjBcbiAgdGhpcy53ID0gMC4wXG5cbiAgdGhpcy5idWZmZXIgPSBudWxsXG4gIHRoaXMuc2l6ZSA9IDBcbiAgdGhpcy5ub3JtYWxpemVkID0gZmFsc2VcbiAgdGhpcy50eXBlID0gR0xfRkxPQVQkNlxuICB0aGlzLm9mZnNldCA9IDBcbiAgdGhpcy5zdHJpZGUgPSAwXG4gIHRoaXMuZGl2aXNvciA9IDBcbn1cblxuZnVuY3Rpb24gd3JhcEF0dHJpYnV0ZVN0YXRlIChcbiAgZ2wsXG4gIGV4dGVuc2lvbnMsXG4gIGxpbWl0cyxcbiAgc3RhdHMsXG4gIGJ1ZmZlclN0YXRlKSB7XG4gIHZhciBOVU1fQVRUUklCVVRFUyA9IGxpbWl0cy5tYXhBdHRyaWJ1dGVzXG4gIHZhciBhdHRyaWJ1dGVCaW5kaW5ncyA9IG5ldyBBcnJheShOVU1fQVRUUklCVVRFUylcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBOVU1fQVRUUklCVVRFUzsgKytpKSB7XG4gICAgYXR0cmlidXRlQmluZGluZ3NbaV0gPSBuZXcgQXR0cmlidXRlUmVjb3JkKClcbiAgfVxuICB2YXIgdmFvQ291bnQgPSAwXG4gIHZhciB2YW9TZXQgPSB7fVxuXG4gIHZhciBzdGF0ZSA9IHtcbiAgICBSZWNvcmQ6IEF0dHJpYnV0ZVJlY29yZCxcbiAgICBzY29wZToge30sXG4gICAgc3RhdGU6IGF0dHJpYnV0ZUJpbmRpbmdzLFxuICAgIGN1cnJlbnRWQU86IG51bGwsXG4gICAgdGFyZ2V0VkFPOiBudWxsLFxuICAgIHJlc3RvcmU6IGV4dFZBTygpID8gcmVzdG9yZVZBTyA6IGZ1bmN0aW9uICgpIHt9LFxuICAgIGNyZWF0ZVZBTzogY3JlYXRlVkFPLFxuICAgIGdldFZBTzogZ2V0VkFPLFxuICAgIGRlc3Ryb3lCdWZmZXI6IGRlc3Ryb3lCdWZmZXIsXG4gICAgc2V0VkFPOiBleHRWQU8oKSA/IHNldFZBT0VYVCA6IHNldFZBT0VtdWxhdGVkLFxuICAgIGNsZWFyOiBleHRWQU8oKSA/IGRlc3Ryb3lWQU9FWFQgOiBmdW5jdGlvbiAoKSB7fVxuICB9XG5cbiAgZnVuY3Rpb24gZGVzdHJveUJ1ZmZlciAoYnVmZmVyKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhdHRyaWJ1dGVCaW5kaW5ncy5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIHJlY29yZCA9IGF0dHJpYnV0ZUJpbmRpbmdzW2ldXG4gICAgICBpZiAocmVjb3JkLmJ1ZmZlciA9PT0gYnVmZmVyKSB7XG4gICAgICAgIGdsLmRpc2FibGVWZXJ0ZXhBdHRyaWJBcnJheShpKVxuICAgICAgICByZWNvcmQuYnVmZmVyID0gbnVsbFxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGV4dFZBTyAoKSB7XG4gICAgcmV0dXJuIGV4dGVuc2lvbnMub2VzX3ZlcnRleF9hcnJheV9vYmplY3RcbiAgfVxuXG4gIGZ1bmN0aW9uIGV4dEluc3RhbmNlZCAoKSB7XG4gICAgcmV0dXJuIGV4dGVuc2lvbnMuYW5nbGVfaW5zdGFuY2VkX2FycmF5c1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0VkFPICh2YW8pIHtcbiAgICBpZiAodHlwZW9mIHZhbyA9PT0gJ2Z1bmN0aW9uJyAmJiB2YW8uX3Zhbykge1xuICAgICAgcmV0dXJuIHZhby5fdmFvXG4gICAgfVxuICAgIHJldHVybiBudWxsXG4gIH1cblxuICBmdW5jdGlvbiBzZXRWQU9FWFQgKHZhbykge1xuICAgIGlmICh2YW8gPT09IHN0YXRlLmN1cnJlbnRWQU8pIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICB2YXIgZXh0ID0gZXh0VkFPKClcbiAgICBpZiAodmFvKSB7XG4gICAgICBleHQuYmluZFZlcnRleEFycmF5T0VTKHZhby52YW8pXG4gICAgfSBlbHNlIHtcbiAgICAgIGV4dC5iaW5kVmVydGV4QXJyYXlPRVMobnVsbClcbiAgICB9XG4gICAgc3RhdGUuY3VycmVudFZBTyA9IHZhb1xuICB9XG5cbiAgZnVuY3Rpb24gc2V0VkFPRW11bGF0ZWQgKHZhbykge1xuICAgIGlmICh2YW8gPT09IHN0YXRlLmN1cnJlbnRWQU8pIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBpZiAodmFvKSB7XG4gICAgICB2YW8uYmluZEF0dHJzKClcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGV4dGkgPSBleHRJbnN0YW5jZWQoKVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhdHRyaWJ1dGVCaW5kaW5ncy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgYmluZGluZyA9IGF0dHJpYnV0ZUJpbmRpbmdzW2ldXG4gICAgICAgIGlmIChiaW5kaW5nLmJ1ZmZlcikge1xuICAgICAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGkpXG4gICAgICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihpLCBiaW5kaW5nLnNpemUsIGJpbmRpbmcudHlwZSwgYmluZGluZy5ub3JtYWxpemVkLCBiaW5kaW5nLnN0cmlkZSwgYmluZGluZy5vZmZmc2V0KVxuICAgICAgICAgIGlmIChleHRpICYmIGJpbmRpbmcuZGl2aXNvcikge1xuICAgICAgICAgICAgZXh0aS52ZXJ0ZXhBdHRyaWJEaXZpc29yQU5HTEUoaSwgYmluZGluZy5kaXZpc29yKVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBnbC5kaXNhYmxlVmVydGV4QXR0cmliQXJyYXkoaSlcbiAgICAgICAgICBnbC52ZXJ0ZXhBdHRyaWI0ZihpLCBiaW5kaW5nLngsIGJpbmRpbmcueSwgYmluZGluZy56LCBiaW5kaW5nLncpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgc3RhdGUuY3VycmVudFZBTyA9IHZhb1xuICB9XG5cbiAgZnVuY3Rpb24gZGVzdHJveVZBT0VYVCAoKSB7XG4gICAgdmFsdWVzKHZhb1NldCkuZm9yRWFjaChmdW5jdGlvbiAodmFvKSB7XG4gICAgICB2YW8uZGVzdHJveSgpXG4gICAgfSlcbiAgfVxuXG4gIGZ1bmN0aW9uIFJFR0xWQU8gKCkge1xuICAgIHRoaXMuaWQgPSArK3Zhb0NvdW50XG4gICAgdGhpcy5hdHRyaWJ1dGVzID0gW11cbiAgICB2YXIgZXh0ZW5zaW9uID0gZXh0VkFPKClcbiAgICBpZiAoZXh0ZW5zaW9uKSB7XG4gICAgICB0aGlzLnZhbyA9IGV4dGVuc2lvbi5jcmVhdGVWZXJ0ZXhBcnJheU9FUygpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudmFvID0gbnVsbFxuICAgIH1cbiAgICB2YW9TZXRbdGhpcy5pZF0gPSB0aGlzXG4gICAgdGhpcy5idWZmZXJzID0gW11cbiAgfVxuXG4gIFJFR0xWQU8ucHJvdG90eXBlLmJpbmRBdHRycyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0aSA9IGV4dEluc3RhbmNlZCgpXG4gICAgdmFyIGF0dHJpYnV0ZXMgPSB0aGlzLmF0dHJpYnV0ZXNcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGF0dHJpYnV0ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciBhdHRyID0gYXR0cmlidXRlc1tpXVxuICAgICAgaWYgKGF0dHIuYnVmZmVyKSB7XG4gICAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGkpXG4gICAgICAgIGdsLmJpbmRCdWZmZXIoR0xfQVJSQVlfQlVGRkVSJDEsIGF0dHIuYnVmZmVyLmJ1ZmZlcilcbiAgICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihpLCBhdHRyLnNpemUsIGF0dHIudHlwZSwgYXR0ci5ub3JtYWxpemVkLCBhdHRyLnN0cmlkZSwgYXR0ci5vZmZzZXQpXG4gICAgICAgIGlmIChleHRpICYmIGF0dHIuZGl2aXNvcikge1xuICAgICAgICAgIGV4dGkudmVydGV4QXR0cmliRGl2aXNvckFOR0xFKGksIGF0dHIuZGl2aXNvcilcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZ2wuZGlzYWJsZVZlcnRleEF0dHJpYkFycmF5KGkpXG4gICAgICAgIGdsLnZlcnRleEF0dHJpYjRmKGksIGF0dHIueCwgYXR0ci55LCBhdHRyLnosIGF0dHIudylcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yICh2YXIgaiA9IGF0dHJpYnV0ZXMubGVuZ3RoOyBqIDwgTlVNX0FUVFJJQlVURVM7ICsraikge1xuICAgICAgZ2wuZGlzYWJsZVZlcnRleEF0dHJpYkFycmF5KGopXG4gICAgfVxuICB9XG5cbiAgUkVHTFZBTy5wcm90b3R5cGUucmVmcmVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ID0gZXh0VkFPKClcbiAgICBpZiAoZXh0KSB7XG4gICAgICBleHQuYmluZFZlcnRleEFycmF5T0VTKHRoaXMudmFvKVxuICAgICAgdGhpcy5iaW5kQXR0cnMoKVxuICAgICAgc3RhdGUuY3VycmVudFZBTyA9IHRoaXNcbiAgICB9XG4gIH1cblxuICBSRUdMVkFPLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLnZhbykge1xuICAgICAgdmFyIGV4dGVuc2lvbiA9IGV4dFZBTygpXG4gICAgICBpZiAodGhpcyA9PT0gc3RhdGUuY3VycmVudFZBTykge1xuICAgICAgICBzdGF0ZS5jdXJyZW50VkFPID0gbnVsbFxuICAgICAgICBleHRlbnNpb24uYmluZFZlcnRleEFycmF5T0VTKG51bGwpXG4gICAgICB9XG4gICAgICBleHRlbnNpb24uZGVsZXRlVmVydGV4QXJyYXlPRVModGhpcy52YW8pXG4gICAgICB0aGlzLnZhbyA9IG51bGxcbiAgICB9XG4gICAgaWYgKHZhb1NldFt0aGlzLmlkXSkge1xuICAgICAgZGVsZXRlIHZhb1NldFt0aGlzLmlkXVxuICAgICAgc3RhdHMudmFvQ291bnQgLT0gMVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc3RvcmVWQU8gKCkge1xuICAgIHZhciBleHQgPSBleHRWQU8oKVxuICAgIGlmIChleHQpIHtcbiAgICAgIHZhbHVlcyh2YW9TZXQpLmZvckVhY2goZnVuY3Rpb24gKHZhbykge1xuICAgICAgICB2YW8ucmVmcmVzaCgpXG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVZBTyAoX2F0dHIpIHtcbiAgICB2YXIgdmFvID0gbmV3IFJFR0xWQU8oKVxuICAgIHN0YXRzLnZhb0NvdW50ICs9IDFcblxuICAgIGZ1bmN0aW9uIHVwZGF0ZVZBTyAoYXR0cmlidXRlcykge1xuICAgICAgY2hlY2skMShBcnJheS5pc0FycmF5KGF0dHJpYnV0ZXMpLCAnYXJndW1lbnRzIHRvIHZlcnRleCBhcnJheSBjb25zdHJ1Y3RvciBtdXN0IGJlIGFuIGFycmF5JylcbiAgICAgIGNoZWNrJDEoYXR0cmlidXRlcy5sZW5ndGggPCBOVU1fQVRUUklCVVRFUywgJ3RvbyBtYW55IGF0dHJpYnV0ZXMnKVxuICAgICAgY2hlY2skMShhdHRyaWJ1dGVzLmxlbmd0aCA+IDAsICdtdXN0IHNwZWNpZnkgYXQgbGVhc3Qgb25lIGF0dHJpYnV0ZScpXG5cbiAgICAgIHZhciBidWZVcGRhdGVkID0ge31cbiAgICAgIHZhciBuYXR0cmlidXRlcyA9IHZhby5hdHRyaWJ1dGVzXG4gICAgICBuYXR0cmlidXRlcy5sZW5ndGggPSBhdHRyaWJ1dGVzLmxlbmd0aFxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhdHRyaWJ1dGVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBzcGVjID0gYXR0cmlidXRlc1tpXVxuICAgICAgICB2YXIgcmVjID0gbmF0dHJpYnV0ZXNbaV0gPSBuZXcgQXR0cmlidXRlUmVjb3JkKClcbiAgICAgICAgdmFyIGRhdGEgPSBzcGVjLmRhdGEgfHwgc3BlY1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSB8fCBpc1R5cGVkQXJyYXkoZGF0YSkgfHwgaXNOREFycmF5TGlrZShkYXRhKSkge1xuICAgICAgICAgIHZhciBidWZcbiAgICAgICAgICBpZiAodmFvLmJ1ZmZlcnNbaV0pIHtcbiAgICAgICAgICAgIGJ1ZiA9IHZhby5idWZmZXJzW2ldXG4gICAgICAgICAgICBpZiAoaXNUeXBlZEFycmF5KGRhdGEpICYmIGJ1Zi5fYnVmZmVyLmJ5dGVMZW5ndGggPj0gZGF0YS5ieXRlTGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGJ1Zi5zdWJkYXRhKGRhdGEpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBidWYuZGVzdHJveSgpXG4gICAgICAgICAgICAgIHZhby5idWZmZXJzW2ldID0gbnVsbFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXZhby5idWZmZXJzW2ldKSB7XG4gICAgICAgICAgICBidWYgPSB2YW8uYnVmZmVyc1tpXSA9IGJ1ZmZlclN0YXRlLmNyZWF0ZShzcGVjLCBHTF9BUlJBWV9CVUZGRVIkMSwgZmFsc2UsIHRydWUpXG4gICAgICAgICAgfVxuICAgICAgICAgIHJlYy5idWZmZXIgPSBidWZmZXJTdGF0ZS5nZXRCdWZmZXIoYnVmKVxuICAgICAgICAgIHJlYy5zaXplID0gcmVjLmJ1ZmZlci5kaW1lbnNpb24gfCAwXG4gICAgICAgICAgcmVjLm5vcm1hbGl6ZWQgPSBmYWxzZVxuICAgICAgICAgIHJlYy50eXBlID0gcmVjLmJ1ZmZlci5kdHlwZVxuICAgICAgICAgIHJlYy5vZmZzZXQgPSAwXG4gICAgICAgICAgcmVjLnN0cmlkZSA9IDBcbiAgICAgICAgICByZWMuZGl2aXNvciA9IDBcbiAgICAgICAgICByZWMuc3RhdGUgPSAxXG4gICAgICAgICAgYnVmVXBkYXRlZFtpXSA9IDFcbiAgICAgICAgfSBlbHNlIGlmIChidWZmZXJTdGF0ZS5nZXRCdWZmZXIoc3BlYykpIHtcbiAgICAgICAgICByZWMuYnVmZmVyID0gYnVmZmVyU3RhdGUuZ2V0QnVmZmVyKHNwZWMpXG4gICAgICAgICAgcmVjLnNpemUgPSByZWMuYnVmZmVyLmRpbWVuc2lvbiB8IDBcbiAgICAgICAgICByZWMubm9ybWFsaXplZCA9IGZhbHNlXG4gICAgICAgICAgcmVjLnR5cGUgPSByZWMuYnVmZmVyLmR0eXBlXG4gICAgICAgICAgcmVjLm9mZnNldCA9IDBcbiAgICAgICAgICByZWMuc3RyaWRlID0gMFxuICAgICAgICAgIHJlYy5kaXZpc29yID0gMFxuICAgICAgICAgIHJlYy5zdGF0ZSA9IDFcbiAgICAgICAgfSBlbHNlIGlmIChidWZmZXJTdGF0ZS5nZXRCdWZmZXIoc3BlYy5idWZmZXIpKSB7XG4gICAgICAgICAgcmVjLmJ1ZmZlciA9IGJ1ZmZlclN0YXRlLmdldEJ1ZmZlcihzcGVjLmJ1ZmZlcilcbiAgICAgICAgICByZWMuc2l6ZSA9ICgoK3NwZWMuc2l6ZSkgfHwgcmVjLmJ1ZmZlci5kaW1lbnNpb24pIHwgMFxuICAgICAgICAgIHJlYy5ub3JtYWxpemVkID0gISFzcGVjLm5vcm1hbGl6ZWQgfHwgZmFsc2VcbiAgICAgICAgICBpZiAoJ3R5cGUnIGluIHNwZWMpIHtcbiAgICAgICAgICAgIGNoZWNrJDEucGFyYW1ldGVyKHNwZWMudHlwZSwgZ2xUeXBlcywgJ2ludmFsaWQgYnVmZmVyIHR5cGUnKVxuICAgICAgICAgICAgcmVjLnR5cGUgPSBnbFR5cGVzW3NwZWMudHlwZV1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVjLnR5cGUgPSByZWMuYnVmZmVyLmR0eXBlXG4gICAgICAgICAgfVxuICAgICAgICAgIHJlYy5vZmZzZXQgPSAoc3BlYy5vZmZzZXQgfHwgMCkgfCAwXG4gICAgICAgICAgcmVjLnN0cmlkZSA9IChzcGVjLnN0cmlkZSB8fCAwKSB8IDBcbiAgICAgICAgICByZWMuZGl2aXNvciA9IChzcGVjLmRpdmlzb3IgfHwgMCkgfCAwXG4gICAgICAgICAgcmVjLnN0YXRlID0gMVxuXG4gICAgICAgICAgY2hlY2skMShyZWMuc2l6ZSA+PSAxICYmIHJlYy5zaXplIDw9IDQsICdzaXplIG11c3QgYmUgYmV0d2VlbiAxIGFuZCA0JylcbiAgICAgICAgICBjaGVjayQxKHJlYy5vZmZzZXQgPj0gMCwgJ2ludmFsaWQgb2Zmc2V0JylcbiAgICAgICAgICBjaGVjayQxKHJlYy5zdHJpZGUgPj0gMCAmJiByZWMuc3RyaWRlIDw9IDI1NSwgJ3N0cmlkZSBtdXN0IGJlIGJldHdlZW4gMCBhbmQgMjU1JylcbiAgICAgICAgICBjaGVjayQxKHJlYy5kaXZpc29yID49IDAsICdkaXZpc29yIG11c3QgYmUgcG9zaXRpdmUnKVxuICAgICAgICAgIGNoZWNrJDEoIXJlYy5kaXZpc29yIHx8ICEhZXh0ZW5zaW9ucy5hbmdsZV9pbnN0YW5jZWRfYXJyYXlzLCAnQU5HTEVfaW5zdGFuY2VkX2FycmF5cyBtdXN0IGJlIGVuYWJsZWQgdG8gdXNlIGRpdmlzb3InKVxuICAgICAgICB9IGVsc2UgaWYgKCd4JyBpbiBzcGVjKSB7XG4gICAgICAgICAgY2hlY2skMShpID4gMCwgJ2ZpcnN0IGF0dHJpYnV0ZSBtdXN0IG5vdCBiZSBhIGNvbnN0YW50JylcbiAgICAgICAgICByZWMueCA9ICtzcGVjLnggfHwgMFxuICAgICAgICAgIHJlYy55ID0gK3NwZWMueSB8fCAwXG4gICAgICAgICAgcmVjLnogPSArc3BlYy56IHx8IDBcbiAgICAgICAgICByZWMudyA9ICtzcGVjLncgfHwgMFxuICAgICAgICAgIHJlYy5zdGF0ZSA9IDJcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjaGVjayQxKGZhbHNlLCAnaW52YWxpZCBhdHRyaWJ1dGUgc3BlYyBmb3IgbG9jYXRpb24gJyArIGkpXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gcmV0aXJlIHVudXNlZCBidWZmZXJzXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHZhby5idWZmZXJzLmxlbmd0aDsgKytqKSB7XG4gICAgICAgIGlmICghYnVmVXBkYXRlZFtqXSAmJiB2YW8uYnVmZmVyc1tqXSkge1xuICAgICAgICAgIHZhby5idWZmZXJzW2pdLmRlc3Ryb3koKVxuICAgICAgICAgIHZhby5idWZmZXJzW2pdID0gbnVsbFxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhby5yZWZyZXNoKClcbiAgICAgIHJldHVybiB1cGRhdGVWQU9cbiAgICB9XG5cbiAgICB1cGRhdGVWQU8uZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdmFvLmJ1ZmZlcnMubGVuZ3RoOyArK2opIHtcbiAgICAgICAgaWYgKHZhby5idWZmZXJzW2pdKSB7XG4gICAgICAgICAgdmFvLmJ1ZmZlcnNbal0uZGVzdHJveSgpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhby5idWZmZXJzLmxlbmd0aCA9IDBcbiAgICAgIHZhby5kZXN0cm95KClcbiAgICB9XG5cbiAgICB1cGRhdGVWQU8uX3ZhbyA9IHZhb1xuICAgIHVwZGF0ZVZBTy5fcmVnbFR5cGUgPSAndmFvJ1xuXG4gICAgcmV0dXJuIHVwZGF0ZVZBTyhfYXR0cilcbiAgfVxuXG4gIHJldHVybiBzdGF0ZVxufVxuXG52YXIgR0xfRlJBR01FTlRfU0hBREVSID0gMzU2MzJcbnZhciBHTF9WRVJURVhfU0hBREVSID0gMzU2MzNcblxudmFyIEdMX0FDVElWRV9VTklGT1JNUyA9IDB4OEI4NlxudmFyIEdMX0FDVElWRV9BVFRSSUJVVEVTID0gMHg4Qjg5XG5cbmZ1bmN0aW9uIHdyYXBTaGFkZXJTdGF0ZSAoZ2wsIHN0cmluZ1N0b3JlLCBzdGF0cywgY29uZmlnKSB7XG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyBnbHNsIGNvbXBpbGF0aW9uIGFuZCBsaW5raW5nXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICB2YXIgZnJhZ1NoYWRlcnMgPSB7fVxuICB2YXIgdmVydFNoYWRlcnMgPSB7fVxuXG4gIGZ1bmN0aW9uIEFjdGl2ZUluZm8gKG5hbWUsIGlkLCBsb2NhdGlvbiwgaW5mbykge1xuICAgIHRoaXMubmFtZSA9IG5hbWVcbiAgICB0aGlzLmlkID0gaWRcbiAgICB0aGlzLmxvY2F0aW9uID0gbG9jYXRpb25cbiAgICB0aGlzLmluZm8gPSBpbmZvXG4gIH1cblxuICBmdW5jdGlvbiBpbnNlcnRBY3RpdmVJbmZvIChsaXN0LCBpbmZvKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgICBpZiAobGlzdFtpXS5pZCA9PT0gaW5mby5pZCkge1xuICAgICAgICBsaXN0W2ldLmxvY2F0aW9uID0gaW5mby5sb2NhdGlvblxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICB9XG4gICAgbGlzdC5wdXNoKGluZm8pXG4gIH1cblxuICBmdW5jdGlvbiBnZXRTaGFkZXIgKHR5cGUsIGlkLCBjb21tYW5kKSB7XG4gICAgdmFyIGNhY2hlID0gdHlwZSA9PT0gR0xfRlJBR01FTlRfU0hBREVSID8gZnJhZ1NoYWRlcnMgOiB2ZXJ0U2hhZGVyc1xuICAgIHZhciBzaGFkZXIgPSBjYWNoZVtpZF1cblxuICAgIGlmICghc2hhZGVyKSB7XG4gICAgICB2YXIgc291cmNlID0gc3RyaW5nU3RvcmUuc3RyKGlkKVxuICAgICAgc2hhZGVyID0gZ2wuY3JlYXRlU2hhZGVyKHR5cGUpXG4gICAgICBnbC5zaGFkZXJTb3VyY2Uoc2hhZGVyLCBzb3VyY2UpXG4gICAgICBnbC5jb21waWxlU2hhZGVyKHNoYWRlcilcbiAgICAgIGNoZWNrJDEuc2hhZGVyRXJyb3IoZ2wsIHNoYWRlciwgc291cmNlLCB0eXBlLCBjb21tYW5kKVxuICAgICAgY2FjaGVbaWRdID0gc2hhZGVyXG4gICAgfVxuXG4gICAgcmV0dXJuIHNoYWRlclxuICB9XG5cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vIHByb2dyYW0gbGlua2luZ1xuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgdmFyIHByb2dyYW1DYWNoZSA9IHt9XG4gIHZhciBwcm9ncmFtTGlzdCA9IFtdXG5cbiAgdmFyIFBST0dSQU1fQ09VTlRFUiA9IDBcblxuICBmdW5jdGlvbiBSRUdMUHJvZ3JhbSAoZnJhZ0lkLCB2ZXJ0SWQpIHtcbiAgICB0aGlzLmlkID0gUFJPR1JBTV9DT1VOVEVSKytcbiAgICB0aGlzLmZyYWdJZCA9IGZyYWdJZFxuICAgIHRoaXMudmVydElkID0gdmVydElkXG4gICAgdGhpcy5wcm9ncmFtID0gbnVsbFxuICAgIHRoaXMudW5pZm9ybXMgPSBbXVxuICAgIHRoaXMuYXR0cmlidXRlcyA9IFtdXG4gICAgdGhpcy5yZWZDb3VudCA9IDFcblxuICAgIGlmIChjb25maWcucHJvZmlsZSkge1xuICAgICAgdGhpcy5zdGF0cyA9IHtcbiAgICAgICAgdW5pZm9ybXNDb3VudDogMCxcbiAgICAgICAgYXR0cmlidXRlc0NvdW50OiAwXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbGlua1Byb2dyYW0gKGRlc2MsIGNvbW1hbmQsIGF0dHJpYnV0ZUxvY2F0aW9ucykge1xuICAgIHZhciBpLCBpbmZvXG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gY29tcGlsZSAmIGxpbmtcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgdmFyIGZyYWdTaGFkZXIgPSBnZXRTaGFkZXIoR0xfRlJBR01FTlRfU0hBREVSLCBkZXNjLmZyYWdJZClcbiAgICB2YXIgdmVydFNoYWRlciA9IGdldFNoYWRlcihHTF9WRVJURVhfU0hBREVSLCBkZXNjLnZlcnRJZClcblxuICAgIHZhciBwcm9ncmFtID0gZGVzYy5wcm9ncmFtID0gZ2wuY3JlYXRlUHJvZ3JhbSgpXG4gICAgZ2wuYXR0YWNoU2hhZGVyKHByb2dyYW0sIGZyYWdTaGFkZXIpXG4gICAgZ2wuYXR0YWNoU2hhZGVyKHByb2dyYW0sIHZlcnRTaGFkZXIpXG4gICAgaWYgKGF0dHJpYnV0ZUxvY2F0aW9ucykge1xuICAgICAgZm9yIChpID0gMDsgaSA8IGF0dHJpYnV0ZUxvY2F0aW9ucy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgYmluZGluZyA9IGF0dHJpYnV0ZUxvY2F0aW9uc1tpXVxuICAgICAgICBnbC5iaW5kQXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgYmluZGluZ1swXSwgYmluZGluZ1sxXSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICBnbC5saW5rUHJvZ3JhbShwcm9ncmFtKVxuICAgIGNoZWNrJDEubGlua0Vycm9yKFxuICAgICAgZ2wsXG4gICAgICBwcm9ncmFtLFxuICAgICAgc3RyaW5nU3RvcmUuc3RyKGRlc2MuZnJhZ0lkKSxcbiAgICAgIHN0cmluZ1N0b3JlLnN0cihkZXNjLnZlcnRJZCksXG4gICAgICBjb21tYW5kKVxuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIGdyYWIgdW5pZm9ybXNcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgdmFyIG51bVVuaWZvcm1zID0gZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlcihwcm9ncmFtLCBHTF9BQ1RJVkVfVU5JRk9STVMpXG4gICAgaWYgKGNvbmZpZy5wcm9maWxlKSB7XG4gICAgICBkZXNjLnN0YXRzLnVuaWZvcm1zQ291bnQgPSBudW1Vbmlmb3Jtc1xuICAgIH1cbiAgICB2YXIgdW5pZm9ybXMgPSBkZXNjLnVuaWZvcm1zXG4gICAgZm9yIChpID0gMDsgaSA8IG51bVVuaWZvcm1zOyArK2kpIHtcbiAgICAgIGluZm8gPSBnbC5nZXRBY3RpdmVVbmlmb3JtKHByb2dyYW0sIGkpXG4gICAgICBpZiAoaW5mbykge1xuICAgICAgICBpZiAoaW5mby5zaXplID4gMSkge1xuICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgaW5mby5zaXplOyArK2opIHtcbiAgICAgICAgICAgIHZhciBuYW1lID0gaW5mby5uYW1lLnJlcGxhY2UoJ1swXScsICdbJyArIGogKyAnXScpXG4gICAgICAgICAgICBpbnNlcnRBY3RpdmVJbmZvKHVuaWZvcm1zLCBuZXcgQWN0aXZlSW5mbyhcbiAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgc3RyaW5nU3RvcmUuaWQobmFtZSksXG4gICAgICAgICAgICAgIGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCBuYW1lKSxcbiAgICAgICAgICAgICAgaW5mbykpXG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGluc2VydEFjdGl2ZUluZm8odW5pZm9ybXMsIG5ldyBBY3RpdmVJbmZvKFxuICAgICAgICAgICAgaW5mby5uYW1lLFxuICAgICAgICAgICAgc3RyaW5nU3RvcmUuaWQoaW5mby5uYW1lKSxcbiAgICAgICAgICAgIGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCBpbmZvLm5hbWUpLFxuICAgICAgICAgICAgaW5mbykpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gZ3JhYiBhdHRyaWJ1dGVzXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIHZhciBudW1BdHRyaWJ1dGVzID0gZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlcihwcm9ncmFtLCBHTF9BQ1RJVkVfQVRUUklCVVRFUylcbiAgICBpZiAoY29uZmlnLnByb2ZpbGUpIHtcbiAgICAgIGRlc2Muc3RhdHMuYXR0cmlidXRlc0NvdW50ID0gbnVtQXR0cmlidXRlc1xuICAgIH1cblxuICAgIHZhciBhdHRyaWJ1dGVzID0gZGVzYy5hdHRyaWJ1dGVzXG4gICAgZm9yIChpID0gMDsgaSA8IG51bUF0dHJpYnV0ZXM7ICsraSkge1xuICAgICAgaW5mbyA9IGdsLmdldEFjdGl2ZUF0dHJpYihwcm9ncmFtLCBpKVxuICAgICAgaWYgKGluZm8pIHtcbiAgICAgICAgaW5zZXJ0QWN0aXZlSW5mbyhhdHRyaWJ1dGVzLCBuZXcgQWN0aXZlSW5mbyhcbiAgICAgICAgICBpbmZvLm5hbWUsXG4gICAgICAgICAgc3RyaW5nU3RvcmUuaWQoaW5mby5uYW1lKSxcbiAgICAgICAgICBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCBpbmZvLm5hbWUpLFxuICAgICAgICAgIGluZm8pKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChjb25maWcucHJvZmlsZSkge1xuICAgIHN0YXRzLmdldE1heFVuaWZvcm1zQ291bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgbSA9IDBcbiAgICAgIHByb2dyYW1MaXN0LmZvckVhY2goZnVuY3Rpb24gKGRlc2MpIHtcbiAgICAgICAgaWYgKGRlc2Muc3RhdHMudW5pZm9ybXNDb3VudCA+IG0pIHtcbiAgICAgICAgICBtID0gZGVzYy5zdGF0cy51bmlmb3Jtc0NvdW50XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICByZXR1cm4gbVxuICAgIH1cblxuICAgIHN0YXRzLmdldE1heEF0dHJpYnV0ZXNDb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBtID0gMFxuICAgICAgcHJvZ3JhbUxpc3QuZm9yRWFjaChmdW5jdGlvbiAoZGVzYykge1xuICAgICAgICBpZiAoZGVzYy5zdGF0cy5hdHRyaWJ1dGVzQ291bnQgPiBtKSB7XG4gICAgICAgICAgbSA9IGRlc2Muc3RhdHMuYXR0cmlidXRlc0NvdW50XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICByZXR1cm4gbVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc3RvcmVTaGFkZXJzICgpIHtcbiAgICBmcmFnU2hhZGVycyA9IHt9XG4gICAgdmVydFNoYWRlcnMgPSB7fVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvZ3JhbUxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICAgIGxpbmtQcm9ncmFtKHByb2dyYW1MaXN0W2ldLCBudWxsLCBwcm9ncmFtTGlzdFtpXS5hdHRyaWJ1dGVzLm1hcChmdW5jdGlvbiAoaW5mbykge1xuICAgICAgICByZXR1cm4gW2luZm8ubG9jYXRpb24sIGluZm8ubmFtZV1cbiAgICAgIH0pKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgY2xlYXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBkZWxldGVTaGFkZXIgPSBnbC5kZWxldGVTaGFkZXIuYmluZChnbClcbiAgICAgIHZhbHVlcyhmcmFnU2hhZGVycykuZm9yRWFjaChkZWxldGVTaGFkZXIpXG4gICAgICBmcmFnU2hhZGVycyA9IHt9XG4gICAgICB2YWx1ZXModmVydFNoYWRlcnMpLmZvckVhY2goZGVsZXRlU2hhZGVyKVxuICAgICAgdmVydFNoYWRlcnMgPSB7fVxuXG4gICAgICBwcm9ncmFtTGlzdC5mb3JFYWNoKGZ1bmN0aW9uIChkZXNjKSB7XG4gICAgICAgIGdsLmRlbGV0ZVByb2dyYW0oZGVzYy5wcm9ncmFtKVxuICAgICAgfSlcbiAgICAgIHByb2dyYW1MaXN0Lmxlbmd0aCA9IDBcbiAgICAgIHByb2dyYW1DYWNoZSA9IHt9XG5cbiAgICAgIHN0YXRzLnNoYWRlckNvdW50ID0gMFxuICAgIH0sXG5cbiAgICBwcm9ncmFtOiBmdW5jdGlvbiAodmVydElkLCBmcmFnSWQsIGNvbW1hbmQsIGF0dHJpYkxvY2F0aW9ucykge1xuICAgICAgY2hlY2skMS5jb21tYW5kKHZlcnRJZCA+PSAwLCAnbWlzc2luZyB2ZXJ0ZXggc2hhZGVyJywgY29tbWFuZClcbiAgICAgIGNoZWNrJDEuY29tbWFuZChmcmFnSWQgPj0gMCwgJ21pc3NpbmcgZnJhZ21lbnQgc2hhZGVyJywgY29tbWFuZClcblxuICAgICAgdmFyIGNhY2hlID0gcHJvZ3JhbUNhY2hlW2ZyYWdJZF1cbiAgICAgIGlmICghY2FjaGUpIHtcbiAgICAgICAgY2FjaGUgPSBwcm9ncmFtQ2FjaGVbZnJhZ0lkXSA9IHt9XG4gICAgICB9XG4gICAgICB2YXIgcHJldlByb2dyYW0gPSBjYWNoZVt2ZXJ0SWRdXG4gICAgICBpZiAocHJldlByb2dyYW0pIHtcbiAgICAgICAgcHJldlByb2dyYW0ucmVmQ291bnQrK1xuICAgICAgICBpZiAoIWF0dHJpYkxvY2F0aW9ucykge1xuICAgICAgICAgIHJldHVybiBwcmV2UHJvZ3JhbVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgcHJvZ3JhbSA9IG5ldyBSRUdMUHJvZ3JhbShmcmFnSWQsIHZlcnRJZClcbiAgICAgIHN0YXRzLnNoYWRlckNvdW50KytcbiAgICAgIGxpbmtQcm9ncmFtKHByb2dyYW0sIGNvbW1hbmQsIGF0dHJpYkxvY2F0aW9ucylcbiAgICAgIGlmICghcHJldlByb2dyYW0pIHtcbiAgICAgICAgY2FjaGVbdmVydElkXSA9IHByb2dyYW1cbiAgICAgIH1cbiAgICAgIHByb2dyYW1MaXN0LnB1c2gocHJvZ3JhbSlcbiAgICAgIHJldHVybiBleHRlbmQocHJvZ3JhbSwge1xuICAgICAgICBkZXN0cm95OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcHJvZ3JhbS5yZWZDb3VudC0tXG4gICAgICAgICAgaWYgKHByb2dyYW0ucmVmQ291bnQgPD0gMCkge1xuICAgICAgICAgICAgZ2wuZGVsZXRlUHJvZ3JhbShwcm9ncmFtLnByb2dyYW0pXG4gICAgICAgICAgICB2YXIgaWR4ID0gcHJvZ3JhbUxpc3QuaW5kZXhPZihwcm9ncmFtKVxuICAgICAgICAgICAgcHJvZ3JhbUxpc3Quc3BsaWNlKGlkeCwgMSlcbiAgICAgICAgICAgIHN0YXRzLnNoYWRlckNvdW50LS1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gbm8gcHJvZ3JhbSBpcyBsaW5rZWQgdG8gdGhpcyB2ZXJ0IGFueW1vcmVcbiAgICAgICAgICBpZiAoY2FjaGVbcHJvZ3JhbS52ZXJ0SWRdLnJlZkNvdW50IDw9IDApIHtcbiAgICAgICAgICAgIGdsLmRlbGV0ZVNoYWRlcih2ZXJ0U2hhZGVyc1twcm9ncmFtLnZlcnRJZF0pXG4gICAgICAgICAgICBkZWxldGUgdmVydFNoYWRlcnNbcHJvZ3JhbS52ZXJ0SWRdXG4gICAgICAgICAgICBkZWxldGUgcHJvZ3JhbUNhY2hlW3Byb2dyYW0uZnJhZ0lkXVtwcm9ncmFtLnZlcnRJZF1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gbm8gcHJvZ3JhbSBpcyBsaW5rZWQgdG8gdGhpcyBmcmFnIGFueW1vcmVcbiAgICAgICAgICBpZiAoIU9iamVjdC5rZXlzKHByb2dyYW1DYWNoZVtwcm9ncmFtLmZyYWdJZF0pLmxlbmd0aCkge1xuICAgICAgICAgICAgZ2wuZGVsZXRlU2hhZGVyKGZyYWdTaGFkZXJzW3Byb2dyYW0uZnJhZ0lkXSlcbiAgICAgICAgICAgIGRlbGV0ZSBmcmFnU2hhZGVyc1twcm9ncmFtLmZyYWdJZF1cbiAgICAgICAgICAgIGRlbGV0ZSBwcm9ncmFtQ2FjaGVbcHJvZ3JhbS5mcmFnSWRdXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH0sXG5cbiAgICByZXN0b3JlOiByZXN0b3JlU2hhZGVycyxcblxuICAgIHNoYWRlcjogZ2V0U2hhZGVyLFxuXG4gICAgZnJhZzogLTEsXG4gICAgdmVydDogLTFcbiAgfVxufVxuXG52YXIgR0xfUkdCQSQzID0gNjQwOFxudmFyIEdMX1VOU0lHTkVEX0JZVEUkNyA9IDUxMjFcbnZhciBHTF9QQUNLX0FMSUdOTUVOVCA9IDB4MEQwNVxudmFyIEdMX0ZMT0FUJDcgPSAweDE0MDYgLy8gNTEyNlxuXG5mdW5jdGlvbiB3cmFwUmVhZFBpeGVscyAoXG4gIGdsLFxuICBmcmFtZWJ1ZmZlclN0YXRlLFxuICByZWdsUG9sbCxcbiAgY29udGV4dCxcbiAgZ2xBdHRyaWJ1dGVzLFxuICBleHRlbnNpb25zLFxuICBsaW1pdHMpIHtcbiAgZnVuY3Rpb24gcmVhZFBpeGVsc0ltcGwgKGlucHV0KSB7XG4gICAgdmFyIHR5cGVcbiAgICBpZiAoZnJhbWVidWZmZXJTdGF0ZS5uZXh0ID09PSBudWxsKSB7XG4gICAgICBjaGVjayQxKFxuICAgICAgICBnbEF0dHJpYnV0ZXMucHJlc2VydmVEcmF3aW5nQnVmZmVyLFxuICAgICAgICAneW91IG11c3QgY3JlYXRlIGEgd2ViZ2wgY29udGV4dCB3aXRoIFwicHJlc2VydmVEcmF3aW5nQnVmZmVyXCI6dHJ1ZSBpbiBvcmRlciB0byByZWFkIHBpeGVscyBmcm9tIHRoZSBkcmF3aW5nIGJ1ZmZlcicpXG4gICAgICB0eXBlID0gR0xfVU5TSUdORURfQllURSQ3XG4gICAgfSBlbHNlIHtcbiAgICAgIGNoZWNrJDEoXG4gICAgICAgIGZyYW1lYnVmZmVyU3RhdGUubmV4dC5jb2xvckF0dGFjaG1lbnRzWzBdLnRleHR1cmUgIT09IG51bGwsXG4gICAgICAgICdZb3UgY2Fubm90IHJlYWQgZnJvbSBhIHJlbmRlcmJ1ZmZlcicpXG4gICAgICB0eXBlID0gZnJhbWVidWZmZXJTdGF0ZS5uZXh0LmNvbG9yQXR0YWNobWVudHNbMF0udGV4dHVyZS5fdGV4dHVyZS50eXBlXG5cbiAgICAgIGlmIChleHRlbnNpb25zLm9lc190ZXh0dXJlX2Zsb2F0KSB7XG4gICAgICAgIGNoZWNrJDEoXG4gICAgICAgICAgdHlwZSA9PT0gR0xfVU5TSUdORURfQllURSQ3IHx8IHR5cGUgPT09IEdMX0ZMT0FUJDcsXG4gICAgICAgICAgJ1JlYWRpbmcgZnJvbSBhIGZyYW1lYnVmZmVyIGlzIG9ubHkgYWxsb3dlZCBmb3IgdGhlIHR5cGVzIFxcJ3VpbnQ4XFwnIGFuZCBcXCdmbG9hdFxcJycpXG5cbiAgICAgICAgaWYgKHR5cGUgPT09IEdMX0ZMT0FUJDcpIHtcbiAgICAgICAgICBjaGVjayQxKGxpbWl0cy5yZWFkRmxvYXQsICdSZWFkaW5nIFxcJ2Zsb2F0XFwnIHZhbHVlcyBpcyBub3QgcGVybWl0dGVkIGluIHlvdXIgYnJvd3Nlci4gRm9yIGEgZmFsbGJhY2ssIHBsZWFzZSBzZWU6IGh0dHBzOi8vd3d3Lm5wbWpzLmNvbS9wYWNrYWdlL2dsc2wtcmVhZC1mbG9hdCcpXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNoZWNrJDEoXG4gICAgICAgICAgdHlwZSA9PT0gR0xfVU5TSUdORURfQllURSQ3LFxuICAgICAgICAgICdSZWFkaW5nIGZyb20gYSBmcmFtZWJ1ZmZlciBpcyBvbmx5IGFsbG93ZWQgZm9yIHRoZSB0eXBlIFxcJ3VpbnQ4XFwnJylcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgeCA9IDBcbiAgICB2YXIgeSA9IDBcbiAgICB2YXIgd2lkdGggPSBjb250ZXh0LmZyYW1lYnVmZmVyV2lkdGhcbiAgICB2YXIgaGVpZ2h0ID0gY29udGV4dC5mcmFtZWJ1ZmZlckhlaWdodFxuICAgIHZhciBkYXRhID0gbnVsbFxuXG4gICAgaWYgKGlzVHlwZWRBcnJheShpbnB1dCkpIHtcbiAgICAgIGRhdGEgPSBpbnB1dFxuICAgIH0gZWxzZSBpZiAoaW5wdXQpIHtcbiAgICAgIGNoZWNrJDEudHlwZShpbnB1dCwgJ29iamVjdCcsICdpbnZhbGlkIGFyZ3VtZW50cyB0byByZWdsLnJlYWQoKScpXG4gICAgICB4ID0gaW5wdXQueCB8IDBcbiAgICAgIHkgPSBpbnB1dC55IHwgMFxuICAgICAgY2hlY2skMShcbiAgICAgICAgeCA+PSAwICYmIHggPCBjb250ZXh0LmZyYW1lYnVmZmVyV2lkdGgsXG4gICAgICAgICdpbnZhbGlkIHggb2Zmc2V0IGZvciByZWdsLnJlYWQnKVxuICAgICAgY2hlY2skMShcbiAgICAgICAgeSA+PSAwICYmIHkgPCBjb250ZXh0LmZyYW1lYnVmZmVySGVpZ2h0LFxuICAgICAgICAnaW52YWxpZCB5IG9mZnNldCBmb3IgcmVnbC5yZWFkJylcbiAgICAgIHdpZHRoID0gKGlucHV0LndpZHRoIHx8IChjb250ZXh0LmZyYW1lYnVmZmVyV2lkdGggLSB4KSkgfCAwXG4gICAgICBoZWlnaHQgPSAoaW5wdXQuaGVpZ2h0IHx8IChjb250ZXh0LmZyYW1lYnVmZmVySGVpZ2h0IC0geSkpIHwgMFxuICAgICAgZGF0YSA9IGlucHV0LmRhdGEgfHwgbnVsbFxuICAgIH1cblxuICAgIC8vIHNhbml0eSBjaGVjayBpbnB1dC5kYXRhXG4gICAgaWYgKGRhdGEpIHtcbiAgICAgIGlmICh0eXBlID09PSBHTF9VTlNJR05FRF9CWVRFJDcpIHtcbiAgICAgICAgY2hlY2skMShcbiAgICAgICAgICBkYXRhIGluc3RhbmNlb2YgVWludDhBcnJheSxcbiAgICAgICAgICAnYnVmZmVyIG11c3QgYmUgXFwnVWludDhBcnJheVxcJyB3aGVuIHJlYWRpbmcgZnJvbSBhIGZyYW1lYnVmZmVyIG9mIHR5cGUgXFwndWludDhcXCcnKVxuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBHTF9GTE9BVCQ3KSB7XG4gICAgICAgIGNoZWNrJDEoXG4gICAgICAgICAgZGF0YSBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheSxcbiAgICAgICAgICAnYnVmZmVyIG11c3QgYmUgXFwnRmxvYXQzMkFycmF5XFwnIHdoZW4gcmVhZGluZyBmcm9tIGEgZnJhbWVidWZmZXIgb2YgdHlwZSBcXCdmbG9hdFxcJycpXG4gICAgICB9XG4gICAgfVxuXG4gICAgY2hlY2skMShcbiAgICAgIHdpZHRoID4gMCAmJiB3aWR0aCArIHggPD0gY29udGV4dC5mcmFtZWJ1ZmZlcldpZHRoLFxuICAgICAgJ2ludmFsaWQgd2lkdGggZm9yIHJlYWQgcGl4ZWxzJylcbiAgICBjaGVjayQxKFxuICAgICAgaGVpZ2h0ID4gMCAmJiBoZWlnaHQgKyB5IDw9IGNvbnRleHQuZnJhbWVidWZmZXJIZWlnaHQsXG4gICAgICAnaW52YWxpZCBoZWlnaHQgZm9yIHJlYWQgcGl4ZWxzJylcblxuICAgIC8vIFVwZGF0ZSBXZWJHTCBzdGF0ZVxuICAgIHJlZ2xQb2xsKClcblxuICAgIC8vIENvbXB1dGUgc2l6ZVxuICAgIHZhciBzaXplID0gd2lkdGggKiBoZWlnaHQgKiA0XG5cbiAgICAvLyBBbGxvY2F0ZSBkYXRhXG4gICAgaWYgKCFkYXRhKSB7XG4gICAgICBpZiAodHlwZSA9PT0gR0xfVU5TSUdORURfQllURSQ3KSB7XG4gICAgICAgIGRhdGEgPSBuZXcgVWludDhBcnJheShzaXplKVxuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBHTF9GTE9BVCQ3KSB7XG4gICAgICAgIGRhdGEgPSBkYXRhIHx8IG5ldyBGbG9hdDMyQXJyYXkoc2l6ZSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUeXBlIGNoZWNrXG4gICAgY2hlY2skMS5pc1R5cGVkQXJyYXkoZGF0YSwgJ2RhdGEgYnVmZmVyIGZvciByZWdsLnJlYWQoKSBtdXN0IGJlIGEgdHlwZWRhcnJheScpXG4gICAgY2hlY2skMShkYXRhLmJ5dGVMZW5ndGggPj0gc2l6ZSwgJ2RhdGEgYnVmZmVyIGZvciByZWdsLnJlYWQoKSB0b28gc21hbGwnKVxuXG4gICAgLy8gUnVuIHJlYWQgcGl4ZWxzXG4gICAgZ2wucGl4ZWxTdG9yZWkoR0xfUEFDS19BTElHTk1FTlQsIDQpXG4gICAgZ2wucmVhZFBpeGVscyh4LCB5LCB3aWR0aCwgaGVpZ2h0LCBHTF9SR0JBJDMsXG4gICAgICB0eXBlLFxuICAgICAgZGF0YSlcblxuICAgIHJldHVybiBkYXRhXG4gIH1cblxuICBmdW5jdGlvbiByZWFkUGl4ZWxzRkJPIChvcHRpb25zKSB7XG4gICAgdmFyIHJlc3VsdFxuICAgIGZyYW1lYnVmZmVyU3RhdGUuc2V0RkJPKHtcbiAgICAgIGZyYW1lYnVmZmVyOiBvcHRpb25zLmZyYW1lYnVmZmVyXG4gICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgcmVzdWx0ID0gcmVhZFBpeGVsc0ltcGwob3B0aW9ucylcbiAgICB9KVxuICAgIHJldHVybiByZXN1bHRcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWRQaXhlbHMgKG9wdGlvbnMpIHtcbiAgICBpZiAoIW9wdGlvbnMgfHwgISgnZnJhbWVidWZmZXInIGluIG9wdGlvbnMpKSB7XG4gICAgICByZXR1cm4gcmVhZFBpeGVsc0ltcGwob3B0aW9ucylcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHJlYWRQaXhlbHNGQk8ob3B0aW9ucylcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVhZFBpeGVsc1xufVxuXG5mdW5jdGlvbiBzbGljZSAoeCkge1xuICByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoeClcbn1cblxuZnVuY3Rpb24gam9pbiAoeCkge1xuICByZXR1cm4gc2xpY2UoeCkuam9pbignJylcbn1cblxuZnVuY3Rpb24gY3JlYXRlRW52aXJvbm1lbnQgKCkge1xuICAvLyBVbmlxdWUgdmFyaWFibGUgaWQgY291bnRlclxuICB2YXIgdmFyQ291bnRlciA9IDBcblxuICAvLyBMaW5rZWQgdmFsdWVzIGFyZSBwYXNzZWQgZnJvbSB0aGlzIHNjb3BlIGludG8gdGhlIGdlbmVyYXRlZCBjb2RlIGJsb2NrXG4gIC8vIENhbGxpbmcgbGluaygpIHBhc3NlcyBhIHZhbHVlIGludG8gdGhlIGdlbmVyYXRlZCBzY29wZSBhbmQgcmV0dXJuc1xuICAvLyB0aGUgdmFyaWFibGUgbmFtZSB3aGljaCBpdCBpcyBib3VuZCB0b1xuICB2YXIgbGlua2VkTmFtZXMgPSBbXVxuICB2YXIgbGlua2VkVmFsdWVzID0gW11cbiAgZnVuY3Rpb24gbGluayAodmFsdWUpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmtlZFZhbHVlcy5sZW5ndGg7ICsraSkge1xuICAgICAgaWYgKGxpbmtlZFZhbHVlc1tpXSA9PT0gdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGxpbmtlZE5hbWVzW2ldXG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIG5hbWUgPSAnZycgKyAodmFyQ291bnRlcisrKVxuICAgIGxpbmtlZE5hbWVzLnB1c2gobmFtZSlcbiAgICBsaW5rZWRWYWx1ZXMucHVzaCh2YWx1ZSlcbiAgICByZXR1cm4gbmFtZVxuICB9XG5cbiAgLy8gY3JlYXRlIGEgY29kZSBibG9ja1xuICBmdW5jdGlvbiBibG9jayAoKSB7XG4gICAgdmFyIGNvZGUgPSBbXVxuICAgIGZ1bmN0aW9uIHB1c2ggKCkge1xuICAgICAgY29kZS5wdXNoLmFwcGx5KGNvZGUsIHNsaWNlKGFyZ3VtZW50cykpXG4gICAgfVxuXG4gICAgdmFyIHZhcnMgPSBbXVxuICAgIGZ1bmN0aW9uIGRlZiAoKSB7XG4gICAgICB2YXIgbmFtZSA9ICd2JyArICh2YXJDb3VudGVyKyspXG4gICAgICB2YXJzLnB1c2gobmFtZSlcblxuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvZGUucHVzaChuYW1lLCAnPScpXG4gICAgICAgIGNvZGUucHVzaC5hcHBseShjb2RlLCBzbGljZShhcmd1bWVudHMpKVxuICAgICAgICBjb2RlLnB1c2goJzsnKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmFtZVxuICAgIH1cblxuICAgIHJldHVybiBleHRlbmQocHVzaCwge1xuICAgICAgZGVmOiBkZWYsXG4gICAgICB0b1N0cmluZzogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gam9pbihbXG4gICAgICAgICAgKHZhcnMubGVuZ3RoID4gMCA/ICd2YXIgJyArIHZhcnMuam9pbignLCcpICsgJzsnIDogJycpLFxuICAgICAgICAgIGpvaW4oY29kZSlcbiAgICAgICAgXSlcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgZnVuY3Rpb24gc2NvcGUgKCkge1xuICAgIHZhciBlbnRyeSA9IGJsb2NrKClcbiAgICB2YXIgZXhpdCA9IGJsb2NrKClcblxuICAgIHZhciBlbnRyeVRvU3RyaW5nID0gZW50cnkudG9TdHJpbmdcbiAgICB2YXIgZXhpdFRvU3RyaW5nID0gZXhpdC50b1N0cmluZ1xuXG4gICAgZnVuY3Rpb24gc2F2ZSAob2JqZWN0LCBwcm9wKSB7XG4gICAgICBleGl0KG9iamVjdCwgcHJvcCwgJz0nLCBlbnRyeS5kZWYob2JqZWN0LCBwcm9wKSwgJzsnKVxuICAgIH1cblxuICAgIHJldHVybiBleHRlbmQoZnVuY3Rpb24gKCkge1xuICAgICAgZW50cnkuYXBwbHkoZW50cnksIHNsaWNlKGFyZ3VtZW50cykpXG4gICAgfSwge1xuICAgICAgZGVmOiBlbnRyeS5kZWYsXG4gICAgICBlbnRyeTogZW50cnksXG4gICAgICBleGl0OiBleGl0LFxuICAgICAgc2F2ZTogc2F2ZSxcbiAgICAgIHNldDogZnVuY3Rpb24gKG9iamVjdCwgcHJvcCwgdmFsdWUpIHtcbiAgICAgICAgc2F2ZShvYmplY3QsIHByb3ApXG4gICAgICAgIGVudHJ5KG9iamVjdCwgcHJvcCwgJz0nLCB2YWx1ZSwgJzsnKVxuICAgICAgfSxcbiAgICAgIHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBlbnRyeVRvU3RyaW5nKCkgKyBleGl0VG9TdHJpbmcoKVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICBmdW5jdGlvbiBjb25kaXRpb25hbCAoKSB7XG4gICAgdmFyIHByZWQgPSBqb2luKGFyZ3VtZW50cylcbiAgICB2YXIgdGhlbkJsb2NrID0gc2NvcGUoKVxuICAgIHZhciBlbHNlQmxvY2sgPSBzY29wZSgpXG5cbiAgICB2YXIgdGhlblRvU3RyaW5nID0gdGhlbkJsb2NrLnRvU3RyaW5nXG4gICAgdmFyIGVsc2VUb1N0cmluZyA9IGVsc2VCbG9jay50b1N0cmluZ1xuXG4gICAgcmV0dXJuIGV4dGVuZCh0aGVuQmxvY2ssIHtcbiAgICAgIHRoZW46IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhlbkJsb2NrLmFwcGx5KHRoZW5CbG9jaywgc2xpY2UoYXJndW1lbnRzKSlcbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgIH0sXG4gICAgICBlbHNlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGVsc2VCbG9jay5hcHBseShlbHNlQmxvY2ssIHNsaWNlKGFyZ3VtZW50cykpXG4gICAgICAgIHJldHVybiB0aGlzXG4gICAgICB9LFxuICAgICAgdG9TdHJpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGVsc2VDbGF1c2UgPSBlbHNlVG9TdHJpbmcoKVxuICAgICAgICBpZiAoZWxzZUNsYXVzZSkge1xuICAgICAgICAgIGVsc2VDbGF1c2UgPSAnZWxzZXsnICsgZWxzZUNsYXVzZSArICd9J1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBqb2luKFtcbiAgICAgICAgICAnaWYoJywgcHJlZCwgJyl7JyxcbiAgICAgICAgICB0aGVuVG9TdHJpbmcoKSxcbiAgICAgICAgICAnfScsIGVsc2VDbGF1c2VcbiAgICAgICAgXSlcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgLy8gcHJvY2VkdXJlIGxpc3RcbiAgdmFyIGdsb2JhbEJsb2NrID0gYmxvY2soKVxuICB2YXIgcHJvY2VkdXJlcyA9IHt9XG4gIGZ1bmN0aW9uIHByb2MgKG5hbWUsIGNvdW50KSB7XG4gICAgdmFyIGFyZ3MgPSBbXVxuICAgIGZ1bmN0aW9uIGFyZyAoKSB7XG4gICAgICB2YXIgbmFtZSA9ICdhJyArIGFyZ3MubGVuZ3RoXG4gICAgICBhcmdzLnB1c2gobmFtZSlcbiAgICAgIHJldHVybiBuYW1lXG4gICAgfVxuXG4gICAgY291bnQgPSBjb3VudCB8fCAwXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgKytpKSB7XG4gICAgICBhcmcoKVxuICAgIH1cblxuICAgIHZhciBib2R5ID0gc2NvcGUoKVxuICAgIHZhciBib2R5VG9TdHJpbmcgPSBib2R5LnRvU3RyaW5nXG5cbiAgICB2YXIgcmVzdWx0ID0gcHJvY2VkdXJlc1tuYW1lXSA9IGV4dGVuZChib2R5LCB7XG4gICAgICBhcmc6IGFyZyxcbiAgICAgIHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBqb2luKFtcbiAgICAgICAgICAnZnVuY3Rpb24oJywgYXJncy5qb2luKCksICcpeycsXG4gICAgICAgICAgYm9keVRvU3RyaW5nKCksXG4gICAgICAgICAgJ30nXG4gICAgICAgIF0pXG4gICAgICB9XG4gICAgfSlcblxuICAgIHJldHVybiByZXN1bHRcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbXBpbGUgKCkge1xuICAgIHZhciBjb2RlID0gWydcInVzZSBzdHJpY3RcIjsnLFxuICAgICAgZ2xvYmFsQmxvY2ssXG4gICAgICAncmV0dXJuIHsnXVxuICAgIE9iamVjdC5rZXlzKHByb2NlZHVyZXMpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIGNvZGUucHVzaCgnXCInLCBuYW1lLCAnXCI6JywgcHJvY2VkdXJlc1tuYW1lXS50b1N0cmluZygpLCAnLCcpXG4gICAgfSlcbiAgICBjb2RlLnB1c2goJ30nKVxuICAgIHZhciBzcmMgPSBqb2luKGNvZGUpXG4gICAgICAucmVwbGFjZSgvOy9nLCAnO1xcbicpXG4gICAgICAucmVwbGFjZSgvfS9nLCAnfVxcbicpXG4gICAgICAucmVwbGFjZSgvey9nLCAne1xcbicpXG4gICAgdmFyIHByb2MgPSBGdW5jdGlvbi5hcHBseShudWxsLCBsaW5rZWROYW1lcy5jb25jYXQoc3JjKSlcbiAgICByZXR1cm4gcHJvYy5hcHBseShudWxsLCBsaW5rZWRWYWx1ZXMpXG4gIH1cblxuICByZXR1cm4ge1xuICAgIGdsb2JhbDogZ2xvYmFsQmxvY2ssXG4gICAgbGluazogbGluayxcbiAgICBibG9jazogYmxvY2ssXG4gICAgcHJvYzogcHJvYyxcbiAgICBzY29wZTogc2NvcGUsXG4gICAgY29uZDogY29uZGl0aW9uYWwsXG4gICAgY29tcGlsZTogY29tcGlsZVxuICB9XG59XG5cbi8vIFwiY3V0ZVwiIG5hbWVzIGZvciB2ZWN0b3IgY29tcG9uZW50c1xudmFyIENVVEVfQ09NUE9ORU5UUyA9ICd4eXp3Jy5zcGxpdCgnJylcblxudmFyIEdMX1VOU0lHTkVEX0JZVEUkOCA9IDUxMjFcblxudmFyIEFUVFJJQl9TVEFURV9QT0lOVEVSID0gMVxudmFyIEFUVFJJQl9TVEFURV9DT05TVEFOVCA9IDJcblxudmFyIERZTl9GVU5DJDEgPSAwXG52YXIgRFlOX1BST1AkMSA9IDFcbnZhciBEWU5fQ09OVEVYVCQxID0gMlxudmFyIERZTl9TVEFURSQxID0gM1xudmFyIERZTl9USFVOSyA9IDRcbnZhciBEWU5fQ09OU1RBTlQkMSA9IDVcbnZhciBEWU5fQVJSQVkkMSA9IDZcblxudmFyIFNfRElUSEVSID0gJ2RpdGhlcidcbnZhciBTX0JMRU5EX0VOQUJMRSA9ICdibGVuZC5lbmFibGUnXG52YXIgU19CTEVORF9DT0xPUiA9ICdibGVuZC5jb2xvcidcbnZhciBTX0JMRU5EX0VRVUFUSU9OID0gJ2JsZW5kLmVxdWF0aW9uJ1xudmFyIFNfQkxFTkRfRlVOQyA9ICdibGVuZC5mdW5jJ1xudmFyIFNfREVQVEhfRU5BQkxFID0gJ2RlcHRoLmVuYWJsZSdcbnZhciBTX0RFUFRIX0ZVTkMgPSAnZGVwdGguZnVuYydcbnZhciBTX0RFUFRIX1JBTkdFID0gJ2RlcHRoLnJhbmdlJ1xudmFyIFNfREVQVEhfTUFTSyA9ICdkZXB0aC5tYXNrJ1xudmFyIFNfQ09MT1JfTUFTSyA9ICdjb2xvck1hc2snXG52YXIgU19DVUxMX0VOQUJMRSA9ICdjdWxsLmVuYWJsZSdcbnZhciBTX0NVTExfRkFDRSA9ICdjdWxsLmZhY2UnXG52YXIgU19GUk9OVF9GQUNFID0gJ2Zyb250RmFjZSdcbnZhciBTX0xJTkVfV0lEVEggPSAnbGluZVdpZHRoJ1xudmFyIFNfUE9MWUdPTl9PRkZTRVRfRU5BQkxFID0gJ3BvbHlnb25PZmZzZXQuZW5hYmxlJ1xudmFyIFNfUE9MWUdPTl9PRkZTRVRfT0ZGU0VUID0gJ3BvbHlnb25PZmZzZXQub2Zmc2V0J1xudmFyIFNfU0FNUExFX0FMUEhBID0gJ3NhbXBsZS5hbHBoYSdcbnZhciBTX1NBTVBMRV9FTkFCTEUgPSAnc2FtcGxlLmVuYWJsZSdcbnZhciBTX1NBTVBMRV9DT1ZFUkFHRSA9ICdzYW1wbGUuY292ZXJhZ2UnXG52YXIgU19TVEVOQ0lMX0VOQUJMRSA9ICdzdGVuY2lsLmVuYWJsZSdcbnZhciBTX1NURU5DSUxfTUFTSyA9ICdzdGVuY2lsLm1hc2snXG52YXIgU19TVEVOQ0lMX0ZVTkMgPSAnc3RlbmNpbC5mdW5jJ1xudmFyIFNfU1RFTkNJTF9PUEZST05UID0gJ3N0ZW5jaWwub3BGcm9udCdcbnZhciBTX1NURU5DSUxfT1BCQUNLID0gJ3N0ZW5jaWwub3BCYWNrJ1xudmFyIFNfU0NJU1NPUl9FTkFCTEUgPSAnc2Npc3Nvci5lbmFibGUnXG52YXIgU19TQ0lTU09SX0JPWCA9ICdzY2lzc29yLmJveCdcbnZhciBTX1ZJRVdQT1JUID0gJ3ZpZXdwb3J0J1xuXG52YXIgU19QUk9GSUxFID0gJ3Byb2ZpbGUnXG5cbnZhciBTX0ZSQU1FQlVGRkVSID0gJ2ZyYW1lYnVmZmVyJ1xudmFyIFNfVkVSVCA9ICd2ZXJ0J1xudmFyIFNfRlJBRyA9ICdmcmFnJ1xudmFyIFNfRUxFTUVOVFMgPSAnZWxlbWVudHMnXG52YXIgU19QUklNSVRJVkUgPSAncHJpbWl0aXZlJ1xudmFyIFNfQ09VTlQgPSAnY291bnQnXG52YXIgU19PRkZTRVQgPSAnb2Zmc2V0J1xudmFyIFNfSU5TVEFOQ0VTID0gJ2luc3RhbmNlcydcbnZhciBTX1ZBTyA9ICd2YW8nXG5cbnZhciBTVUZGSVhfV0lEVEggPSAnV2lkdGgnXG52YXIgU1VGRklYX0hFSUdIVCA9ICdIZWlnaHQnXG5cbnZhciBTX0ZSQU1FQlVGRkVSX1dJRFRIID0gU19GUkFNRUJVRkZFUiArIFNVRkZJWF9XSURUSFxudmFyIFNfRlJBTUVCVUZGRVJfSEVJR0hUID0gU19GUkFNRUJVRkZFUiArIFNVRkZJWF9IRUlHSFRcbnZhciBTX1ZJRVdQT1JUX1dJRFRIID0gU19WSUVXUE9SVCArIFNVRkZJWF9XSURUSFxudmFyIFNfVklFV1BPUlRfSEVJR0hUID0gU19WSUVXUE9SVCArIFNVRkZJWF9IRUlHSFRcbnZhciBTX0RSQVdJTkdCVUZGRVIgPSAnZHJhd2luZ0J1ZmZlcidcbnZhciBTX0RSQVdJTkdCVUZGRVJfV0lEVEggPSBTX0RSQVdJTkdCVUZGRVIgKyBTVUZGSVhfV0lEVEhcbnZhciBTX0RSQVdJTkdCVUZGRVJfSEVJR0hUID0gU19EUkFXSU5HQlVGRkVSICsgU1VGRklYX0hFSUdIVFxuXG52YXIgTkVTVEVEX09QVElPTlMgPSBbXG4gIFNfQkxFTkRfRlVOQyxcbiAgU19CTEVORF9FUVVBVElPTixcbiAgU19TVEVOQ0lMX0ZVTkMsXG4gIFNfU1RFTkNJTF9PUEZST05ULFxuICBTX1NURU5DSUxfT1BCQUNLLFxuICBTX1NBTVBMRV9DT1ZFUkFHRSxcbiAgU19WSUVXUE9SVCxcbiAgU19TQ0lTU09SX0JPWCxcbiAgU19QT0xZR09OX09GRlNFVF9PRkZTRVRcbl1cblxudmFyIEdMX0FSUkFZX0JVRkZFUiQyID0gMzQ5NjJcbnZhciBHTF9FTEVNRU5UX0FSUkFZX0JVRkZFUiQxID0gMzQ5NjNcblxudmFyIEdMX0ZSQUdNRU5UX1NIQURFUiQxID0gMzU2MzJcbnZhciBHTF9WRVJURVhfU0hBREVSJDEgPSAzNTYzM1xuXG52YXIgR0xfVEVYVFVSRV8yRCQzID0gMHgwREUxXG52YXIgR0xfVEVYVFVSRV9DVUJFX01BUCQyID0gMHg4NTEzXG5cbnZhciBHTF9DVUxMX0ZBQ0UgPSAweDBCNDRcbnZhciBHTF9CTEVORCA9IDB4MEJFMlxudmFyIEdMX0RJVEhFUiA9IDB4MEJEMFxudmFyIEdMX1NURU5DSUxfVEVTVCA9IDB4MEI5MFxudmFyIEdMX0RFUFRIX1RFU1QgPSAweDBCNzFcbnZhciBHTF9TQ0lTU09SX1RFU1QgPSAweDBDMTFcbnZhciBHTF9QT0xZR09OX09GRlNFVF9GSUxMID0gMHg4MDM3XG52YXIgR0xfU0FNUExFX0FMUEhBX1RPX0NPVkVSQUdFID0gMHg4MDlFXG52YXIgR0xfU0FNUExFX0NPVkVSQUdFID0gMHg4MEEwXG5cbnZhciBHTF9GTE9BVCQ4ID0gNTEyNlxudmFyIEdMX0ZMT0FUX1ZFQzIgPSAzNTY2NFxudmFyIEdMX0ZMT0FUX1ZFQzMgPSAzNTY2NVxudmFyIEdMX0ZMT0FUX1ZFQzQgPSAzNTY2NlxudmFyIEdMX0lOVCQzID0gNTEyNFxudmFyIEdMX0lOVF9WRUMyID0gMzU2NjdcbnZhciBHTF9JTlRfVkVDMyA9IDM1NjY4XG52YXIgR0xfSU5UX1ZFQzQgPSAzNTY2OVxudmFyIEdMX0JPT0wgPSAzNTY3MFxudmFyIEdMX0JPT0xfVkVDMiA9IDM1NjcxXG52YXIgR0xfQk9PTF9WRUMzID0gMzU2NzJcbnZhciBHTF9CT09MX1ZFQzQgPSAzNTY3M1xudmFyIEdMX0ZMT0FUX01BVDIgPSAzNTY3NFxudmFyIEdMX0ZMT0FUX01BVDMgPSAzNTY3NVxudmFyIEdMX0ZMT0FUX01BVDQgPSAzNTY3NlxudmFyIEdMX1NBTVBMRVJfMkQgPSAzNTY3OFxudmFyIEdMX1NBTVBMRVJfQ1VCRSA9IDM1NjgwXG5cbnZhciBHTF9UUklBTkdMRVMkMSA9IDRcblxudmFyIEdMX0ZST05UID0gMTAyOFxudmFyIEdMX0JBQ0sgPSAxMDI5XG52YXIgR0xfQ1cgPSAweDA5MDBcbnZhciBHTF9DQ1cgPSAweDA5MDFcbnZhciBHTF9NSU5fRVhUID0gMHg4MDA3XG52YXIgR0xfTUFYX0VYVCA9IDB4ODAwOFxudmFyIEdMX0FMV0FZUyA9IDUxOVxudmFyIEdMX0tFRVAgPSA3NjgwXG52YXIgR0xfWkVSTyA9IDBcbnZhciBHTF9PTkUgPSAxXG52YXIgR0xfRlVOQ19BREQgPSAweDgwMDZcbnZhciBHTF9MRVNTID0gNTEzXG5cbnZhciBHTF9GUkFNRUJVRkZFUiQyID0gMHg4RDQwXG52YXIgR0xfQ09MT1JfQVRUQUNITUVOVDAkMiA9IDB4OENFMFxuXG52YXIgYmxlbmRGdW5jcyA9IHtcbiAgJzAnOiAwLFxuICAnMSc6IDEsXG4gICd6ZXJvJzogMCxcbiAgJ29uZSc6IDEsXG4gICdzcmMgY29sb3InOiA3NjgsXG4gICdvbmUgbWludXMgc3JjIGNvbG9yJzogNzY5LFxuICAnc3JjIGFscGhhJzogNzcwLFxuICAnb25lIG1pbnVzIHNyYyBhbHBoYSc6IDc3MSxcbiAgJ2RzdCBjb2xvcic6IDc3NCxcbiAgJ29uZSBtaW51cyBkc3QgY29sb3InOiA3NzUsXG4gICdkc3QgYWxwaGEnOiA3NzIsXG4gICdvbmUgbWludXMgZHN0IGFscGhhJzogNzczLFxuICAnY29uc3RhbnQgY29sb3InOiAzMjc2OSxcbiAgJ29uZSBtaW51cyBjb25zdGFudCBjb2xvcic6IDMyNzcwLFxuICAnY29uc3RhbnQgYWxwaGEnOiAzMjc3MSxcbiAgJ29uZSBtaW51cyBjb25zdGFudCBhbHBoYSc6IDMyNzcyLFxuICAnc3JjIGFscGhhIHNhdHVyYXRlJzogNzc2XG59XG5cbi8vIFRoZXJlIGFyZSBpbnZhbGlkIHZhbHVlcyBmb3Igc3JjUkdCIGFuZCBkc3RSR0IuIFNlZTpcbi8vIGh0dHBzOi8vd3d3Lmtocm9ub3Mub3JnL3JlZ2lzdHJ5L3dlYmdsL3NwZWNzLzEuMC8jNi4xM1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL0tocm9ub3NHcm91cC9XZWJHTC9ibG9iLzBkMzIwMWY1ZjdlYzNjMDA2MGJjMWYwNDA3NzQ2MTU0MWYxOTg3YjkvY29uZm9ybWFuY2Utc3VpdGVzLzEuMC4zL2NvbmZvcm1hbmNlL21pc2Mvd2ViZ2wtc3BlY2lmaWMuaHRtbCNMNTZcbnZhciBpbnZhbGlkQmxlbmRDb21iaW5hdGlvbnMgPSBbXG4gICdjb25zdGFudCBjb2xvciwgY29uc3RhbnQgYWxwaGEnLFxuICAnb25lIG1pbnVzIGNvbnN0YW50IGNvbG9yLCBjb25zdGFudCBhbHBoYScsXG4gICdjb25zdGFudCBjb2xvciwgb25lIG1pbnVzIGNvbnN0YW50IGFscGhhJyxcbiAgJ29uZSBtaW51cyBjb25zdGFudCBjb2xvciwgb25lIG1pbnVzIGNvbnN0YW50IGFscGhhJyxcbiAgJ2NvbnN0YW50IGFscGhhLCBjb25zdGFudCBjb2xvcicsXG4gICdjb25zdGFudCBhbHBoYSwgb25lIG1pbnVzIGNvbnN0YW50IGNvbG9yJyxcbiAgJ29uZSBtaW51cyBjb25zdGFudCBhbHBoYSwgY29uc3RhbnQgY29sb3InLFxuICAnb25lIG1pbnVzIGNvbnN0YW50IGFscGhhLCBvbmUgbWludXMgY29uc3RhbnQgY29sb3InXG5dXG5cbnZhciBjb21wYXJlRnVuY3MgPSB7XG4gICduZXZlcic6IDUxMixcbiAgJ2xlc3MnOiA1MTMsXG4gICc8JzogNTEzLFxuICAnZXF1YWwnOiA1MTQsXG4gICc9JzogNTE0LFxuICAnPT0nOiA1MTQsXG4gICc9PT0nOiA1MTQsXG4gICdsZXF1YWwnOiA1MTUsXG4gICc8PSc6IDUxNSxcbiAgJ2dyZWF0ZXInOiA1MTYsXG4gICc+JzogNTE2LFxuICAnbm90ZXF1YWwnOiA1MTcsXG4gICchPSc6IDUxNyxcbiAgJyE9PSc6IDUxNyxcbiAgJ2dlcXVhbCc6IDUxOCxcbiAgJz49JzogNTE4LFxuICAnYWx3YXlzJzogNTE5XG59XG5cbnZhciBzdGVuY2lsT3BzID0ge1xuICAnMCc6IDAsXG4gICd6ZXJvJzogMCxcbiAgJ2tlZXAnOiA3NjgwLFxuICAncmVwbGFjZSc6IDc2ODEsXG4gICdpbmNyZW1lbnQnOiA3NjgyLFxuICAnZGVjcmVtZW50JzogNzY4MyxcbiAgJ2luY3JlbWVudCB3cmFwJzogMzQwNTUsXG4gICdkZWNyZW1lbnQgd3JhcCc6IDM0MDU2LFxuICAnaW52ZXJ0JzogNTM4NlxufVxuXG52YXIgc2hhZGVyVHlwZSA9IHtcbiAgJ2ZyYWcnOiBHTF9GUkFHTUVOVF9TSEFERVIkMSxcbiAgJ3ZlcnQnOiBHTF9WRVJURVhfU0hBREVSJDFcbn1cblxudmFyIG9yaWVudGF0aW9uVHlwZSA9IHtcbiAgJ2N3JzogR0xfQ1csXG4gICdjY3cnOiBHTF9DQ1dcbn1cblxuZnVuY3Rpb24gaXNCdWZmZXJBcmdzICh4KSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KHgpIHx8XG4gICAgaXNUeXBlZEFycmF5KHgpIHx8XG4gICAgaXNOREFycmF5TGlrZSh4KVxufVxuXG4vLyBNYWtlIHN1cmUgdmlld3BvcnQgaXMgcHJvY2Vzc2VkIGZpcnN0XG5mdW5jdGlvbiBzb3J0U3RhdGUgKHN0YXRlKSB7XG4gIHJldHVybiBzdGF0ZS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgaWYgKGEgPT09IFNfVklFV1BPUlQpIHtcbiAgICAgIHJldHVybiAtMVxuICAgIH0gZWxzZSBpZiAoYiA9PT0gU19WSUVXUE9SVCkge1xuICAgICAgcmV0dXJuIDFcbiAgICB9XG4gICAgcmV0dXJuIChhIDwgYikgPyAtMSA6IDFcbiAgfSlcbn1cblxuZnVuY3Rpb24gRGVjbGFyYXRpb24gKHRoaXNEZXAsIGNvbnRleHREZXAsIHByb3BEZXAsIGFwcGVuZCkge1xuICB0aGlzLnRoaXNEZXAgPSB0aGlzRGVwXG4gIHRoaXMuY29udGV4dERlcCA9IGNvbnRleHREZXBcbiAgdGhpcy5wcm9wRGVwID0gcHJvcERlcFxuICB0aGlzLmFwcGVuZCA9IGFwcGVuZFxufVxuXG5mdW5jdGlvbiBpc1N0YXRpYyAoZGVjbCkge1xuICByZXR1cm4gZGVjbCAmJiAhKGRlY2wudGhpc0RlcCB8fCBkZWNsLmNvbnRleHREZXAgfHwgZGVjbC5wcm9wRGVwKVxufVxuXG5mdW5jdGlvbiBjcmVhdGVTdGF0aWNEZWNsIChhcHBlbmQpIHtcbiAgcmV0dXJuIG5ldyBEZWNsYXJhdGlvbihmYWxzZSwgZmFsc2UsIGZhbHNlLCBhcHBlbmQpXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUR5bmFtaWNEZWNsIChkeW4sIGFwcGVuZCkge1xuICB2YXIgdHlwZSA9IGR5bi50eXBlXG4gIGlmICh0eXBlID09PSBEWU5fRlVOQyQxKSB7XG4gICAgdmFyIG51bUFyZ3MgPSBkeW4uZGF0YS5sZW5ndGhcbiAgICByZXR1cm4gbmV3IERlY2xhcmF0aW9uKFxuICAgICAgdHJ1ZSxcbiAgICAgIG51bUFyZ3MgPj0gMSxcbiAgICAgIG51bUFyZ3MgPj0gMixcbiAgICAgIGFwcGVuZClcbiAgfSBlbHNlIGlmICh0eXBlID09PSBEWU5fVEhVTkspIHtcbiAgICB2YXIgZGF0YSA9IGR5bi5kYXRhXG4gICAgcmV0dXJuIG5ldyBEZWNsYXJhdGlvbihcbiAgICAgIGRhdGEudGhpc0RlcCxcbiAgICAgIGRhdGEuY29udGV4dERlcCxcbiAgICAgIGRhdGEucHJvcERlcCxcbiAgICAgIGFwcGVuZClcbiAgfSBlbHNlIGlmICh0eXBlID09PSBEWU5fQ09OU1RBTlQkMSkge1xuICAgIHJldHVybiBuZXcgRGVjbGFyYXRpb24oXG4gICAgICBmYWxzZSxcbiAgICAgIGZhbHNlLFxuICAgICAgZmFsc2UsXG4gICAgICBhcHBlbmQpXG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gRFlOX0FSUkFZJDEpIHtcbiAgICB2YXIgdGhpc0RlcCA9IGZhbHNlXG4gICAgdmFyIGNvbnRleHREZXAgPSBmYWxzZVxuICAgIHZhciBwcm9wRGVwID0gZmFsc2VcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGR5bi5kYXRhLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgc3ViRHluID0gZHluLmRhdGFbaV1cbiAgICAgIGlmIChzdWJEeW4udHlwZSA9PT0gRFlOX1BST1AkMSkge1xuICAgICAgICBwcm9wRGVwID0gdHJ1ZVxuICAgICAgfSBlbHNlIGlmIChzdWJEeW4udHlwZSA9PT0gRFlOX0NPTlRFWFQkMSkge1xuICAgICAgICBjb250ZXh0RGVwID0gdHJ1ZVxuICAgICAgfSBlbHNlIGlmIChzdWJEeW4udHlwZSA9PT0gRFlOX1NUQVRFJDEpIHtcbiAgICAgICAgdGhpc0RlcCA9IHRydWVcbiAgICAgIH0gZWxzZSBpZiAoc3ViRHluLnR5cGUgPT09IERZTl9GVU5DJDEpIHtcbiAgICAgICAgdGhpc0RlcCA9IHRydWVcbiAgICAgICAgdmFyIHN1YkFyZ3MgPSBzdWJEeW4uZGF0YVxuICAgICAgICBpZiAoc3ViQXJncyA+PSAxKSB7XG4gICAgICAgICAgY29udGV4dERlcCA9IHRydWVcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3ViQXJncyA+PSAyKSB7XG4gICAgICAgICAgcHJvcERlcCA9IHRydWVcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChzdWJEeW4udHlwZSA9PT0gRFlOX1RIVU5LKSB7XG4gICAgICAgIHRoaXNEZXAgPSB0aGlzRGVwIHx8IHN1YkR5bi5kYXRhLnRoaXNEZXBcbiAgICAgICAgY29udGV4dERlcCA9IGNvbnRleHREZXAgfHwgc3ViRHluLmRhdGEuY29udGV4dERlcFxuICAgICAgICBwcm9wRGVwID0gcHJvcERlcCB8fCBzdWJEeW4uZGF0YS5wcm9wRGVwXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXcgRGVjbGFyYXRpb24oXG4gICAgICB0aGlzRGVwLFxuICAgICAgY29udGV4dERlcCxcbiAgICAgIHByb3BEZXAsXG4gICAgICBhcHBlbmQpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBEZWNsYXJhdGlvbihcbiAgICAgIHR5cGUgPT09IERZTl9TVEFURSQxLFxuICAgICAgdHlwZSA9PT0gRFlOX0NPTlRFWFQkMSxcbiAgICAgIHR5cGUgPT09IERZTl9QUk9QJDEsXG4gICAgICBhcHBlbmQpXG4gIH1cbn1cblxudmFyIFNDT1BFX0RFQ0wgPSBuZXcgRGVjbGFyYXRpb24oZmFsc2UsIGZhbHNlLCBmYWxzZSwgZnVuY3Rpb24gKCkge30pXG5cbmZ1bmN0aW9uIHJlZ2xDb3JlIChcbiAgZ2wsXG4gIHN0cmluZ1N0b3JlLFxuICBleHRlbnNpb25zLFxuICBsaW1pdHMsXG4gIGJ1ZmZlclN0YXRlLFxuICBlbGVtZW50U3RhdGUsXG4gIHRleHR1cmVTdGF0ZSxcbiAgZnJhbWVidWZmZXJTdGF0ZSxcbiAgdW5pZm9ybVN0YXRlLFxuICBhdHRyaWJ1dGVTdGF0ZSxcbiAgc2hhZGVyU3RhdGUsXG4gIGRyYXdTdGF0ZSxcbiAgY29udGV4dFN0YXRlLFxuICB0aW1lcixcbiAgY29uZmlnKSB7XG4gIHZhciBBdHRyaWJ1dGVSZWNvcmQgPSBhdHRyaWJ1dGVTdGF0ZS5SZWNvcmRcblxuICB2YXIgYmxlbmRFcXVhdGlvbnMgPSB7XG4gICAgJ2FkZCc6IDMyNzc0LFxuICAgICdzdWJ0cmFjdCc6IDMyNzc4LFxuICAgICdyZXZlcnNlIHN1YnRyYWN0JzogMzI3NzlcbiAgfVxuICBpZiAoZXh0ZW5zaW9ucy5leHRfYmxlbmRfbWlubWF4KSB7XG4gICAgYmxlbmRFcXVhdGlvbnMubWluID0gR0xfTUlOX0VYVFxuICAgIGJsZW5kRXF1YXRpb25zLm1heCA9IEdMX01BWF9FWFRcbiAgfVxuXG4gIHZhciBleHRJbnN0YW5jaW5nID0gZXh0ZW5zaW9ucy5hbmdsZV9pbnN0YW5jZWRfYXJyYXlzXG4gIHZhciBleHREcmF3QnVmZmVycyA9IGV4dGVuc2lvbnMud2ViZ2xfZHJhd19idWZmZXJzXG5cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyBXRUJHTCBTVEFURVxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIHZhciBjdXJyZW50U3RhdGUgPSB7XG4gICAgZGlydHk6IHRydWUsXG4gICAgcHJvZmlsZTogY29uZmlnLnByb2ZpbGVcbiAgfVxuICB2YXIgbmV4dFN0YXRlID0ge31cbiAgdmFyIEdMX1NUQVRFX05BTUVTID0gW11cbiAgdmFyIEdMX0ZMQUdTID0ge31cbiAgdmFyIEdMX1ZBUklBQkxFUyA9IHt9XG5cbiAgZnVuY3Rpb24gcHJvcE5hbWUgKG5hbWUpIHtcbiAgICByZXR1cm4gbmFtZS5yZXBsYWNlKCcuJywgJ18nKVxuICB9XG5cbiAgZnVuY3Rpb24gc3RhdGVGbGFnIChzbmFtZSwgY2FwLCBpbml0KSB7XG4gICAgdmFyIG5hbWUgPSBwcm9wTmFtZShzbmFtZSlcbiAgICBHTF9TVEFURV9OQU1FUy5wdXNoKHNuYW1lKVxuICAgIG5leHRTdGF0ZVtuYW1lXSA9IGN1cnJlbnRTdGF0ZVtuYW1lXSA9ICEhaW5pdFxuICAgIEdMX0ZMQUdTW25hbWVdID0gY2FwXG4gIH1cblxuICBmdW5jdGlvbiBzdGF0ZVZhcmlhYmxlIChzbmFtZSwgZnVuYywgaW5pdCkge1xuICAgIHZhciBuYW1lID0gcHJvcE5hbWUoc25hbWUpXG4gICAgR0xfU1RBVEVfTkFNRVMucHVzaChzbmFtZSlcbiAgICBpZiAoQXJyYXkuaXNBcnJheShpbml0KSkge1xuICAgICAgY3VycmVudFN0YXRlW25hbWVdID0gaW5pdC5zbGljZSgpXG4gICAgICBuZXh0U3RhdGVbbmFtZV0gPSBpbml0LnNsaWNlKClcbiAgICB9IGVsc2Uge1xuICAgICAgY3VycmVudFN0YXRlW25hbWVdID0gbmV4dFN0YXRlW25hbWVdID0gaW5pdFxuICAgIH1cbiAgICBHTF9WQVJJQUJMRVNbbmFtZV0gPSBmdW5jXG4gIH1cblxuICAvLyBEaXRoZXJpbmdcbiAgc3RhdGVGbGFnKFNfRElUSEVSLCBHTF9ESVRIRVIpXG5cbiAgLy8gQmxlbmRpbmdcbiAgc3RhdGVGbGFnKFNfQkxFTkRfRU5BQkxFLCBHTF9CTEVORClcbiAgc3RhdGVWYXJpYWJsZShTX0JMRU5EX0NPTE9SLCAnYmxlbmRDb2xvcicsIFswLCAwLCAwLCAwXSlcbiAgc3RhdGVWYXJpYWJsZShTX0JMRU5EX0VRVUFUSU9OLCAnYmxlbmRFcXVhdGlvblNlcGFyYXRlJyxcbiAgICBbR0xfRlVOQ19BREQsIEdMX0ZVTkNfQUREXSlcbiAgc3RhdGVWYXJpYWJsZShTX0JMRU5EX0ZVTkMsICdibGVuZEZ1bmNTZXBhcmF0ZScsXG4gICAgW0dMX09ORSwgR0xfWkVSTywgR0xfT05FLCBHTF9aRVJPXSlcblxuICAvLyBEZXB0aFxuICBzdGF0ZUZsYWcoU19ERVBUSF9FTkFCTEUsIEdMX0RFUFRIX1RFU1QsIHRydWUpXG4gIHN0YXRlVmFyaWFibGUoU19ERVBUSF9GVU5DLCAnZGVwdGhGdW5jJywgR0xfTEVTUylcbiAgc3RhdGVWYXJpYWJsZShTX0RFUFRIX1JBTkdFLCAnZGVwdGhSYW5nZScsIFswLCAxXSlcbiAgc3RhdGVWYXJpYWJsZShTX0RFUFRIX01BU0ssICdkZXB0aE1hc2snLCB0cnVlKVxuXG4gIC8vIENvbG9yIG1hc2tcbiAgc3RhdGVWYXJpYWJsZShTX0NPTE9SX01BU0ssIFNfQ09MT1JfTUFTSywgW3RydWUsIHRydWUsIHRydWUsIHRydWVdKVxuXG4gIC8vIEZhY2UgY3VsbGluZ1xuICBzdGF0ZUZsYWcoU19DVUxMX0VOQUJMRSwgR0xfQ1VMTF9GQUNFKVxuICBzdGF0ZVZhcmlhYmxlKFNfQ1VMTF9GQUNFLCAnY3VsbEZhY2UnLCBHTF9CQUNLKVxuXG4gIC8vIEZyb250IGZhY2Ugb3JpZW50YXRpb25cbiAgc3RhdGVWYXJpYWJsZShTX0ZST05UX0ZBQ0UsIFNfRlJPTlRfRkFDRSwgR0xfQ0NXKVxuXG4gIC8vIExpbmUgd2lkdGhcbiAgc3RhdGVWYXJpYWJsZShTX0xJTkVfV0lEVEgsIFNfTElORV9XSURUSCwgMSlcblxuICAvLyBQb2x5Z29uIG9mZnNldFxuICBzdGF0ZUZsYWcoU19QT0xZR09OX09GRlNFVF9FTkFCTEUsIEdMX1BPTFlHT05fT0ZGU0VUX0ZJTEwpXG4gIHN0YXRlVmFyaWFibGUoU19QT0xZR09OX09GRlNFVF9PRkZTRVQsICdwb2x5Z29uT2Zmc2V0JywgWzAsIDBdKVxuXG4gIC8vIFNhbXBsZSBjb3ZlcmFnZVxuICBzdGF0ZUZsYWcoU19TQU1QTEVfQUxQSEEsIEdMX1NBTVBMRV9BTFBIQV9UT19DT1ZFUkFHRSlcbiAgc3RhdGVGbGFnKFNfU0FNUExFX0VOQUJMRSwgR0xfU0FNUExFX0NPVkVSQUdFKVxuICBzdGF0ZVZhcmlhYmxlKFNfU0FNUExFX0NPVkVSQUdFLCAnc2FtcGxlQ292ZXJhZ2UnLCBbMSwgZmFsc2VdKVxuXG4gIC8vIFN0ZW5jaWxcbiAgc3RhdGVGbGFnKFNfU1RFTkNJTF9FTkFCTEUsIEdMX1NURU5DSUxfVEVTVClcbiAgc3RhdGVWYXJpYWJsZShTX1NURU5DSUxfTUFTSywgJ3N0ZW5jaWxNYXNrJywgLTEpXG4gIHN0YXRlVmFyaWFibGUoU19TVEVOQ0lMX0ZVTkMsICdzdGVuY2lsRnVuYycsIFtHTF9BTFdBWVMsIDAsIC0xXSlcbiAgc3RhdGVWYXJpYWJsZShTX1NURU5DSUxfT1BGUk9OVCwgJ3N0ZW5jaWxPcFNlcGFyYXRlJyxcbiAgICBbR0xfRlJPTlQsIEdMX0tFRVAsIEdMX0tFRVAsIEdMX0tFRVBdKVxuICBzdGF0ZVZhcmlhYmxlKFNfU1RFTkNJTF9PUEJBQ0ssICdzdGVuY2lsT3BTZXBhcmF0ZScsXG4gICAgW0dMX0JBQ0ssIEdMX0tFRVAsIEdMX0tFRVAsIEdMX0tFRVBdKVxuXG4gIC8vIFNjaXNzb3JcbiAgc3RhdGVGbGFnKFNfU0NJU1NPUl9FTkFCTEUsIEdMX1NDSVNTT1JfVEVTVClcbiAgc3RhdGVWYXJpYWJsZShTX1NDSVNTT1JfQk9YLCAnc2Npc3NvcicsXG4gICAgWzAsIDAsIGdsLmRyYXdpbmdCdWZmZXJXaWR0aCwgZ2wuZHJhd2luZ0J1ZmZlckhlaWdodF0pXG5cbiAgLy8gVmlld3BvcnRcbiAgc3RhdGVWYXJpYWJsZShTX1ZJRVdQT1JULCBTX1ZJRVdQT1JULFxuICAgIFswLCAwLCBnbC5kcmF3aW5nQnVmZmVyV2lkdGgsIGdsLmRyYXdpbmdCdWZmZXJIZWlnaHRdKVxuXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8gRU5WSVJPTk1FTlRcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICB2YXIgc2hhcmVkU3RhdGUgPSB7XG4gICAgZ2w6IGdsLFxuICAgIGNvbnRleHQ6IGNvbnRleHRTdGF0ZSxcbiAgICBzdHJpbmdzOiBzdHJpbmdTdG9yZSxcbiAgICBuZXh0OiBuZXh0U3RhdGUsXG4gICAgY3VycmVudDogY3VycmVudFN0YXRlLFxuICAgIGRyYXc6IGRyYXdTdGF0ZSxcbiAgICBlbGVtZW50czogZWxlbWVudFN0YXRlLFxuICAgIGJ1ZmZlcjogYnVmZmVyU3RhdGUsXG4gICAgc2hhZGVyOiBzaGFkZXJTdGF0ZSxcbiAgICBhdHRyaWJ1dGVzOiBhdHRyaWJ1dGVTdGF0ZS5zdGF0ZSxcbiAgICB2YW86IGF0dHJpYnV0ZVN0YXRlLFxuICAgIHVuaWZvcm1zOiB1bmlmb3JtU3RhdGUsXG4gICAgZnJhbWVidWZmZXI6IGZyYW1lYnVmZmVyU3RhdGUsXG4gICAgZXh0ZW5zaW9uczogZXh0ZW5zaW9ucyxcblxuICAgIHRpbWVyOiB0aW1lcixcbiAgICBpc0J1ZmZlckFyZ3M6IGlzQnVmZmVyQXJnc1xuICB9XG5cbiAgdmFyIHNoYXJlZENvbnN0YW50cyA9IHtcbiAgICBwcmltVHlwZXM6IHByaW1UeXBlcyxcbiAgICBjb21wYXJlRnVuY3M6IGNvbXBhcmVGdW5jcyxcbiAgICBibGVuZEZ1bmNzOiBibGVuZEZ1bmNzLFxuICAgIGJsZW5kRXF1YXRpb25zOiBibGVuZEVxdWF0aW9ucyxcbiAgICBzdGVuY2lsT3BzOiBzdGVuY2lsT3BzLFxuICAgIGdsVHlwZXM6IGdsVHlwZXMsXG4gICAgb3JpZW50YXRpb25UeXBlOiBvcmllbnRhdGlvblR5cGVcbiAgfVxuXG4gIGNoZWNrJDEub3B0aW9uYWwoZnVuY3Rpb24gKCkge1xuICAgIHNoYXJlZFN0YXRlLmlzQXJyYXlMaWtlID0gaXNBcnJheUxpa2VcbiAgfSlcblxuICBpZiAoZXh0RHJhd0J1ZmZlcnMpIHtcbiAgICBzaGFyZWRDb25zdGFudHMuYmFja0J1ZmZlciA9IFtHTF9CQUNLXVxuICAgIHNoYXJlZENvbnN0YW50cy5kcmF3QnVmZmVyID0gbG9vcChsaW1pdHMubWF4RHJhd2J1ZmZlcnMsIGZ1bmN0aW9uIChpKSB7XG4gICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gWzBdXG4gICAgICB9XG4gICAgICByZXR1cm4gbG9vcChpLCBmdW5jdGlvbiAoaikge1xuICAgICAgICByZXR1cm4gR0xfQ09MT1JfQVRUQUNITUVOVDAkMiArIGpcbiAgICAgIH0pXG4gICAgfSlcbiAgfVxuXG4gIHZhciBkcmF3Q2FsbENvdW50ZXIgPSAwXG4gIGZ1bmN0aW9uIGNyZWF0ZVJFR0xFbnZpcm9ubWVudCAoKSB7XG4gICAgdmFyIGVudiA9IGNyZWF0ZUVudmlyb25tZW50KClcbiAgICB2YXIgbGluayA9IGVudi5saW5rXG4gICAgdmFyIGdsb2JhbCA9IGVudi5nbG9iYWxcbiAgICBlbnYuaWQgPSBkcmF3Q2FsbENvdW50ZXIrK1xuXG4gICAgZW52LmJhdGNoSWQgPSAnMCdcblxuICAgIC8vIGxpbmsgc2hhcmVkIHN0YXRlXG4gICAgdmFyIFNIQVJFRCA9IGxpbmsoc2hhcmVkU3RhdGUpXG4gICAgdmFyIHNoYXJlZCA9IGVudi5zaGFyZWQgPSB7XG4gICAgICBwcm9wczogJ2EwJ1xuICAgIH1cbiAgICBPYmplY3Qua2V5cyhzaGFyZWRTdGF0ZSkuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgICAgc2hhcmVkW3Byb3BdID0gZ2xvYmFsLmRlZihTSEFSRUQsICcuJywgcHJvcClcbiAgICB9KVxuXG4gICAgLy8gSW5qZWN0IHJ1bnRpbWUgYXNzZXJ0aW9uIHN0dWZmIGZvciBkZWJ1ZyBidWlsZHNcbiAgICBjaGVjayQxLm9wdGlvbmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgIGVudi5DSEVDSyA9IGxpbmsoY2hlY2skMSlcbiAgICAgIGVudi5jb21tYW5kU3RyID0gY2hlY2skMS5ndWVzc0NvbW1hbmQoKVxuICAgICAgZW52LmNvbW1hbmQgPSBsaW5rKGVudi5jb21tYW5kU3RyKVxuICAgICAgZW52LmFzc2VydCA9IGZ1bmN0aW9uIChibG9jaywgcHJlZCwgbWVzc2FnZSkge1xuICAgICAgICBibG9jayhcbiAgICAgICAgICAnaWYoISgnLCBwcmVkLCAnKSknLFxuICAgICAgICAgIHRoaXMuQ0hFQ0ssICcuY29tbWFuZFJhaXNlKCcsIGxpbmsobWVzc2FnZSksICcsJywgdGhpcy5jb21tYW5kLCAnKTsnKVxuICAgICAgfVxuXG4gICAgICBzaGFyZWRDb25zdGFudHMuaW52YWxpZEJsZW5kQ29tYmluYXRpb25zID0gaW52YWxpZEJsZW5kQ29tYmluYXRpb25zXG4gICAgfSlcblxuICAgIC8vIENvcHkgR0wgc3RhdGUgdmFyaWFibGVzIG92ZXJcbiAgICB2YXIgbmV4dFZhcnMgPSBlbnYubmV4dCA9IHt9XG4gICAgdmFyIGN1cnJlbnRWYXJzID0gZW52LmN1cnJlbnQgPSB7fVxuICAgIE9iamVjdC5rZXlzKEdMX1ZBUklBQkxFUykuZm9yRWFjaChmdW5jdGlvbiAodmFyaWFibGUpIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGN1cnJlbnRTdGF0ZVt2YXJpYWJsZV0pKSB7XG4gICAgICAgIG5leHRWYXJzW3ZhcmlhYmxlXSA9IGdsb2JhbC5kZWYoc2hhcmVkLm5leHQsICcuJywgdmFyaWFibGUpXG4gICAgICAgIGN1cnJlbnRWYXJzW3ZhcmlhYmxlXSA9IGdsb2JhbC5kZWYoc2hhcmVkLmN1cnJlbnQsICcuJywgdmFyaWFibGUpXG4gICAgICB9XG4gICAgfSlcblxuICAgIC8vIEluaXRpYWxpemUgc2hhcmVkIGNvbnN0YW50c1xuICAgIHZhciBjb25zdGFudHMgPSBlbnYuY29uc3RhbnRzID0ge31cbiAgICBPYmplY3Qua2V5cyhzaGFyZWRDb25zdGFudHMpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIGNvbnN0YW50c1tuYW1lXSA9IGdsb2JhbC5kZWYoSlNPTi5zdHJpbmdpZnkoc2hhcmVkQ29uc3RhbnRzW25hbWVdKSlcbiAgICB9KVxuXG4gICAgLy8gSGVscGVyIGZ1bmN0aW9uIGZvciBjYWxsaW5nIGEgYmxvY2tcbiAgICBlbnYuaW52b2tlID0gZnVuY3Rpb24gKGJsb2NrLCB4KSB7XG4gICAgICBzd2l0Y2ggKHgudHlwZSkge1xuICAgICAgICBjYXNlIERZTl9GVU5DJDE6XG4gICAgICAgICAgdmFyIGFyZ0xpc3QgPSBbXG4gICAgICAgICAgICAndGhpcycsXG4gICAgICAgICAgICBzaGFyZWQuY29udGV4dCxcbiAgICAgICAgICAgIHNoYXJlZC5wcm9wcyxcbiAgICAgICAgICAgIGVudi5iYXRjaElkXG4gICAgICAgICAgXVxuICAgICAgICAgIHJldHVybiBibG9jay5kZWYoXG4gICAgICAgICAgICBsaW5rKHguZGF0YSksICcuY2FsbCgnLFxuICAgICAgICAgICAgYXJnTGlzdC5zbGljZSgwLCBNYXRoLm1heCh4LmRhdGEubGVuZ3RoICsgMSwgNCkpLFxuICAgICAgICAgICAgJyknKVxuICAgICAgICBjYXNlIERZTl9QUk9QJDE6XG4gICAgICAgICAgcmV0dXJuIGJsb2NrLmRlZihzaGFyZWQucHJvcHMsIHguZGF0YSlcbiAgICAgICAgY2FzZSBEWU5fQ09OVEVYVCQxOlxuICAgICAgICAgIHJldHVybiBibG9jay5kZWYoc2hhcmVkLmNvbnRleHQsIHguZGF0YSlcbiAgICAgICAgY2FzZSBEWU5fU1RBVEUkMTpcbiAgICAgICAgICByZXR1cm4gYmxvY2suZGVmKCd0aGlzJywgeC5kYXRhKVxuICAgICAgICBjYXNlIERZTl9USFVOSzpcbiAgICAgICAgICB4LmRhdGEuYXBwZW5kKGVudiwgYmxvY2spXG4gICAgICAgICAgcmV0dXJuIHguZGF0YS5yZWZcbiAgICAgICAgY2FzZSBEWU5fQ09OU1RBTlQkMTpcbiAgICAgICAgICByZXR1cm4geC5kYXRhLnRvU3RyaW5nKClcbiAgICAgICAgY2FzZSBEWU5fQVJSQVkkMTpcbiAgICAgICAgICByZXR1cm4geC5kYXRhLm1hcChmdW5jdGlvbiAoeSkge1xuICAgICAgICAgICAgcmV0dXJuIGVudi5pbnZva2UoYmxvY2ssIHkpXG4gICAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICBlbnYuYXR0cmliQ2FjaGUgPSB7fVxuXG4gICAgdmFyIHNjb3BlQXR0cmlicyA9IHt9XG4gICAgZW52LnNjb3BlQXR0cmliID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIHZhciBpZCA9IHN0cmluZ1N0b3JlLmlkKG5hbWUpXG4gICAgICBpZiAoaWQgaW4gc2NvcGVBdHRyaWJzKSB7XG4gICAgICAgIHJldHVybiBzY29wZUF0dHJpYnNbaWRdXG4gICAgICB9XG4gICAgICB2YXIgYmluZGluZyA9IGF0dHJpYnV0ZVN0YXRlLnNjb3BlW2lkXVxuICAgICAgaWYgKCFiaW5kaW5nKSB7XG4gICAgICAgIGJpbmRpbmcgPSBhdHRyaWJ1dGVTdGF0ZS5zY29wZVtpZF0gPSBuZXcgQXR0cmlidXRlUmVjb3JkKClcbiAgICAgIH1cbiAgICAgIHZhciByZXN1bHQgPSBzY29wZUF0dHJpYnNbaWRdID0gbGluayhiaW5kaW5nKVxuICAgICAgcmV0dXJuIHJlc3VsdFxuICAgIH1cblxuICAgIHJldHVybiBlbnZcbiAgfVxuXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8gUEFSU0lOR1xuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIGZ1bmN0aW9uIHBhcnNlUHJvZmlsZSAob3B0aW9ucykge1xuICAgIHZhciBzdGF0aWNPcHRpb25zID0gb3B0aW9ucy5zdGF0aWNcbiAgICB2YXIgZHluYW1pY09wdGlvbnMgPSBvcHRpb25zLmR5bmFtaWNcblxuICAgIHZhciBwcm9maWxlRW5hYmxlXG4gICAgaWYgKFNfUFJPRklMRSBpbiBzdGF0aWNPcHRpb25zKSB7XG4gICAgICB2YXIgdmFsdWUgPSAhIXN0YXRpY09wdGlvbnNbU19QUk9GSUxFXVxuICAgICAgcHJvZmlsZUVuYWJsZSA9IGNyZWF0ZVN0YXRpY0RlY2woZnVuY3Rpb24gKGVudiwgc2NvcGUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlXG4gICAgICB9KVxuICAgICAgcHJvZmlsZUVuYWJsZS5lbmFibGUgPSB2YWx1ZVxuICAgIH0gZWxzZSBpZiAoU19QUk9GSUxFIGluIGR5bmFtaWNPcHRpb25zKSB7XG4gICAgICB2YXIgZHluID0gZHluYW1pY09wdGlvbnNbU19QUk9GSUxFXVxuICAgICAgcHJvZmlsZUVuYWJsZSA9IGNyZWF0ZUR5bmFtaWNEZWNsKGR5biwgZnVuY3Rpb24gKGVudiwgc2NvcGUpIHtcbiAgICAgICAgcmV0dXJuIGVudi5pbnZva2Uoc2NvcGUsIGR5bilcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgcmV0dXJuIHByb2ZpbGVFbmFibGVcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlRnJhbWVidWZmZXIgKG9wdGlvbnMsIGVudikge1xuICAgIHZhciBzdGF0aWNPcHRpb25zID0gb3B0aW9ucy5zdGF0aWNcbiAgICB2YXIgZHluYW1pY09wdGlvbnMgPSBvcHRpb25zLmR5bmFtaWNcblxuICAgIGlmIChTX0ZSQU1FQlVGRkVSIGluIHN0YXRpY09wdGlvbnMpIHtcbiAgICAgIHZhciBmcmFtZWJ1ZmZlciA9IHN0YXRpY09wdGlvbnNbU19GUkFNRUJVRkZFUl1cbiAgICAgIGlmIChmcmFtZWJ1ZmZlcikge1xuICAgICAgICBmcmFtZWJ1ZmZlciA9IGZyYW1lYnVmZmVyU3RhdGUuZ2V0RnJhbWVidWZmZXIoZnJhbWVidWZmZXIpXG4gICAgICAgIGNoZWNrJDEuY29tbWFuZChmcmFtZWJ1ZmZlciwgJ2ludmFsaWQgZnJhbWVidWZmZXIgb2JqZWN0JylcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVN0YXRpY0RlY2woZnVuY3Rpb24gKGVudiwgYmxvY2spIHtcbiAgICAgICAgICB2YXIgRlJBTUVCVUZGRVIgPSBlbnYubGluayhmcmFtZWJ1ZmZlcilcbiAgICAgICAgICB2YXIgc2hhcmVkID0gZW52LnNoYXJlZFxuICAgICAgICAgIGJsb2NrLnNldChcbiAgICAgICAgICAgIHNoYXJlZC5mcmFtZWJ1ZmZlcixcbiAgICAgICAgICAgICcubmV4dCcsXG4gICAgICAgICAgICBGUkFNRUJVRkZFUilcbiAgICAgICAgICB2YXIgQ09OVEVYVCA9IHNoYXJlZC5jb250ZXh0XG4gICAgICAgICAgYmxvY2suc2V0KFxuICAgICAgICAgICAgQ09OVEVYVCxcbiAgICAgICAgICAgICcuJyArIFNfRlJBTUVCVUZGRVJfV0lEVEgsXG4gICAgICAgICAgICBGUkFNRUJVRkZFUiArICcud2lkdGgnKVxuICAgICAgICAgIGJsb2NrLnNldChcbiAgICAgICAgICAgIENPTlRFWFQsXG4gICAgICAgICAgICAnLicgKyBTX0ZSQU1FQlVGRkVSX0hFSUdIVCxcbiAgICAgICAgICAgIEZSQU1FQlVGRkVSICsgJy5oZWlnaHQnKVxuICAgICAgICAgIHJldHVybiBGUkFNRUJVRkZFUlxuICAgICAgICB9KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVN0YXRpY0RlY2woZnVuY3Rpb24gKGVudiwgc2NvcGUpIHtcbiAgICAgICAgICB2YXIgc2hhcmVkID0gZW52LnNoYXJlZFxuICAgICAgICAgIHNjb3BlLnNldChcbiAgICAgICAgICAgIHNoYXJlZC5mcmFtZWJ1ZmZlcixcbiAgICAgICAgICAgICcubmV4dCcsXG4gICAgICAgICAgICAnbnVsbCcpXG4gICAgICAgICAgdmFyIENPTlRFWFQgPSBzaGFyZWQuY29udGV4dFxuICAgICAgICAgIHNjb3BlLnNldChcbiAgICAgICAgICAgIENPTlRFWFQsXG4gICAgICAgICAgICAnLicgKyBTX0ZSQU1FQlVGRkVSX1dJRFRILFxuICAgICAgICAgICAgQ09OVEVYVCArICcuJyArIFNfRFJBV0lOR0JVRkZFUl9XSURUSClcbiAgICAgICAgICBzY29wZS5zZXQoXG4gICAgICAgICAgICBDT05URVhULFxuICAgICAgICAgICAgJy4nICsgU19GUkFNRUJVRkZFUl9IRUlHSFQsXG4gICAgICAgICAgICBDT05URVhUICsgJy4nICsgU19EUkFXSU5HQlVGRkVSX0hFSUdIVClcbiAgICAgICAgICByZXR1cm4gJ251bGwnXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChTX0ZSQU1FQlVGRkVSIGluIGR5bmFtaWNPcHRpb25zKSB7XG4gICAgICB2YXIgZHluID0gZHluYW1pY09wdGlvbnNbU19GUkFNRUJVRkZFUl1cbiAgICAgIHJldHVybiBjcmVhdGVEeW5hbWljRGVjbChkeW4sIGZ1bmN0aW9uIChlbnYsIHNjb3BlKSB7XG4gICAgICAgIHZhciBGUkFNRUJVRkZFUl9GVU5DID0gZW52Lmludm9rZShzY29wZSwgZHluKVxuICAgICAgICB2YXIgc2hhcmVkID0gZW52LnNoYXJlZFxuICAgICAgICB2YXIgRlJBTUVCVUZGRVJfU1RBVEUgPSBzaGFyZWQuZnJhbWVidWZmZXJcbiAgICAgICAgdmFyIEZSQU1FQlVGRkVSID0gc2NvcGUuZGVmKFxuICAgICAgICAgIEZSQU1FQlVGRkVSX1NUQVRFLCAnLmdldEZyYW1lYnVmZmVyKCcsIEZSQU1FQlVGRkVSX0ZVTkMsICcpJylcblxuICAgICAgICBjaGVjayQxLm9wdGlvbmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBlbnYuYXNzZXJ0KHNjb3BlLFxuICAgICAgICAgICAgJyEnICsgRlJBTUVCVUZGRVJfRlVOQyArICd8fCcgKyBGUkFNRUJVRkZFUixcbiAgICAgICAgICAgICdpbnZhbGlkIGZyYW1lYnVmZmVyIG9iamVjdCcpXG4gICAgICAgIH0pXG5cbiAgICAgICAgc2NvcGUuc2V0KFxuICAgICAgICAgIEZSQU1FQlVGRkVSX1NUQVRFLFxuICAgICAgICAgICcubmV4dCcsXG4gICAgICAgICAgRlJBTUVCVUZGRVIpXG4gICAgICAgIHZhciBDT05URVhUID0gc2hhcmVkLmNvbnRleHRcbiAgICAgICAgc2NvcGUuc2V0KFxuICAgICAgICAgIENPTlRFWFQsXG4gICAgICAgICAgJy4nICsgU19GUkFNRUJVRkZFUl9XSURUSCxcbiAgICAgICAgICBGUkFNRUJVRkZFUiArICc/JyArIEZSQU1FQlVGRkVSICsgJy53aWR0aDonICtcbiAgICAgICAgICBDT05URVhUICsgJy4nICsgU19EUkFXSU5HQlVGRkVSX1dJRFRIKVxuICAgICAgICBzY29wZS5zZXQoXG4gICAgICAgICAgQ09OVEVYVCxcbiAgICAgICAgICAnLicgKyBTX0ZSQU1FQlVGRkVSX0hFSUdIVCxcbiAgICAgICAgICBGUkFNRUJVRkZFUiArXG4gICAgICAgICAgJz8nICsgRlJBTUVCVUZGRVIgKyAnLmhlaWdodDonICtcbiAgICAgICAgICBDT05URVhUICsgJy4nICsgU19EUkFXSU5HQlVGRkVSX0hFSUdIVClcbiAgICAgICAgcmV0dXJuIEZSQU1FQlVGRkVSXG4gICAgICB9KVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlVmlld3BvcnRTY2lzc29yIChvcHRpb25zLCBmcmFtZWJ1ZmZlciwgZW52KSB7XG4gICAgdmFyIHN0YXRpY09wdGlvbnMgPSBvcHRpb25zLnN0YXRpY1xuICAgIHZhciBkeW5hbWljT3B0aW9ucyA9IG9wdGlvbnMuZHluYW1pY1xuXG4gICAgZnVuY3Rpb24gcGFyc2VCb3ggKHBhcmFtKSB7XG4gICAgICBpZiAocGFyYW0gaW4gc3RhdGljT3B0aW9ucykge1xuICAgICAgICB2YXIgYm94ID0gc3RhdGljT3B0aW9uc1twYXJhbV1cbiAgICAgICAgY2hlY2skMS5jb21tYW5kVHlwZShib3gsICdvYmplY3QnLCAnaW52YWxpZCAnICsgcGFyYW0sIGVudi5jb21tYW5kU3RyKVxuXG4gICAgICAgIHZhciBpc1N0YXRpYyA9IHRydWVcbiAgICAgICAgdmFyIHggPSBib3gueCB8IDBcbiAgICAgICAgdmFyIHkgPSBib3gueSB8IDBcbiAgICAgICAgdmFyIHcsIGhcbiAgICAgICAgaWYgKCd3aWR0aCcgaW4gYm94KSB7XG4gICAgICAgICAgdyA9IGJveC53aWR0aCB8IDBcbiAgICAgICAgICBjaGVjayQxLmNvbW1hbmQodyA+PSAwLCAnaW52YWxpZCAnICsgcGFyYW0sIGVudi5jb21tYW5kU3RyKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlzU3RhdGljID0gZmFsc2VcbiAgICAgICAgfVxuICAgICAgICBpZiAoJ2hlaWdodCcgaW4gYm94KSB7XG4gICAgICAgICAgaCA9IGJveC5oZWlnaHQgfCAwXG4gICAgICAgICAgY2hlY2skMS5jb21tYW5kKGggPj0gMCwgJ2ludmFsaWQgJyArIHBhcmFtLCBlbnYuY29tbWFuZFN0cilcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpc1N0YXRpYyA9IGZhbHNlXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3IERlY2xhcmF0aW9uKFxuICAgICAgICAgICFpc1N0YXRpYyAmJiBmcmFtZWJ1ZmZlciAmJiBmcmFtZWJ1ZmZlci50aGlzRGVwLFxuICAgICAgICAgICFpc1N0YXRpYyAmJiBmcmFtZWJ1ZmZlciAmJiBmcmFtZWJ1ZmZlci5jb250ZXh0RGVwLFxuICAgICAgICAgICFpc1N0YXRpYyAmJiBmcmFtZWJ1ZmZlciAmJiBmcmFtZWJ1ZmZlci5wcm9wRGVwLFxuICAgICAgICAgIGZ1bmN0aW9uIChlbnYsIHNjb3BlKSB7XG4gICAgICAgICAgICB2YXIgQ09OVEVYVCA9IGVudi5zaGFyZWQuY29udGV4dFxuICAgICAgICAgICAgdmFyIEJPWF9XID0gd1xuICAgICAgICAgICAgaWYgKCEoJ3dpZHRoJyBpbiBib3gpKSB7XG4gICAgICAgICAgICAgIEJPWF9XID0gc2NvcGUuZGVmKENPTlRFWFQsICcuJywgU19GUkFNRUJVRkZFUl9XSURUSCwgJy0nLCB4KVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIEJPWF9IID0gaFxuICAgICAgICAgICAgaWYgKCEoJ2hlaWdodCcgaW4gYm94KSkge1xuICAgICAgICAgICAgICBCT1hfSCA9IHNjb3BlLmRlZihDT05URVhULCAnLicsIFNfRlJBTUVCVUZGRVJfSEVJR0hULCAnLScsIHkpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gW3gsIHksIEJPWF9XLCBCT1hfSF1cbiAgICAgICAgICB9KVxuICAgICAgfSBlbHNlIGlmIChwYXJhbSBpbiBkeW5hbWljT3B0aW9ucykge1xuICAgICAgICB2YXIgZHluQm94ID0gZHluYW1pY09wdGlvbnNbcGFyYW1dXG4gICAgICAgIHZhciByZXN1bHQgPSBjcmVhdGVEeW5hbWljRGVjbChkeW5Cb3gsIGZ1bmN0aW9uIChlbnYsIHNjb3BlKSB7XG4gICAgICAgICAgdmFyIEJPWCA9IGVudi5pbnZva2Uoc2NvcGUsIGR5bkJveClcblxuICAgICAgICAgIGNoZWNrJDEub3B0aW9uYWwoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZW52LmFzc2VydChzY29wZSxcbiAgICAgICAgICAgICAgQk9YICsgJyYmdHlwZW9mICcgKyBCT1ggKyAnPT09XCJvYmplY3RcIicsXG4gICAgICAgICAgICAgICdpbnZhbGlkICcgKyBwYXJhbSlcbiAgICAgICAgICB9KVxuXG4gICAgICAgICAgdmFyIENPTlRFWFQgPSBlbnYuc2hhcmVkLmNvbnRleHRcbiAgICAgICAgICB2YXIgQk9YX1ggPSBzY29wZS5kZWYoQk9YLCAnLnh8MCcpXG4gICAgICAgICAgdmFyIEJPWF9ZID0gc2NvcGUuZGVmKEJPWCwgJy55fDAnKVxuICAgICAgICAgIHZhciBCT1hfVyA9IHNjb3BlLmRlZihcbiAgICAgICAgICAgICdcIndpZHRoXCIgaW4gJywgQk9YLCAnPycsIEJPWCwgJy53aWR0aHwwOicsXG4gICAgICAgICAgICAnKCcsIENPTlRFWFQsICcuJywgU19GUkFNRUJVRkZFUl9XSURUSCwgJy0nLCBCT1hfWCwgJyknKVxuICAgICAgICAgIHZhciBCT1hfSCA9IHNjb3BlLmRlZihcbiAgICAgICAgICAgICdcImhlaWdodFwiIGluICcsIEJPWCwgJz8nLCBCT1gsICcuaGVpZ2h0fDA6JyxcbiAgICAgICAgICAgICcoJywgQ09OVEVYVCwgJy4nLCBTX0ZSQU1FQlVGRkVSX0hFSUdIVCwgJy0nLCBCT1hfWSwgJyknKVxuXG4gICAgICAgICAgY2hlY2skMS5vcHRpb25hbChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBlbnYuYXNzZXJ0KHNjb3BlLFxuICAgICAgICAgICAgICBCT1hfVyArICc+PTAmJicgK1xuICAgICAgICAgICAgICBCT1hfSCArICc+PTAnLFxuICAgICAgICAgICAgICAnaW52YWxpZCAnICsgcGFyYW0pXG4gICAgICAgICAgfSlcblxuICAgICAgICAgIHJldHVybiBbQk9YX1gsIEJPWF9ZLCBCT1hfVywgQk9YX0hdXG4gICAgICAgIH0pXG4gICAgICAgIGlmIChmcmFtZWJ1ZmZlcikge1xuICAgICAgICAgIHJlc3VsdC50aGlzRGVwID0gcmVzdWx0LnRoaXNEZXAgfHwgZnJhbWVidWZmZXIudGhpc0RlcFxuICAgICAgICAgIHJlc3VsdC5jb250ZXh0RGVwID0gcmVzdWx0LmNvbnRleHREZXAgfHwgZnJhbWVidWZmZXIuY29udGV4dERlcFxuICAgICAgICAgIHJlc3VsdC5wcm9wRGVwID0gcmVzdWx0LnByb3BEZXAgfHwgZnJhbWVidWZmZXIucHJvcERlcFxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHRcbiAgICAgIH0gZWxzZSBpZiAoZnJhbWVidWZmZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEZWNsYXJhdGlvbihcbiAgICAgICAgICBmcmFtZWJ1ZmZlci50aGlzRGVwLFxuICAgICAgICAgIGZyYW1lYnVmZmVyLmNvbnRleHREZXAsXG4gICAgICAgICAgZnJhbWVidWZmZXIucHJvcERlcCxcbiAgICAgICAgICBmdW5jdGlvbiAoZW52LCBzY29wZSkge1xuICAgICAgICAgICAgdmFyIENPTlRFWFQgPSBlbnYuc2hhcmVkLmNvbnRleHRcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgIDAsIDAsXG4gICAgICAgICAgICAgIHNjb3BlLmRlZihDT05URVhULCAnLicsIFNfRlJBTUVCVUZGRVJfV0lEVEgpLFxuICAgICAgICAgICAgICBzY29wZS5kZWYoQ09OVEVYVCwgJy4nLCBTX0ZSQU1FQlVGRkVSX0hFSUdIVCldXG4gICAgICAgICAgfSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBudWxsXG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHZpZXdwb3J0ID0gcGFyc2VCb3goU19WSUVXUE9SVClcblxuICAgIGlmICh2aWV3cG9ydCkge1xuICAgICAgdmFyIHByZXZWaWV3cG9ydCA9IHZpZXdwb3J0XG4gICAgICB2aWV3cG9ydCA9IG5ldyBEZWNsYXJhdGlvbihcbiAgICAgICAgdmlld3BvcnQudGhpc0RlcCxcbiAgICAgICAgdmlld3BvcnQuY29udGV4dERlcCxcbiAgICAgICAgdmlld3BvcnQucHJvcERlcCxcbiAgICAgICAgZnVuY3Rpb24gKGVudiwgc2NvcGUpIHtcbiAgICAgICAgICB2YXIgVklFV1BPUlQgPSBwcmV2Vmlld3BvcnQuYXBwZW5kKGVudiwgc2NvcGUpXG4gICAgICAgICAgdmFyIENPTlRFWFQgPSBlbnYuc2hhcmVkLmNvbnRleHRcbiAgICAgICAgICBzY29wZS5zZXQoXG4gICAgICAgICAgICBDT05URVhULFxuICAgICAgICAgICAgJy4nICsgU19WSUVXUE9SVF9XSURUSCxcbiAgICAgICAgICAgIFZJRVdQT1JUWzJdKVxuICAgICAgICAgIHNjb3BlLnNldChcbiAgICAgICAgICAgIENPTlRFWFQsXG4gICAgICAgICAgICAnLicgKyBTX1ZJRVdQT1JUX0hFSUdIVCxcbiAgICAgICAgICAgIFZJRVdQT1JUWzNdKVxuICAgICAgICAgIHJldHVybiBWSUVXUE9SVFxuICAgICAgICB9KVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICB2aWV3cG9ydDogdmlld3BvcnQsXG4gICAgICBzY2lzc29yX2JveDogcGFyc2VCb3goU19TQ0lTU09SX0JPWClcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZUF0dHJpYkxvY2F0aW9ucyAob3B0aW9ucywgYXR0cmlidXRlcykge1xuICAgIHZhciBzdGF0aWNPcHRpb25zID0gb3B0aW9ucy5zdGF0aWNcbiAgICB2YXIgc3RhdGljUHJvZ3JhbSA9XG4gICAgICB0eXBlb2Ygc3RhdGljT3B0aW9uc1tTX0ZSQUddID09PSAnc3RyaW5nJyAmJlxuICAgICAgdHlwZW9mIHN0YXRpY09wdGlvbnNbU19WRVJUXSA9PT0gJ3N0cmluZydcbiAgICBpZiAoc3RhdGljUHJvZ3JhbSkge1xuICAgICAgaWYgKE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMuZHluYW1pYykubGVuZ3RoID4gMCkge1xuICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgfVxuICAgICAgdmFyIHN0YXRpY0F0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzLnN0YXRpY1xuICAgICAgdmFyIHNBdHRyaWJ1dGVzID0gT2JqZWN0LmtleXMoc3RhdGljQXR0cmlidXRlcylcbiAgICAgIGlmIChzQXR0cmlidXRlcy5sZW5ndGggPiAwICYmIHR5cGVvZiBzdGF0aWNBdHRyaWJ1dGVzW3NBdHRyaWJ1dGVzWzBdXSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgdmFyIGJpbmRpbmdzID0gW11cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzQXR0cmlidXRlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGNoZWNrJDEodHlwZW9mIHN0YXRpY0F0dHJpYnV0ZXNbc0F0dHJpYnV0ZXNbaV1dID09PSAnbnVtYmVyJywgJ211c3Qgc3BlY2lmeSBhbGwgdmVydGV4IGF0dHJpYnV0ZSBsb2NhdGlvbnMgd2hlbiB1c2luZyB2YW9zJylcbiAgICAgICAgICBiaW5kaW5ncy5wdXNoKFtzdGF0aWNBdHRyaWJ1dGVzW3NBdHRyaWJ1dGVzW2ldXSB8IDAsIHNBdHRyaWJ1dGVzW2ldXSlcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYmluZGluZ3NcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlUHJvZ3JhbSAob3B0aW9ucywgZW52LCBhdHRyaWJMb2NhdGlvbnMpIHtcbiAgICB2YXIgc3RhdGljT3B0aW9ucyA9IG9wdGlvbnMuc3RhdGljXG4gICAgdmFyIGR5bmFtaWNPcHRpb25zID0gb3B0aW9ucy5keW5hbWljXG5cbiAgICBmdW5jdGlvbiBwYXJzZVNoYWRlciAobmFtZSkge1xuICAgICAgaWYgKG5hbWUgaW4gc3RhdGljT3B0aW9ucykge1xuICAgICAgICB2YXIgaWQgPSBzdHJpbmdTdG9yZS5pZChzdGF0aWNPcHRpb25zW25hbWVdKVxuICAgICAgICBjaGVjayQxLm9wdGlvbmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBzaGFkZXJTdGF0ZS5zaGFkZXIoc2hhZGVyVHlwZVtuYW1lXSwgaWQsIGNoZWNrJDEuZ3Vlc3NDb21tYW5kKCkpXG4gICAgICAgIH0pXG4gICAgICAgIHZhciByZXN1bHQgPSBjcmVhdGVTdGF0aWNEZWNsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gaWRcbiAgICAgICAgfSlcbiAgICAgICAgcmVzdWx0LmlkID0gaWRcbiAgICAgICAgcmV0dXJuIHJlc3VsdFxuICAgICAgfSBlbHNlIGlmIChuYW1lIGluIGR5bmFtaWNPcHRpb25zKSB7XG4gICAgICAgIHZhciBkeW4gPSBkeW5hbWljT3B0aW9uc1tuYW1lXVxuICAgICAgICByZXR1cm4gY3JlYXRlRHluYW1pY0RlY2woZHluLCBmdW5jdGlvbiAoZW52LCBzY29wZSkge1xuICAgICAgICAgIHZhciBzdHIgPSBlbnYuaW52b2tlKHNjb3BlLCBkeW4pXG4gICAgICAgICAgdmFyIGlkID0gc2NvcGUuZGVmKGVudi5zaGFyZWQuc3RyaW5ncywgJy5pZCgnLCBzdHIsICcpJylcbiAgICAgICAgICBjaGVjayQxLm9wdGlvbmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHNjb3BlKFxuICAgICAgICAgICAgICBlbnYuc2hhcmVkLnNoYWRlciwgJy5zaGFkZXIoJyxcbiAgICAgICAgICAgICAgc2hhZGVyVHlwZVtuYW1lXSwgJywnLFxuICAgICAgICAgICAgICBpZCwgJywnLFxuICAgICAgICAgICAgICBlbnYuY29tbWFuZCwgJyk7JylcbiAgICAgICAgICB9KVxuICAgICAgICAgIHJldHVybiBpZFxuICAgICAgICB9KVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG5cbiAgICB2YXIgZnJhZyA9IHBhcnNlU2hhZGVyKFNfRlJBRylcbiAgICB2YXIgdmVydCA9IHBhcnNlU2hhZGVyKFNfVkVSVClcblxuICAgIHZhciBwcm9ncmFtID0gbnVsbFxuICAgIHZhciBwcm9nVmFyXG4gICAgaWYgKGlzU3RhdGljKGZyYWcpICYmIGlzU3RhdGljKHZlcnQpKSB7XG4gICAgICBwcm9ncmFtID0gc2hhZGVyU3RhdGUucHJvZ3JhbSh2ZXJ0LmlkLCBmcmFnLmlkLCBudWxsLCBhdHRyaWJMb2NhdGlvbnMpXG4gICAgICBwcm9nVmFyID0gY3JlYXRlU3RhdGljRGVjbChmdW5jdGlvbiAoZW52LCBzY29wZSkge1xuICAgICAgICByZXR1cm4gZW52LmxpbmsocHJvZ3JhbSlcbiAgICAgIH0pXG4gICAgfSBlbHNlIHtcbiAgICAgIHByb2dWYXIgPSBuZXcgRGVjbGFyYXRpb24oXG4gICAgICAgIChmcmFnICYmIGZyYWcudGhpc0RlcCkgfHwgKHZlcnQgJiYgdmVydC50aGlzRGVwKSxcbiAgICAgICAgKGZyYWcgJiYgZnJhZy5jb250ZXh0RGVwKSB8fCAodmVydCAmJiB2ZXJ0LmNvbnRleHREZXApLFxuICAgICAgICAoZnJhZyAmJiBmcmFnLnByb3BEZXApIHx8ICh2ZXJ0ICYmIHZlcnQucHJvcERlcCksXG4gICAgICAgIGZ1bmN0aW9uIChlbnYsIHNjb3BlKSB7XG4gICAgICAgICAgdmFyIFNIQURFUl9TVEFURSA9IGVudi5zaGFyZWQuc2hhZGVyXG4gICAgICAgICAgdmFyIGZyYWdJZFxuICAgICAgICAgIGlmIChmcmFnKSB7XG4gICAgICAgICAgICBmcmFnSWQgPSBmcmFnLmFwcGVuZChlbnYsIHNjb3BlKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmcmFnSWQgPSBzY29wZS5kZWYoU0hBREVSX1NUQVRFLCAnLicsIFNfRlJBRylcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHZlcnRJZFxuICAgICAgICAgIGlmICh2ZXJ0KSB7XG4gICAgICAgICAgICB2ZXJ0SWQgPSB2ZXJ0LmFwcGVuZChlbnYsIHNjb3BlKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2ZXJ0SWQgPSBzY29wZS5kZWYoU0hBREVSX1NUQVRFLCAnLicsIFNfVkVSVClcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHByb2dEZWYgPSBTSEFERVJfU1RBVEUgKyAnLnByb2dyYW0oJyArIHZlcnRJZCArICcsJyArIGZyYWdJZFxuICAgICAgICAgIGNoZWNrJDEub3B0aW9uYWwoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcHJvZ0RlZiArPSAnLCcgKyBlbnYuY29tbWFuZFxuICAgICAgICAgIH0pXG4gICAgICAgICAgcmV0dXJuIHNjb3BlLmRlZihwcm9nRGVmICsgJyknKVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBmcmFnOiBmcmFnLFxuICAgICAgdmVydDogdmVydCxcbiAgICAgIHByb2dWYXI6IHByb2dWYXIsXG4gICAgICBwcm9ncmFtOiBwcm9ncmFtXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VEcmF3IChvcHRpb25zLCBlbnYpIHtcbiAgICB2YXIgc3RhdGljT3B0aW9ucyA9IG9wdGlvbnMuc3RhdGljXG4gICAgdmFyIGR5bmFtaWNPcHRpb25zID0gb3B0aW9ucy5keW5hbWljXG5cbiAgICBmdW5jdGlvbiBwYXJzZUVsZW1lbnRzICgpIHtcbiAgICAgIGlmIChTX0VMRU1FTlRTIGluIHN0YXRpY09wdGlvbnMpIHtcbiAgICAgICAgdmFyIGVsZW1lbnRzID0gc3RhdGljT3B0aW9uc1tTX0VMRU1FTlRTXVxuICAgICAgICBpZiAoaXNCdWZmZXJBcmdzKGVsZW1lbnRzKSkge1xuICAgICAgICAgIGVsZW1lbnRzID0gZWxlbWVudFN0YXRlLmdldEVsZW1lbnRzKGVsZW1lbnRTdGF0ZS5jcmVhdGUoZWxlbWVudHMsIHRydWUpKVxuICAgICAgICB9IGVsc2UgaWYgKGVsZW1lbnRzKSB7XG4gICAgICAgICAgZWxlbWVudHMgPSBlbGVtZW50U3RhdGUuZ2V0RWxlbWVudHMoZWxlbWVudHMpXG4gICAgICAgICAgY2hlY2skMS5jb21tYW5kKGVsZW1lbnRzLCAnaW52YWxpZCBlbGVtZW50cycsIGVudi5jb21tYW5kU3RyKVxuICAgICAgICB9XG4gICAgICAgIHZhciByZXN1bHQgPSBjcmVhdGVTdGF0aWNEZWNsKGZ1bmN0aW9uIChlbnYsIHNjb3BlKSB7XG4gICAgICAgICAgaWYgKGVsZW1lbnRzKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gZW52LmxpbmsoZWxlbWVudHMpXG4gICAgICAgICAgICBlbnYuRUxFTUVOVFMgPSByZXN1bHRcbiAgICAgICAgICAgIHJldHVybiByZXN1bHRcbiAgICAgICAgICB9XG4gICAgICAgICAgZW52LkVMRU1FTlRTID0gbnVsbFxuICAgICAgICAgIHJldHVybiBudWxsXG4gICAgICAgIH0pXG4gICAgICAgIHJlc3VsdC52YWx1ZSA9IGVsZW1lbnRzXG4gICAgICAgIHJldHVybiByZXN1bHRcbiAgICAgIH0gZWxzZSBpZiAoU19FTEVNRU5UUyBpbiBkeW5hbWljT3B0aW9ucykge1xuICAgICAgICB2YXIgZHluID0gZHluYW1pY09wdGlvbnNbU19FTEVNRU5UU11cbiAgICAgICAgcmV0dXJuIGNyZWF0ZUR5bmFtaWNEZWNsKGR5biwgZnVuY3Rpb24gKGVudiwgc2NvcGUpIHtcbiAgICAgICAgICB2YXIgc2hhcmVkID0gZW52LnNoYXJlZFxuXG4gICAgICAgICAgdmFyIElTX0JVRkZFUl9BUkdTID0gc2hhcmVkLmlzQnVmZmVyQXJnc1xuICAgICAgICAgIHZhciBFTEVNRU5UX1NUQVRFID0gc2hhcmVkLmVsZW1lbnRzXG5cbiAgICAgICAgICB2YXIgZWxlbWVudERlZm4gPSBlbnYuaW52b2tlKHNjb3BlLCBkeW4pXG4gICAgICAgICAgdmFyIGVsZW1lbnRzID0gc2NvcGUuZGVmKCdudWxsJylcbiAgICAgICAgICB2YXIgZWxlbWVudFN0cmVhbSA9IHNjb3BlLmRlZihJU19CVUZGRVJfQVJHUywgJygnLCBlbGVtZW50RGVmbiwgJyknKVxuXG4gICAgICAgICAgdmFyIGlmdGUgPSBlbnYuY29uZChlbGVtZW50U3RyZWFtKVxuICAgICAgICAgICAgLnRoZW4oZWxlbWVudHMsICc9JywgRUxFTUVOVF9TVEFURSwgJy5jcmVhdGVTdHJlYW0oJywgZWxlbWVudERlZm4sICcpOycpXG4gICAgICAgICAgICAuZWxzZShlbGVtZW50cywgJz0nLCBFTEVNRU5UX1NUQVRFLCAnLmdldEVsZW1lbnRzKCcsIGVsZW1lbnREZWZuLCAnKTsnKVxuXG4gICAgICAgICAgY2hlY2skMS5vcHRpb25hbChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBlbnYuYXNzZXJ0KGlmdGUuZWxzZSxcbiAgICAgICAgICAgICAgJyEnICsgZWxlbWVudERlZm4gKyAnfHwnICsgZWxlbWVudHMsXG4gICAgICAgICAgICAgICdpbnZhbGlkIGVsZW1lbnRzJylcbiAgICAgICAgICB9KVxuXG4gICAgICAgICAgc2NvcGUuZW50cnkoaWZ0ZSlcbiAgICAgICAgICBzY29wZS5leGl0KFxuICAgICAgICAgICAgZW52LmNvbmQoZWxlbWVudFN0cmVhbSlcbiAgICAgICAgICAgICAgLnRoZW4oRUxFTUVOVF9TVEFURSwgJy5kZXN0cm95U3RyZWFtKCcsIGVsZW1lbnRzLCAnKTsnKSlcblxuICAgICAgICAgIGVudi5FTEVNRU5UUyA9IGVsZW1lbnRzXG5cbiAgICAgICAgICByZXR1cm4gZWxlbWVudHNcbiAgICAgICAgfSlcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG5cbiAgICB2YXIgZWxlbWVudHMgPSBwYXJzZUVsZW1lbnRzKClcblxuICAgIGZ1bmN0aW9uIHBhcnNlUHJpbWl0aXZlICgpIHtcbiAgICAgIGlmIChTX1BSSU1JVElWRSBpbiBzdGF0aWNPcHRpb25zKSB7XG4gICAgICAgIHZhciBwcmltaXRpdmUgPSBzdGF0aWNPcHRpb25zW1NfUFJJTUlUSVZFXVxuICAgICAgICBjaGVjayQxLmNvbW1hbmRQYXJhbWV0ZXIocHJpbWl0aXZlLCBwcmltVHlwZXMsICdpbnZhbGlkIHByaW1pdHZlJywgZW52LmNvbW1hbmRTdHIpXG4gICAgICAgIHJldHVybiBjcmVhdGVTdGF0aWNEZWNsKGZ1bmN0aW9uIChlbnYsIHNjb3BlKSB7XG4gICAgICAgICAgcmV0dXJuIHByaW1UeXBlc1twcmltaXRpdmVdXG4gICAgICAgIH0pXG4gICAgICB9IGVsc2UgaWYgKFNfUFJJTUlUSVZFIGluIGR5bmFtaWNPcHRpb25zKSB7XG4gICAgICAgIHZhciBkeW5QcmltaXRpdmUgPSBkeW5hbWljT3B0aW9uc1tTX1BSSU1JVElWRV1cbiAgICAgICAgcmV0dXJuIGNyZWF0ZUR5bmFtaWNEZWNsKGR5blByaW1pdGl2ZSwgZnVuY3Rpb24gKGVudiwgc2NvcGUpIHtcbiAgICAgICAgICB2YXIgUFJJTV9UWVBFUyA9IGVudi5jb25zdGFudHMucHJpbVR5cGVzXG4gICAgICAgICAgdmFyIHByaW0gPSBlbnYuaW52b2tlKHNjb3BlLCBkeW5QcmltaXRpdmUpXG4gICAgICAgICAgY2hlY2skMS5vcHRpb25hbChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBlbnYuYXNzZXJ0KHNjb3BlLFxuICAgICAgICAgICAgICBwcmltICsgJyBpbiAnICsgUFJJTV9UWVBFUyxcbiAgICAgICAgICAgICAgJ2ludmFsaWQgcHJpbWl0aXZlLCBtdXN0IGJlIG9uZSBvZiAnICsgT2JqZWN0LmtleXMocHJpbVR5cGVzKSlcbiAgICAgICAgICB9KVxuICAgICAgICAgIHJldHVybiBzY29wZS5kZWYoUFJJTV9UWVBFUywgJ1snLCBwcmltLCAnXScpXG4gICAgICAgIH0pXG4gICAgICB9IGVsc2UgaWYgKGVsZW1lbnRzKSB7XG4gICAgICAgIGlmIChpc1N0YXRpYyhlbGVtZW50cykpIHtcbiAgICAgICAgICBpZiAoZWxlbWVudHMudmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVTdGF0aWNEZWNsKGZ1bmN0aW9uIChlbnYsIHNjb3BlKSB7XG4gICAgICAgICAgICAgIHJldHVybiBzY29wZS5kZWYoZW52LkVMRU1FTlRTLCAnLnByaW1UeXBlJylcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVTdGF0aWNEZWNsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIEdMX1RSSUFOR0xFUyQxXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gbmV3IERlY2xhcmF0aW9uKFxuICAgICAgICAgICAgZWxlbWVudHMudGhpc0RlcCxcbiAgICAgICAgICAgIGVsZW1lbnRzLmNvbnRleHREZXAsXG4gICAgICAgICAgICBlbGVtZW50cy5wcm9wRGVwLFxuICAgICAgICAgICAgZnVuY3Rpb24gKGVudiwgc2NvcGUpIHtcbiAgICAgICAgICAgICAgdmFyIGVsZW1lbnRzID0gZW52LkVMRU1FTlRTXG4gICAgICAgICAgICAgIHJldHVybiBzY29wZS5kZWYoZWxlbWVudHMsICc/JywgZWxlbWVudHMsICcucHJpbVR5cGU6JywgR0xfVFJJQU5HTEVTJDEpXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlUGFyYW0gKHBhcmFtLCBpc09mZnNldCkge1xuICAgICAgaWYgKHBhcmFtIGluIHN0YXRpY09wdGlvbnMpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gc3RhdGljT3B0aW9uc1twYXJhbV0gfCAwXG4gICAgICAgIGNoZWNrJDEuY29tbWFuZCghaXNPZmZzZXQgfHwgdmFsdWUgPj0gMCwgJ2ludmFsaWQgJyArIHBhcmFtLCBlbnYuY29tbWFuZFN0cilcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVN0YXRpY0RlY2woZnVuY3Rpb24gKGVudiwgc2NvcGUpIHtcbiAgICAgICAgICBpZiAoaXNPZmZzZXQpIHtcbiAgICAgICAgICAgIGVudi5PRkZTRVQgPSB2YWx1ZVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdmFsdWVcbiAgICAgICAgfSlcbiAgICAgIH0gZWxzZSBpZiAocGFyYW0gaW4gZHluYW1pY09wdGlvbnMpIHtcbiAgICAgICAgdmFyIGR5blZhbHVlID0gZHluYW1pY09wdGlvbnNbcGFyYW1dXG4gICAgICAgIHJldHVybiBjcmVhdGVEeW5hbWljRGVjbChkeW5WYWx1ZSwgZnVuY3Rpb24gKGVudiwgc2NvcGUpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gZW52Lmludm9rZShzY29wZSwgZHluVmFsdWUpXG4gICAgICAgICAgaWYgKGlzT2Zmc2V0KSB7XG4gICAgICAgICAgICBlbnYuT0ZGU0VUID0gcmVzdWx0XG4gICAgICAgICAgICBjaGVjayQxLm9wdGlvbmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgZW52LmFzc2VydChzY29wZSxcbiAgICAgICAgICAgICAgICByZXN1bHQgKyAnPj0wJyxcbiAgICAgICAgICAgICAgICAnaW52YWxpZCAnICsgcGFyYW0pXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0XG4gICAgICAgIH0pXG4gICAgICB9IGVsc2UgaWYgKGlzT2Zmc2V0ICYmIGVsZW1lbnRzKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVTdGF0aWNEZWNsKGZ1bmN0aW9uIChlbnYsIHNjb3BlKSB7XG4gICAgICAgICAgZW52Lk9GRlNFVCA9ICcwJ1xuICAgICAgICAgIHJldHVybiAwXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cblxuICAgIHZhciBPRkZTRVQgPSBwYXJzZVBhcmFtKFNfT0ZGU0VULCB0cnVlKVxuXG4gICAgZnVuY3Rpb24gcGFyc2VWZXJ0Q291bnQgKCkge1xuICAgICAgaWYgKFNfQ09VTlQgaW4gc3RhdGljT3B0aW9ucykge1xuICAgICAgICB2YXIgY291bnQgPSBzdGF0aWNPcHRpb25zW1NfQ09VTlRdIHwgMFxuICAgICAgICBjaGVjayQxLmNvbW1hbmQoXG4gICAgICAgICAgdHlwZW9mIGNvdW50ID09PSAnbnVtYmVyJyAmJiBjb3VudCA+PSAwLCAnaW52YWxpZCB2ZXJ0ZXggY291bnQnLCBlbnYuY29tbWFuZFN0cilcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVN0YXRpY0RlY2woZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBjb3VudFxuICAgICAgICB9KVxuICAgICAgfSBlbHNlIGlmIChTX0NPVU5UIGluIGR5bmFtaWNPcHRpb25zKSB7XG4gICAgICAgIHZhciBkeW5Db3VudCA9IGR5bmFtaWNPcHRpb25zW1NfQ09VTlRdXG4gICAgICAgIHJldHVybiBjcmVhdGVEeW5hbWljRGVjbChkeW5Db3VudCwgZnVuY3Rpb24gKGVudiwgc2NvcGUpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gZW52Lmludm9rZShzY29wZSwgZHluQ291bnQpXG4gICAgICAgICAgY2hlY2skMS5vcHRpb25hbChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBlbnYuYXNzZXJ0KHNjb3BlLFxuICAgICAgICAgICAgICAndHlwZW9mICcgKyByZXN1bHQgKyAnPT09XCJudW1iZXJcIiYmJyArXG4gICAgICAgICAgICAgIHJlc3VsdCArICc+PTAmJicgK1xuICAgICAgICAgICAgICByZXN1bHQgKyAnPT09KCcgKyByZXN1bHQgKyAnfDApJyxcbiAgICAgICAgICAgICAgJ2ludmFsaWQgdmVydGV4IGNvdW50JylcbiAgICAgICAgICB9KVxuICAgICAgICAgIHJldHVybiByZXN1bHRcbiAgICAgICAgfSlcbiAgICAgIH0gZWxzZSBpZiAoZWxlbWVudHMpIHtcbiAgICAgICAgaWYgKGlzU3RhdGljKGVsZW1lbnRzKSkge1xuICAgICAgICAgIGlmIChlbGVtZW50cykge1xuICAgICAgICAgICAgaWYgKE9GRlNFVCkge1xuICAgICAgICAgICAgICByZXR1cm4gbmV3IERlY2xhcmF0aW9uKFxuICAgICAgICAgICAgICAgIE9GRlNFVC50aGlzRGVwLFxuICAgICAgICAgICAgICAgIE9GRlNFVC5jb250ZXh0RGVwLFxuICAgICAgICAgICAgICAgIE9GRlNFVC5wcm9wRGVwLFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChlbnYsIHNjb3BlKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gc2NvcGUuZGVmKFxuICAgICAgICAgICAgICAgICAgICBlbnYuRUxFTUVOVFMsICcudmVydENvdW50LScsIGVudi5PRkZTRVQpXG5cbiAgICAgICAgICAgICAgICAgIGNoZWNrJDEub3B0aW9uYWwoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBlbnYuYXNzZXJ0KHNjb3BlLFxuICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArICc+PTAnLFxuICAgICAgICAgICAgICAgICAgICAgICdpbnZhbGlkIHZlcnRleCBvZmZzZXQvZWxlbWVudCBidWZmZXIgdG9vIHNtYWxsJylcbiAgICAgICAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZVN0YXRpY0RlY2woZnVuY3Rpb24gKGVudiwgc2NvcGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2NvcGUuZGVmKGVudi5FTEVNRU5UUywgJy52ZXJ0Q291bnQnKVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gY3JlYXRlU3RhdGljRGVjbChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHJldHVybiAtMVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIGNoZWNrJDEub3B0aW9uYWwoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICByZXN1bHQuTUlTU0lORyA9IHRydWVcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciB2YXJpYWJsZSA9IG5ldyBEZWNsYXJhdGlvbihcbiAgICAgICAgICAgIGVsZW1lbnRzLnRoaXNEZXAgfHwgT0ZGU0VULnRoaXNEZXAsXG4gICAgICAgICAgICBlbGVtZW50cy5jb250ZXh0RGVwIHx8IE9GRlNFVC5jb250ZXh0RGVwLFxuICAgICAgICAgICAgZWxlbWVudHMucHJvcERlcCB8fCBPRkZTRVQucHJvcERlcCxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChlbnYsIHNjb3BlKSB7XG4gICAgICAgICAgICAgIHZhciBlbGVtZW50cyA9IGVudi5FTEVNRU5UU1xuICAgICAgICAgICAgICBpZiAoZW52Lk9GRlNFVCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzY29wZS5kZWYoZWxlbWVudHMsICc/JywgZWxlbWVudHMsICcudmVydENvdW50LScsXG4gICAgICAgICAgICAgICAgICBlbnYuT0ZGU0VULCAnOi0xJylcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gc2NvcGUuZGVmKGVsZW1lbnRzLCAnPycsIGVsZW1lbnRzLCAnLnZlcnRDb3VudDotMScpXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIGNoZWNrJDEub3B0aW9uYWwoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyaWFibGUuRFlOQU1JQyA9IHRydWVcbiAgICAgICAgICB9KVxuICAgICAgICAgIHJldHVybiB2YXJpYWJsZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBlbGVtZW50czogZWxlbWVudHMsXG4gICAgICBwcmltaXRpdmU6IHBhcnNlUHJpbWl0aXZlKCksXG4gICAgICBjb3VudDogcGFyc2VWZXJ0Q291bnQoKSxcbiAgICAgIGluc3RhbmNlczogcGFyc2VQYXJhbShTX0lOU1RBTkNFUywgZmFsc2UpLFxuICAgICAgb2Zmc2V0OiBPRkZTRVRcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZUdMU3RhdGUgKG9wdGlvbnMsIGVudikge1xuICAgIHZhciBzdGF0aWNPcHRpb25zID0gb3B0aW9ucy5zdGF0aWNcbiAgICB2YXIgZHluYW1pY09wdGlvbnMgPSBvcHRpb25zLmR5bmFtaWNcblxuICAgIHZhciBTVEFURSA9IHt9XG5cbiAgICBHTF9TVEFURV9OQU1FUy5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICB2YXIgcGFyYW0gPSBwcm9wTmFtZShwcm9wKVxuXG4gICAgICBmdW5jdGlvbiBwYXJzZVBhcmFtIChwYXJzZVN0YXRpYywgcGFyc2VEeW5hbWljKSB7XG4gICAgICAgIGlmIChwcm9wIGluIHN0YXRpY09wdGlvbnMpIHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBwYXJzZVN0YXRpYyhzdGF0aWNPcHRpb25zW3Byb3BdKVxuICAgICAgICAgIFNUQVRFW3BhcmFtXSA9IGNyZWF0ZVN0YXRpY0RlY2woZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlXG4gICAgICAgICAgfSlcbiAgICAgICAgfSBlbHNlIGlmIChwcm9wIGluIGR5bmFtaWNPcHRpb25zKSB7XG4gICAgICAgICAgdmFyIGR5biA9IGR5bmFtaWNPcHRpb25zW3Byb3BdXG4gICAgICAgICAgU1RBVEVbcGFyYW1dID0gY3JlYXRlRHluYW1pY0RlY2woZHluLCBmdW5jdGlvbiAoZW52LCBzY29wZSkge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlRHluYW1pYyhlbnYsIHNjb3BlLCBlbnYuaW52b2tlKHNjb3BlLCBkeW4pKVxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc3dpdGNoIChwcm9wKSB7XG4gICAgICAgIGNhc2UgU19DVUxMX0VOQUJMRTpcbiAgICAgICAgY2FzZSBTX0JMRU5EX0VOQUJMRTpcbiAgICAgICAgY2FzZSBTX0RJVEhFUjpcbiAgICAgICAgY2FzZSBTX1NURU5DSUxfRU5BQkxFOlxuICAgICAgICBjYXNlIFNfREVQVEhfRU5BQkxFOlxuICAgICAgICBjYXNlIFNfU0NJU1NPUl9FTkFCTEU6XG4gICAgICAgIGNhc2UgU19QT0xZR09OX09GRlNFVF9FTkFCTEU6XG4gICAgICAgIGNhc2UgU19TQU1QTEVfQUxQSEE6XG4gICAgICAgIGNhc2UgU19TQU1QTEVfRU5BQkxFOlxuICAgICAgICBjYXNlIFNfREVQVEhfTUFTSzpcbiAgICAgICAgICByZXR1cm4gcGFyc2VQYXJhbShcbiAgICAgICAgICAgIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICBjaGVjayQxLmNvbW1hbmRUeXBlKHZhbHVlLCAnYm9vbGVhbicsIHByb3AsIGVudi5jb21tYW5kU3RyKVxuICAgICAgICAgICAgICByZXR1cm4gdmFsdWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmdW5jdGlvbiAoZW52LCBzY29wZSwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgY2hlY2skMS5vcHRpb25hbChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgZW52LmFzc2VydChzY29wZSxcbiAgICAgICAgICAgICAgICAgICd0eXBlb2YgJyArIHZhbHVlICsgJz09PVwiYm9vbGVhblwiJyxcbiAgICAgICAgICAgICAgICAgICdpbnZhbGlkIGZsYWcgJyArIHByb3AsIGVudi5jb21tYW5kU3RyKVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICByZXR1cm4gdmFsdWVcbiAgICAgICAgICAgIH0pXG5cbiAgICAgICAgY2FzZSBTX0RFUFRIX0ZVTkM6XG4gICAgICAgICAgcmV0dXJuIHBhcnNlUGFyYW0oXG4gICAgICAgICAgICBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgY2hlY2skMS5jb21tYW5kUGFyYW1ldGVyKHZhbHVlLCBjb21wYXJlRnVuY3MsICdpbnZhbGlkICcgKyBwcm9wLCBlbnYuY29tbWFuZFN0cilcbiAgICAgICAgICAgICAgcmV0dXJuIGNvbXBhcmVGdW5jc1t2YWx1ZV1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmdW5jdGlvbiAoZW52LCBzY29wZSwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgdmFyIENPTVBBUkVfRlVOQ1MgPSBlbnYuY29uc3RhbnRzLmNvbXBhcmVGdW5jc1xuICAgICAgICAgICAgICBjaGVjayQxLm9wdGlvbmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBlbnYuYXNzZXJ0KHNjb3BlLFxuICAgICAgICAgICAgICAgICAgdmFsdWUgKyAnIGluICcgKyBDT01QQVJFX0ZVTkNTLFxuICAgICAgICAgICAgICAgICAgJ2ludmFsaWQgJyArIHByb3AgKyAnLCBtdXN0IGJlIG9uZSBvZiAnICsgT2JqZWN0LmtleXMoY29tcGFyZUZ1bmNzKSlcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgcmV0dXJuIHNjb3BlLmRlZihDT01QQVJFX0ZVTkNTLCAnWycsIHZhbHVlLCAnXScpXG4gICAgICAgICAgICB9KVxuXG4gICAgICAgIGNhc2UgU19ERVBUSF9SQU5HRTpcbiAgICAgICAgICByZXR1cm4gcGFyc2VQYXJhbShcbiAgICAgICAgICAgIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICBjaGVjayQxLmNvbW1hbmQoXG4gICAgICAgICAgICAgICAgaXNBcnJheUxpa2UodmFsdWUpICYmXG4gICAgICAgICAgICAgICAgdmFsdWUubGVuZ3RoID09PSAyICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIHZhbHVlWzBdID09PSAnbnVtYmVyJyAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiB2YWx1ZVsxXSA9PT0gJ251bWJlcicgJiZcbiAgICAgICAgICAgICAgICB2YWx1ZVswXSA8PSB2YWx1ZVsxXSxcbiAgICAgICAgICAgICAgICAnZGVwdGggcmFuZ2UgaXMgMmQgYXJyYXknLFxuICAgICAgICAgICAgICAgIGVudi5jb21tYW5kU3RyKVxuICAgICAgICAgICAgICByZXR1cm4gdmFsdWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmdW5jdGlvbiAoZW52LCBzY29wZSwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgY2hlY2skMS5vcHRpb25hbChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgZW52LmFzc2VydChzY29wZSxcbiAgICAgICAgICAgICAgICAgIGVudi5zaGFyZWQuaXNBcnJheUxpa2UgKyAnKCcgKyB2YWx1ZSArICcpJiYnICtcbiAgICAgICAgICAgICAgICAgIHZhbHVlICsgJy5sZW5ndGg9PT0yJiYnICtcbiAgICAgICAgICAgICAgICAgICd0eXBlb2YgJyArIHZhbHVlICsgJ1swXT09PVwibnVtYmVyXCImJicgK1xuICAgICAgICAgICAgICAgICAgJ3R5cGVvZiAnICsgdmFsdWUgKyAnWzFdPT09XCJudW1iZXJcIiYmJyArXG4gICAgICAgICAgICAgICAgICB2YWx1ZSArICdbMF08PScgKyB2YWx1ZSArICdbMV0nLFxuICAgICAgICAgICAgICAgICAgJ2RlcHRoIHJhbmdlIG11c3QgYmUgYSAyZCBhcnJheScpXG4gICAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgICAgdmFyIFpfTkVBUiA9IHNjb3BlLmRlZignKycsIHZhbHVlLCAnWzBdJylcbiAgICAgICAgICAgICAgdmFyIFpfRkFSID0gc2NvcGUuZGVmKCcrJywgdmFsdWUsICdbMV0nKVxuICAgICAgICAgICAgICByZXR1cm4gW1pfTkVBUiwgWl9GQVJdXG4gICAgICAgICAgICB9KVxuXG4gICAgICAgIGNhc2UgU19CTEVORF9GVU5DOlxuICAgICAgICAgIHJldHVybiBwYXJzZVBhcmFtKFxuICAgICAgICAgICAgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgIGNoZWNrJDEuY29tbWFuZFR5cGUodmFsdWUsICdvYmplY3QnLCAnYmxlbmQuZnVuYycsIGVudi5jb21tYW5kU3RyKVxuICAgICAgICAgICAgICB2YXIgc3JjUkdCID0gKCdzcmNSR0InIGluIHZhbHVlID8gdmFsdWUuc3JjUkdCIDogdmFsdWUuc3JjKVxuICAgICAgICAgICAgICB2YXIgc3JjQWxwaGEgPSAoJ3NyY0FscGhhJyBpbiB2YWx1ZSA/IHZhbHVlLnNyY0FscGhhIDogdmFsdWUuc3JjKVxuICAgICAgICAgICAgICB2YXIgZHN0UkdCID0gKCdkc3RSR0InIGluIHZhbHVlID8gdmFsdWUuZHN0UkdCIDogdmFsdWUuZHN0KVxuICAgICAgICAgICAgICB2YXIgZHN0QWxwaGEgPSAoJ2RzdEFscGhhJyBpbiB2YWx1ZSA/IHZhbHVlLmRzdEFscGhhIDogdmFsdWUuZHN0KVxuICAgICAgICAgICAgICBjaGVjayQxLmNvbW1hbmRQYXJhbWV0ZXIoc3JjUkdCLCBibGVuZEZ1bmNzLCBwYXJhbSArICcuc3JjUkdCJywgZW52LmNvbW1hbmRTdHIpXG4gICAgICAgICAgICAgIGNoZWNrJDEuY29tbWFuZFBhcmFtZXRlcihzcmNBbHBoYSwgYmxlbmRGdW5jcywgcGFyYW0gKyAnLnNyY0FscGhhJywgZW52LmNvbW1hbmRTdHIpXG4gICAgICAgICAgICAgIGNoZWNrJDEuY29tbWFuZFBhcmFtZXRlcihkc3RSR0IsIGJsZW5kRnVuY3MsIHBhcmFtICsgJy5kc3RSR0InLCBlbnYuY29tbWFuZFN0cilcbiAgICAgICAgICAgICAgY2hlY2skMS5jb21tYW5kUGFyYW1ldGVyKGRzdEFscGhhLCBibGVuZEZ1bmNzLCBwYXJhbSArICcuZHN0QWxwaGEnLCBlbnYuY29tbWFuZFN0cilcblxuICAgICAgICAgICAgICBjaGVjayQxLmNvbW1hbmQoXG4gICAgICAgICAgICAgICAgKGludmFsaWRCbGVuZENvbWJpbmF0aW9ucy5pbmRleE9mKHNyY1JHQiArICcsICcgKyBkc3RSR0IpID09PSAtMSksXG4gICAgICAgICAgICAgICAgJ3VuYWxsb3dlZCBibGVuZGluZyBjb21iaW5hdGlvbiAoc3JjUkdCLCBkc3RSR0IpID0gKCcgKyBzcmNSR0IgKyAnLCAnICsgZHN0UkdCICsgJyknLCBlbnYuY29tbWFuZFN0cilcblxuICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIGJsZW5kRnVuY3Nbc3JjUkdCXSxcbiAgICAgICAgICAgICAgICBibGVuZEZ1bmNzW2RzdFJHQl0sXG4gICAgICAgICAgICAgICAgYmxlbmRGdW5jc1tzcmNBbHBoYV0sXG4gICAgICAgICAgICAgICAgYmxlbmRGdW5jc1tkc3RBbHBoYV1cbiAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChlbnYsIHNjb3BlLCB2YWx1ZSkge1xuICAgICAgICAgICAgICB2YXIgQkxFTkRfRlVOQ1MgPSBlbnYuY29uc3RhbnRzLmJsZW5kRnVuY3NcblxuICAgICAgICAgICAgICBjaGVjayQxLm9wdGlvbmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBlbnYuYXNzZXJ0KHNjb3BlLFxuICAgICAgICAgICAgICAgICAgdmFsdWUgKyAnJiZ0eXBlb2YgJyArIHZhbHVlICsgJz09PVwib2JqZWN0XCInLFxuICAgICAgICAgICAgICAgICAgJ2ludmFsaWQgYmxlbmQgZnVuYywgbXVzdCBiZSBhbiBvYmplY3QnKVxuICAgICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICAgIGZ1bmN0aW9uIHJlYWQgKHByZWZpeCwgc3VmZml4KSB7XG4gICAgICAgICAgICAgICAgdmFyIGZ1bmMgPSBzY29wZS5kZWYoXG4gICAgICAgICAgICAgICAgICAnXCInLCBwcmVmaXgsIHN1ZmZpeCwgJ1wiIGluICcsIHZhbHVlLFxuICAgICAgICAgICAgICAgICAgJz8nLCB2YWx1ZSwgJy4nLCBwcmVmaXgsIHN1ZmZpeCxcbiAgICAgICAgICAgICAgICAgICc6JywgdmFsdWUsICcuJywgcHJlZml4KVxuXG4gICAgICAgICAgICAgICAgY2hlY2skMS5vcHRpb25hbChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICBlbnYuYXNzZXJ0KHNjb3BlLFxuICAgICAgICAgICAgICAgICAgICBmdW5jICsgJyBpbiAnICsgQkxFTkRfRlVOQ1MsXG4gICAgICAgICAgICAgICAgICAgICdpbnZhbGlkICcgKyBwcm9wICsgJy4nICsgcHJlZml4ICsgc3VmZml4ICsgJywgbXVzdCBiZSBvbmUgb2YgJyArIE9iamVjdC5rZXlzKGJsZW5kRnVuY3MpKVxuICAgICAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdmFyIHNyY1JHQiA9IHJlYWQoJ3NyYycsICdSR0InKVxuICAgICAgICAgICAgICB2YXIgZHN0UkdCID0gcmVhZCgnZHN0JywgJ1JHQicpXG5cbiAgICAgICAgICAgICAgY2hlY2skMS5vcHRpb25hbChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIElOVkFMSURfQkxFTkRfQ09NQklOQVRJT05TID0gZW52LmNvbnN0YW50cy5pbnZhbGlkQmxlbmRDb21iaW5hdGlvbnNcblxuICAgICAgICAgICAgICAgIGVudi5hc3NlcnQoc2NvcGUsXG4gICAgICAgICAgICAgICAgICBJTlZBTElEX0JMRU5EX0NPTUJJTkFUSU9OUyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAnLmluZGV4T2YoJyArIHNyY1JHQiArICcrXCIsIFwiKycgKyBkc3RSR0IgKyAnKSA9PT0gLTEgJyxcbiAgICAgICAgICAgICAgICAgICd1bmFsbG93ZWQgYmxlbmRpbmcgY29tYmluYXRpb24gZm9yIChzcmNSR0IsIGRzdFJHQiknXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICAgIHZhciBTUkNfUkdCID0gc2NvcGUuZGVmKEJMRU5EX0ZVTkNTLCAnWycsIHNyY1JHQiwgJ10nKVxuICAgICAgICAgICAgICB2YXIgU1JDX0FMUEhBID0gc2NvcGUuZGVmKEJMRU5EX0ZVTkNTLCAnWycsIHJlYWQoJ3NyYycsICdBbHBoYScpLCAnXScpXG4gICAgICAgICAgICAgIHZhciBEU1RfUkdCID0gc2NvcGUuZGVmKEJMRU5EX0ZVTkNTLCAnWycsIGRzdFJHQiwgJ10nKVxuICAgICAgICAgICAgICB2YXIgRFNUX0FMUEhBID0gc2NvcGUuZGVmKEJMRU5EX0ZVTkNTLCAnWycsIHJlYWQoJ2RzdCcsICdBbHBoYScpLCAnXScpXG5cbiAgICAgICAgICAgICAgcmV0dXJuIFtTUkNfUkdCLCBEU1RfUkdCLCBTUkNfQUxQSEEsIERTVF9BTFBIQV1cbiAgICAgICAgICAgIH0pXG5cbiAgICAgICAgY2FzZSBTX0JMRU5EX0VRVUFUSU9OOlxuICAgICAgICAgIHJldHVybiBwYXJzZVBhcmFtKFxuICAgICAgICAgICAgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgY2hlY2skMS5jb21tYW5kUGFyYW1ldGVyKHZhbHVlLCBibGVuZEVxdWF0aW9ucywgJ2ludmFsaWQgJyArIHByb3AsIGVudi5jb21tYW5kU3RyKVxuICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICBibGVuZEVxdWF0aW9uc1t2YWx1ZV0sXG4gICAgICAgICAgICAgICAgICBibGVuZEVxdWF0aW9uc1t2YWx1ZV1cbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIGNoZWNrJDEuY29tbWFuZFBhcmFtZXRlcihcbiAgICAgICAgICAgICAgICAgIHZhbHVlLnJnYiwgYmxlbmRFcXVhdGlvbnMsIHByb3AgKyAnLnJnYicsIGVudi5jb21tYW5kU3RyKVxuICAgICAgICAgICAgICAgIGNoZWNrJDEuY29tbWFuZFBhcmFtZXRlcihcbiAgICAgICAgICAgICAgICAgIHZhbHVlLmFscGhhLCBibGVuZEVxdWF0aW9ucywgcHJvcCArICcuYWxwaGEnLCBlbnYuY29tbWFuZFN0cilcbiAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgYmxlbmRFcXVhdGlvbnNbdmFsdWUucmdiXSxcbiAgICAgICAgICAgICAgICAgIGJsZW5kRXF1YXRpb25zW3ZhbHVlLmFscGhhXVxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjaGVjayQxLmNvbW1hbmRSYWlzZSgnaW52YWxpZCBibGVuZC5lcXVhdGlvbicsIGVudi5jb21tYW5kU3RyKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZnVuY3Rpb24gKGVudiwgc2NvcGUsIHZhbHVlKSB7XG4gICAgICAgICAgICAgIHZhciBCTEVORF9FUVVBVElPTlMgPSBlbnYuY29uc3RhbnRzLmJsZW5kRXF1YXRpb25zXG5cbiAgICAgICAgICAgICAgdmFyIFJHQiA9IHNjb3BlLmRlZigpXG4gICAgICAgICAgICAgIHZhciBBTFBIQSA9IHNjb3BlLmRlZigpXG5cbiAgICAgICAgICAgICAgdmFyIGlmdGUgPSBlbnYuY29uZCgndHlwZW9mICcsIHZhbHVlLCAnPT09XCJzdHJpbmdcIicpXG5cbiAgICAgICAgICAgICAgY2hlY2skMS5vcHRpb25hbChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gY2hlY2tQcm9wIChibG9jaywgbmFtZSwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgIGVudi5hc3NlcnQoYmxvY2ssXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlICsgJyBpbiAnICsgQkxFTkRfRVFVQVRJT05TLFxuICAgICAgICAgICAgICAgICAgICAnaW52YWxpZCAnICsgbmFtZSArICcsIG11c3QgYmUgb25lIG9mICcgKyBPYmplY3Qua2V5cyhibGVuZEVxdWF0aW9ucykpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNoZWNrUHJvcChpZnRlLnRoZW4sIHByb3AsIHZhbHVlKVxuXG4gICAgICAgICAgICAgICAgZW52LmFzc2VydChpZnRlLmVsc2UsXG4gICAgICAgICAgICAgICAgICB2YWx1ZSArICcmJnR5cGVvZiAnICsgdmFsdWUgKyAnPT09XCJvYmplY3RcIicsXG4gICAgICAgICAgICAgICAgICAnaW52YWxpZCAnICsgcHJvcClcbiAgICAgICAgICAgICAgICBjaGVja1Byb3AoaWZ0ZS5lbHNlLCBwcm9wICsgJy5yZ2InLCB2YWx1ZSArICcucmdiJylcbiAgICAgICAgICAgICAgICBjaGVja1Byb3AoaWZ0ZS5lbHNlLCBwcm9wICsgJy5hbHBoYScsIHZhbHVlICsgJy5hbHBoYScpXG4gICAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgICAgaWZ0ZS50aGVuKFxuICAgICAgICAgICAgICAgIFJHQiwgJz0nLCBBTFBIQSwgJz0nLCBCTEVORF9FUVVBVElPTlMsICdbJywgdmFsdWUsICddOycpXG4gICAgICAgICAgICAgIGlmdGUuZWxzZShcbiAgICAgICAgICAgICAgICBSR0IsICc9JywgQkxFTkRfRVFVQVRJT05TLCAnWycsIHZhbHVlLCAnLnJnYl07JyxcbiAgICAgICAgICAgICAgICBBTFBIQSwgJz0nLCBCTEVORF9FUVVBVElPTlMsICdbJywgdmFsdWUsICcuYWxwaGFdOycpXG5cbiAgICAgICAgICAgICAgc2NvcGUoaWZ0ZSlcblxuICAgICAgICAgICAgICByZXR1cm4gW1JHQiwgQUxQSEFdXG4gICAgICAgICAgICB9KVxuXG4gICAgICAgIGNhc2UgU19CTEVORF9DT0xPUjpcbiAgICAgICAgICByZXR1cm4gcGFyc2VQYXJhbShcbiAgICAgICAgICAgIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICBjaGVjayQxLmNvbW1hbmQoXG4gICAgICAgICAgICAgICAgaXNBcnJheUxpa2UodmFsdWUpICYmXG4gICAgICAgICAgICAgICAgdmFsdWUubGVuZ3RoID09PSA0LFxuICAgICAgICAgICAgICAgICdibGVuZC5jb2xvciBtdXN0IGJlIGEgNGQgYXJyYXknLCBlbnYuY29tbWFuZFN0cilcbiAgICAgICAgICAgICAgcmV0dXJuIGxvb3AoNCwgZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gK3ZhbHVlW2ldXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZnVuY3Rpb24gKGVudiwgc2NvcGUsIHZhbHVlKSB7XG4gICAgICAgICAgICAgIGNoZWNrJDEub3B0aW9uYWwoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGVudi5hc3NlcnQoc2NvcGUsXG4gICAgICAgICAgICAgICAgICBlbnYuc2hhcmVkLmlzQXJyYXlMaWtlICsgJygnICsgdmFsdWUgKyAnKSYmJyArXG4gICAgICAgICAgICAgICAgICB2YWx1ZSArICcubGVuZ3RoPT09NCcsXG4gICAgICAgICAgICAgICAgICAnYmxlbmQuY29sb3IgbXVzdCBiZSBhIDRkIGFycmF5JylcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgcmV0dXJuIGxvb3AoNCwgZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2NvcGUuZGVmKCcrJywgdmFsdWUsICdbJywgaSwgJ10nKVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSlcblxuICAgICAgICBjYXNlIFNfU1RFTkNJTF9NQVNLOlxuICAgICAgICAgIHJldHVybiBwYXJzZVBhcmFtKFxuICAgICAgICAgICAgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgIGNoZWNrJDEuY29tbWFuZFR5cGUodmFsdWUsICdudW1iZXInLCBwYXJhbSwgZW52LmNvbW1hbmRTdHIpXG4gICAgICAgICAgICAgIHJldHVybiB2YWx1ZSB8IDBcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmdW5jdGlvbiAoZW52LCBzY29wZSwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgY2hlY2skMS5vcHRpb25hbChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgZW52LmFzc2VydChzY29wZSxcbiAgICAgICAgICAgICAgICAgICd0eXBlb2YgJyArIHZhbHVlICsgJz09PVwibnVtYmVyXCInLFxuICAgICAgICAgICAgICAgICAgJ2ludmFsaWQgc3RlbmNpbC5tYXNrJylcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgcmV0dXJuIHNjb3BlLmRlZih2YWx1ZSwgJ3wwJylcbiAgICAgICAgICAgIH0pXG5cbiAgICAgICAgY2FzZSBTX1NURU5DSUxfRlVOQzpcbiAgICAgICAgICByZXR1cm4gcGFyc2VQYXJhbShcbiAgICAgICAgICAgIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICBjaGVjayQxLmNvbW1hbmRUeXBlKHZhbHVlLCAnb2JqZWN0JywgcGFyYW0sIGVudi5jb21tYW5kU3RyKVxuICAgICAgICAgICAgICB2YXIgY21wID0gdmFsdWUuY21wIHx8ICdrZWVwJ1xuICAgICAgICAgICAgICB2YXIgcmVmID0gdmFsdWUucmVmIHx8IDBcbiAgICAgICAgICAgICAgdmFyIG1hc2sgPSAnbWFzaycgaW4gdmFsdWUgPyB2YWx1ZS5tYXNrIDogLTFcbiAgICAgICAgICAgICAgY2hlY2skMS5jb21tYW5kUGFyYW1ldGVyKGNtcCwgY29tcGFyZUZ1bmNzLCBwcm9wICsgJy5jbXAnLCBlbnYuY29tbWFuZFN0cilcbiAgICAgICAgICAgICAgY2hlY2skMS5jb21tYW5kVHlwZShyZWYsICdudW1iZXInLCBwcm9wICsgJy5yZWYnLCBlbnYuY29tbWFuZFN0cilcbiAgICAgICAgICAgICAgY2hlY2skMS5jb21tYW5kVHlwZShtYXNrLCAnbnVtYmVyJywgcHJvcCArICcubWFzaycsIGVudi5jb21tYW5kU3RyKVxuICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIGNvbXBhcmVGdW5jc1tjbXBdLFxuICAgICAgICAgICAgICAgIHJlZixcbiAgICAgICAgICAgICAgICBtYXNrXG4gICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmdW5jdGlvbiAoZW52LCBzY29wZSwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgdmFyIENPTVBBUkVfRlVOQ1MgPSBlbnYuY29uc3RhbnRzLmNvbXBhcmVGdW5jc1xuICAgICAgICAgICAgICBjaGVjayQxLm9wdGlvbmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBhc3NlcnQgKCkge1xuICAgICAgICAgICAgICAgICAgZW52LmFzc2VydChzY29wZSxcbiAgICAgICAgICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLmpvaW4uY2FsbChhcmd1bWVudHMsICcnKSxcbiAgICAgICAgICAgICAgICAgICAgJ2ludmFsaWQgc3RlbmNpbC5mdW5jJylcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYXNzZXJ0KHZhbHVlICsgJyYmdHlwZW9mICcsIHZhbHVlLCAnPT09XCJvYmplY3RcIicpXG4gICAgICAgICAgICAgICAgYXNzZXJ0KCchKFwiY21wXCIgaW4gJywgdmFsdWUsICcpfHwoJyxcbiAgICAgICAgICAgICAgICAgIHZhbHVlLCAnLmNtcCBpbiAnLCBDT01QQVJFX0ZVTkNTLCAnKScpXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIHZhciBjbXAgPSBzY29wZS5kZWYoXG4gICAgICAgICAgICAgICAgJ1wiY21wXCIgaW4gJywgdmFsdWUsXG4gICAgICAgICAgICAgICAgJz8nLCBDT01QQVJFX0ZVTkNTLCAnWycsIHZhbHVlLCAnLmNtcF0nLFxuICAgICAgICAgICAgICAgICc6JywgR0xfS0VFUClcbiAgICAgICAgICAgICAgdmFyIHJlZiA9IHNjb3BlLmRlZih2YWx1ZSwgJy5yZWZ8MCcpXG4gICAgICAgICAgICAgIHZhciBtYXNrID0gc2NvcGUuZGVmKFxuICAgICAgICAgICAgICAgICdcIm1hc2tcIiBpbiAnLCB2YWx1ZSxcbiAgICAgICAgICAgICAgICAnPycsIHZhbHVlLCAnLm1hc2t8MDotMScpXG4gICAgICAgICAgICAgIHJldHVybiBbY21wLCByZWYsIG1hc2tdXG4gICAgICAgICAgICB9KVxuXG4gICAgICAgIGNhc2UgU19TVEVOQ0lMX09QRlJPTlQ6XG4gICAgICAgIGNhc2UgU19TVEVOQ0lMX09QQkFDSzpcbiAgICAgICAgICByZXR1cm4gcGFyc2VQYXJhbShcbiAgICAgICAgICAgIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICBjaGVjayQxLmNvbW1hbmRUeXBlKHZhbHVlLCAnb2JqZWN0JywgcGFyYW0sIGVudi5jb21tYW5kU3RyKVxuICAgICAgICAgICAgICB2YXIgZmFpbCA9IHZhbHVlLmZhaWwgfHwgJ2tlZXAnXG4gICAgICAgICAgICAgIHZhciB6ZmFpbCA9IHZhbHVlLnpmYWlsIHx8ICdrZWVwJ1xuICAgICAgICAgICAgICB2YXIgenBhc3MgPSB2YWx1ZS56cGFzcyB8fCAna2VlcCdcbiAgICAgICAgICAgICAgY2hlY2skMS5jb21tYW5kUGFyYW1ldGVyKGZhaWwsIHN0ZW5jaWxPcHMsIHByb3AgKyAnLmZhaWwnLCBlbnYuY29tbWFuZFN0cilcbiAgICAgICAgICAgICAgY2hlY2skMS5jb21tYW5kUGFyYW1ldGVyKHpmYWlsLCBzdGVuY2lsT3BzLCBwcm9wICsgJy56ZmFpbCcsIGVudi5jb21tYW5kU3RyKVxuICAgICAgICAgICAgICBjaGVjayQxLmNvbW1hbmRQYXJhbWV0ZXIoenBhc3MsIHN0ZW5jaWxPcHMsIHByb3AgKyAnLnpwYXNzJywgZW52LmNvbW1hbmRTdHIpXG4gICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgcHJvcCA9PT0gU19TVEVOQ0lMX09QQkFDSyA/IEdMX0JBQ0sgOiBHTF9GUk9OVCxcbiAgICAgICAgICAgICAgICBzdGVuY2lsT3BzW2ZhaWxdLFxuICAgICAgICAgICAgICAgIHN0ZW5jaWxPcHNbemZhaWxdLFxuICAgICAgICAgICAgICAgIHN0ZW5jaWxPcHNbenBhc3NdXG4gICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmdW5jdGlvbiAoZW52LCBzY29wZSwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgdmFyIFNURU5DSUxfT1BTID0gZW52LmNvbnN0YW50cy5zdGVuY2lsT3BzXG5cbiAgICAgICAgICAgICAgY2hlY2skMS5vcHRpb25hbChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgZW52LmFzc2VydChzY29wZSxcbiAgICAgICAgICAgICAgICAgIHZhbHVlICsgJyYmdHlwZW9mICcgKyB2YWx1ZSArICc9PT1cIm9iamVjdFwiJyxcbiAgICAgICAgICAgICAgICAgICdpbnZhbGlkICcgKyBwcm9wKVxuICAgICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICAgIGZ1bmN0aW9uIHJlYWQgKG5hbWUpIHtcbiAgICAgICAgICAgICAgICBjaGVjayQxLm9wdGlvbmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgIGVudi5hc3NlcnQoc2NvcGUsXG4gICAgICAgICAgICAgICAgICAgICchKFwiJyArIG5hbWUgKyAnXCIgaW4gJyArIHZhbHVlICsgJyl8fCcgK1xuICAgICAgICAgICAgICAgICAgICAnKCcgKyB2YWx1ZSArICcuJyArIG5hbWUgKyAnIGluICcgKyBTVEVOQ0lMX09QUyArICcpJyxcbiAgICAgICAgICAgICAgICAgICAgJ2ludmFsaWQgJyArIHByb3AgKyAnLicgKyBuYW1lICsgJywgbXVzdCBiZSBvbmUgb2YgJyArIE9iamVjdC5rZXlzKHN0ZW5jaWxPcHMpKVxuICAgICAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgICAgICByZXR1cm4gc2NvcGUuZGVmKFxuICAgICAgICAgICAgICAgICAgJ1wiJywgbmFtZSwgJ1wiIGluICcsIHZhbHVlLFxuICAgICAgICAgICAgICAgICAgJz8nLCBTVEVOQ0lMX09QUywgJ1snLCB2YWx1ZSwgJy4nLCBuYW1lLCAnXTonLFxuICAgICAgICAgICAgICAgICAgR0xfS0VFUClcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgcHJvcCA9PT0gU19TVEVOQ0lMX09QQkFDSyA/IEdMX0JBQ0sgOiBHTF9GUk9OVCxcbiAgICAgICAgICAgICAgICByZWFkKCdmYWlsJyksXG4gICAgICAgICAgICAgICAgcmVhZCgnemZhaWwnKSxcbiAgICAgICAgICAgICAgICByZWFkKCd6cGFzcycpXG4gICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH0pXG5cbiAgICAgICAgY2FzZSBTX1BPTFlHT05fT0ZGU0VUX09GRlNFVDpcbiAgICAgICAgICByZXR1cm4gcGFyc2VQYXJhbShcbiAgICAgICAgICAgIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICBjaGVjayQxLmNvbW1hbmRUeXBlKHZhbHVlLCAnb2JqZWN0JywgcGFyYW0sIGVudi5jb21tYW5kU3RyKVxuICAgICAgICAgICAgICB2YXIgZmFjdG9yID0gdmFsdWUuZmFjdG9yIHwgMFxuICAgICAgICAgICAgICB2YXIgdW5pdHMgPSB2YWx1ZS51bml0cyB8IDBcbiAgICAgICAgICAgICAgY2hlY2skMS5jb21tYW5kVHlwZShmYWN0b3IsICdudW1iZXInLCBwYXJhbSArICcuZmFjdG9yJywgZW52LmNvbW1hbmRTdHIpXG4gICAgICAgICAgICAgIGNoZWNrJDEuY29tbWFuZFR5cGUodW5pdHMsICdudW1iZXInLCBwYXJhbSArICcudW5pdHMnLCBlbnYuY29tbWFuZFN0cilcbiAgICAgICAgICAgICAgcmV0dXJuIFtmYWN0b3IsIHVuaXRzXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChlbnYsIHNjb3BlLCB2YWx1ZSkge1xuICAgICAgICAgICAgICBjaGVjayQxLm9wdGlvbmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBlbnYuYXNzZXJ0KHNjb3BlLFxuICAgICAgICAgICAgICAgICAgdmFsdWUgKyAnJiZ0eXBlb2YgJyArIHZhbHVlICsgJz09PVwib2JqZWN0XCInLFxuICAgICAgICAgICAgICAgICAgJ2ludmFsaWQgJyArIHByb3ApXG4gICAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgICAgdmFyIEZBQ1RPUiA9IHNjb3BlLmRlZih2YWx1ZSwgJy5mYWN0b3J8MCcpXG4gICAgICAgICAgICAgIHZhciBVTklUUyA9IHNjb3BlLmRlZih2YWx1ZSwgJy51bml0c3wwJylcblxuICAgICAgICAgICAgICByZXR1cm4gW0ZBQ1RPUiwgVU5JVFNdXG4gICAgICAgICAgICB9KVxuXG4gICAgICAgIGNhc2UgU19DVUxMX0ZBQ0U6XG4gICAgICAgICAgcmV0dXJuIHBhcnNlUGFyYW0oXG4gICAgICAgICAgICBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgdmFyIGZhY2UgPSAwXG4gICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gJ2Zyb250Jykge1xuICAgICAgICAgICAgICAgIGZhY2UgPSBHTF9GUk9OVFxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlID09PSAnYmFjaycpIHtcbiAgICAgICAgICAgICAgICBmYWNlID0gR0xfQkFDS1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNoZWNrJDEuY29tbWFuZCghIWZhY2UsIHBhcmFtLCBlbnYuY29tbWFuZFN0cilcbiAgICAgICAgICAgICAgcmV0dXJuIGZhY2VcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmdW5jdGlvbiAoZW52LCBzY29wZSwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgY2hlY2skMS5vcHRpb25hbChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgZW52LmFzc2VydChzY29wZSxcbiAgICAgICAgICAgICAgICAgIHZhbHVlICsgJz09PVwiZnJvbnRcInx8JyArXG4gICAgICAgICAgICAgICAgICB2YWx1ZSArICc9PT1cImJhY2tcIicsXG4gICAgICAgICAgICAgICAgICAnaW52YWxpZCBjdWxsLmZhY2UnKVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICByZXR1cm4gc2NvcGUuZGVmKHZhbHVlLCAnPT09XCJmcm9udFwiPycsIEdMX0ZST05ULCAnOicsIEdMX0JBQ0spXG4gICAgICAgICAgICB9KVxuXG4gICAgICAgIGNhc2UgU19MSU5FX1dJRFRIOlxuICAgICAgICAgIHJldHVybiBwYXJzZVBhcmFtKFxuICAgICAgICAgICAgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgIGNoZWNrJDEuY29tbWFuZChcbiAgICAgICAgICAgICAgICB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmXG4gICAgICAgICAgICAgICAgdmFsdWUgPj0gbGltaXRzLmxpbmVXaWR0aERpbXNbMF0gJiZcbiAgICAgICAgICAgICAgICB2YWx1ZSA8PSBsaW1pdHMubGluZVdpZHRoRGltc1sxXSxcbiAgICAgICAgICAgICAgICAnaW52YWxpZCBsaW5lIHdpZHRoLCBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyIGJldHdlZW4gJyArXG4gICAgICAgICAgICAgICAgbGltaXRzLmxpbmVXaWR0aERpbXNbMF0gKyAnIGFuZCAnICsgbGltaXRzLmxpbmVXaWR0aERpbXNbMV0sIGVudi5jb21tYW5kU3RyKVxuICAgICAgICAgICAgICByZXR1cm4gdmFsdWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmdW5jdGlvbiAoZW52LCBzY29wZSwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgY2hlY2skMS5vcHRpb25hbChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgZW52LmFzc2VydChzY29wZSxcbiAgICAgICAgICAgICAgICAgICd0eXBlb2YgJyArIHZhbHVlICsgJz09PVwibnVtYmVyXCImJicgK1xuICAgICAgICAgICAgICAgICAgdmFsdWUgKyAnPj0nICsgbGltaXRzLmxpbmVXaWR0aERpbXNbMF0gKyAnJiYnICtcbiAgICAgICAgICAgICAgICAgIHZhbHVlICsgJzw9JyArIGxpbWl0cy5saW5lV2lkdGhEaW1zWzFdLFxuICAgICAgICAgICAgICAgICAgJ2ludmFsaWQgbGluZSB3aWR0aCcpXG4gICAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlXG4gICAgICAgICAgICB9KVxuXG4gICAgICAgIGNhc2UgU19GUk9OVF9GQUNFOlxuICAgICAgICAgIHJldHVybiBwYXJzZVBhcmFtKFxuICAgICAgICAgICAgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgIGNoZWNrJDEuY29tbWFuZFBhcmFtZXRlcih2YWx1ZSwgb3JpZW50YXRpb25UeXBlLCBwYXJhbSwgZW52LmNvbW1hbmRTdHIpXG4gICAgICAgICAgICAgIHJldHVybiBvcmllbnRhdGlvblR5cGVbdmFsdWVdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZnVuY3Rpb24gKGVudiwgc2NvcGUsIHZhbHVlKSB7XG4gICAgICAgICAgICAgIGNoZWNrJDEub3B0aW9uYWwoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGVudi5hc3NlcnQoc2NvcGUsXG4gICAgICAgICAgICAgICAgICB2YWx1ZSArICc9PT1cImN3XCJ8fCcgK1xuICAgICAgICAgICAgICAgICAgdmFsdWUgKyAnPT09XCJjY3dcIicsXG4gICAgICAgICAgICAgICAgICAnaW52YWxpZCBmcm9udEZhY2UsIG11c3QgYmUgb25lIG9mIGN3LGNjdycpXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIHJldHVybiBzY29wZS5kZWYodmFsdWUgKyAnPT09XCJjd1wiPycgKyBHTF9DVyArICc6JyArIEdMX0NDVylcbiAgICAgICAgICAgIH0pXG5cbiAgICAgICAgY2FzZSBTX0NPTE9SX01BU0s6XG4gICAgICAgICAgcmV0dXJuIHBhcnNlUGFyYW0oXG4gICAgICAgICAgICBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgY2hlY2skMS5jb21tYW5kKFxuICAgICAgICAgICAgICAgIGlzQXJyYXlMaWtlKHZhbHVlKSAmJiB2YWx1ZS5sZW5ndGggPT09IDQsXG4gICAgICAgICAgICAgICAgJ2NvbG9yLm1hc2sgbXVzdCBiZSBsZW5ndGggNCBhcnJheScsIGVudi5jb21tYW5kU3RyKVxuICAgICAgICAgICAgICByZXR1cm4gdmFsdWUubWFwKGZ1bmN0aW9uICh2KSB7IHJldHVybiAhIXYgfSlcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmdW5jdGlvbiAoZW52LCBzY29wZSwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgY2hlY2skMS5vcHRpb25hbChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgZW52LmFzc2VydChzY29wZSxcbiAgICAgICAgICAgICAgICAgIGVudi5zaGFyZWQuaXNBcnJheUxpa2UgKyAnKCcgKyB2YWx1ZSArICcpJiYnICtcbiAgICAgICAgICAgICAgICAgIHZhbHVlICsgJy5sZW5ndGg9PT00JyxcbiAgICAgICAgICAgICAgICAgICdpbnZhbGlkIGNvbG9yLm1hc2snKVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICByZXR1cm4gbG9vcCg0LCBmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnISEnICsgdmFsdWUgKyAnWycgKyBpICsgJ10nXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KVxuXG4gICAgICAgIGNhc2UgU19TQU1QTEVfQ09WRVJBR0U6XG4gICAgICAgICAgcmV0dXJuIHBhcnNlUGFyYW0oXG4gICAgICAgICAgICBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgY2hlY2skMS5jb21tYW5kKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUsIHBhcmFtLCBlbnYuY29tbWFuZFN0cilcbiAgICAgICAgICAgICAgdmFyIHNhbXBsZVZhbHVlID0gJ3ZhbHVlJyBpbiB2YWx1ZSA/IHZhbHVlLnZhbHVlIDogMVxuICAgICAgICAgICAgICB2YXIgc2FtcGxlSW52ZXJ0ID0gISF2YWx1ZS5pbnZlcnRcbiAgICAgICAgICAgICAgY2hlY2skMS5jb21tYW5kKFxuICAgICAgICAgICAgICAgIHR5cGVvZiBzYW1wbGVWYWx1ZSA9PT0gJ251bWJlcicgJiZcbiAgICAgICAgICAgICAgICBzYW1wbGVWYWx1ZSA+PSAwICYmIHNhbXBsZVZhbHVlIDw9IDEsXG4gICAgICAgICAgICAgICAgJ3NhbXBsZS5jb3ZlcmFnZS52YWx1ZSBtdXN0IGJlIGEgbnVtYmVyIGJldHdlZW4gMCBhbmQgMScsIGVudi5jb21tYW5kU3RyKVxuICAgICAgICAgICAgICByZXR1cm4gW3NhbXBsZVZhbHVlLCBzYW1wbGVJbnZlcnRdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZnVuY3Rpb24gKGVudiwgc2NvcGUsIHZhbHVlKSB7XG4gICAgICAgICAgICAgIGNoZWNrJDEub3B0aW9uYWwoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGVudi5hc3NlcnQoc2NvcGUsXG4gICAgICAgICAgICAgICAgICB2YWx1ZSArICcmJnR5cGVvZiAnICsgdmFsdWUgKyAnPT09XCJvYmplY3RcIicsXG4gICAgICAgICAgICAgICAgICAnaW52YWxpZCBzYW1wbGUuY292ZXJhZ2UnKVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICB2YXIgVkFMVUUgPSBzY29wZS5kZWYoXG4gICAgICAgICAgICAgICAgJ1widmFsdWVcIiBpbiAnLCB2YWx1ZSwgJz8rJywgdmFsdWUsICcudmFsdWU6MScpXG4gICAgICAgICAgICAgIHZhciBJTlZFUlQgPSBzY29wZS5kZWYoJyEhJywgdmFsdWUsICcuaW52ZXJ0JylcbiAgICAgICAgICAgICAgcmV0dXJuIFtWQUxVRSwgSU5WRVJUXVxuICAgICAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgcmV0dXJuIFNUQVRFXG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZVVuaWZvcm1zICh1bmlmb3JtcywgZW52KSB7XG4gICAgdmFyIHN0YXRpY1VuaWZvcm1zID0gdW5pZm9ybXMuc3RhdGljXG4gICAgdmFyIGR5bmFtaWNVbmlmb3JtcyA9IHVuaWZvcm1zLmR5bmFtaWNcblxuICAgIHZhciBVTklGT1JNUyA9IHt9XG5cbiAgICBPYmplY3Qua2V5cyhzdGF0aWNVbmlmb3JtcykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgdmFyIHZhbHVlID0gc3RhdGljVW5pZm9ybXNbbmFtZV1cbiAgICAgIHZhciByZXN1bHRcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInIHx8XG4gICAgICAgICAgdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgcmVzdWx0ID0gY3JlYXRlU3RhdGljRGVjbChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlXG4gICAgICAgIH0pXG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB2YXIgcmVnbFR5cGUgPSB2YWx1ZS5fcmVnbFR5cGVcbiAgICAgICAgaWYgKHJlZ2xUeXBlID09PSAndGV4dHVyZTJkJyB8fFxuICAgICAgICAgICAgcmVnbFR5cGUgPT09ICd0ZXh0dXJlQ3ViZScpIHtcbiAgICAgICAgICByZXN1bHQgPSBjcmVhdGVTdGF0aWNEZWNsKGZ1bmN0aW9uIChlbnYpIHtcbiAgICAgICAgICAgIHJldHVybiBlbnYubGluayh2YWx1ZSlcbiAgICAgICAgICB9KVxuICAgICAgICB9IGVsc2UgaWYgKHJlZ2xUeXBlID09PSAnZnJhbWVidWZmZXInIHx8XG4gICAgICAgICAgICAgICAgICAgcmVnbFR5cGUgPT09ICdmcmFtZWJ1ZmZlckN1YmUnKSB7XG4gICAgICAgICAgY2hlY2skMS5jb21tYW5kKHZhbHVlLmNvbG9yLmxlbmd0aCA+IDAsXG4gICAgICAgICAgICAnbWlzc2luZyBjb2xvciBhdHRhY2htZW50IGZvciBmcmFtZWJ1ZmZlciBzZW50IHRvIHVuaWZvcm0gXCInICsgbmFtZSArICdcIicsIGVudi5jb21tYW5kU3RyKVxuICAgICAgICAgIHJlc3VsdCA9IGNyZWF0ZVN0YXRpY0RlY2woZnVuY3Rpb24gKGVudikge1xuICAgICAgICAgICAgcmV0dXJuIGVudi5saW5rKHZhbHVlLmNvbG9yWzBdKVxuICAgICAgICAgIH0pXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2hlY2skMS5jb21tYW5kUmFpc2UoJ2ludmFsaWQgZGF0YSBmb3IgdW5pZm9ybSBcIicgKyBuYW1lICsgJ1wiJywgZW52LmNvbW1hbmRTdHIpXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaXNBcnJheUxpa2UodmFsdWUpKSB7XG4gICAgICAgIHJlc3VsdCA9IGNyZWF0ZVN0YXRpY0RlY2woZnVuY3Rpb24gKGVudikge1xuICAgICAgICAgIHZhciBJVEVNID0gZW52Lmdsb2JhbC5kZWYoJ1snLFxuICAgICAgICAgICAgbG9vcCh2YWx1ZS5sZW5ndGgsIGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgICAgIGNoZWNrJDEuY29tbWFuZChcbiAgICAgICAgICAgICAgICB0eXBlb2YgdmFsdWVbaV0gPT09ICdudW1iZXInIHx8XG4gICAgICAgICAgICAgICAgdHlwZW9mIHZhbHVlW2ldID09PSAnYm9vbGVhbicsXG4gICAgICAgICAgICAgICAgJ2ludmFsaWQgdW5pZm9ybSAnICsgbmFtZSwgZW52LmNvbW1hbmRTdHIpXG4gICAgICAgICAgICAgIHJldHVybiB2YWx1ZVtpXVxuICAgICAgICAgICAgfSksICddJylcbiAgICAgICAgICByZXR1cm4gSVRFTVxuICAgICAgICB9KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2hlY2skMS5jb21tYW5kUmFpc2UoJ2ludmFsaWQgb3IgbWlzc2luZyBkYXRhIGZvciB1bmlmb3JtIFwiJyArIG5hbWUgKyAnXCInLCBlbnYuY29tbWFuZFN0cilcbiAgICAgIH1cbiAgICAgIHJlc3VsdC52YWx1ZSA9IHZhbHVlXG4gICAgICBVTklGT1JNU1tuYW1lXSA9IHJlc3VsdFxuICAgIH0pXG5cbiAgICBPYmplY3Qua2V5cyhkeW5hbWljVW5pZm9ybXMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgdmFyIGR5biA9IGR5bmFtaWNVbmlmb3Jtc1trZXldXG4gICAgICBVTklGT1JNU1trZXldID0gY3JlYXRlRHluYW1pY0RlY2woZHluLCBmdW5jdGlvbiAoZW52LCBzY29wZSkge1xuICAgICAgICByZXR1cm4gZW52Lmludm9rZShzY29wZSwgZHluKVxuICAgICAgfSlcbiAgICB9KVxuXG4gICAgcmV0dXJuIFVOSUZPUk1TXG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZUF0dHJpYnV0ZXMgKGF0dHJpYnV0ZXMsIGVudikge1xuICAgIHZhciBzdGF0aWNBdHRyaWJ1dGVzID0gYXR0cmlidXRlcy5zdGF0aWNcbiAgICB2YXIgZHluYW1pY0F0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzLmR5bmFtaWNcblxuICAgIHZhciBhdHRyaWJ1dGVEZWZzID0ge31cblxuICAgIE9iamVjdC5rZXlzKHN0YXRpY0F0dHJpYnV0ZXMpLmZvckVhY2goZnVuY3Rpb24gKGF0dHJpYnV0ZSkge1xuICAgICAgdmFyIHZhbHVlID0gc3RhdGljQXR0cmlidXRlc1thdHRyaWJ1dGVdXG4gICAgICB2YXIgaWQgPSBzdHJpbmdTdG9yZS5pZChhdHRyaWJ1dGUpXG5cbiAgICAgIHZhciByZWNvcmQgPSBuZXcgQXR0cmlidXRlUmVjb3JkKClcbiAgICAgIGlmIChpc0J1ZmZlckFyZ3ModmFsdWUpKSB7XG4gICAgICAgIHJlY29yZC5zdGF0ZSA9IEFUVFJJQl9TVEFURV9QT0lOVEVSXG4gICAgICAgIHJlY29yZC5idWZmZXIgPSBidWZmZXJTdGF0ZS5nZXRCdWZmZXIoXG4gICAgICAgICAgYnVmZmVyU3RhdGUuY3JlYXRlKHZhbHVlLCBHTF9BUlJBWV9CVUZGRVIkMiwgZmFsc2UsIHRydWUpKVxuICAgICAgICByZWNvcmQudHlwZSA9IDBcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBidWZmZXIgPSBidWZmZXJTdGF0ZS5nZXRCdWZmZXIodmFsdWUpXG4gICAgICAgIGlmIChidWZmZXIpIHtcbiAgICAgICAgICByZWNvcmQuc3RhdGUgPSBBVFRSSUJfU1RBVEVfUE9JTlRFUlxuICAgICAgICAgIHJlY29yZC5idWZmZXIgPSBidWZmZXJcbiAgICAgICAgICByZWNvcmQudHlwZSA9IDBcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjaGVjayQxLmNvbW1hbmQodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSxcbiAgICAgICAgICAgICdpbnZhbGlkIGRhdGEgZm9yIGF0dHJpYnV0ZSAnICsgYXR0cmlidXRlLCBlbnYuY29tbWFuZFN0cilcbiAgICAgICAgICBpZiAoJ2NvbnN0YW50JyBpbiB2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIGNvbnN0YW50ID0gdmFsdWUuY29uc3RhbnRcbiAgICAgICAgICAgIHJlY29yZC5idWZmZXIgPSAnbnVsbCdcbiAgICAgICAgICAgIHJlY29yZC5zdGF0ZSA9IEFUVFJJQl9TVEFURV9DT05TVEFOVFxuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb25zdGFudCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgcmVjb3JkLnggPSBjb25zdGFudFxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY2hlY2skMS5jb21tYW5kKFxuICAgICAgICAgICAgICAgIGlzQXJyYXlMaWtlKGNvbnN0YW50KSAmJlxuICAgICAgICAgICAgICAgIGNvbnN0YW50Lmxlbmd0aCA+IDAgJiZcbiAgICAgICAgICAgICAgICBjb25zdGFudC5sZW5ndGggPD0gNCxcbiAgICAgICAgICAgICAgICAnaW52YWxpZCBjb25zdGFudCBmb3IgYXR0cmlidXRlICcgKyBhdHRyaWJ1dGUsIGVudi5jb21tYW5kU3RyKVxuICAgICAgICAgICAgICBDVVRFX0NPTVBPTkVOVFMuZm9yRWFjaChmdW5jdGlvbiAoYywgaSkge1xuICAgICAgICAgICAgICAgIGlmIChpIDwgY29uc3RhbnQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICByZWNvcmRbY10gPSBjb25zdGFudFtpXVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGlzQnVmZmVyQXJncyh2YWx1ZS5idWZmZXIpKSB7XG4gICAgICAgICAgICAgIGJ1ZmZlciA9IGJ1ZmZlclN0YXRlLmdldEJ1ZmZlcihcbiAgICAgICAgICAgICAgICBidWZmZXJTdGF0ZS5jcmVhdGUodmFsdWUuYnVmZmVyLCBHTF9BUlJBWV9CVUZGRVIkMiwgZmFsc2UsIHRydWUpKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgYnVmZmVyID0gYnVmZmVyU3RhdGUuZ2V0QnVmZmVyKHZhbHVlLmJ1ZmZlcilcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNoZWNrJDEuY29tbWFuZCghIWJ1ZmZlciwgJ21pc3NpbmcgYnVmZmVyIGZvciBhdHRyaWJ1dGUgXCInICsgYXR0cmlidXRlICsgJ1wiJywgZW52LmNvbW1hbmRTdHIpXG5cbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSB2YWx1ZS5vZmZzZXQgfCAwXG4gICAgICAgICAgICBjaGVjayQxLmNvbW1hbmQob2Zmc2V0ID49IDAsXG4gICAgICAgICAgICAgICdpbnZhbGlkIG9mZnNldCBmb3IgYXR0cmlidXRlIFwiJyArIGF0dHJpYnV0ZSArICdcIicsIGVudi5jb21tYW5kU3RyKVxuXG4gICAgICAgICAgICB2YXIgc3RyaWRlID0gdmFsdWUuc3RyaWRlIHwgMFxuICAgICAgICAgICAgY2hlY2skMS5jb21tYW5kKHN0cmlkZSA+PSAwICYmIHN0cmlkZSA8IDI1NixcbiAgICAgICAgICAgICAgJ2ludmFsaWQgc3RyaWRlIGZvciBhdHRyaWJ1dGUgXCInICsgYXR0cmlidXRlICsgJ1wiLCBtdXN0IGJlIGludGVnZXIgYmV0d2VlZW4gWzAsIDI1NV0nLCBlbnYuY29tbWFuZFN0cilcblxuICAgICAgICAgICAgdmFyIHNpemUgPSB2YWx1ZS5zaXplIHwgMFxuICAgICAgICAgICAgY2hlY2skMS5jb21tYW5kKCEoJ3NpemUnIGluIHZhbHVlKSB8fCAoc2l6ZSA+IDAgJiYgc2l6ZSA8PSA0KSxcbiAgICAgICAgICAgICAgJ2ludmFsaWQgc2l6ZSBmb3IgYXR0cmlidXRlIFwiJyArIGF0dHJpYnV0ZSArICdcIiwgbXVzdCBiZSAxLDIsMyw0JywgZW52LmNvbW1hbmRTdHIpXG5cbiAgICAgICAgICAgIHZhciBub3JtYWxpemVkID0gISF2YWx1ZS5ub3JtYWxpemVkXG5cbiAgICAgICAgICAgIHZhciB0eXBlID0gMFxuICAgICAgICAgICAgaWYgKCd0eXBlJyBpbiB2YWx1ZSkge1xuICAgICAgICAgICAgICBjaGVjayQxLmNvbW1hbmRQYXJhbWV0ZXIoXG4gICAgICAgICAgICAgICAgdmFsdWUudHlwZSwgZ2xUeXBlcyxcbiAgICAgICAgICAgICAgICAnaW52YWxpZCB0eXBlIGZvciBhdHRyaWJ1dGUgJyArIGF0dHJpYnV0ZSwgZW52LmNvbW1hbmRTdHIpXG4gICAgICAgICAgICAgIHR5cGUgPSBnbFR5cGVzW3ZhbHVlLnR5cGVdXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBkaXZpc29yID0gdmFsdWUuZGl2aXNvciB8IDBcbiAgICAgICAgICAgIGlmICgnZGl2aXNvcicgaW4gdmFsdWUpIHtcbiAgICAgICAgICAgICAgY2hlY2skMS5jb21tYW5kKGRpdmlzb3IgPT09IDAgfHwgZXh0SW5zdGFuY2luZyxcbiAgICAgICAgICAgICAgICAnY2Fubm90IHNwZWNpZnkgZGl2aXNvciBmb3IgYXR0cmlidXRlIFwiJyArIGF0dHJpYnV0ZSArICdcIiwgaW5zdGFuY2luZyBub3Qgc3VwcG9ydGVkJywgZW52LmNvbW1hbmRTdHIpXG4gICAgICAgICAgICAgIGNoZWNrJDEuY29tbWFuZChkaXZpc29yID49IDAsXG4gICAgICAgICAgICAgICAgJ2ludmFsaWQgZGl2aXNvciBmb3IgYXR0cmlidXRlIFwiJyArIGF0dHJpYnV0ZSArICdcIicsIGVudi5jb21tYW5kU3RyKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjaGVjayQxLm9wdGlvbmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgdmFyIGNvbW1hbmQgPSBlbnYuY29tbWFuZFN0clxuXG4gICAgICAgICAgICAgIHZhciBWQUxJRF9LRVlTID0gW1xuICAgICAgICAgICAgICAgICdidWZmZXInLFxuICAgICAgICAgICAgICAgICdvZmZzZXQnLFxuICAgICAgICAgICAgICAgICdkaXZpc29yJyxcbiAgICAgICAgICAgICAgICAnbm9ybWFsaXplZCcsXG4gICAgICAgICAgICAgICAgJ3R5cGUnLFxuICAgICAgICAgICAgICAgICdzaXplJyxcbiAgICAgICAgICAgICAgICAnc3RyaWRlJ1xuICAgICAgICAgICAgICBdXG5cbiAgICAgICAgICAgICAgT2JqZWN0LmtleXModmFsdWUpLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgICAgICAgICBjaGVjayQxLmNvbW1hbmQoXG4gICAgICAgICAgICAgICAgICBWQUxJRF9LRVlTLmluZGV4T2YocHJvcCkgPj0gMCxcbiAgICAgICAgICAgICAgICAgICd1bmtub3duIHBhcmFtZXRlciBcIicgKyBwcm9wICsgJ1wiIGZvciBhdHRyaWJ1dGUgcG9pbnRlciBcIicgKyBhdHRyaWJ1dGUgKyAnXCIgKHZhbGlkIHBhcmFtZXRlcnMgYXJlICcgKyBWQUxJRF9LRVlTICsgJyknLFxuICAgICAgICAgICAgICAgICAgY29tbWFuZClcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgIHJlY29yZC5idWZmZXIgPSBidWZmZXJcbiAgICAgICAgICAgIHJlY29yZC5zdGF0ZSA9IEFUVFJJQl9TVEFURV9QT0lOVEVSXG4gICAgICAgICAgICByZWNvcmQuc2l6ZSA9IHNpemVcbiAgICAgICAgICAgIHJlY29yZC5ub3JtYWxpemVkID0gbm9ybWFsaXplZFxuICAgICAgICAgICAgcmVjb3JkLnR5cGUgPSB0eXBlIHx8IGJ1ZmZlci5kdHlwZVxuICAgICAgICAgICAgcmVjb3JkLm9mZnNldCA9IG9mZnNldFxuICAgICAgICAgICAgcmVjb3JkLnN0cmlkZSA9IHN0cmlkZVxuICAgICAgICAgICAgcmVjb3JkLmRpdmlzb3IgPSBkaXZpc29yXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGF0dHJpYnV0ZURlZnNbYXR0cmlidXRlXSA9IGNyZWF0ZVN0YXRpY0RlY2woZnVuY3Rpb24gKGVudiwgc2NvcGUpIHtcbiAgICAgICAgdmFyIGNhY2hlID0gZW52LmF0dHJpYkNhY2hlXG4gICAgICAgIGlmIChpZCBpbiBjYWNoZSkge1xuICAgICAgICAgIHJldHVybiBjYWNoZVtpZF1cbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzdWx0ID0ge1xuICAgICAgICAgIGlzU3RyZWFtOiBmYWxzZVxuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5rZXlzKHJlY29yZCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgcmVzdWx0W2tleV0gPSByZWNvcmRba2V5XVxuICAgICAgICB9KVxuICAgICAgICBpZiAocmVjb3JkLmJ1ZmZlcikge1xuICAgICAgICAgIHJlc3VsdC5idWZmZXIgPSBlbnYubGluayhyZWNvcmQuYnVmZmVyKVxuICAgICAgICAgIHJlc3VsdC50eXBlID0gcmVzdWx0LnR5cGUgfHwgKHJlc3VsdC5idWZmZXIgKyAnLmR0eXBlJylcbiAgICAgICAgfVxuICAgICAgICBjYWNoZVtpZF0gPSByZXN1bHRcbiAgICAgICAgcmV0dXJuIHJlc3VsdFxuICAgICAgfSlcbiAgICB9KVxuXG4gICAgT2JqZWN0LmtleXMoZHluYW1pY0F0dHJpYnV0ZXMpLmZvckVhY2goZnVuY3Rpb24gKGF0dHJpYnV0ZSkge1xuICAgICAgdmFyIGR5biA9IGR5bmFtaWNBdHRyaWJ1dGVzW2F0dHJpYnV0ZV1cblxuICAgICAgZnVuY3Rpb24gYXBwZW5kQXR0cmlidXRlQ29kZSAoZW52LCBibG9jaykge1xuICAgICAgICB2YXIgVkFMVUUgPSBlbnYuaW52b2tlKGJsb2NrLCBkeW4pXG5cbiAgICAgICAgdmFyIHNoYXJlZCA9IGVudi5zaGFyZWRcbiAgICAgICAgdmFyIGNvbnN0YW50cyA9IGVudi5jb25zdGFudHNcblxuICAgICAgICB2YXIgSVNfQlVGRkVSX0FSR1MgPSBzaGFyZWQuaXNCdWZmZXJBcmdzXG4gICAgICAgIHZhciBCVUZGRVJfU1RBVEUgPSBzaGFyZWQuYnVmZmVyXG5cbiAgICAgICAgLy8gUGVyZm9ybSB2YWxpZGF0aW9uIG9uIGF0dHJpYnV0ZVxuICAgICAgICBjaGVjayQxLm9wdGlvbmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBlbnYuYXNzZXJ0KGJsb2NrLFxuICAgICAgICAgICAgVkFMVUUgKyAnJiYodHlwZW9mICcgKyBWQUxVRSArICc9PT1cIm9iamVjdFwifHx0eXBlb2YgJyArXG4gICAgICAgICAgICBWQUxVRSArICc9PT1cImZ1bmN0aW9uXCIpJiYoJyArXG4gICAgICAgICAgICBJU19CVUZGRVJfQVJHUyArICcoJyArIFZBTFVFICsgJyl8fCcgK1xuICAgICAgICAgICAgQlVGRkVSX1NUQVRFICsgJy5nZXRCdWZmZXIoJyArIFZBTFVFICsgJyl8fCcgK1xuICAgICAgICAgICAgQlVGRkVSX1NUQVRFICsgJy5nZXRCdWZmZXIoJyArIFZBTFVFICsgJy5idWZmZXIpfHwnICtcbiAgICAgICAgICAgIElTX0JVRkZFUl9BUkdTICsgJygnICsgVkFMVUUgKyAnLmJ1ZmZlcil8fCcgK1xuICAgICAgICAgICAgJyhcImNvbnN0YW50XCIgaW4gJyArIFZBTFVFICtcbiAgICAgICAgICAgICcmJih0eXBlb2YgJyArIFZBTFVFICsgJy5jb25zdGFudD09PVwibnVtYmVyXCJ8fCcgK1xuICAgICAgICAgICAgc2hhcmVkLmlzQXJyYXlMaWtlICsgJygnICsgVkFMVUUgKyAnLmNvbnN0YW50KSkpKScsXG4gICAgICAgICAgICAnaW52YWxpZCBkeW5hbWljIGF0dHJpYnV0ZSBcIicgKyBhdHRyaWJ1dGUgKyAnXCInKVxuICAgICAgICB9KVxuXG4gICAgICAgIC8vIGFsbG9jYXRlIG5hbWVzIGZvciByZXN1bHRcbiAgICAgICAgdmFyIHJlc3VsdCA9IHtcbiAgICAgICAgICBpc1N0cmVhbTogYmxvY2suZGVmKGZhbHNlKVxuICAgICAgICB9XG4gICAgICAgIHZhciBkZWZhdWx0UmVjb3JkID0gbmV3IEF0dHJpYnV0ZVJlY29yZCgpXG4gICAgICAgIGRlZmF1bHRSZWNvcmQuc3RhdGUgPSBBVFRSSUJfU1RBVEVfUE9JTlRFUlxuICAgICAgICBPYmplY3Qua2V5cyhkZWZhdWx0UmVjb3JkKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICByZXN1bHRba2V5XSA9IGJsb2NrLmRlZignJyArIGRlZmF1bHRSZWNvcmRba2V5XSlcbiAgICAgICAgfSlcblxuICAgICAgICB2YXIgQlVGRkVSID0gcmVzdWx0LmJ1ZmZlclxuICAgICAgICB2YXIgVFlQRSA9IHJlc3VsdC50eXBlXG4gICAgICAgIGJsb2NrKFxuICAgICAgICAgICdpZignLCBJU19CVUZGRVJfQVJHUywgJygnLCBWQUxVRSwgJykpeycsXG4gICAgICAgICAgcmVzdWx0LmlzU3RyZWFtLCAnPXRydWU7JyxcbiAgICAgICAgICBCVUZGRVIsICc9JywgQlVGRkVSX1NUQVRFLCAnLmNyZWF0ZVN0cmVhbSgnLCBHTF9BUlJBWV9CVUZGRVIkMiwgJywnLCBWQUxVRSwgJyk7JyxcbiAgICAgICAgICBUWVBFLCAnPScsIEJVRkZFUiwgJy5kdHlwZTsnLFxuICAgICAgICAgICd9ZWxzZXsnLFxuICAgICAgICAgIEJVRkZFUiwgJz0nLCBCVUZGRVJfU1RBVEUsICcuZ2V0QnVmZmVyKCcsIFZBTFVFLCAnKTsnLFxuICAgICAgICAgICdpZignLCBCVUZGRVIsICcpeycsXG4gICAgICAgICAgVFlQRSwgJz0nLCBCVUZGRVIsICcuZHR5cGU7JyxcbiAgICAgICAgICAnfWVsc2UgaWYoXCJjb25zdGFudFwiIGluICcsIFZBTFVFLCAnKXsnLFxuICAgICAgICAgIHJlc3VsdC5zdGF0ZSwgJz0nLCBBVFRSSUJfU1RBVEVfQ09OU1RBTlQsICc7JyxcbiAgICAgICAgICAnaWYodHlwZW9mICcgKyBWQUxVRSArICcuY29uc3RhbnQgPT09IFwibnVtYmVyXCIpeycsXG4gICAgICAgICAgcmVzdWx0W0NVVEVfQ09NUE9ORU5UU1swXV0sICc9JywgVkFMVUUsICcuY29uc3RhbnQ7JyxcbiAgICAgICAgICBDVVRFX0NPTVBPTkVOVFMuc2xpY2UoMSkubWFwKGZ1bmN0aW9uIChuKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0W25dXG4gICAgICAgICAgfSkuam9pbignPScpLCAnPTA7JyxcbiAgICAgICAgICAnfWVsc2V7JyxcbiAgICAgICAgICBDVVRFX0NPTVBPTkVOVFMubWFwKGZ1bmN0aW9uIChuYW1lLCBpKSB7XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICByZXN1bHRbbmFtZV0gKyAnPScgKyBWQUxVRSArICcuY29uc3RhbnQubGVuZ3RoPicgKyBpICtcbiAgICAgICAgICAgICAgJz8nICsgVkFMVUUgKyAnLmNvbnN0YW50WycgKyBpICsgJ106MDsnXG4gICAgICAgICAgICApXG4gICAgICAgICAgfSkuam9pbignJyksXG4gICAgICAgICAgJ319ZWxzZXsnLFxuICAgICAgICAgICdpZignLCBJU19CVUZGRVJfQVJHUywgJygnLCBWQUxVRSwgJy5idWZmZXIpKXsnLFxuICAgICAgICAgIEJVRkZFUiwgJz0nLCBCVUZGRVJfU1RBVEUsICcuY3JlYXRlU3RyZWFtKCcsIEdMX0FSUkFZX0JVRkZFUiQyLCAnLCcsIFZBTFVFLCAnLmJ1ZmZlcik7JyxcbiAgICAgICAgICAnfWVsc2V7JyxcbiAgICAgICAgICBCVUZGRVIsICc9JywgQlVGRkVSX1NUQVRFLCAnLmdldEJ1ZmZlcignLCBWQUxVRSwgJy5idWZmZXIpOycsXG4gICAgICAgICAgJ30nLFxuICAgICAgICAgIFRZUEUsICc9XCJ0eXBlXCIgaW4gJywgVkFMVUUsICc/JyxcbiAgICAgICAgICBjb25zdGFudHMuZ2xUeXBlcywgJ1snLCBWQUxVRSwgJy50eXBlXTonLCBCVUZGRVIsICcuZHR5cGU7JyxcbiAgICAgICAgICByZXN1bHQubm9ybWFsaXplZCwgJz0hIScsIFZBTFVFLCAnLm5vcm1hbGl6ZWQ7JylcbiAgICAgICAgZnVuY3Rpb24gZW1pdFJlYWRSZWNvcmQgKG5hbWUpIHtcbiAgICAgICAgICBibG9jayhyZXN1bHRbbmFtZV0sICc9JywgVkFMVUUsICcuJywgbmFtZSwgJ3wwOycpXG4gICAgICAgIH1cbiAgICAgICAgZW1pdFJlYWRSZWNvcmQoJ3NpemUnKVxuICAgICAgICBlbWl0UmVhZFJlY29yZCgnb2Zmc2V0JylcbiAgICAgICAgZW1pdFJlYWRSZWNvcmQoJ3N0cmlkZScpXG4gICAgICAgIGVtaXRSZWFkUmVjb3JkKCdkaXZpc29yJylcblxuICAgICAgICBibG9jaygnfX0nKVxuXG4gICAgICAgIGJsb2NrLmV4aXQoXG4gICAgICAgICAgJ2lmKCcsIHJlc3VsdC5pc1N0cmVhbSwgJyl7JyxcbiAgICAgICAgICBCVUZGRVJfU1RBVEUsICcuZGVzdHJveVN0cmVhbSgnLCBCVUZGRVIsICcpOycsXG4gICAgICAgICAgJ30nKVxuXG4gICAgICAgIHJldHVybiByZXN1bHRcbiAgICAgIH1cblxuICAgICAgYXR0cmlidXRlRGVmc1thdHRyaWJ1dGVdID0gY3JlYXRlRHluYW1pY0RlY2woZHluLCBhcHBlbmRBdHRyaWJ1dGVDb2RlKVxuICAgIH0pXG5cbiAgICByZXR1cm4gYXR0cmlidXRlRGVmc1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VWQU8gKG9wdGlvbnMsIGVudikge1xuICAgIHZhciBzdGF0aWNPcHRpb25zID0gb3B0aW9ucy5zdGF0aWNcbiAgICB2YXIgZHluYW1pY09wdGlvbnMgPSBvcHRpb25zLmR5bmFtaWNcbiAgICBpZiAoU19WQU8gaW4gc3RhdGljT3B0aW9ucykge1xuICAgICAgdmFyIHZhbyA9IHN0YXRpY09wdGlvbnNbU19WQU9dXG4gICAgICBpZiAodmFvICE9PSBudWxsICYmIGF0dHJpYnV0ZVN0YXRlLmdldFZBTyh2YW8pID09PSBudWxsKSB7XG4gICAgICAgIHZhbyA9IGF0dHJpYnV0ZVN0YXRlLmNyZWF0ZVZBTyh2YW8pXG4gICAgICB9XG4gICAgICByZXR1cm4gY3JlYXRlU3RhdGljRGVjbChmdW5jdGlvbiAoZW52KSB7XG4gICAgICAgIHJldHVybiBlbnYubGluayhhdHRyaWJ1dGVTdGF0ZS5nZXRWQU8odmFvKSlcbiAgICAgIH0pXG4gICAgfSBlbHNlIGlmIChTX1ZBTyBpbiBkeW5hbWljT3B0aW9ucykge1xuICAgICAgdmFyIGR5biA9IGR5bmFtaWNPcHRpb25zW1NfVkFPXVxuICAgICAgcmV0dXJuIGNyZWF0ZUR5bmFtaWNEZWNsKGR5biwgZnVuY3Rpb24gKGVudiwgc2NvcGUpIHtcbiAgICAgICAgdmFyIHZhb1JlZiA9IGVudi5pbnZva2Uoc2NvcGUsIGR5bilcbiAgICAgICAgcmV0dXJuIHNjb3BlLmRlZihlbnYuc2hhcmVkLnZhbyArICcuZ2V0VkFPKCcgKyB2YW9SZWYgKyAnKScpXG4gICAgICB9KVxuICAgIH1cbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VDb250ZXh0IChjb250ZXh0KSB7XG4gICAgdmFyIHN0YXRpY0NvbnRleHQgPSBjb250ZXh0LnN0YXRpY1xuICAgIHZhciBkeW5hbWljQ29udGV4dCA9IGNvbnRleHQuZHluYW1pY1xuICAgIHZhciByZXN1bHQgPSB7fVxuXG4gICAgT2JqZWN0LmtleXMoc3RhdGljQ29udGV4dCkuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgdmFyIHZhbHVlID0gc3RhdGljQ29udGV4dFtuYW1lXVxuICAgICAgcmVzdWx0W25hbWVdID0gY3JlYXRlU3RhdGljRGVjbChmdW5jdGlvbiAoZW52LCBzY29wZSkge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyB8fCB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgIHJldHVybiAnJyArIHZhbHVlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGVudi5saW5rKHZhbHVlKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH0pXG5cbiAgICBPYmplY3Qua2V5cyhkeW5hbWljQ29udGV4dCkuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgdmFyIGR5biA9IGR5bmFtaWNDb250ZXh0W25hbWVdXG4gICAgICByZXN1bHRbbmFtZV0gPSBjcmVhdGVEeW5hbWljRGVjbChkeW4sIGZ1bmN0aW9uIChlbnYsIHNjb3BlKSB7XG4gICAgICAgIHJldHVybiBlbnYuaW52b2tlKHNjb3BlLCBkeW4pXG4gICAgICB9KVxuICAgIH0pXG5cbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZUFyZ3VtZW50cyAob3B0aW9ucywgYXR0cmlidXRlcywgdW5pZm9ybXMsIGNvbnRleHQsIGVudikge1xuICAgIHZhciBzdGF0aWNPcHRpb25zID0gb3B0aW9ucy5zdGF0aWNcbiAgICB2YXIgZHluYW1pY09wdGlvbnMgPSBvcHRpb25zLmR5bmFtaWNcblxuICAgIGNoZWNrJDEub3B0aW9uYWwoZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIEtFWV9OQU1FUyA9IFtcbiAgICAgICAgU19GUkFNRUJVRkZFUixcbiAgICAgICAgU19WRVJULFxuICAgICAgICBTX0ZSQUcsXG4gICAgICAgIFNfRUxFTUVOVFMsXG4gICAgICAgIFNfUFJJTUlUSVZFLFxuICAgICAgICBTX09GRlNFVCxcbiAgICAgICAgU19DT1VOVCxcbiAgICAgICAgU19JTlNUQU5DRVMsXG4gICAgICAgIFNfUFJPRklMRSxcbiAgICAgICAgU19WQU9cbiAgICAgIF0uY29uY2F0KEdMX1NUQVRFX05BTUVTKVxuXG4gICAgICBmdW5jdGlvbiBjaGVja0tleXMgKGRpY3QpIHtcbiAgICAgICAgT2JqZWN0LmtleXMoZGljdCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgY2hlY2skMS5jb21tYW5kKFxuICAgICAgICAgICAgS0VZX05BTUVTLmluZGV4T2Yoa2V5KSA+PSAwLFxuICAgICAgICAgICAgJ3Vua25vd24gcGFyYW1ldGVyIFwiJyArIGtleSArICdcIicsXG4gICAgICAgICAgICBlbnYuY29tbWFuZFN0cilcbiAgICAgICAgfSlcbiAgICAgIH1cblxuICAgICAgY2hlY2tLZXlzKHN0YXRpY09wdGlvbnMpXG4gICAgICBjaGVja0tleXMoZHluYW1pY09wdGlvbnMpXG4gICAgfSlcblxuICAgIHZhciBhdHRyaWJMb2NhdGlvbnMgPSBwYXJzZUF0dHJpYkxvY2F0aW9ucyhvcHRpb25zLCBhdHRyaWJ1dGVzKVxuXG4gICAgdmFyIGZyYW1lYnVmZmVyID0gcGFyc2VGcmFtZWJ1ZmZlcihvcHRpb25zLCBlbnYpXG4gICAgdmFyIHZpZXdwb3J0QW5kU2Npc3NvciA9IHBhcnNlVmlld3BvcnRTY2lzc29yKG9wdGlvbnMsIGZyYW1lYnVmZmVyLCBlbnYpXG4gICAgdmFyIGRyYXcgPSBwYXJzZURyYXcob3B0aW9ucywgZW52KVxuICAgIHZhciBzdGF0ZSA9IHBhcnNlR0xTdGF0ZShvcHRpb25zLCBlbnYpXG4gICAgdmFyIHNoYWRlciA9IHBhcnNlUHJvZ3JhbShvcHRpb25zLCBlbnYsIGF0dHJpYkxvY2F0aW9ucylcblxuICAgIGZ1bmN0aW9uIGNvcHlCb3ggKG5hbWUpIHtcbiAgICAgIHZhciBkZWZuID0gdmlld3BvcnRBbmRTY2lzc29yW25hbWVdXG4gICAgICBpZiAoZGVmbikge1xuICAgICAgICBzdGF0ZVtuYW1lXSA9IGRlZm5cbiAgICAgIH1cbiAgICB9XG4gICAgY29weUJveChTX1ZJRVdQT1JUKVxuICAgIGNvcHlCb3gocHJvcE5hbWUoU19TQ0lTU09SX0JPWCkpXG5cbiAgICB2YXIgZGlydHkgPSBPYmplY3Qua2V5cyhzdGF0ZSkubGVuZ3RoID4gMFxuXG4gICAgdmFyIHJlc3VsdCA9IHtcbiAgICAgIGZyYW1lYnVmZmVyOiBmcmFtZWJ1ZmZlcixcbiAgICAgIGRyYXc6IGRyYXcsXG4gICAgICBzaGFkZXI6IHNoYWRlcixcbiAgICAgIHN0YXRlOiBzdGF0ZSxcbiAgICAgIGRpcnR5OiBkaXJ0eSxcbiAgICAgIHNjb3BlVkFPOiBudWxsLFxuICAgICAgZHJhd1ZBTzogbnVsbCxcbiAgICAgIHVzZVZBTzogZmFsc2UsXG4gICAgICBhdHRyaWJ1dGVzOiB7fVxuICAgIH1cblxuICAgIHJlc3VsdC5wcm9maWxlID0gcGFyc2VQcm9maWxlKG9wdGlvbnMsIGVudilcbiAgICByZXN1bHQudW5pZm9ybXMgPSBwYXJzZVVuaWZvcm1zKHVuaWZvcm1zLCBlbnYpXG4gICAgcmVzdWx0LmRyYXdWQU8gPSByZXN1bHQuc2NvcGVWQU8gPSBwYXJzZVZBTyhvcHRpb25zLCBlbnYpXG4gICAgLy8gc3BlY2lhbCBjYXNlOiBjaGVjayBpZiB3ZSBjYW4gc3RhdGljYWxseSBhbGxvY2F0ZSBhIHZlcnRleCBhcnJheSBvYmplY3QgZm9yIHRoaXMgcHJvZ3JhbVxuICAgIGlmICghcmVzdWx0LmRyYXdWQU8gJiYgc2hhZGVyLnByb2dyYW0gJiYgIWF0dHJpYkxvY2F0aW9ucyAmJiBleHRlbnNpb25zLmFuZ2xlX2luc3RhbmNlZF9hcnJheXMpIHtcbiAgICAgIHZhciB1c2VWQU8gPSB0cnVlXG4gICAgICB2YXIgc3RhdGljQmluZGluZ3MgPSBzaGFkZXIucHJvZ3JhbS5hdHRyaWJ1dGVzLm1hcChmdW5jdGlvbiAoYXR0cikge1xuICAgICAgICB2YXIgYmluZGluZyA9IGF0dHJpYnV0ZXMuc3RhdGljW2F0dHJdXG4gICAgICAgIHVzZVZBTyA9IHVzZVZBTyAmJiAhIWJpbmRpbmdcbiAgICAgICAgcmV0dXJuIGJpbmRpbmdcbiAgICAgIH0pXG4gICAgICBpZiAodXNlVkFPICYmIHN0YXRpY0JpbmRpbmdzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdmFyIHZhbyA9IGF0dHJpYnV0ZVN0YXRlLmdldFZBTyhhdHRyaWJ1dGVTdGF0ZS5jcmVhdGVWQU8oc3RhdGljQmluZGluZ3MpKVxuICAgICAgICByZXN1bHQuZHJhd1ZBTyA9IG5ldyBEZWNsYXJhdGlvbihudWxsLCBudWxsLCBudWxsLCBmdW5jdGlvbiAoZW52LCBzY29wZSkge1xuICAgICAgICAgIHJldHVybiBlbnYubGluayh2YW8pXG4gICAgICAgIH0pXG4gICAgICAgIHJlc3VsdC51c2VWQU8gPSB0cnVlXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChhdHRyaWJMb2NhdGlvbnMpIHtcbiAgICAgIHJlc3VsdC51c2VWQU8gPSB0cnVlXG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdC5hdHRyaWJ1dGVzID0gcGFyc2VBdHRyaWJ1dGVzKGF0dHJpYnV0ZXMsIGVudilcbiAgICB9XG4gICAgcmVzdWx0LmNvbnRleHQgPSBwYXJzZUNvbnRleHQoY29udGV4dCwgZW52KVxuICAgIHJldHVybiByZXN1bHRcbiAgfVxuXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8gQ09NTU9OIFVQREFURSBGVU5DVElPTlNcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICBmdW5jdGlvbiBlbWl0Q29udGV4dCAoZW52LCBzY29wZSwgY29udGV4dCkge1xuICAgIHZhciBzaGFyZWQgPSBlbnYuc2hhcmVkXG4gICAgdmFyIENPTlRFWFQgPSBzaGFyZWQuY29udGV4dFxuXG4gICAgdmFyIGNvbnRleHRFbnRlciA9IGVudi5zY29wZSgpXG5cbiAgICBPYmplY3Qua2V5cyhjb250ZXh0KS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICBzY29wZS5zYXZlKENPTlRFWFQsICcuJyArIG5hbWUpXG4gICAgICB2YXIgZGVmbiA9IGNvbnRleHRbbmFtZV1cbiAgICAgIHZhciB2YWx1ZSA9IGRlZm4uYXBwZW5kKGVudiwgc2NvcGUpXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgY29udGV4dEVudGVyKENPTlRFWFQsICcuJywgbmFtZSwgJz1bJywgdmFsdWUuam9pbigpLCAnXTsnKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udGV4dEVudGVyKENPTlRFWFQsICcuJywgbmFtZSwgJz0nLCB2YWx1ZSwgJzsnKVxuICAgICAgfVxuICAgIH0pXG5cbiAgICBzY29wZShjb250ZXh0RW50ZXIpXG4gIH1cblxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vIENPTU1PTiBEUkFXSU5HIEZVTkNUSU9OU1xuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIGZ1bmN0aW9uIGVtaXRQb2xsRnJhbWVidWZmZXIgKGVudiwgc2NvcGUsIGZyYW1lYnVmZmVyLCBza2lwQ2hlY2spIHtcbiAgICB2YXIgc2hhcmVkID0gZW52LnNoYXJlZFxuXG4gICAgdmFyIEdMID0gc2hhcmVkLmdsXG4gICAgdmFyIEZSQU1FQlVGRkVSX1NUQVRFID0gc2hhcmVkLmZyYW1lYnVmZmVyXG4gICAgdmFyIEVYVF9EUkFXX0JVRkZFUlNcbiAgICBpZiAoZXh0RHJhd0J1ZmZlcnMpIHtcbiAgICAgIEVYVF9EUkFXX0JVRkZFUlMgPSBzY29wZS5kZWYoc2hhcmVkLmV4dGVuc2lvbnMsICcud2ViZ2xfZHJhd19idWZmZXJzJylcbiAgICB9XG5cbiAgICB2YXIgY29uc3RhbnRzID0gZW52LmNvbnN0YW50c1xuXG4gICAgdmFyIERSQVdfQlVGRkVSUyA9IGNvbnN0YW50cy5kcmF3QnVmZmVyXG4gICAgdmFyIEJBQ0tfQlVGRkVSID0gY29uc3RhbnRzLmJhY2tCdWZmZXJcblxuICAgIHZhciBORVhUXG4gICAgaWYgKGZyYW1lYnVmZmVyKSB7XG4gICAgICBORVhUID0gZnJhbWVidWZmZXIuYXBwZW5kKGVudiwgc2NvcGUpXG4gICAgfSBlbHNlIHtcbiAgICAgIE5FWFQgPSBzY29wZS5kZWYoRlJBTUVCVUZGRVJfU1RBVEUsICcubmV4dCcpXG4gICAgfVxuXG4gICAgaWYgKCFza2lwQ2hlY2spIHtcbiAgICAgIHNjb3BlKCdpZignLCBORVhULCAnIT09JywgRlJBTUVCVUZGRVJfU1RBVEUsICcuY3VyKXsnKVxuICAgIH1cbiAgICBzY29wZShcbiAgICAgICdpZignLCBORVhULCAnKXsnLFxuICAgICAgR0wsICcuYmluZEZyYW1lYnVmZmVyKCcsIEdMX0ZSQU1FQlVGRkVSJDIsICcsJywgTkVYVCwgJy5mcmFtZWJ1ZmZlcik7JylcbiAgICBpZiAoZXh0RHJhd0J1ZmZlcnMpIHtcbiAgICAgIHNjb3BlKEVYVF9EUkFXX0JVRkZFUlMsICcuZHJhd0J1ZmZlcnNXRUJHTCgnLFxuICAgICAgICBEUkFXX0JVRkZFUlMsICdbJywgTkVYVCwgJy5jb2xvckF0dGFjaG1lbnRzLmxlbmd0aF0pOycpXG4gICAgfVxuICAgIHNjb3BlKCd9ZWxzZXsnLFxuICAgICAgR0wsICcuYmluZEZyYW1lYnVmZmVyKCcsIEdMX0ZSQU1FQlVGRkVSJDIsICcsbnVsbCk7JylcbiAgICBpZiAoZXh0RHJhd0J1ZmZlcnMpIHtcbiAgICAgIHNjb3BlKEVYVF9EUkFXX0JVRkZFUlMsICcuZHJhd0J1ZmZlcnNXRUJHTCgnLCBCQUNLX0JVRkZFUiwgJyk7JylcbiAgICB9XG4gICAgc2NvcGUoXG4gICAgICAnfScsXG4gICAgICBGUkFNRUJVRkZFUl9TVEFURSwgJy5jdXI9JywgTkVYVCwgJzsnKVxuICAgIGlmICghc2tpcENoZWNrKSB7XG4gICAgICBzY29wZSgnfScpXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZW1pdFBvbGxTdGF0ZSAoZW52LCBzY29wZSwgYXJncykge1xuICAgIHZhciBzaGFyZWQgPSBlbnYuc2hhcmVkXG5cbiAgICB2YXIgR0wgPSBzaGFyZWQuZ2xcblxuICAgIHZhciBDVVJSRU5UX1ZBUlMgPSBlbnYuY3VycmVudFxuICAgIHZhciBORVhUX1ZBUlMgPSBlbnYubmV4dFxuICAgIHZhciBDVVJSRU5UX1NUQVRFID0gc2hhcmVkLmN1cnJlbnRcbiAgICB2YXIgTkVYVF9TVEFURSA9IHNoYXJlZC5uZXh0XG5cbiAgICB2YXIgYmxvY2sgPSBlbnYuY29uZChDVVJSRU5UX1NUQVRFLCAnLmRpcnR5JylcblxuICAgIEdMX1NUQVRFX05BTUVTLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgIHZhciBwYXJhbSA9IHByb3BOYW1lKHByb3ApXG4gICAgICBpZiAocGFyYW0gaW4gYXJncy5zdGF0ZSkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgdmFyIE5FWFQsIENVUlJFTlRcbiAgICAgIGlmIChwYXJhbSBpbiBORVhUX1ZBUlMpIHtcbiAgICAgICAgTkVYVCA9IE5FWFRfVkFSU1twYXJhbV1cbiAgICAgICAgQ1VSUkVOVCA9IENVUlJFTlRfVkFSU1twYXJhbV1cbiAgICAgICAgdmFyIHBhcnRzID0gbG9vcChjdXJyZW50U3RhdGVbcGFyYW1dLmxlbmd0aCwgZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICByZXR1cm4gYmxvY2suZGVmKE5FWFQsICdbJywgaSwgJ10nKVxuICAgICAgICB9KVxuICAgICAgICBibG9jayhlbnYuY29uZChwYXJ0cy5tYXAoZnVuY3Rpb24gKHAsIGkpIHtcbiAgICAgICAgICByZXR1cm4gcCArICchPT0nICsgQ1VSUkVOVCArICdbJyArIGkgKyAnXSdcbiAgICAgICAgfSkuam9pbignfHwnKSlcbiAgICAgICAgICAudGhlbihcbiAgICAgICAgICAgIEdMLCAnLicsIEdMX1ZBUklBQkxFU1twYXJhbV0sICcoJywgcGFydHMsICcpOycsXG4gICAgICAgICAgICBwYXJ0cy5tYXAoZnVuY3Rpb24gKHAsIGkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIENVUlJFTlQgKyAnWycgKyBpICsgJ109JyArIHBcbiAgICAgICAgICAgIH0pLmpvaW4oJzsnKSwgJzsnKSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIE5FWFQgPSBibG9jay5kZWYoTkVYVF9TVEFURSwgJy4nLCBwYXJhbSlcbiAgICAgICAgdmFyIGlmdGUgPSBlbnYuY29uZChORVhULCAnIT09JywgQ1VSUkVOVF9TVEFURSwgJy4nLCBwYXJhbSlcbiAgICAgICAgYmxvY2soaWZ0ZSlcbiAgICAgICAgaWYgKHBhcmFtIGluIEdMX0ZMQUdTKSB7XG4gICAgICAgICAgaWZ0ZShcbiAgICAgICAgICAgIGVudi5jb25kKE5FWFQpXG4gICAgICAgICAgICAgIC50aGVuKEdMLCAnLmVuYWJsZSgnLCBHTF9GTEFHU1twYXJhbV0sICcpOycpXG4gICAgICAgICAgICAgIC5lbHNlKEdMLCAnLmRpc2FibGUoJywgR0xfRkxBR1NbcGFyYW1dLCAnKTsnKSxcbiAgICAgICAgICAgIENVUlJFTlRfU1RBVEUsICcuJywgcGFyYW0sICc9JywgTkVYVCwgJzsnKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmdGUoXG4gICAgICAgICAgICBHTCwgJy4nLCBHTF9WQVJJQUJMRVNbcGFyYW1dLCAnKCcsIE5FWFQsICcpOycsXG4gICAgICAgICAgICBDVVJSRU5UX1NUQVRFLCAnLicsIHBhcmFtLCAnPScsIE5FWFQsICc7JylcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pXG4gICAgaWYgKE9iamVjdC5rZXlzKGFyZ3Muc3RhdGUpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgYmxvY2soQ1VSUkVOVF9TVEFURSwgJy5kaXJ0eT1mYWxzZTsnKVxuICAgIH1cbiAgICBzY29wZShibG9jaylcbiAgfVxuXG4gIGZ1bmN0aW9uIGVtaXRTZXRPcHRpb25zIChlbnYsIHNjb3BlLCBvcHRpb25zLCBmaWx0ZXIpIHtcbiAgICB2YXIgc2hhcmVkID0gZW52LnNoYXJlZFxuICAgIHZhciBDVVJSRU5UX1ZBUlMgPSBlbnYuY3VycmVudFxuICAgIHZhciBDVVJSRU5UX1NUQVRFID0gc2hhcmVkLmN1cnJlbnRcbiAgICB2YXIgR0wgPSBzaGFyZWQuZ2xcbiAgICBzb3J0U3RhdGUoT2JqZWN0LmtleXMob3B0aW9ucykpLmZvckVhY2goZnVuY3Rpb24gKHBhcmFtKSB7XG4gICAgICB2YXIgZGVmbiA9IG9wdGlvbnNbcGFyYW1dXG4gICAgICBpZiAoZmlsdGVyICYmICFmaWx0ZXIoZGVmbikpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICB2YXIgdmFyaWFibGUgPSBkZWZuLmFwcGVuZChlbnYsIHNjb3BlKVxuICAgICAgaWYgKEdMX0ZMQUdTW3BhcmFtXSkge1xuICAgICAgICB2YXIgZmxhZyA9IEdMX0ZMQUdTW3BhcmFtXVxuICAgICAgICBpZiAoaXNTdGF0aWMoZGVmbikpIHtcbiAgICAgICAgICBpZiAodmFyaWFibGUpIHtcbiAgICAgICAgICAgIHNjb3BlKEdMLCAnLmVuYWJsZSgnLCBmbGFnLCAnKTsnKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzY29wZShHTCwgJy5kaXNhYmxlKCcsIGZsYWcsICcpOycpXG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNjb3BlKGVudi5jb25kKHZhcmlhYmxlKVxuICAgICAgICAgICAgLnRoZW4oR0wsICcuZW5hYmxlKCcsIGZsYWcsICcpOycpXG4gICAgICAgICAgICAuZWxzZShHTCwgJy5kaXNhYmxlKCcsIGZsYWcsICcpOycpKVxuICAgICAgICB9XG4gICAgICAgIHNjb3BlKENVUlJFTlRfU1RBVEUsICcuJywgcGFyYW0sICc9JywgdmFyaWFibGUsICc7JylcbiAgICAgIH0gZWxzZSBpZiAoaXNBcnJheUxpa2UodmFyaWFibGUpKSB7XG4gICAgICAgIHZhciBDVVJSRU5UID0gQ1VSUkVOVF9WQVJTW3BhcmFtXVxuICAgICAgICBzY29wZShcbiAgICAgICAgICBHTCwgJy4nLCBHTF9WQVJJQUJMRVNbcGFyYW1dLCAnKCcsIHZhcmlhYmxlLCAnKTsnLFxuICAgICAgICAgIHZhcmlhYmxlLm1hcChmdW5jdGlvbiAodiwgaSkge1xuICAgICAgICAgICAgcmV0dXJuIENVUlJFTlQgKyAnWycgKyBpICsgJ109JyArIHZcbiAgICAgICAgICB9KS5qb2luKCc7JyksICc7JylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNjb3BlKFxuICAgICAgICAgIEdMLCAnLicsIEdMX1ZBUklBQkxFU1twYXJhbV0sICcoJywgdmFyaWFibGUsICcpOycsXG4gICAgICAgICAgQ1VSUkVOVF9TVEFURSwgJy4nLCBwYXJhbSwgJz0nLCB2YXJpYWJsZSwgJzsnKVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICBmdW5jdGlvbiBpbmplY3RFeHRlbnNpb25zIChlbnYsIHNjb3BlKSB7XG4gICAgaWYgKGV4dEluc3RhbmNpbmcpIHtcbiAgICAgIGVudi5pbnN0YW5jaW5nID0gc2NvcGUuZGVmKFxuICAgICAgICBlbnYuc2hhcmVkLmV4dGVuc2lvbnMsICcuYW5nbGVfaW5zdGFuY2VkX2FycmF5cycpXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZW1pdFByb2ZpbGUgKGVudiwgc2NvcGUsIGFyZ3MsIHVzZVNjb3BlLCBpbmNyZW1lbnRDb3VudGVyKSB7XG4gICAgdmFyIHNoYXJlZCA9IGVudi5zaGFyZWRcbiAgICB2YXIgU1RBVFMgPSBlbnYuc3RhdHNcbiAgICB2YXIgQ1VSUkVOVF9TVEFURSA9IHNoYXJlZC5jdXJyZW50XG4gICAgdmFyIFRJTUVSID0gc2hhcmVkLnRpbWVyXG4gICAgdmFyIHByb2ZpbGVBcmcgPSBhcmdzLnByb2ZpbGVcblxuICAgIGZ1bmN0aW9uIHBlcmZDb3VudGVyICgpIHtcbiAgICAgIGlmICh0eXBlb2YgcGVyZm9ybWFuY2UgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiAnRGF0ZS5ub3coKSdcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAncGVyZm9ybWFuY2Uubm93KCknXG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIENQVV9TVEFSVCwgUVVFUllfQ09VTlRFUlxuICAgIGZ1bmN0aW9uIGVtaXRQcm9maWxlU3RhcnQgKGJsb2NrKSB7XG4gICAgICBDUFVfU1RBUlQgPSBzY29wZS5kZWYoKVxuICAgICAgYmxvY2soQ1BVX1NUQVJULCAnPScsIHBlcmZDb3VudGVyKCksICc7JylcbiAgICAgIGlmICh0eXBlb2YgaW5jcmVtZW50Q291bnRlciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgYmxvY2soU1RBVFMsICcuY291bnQrPScsIGluY3JlbWVudENvdW50ZXIsICc7JylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJsb2NrKFNUQVRTLCAnLmNvdW50Kys7JylcbiAgICAgIH1cbiAgICAgIGlmICh0aW1lcikge1xuICAgICAgICBpZiAodXNlU2NvcGUpIHtcbiAgICAgICAgICBRVUVSWV9DT1VOVEVSID0gc2NvcGUuZGVmKClcbiAgICAgICAgICBibG9jayhRVUVSWV9DT1VOVEVSLCAnPScsIFRJTUVSLCAnLmdldE51bVBlbmRpbmdRdWVyaWVzKCk7JylcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBibG9jayhUSU1FUiwgJy5iZWdpblF1ZXJ5KCcsIFNUQVRTLCAnKTsnKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZW1pdFByb2ZpbGVFbmQgKGJsb2NrKSB7XG4gICAgICBibG9jayhTVEFUUywgJy5jcHVUaW1lKz0nLCBwZXJmQ291bnRlcigpLCAnLScsIENQVV9TVEFSVCwgJzsnKVxuICAgICAgaWYgKHRpbWVyKSB7XG4gICAgICAgIGlmICh1c2VTY29wZSkge1xuICAgICAgICAgIGJsb2NrKFRJTUVSLCAnLnB1c2hTY29wZVN0YXRzKCcsXG4gICAgICAgICAgICBRVUVSWV9DT1VOVEVSLCAnLCcsXG4gICAgICAgICAgICBUSU1FUiwgJy5nZXROdW1QZW5kaW5nUXVlcmllcygpLCcsXG4gICAgICAgICAgICBTVEFUUywgJyk7JylcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBibG9jayhUSU1FUiwgJy5lbmRRdWVyeSgpOycpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzY29wZVByb2ZpbGUgKHZhbHVlKSB7XG4gICAgICB2YXIgcHJldiA9IHNjb3BlLmRlZihDVVJSRU5UX1NUQVRFLCAnLnByb2ZpbGUnKVxuICAgICAgc2NvcGUoQ1VSUkVOVF9TVEFURSwgJy5wcm9maWxlPScsIHZhbHVlLCAnOycpXG4gICAgICBzY29wZS5leGl0KENVUlJFTlRfU1RBVEUsICcucHJvZmlsZT0nLCBwcmV2LCAnOycpXG4gICAgfVxuXG4gICAgdmFyIFVTRV9QUk9GSUxFXG4gICAgaWYgKHByb2ZpbGVBcmcpIHtcbiAgICAgIGlmIChpc1N0YXRpYyhwcm9maWxlQXJnKSkge1xuICAgICAgICBpZiAocHJvZmlsZUFyZy5lbmFibGUpIHtcbiAgICAgICAgICBlbWl0UHJvZmlsZVN0YXJ0KHNjb3BlKVxuICAgICAgICAgIGVtaXRQcm9maWxlRW5kKHNjb3BlLmV4aXQpXG4gICAgICAgICAgc2NvcGVQcm9maWxlKCd0cnVlJylcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzY29wZVByb2ZpbGUoJ2ZhbHNlJylcbiAgICAgICAgfVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIFVTRV9QUk9GSUxFID0gcHJvZmlsZUFyZy5hcHBlbmQoZW52LCBzY29wZSlcbiAgICAgIHNjb3BlUHJvZmlsZShVU0VfUFJPRklMRSlcbiAgICB9IGVsc2Uge1xuICAgICAgVVNFX1BST0ZJTEUgPSBzY29wZS5kZWYoQ1VSUkVOVF9TVEFURSwgJy5wcm9maWxlJylcbiAgICB9XG5cbiAgICB2YXIgc3RhcnQgPSBlbnYuYmxvY2soKVxuICAgIGVtaXRQcm9maWxlU3RhcnQoc3RhcnQpXG4gICAgc2NvcGUoJ2lmKCcsIFVTRV9QUk9GSUxFLCAnKXsnLCBzdGFydCwgJ30nKVxuICAgIHZhciBlbmQgPSBlbnYuYmxvY2soKVxuICAgIGVtaXRQcm9maWxlRW5kKGVuZClcbiAgICBzY29wZS5leGl0KCdpZignLCBVU0VfUFJPRklMRSwgJyl7JywgZW5kLCAnfScpXG4gIH1cblxuICBmdW5jdGlvbiBlbWl0QXR0cmlidXRlcyAoZW52LCBzY29wZSwgYXJncywgYXR0cmlidXRlcywgZmlsdGVyKSB7XG4gICAgdmFyIHNoYXJlZCA9IGVudi5zaGFyZWRcblxuICAgIGZ1bmN0aW9uIHR5cGVMZW5ndGggKHgpIHtcbiAgICAgIHN3aXRjaCAoeCkge1xuICAgICAgICBjYXNlIEdMX0ZMT0FUX1ZFQzI6XG4gICAgICAgIGNhc2UgR0xfSU5UX1ZFQzI6XG4gICAgICAgIGNhc2UgR0xfQk9PTF9WRUMyOlxuICAgICAgICAgIHJldHVybiAyXG4gICAgICAgIGNhc2UgR0xfRkxPQVRfVkVDMzpcbiAgICAgICAgY2FzZSBHTF9JTlRfVkVDMzpcbiAgICAgICAgY2FzZSBHTF9CT09MX1ZFQzM6XG4gICAgICAgICAgcmV0dXJuIDNcbiAgICAgICAgY2FzZSBHTF9GTE9BVF9WRUM0OlxuICAgICAgICBjYXNlIEdMX0lOVF9WRUM0OlxuICAgICAgICBjYXNlIEdMX0JPT0xfVkVDNDpcbiAgICAgICAgICByZXR1cm4gNFxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiAxXG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZW1pdEJpbmRBdHRyaWJ1dGUgKEFUVFJJQlVURSwgc2l6ZSwgcmVjb3JkKSB7XG4gICAgICB2YXIgR0wgPSBzaGFyZWQuZ2xcblxuICAgICAgdmFyIExPQ0FUSU9OID0gc2NvcGUuZGVmKEFUVFJJQlVURSwgJy5sb2NhdGlvbicpXG4gICAgICB2YXIgQklORElORyA9IHNjb3BlLmRlZihzaGFyZWQuYXR0cmlidXRlcywgJ1snLCBMT0NBVElPTiwgJ10nKVxuXG4gICAgICB2YXIgU1RBVEUgPSByZWNvcmQuc3RhdGVcbiAgICAgIHZhciBCVUZGRVIgPSByZWNvcmQuYnVmZmVyXG4gICAgICB2YXIgQ09OU1RfQ09NUE9ORU5UUyA9IFtcbiAgICAgICAgcmVjb3JkLngsXG4gICAgICAgIHJlY29yZC55LFxuICAgICAgICByZWNvcmQueixcbiAgICAgICAgcmVjb3JkLndcbiAgICAgIF1cblxuICAgICAgdmFyIENPTU1PTl9LRVlTID0gW1xuICAgICAgICAnYnVmZmVyJyxcbiAgICAgICAgJ25vcm1hbGl6ZWQnLFxuICAgICAgICAnb2Zmc2V0JyxcbiAgICAgICAgJ3N0cmlkZSdcbiAgICAgIF1cblxuICAgICAgZnVuY3Rpb24gZW1pdEJ1ZmZlciAoKSB7XG4gICAgICAgIHNjb3BlKFxuICAgICAgICAgICdpZighJywgQklORElORywgJy5idWZmZXIpeycsXG4gICAgICAgICAgR0wsICcuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoJywgTE9DQVRJT04sICcpO30nKVxuXG4gICAgICAgIHZhciBUWVBFID0gcmVjb3JkLnR5cGVcbiAgICAgICAgdmFyIFNJWkVcbiAgICAgICAgaWYgKCFyZWNvcmQuc2l6ZSkge1xuICAgICAgICAgIFNJWkUgPSBzaXplXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgU0laRSA9IHNjb3BlLmRlZihyZWNvcmQuc2l6ZSwgJ3x8Jywgc2l6ZSlcbiAgICAgICAgfVxuXG4gICAgICAgIHNjb3BlKCdpZignLFxuICAgICAgICAgIEJJTkRJTkcsICcudHlwZSE9PScsIFRZUEUsICd8fCcsXG4gICAgICAgICAgQklORElORywgJy5zaXplIT09JywgU0laRSwgJ3x8JyxcbiAgICAgICAgICBDT01NT05fS0VZUy5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgcmV0dXJuIEJJTkRJTkcgKyAnLicgKyBrZXkgKyAnIT09JyArIHJlY29yZFtrZXldXG4gICAgICAgICAgfSkuam9pbignfHwnKSxcbiAgICAgICAgICAnKXsnLFxuICAgICAgICAgIEdMLCAnLmJpbmRCdWZmZXIoJywgR0xfQVJSQVlfQlVGRkVSJDIsICcsJywgQlVGRkVSLCAnLmJ1ZmZlcik7JyxcbiAgICAgICAgICBHTCwgJy52ZXJ0ZXhBdHRyaWJQb2ludGVyKCcsIFtcbiAgICAgICAgICAgIExPQ0FUSU9OLFxuICAgICAgICAgICAgU0laRSxcbiAgICAgICAgICAgIFRZUEUsXG4gICAgICAgICAgICByZWNvcmQubm9ybWFsaXplZCxcbiAgICAgICAgICAgIHJlY29yZC5zdHJpZGUsXG4gICAgICAgICAgICByZWNvcmQub2Zmc2V0XG4gICAgICAgICAgXSwgJyk7JyxcbiAgICAgICAgICBCSU5ESU5HLCAnLnR5cGU9JywgVFlQRSwgJzsnLFxuICAgICAgICAgIEJJTkRJTkcsICcuc2l6ZT0nLCBTSVpFLCAnOycsXG4gICAgICAgICAgQ09NTU9OX0tFWVMubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIHJldHVybiBCSU5ESU5HICsgJy4nICsga2V5ICsgJz0nICsgcmVjb3JkW2tleV0gKyAnOydcbiAgICAgICAgICB9KS5qb2luKCcnKSxcbiAgICAgICAgICAnfScpXG5cbiAgICAgICAgaWYgKGV4dEluc3RhbmNpbmcpIHtcbiAgICAgICAgICB2YXIgRElWSVNPUiA9IHJlY29yZC5kaXZpc29yXG4gICAgICAgICAgc2NvcGUoXG4gICAgICAgICAgICAnaWYoJywgQklORElORywgJy5kaXZpc29yIT09JywgRElWSVNPUiwgJyl7JyxcbiAgICAgICAgICAgIGVudi5pbnN0YW5jaW5nLCAnLnZlcnRleEF0dHJpYkRpdmlzb3JBTkdMRSgnLCBbTE9DQVRJT04sIERJVklTT1JdLCAnKTsnLFxuICAgICAgICAgICAgQklORElORywgJy5kaXZpc29yPScsIERJVklTT1IsICc7fScpXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZW1pdENvbnN0YW50ICgpIHtcbiAgICAgICAgc2NvcGUoXG4gICAgICAgICAgJ2lmKCcsIEJJTkRJTkcsICcuYnVmZmVyKXsnLFxuICAgICAgICAgIEdMLCAnLmRpc2FibGVWZXJ0ZXhBdHRyaWJBcnJheSgnLCBMT0NBVElPTiwgJyk7JyxcbiAgICAgICAgICBCSU5ESU5HLCAnLmJ1ZmZlcj1udWxsOycsXG4gICAgICAgICAgJ31pZignLCBDVVRFX0NPTVBPTkVOVFMubWFwKGZ1bmN0aW9uIChjLCBpKSB7XG4gICAgICAgICAgICByZXR1cm4gQklORElORyArICcuJyArIGMgKyAnIT09JyArIENPTlNUX0NPTVBPTkVOVFNbaV1cbiAgICAgICAgICB9KS5qb2luKCd8fCcpLCAnKXsnLFxuICAgICAgICAgIEdMLCAnLnZlcnRleEF0dHJpYjRmKCcsIExPQ0FUSU9OLCAnLCcsIENPTlNUX0NPTVBPTkVOVFMsICcpOycsXG4gICAgICAgICAgQ1VURV9DT01QT05FTlRTLm1hcChmdW5jdGlvbiAoYywgaSkge1xuICAgICAgICAgICAgcmV0dXJuIEJJTkRJTkcgKyAnLicgKyBjICsgJz0nICsgQ09OU1RfQ09NUE9ORU5UU1tpXSArICc7J1xuICAgICAgICAgIH0pLmpvaW4oJycpLFxuICAgICAgICAgICd9JylcbiAgICAgIH1cblxuICAgICAgaWYgKFNUQVRFID09PSBBVFRSSUJfU1RBVEVfUE9JTlRFUikge1xuICAgICAgICBlbWl0QnVmZmVyKClcbiAgICAgIH0gZWxzZSBpZiAoU1RBVEUgPT09IEFUVFJJQl9TVEFURV9DT05TVEFOVCkge1xuICAgICAgICBlbWl0Q29uc3RhbnQoKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2NvcGUoJ2lmKCcsIFNUQVRFLCAnPT09JywgQVRUUklCX1NUQVRFX1BPSU5URVIsICcpeycpXG4gICAgICAgIGVtaXRCdWZmZXIoKVxuICAgICAgICBzY29wZSgnfWVsc2V7JylcbiAgICAgICAgZW1pdENvbnN0YW50KClcbiAgICAgICAgc2NvcGUoJ30nKVxuICAgICAgfVxuICAgIH1cblxuICAgIGF0dHJpYnV0ZXMuZm9yRWFjaChmdW5jdGlvbiAoYXR0cmlidXRlKSB7XG4gICAgICB2YXIgbmFtZSA9IGF0dHJpYnV0ZS5uYW1lXG4gICAgICB2YXIgYXJnID0gYXJncy5hdHRyaWJ1dGVzW25hbWVdXG4gICAgICB2YXIgcmVjb3JkXG4gICAgICBpZiAoYXJnKSB7XG4gICAgICAgIGlmICghZmlsdGVyKGFyZykpIHtcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICByZWNvcmQgPSBhcmcuYXBwZW5kKGVudiwgc2NvcGUpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIWZpbHRlcihTQ09QRV9ERUNMKSkge1xuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICAgIHZhciBzY29wZUF0dHJpYiA9IGVudi5zY29wZUF0dHJpYihuYW1lKVxuICAgICAgICBjaGVjayQxLm9wdGlvbmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBlbnYuYXNzZXJ0KHNjb3BlLFxuICAgICAgICAgICAgc2NvcGVBdHRyaWIgKyAnLnN0YXRlJyxcbiAgICAgICAgICAgICdtaXNzaW5nIGF0dHJpYnV0ZSAnICsgbmFtZSlcbiAgICAgICAgfSlcbiAgICAgICAgcmVjb3JkID0ge31cbiAgICAgICAgT2JqZWN0LmtleXMobmV3IEF0dHJpYnV0ZVJlY29yZCgpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICByZWNvcmRba2V5XSA9IHNjb3BlLmRlZihzY29wZUF0dHJpYiwgJy4nLCBrZXkpXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgICBlbWl0QmluZEF0dHJpYnV0ZShcbiAgICAgICAgZW52LmxpbmsoYXR0cmlidXRlKSwgdHlwZUxlbmd0aChhdHRyaWJ1dGUuaW5mby50eXBlKSwgcmVjb3JkKVxuICAgIH0pXG4gIH1cblxuICBmdW5jdGlvbiBlbWl0VW5pZm9ybXMgKGVudiwgc2NvcGUsIGFyZ3MsIHVuaWZvcm1zLCBmaWx0ZXIpIHtcbiAgICB2YXIgc2hhcmVkID0gZW52LnNoYXJlZFxuICAgIHZhciBHTCA9IHNoYXJlZC5nbFxuXG4gICAgdmFyIGluZml4XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB1bmlmb3Jtcy5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIHVuaWZvcm0gPSB1bmlmb3Jtc1tpXVxuICAgICAgdmFyIG5hbWUgPSB1bmlmb3JtLm5hbWVcbiAgICAgIHZhciB0eXBlID0gdW5pZm9ybS5pbmZvLnR5cGVcbiAgICAgIHZhciBhcmcgPSBhcmdzLnVuaWZvcm1zW25hbWVdXG4gICAgICB2YXIgVU5JRk9STSA9IGVudi5saW5rKHVuaWZvcm0pXG4gICAgICB2YXIgTE9DQVRJT04gPSBVTklGT1JNICsgJy5sb2NhdGlvbidcblxuICAgICAgdmFyIFZBTFVFXG4gICAgICBpZiAoYXJnKSB7XG4gICAgICAgIGlmICghZmlsdGVyKGFyZykpIHtcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG4gICAgICAgIGlmIChpc1N0YXRpYyhhcmcpKSB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gYXJnLnZhbHVlXG4gICAgICAgICAgY2hlY2skMS5jb21tYW5kKFxuICAgICAgICAgICAgdmFsdWUgIT09IG51bGwgJiYgdHlwZW9mIHZhbHVlICE9PSAndW5kZWZpbmVkJyxcbiAgICAgICAgICAgICdtaXNzaW5nIHVuaWZvcm0gXCInICsgbmFtZSArICdcIicsIGVudi5jb21tYW5kU3RyKVxuICAgICAgICAgIGlmICh0eXBlID09PSBHTF9TQU1QTEVSXzJEIHx8IHR5cGUgPT09IEdMX1NBTVBMRVJfQ1VCRSkge1xuICAgICAgICAgICAgY2hlY2skMS5jb21tYW5kKFxuICAgICAgICAgICAgICB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgICAgICAgKCh0eXBlID09PSBHTF9TQU1QTEVSXzJEICYmXG4gICAgICAgICAgICAgICAgKHZhbHVlLl9yZWdsVHlwZSA9PT0gJ3RleHR1cmUyZCcgfHxcbiAgICAgICAgICAgICAgICB2YWx1ZS5fcmVnbFR5cGUgPT09ICdmcmFtZWJ1ZmZlcicpKSB8fFxuICAgICAgICAgICAgICAodHlwZSA9PT0gR0xfU0FNUExFUl9DVUJFICYmXG4gICAgICAgICAgICAgICAgKHZhbHVlLl9yZWdsVHlwZSA9PT0gJ3RleHR1cmVDdWJlJyB8fFxuICAgICAgICAgICAgICAgIHZhbHVlLl9yZWdsVHlwZSA9PT0gJ2ZyYW1lYnVmZmVyQ3ViZScpKSksXG4gICAgICAgICAgICAgICdpbnZhbGlkIHRleHR1cmUgZm9yIHVuaWZvcm0gJyArIG5hbWUsIGVudi5jb21tYW5kU3RyKVxuICAgICAgICAgICAgdmFyIFRFWF9WQUxVRSA9IGVudi5saW5rKHZhbHVlLl90ZXh0dXJlIHx8IHZhbHVlLmNvbG9yWzBdLl90ZXh0dXJlKVxuICAgICAgICAgICAgc2NvcGUoR0wsICcudW5pZm9ybTFpKCcsIExPQ0FUSU9OLCAnLCcsIFRFWF9WQUxVRSArICcuYmluZCgpKTsnKVxuICAgICAgICAgICAgc2NvcGUuZXhpdChURVhfVkFMVUUsICcudW5iaW5kKCk7JylcbiAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgdHlwZSA9PT0gR0xfRkxPQVRfTUFUMiB8fFxuICAgICAgICAgICAgdHlwZSA9PT0gR0xfRkxPQVRfTUFUMyB8fFxuICAgICAgICAgICAgdHlwZSA9PT0gR0xfRkxPQVRfTUFUNCkge1xuICAgICAgICAgICAgY2hlY2skMS5vcHRpb25hbChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIGNoZWNrJDEuY29tbWFuZChpc0FycmF5TGlrZSh2YWx1ZSksXG4gICAgICAgICAgICAgICAgJ2ludmFsaWQgbWF0cml4IGZvciB1bmlmb3JtICcgKyBuYW1lLCBlbnYuY29tbWFuZFN0cilcbiAgICAgICAgICAgICAgY2hlY2skMS5jb21tYW5kKFxuICAgICAgICAgICAgICAgICh0eXBlID09PSBHTF9GTE9BVF9NQVQyICYmIHZhbHVlLmxlbmd0aCA9PT0gNCkgfHxcbiAgICAgICAgICAgICAgICAodHlwZSA9PT0gR0xfRkxPQVRfTUFUMyAmJiB2YWx1ZS5sZW5ndGggPT09IDkpIHx8XG4gICAgICAgICAgICAgICAgKHR5cGUgPT09IEdMX0ZMT0FUX01BVDQgJiYgdmFsdWUubGVuZ3RoID09PSAxNiksXG4gICAgICAgICAgICAgICAgJ2ludmFsaWQgbGVuZ3RoIGZvciBtYXRyaXggdW5pZm9ybSAnICsgbmFtZSwgZW52LmNvbW1hbmRTdHIpXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgdmFyIE1BVF9WQUxVRSA9IGVudi5nbG9iYWwuZGVmKCduZXcgRmxvYXQzMkFycmF5KFsnICtcbiAgICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodmFsdWUpICsgJ10pJylcbiAgICAgICAgICAgIHZhciBkaW0gPSAyXG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gR0xfRkxPQVRfTUFUMykge1xuICAgICAgICAgICAgICBkaW0gPSAzXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IEdMX0ZMT0FUX01BVDQpIHtcbiAgICAgICAgICAgICAgZGltID0gNFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2NvcGUoXG4gICAgICAgICAgICAgIEdMLCAnLnVuaWZvcm1NYXRyaXgnLCBkaW0sICdmdignLFxuICAgICAgICAgICAgICBMT0NBVElPTiwgJyxmYWxzZSwnLCBNQVRfVkFMVUUsICcpOycpXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgICBjYXNlIEdMX0ZMT0FUJDg6XG4gICAgICAgICAgICAgICAgY2hlY2skMS5jb21tYW5kVHlwZSh2YWx1ZSwgJ251bWJlcicsICd1bmlmb3JtICcgKyBuYW1lLCBlbnYuY29tbWFuZFN0cilcbiAgICAgICAgICAgICAgICBpbmZpeCA9ICcxZidcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICBjYXNlIEdMX0ZMT0FUX1ZFQzI6XG4gICAgICAgICAgICAgICAgY2hlY2skMS5jb21tYW5kKFxuICAgICAgICAgICAgICAgICAgaXNBcnJheUxpa2UodmFsdWUpICYmIHZhbHVlLmxlbmd0aCA9PT0gMixcbiAgICAgICAgICAgICAgICAgICd1bmlmb3JtICcgKyBuYW1lLCBlbnYuY29tbWFuZFN0cilcbiAgICAgICAgICAgICAgICBpbmZpeCA9ICcyZidcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICBjYXNlIEdMX0ZMT0FUX1ZFQzM6XG4gICAgICAgICAgICAgICAgY2hlY2skMS5jb21tYW5kKFxuICAgICAgICAgICAgICAgICAgaXNBcnJheUxpa2UodmFsdWUpICYmIHZhbHVlLmxlbmd0aCA9PT0gMyxcbiAgICAgICAgICAgICAgICAgICd1bmlmb3JtICcgKyBuYW1lLCBlbnYuY29tbWFuZFN0cilcbiAgICAgICAgICAgICAgICBpbmZpeCA9ICczZidcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICBjYXNlIEdMX0ZMT0FUX1ZFQzQ6XG4gICAgICAgICAgICAgICAgY2hlY2skMS5jb21tYW5kKFxuICAgICAgICAgICAgICAgICAgaXNBcnJheUxpa2UodmFsdWUpICYmIHZhbHVlLmxlbmd0aCA9PT0gNCxcbiAgICAgICAgICAgICAgICAgICd1bmlmb3JtICcgKyBuYW1lLCBlbnYuY29tbWFuZFN0cilcbiAgICAgICAgICAgICAgICBpbmZpeCA9ICc0ZidcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICBjYXNlIEdMX0JPT0w6XG4gICAgICAgICAgICAgICAgY2hlY2skMS5jb21tYW5kVHlwZSh2YWx1ZSwgJ2Jvb2xlYW4nLCAndW5pZm9ybSAnICsgbmFtZSwgZW52LmNvbW1hbmRTdHIpXG4gICAgICAgICAgICAgICAgaW5maXggPSAnMWknXG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgY2FzZSBHTF9JTlQkMzpcbiAgICAgICAgICAgICAgICBjaGVjayQxLmNvbW1hbmRUeXBlKHZhbHVlLCAnbnVtYmVyJywgJ3VuaWZvcm0gJyArIG5hbWUsIGVudi5jb21tYW5kU3RyKVxuICAgICAgICAgICAgICAgIGluZml4ID0gJzFpJ1xuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgIGNhc2UgR0xfQk9PTF9WRUMyOlxuICAgICAgICAgICAgICAgIGNoZWNrJDEuY29tbWFuZChcbiAgICAgICAgICAgICAgICAgIGlzQXJyYXlMaWtlKHZhbHVlKSAmJiB2YWx1ZS5sZW5ndGggPT09IDIsXG4gICAgICAgICAgICAgICAgICAndW5pZm9ybSAnICsgbmFtZSwgZW52LmNvbW1hbmRTdHIpXG4gICAgICAgICAgICAgICAgaW5maXggPSAnMmknXG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgY2FzZSBHTF9JTlRfVkVDMjpcbiAgICAgICAgICAgICAgICBjaGVjayQxLmNvbW1hbmQoXG4gICAgICAgICAgICAgICAgICBpc0FycmF5TGlrZSh2YWx1ZSkgJiYgdmFsdWUubGVuZ3RoID09PSAyLFxuICAgICAgICAgICAgICAgICAgJ3VuaWZvcm0gJyArIG5hbWUsIGVudi5jb21tYW5kU3RyKVxuICAgICAgICAgICAgICAgIGluZml4ID0gJzJpJ1xuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgIGNhc2UgR0xfQk9PTF9WRUMzOlxuICAgICAgICAgICAgICAgIGNoZWNrJDEuY29tbWFuZChcbiAgICAgICAgICAgICAgICAgIGlzQXJyYXlMaWtlKHZhbHVlKSAmJiB2YWx1ZS5sZW5ndGggPT09IDMsXG4gICAgICAgICAgICAgICAgICAndW5pZm9ybSAnICsgbmFtZSwgZW52LmNvbW1hbmRTdHIpXG4gICAgICAgICAgICAgICAgaW5maXggPSAnM2knXG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgY2FzZSBHTF9JTlRfVkVDMzpcbiAgICAgICAgICAgICAgICBjaGVjayQxLmNvbW1hbmQoXG4gICAgICAgICAgICAgICAgICBpc0FycmF5TGlrZSh2YWx1ZSkgJiYgdmFsdWUubGVuZ3RoID09PSAzLFxuICAgICAgICAgICAgICAgICAgJ3VuaWZvcm0gJyArIG5hbWUsIGVudi5jb21tYW5kU3RyKVxuICAgICAgICAgICAgICAgIGluZml4ID0gJzNpJ1xuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgIGNhc2UgR0xfQk9PTF9WRUM0OlxuICAgICAgICAgICAgICAgIGNoZWNrJDEuY29tbWFuZChcbiAgICAgICAgICAgICAgICAgIGlzQXJyYXlMaWtlKHZhbHVlKSAmJiB2YWx1ZS5sZW5ndGggPT09IDQsXG4gICAgICAgICAgICAgICAgICAndW5pZm9ybSAnICsgbmFtZSwgZW52LmNvbW1hbmRTdHIpXG4gICAgICAgICAgICAgICAgaW5maXggPSAnNGknXG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgY2FzZSBHTF9JTlRfVkVDNDpcbiAgICAgICAgICAgICAgICBjaGVjayQxLmNvbW1hbmQoXG4gICAgICAgICAgICAgICAgICBpc0FycmF5TGlrZSh2YWx1ZSkgJiYgdmFsdWUubGVuZ3RoID09PSA0LFxuICAgICAgICAgICAgICAgICAgJ3VuaWZvcm0gJyArIG5hbWUsIGVudi5jb21tYW5kU3RyKVxuICAgICAgICAgICAgICAgIGluZml4ID0gJzRpJ1xuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzY29wZShHTCwgJy51bmlmb3JtJywgaW5maXgsICcoJywgTE9DQVRJT04sICcsJyxcbiAgICAgICAgICAgICAgaXNBcnJheUxpa2UodmFsdWUpID8gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodmFsdWUpIDogdmFsdWUsXG4gICAgICAgICAgICAgICcpOycpXG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgVkFMVUUgPSBhcmcuYXBwZW5kKGVudiwgc2NvcGUpXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghZmlsdGVyKFNDT1BFX0RFQ0wpKSB7XG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuICAgICAgICBWQUxVRSA9IHNjb3BlLmRlZihzaGFyZWQudW5pZm9ybXMsICdbJywgc3RyaW5nU3RvcmUuaWQobmFtZSksICddJylcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGUgPT09IEdMX1NBTVBMRVJfMkQpIHtcbiAgICAgICAgY2hlY2skMSghQXJyYXkuaXNBcnJheShWQUxVRSksICdtdXN0IHNwZWNpZnkgYSBzY2FsYXIgcHJvcCBmb3IgdGV4dHVyZXMnKVxuICAgICAgICBzY29wZShcbiAgICAgICAgICAnaWYoJywgVkFMVUUsICcmJicsIFZBTFVFLCAnLl9yZWdsVHlwZT09PVwiZnJhbWVidWZmZXJcIil7JyxcbiAgICAgICAgICBWQUxVRSwgJz0nLCBWQUxVRSwgJy5jb2xvclswXTsnLFxuICAgICAgICAgICd9JylcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gR0xfU0FNUExFUl9DVUJFKSB7XG4gICAgICAgIGNoZWNrJDEoIUFycmF5LmlzQXJyYXkoVkFMVUUpLCAnbXVzdCBzcGVjaWZ5IGEgc2NhbGFyIHByb3AgZm9yIGN1YmUgbWFwcycpXG4gICAgICAgIHNjb3BlKFxuICAgICAgICAgICdpZignLCBWQUxVRSwgJyYmJywgVkFMVUUsICcuX3JlZ2xUeXBlPT09XCJmcmFtZWJ1ZmZlckN1YmVcIil7JyxcbiAgICAgICAgICBWQUxVRSwgJz0nLCBWQUxVRSwgJy5jb2xvclswXTsnLFxuICAgICAgICAgICd9JylcbiAgICAgIH1cblxuICAgICAgLy8gcGVyZm9ybSB0eXBlIHZhbGlkYXRpb25cbiAgICAgIGNoZWNrJDEub3B0aW9uYWwoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBlbWl0Q2hlY2sgKHByZWQsIG1lc3NhZ2UpIHtcbiAgICAgICAgICBlbnYuYXNzZXJ0KHNjb3BlLCBwcmVkLFxuICAgICAgICAgICAgJ2JhZCBkYXRhIG9yIG1pc3NpbmcgZm9yIHVuaWZvcm0gXCInICsgbmFtZSArICdcIi4gICcgKyBtZXNzYWdlKVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gY2hlY2tUeXBlICh0eXBlKSB7XG4gICAgICAgICAgY2hlY2skMSghQXJyYXkuaXNBcnJheShWQUxVRSksICdtdXN0IG5vdCBzcGVjaWZ5IGFuIGFycmF5IHR5cGUgZm9yIHVuaWZvcm0nKVxuICAgICAgICAgIGVtaXRDaGVjayhcbiAgICAgICAgICAgICd0eXBlb2YgJyArIFZBTFVFICsgJz09PVwiJyArIHR5cGUgKyAnXCInLFxuICAgICAgICAgICAgJ2ludmFsaWQgdHlwZSwgZXhwZWN0ZWQgJyArIHR5cGUpXG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBjaGVja1ZlY3RvciAobiwgdHlwZSkge1xuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KFZBTFVFKSkge1xuICAgICAgICAgICAgY2hlY2skMShWQUxVRS5sZW5ndGggPT09IG4sICdtdXN0IGhhdmUgbGVuZ3RoICcgKyBuKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlbWl0Q2hlY2soXG4gICAgICAgICAgICAgIHNoYXJlZC5pc0FycmF5TGlrZSArICcoJyArIFZBTFVFICsgJykmJicgKyBWQUxVRSArICcubGVuZ3RoPT09JyArIG4sXG4gICAgICAgICAgICAgICdpbnZhbGlkIHZlY3Rvciwgc2hvdWxkIGhhdmUgbGVuZ3RoICcgKyBuLCBlbnYuY29tbWFuZFN0cilcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBjaGVja1RleHR1cmUgKHRhcmdldCkge1xuICAgICAgICAgIGNoZWNrJDEoIUFycmF5LmlzQXJyYXkoVkFMVUUpLCAnbXVzdCBub3Qgc3BlY2lmeSBhIHZhbHVlIHR5cGUnKVxuICAgICAgICAgIGVtaXRDaGVjayhcbiAgICAgICAgICAgICd0eXBlb2YgJyArIFZBTFVFICsgJz09PVwiZnVuY3Rpb25cIiYmJyArXG4gICAgICAgICAgICBWQUxVRSArICcuX3JlZ2xUeXBlPT09XCJ0ZXh0dXJlJyArXG4gICAgICAgICAgICAodGFyZ2V0ID09PSBHTF9URVhUVVJFXzJEJDMgPyAnMmQnIDogJ0N1YmUnKSArICdcIicsXG4gICAgICAgICAgICAnaW52YWxpZCB0ZXh0dXJlIHR5cGUnLCBlbnYuY29tbWFuZFN0cilcbiAgICAgICAgfVxuXG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgIGNhc2UgR0xfSU5UJDM6XG4gICAgICAgICAgICBjaGVja1R5cGUoJ251bWJlcicpXG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIGNhc2UgR0xfSU5UX1ZFQzI6XG4gICAgICAgICAgICBjaGVja1ZlY3RvcigyLCAnbnVtYmVyJylcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgY2FzZSBHTF9JTlRfVkVDMzpcbiAgICAgICAgICAgIGNoZWNrVmVjdG9yKDMsICdudW1iZXInKVxuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICBjYXNlIEdMX0lOVF9WRUM0OlxuICAgICAgICAgICAgY2hlY2tWZWN0b3IoNCwgJ251bWJlcicpXG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIGNhc2UgR0xfRkxPQVQkODpcbiAgICAgICAgICAgIGNoZWNrVHlwZSgnbnVtYmVyJylcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgY2FzZSBHTF9GTE9BVF9WRUMyOlxuICAgICAgICAgICAgY2hlY2tWZWN0b3IoMiwgJ251bWJlcicpXG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIGNhc2UgR0xfRkxPQVRfVkVDMzpcbiAgICAgICAgICAgIGNoZWNrVmVjdG9yKDMsICdudW1iZXInKVxuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICBjYXNlIEdMX0ZMT0FUX1ZFQzQ6XG4gICAgICAgICAgICBjaGVja1ZlY3Rvcig0LCAnbnVtYmVyJylcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgY2FzZSBHTF9CT09MOlxuICAgICAgICAgICAgY2hlY2tUeXBlKCdib29sZWFuJylcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgY2FzZSBHTF9CT09MX1ZFQzI6XG4gICAgICAgICAgICBjaGVja1ZlY3RvcigyLCAnYm9vbGVhbicpXG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIGNhc2UgR0xfQk9PTF9WRUMzOlxuICAgICAgICAgICAgY2hlY2tWZWN0b3IoMywgJ2Jvb2xlYW4nKVxuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICBjYXNlIEdMX0JPT0xfVkVDNDpcbiAgICAgICAgICAgIGNoZWNrVmVjdG9yKDQsICdib29sZWFuJylcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgY2FzZSBHTF9GTE9BVF9NQVQyOlxuICAgICAgICAgICAgY2hlY2tWZWN0b3IoNCwgJ251bWJlcicpXG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIGNhc2UgR0xfRkxPQVRfTUFUMzpcbiAgICAgICAgICAgIGNoZWNrVmVjdG9yKDksICdudW1iZXInKVxuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICBjYXNlIEdMX0ZMT0FUX01BVDQ6XG4gICAgICAgICAgICBjaGVja1ZlY3RvcigxNiwgJ251bWJlcicpXG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIGNhc2UgR0xfU0FNUExFUl8yRDpcbiAgICAgICAgICAgIGNoZWNrVGV4dHVyZShHTF9URVhUVVJFXzJEJDMpXG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIGNhc2UgR0xfU0FNUExFUl9DVUJFOlxuICAgICAgICAgICAgY2hlY2tUZXh0dXJlKEdMX1RFWFRVUkVfQ1VCRV9NQVAkMilcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH0pXG5cbiAgICAgIHZhciB1bnJvbGwgPSAxXG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBHTF9TQU1QTEVSXzJEOlxuICAgICAgICBjYXNlIEdMX1NBTVBMRVJfQ1VCRTpcbiAgICAgICAgICB2YXIgVEVYID0gc2NvcGUuZGVmKFZBTFVFLCAnLl90ZXh0dXJlJylcbiAgICAgICAgICBzY29wZShHTCwgJy51bmlmb3JtMWkoJywgTE9DQVRJT04sICcsJywgVEVYLCAnLmJpbmQoKSk7JylcbiAgICAgICAgICBzY29wZS5leGl0KFRFWCwgJy51bmJpbmQoKTsnKVxuICAgICAgICAgIGNvbnRpbnVlXG5cbiAgICAgICAgY2FzZSBHTF9JTlQkMzpcbiAgICAgICAgY2FzZSBHTF9CT09MOlxuICAgICAgICAgIGluZml4ID0gJzFpJ1xuICAgICAgICAgIGJyZWFrXG5cbiAgICAgICAgY2FzZSBHTF9JTlRfVkVDMjpcbiAgICAgICAgY2FzZSBHTF9CT09MX1ZFQzI6XG4gICAgICAgICAgaW5maXggPSAnMmknXG4gICAgICAgICAgdW5yb2xsID0gMlxuICAgICAgICAgIGJyZWFrXG5cbiAgICAgICAgY2FzZSBHTF9JTlRfVkVDMzpcbiAgICAgICAgY2FzZSBHTF9CT09MX1ZFQzM6XG4gICAgICAgICAgaW5maXggPSAnM2knXG4gICAgICAgICAgdW5yb2xsID0gM1xuICAgICAgICAgIGJyZWFrXG5cbiAgICAgICAgY2FzZSBHTF9JTlRfVkVDNDpcbiAgICAgICAgY2FzZSBHTF9CT09MX1ZFQzQ6XG4gICAgICAgICAgaW5maXggPSAnNGknXG4gICAgICAgICAgdW5yb2xsID0gNFxuICAgICAgICAgIGJyZWFrXG5cbiAgICAgICAgY2FzZSBHTF9GTE9BVCQ4OlxuICAgICAgICAgIGluZml4ID0gJzFmJ1xuICAgICAgICAgIGJyZWFrXG5cbiAgICAgICAgY2FzZSBHTF9GTE9BVF9WRUMyOlxuICAgICAgICAgIGluZml4ID0gJzJmJ1xuICAgICAgICAgIHVucm9sbCA9IDJcbiAgICAgICAgICBicmVha1xuXG4gICAgICAgIGNhc2UgR0xfRkxPQVRfVkVDMzpcbiAgICAgICAgICBpbmZpeCA9ICczZidcbiAgICAgICAgICB1bnJvbGwgPSAzXG4gICAgICAgICAgYnJlYWtcblxuICAgICAgICBjYXNlIEdMX0ZMT0FUX1ZFQzQ6XG4gICAgICAgICAgaW5maXggPSAnNGYnXG4gICAgICAgICAgdW5yb2xsID0gNFxuICAgICAgICAgIGJyZWFrXG5cbiAgICAgICAgY2FzZSBHTF9GTE9BVF9NQVQyOlxuICAgICAgICAgIGluZml4ID0gJ01hdHJpeDJmdidcbiAgICAgICAgICBicmVha1xuXG4gICAgICAgIGNhc2UgR0xfRkxPQVRfTUFUMzpcbiAgICAgICAgICBpbmZpeCA9ICdNYXRyaXgzZnYnXG4gICAgICAgICAgYnJlYWtcblxuICAgICAgICBjYXNlIEdMX0ZMT0FUX01BVDQ6XG4gICAgICAgICAgaW5maXggPSAnTWF0cml4NGZ2J1xuICAgICAgICAgIGJyZWFrXG4gICAgICB9XG5cbiAgICAgIHNjb3BlKEdMLCAnLnVuaWZvcm0nLCBpbmZpeCwgJygnLCBMT0NBVElPTiwgJywnKVxuICAgICAgaWYgKGluZml4LmNoYXJBdCgwKSA9PT0gJ00nKSB7XG4gICAgICAgIHZhciBtYXRTaXplID0gTWF0aC5wb3codHlwZSAtIEdMX0ZMT0FUX01BVDIgKyAyLCAyKVxuICAgICAgICB2YXIgU1RPUkFHRSA9IGVudi5nbG9iYWwuZGVmKCduZXcgRmxvYXQzMkFycmF5KCcsIG1hdFNpemUsICcpJylcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoVkFMVUUpKSB7XG4gICAgICAgICAgc2NvcGUoXG4gICAgICAgICAgICAnZmFsc2UsKCcsXG4gICAgICAgICAgICBsb29wKG1hdFNpemUsIGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBTVE9SQUdFICsgJ1snICsgaSArICddPScgKyBWQUxVRVtpXVxuICAgICAgICAgICAgfSksICcsJywgU1RPUkFHRSwgJyknKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNjb3BlKFxuICAgICAgICAgICAgJ2ZhbHNlLChBcnJheS5pc0FycmF5KCcsIFZBTFVFLCAnKXx8JywgVkFMVUUsICcgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkpPycsIFZBTFVFLCAnOignLFxuICAgICAgICAgICAgbG9vcChtYXRTaXplLCBmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgICByZXR1cm4gU1RPUkFHRSArICdbJyArIGkgKyAnXT0nICsgVkFMVUUgKyAnWycgKyBpICsgJ10nXG4gICAgICAgICAgICB9KSwgJywnLCBTVE9SQUdFLCAnKScpXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodW5yb2xsID4gMSkge1xuICAgICAgICBzY29wZShsb29wKHVucm9sbCwgZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheShWQUxVRSkgPyBWQUxVRVtpXSA6IFZBTFVFICsgJ1snICsgaSArICddJ1xuICAgICAgICB9KSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNoZWNrJDEoIUFycmF5LmlzQXJyYXkoVkFMVUUpLCAndW5pZm9ybSB2YWx1ZSBtdXN0IG5vdCBiZSBhbiBhcnJheScpXG4gICAgICAgIHNjb3BlKFZBTFVFKVxuICAgICAgfVxuICAgICAgc2NvcGUoJyk7JylcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBlbWl0RHJhdyAoZW52LCBvdXRlciwgaW5uZXIsIGFyZ3MpIHtcbiAgICB2YXIgc2hhcmVkID0gZW52LnNoYXJlZFxuICAgIHZhciBHTCA9IHNoYXJlZC5nbFxuICAgIHZhciBEUkFXX1NUQVRFID0gc2hhcmVkLmRyYXdcblxuICAgIHZhciBkcmF3T3B0aW9ucyA9IGFyZ3MuZHJhd1xuXG4gICAgZnVuY3Rpb24gZW1pdEVsZW1lbnRzICgpIHtcbiAgICAgIHZhciBkZWZuID0gZHJhd09wdGlvbnMuZWxlbWVudHNcbiAgICAgIHZhciBFTEVNRU5UU1xuICAgICAgdmFyIHNjb3BlID0gb3V0ZXJcbiAgICAgIGlmIChkZWZuKSB7XG4gICAgICAgIGlmICgoZGVmbi5jb250ZXh0RGVwICYmIGFyZ3MuY29udGV4dER5bmFtaWMpIHx8IGRlZm4ucHJvcERlcCkge1xuICAgICAgICAgIHNjb3BlID0gaW5uZXJcbiAgICAgICAgfVxuICAgICAgICBFTEVNRU5UUyA9IGRlZm4uYXBwZW5kKGVudiwgc2NvcGUpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBFTEVNRU5UUyA9IHNjb3BlLmRlZihEUkFXX1NUQVRFLCAnLicsIFNfRUxFTUVOVFMpXG4gICAgICB9XG4gICAgICBpZiAoRUxFTUVOVFMpIHtcbiAgICAgICAgc2NvcGUoXG4gICAgICAgICAgJ2lmKCcgKyBFTEVNRU5UUyArICcpJyArXG4gICAgICAgICAgR0wgKyAnLmJpbmRCdWZmZXIoJyArIEdMX0VMRU1FTlRfQVJSQVlfQlVGRkVSJDEgKyAnLCcgKyBFTEVNRU5UUyArICcuYnVmZmVyLmJ1ZmZlcik7JylcbiAgICAgIH1cbiAgICAgIHJldHVybiBFTEVNRU5UU1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVtaXRDb3VudCAoKSB7XG4gICAgICB2YXIgZGVmbiA9IGRyYXdPcHRpb25zLmNvdW50XG4gICAgICB2YXIgQ09VTlRcbiAgICAgIHZhciBzY29wZSA9IG91dGVyXG4gICAgICBpZiAoZGVmbikge1xuICAgICAgICBpZiAoKGRlZm4uY29udGV4dERlcCAmJiBhcmdzLmNvbnRleHREeW5hbWljKSB8fCBkZWZuLnByb3BEZXApIHtcbiAgICAgICAgICBzY29wZSA9IGlubmVyXG4gICAgICAgIH1cbiAgICAgICAgQ09VTlQgPSBkZWZuLmFwcGVuZChlbnYsIHNjb3BlKVxuICAgICAgICBjaGVjayQxLm9wdGlvbmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoZGVmbi5NSVNTSU5HKSB7XG4gICAgICAgICAgICBlbnYuYXNzZXJ0KG91dGVyLCAnZmFsc2UnLCAnbWlzc2luZyB2ZXJ0ZXggY291bnQnKVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZGVmbi5EWU5BTUlDKSB7XG4gICAgICAgICAgICBlbnYuYXNzZXJ0KHNjb3BlLCBDT1VOVCArICc+PTAnLCAnbWlzc2luZyB2ZXJ0ZXggY291bnQnKVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIENPVU5UID0gc2NvcGUuZGVmKERSQVdfU1RBVEUsICcuJywgU19DT1VOVClcbiAgICAgICAgY2hlY2skMS5vcHRpb25hbChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZW52LmFzc2VydChzY29wZSwgQ09VTlQgKyAnPj0wJywgJ21pc3NpbmcgdmVydGV4IGNvdW50JylcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICAgIHJldHVybiBDT1VOVFxuICAgIH1cblxuICAgIHZhciBFTEVNRU5UUyA9IGVtaXRFbGVtZW50cygpXG4gICAgZnVuY3Rpb24gZW1pdFZhbHVlIChuYW1lKSB7XG4gICAgICB2YXIgZGVmbiA9IGRyYXdPcHRpb25zW25hbWVdXG4gICAgICBpZiAoZGVmbikge1xuICAgICAgICBpZiAoKGRlZm4uY29udGV4dERlcCAmJiBhcmdzLmNvbnRleHREeW5hbWljKSB8fCBkZWZuLnByb3BEZXApIHtcbiAgICAgICAgICByZXR1cm4gZGVmbi5hcHBlbmQoZW52LCBpbm5lcilcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gZGVmbi5hcHBlbmQoZW52LCBvdXRlcilcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG91dGVyLmRlZihEUkFXX1NUQVRFLCAnLicsIG5hbWUpXG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIFBSSU1JVElWRSA9IGVtaXRWYWx1ZShTX1BSSU1JVElWRSlcbiAgICB2YXIgT0ZGU0VUID0gZW1pdFZhbHVlKFNfT0ZGU0VUKVxuXG4gICAgdmFyIENPVU5UID0gZW1pdENvdW50KClcbiAgICBpZiAodHlwZW9mIENPVU5UID09PSAnbnVtYmVyJykge1xuICAgICAgaWYgKENPVU5UID09PSAwKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpbm5lcignaWYoJywgQ09VTlQsICcpeycpXG4gICAgICBpbm5lci5leGl0KCd9JylcbiAgICB9XG5cbiAgICB2YXIgSU5TVEFOQ0VTLCBFWFRfSU5TVEFOQ0lOR1xuICAgIGlmIChleHRJbnN0YW5jaW5nKSB7XG4gICAgICBJTlNUQU5DRVMgPSBlbWl0VmFsdWUoU19JTlNUQU5DRVMpXG4gICAgICBFWFRfSU5TVEFOQ0lORyA9IGVudi5pbnN0YW5jaW5nXG4gICAgfVxuXG4gICAgdmFyIEVMRU1FTlRfVFlQRSA9IEVMRU1FTlRTICsgJy50eXBlJ1xuXG4gICAgdmFyIGVsZW1lbnRzU3RhdGljID0gZHJhd09wdGlvbnMuZWxlbWVudHMgJiYgaXNTdGF0aWMoZHJhd09wdGlvbnMuZWxlbWVudHMpXG5cbiAgICBmdW5jdGlvbiBlbWl0SW5zdGFuY2luZyAoKSB7XG4gICAgICBmdW5jdGlvbiBkcmF3RWxlbWVudHMgKCkge1xuICAgICAgICBpbm5lcihFWFRfSU5TVEFOQ0lORywgJy5kcmF3RWxlbWVudHNJbnN0YW5jZWRBTkdMRSgnLCBbXG4gICAgICAgICAgUFJJTUlUSVZFLFxuICAgICAgICAgIENPVU5ULFxuICAgICAgICAgIEVMRU1FTlRfVFlQRSxcbiAgICAgICAgICBPRkZTRVQgKyAnPDwoKCcgKyBFTEVNRU5UX1RZUEUgKyAnLScgKyBHTF9VTlNJR05FRF9CWVRFJDggKyAnKT4+MSknLFxuICAgICAgICAgIElOU1RBTkNFU1xuICAgICAgICBdLCAnKTsnKVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBkcmF3QXJyYXlzICgpIHtcbiAgICAgICAgaW5uZXIoRVhUX0lOU1RBTkNJTkcsICcuZHJhd0FycmF5c0luc3RhbmNlZEFOR0xFKCcsXG4gICAgICAgICAgW1BSSU1JVElWRSwgT0ZGU0VULCBDT1VOVCwgSU5TVEFOQ0VTXSwgJyk7JylcbiAgICAgIH1cblxuICAgICAgaWYgKEVMRU1FTlRTKSB7XG4gICAgICAgIGlmICghZWxlbWVudHNTdGF0aWMpIHtcbiAgICAgICAgICBpbm5lcignaWYoJywgRUxFTUVOVFMsICcpeycpXG4gICAgICAgICAgZHJhd0VsZW1lbnRzKClcbiAgICAgICAgICBpbm5lcignfWVsc2V7JylcbiAgICAgICAgICBkcmF3QXJyYXlzKClcbiAgICAgICAgICBpbm5lcignfScpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZHJhd0VsZW1lbnRzKClcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZHJhd0FycmF5cygpXG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZW1pdFJlZ3VsYXIgKCkge1xuICAgICAgZnVuY3Rpb24gZHJhd0VsZW1lbnRzICgpIHtcbiAgICAgICAgaW5uZXIoR0wgKyAnLmRyYXdFbGVtZW50cygnICsgW1xuICAgICAgICAgIFBSSU1JVElWRSxcbiAgICAgICAgICBDT1VOVCxcbiAgICAgICAgICBFTEVNRU5UX1RZUEUsXG4gICAgICAgICAgT0ZGU0VUICsgJzw8KCgnICsgRUxFTUVOVF9UWVBFICsgJy0nICsgR0xfVU5TSUdORURfQllURSQ4ICsgJyk+PjEpJ1xuICAgICAgICBdICsgJyk7JylcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZHJhd0FycmF5cyAoKSB7XG4gICAgICAgIGlubmVyKEdMICsgJy5kcmF3QXJyYXlzKCcgKyBbUFJJTUlUSVZFLCBPRkZTRVQsIENPVU5UXSArICcpOycpXG4gICAgICB9XG5cbiAgICAgIGlmIChFTEVNRU5UUykge1xuICAgICAgICBpZiAoIWVsZW1lbnRzU3RhdGljKSB7XG4gICAgICAgICAgaW5uZXIoJ2lmKCcsIEVMRU1FTlRTLCAnKXsnKVxuICAgICAgICAgIGRyYXdFbGVtZW50cygpXG4gICAgICAgICAgaW5uZXIoJ31lbHNleycpXG4gICAgICAgICAgZHJhd0FycmF5cygpXG4gICAgICAgICAgaW5uZXIoJ30nKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRyYXdFbGVtZW50cygpXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRyYXdBcnJheXMoKVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChleHRJbnN0YW5jaW5nICYmICh0eXBlb2YgSU5TVEFOQ0VTICE9PSAnbnVtYmVyJyB8fCBJTlNUQU5DRVMgPj0gMCkpIHtcbiAgICAgIGlmICh0eXBlb2YgSU5TVEFOQ0VTID09PSAnc3RyaW5nJykge1xuICAgICAgICBpbm5lcignaWYoJywgSU5TVEFOQ0VTLCAnPjApeycpXG4gICAgICAgIGVtaXRJbnN0YW5jaW5nKClcbiAgICAgICAgaW5uZXIoJ31lbHNlIGlmKCcsIElOU1RBTkNFUywgJzwwKXsnKVxuICAgICAgICBlbWl0UmVndWxhcigpXG4gICAgICAgIGlubmVyKCd9JylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVtaXRJbnN0YW5jaW5nKClcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZW1pdFJlZ3VsYXIoKVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUJvZHkgKGVtaXRCb2R5LCBwYXJlbnRFbnYsIGFyZ3MsIHByb2dyYW0sIGNvdW50KSB7XG4gICAgdmFyIGVudiA9IGNyZWF0ZVJFR0xFbnZpcm9ubWVudCgpXG4gICAgdmFyIHNjb3BlID0gZW52LnByb2MoJ2JvZHknLCBjb3VudClcbiAgICBjaGVjayQxLm9wdGlvbmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgIGVudi5jb21tYW5kU3RyID0gcGFyZW50RW52LmNvbW1hbmRTdHJcbiAgICAgIGVudi5jb21tYW5kID0gZW52LmxpbmsocGFyZW50RW52LmNvbW1hbmRTdHIpXG4gICAgfSlcbiAgICBpZiAoZXh0SW5zdGFuY2luZykge1xuICAgICAgZW52Lmluc3RhbmNpbmcgPSBzY29wZS5kZWYoXG4gICAgICAgIGVudi5zaGFyZWQuZXh0ZW5zaW9ucywgJy5hbmdsZV9pbnN0YW5jZWRfYXJyYXlzJylcbiAgICB9XG4gICAgZW1pdEJvZHkoZW52LCBzY29wZSwgYXJncywgcHJvZ3JhbSlcbiAgICByZXR1cm4gZW52LmNvbXBpbGUoKS5ib2R5XG4gIH1cblxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vIERSQVcgUFJPQ1xuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIGZ1bmN0aW9uIGVtaXREcmF3Qm9keSAoZW52LCBkcmF3LCBhcmdzLCBwcm9ncmFtKSB7XG4gICAgaW5qZWN0RXh0ZW5zaW9ucyhlbnYsIGRyYXcpXG4gICAgaWYgKGFyZ3MudXNlVkFPKSB7XG4gICAgICBpZiAoYXJncy5kcmF3VkFPKSB7XG4gICAgICAgIGRyYXcoZW52LnNoYXJlZC52YW8sICcuc2V0VkFPKCcsIGFyZ3MuZHJhd1ZBTy5hcHBlbmQoZW52LCBkcmF3KSwgJyk7JylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRyYXcoZW52LnNoYXJlZC52YW8sICcuc2V0VkFPKCcsIGVudi5zaGFyZWQudmFvLCAnLnRhcmdldFZBTyk7JylcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZHJhdyhlbnYuc2hhcmVkLnZhbywgJy5zZXRWQU8obnVsbCk7JylcbiAgICAgIGVtaXRBdHRyaWJ1dGVzKGVudiwgZHJhdywgYXJncywgcHJvZ3JhbS5hdHRyaWJ1dGVzLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9KVxuICAgIH1cbiAgICBlbWl0VW5pZm9ybXMoZW52LCBkcmF3LCBhcmdzLCBwcm9ncmFtLnVuaWZvcm1zLCBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH0pXG4gICAgZW1pdERyYXcoZW52LCBkcmF3LCBkcmF3LCBhcmdzKVxuICB9XG5cbiAgZnVuY3Rpb24gZW1pdERyYXdQcm9jIChlbnYsIGFyZ3MpIHtcbiAgICB2YXIgZHJhdyA9IGVudi5wcm9jKCdkcmF3JywgMSlcblxuICAgIGluamVjdEV4dGVuc2lvbnMoZW52LCBkcmF3KVxuXG4gICAgZW1pdENvbnRleHQoZW52LCBkcmF3LCBhcmdzLmNvbnRleHQpXG4gICAgZW1pdFBvbGxGcmFtZWJ1ZmZlcihlbnYsIGRyYXcsIGFyZ3MuZnJhbWVidWZmZXIpXG5cbiAgICBlbWl0UG9sbFN0YXRlKGVudiwgZHJhdywgYXJncylcbiAgICBlbWl0U2V0T3B0aW9ucyhlbnYsIGRyYXcsIGFyZ3Muc3RhdGUpXG5cbiAgICBlbWl0UHJvZmlsZShlbnYsIGRyYXcsIGFyZ3MsIGZhbHNlLCB0cnVlKVxuXG4gICAgdmFyIHByb2dyYW0gPSBhcmdzLnNoYWRlci5wcm9nVmFyLmFwcGVuZChlbnYsIGRyYXcpXG4gICAgZHJhdyhlbnYuc2hhcmVkLmdsLCAnLnVzZVByb2dyYW0oJywgcHJvZ3JhbSwgJy5wcm9ncmFtKTsnKVxuXG4gICAgaWYgKGFyZ3Muc2hhZGVyLnByb2dyYW0pIHtcbiAgICAgIGVtaXREcmF3Qm9keShlbnYsIGRyYXcsIGFyZ3MsIGFyZ3Muc2hhZGVyLnByb2dyYW0pXG4gICAgfSBlbHNlIHtcbiAgICAgIGRyYXcoZW52LnNoYXJlZC52YW8sICcuc2V0VkFPKG51bGwpOycpXG4gICAgICB2YXIgZHJhd0NhY2hlID0gZW52Lmdsb2JhbC5kZWYoJ3t9JylcbiAgICAgIHZhciBQUk9HX0lEID0gZHJhdy5kZWYocHJvZ3JhbSwgJy5pZCcpXG4gICAgICB2YXIgQ0FDSEVEX1BST0MgPSBkcmF3LmRlZihkcmF3Q2FjaGUsICdbJywgUFJPR19JRCwgJ10nKVxuICAgICAgZHJhdyhcbiAgICAgICAgZW52LmNvbmQoQ0FDSEVEX1BST0MpXG4gICAgICAgICAgLnRoZW4oQ0FDSEVEX1BST0MsICcuY2FsbCh0aGlzLGEwKTsnKVxuICAgICAgICAgIC5lbHNlKFxuICAgICAgICAgICAgQ0FDSEVEX1BST0MsICc9JywgZHJhd0NhY2hlLCAnWycsIFBST0dfSUQsICddPScsXG4gICAgICAgICAgICBlbnYubGluayhmdW5jdGlvbiAocHJvZ3JhbSkge1xuICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlQm9keShlbWl0RHJhd0JvZHksIGVudiwgYXJncywgcHJvZ3JhbSwgMSlcbiAgICAgICAgICAgIH0pLCAnKCcsIHByb2dyYW0sICcpOycsXG4gICAgICAgICAgICBDQUNIRURfUFJPQywgJy5jYWxsKHRoaXMsYTApOycpKVxuICAgIH1cblxuICAgIGlmIChPYmplY3Qua2V5cyhhcmdzLnN0YXRlKS5sZW5ndGggPiAwKSB7XG4gICAgICBkcmF3KGVudi5zaGFyZWQuY3VycmVudCwgJy5kaXJ0eT10cnVlOycpXG4gICAgfVxuICB9XG5cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyBCQVRDSCBQUk9DXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICBmdW5jdGlvbiBlbWl0QmF0Y2hEeW5hbWljU2hhZGVyQm9keSAoZW52LCBzY29wZSwgYXJncywgcHJvZ3JhbSkge1xuICAgIGVudi5iYXRjaElkID0gJ2ExJ1xuXG4gICAgaW5qZWN0RXh0ZW5zaW9ucyhlbnYsIHNjb3BlKVxuXG4gICAgZnVuY3Rpb24gYWxsICgpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgZW1pdEF0dHJpYnV0ZXMoZW52LCBzY29wZSwgYXJncywgcHJvZ3JhbS5hdHRyaWJ1dGVzLCBhbGwpXG4gICAgZW1pdFVuaWZvcm1zKGVudiwgc2NvcGUsIGFyZ3MsIHByb2dyYW0udW5pZm9ybXMsIGFsbClcbiAgICBlbWl0RHJhdyhlbnYsIHNjb3BlLCBzY29wZSwgYXJncylcbiAgfVxuXG4gIGZ1bmN0aW9uIGVtaXRCYXRjaEJvZHkgKGVudiwgc2NvcGUsIGFyZ3MsIHByb2dyYW0pIHtcbiAgICBpbmplY3RFeHRlbnNpb25zKGVudiwgc2NvcGUpXG5cbiAgICB2YXIgY29udGV4dER5bmFtaWMgPSBhcmdzLmNvbnRleHREZXBcblxuICAgIHZhciBCQVRDSF9JRCA9IHNjb3BlLmRlZigpXG4gICAgdmFyIFBST1BfTElTVCA9ICdhMCdcbiAgICB2YXIgTlVNX1BST1BTID0gJ2ExJ1xuICAgIHZhciBQUk9QUyA9IHNjb3BlLmRlZigpXG4gICAgZW52LnNoYXJlZC5wcm9wcyA9IFBST1BTXG4gICAgZW52LmJhdGNoSWQgPSBCQVRDSF9JRFxuXG4gICAgdmFyIG91dGVyID0gZW52LnNjb3BlKClcbiAgICB2YXIgaW5uZXIgPSBlbnYuc2NvcGUoKVxuXG4gICAgc2NvcGUoXG4gICAgICBvdXRlci5lbnRyeSxcbiAgICAgICdmb3IoJywgQkFUQ0hfSUQsICc9MDsnLCBCQVRDSF9JRCwgJzwnLCBOVU1fUFJPUFMsICc7KysnLCBCQVRDSF9JRCwgJyl7JyxcbiAgICAgIFBST1BTLCAnPScsIFBST1BfTElTVCwgJ1snLCBCQVRDSF9JRCwgJ107JyxcbiAgICAgIGlubmVyLFxuICAgICAgJ30nLFxuICAgICAgb3V0ZXIuZXhpdClcblxuICAgIGZ1bmN0aW9uIGlzSW5uZXJEZWZuIChkZWZuKSB7XG4gICAgICByZXR1cm4gKChkZWZuLmNvbnRleHREZXAgJiYgY29udGV4dER5bmFtaWMpIHx8IGRlZm4ucHJvcERlcClcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc091dGVyRGVmbiAoZGVmbikge1xuICAgICAgcmV0dXJuICFpc0lubmVyRGVmbihkZWZuKVxuICAgIH1cblxuICAgIGlmIChhcmdzLm5lZWRzQ29udGV4dCkge1xuICAgICAgZW1pdENvbnRleHQoZW52LCBpbm5lciwgYXJncy5jb250ZXh0KVxuICAgIH1cbiAgICBpZiAoYXJncy5uZWVkc0ZyYW1lYnVmZmVyKSB7XG4gICAgICBlbWl0UG9sbEZyYW1lYnVmZmVyKGVudiwgaW5uZXIsIGFyZ3MuZnJhbWVidWZmZXIpXG4gICAgfVxuICAgIGVtaXRTZXRPcHRpb25zKGVudiwgaW5uZXIsIGFyZ3Muc3RhdGUsIGlzSW5uZXJEZWZuKVxuXG4gICAgaWYgKGFyZ3MucHJvZmlsZSAmJiBpc0lubmVyRGVmbihhcmdzLnByb2ZpbGUpKSB7XG4gICAgICBlbWl0UHJvZmlsZShlbnYsIGlubmVyLCBhcmdzLCBmYWxzZSwgdHJ1ZSlcbiAgICB9XG5cbiAgICBpZiAoIXByb2dyYW0pIHtcbiAgICAgIHZhciBwcm9nQ2FjaGUgPSBlbnYuZ2xvYmFsLmRlZigne30nKVxuICAgICAgdmFyIFBST0dSQU0gPSBhcmdzLnNoYWRlci5wcm9nVmFyLmFwcGVuZChlbnYsIGlubmVyKVxuICAgICAgdmFyIFBST0dfSUQgPSBpbm5lci5kZWYoUFJPR1JBTSwgJy5pZCcpXG4gICAgICB2YXIgQ0FDSEVEX1BST0MgPSBpbm5lci5kZWYocHJvZ0NhY2hlLCAnWycsIFBST0dfSUQsICddJylcbiAgICAgIGlubmVyKFxuICAgICAgICBlbnYuc2hhcmVkLmdsLCAnLnVzZVByb2dyYW0oJywgUFJPR1JBTSwgJy5wcm9ncmFtKTsnLFxuICAgICAgICAnaWYoIScsIENBQ0hFRF9QUk9DLCAnKXsnLFxuICAgICAgICBDQUNIRURfUFJPQywgJz0nLCBwcm9nQ2FjaGUsICdbJywgUFJPR19JRCwgJ109JyxcbiAgICAgICAgZW52LmxpbmsoZnVuY3Rpb24gKHByb2dyYW0pIHtcbiAgICAgICAgICByZXR1cm4gY3JlYXRlQm9keShcbiAgICAgICAgICAgIGVtaXRCYXRjaER5bmFtaWNTaGFkZXJCb2R5LCBlbnYsIGFyZ3MsIHByb2dyYW0sIDIpXG4gICAgICAgIH0pLCAnKCcsIFBST0dSQU0sICcpO30nLFxuICAgICAgICBDQUNIRURfUFJPQywgJy5jYWxsKHRoaXMsYTBbJywgQkFUQ0hfSUQsICddLCcsIEJBVENIX0lELCAnKTsnKVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoYXJncy51c2VWQU8pIHtcbiAgICAgICAgaWYgKGFyZ3MuZHJhd1ZBTykge1xuICAgICAgICAgIGlmIChpc0lubmVyRGVmbihhcmdzLmRyYXdWQU8pKSB7XG4gICAgICAgICAgICAvLyB2YW8gaXMgYSBwcm9wXG4gICAgICAgICAgICBpbm5lcihlbnYuc2hhcmVkLnZhbywgJy5zZXRWQU8oJywgYXJncy5kcmF3VkFPLmFwcGVuZChlbnYsIGlubmVyKSwgJyk7JylcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gdmFvIGlzIGludmFyaWFudFxuICAgICAgICAgICAgb3V0ZXIoZW52LnNoYXJlZC52YW8sICcuc2V0VkFPKCcsIGFyZ3MuZHJhd1ZBTy5hcHBlbmQoZW52LCBvdXRlciksICcpOycpXG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHNjb3BlZCB2YW8gYmluZGluZ1xuICAgICAgICAgIG91dGVyKGVudi5zaGFyZWQudmFvLCAnLnNldFZBTygnLCBlbnYuc2hhcmVkLnZhbywgJy50YXJnZXRWQU8pOycpXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG91dGVyKGVudi5zaGFyZWQudmFvLCAnLnNldFZBTyhudWxsKTsnKVxuICAgICAgICBlbWl0QXR0cmlidXRlcyhlbnYsIG91dGVyLCBhcmdzLCBwcm9ncmFtLmF0dHJpYnV0ZXMsIGlzT3V0ZXJEZWZuKVxuICAgICAgICBlbWl0QXR0cmlidXRlcyhlbnYsIGlubmVyLCBhcmdzLCBwcm9ncmFtLmF0dHJpYnV0ZXMsIGlzSW5uZXJEZWZuKVxuICAgICAgfVxuICAgICAgZW1pdFVuaWZvcm1zKGVudiwgb3V0ZXIsIGFyZ3MsIHByb2dyYW0udW5pZm9ybXMsIGlzT3V0ZXJEZWZuKVxuICAgICAgZW1pdFVuaWZvcm1zKGVudiwgaW5uZXIsIGFyZ3MsIHByb2dyYW0udW5pZm9ybXMsIGlzSW5uZXJEZWZuKVxuICAgICAgZW1pdERyYXcoZW52LCBvdXRlciwgaW5uZXIsIGFyZ3MpXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZW1pdEJhdGNoUHJvYyAoZW52LCBhcmdzKSB7XG4gICAgdmFyIGJhdGNoID0gZW52LnByb2MoJ2JhdGNoJywgMilcbiAgICBlbnYuYmF0Y2hJZCA9ICcwJ1xuXG4gICAgaW5qZWN0RXh0ZW5zaW9ucyhlbnYsIGJhdGNoKVxuXG4gICAgLy8gQ2hlY2sgaWYgYW55IGNvbnRleHQgdmFyaWFibGVzIGRlcGVuZCBvbiBwcm9wc1xuICAgIHZhciBjb250ZXh0RHluYW1pYyA9IGZhbHNlXG4gICAgdmFyIG5lZWRzQ29udGV4dCA9IHRydWVcbiAgICBPYmplY3Qua2V5cyhhcmdzLmNvbnRleHQpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIGNvbnRleHREeW5hbWljID0gY29udGV4dER5bmFtaWMgfHwgYXJncy5jb250ZXh0W25hbWVdLnByb3BEZXBcbiAgICB9KVxuICAgIGlmICghY29udGV4dER5bmFtaWMpIHtcbiAgICAgIGVtaXRDb250ZXh0KGVudiwgYmF0Y2gsIGFyZ3MuY29udGV4dClcbiAgICAgIG5lZWRzQ29udGV4dCA9IGZhbHNlXG4gICAgfVxuXG4gICAgLy8gZnJhbWVidWZmZXIgc3RhdGUgYWZmZWN0cyBmcmFtZWJ1ZmZlcldpZHRoL2hlaWdodCBjb250ZXh0IHZhcnNcbiAgICB2YXIgZnJhbWVidWZmZXIgPSBhcmdzLmZyYW1lYnVmZmVyXG4gICAgdmFyIG5lZWRzRnJhbWVidWZmZXIgPSBmYWxzZVxuICAgIGlmIChmcmFtZWJ1ZmZlcikge1xuICAgICAgaWYgKGZyYW1lYnVmZmVyLnByb3BEZXApIHtcbiAgICAgICAgY29udGV4dER5bmFtaWMgPSBuZWVkc0ZyYW1lYnVmZmVyID0gdHJ1ZVxuICAgICAgfSBlbHNlIGlmIChmcmFtZWJ1ZmZlci5jb250ZXh0RGVwICYmIGNvbnRleHREeW5hbWljKSB7XG4gICAgICAgIG5lZWRzRnJhbWVidWZmZXIgPSB0cnVlXG4gICAgICB9XG4gICAgICBpZiAoIW5lZWRzRnJhbWVidWZmZXIpIHtcbiAgICAgICAgZW1pdFBvbGxGcmFtZWJ1ZmZlcihlbnYsIGJhdGNoLCBmcmFtZWJ1ZmZlcilcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZW1pdFBvbGxGcmFtZWJ1ZmZlcihlbnYsIGJhdGNoLCBudWxsKVxuICAgIH1cblxuICAgIC8vIHZpZXdwb3J0IGlzIHdlaXJkIGJlY2F1c2UgaXQgY2FuIGFmZmVjdCBjb250ZXh0IHZhcnNcbiAgICBpZiAoYXJncy5zdGF0ZS52aWV3cG9ydCAmJiBhcmdzLnN0YXRlLnZpZXdwb3J0LnByb3BEZXApIHtcbiAgICAgIGNvbnRleHREeW5hbWljID0gdHJ1ZVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzSW5uZXJEZWZuIChkZWZuKSB7XG4gICAgICByZXR1cm4gKGRlZm4uY29udGV4dERlcCAmJiBjb250ZXh0RHluYW1pYykgfHwgZGVmbi5wcm9wRGVwXG4gICAgfVxuXG4gICAgLy8gc2V0IHdlYmdsIG9wdGlvbnNcbiAgICBlbWl0UG9sbFN0YXRlKGVudiwgYmF0Y2gsIGFyZ3MpXG4gICAgZW1pdFNldE9wdGlvbnMoZW52LCBiYXRjaCwgYXJncy5zdGF0ZSwgZnVuY3Rpb24gKGRlZm4pIHtcbiAgICAgIHJldHVybiAhaXNJbm5lckRlZm4oZGVmbilcbiAgICB9KVxuXG4gICAgaWYgKCFhcmdzLnByb2ZpbGUgfHwgIWlzSW5uZXJEZWZuKGFyZ3MucHJvZmlsZSkpIHtcbiAgICAgIGVtaXRQcm9maWxlKGVudiwgYmF0Y2gsIGFyZ3MsIGZhbHNlLCAnYTEnKVxuICAgIH1cblxuICAgIC8vIFNhdmUgdGhlc2UgdmFsdWVzIHRvIGFyZ3Mgc28gdGhhdCB0aGUgYmF0Y2ggYm9keSByb3V0aW5lIGNhbiB1c2UgdGhlbVxuICAgIGFyZ3MuY29udGV4dERlcCA9IGNvbnRleHREeW5hbWljXG4gICAgYXJncy5uZWVkc0NvbnRleHQgPSBuZWVkc0NvbnRleHRcbiAgICBhcmdzLm5lZWRzRnJhbWVidWZmZXIgPSBuZWVkc0ZyYW1lYnVmZmVyXG5cbiAgICAvLyBkZXRlcm1pbmUgaWYgc2hhZGVyIGlzIGR5bmFtaWNcbiAgICB2YXIgcHJvZ0RlZm4gPSBhcmdzLnNoYWRlci5wcm9nVmFyXG4gICAgaWYgKChwcm9nRGVmbi5jb250ZXh0RGVwICYmIGNvbnRleHREeW5hbWljKSB8fCBwcm9nRGVmbi5wcm9wRGVwKSB7XG4gICAgICBlbWl0QmF0Y2hCb2R5KFxuICAgICAgICBlbnYsXG4gICAgICAgIGJhdGNoLFxuICAgICAgICBhcmdzLFxuICAgICAgICBudWxsKVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgUFJPR1JBTSA9IHByb2dEZWZuLmFwcGVuZChlbnYsIGJhdGNoKVxuICAgICAgYmF0Y2goZW52LnNoYXJlZC5nbCwgJy51c2VQcm9ncmFtKCcsIFBST0dSQU0sICcucHJvZ3JhbSk7JylcbiAgICAgIGlmIChhcmdzLnNoYWRlci5wcm9ncmFtKSB7XG4gICAgICAgIGVtaXRCYXRjaEJvZHkoXG4gICAgICAgICAgZW52LFxuICAgICAgICAgIGJhdGNoLFxuICAgICAgICAgIGFyZ3MsXG4gICAgICAgICAgYXJncy5zaGFkZXIucHJvZ3JhbSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJhdGNoKGVudi5zaGFyZWQudmFvLCAnLnNldFZBTyhudWxsKTsnKVxuICAgICAgICB2YXIgYmF0Y2hDYWNoZSA9IGVudi5nbG9iYWwuZGVmKCd7fScpXG4gICAgICAgIHZhciBQUk9HX0lEID0gYmF0Y2guZGVmKFBST0dSQU0sICcuaWQnKVxuICAgICAgICB2YXIgQ0FDSEVEX1BST0MgPSBiYXRjaC5kZWYoYmF0Y2hDYWNoZSwgJ1snLCBQUk9HX0lELCAnXScpXG4gICAgICAgIGJhdGNoKFxuICAgICAgICAgIGVudi5jb25kKENBQ0hFRF9QUk9DKVxuICAgICAgICAgICAgLnRoZW4oQ0FDSEVEX1BST0MsICcuY2FsbCh0aGlzLGEwLGExKTsnKVxuICAgICAgICAgICAgLmVsc2UoXG4gICAgICAgICAgICAgIENBQ0hFRF9QUk9DLCAnPScsIGJhdGNoQ2FjaGUsICdbJywgUFJPR19JRCwgJ109JyxcbiAgICAgICAgICAgICAgZW52LmxpbmsoZnVuY3Rpb24gKHByb2dyYW0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlQm9keShlbWl0QmF0Y2hCb2R5LCBlbnYsIGFyZ3MsIHByb2dyYW0sIDIpXG4gICAgICAgICAgICAgIH0pLCAnKCcsIFBST0dSQU0sICcpOycsXG4gICAgICAgICAgICAgIENBQ0hFRF9QUk9DLCAnLmNhbGwodGhpcyxhMCxhMSk7JykpXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKE9iamVjdC5rZXlzKGFyZ3Muc3RhdGUpLmxlbmd0aCA+IDApIHtcbiAgICAgIGJhdGNoKGVudi5zaGFyZWQuY3VycmVudCwgJy5kaXJ0eT10cnVlOycpXG4gICAgfVxuICB9XG5cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyBTQ09QRSBDT01NQU5EXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgZnVuY3Rpb24gZW1pdFNjb3BlUHJvYyAoZW52LCBhcmdzKSB7XG4gICAgdmFyIHNjb3BlID0gZW52LnByb2MoJ3Njb3BlJywgMylcbiAgICBlbnYuYmF0Y2hJZCA9ICdhMidcblxuICAgIHZhciBzaGFyZWQgPSBlbnYuc2hhcmVkXG4gICAgdmFyIENVUlJFTlRfU1RBVEUgPSBzaGFyZWQuY3VycmVudFxuXG4gICAgZW1pdENvbnRleHQoZW52LCBzY29wZSwgYXJncy5jb250ZXh0KVxuXG4gICAgaWYgKGFyZ3MuZnJhbWVidWZmZXIpIHtcbiAgICAgIGFyZ3MuZnJhbWVidWZmZXIuYXBwZW5kKGVudiwgc2NvcGUpXG4gICAgfVxuXG4gICAgc29ydFN0YXRlKE9iamVjdC5rZXlzKGFyZ3Muc3RhdGUpKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICB2YXIgZGVmbiA9IGFyZ3Muc3RhdGVbbmFtZV1cbiAgICAgIHZhciB2YWx1ZSA9IGRlZm4uYXBwZW5kKGVudiwgc2NvcGUpXG4gICAgICBpZiAoaXNBcnJheUxpa2UodmFsdWUpKSB7XG4gICAgICAgIHZhbHVlLmZvckVhY2goZnVuY3Rpb24gKHYsIGkpIHtcbiAgICAgICAgICBzY29wZS5zZXQoZW52Lm5leHRbbmFtZV0sICdbJyArIGkgKyAnXScsIHYpXG4gICAgICAgIH0pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzY29wZS5zZXQoc2hhcmVkLm5leHQsICcuJyArIG5hbWUsIHZhbHVlKVxuICAgICAgfVxuICAgIH0pXG5cbiAgICBlbWl0UHJvZmlsZShlbnYsIHNjb3BlLCBhcmdzLCB0cnVlLCB0cnVlKVxuXG4gICAgO1tTX0VMRU1FTlRTLCBTX09GRlNFVCwgU19DT1VOVCwgU19JTlNUQU5DRVMsIFNfUFJJTUlUSVZFXS5mb3JFYWNoKFxuICAgICAgZnVuY3Rpb24gKG9wdCkge1xuICAgICAgICB2YXIgdmFyaWFibGUgPSBhcmdzLmRyYXdbb3B0XVxuICAgICAgICBpZiAoIXZhcmlhYmxlKSB7XG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgICAgc2NvcGUuc2V0KHNoYXJlZC5kcmF3LCAnLicgKyBvcHQsICcnICsgdmFyaWFibGUuYXBwZW5kKGVudiwgc2NvcGUpKVxuICAgICAgfSlcblxuICAgIE9iamVjdC5rZXlzKGFyZ3MudW5pZm9ybXMpLmZvckVhY2goZnVuY3Rpb24gKG9wdCkge1xuICAgICAgdmFyIHZhbHVlID0gYXJncy51bmlmb3Jtc1tvcHRdLmFwcGVuZChlbnYsIHNjb3BlKVxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHZhbHVlID0gJ1snICsgdmFsdWUuam9pbigpICsgJ10nXG4gICAgICB9XG4gICAgICBzY29wZS5zZXQoXG4gICAgICAgIHNoYXJlZC51bmlmb3JtcyxcbiAgICAgICAgJ1snICsgc3RyaW5nU3RvcmUuaWQob3B0KSArICddJyxcbiAgICAgICAgdmFsdWUpXG4gICAgfSlcblxuICAgIE9iamVjdC5rZXlzKGFyZ3MuYXR0cmlidXRlcykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgdmFyIHJlY29yZCA9IGFyZ3MuYXR0cmlidXRlc1tuYW1lXS5hcHBlbmQoZW52LCBzY29wZSlcbiAgICAgIHZhciBzY29wZUF0dHJpYiA9IGVudi5zY29wZUF0dHJpYihuYW1lKVxuICAgICAgT2JqZWN0LmtleXMobmV3IEF0dHJpYnV0ZVJlY29yZCgpKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgIHNjb3BlLnNldChzY29wZUF0dHJpYiwgJy4nICsgcHJvcCwgcmVjb3JkW3Byb3BdKVxuICAgICAgfSlcbiAgICB9KVxuXG4gICAgaWYgKGFyZ3Muc2NvcGVWQU8pIHtcbiAgICAgIHNjb3BlLnNldChzaGFyZWQudmFvLCAnLnRhcmdldFZBTycsIGFyZ3Muc2NvcGVWQU8uYXBwZW5kKGVudiwgc2NvcGUpKVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNhdmVTaGFkZXIgKG5hbWUpIHtcbiAgICAgIHZhciBzaGFkZXIgPSBhcmdzLnNoYWRlcltuYW1lXVxuICAgICAgaWYgKHNoYWRlcikge1xuICAgICAgICBzY29wZS5zZXQoc2hhcmVkLnNoYWRlciwgJy4nICsgbmFtZSwgc2hhZGVyLmFwcGVuZChlbnYsIHNjb3BlKSlcbiAgICAgIH1cbiAgICB9XG4gICAgc2F2ZVNoYWRlcihTX1ZFUlQpXG4gICAgc2F2ZVNoYWRlcihTX0ZSQUcpXG5cbiAgICBpZiAoT2JqZWN0LmtleXMoYXJncy5zdGF0ZSkubGVuZ3RoID4gMCkge1xuICAgICAgc2NvcGUoQ1VSUkVOVF9TVEFURSwgJy5kaXJ0eT10cnVlOycpXG4gICAgICBzY29wZS5leGl0KENVUlJFTlRfU1RBVEUsICcuZGlydHk9dHJ1ZTsnKVxuICAgIH1cblxuICAgIHNjb3BlKCdhMSgnLCBlbnYuc2hhcmVkLmNvbnRleHQsICcsYTAsJywgZW52LmJhdGNoSWQsICcpOycpXG4gIH1cblxuICBmdW5jdGlvbiBpc0R5bmFtaWNPYmplY3QgKG9iamVjdCkge1xuICAgIGlmICh0eXBlb2Ygb2JqZWN0ICE9PSAnb2JqZWN0JyB8fCBpc0FycmF5TGlrZShvYmplY3QpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgdmFyIHByb3BzID0gT2JqZWN0LmtleXMob2JqZWN0KVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGlmIChkeW5hbWljLmlzRHluYW1pYyhvYmplY3RbcHJvcHNbaV1dKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIGZ1bmN0aW9uIHNwbGF0T2JqZWN0IChlbnYsIG9wdGlvbnMsIG5hbWUpIHtcbiAgICB2YXIgb2JqZWN0ID0gb3B0aW9ucy5zdGF0aWNbbmFtZV1cbiAgICBpZiAoIW9iamVjdCB8fCAhaXNEeW5hbWljT2JqZWN0KG9iamVjdCkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHZhciBnbG9iYWxzID0gZW52Lmdsb2JhbFxuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KVxuICAgIHZhciB0aGlzRGVwID0gZmFsc2VcbiAgICB2YXIgY29udGV4dERlcCA9IGZhbHNlXG4gICAgdmFyIHByb3BEZXAgPSBmYWxzZVxuICAgIHZhciBvYmplY3RSZWYgPSBlbnYuZ2xvYmFsLmRlZigne30nKVxuICAgIGtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICB2YXIgdmFsdWUgPSBvYmplY3Rba2V5XVxuICAgICAgaWYgKGR5bmFtaWMuaXNEeW5hbWljKHZhbHVlKSkge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgdmFsdWUgPSBvYmplY3Rba2V5XSA9IGR5bmFtaWMudW5ib3godmFsdWUpXG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRlcHMgPSBjcmVhdGVEeW5hbWljRGVjbCh2YWx1ZSwgbnVsbClcbiAgICAgICAgdGhpc0RlcCA9IHRoaXNEZXAgfHwgZGVwcy50aGlzRGVwXG4gICAgICAgIHByb3BEZXAgPSBwcm9wRGVwIHx8IGRlcHMucHJvcERlcFxuICAgICAgICBjb250ZXh0RGVwID0gY29udGV4dERlcCB8fCBkZXBzLmNvbnRleHREZXBcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGdsb2JhbHMob2JqZWN0UmVmLCAnLicsIGtleSwgJz0nKVxuICAgICAgICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xuICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICBnbG9iYWxzKHZhbHVlKVxuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgZ2xvYmFscygnXCInLCB2YWx1ZSwgJ1wiJylcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICBnbG9iYWxzKCdbJywgdmFsdWUuam9pbigpLCAnXScpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBnbG9iYWxzKGVudi5saW5rKHZhbHVlKSlcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgZ2xvYmFscygnOycpXG4gICAgICB9XG4gICAgfSlcblxuICAgIGZ1bmN0aW9uIGFwcGVuZEJsb2NrIChlbnYsIGJsb2NrKSB7XG4gICAgICBrZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICB2YXIgdmFsdWUgPSBvYmplY3Rba2V5XVxuICAgICAgICBpZiAoIWR5bmFtaWMuaXNEeW5hbWljKHZhbHVlKSkge1xuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICAgIHZhciByZWYgPSBlbnYuaW52b2tlKGJsb2NrLCB2YWx1ZSlcbiAgICAgICAgYmxvY2sob2JqZWN0UmVmLCAnLicsIGtleSwgJz0nLCByZWYsICc7JylcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgb3B0aW9ucy5keW5hbWljW25hbWVdID0gbmV3IGR5bmFtaWMuRHluYW1pY1ZhcmlhYmxlKERZTl9USFVOSywge1xuICAgICAgdGhpc0RlcDogdGhpc0RlcCxcbiAgICAgIGNvbnRleHREZXA6IGNvbnRleHREZXAsXG4gICAgICBwcm9wRGVwOiBwcm9wRGVwLFxuICAgICAgcmVmOiBvYmplY3RSZWYsXG4gICAgICBhcHBlbmQ6IGFwcGVuZEJsb2NrXG4gICAgfSlcbiAgICBkZWxldGUgb3B0aW9ucy5zdGF0aWNbbmFtZV1cbiAgfVxuXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8gTUFJTiBEUkFXIENPTU1BTkRcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICBmdW5jdGlvbiBjb21waWxlQ29tbWFuZCAob3B0aW9ucywgYXR0cmlidXRlcywgdW5pZm9ybXMsIGNvbnRleHQsIHN0YXRzKSB7XG4gICAgdmFyIGVudiA9IGNyZWF0ZVJFR0xFbnZpcm9ubWVudCgpXG5cbiAgICAvLyBsaW5rIHN0YXRzLCBzbyB0aGF0IHdlIGNhbiBlYXNpbHkgYWNjZXNzIGl0IGluIHRoZSBwcm9ncmFtLlxuICAgIGVudi5zdGF0cyA9IGVudi5saW5rKHN0YXRzKVxuXG4gICAgLy8gc3BsYXQgb3B0aW9ucyBhbmQgYXR0cmlidXRlcyB0byBhbGxvdyBmb3IgZHluYW1pYyBuZXN0ZWQgcHJvcGVydGllc1xuICAgIE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMuc3RhdGljKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHNwbGF0T2JqZWN0KGVudiwgYXR0cmlidXRlcywga2V5KVxuICAgIH0pXG4gICAgTkVTVEVEX09QVElPTlMuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgc3BsYXRPYmplY3QoZW52LCBvcHRpb25zLCBuYW1lKVxuICAgIH0pXG5cbiAgICB2YXIgYXJncyA9IHBhcnNlQXJndW1lbnRzKG9wdGlvbnMsIGF0dHJpYnV0ZXMsIHVuaWZvcm1zLCBjb250ZXh0LCBlbnYpXG5cbiAgICBlbWl0RHJhd1Byb2MoZW52LCBhcmdzKVxuICAgIGVtaXRTY29wZVByb2MoZW52LCBhcmdzKVxuICAgIGVtaXRCYXRjaFByb2MoZW52LCBhcmdzKVxuXG4gICAgcmV0dXJuIGV4dGVuZChlbnYuY29tcGlsZSgpLCB7XG4gICAgICBkZXN0cm95OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGFyZ3Muc2hhZGVyLnByb2dyYW0uZGVzdHJveSgpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8gUE9MTCAvIFJFRlJFU0hcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICByZXR1cm4ge1xuICAgIG5leHQ6IG5leHRTdGF0ZSxcbiAgICBjdXJyZW50OiBjdXJyZW50U3RhdGUsXG4gICAgcHJvY3M6IChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgZW52ID0gY3JlYXRlUkVHTEVudmlyb25tZW50KClcbiAgICAgIHZhciBwb2xsID0gZW52LnByb2MoJ3BvbGwnKVxuICAgICAgdmFyIHJlZnJlc2ggPSBlbnYucHJvYygncmVmcmVzaCcpXG4gICAgICB2YXIgY29tbW9uID0gZW52LmJsb2NrKClcbiAgICAgIHBvbGwoY29tbW9uKVxuICAgICAgcmVmcmVzaChjb21tb24pXG5cbiAgICAgIHZhciBzaGFyZWQgPSBlbnYuc2hhcmVkXG4gICAgICB2YXIgR0wgPSBzaGFyZWQuZ2xcbiAgICAgIHZhciBORVhUX1NUQVRFID0gc2hhcmVkLm5leHRcbiAgICAgIHZhciBDVVJSRU5UX1NUQVRFID0gc2hhcmVkLmN1cnJlbnRcblxuICAgICAgY29tbW9uKENVUlJFTlRfU1RBVEUsICcuZGlydHk9ZmFsc2U7JylcblxuICAgICAgZW1pdFBvbGxGcmFtZWJ1ZmZlcihlbnYsIHBvbGwpXG4gICAgICBlbWl0UG9sbEZyYW1lYnVmZmVyKGVudiwgcmVmcmVzaCwgbnVsbCwgdHJ1ZSlcblxuICAgICAgLy8gUmVmcmVzaCB1cGRhdGVzIGFsbCBhdHRyaWJ1dGUgc3RhdGUgY2hhbmdlc1xuICAgICAgdmFyIElOU1RBTkNJTkdcbiAgICAgIGlmIChleHRJbnN0YW5jaW5nKSB7XG4gICAgICAgIElOU1RBTkNJTkcgPSBlbnYubGluayhleHRJbnN0YW5jaW5nKVxuICAgICAgfVxuXG4gICAgICAvLyB1cGRhdGUgdmVydGV4IGFycmF5IGJpbmRpbmdzXG4gICAgICBpZiAoZXh0ZW5zaW9ucy5vZXNfdmVydGV4X2FycmF5X29iamVjdCkge1xuICAgICAgICByZWZyZXNoKGVudi5saW5rKGV4dGVuc2lvbnMub2VzX3ZlcnRleF9hcnJheV9vYmplY3QpLCAnLmJpbmRWZXJ0ZXhBcnJheU9FUyhudWxsKTsnKVxuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW1pdHMubWF4QXR0cmlidXRlczsgKytpKSB7XG4gICAgICAgIHZhciBCSU5ESU5HID0gcmVmcmVzaC5kZWYoc2hhcmVkLmF0dHJpYnV0ZXMsICdbJywgaSwgJ10nKVxuICAgICAgICB2YXIgaWZ0ZSA9IGVudi5jb25kKEJJTkRJTkcsICcuYnVmZmVyJylcbiAgICAgICAgaWZ0ZS50aGVuKFxuICAgICAgICAgIEdMLCAnLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KCcsIGksICcpOycsXG4gICAgICAgICAgR0wsICcuYmluZEJ1ZmZlcignLFxuICAgICAgICAgIEdMX0FSUkFZX0JVRkZFUiQyLCAnLCcsXG4gICAgICAgICAgQklORElORywgJy5idWZmZXIuYnVmZmVyKTsnLFxuICAgICAgICAgIEdMLCAnLnZlcnRleEF0dHJpYlBvaW50ZXIoJyxcbiAgICAgICAgICBpLCAnLCcsXG4gICAgICAgICAgQklORElORywgJy5zaXplLCcsXG4gICAgICAgICAgQklORElORywgJy50eXBlLCcsXG4gICAgICAgICAgQklORElORywgJy5ub3JtYWxpemVkLCcsXG4gICAgICAgICAgQklORElORywgJy5zdHJpZGUsJyxcbiAgICAgICAgICBCSU5ESU5HLCAnLm9mZnNldCk7J1xuICAgICAgICApLmVsc2UoXG4gICAgICAgICAgR0wsICcuZGlzYWJsZVZlcnRleEF0dHJpYkFycmF5KCcsIGksICcpOycsXG4gICAgICAgICAgR0wsICcudmVydGV4QXR0cmliNGYoJyxcbiAgICAgICAgICBpLCAnLCcsXG4gICAgICAgICAgQklORElORywgJy54LCcsXG4gICAgICAgICAgQklORElORywgJy55LCcsXG4gICAgICAgICAgQklORElORywgJy56LCcsXG4gICAgICAgICAgQklORElORywgJy53KTsnLFxuICAgICAgICAgIEJJTkRJTkcsICcuYnVmZmVyPW51bGw7JylcbiAgICAgICAgcmVmcmVzaChpZnRlKVxuICAgICAgICBpZiAoZXh0SW5zdGFuY2luZykge1xuICAgICAgICAgIHJlZnJlc2goXG4gICAgICAgICAgICBJTlNUQU5DSU5HLCAnLnZlcnRleEF0dHJpYkRpdmlzb3JBTkdMRSgnLFxuICAgICAgICAgICAgaSwgJywnLFxuICAgICAgICAgICAgQklORElORywgJy5kaXZpc29yKTsnKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZWZyZXNoKFxuICAgICAgICBlbnYuc2hhcmVkLnZhbywgJy5jdXJyZW50VkFPPW51bGw7JyxcbiAgICAgICAgZW52LnNoYXJlZC52YW8sICcuc2V0VkFPKCcsIGVudi5zaGFyZWQudmFvLCAnLnRhcmdldFZBTyk7JylcblxuICAgICAgT2JqZWN0LmtleXMoR0xfRkxBR1MpLmZvckVhY2goZnVuY3Rpb24gKGZsYWcpIHtcbiAgICAgICAgdmFyIGNhcCA9IEdMX0ZMQUdTW2ZsYWddXG4gICAgICAgIHZhciBORVhUID0gY29tbW9uLmRlZihORVhUX1NUQVRFLCAnLicsIGZsYWcpXG4gICAgICAgIHZhciBibG9jayA9IGVudi5ibG9jaygpXG4gICAgICAgIGJsb2NrKCdpZignLCBORVhULCAnKXsnLFxuICAgICAgICAgIEdMLCAnLmVuYWJsZSgnLCBjYXAsICcpfWVsc2V7JyxcbiAgICAgICAgICBHTCwgJy5kaXNhYmxlKCcsIGNhcCwgJyl9JyxcbiAgICAgICAgICBDVVJSRU5UX1NUQVRFLCAnLicsIGZsYWcsICc9JywgTkVYVCwgJzsnKVxuICAgICAgICByZWZyZXNoKGJsb2NrKVxuICAgICAgICBwb2xsKFxuICAgICAgICAgICdpZignLCBORVhULCAnIT09JywgQ1VSUkVOVF9TVEFURSwgJy4nLCBmbGFnLCAnKXsnLFxuICAgICAgICAgIGJsb2NrLFxuICAgICAgICAgICd9JylcbiAgICAgIH0pXG5cbiAgICAgIE9iamVjdC5rZXlzKEdMX1ZBUklBQkxFUykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICB2YXIgZnVuYyA9IEdMX1ZBUklBQkxFU1tuYW1lXVxuICAgICAgICB2YXIgaW5pdCA9IGN1cnJlbnRTdGF0ZVtuYW1lXVxuICAgICAgICB2YXIgTkVYVCwgQ1VSUkVOVFxuICAgICAgICB2YXIgYmxvY2sgPSBlbnYuYmxvY2soKVxuICAgICAgICBibG9jayhHTCwgJy4nLCBmdW5jLCAnKCcpXG4gICAgICAgIGlmIChpc0FycmF5TGlrZShpbml0KSkge1xuICAgICAgICAgIHZhciBuID0gaW5pdC5sZW5ndGhcbiAgICAgICAgICBORVhUID0gZW52Lmdsb2JhbC5kZWYoTkVYVF9TVEFURSwgJy4nLCBuYW1lKVxuICAgICAgICAgIENVUlJFTlQgPSBlbnYuZ2xvYmFsLmRlZihDVVJSRU5UX1NUQVRFLCAnLicsIG5hbWUpXG4gICAgICAgICAgYmxvY2soXG4gICAgICAgICAgICBsb29wKG4sIGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBORVhUICsgJ1snICsgaSArICddJ1xuICAgICAgICAgICAgfSksICcpOycsXG4gICAgICAgICAgICBsb29wKG4sIGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBDVVJSRU5UICsgJ1snICsgaSArICddPScgKyBORVhUICsgJ1snICsgaSArICddOydcbiAgICAgICAgICAgIH0pLmpvaW4oJycpKVxuICAgICAgICAgIHBvbGwoXG4gICAgICAgICAgICAnaWYoJywgbG9vcChuLCBmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgICByZXR1cm4gTkVYVCArICdbJyArIGkgKyAnXSE9PScgKyBDVVJSRU5UICsgJ1snICsgaSArICddJ1xuICAgICAgICAgICAgfSkuam9pbignfHwnKSwgJyl7JyxcbiAgICAgICAgICAgIGJsb2NrLFxuICAgICAgICAgICAgJ30nKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIE5FWFQgPSBjb21tb24uZGVmKE5FWFRfU1RBVEUsICcuJywgbmFtZSlcbiAgICAgICAgICBDVVJSRU5UID0gY29tbW9uLmRlZihDVVJSRU5UX1NUQVRFLCAnLicsIG5hbWUpXG4gICAgICAgICAgYmxvY2soXG4gICAgICAgICAgICBORVhULCAnKTsnLFxuICAgICAgICAgICAgQ1VSUkVOVF9TVEFURSwgJy4nLCBuYW1lLCAnPScsIE5FWFQsICc7JylcbiAgICAgICAgICBwb2xsKFxuICAgICAgICAgICAgJ2lmKCcsIE5FWFQsICchPT0nLCBDVVJSRU5ULCAnKXsnLFxuICAgICAgICAgICAgYmxvY2ssXG4gICAgICAgICAgICAnfScpXG4gICAgICAgIH1cbiAgICAgICAgcmVmcmVzaChibG9jaylcbiAgICAgIH0pXG5cbiAgICAgIHJldHVybiBlbnYuY29tcGlsZSgpXG4gICAgfSkoKSxcbiAgICBjb21waWxlOiBjb21waWxlQ29tbWFuZFxuICB9XG59XG5cbmZ1bmN0aW9uIHN0YXRzICgpIHtcbiAgcmV0dXJuIHtcbiAgICB2YW9Db3VudDogMCxcbiAgICBidWZmZXJDb3VudDogMCxcbiAgICBlbGVtZW50c0NvdW50OiAwLFxuICAgIGZyYW1lYnVmZmVyQ291bnQ6IDAsXG4gICAgc2hhZGVyQ291bnQ6IDAsXG4gICAgdGV4dHVyZUNvdW50OiAwLFxuICAgIGN1YmVDb3VudDogMCxcbiAgICByZW5kZXJidWZmZXJDb3VudDogMCxcbiAgICBtYXhUZXh0dXJlVW5pdHM6IDBcbiAgfVxufVxuXG52YXIgR0xfUVVFUllfUkVTVUxUX0VYVCA9IDB4ODg2NlxudmFyIEdMX1FVRVJZX1JFU1VMVF9BVkFJTEFCTEVfRVhUID0gMHg4ODY3XG52YXIgR0xfVElNRV9FTEFQU0VEX0VYVCA9IDB4ODhCRlxuXG52YXIgY3JlYXRlVGltZXIgPSBmdW5jdGlvbiAoZ2wsIGV4dGVuc2lvbnMpIHtcbiAgaWYgKCFleHRlbnNpb25zLmV4dF9kaXNqb2ludF90aW1lcl9xdWVyeSkge1xuICAgIHJldHVybiBudWxsXG4gIH1cblxuICAvLyBRVUVSWSBQT09MIEJFR0lOXG4gIHZhciBxdWVyeVBvb2wgPSBbXVxuICBmdW5jdGlvbiBhbGxvY1F1ZXJ5ICgpIHtcbiAgICByZXR1cm4gcXVlcnlQb29sLnBvcCgpIHx8IGV4dGVuc2lvbnMuZXh0X2Rpc2pvaW50X3RpbWVyX3F1ZXJ5LmNyZWF0ZVF1ZXJ5RVhUKClcbiAgfVxuICBmdW5jdGlvbiBmcmVlUXVlcnkgKHF1ZXJ5KSB7XG4gICAgcXVlcnlQb29sLnB1c2gocXVlcnkpXG4gIH1cbiAgLy8gUVVFUlkgUE9PTCBFTkRcblxuICB2YXIgcGVuZGluZ1F1ZXJpZXMgPSBbXVxuICBmdW5jdGlvbiBiZWdpblF1ZXJ5IChzdGF0cykge1xuICAgIHZhciBxdWVyeSA9IGFsbG9jUXVlcnkoKVxuICAgIGV4dGVuc2lvbnMuZXh0X2Rpc2pvaW50X3RpbWVyX3F1ZXJ5LmJlZ2luUXVlcnlFWFQoR0xfVElNRV9FTEFQU0VEX0VYVCwgcXVlcnkpXG4gICAgcGVuZGluZ1F1ZXJpZXMucHVzaChxdWVyeSlcbiAgICBwdXNoU2NvcGVTdGF0cyhwZW5kaW5nUXVlcmllcy5sZW5ndGggLSAxLCBwZW5kaW5nUXVlcmllcy5sZW5ndGgsIHN0YXRzKVxuICB9XG5cbiAgZnVuY3Rpb24gZW5kUXVlcnkgKCkge1xuICAgIGV4dGVuc2lvbnMuZXh0X2Rpc2pvaW50X3RpbWVyX3F1ZXJ5LmVuZFF1ZXJ5RVhUKEdMX1RJTUVfRUxBUFNFRF9FWFQpXG4gIH1cblxuICAvL1xuICAvLyBQZW5kaW5nIHN0YXRzIHBvb2wuXG4gIC8vXG4gIGZ1bmN0aW9uIFBlbmRpbmdTdGF0cyAoKSB7XG4gICAgdGhpcy5zdGFydFF1ZXJ5SW5kZXggPSAtMVxuICAgIHRoaXMuZW5kUXVlcnlJbmRleCA9IC0xXG4gICAgdGhpcy5zdW0gPSAwXG4gICAgdGhpcy5zdGF0cyA9IG51bGxcbiAgfVxuICB2YXIgcGVuZGluZ1N0YXRzUG9vbCA9IFtdXG4gIGZ1bmN0aW9uIGFsbG9jUGVuZGluZ1N0YXRzICgpIHtcbiAgICByZXR1cm4gcGVuZGluZ1N0YXRzUG9vbC5wb3AoKSB8fCBuZXcgUGVuZGluZ1N0YXRzKClcbiAgfVxuICBmdW5jdGlvbiBmcmVlUGVuZGluZ1N0YXRzIChwZW5kaW5nU3RhdHMpIHtcbiAgICBwZW5kaW5nU3RhdHNQb29sLnB1c2gocGVuZGluZ1N0YXRzKVxuICB9XG4gIC8vIFBlbmRpbmcgc3RhdHMgcG9vbCBlbmRcblxuICB2YXIgcGVuZGluZ1N0YXRzID0gW11cbiAgZnVuY3Rpb24gcHVzaFNjb3BlU3RhdHMgKHN0YXJ0LCBlbmQsIHN0YXRzKSB7XG4gICAgdmFyIHBzID0gYWxsb2NQZW5kaW5nU3RhdHMoKVxuICAgIHBzLnN0YXJ0UXVlcnlJbmRleCA9IHN0YXJ0XG4gICAgcHMuZW5kUXVlcnlJbmRleCA9IGVuZFxuICAgIHBzLnN1bSA9IDBcbiAgICBwcy5zdGF0cyA9IHN0YXRzXG4gICAgcGVuZGluZ1N0YXRzLnB1c2gocHMpXG4gIH1cblxuICAvLyB3ZSBzaG91bGQgY2FsbCB0aGlzIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIGZyYW1lLFxuICAvLyBpbiBvcmRlciB0byB1cGRhdGUgZ3B1VGltZVxuICB2YXIgdGltZVN1bSA9IFtdXG4gIHZhciBxdWVyeVB0ciA9IFtdXG4gIGZ1bmN0aW9uIHVwZGF0ZSAoKSB7XG4gICAgdmFyIHB0ciwgaVxuXG4gICAgdmFyIG4gPSBwZW5kaW5nUXVlcmllcy5sZW5ndGhcbiAgICBpZiAobiA9PT0gMCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gUmVzZXJ2ZSBzcGFjZVxuICAgIHF1ZXJ5UHRyLmxlbmd0aCA9IE1hdGgubWF4KHF1ZXJ5UHRyLmxlbmd0aCwgbiArIDEpXG4gICAgdGltZVN1bS5sZW5ndGggPSBNYXRoLm1heCh0aW1lU3VtLmxlbmd0aCwgbiArIDEpXG4gICAgdGltZVN1bVswXSA9IDBcbiAgICBxdWVyeVB0clswXSA9IDBcblxuICAgIC8vIFVwZGF0ZSBhbGwgcGVuZGluZyB0aW1lciBxdWVyaWVzXG4gICAgdmFyIHF1ZXJ5VGltZSA9IDBcbiAgICBwdHIgPSAwXG4gICAgZm9yIChpID0gMDsgaSA8IHBlbmRpbmdRdWVyaWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgcXVlcnkgPSBwZW5kaW5nUXVlcmllc1tpXVxuICAgICAgaWYgKGV4dGVuc2lvbnMuZXh0X2Rpc2pvaW50X3RpbWVyX3F1ZXJ5LmdldFF1ZXJ5T2JqZWN0RVhUKHF1ZXJ5LCBHTF9RVUVSWV9SRVNVTFRfQVZBSUxBQkxFX0VYVCkpIHtcbiAgICAgICAgcXVlcnlUaW1lICs9IGV4dGVuc2lvbnMuZXh0X2Rpc2pvaW50X3RpbWVyX3F1ZXJ5LmdldFF1ZXJ5T2JqZWN0RVhUKHF1ZXJ5LCBHTF9RVUVSWV9SRVNVTFRfRVhUKVxuICAgICAgICBmcmVlUXVlcnkocXVlcnkpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwZW5kaW5nUXVlcmllc1twdHIrK10gPSBxdWVyeVxuICAgICAgfVxuICAgICAgdGltZVN1bVtpICsgMV0gPSBxdWVyeVRpbWVcbiAgICAgIHF1ZXJ5UHRyW2kgKyAxXSA9IHB0clxuICAgIH1cbiAgICBwZW5kaW5nUXVlcmllcy5sZW5ndGggPSBwdHJcblxuICAgIC8vIFVwZGF0ZSBhbGwgcGVuZGluZyBzdGF0IHF1ZXJpZXNcbiAgICBwdHIgPSAwXG4gICAgZm9yIChpID0gMDsgaSA8IHBlbmRpbmdTdGF0cy5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIHN0YXRzID0gcGVuZGluZ1N0YXRzW2ldXG4gICAgICB2YXIgc3RhcnQgPSBzdGF0cy5zdGFydFF1ZXJ5SW5kZXhcbiAgICAgIHZhciBlbmQgPSBzdGF0cy5lbmRRdWVyeUluZGV4XG4gICAgICBzdGF0cy5zdW0gKz0gdGltZVN1bVtlbmRdIC0gdGltZVN1bVtzdGFydF1cbiAgICAgIHZhciBzdGFydFB0ciA9IHF1ZXJ5UHRyW3N0YXJ0XVxuICAgICAgdmFyIGVuZFB0ciA9IHF1ZXJ5UHRyW2VuZF1cbiAgICAgIGlmIChlbmRQdHIgPT09IHN0YXJ0UHRyKSB7XG4gICAgICAgIHN0YXRzLnN0YXRzLmdwdVRpbWUgKz0gc3RhdHMuc3VtIC8gMWU2XG4gICAgICAgIGZyZWVQZW5kaW5nU3RhdHMoc3RhdHMpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0cy5zdGFydFF1ZXJ5SW5kZXggPSBzdGFydFB0clxuICAgICAgICBzdGF0cy5lbmRRdWVyeUluZGV4ID0gZW5kUHRyXG4gICAgICAgIHBlbmRpbmdTdGF0c1twdHIrK10gPSBzdGF0c1xuICAgICAgfVxuICAgIH1cbiAgICBwZW5kaW5nU3RhdHMubGVuZ3RoID0gcHRyXG4gIH1cblxuICByZXR1cm4ge1xuICAgIGJlZ2luUXVlcnk6IGJlZ2luUXVlcnksXG4gICAgZW5kUXVlcnk6IGVuZFF1ZXJ5LFxuICAgIHB1c2hTY29wZVN0YXRzOiBwdXNoU2NvcGVTdGF0cyxcbiAgICB1cGRhdGU6IHVwZGF0ZSxcbiAgICBnZXROdW1QZW5kaW5nUXVlcmllczogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHBlbmRpbmdRdWVyaWVzLmxlbmd0aFxuICAgIH0sXG4gICAgY2xlYXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHF1ZXJ5UG9vbC5wdXNoLmFwcGx5KHF1ZXJ5UG9vbCwgcGVuZGluZ1F1ZXJpZXMpXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHF1ZXJ5UG9vbC5sZW5ndGg7IGkrKykge1xuICAgICAgICBleHRlbnNpb25zLmV4dF9kaXNqb2ludF90aW1lcl9xdWVyeS5kZWxldGVRdWVyeUVYVChxdWVyeVBvb2xbaV0pXG4gICAgICB9XG4gICAgICBwZW5kaW5nUXVlcmllcy5sZW5ndGggPSAwXG4gICAgICBxdWVyeVBvb2wubGVuZ3RoID0gMFxuICAgIH0sXG4gICAgcmVzdG9yZTogZnVuY3Rpb24gKCkge1xuICAgICAgcGVuZGluZ1F1ZXJpZXMubGVuZ3RoID0gMFxuICAgICAgcXVlcnlQb29sLmxlbmd0aCA9IDBcbiAgICB9XG4gIH1cbn1cblxudmFyIEdMX0NPTE9SX0JVRkZFUl9CSVQgPSAxNjM4NFxudmFyIEdMX0RFUFRIX0JVRkZFUl9CSVQgPSAyNTZcbnZhciBHTF9TVEVOQ0lMX0JVRkZFUl9CSVQgPSAxMDI0XG5cbnZhciBHTF9BUlJBWV9CVUZGRVIgPSAzNDk2MlxuXG52YXIgQ09OVEVYVF9MT1NUX0VWRU5UID0gJ3dlYmdsY29udGV4dGxvc3QnXG52YXIgQ09OVEVYVF9SRVNUT1JFRF9FVkVOVCA9ICd3ZWJnbGNvbnRleHRyZXN0b3JlZCdcblxudmFyIERZTl9QUk9QID0gMVxudmFyIERZTl9DT05URVhUID0gMlxudmFyIERZTl9TVEFURSA9IDNcblxuZnVuY3Rpb24gZmluZCAoaGF5c3RhY2ssIG5lZWRsZSkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGhheXN0YWNrLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKGhheXN0YWNrW2ldID09PSBuZWVkbGUpIHtcbiAgICAgIHJldHVybiBpXG4gICAgfVxuICB9XG4gIHJldHVybiAtMVxufVxuXG5mdW5jdGlvbiB3cmFwUkVHTCAoYXJncykge1xuICB2YXIgY29uZmlnID0gcGFyc2VBcmdzKGFyZ3MpXG4gIGlmICghY29uZmlnKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIHZhciBnbCA9IGNvbmZpZy5nbFxuICB2YXIgZ2xBdHRyaWJ1dGVzID0gZ2wuZ2V0Q29udGV4dEF0dHJpYnV0ZXMoKVxuICB2YXIgY29udGV4dExvc3QgPSBnbC5pc0NvbnRleHRMb3N0KClcblxuICB2YXIgZXh0ZW5zaW9uU3RhdGUgPSBjcmVhdGVFeHRlbnNpb25DYWNoZShnbCwgY29uZmlnKVxuICBpZiAoIWV4dGVuc2lvblN0YXRlKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIHZhciBzdHJpbmdTdG9yZSA9IGNyZWF0ZVN0cmluZ1N0b3JlKClcbiAgdmFyIHN0YXRzJCQxID0gc3RhdHMoKVxuICB2YXIgZXh0ZW5zaW9ucyA9IGV4dGVuc2lvblN0YXRlLmV4dGVuc2lvbnNcbiAgdmFyIHRpbWVyID0gY3JlYXRlVGltZXIoZ2wsIGV4dGVuc2lvbnMpXG5cbiAgdmFyIFNUQVJUX1RJTUUgPSBjbG9jaygpXG4gIHZhciBXSURUSCA9IGdsLmRyYXdpbmdCdWZmZXJXaWR0aFxuICB2YXIgSEVJR0hUID0gZ2wuZHJhd2luZ0J1ZmZlckhlaWdodFxuXG4gIHZhciBjb250ZXh0U3RhdGUgPSB7XG4gICAgdGljazogMCxcbiAgICB0aW1lOiAwLFxuICAgIHZpZXdwb3J0V2lkdGg6IFdJRFRILFxuICAgIHZpZXdwb3J0SGVpZ2h0OiBIRUlHSFQsXG4gICAgZnJhbWVidWZmZXJXaWR0aDogV0lEVEgsXG4gICAgZnJhbWVidWZmZXJIZWlnaHQ6IEhFSUdIVCxcbiAgICBkcmF3aW5nQnVmZmVyV2lkdGg6IFdJRFRILFxuICAgIGRyYXdpbmdCdWZmZXJIZWlnaHQ6IEhFSUdIVCxcbiAgICBwaXhlbFJhdGlvOiBjb25maWcucGl4ZWxSYXRpb1xuICB9XG4gIHZhciB1bmlmb3JtU3RhdGUgPSB7fVxuICB2YXIgZHJhd1N0YXRlID0ge1xuICAgIGVsZW1lbnRzOiBudWxsLFxuICAgIHByaW1pdGl2ZTogNCwgLy8gR0xfVFJJQU5HTEVTXG4gICAgY291bnQ6IC0xLFxuICAgIG9mZnNldDogMCxcbiAgICBpbnN0YW5jZXM6IC0xXG4gIH1cblxuICB2YXIgbGltaXRzID0gd3JhcExpbWl0cyhnbCwgZXh0ZW5zaW9ucylcbiAgdmFyIGJ1ZmZlclN0YXRlID0gd3JhcEJ1ZmZlclN0YXRlKFxuICAgIGdsLFxuICAgIHN0YXRzJCQxLFxuICAgIGNvbmZpZyxcbiAgICBkZXN0cm95QnVmZmVyKVxuICB2YXIgYXR0cmlidXRlU3RhdGUgPSB3cmFwQXR0cmlidXRlU3RhdGUoXG4gICAgZ2wsXG4gICAgZXh0ZW5zaW9ucyxcbiAgICBsaW1pdHMsXG4gICAgc3RhdHMkJDEsXG4gICAgYnVmZmVyU3RhdGUpXG4gIGZ1bmN0aW9uIGRlc3Ryb3lCdWZmZXIgKGJ1ZmZlcikge1xuICAgIHJldHVybiBhdHRyaWJ1dGVTdGF0ZS5kZXN0cm95QnVmZmVyKGJ1ZmZlcilcbiAgfVxuICB2YXIgZWxlbWVudFN0YXRlID0gd3JhcEVsZW1lbnRzU3RhdGUoZ2wsIGV4dGVuc2lvbnMsIGJ1ZmZlclN0YXRlLCBzdGF0cyQkMSlcbiAgdmFyIHNoYWRlclN0YXRlID0gd3JhcFNoYWRlclN0YXRlKGdsLCBzdHJpbmdTdG9yZSwgc3RhdHMkJDEsIGNvbmZpZylcbiAgdmFyIHRleHR1cmVTdGF0ZSA9IGNyZWF0ZVRleHR1cmVTZXQoXG4gICAgZ2wsXG4gICAgZXh0ZW5zaW9ucyxcbiAgICBsaW1pdHMsXG4gICAgZnVuY3Rpb24gKCkgeyBjb3JlLnByb2NzLnBvbGwoKSB9LFxuICAgIGNvbnRleHRTdGF0ZSxcbiAgICBzdGF0cyQkMSxcbiAgICBjb25maWcpXG4gIHZhciByZW5kZXJidWZmZXJTdGF0ZSA9IHdyYXBSZW5kZXJidWZmZXJzKGdsLCBleHRlbnNpb25zLCBsaW1pdHMsIHN0YXRzJCQxLCBjb25maWcpXG4gIHZhciBmcmFtZWJ1ZmZlclN0YXRlID0gd3JhcEZCT1N0YXRlKFxuICAgIGdsLFxuICAgIGV4dGVuc2lvbnMsXG4gICAgbGltaXRzLFxuICAgIHRleHR1cmVTdGF0ZSxcbiAgICByZW5kZXJidWZmZXJTdGF0ZSxcbiAgICBzdGF0cyQkMSlcbiAgdmFyIGNvcmUgPSByZWdsQ29yZShcbiAgICBnbCxcbiAgICBzdHJpbmdTdG9yZSxcbiAgICBleHRlbnNpb25zLFxuICAgIGxpbWl0cyxcbiAgICBidWZmZXJTdGF0ZSxcbiAgICBlbGVtZW50U3RhdGUsXG4gICAgdGV4dHVyZVN0YXRlLFxuICAgIGZyYW1lYnVmZmVyU3RhdGUsXG4gICAgdW5pZm9ybVN0YXRlLFxuICAgIGF0dHJpYnV0ZVN0YXRlLFxuICAgIHNoYWRlclN0YXRlLFxuICAgIGRyYXdTdGF0ZSxcbiAgICBjb250ZXh0U3RhdGUsXG4gICAgdGltZXIsXG4gICAgY29uZmlnKVxuICB2YXIgcmVhZFBpeGVscyA9IHdyYXBSZWFkUGl4ZWxzKFxuICAgIGdsLFxuICAgIGZyYW1lYnVmZmVyU3RhdGUsXG4gICAgY29yZS5wcm9jcy5wb2xsLFxuICAgIGNvbnRleHRTdGF0ZSxcbiAgICBnbEF0dHJpYnV0ZXMsIGV4dGVuc2lvbnMsIGxpbWl0cylcblxuICB2YXIgbmV4dFN0YXRlID0gY29yZS5uZXh0XG4gIHZhciBjYW52YXMgPSBnbC5jYW52YXNcblxuICB2YXIgcmFmQ2FsbGJhY2tzID0gW11cbiAgdmFyIGxvc3NDYWxsYmFja3MgPSBbXVxuICB2YXIgcmVzdG9yZUNhbGxiYWNrcyA9IFtdXG4gIHZhciBkZXN0cm95Q2FsbGJhY2tzID0gW2NvbmZpZy5vbkRlc3Ryb3ldXG5cbiAgdmFyIGFjdGl2ZVJBRiA9IG51bGxcbiAgZnVuY3Rpb24gaGFuZGxlUkFGICgpIHtcbiAgICBpZiAocmFmQ2FsbGJhY2tzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgaWYgKHRpbWVyKSB7XG4gICAgICAgIHRpbWVyLnVwZGF0ZSgpXG4gICAgICB9XG4gICAgICBhY3RpdmVSQUYgPSBudWxsXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyBzY2hlZHVsZSBuZXh0IGFuaW1hdGlvbiBmcmFtZVxuICAgIGFjdGl2ZVJBRiA9IHJhZi5uZXh0KGhhbmRsZVJBRilcblxuICAgIC8vIHBvbGwgZm9yIGNoYW5nZXNcbiAgICBwb2xsKClcblxuICAgIC8vIGZpcmUgYSBjYWxsYmFjayBmb3IgYWxsIHBlbmRpbmcgcmFmc1xuICAgIGZvciAodmFyIGkgPSByYWZDYWxsYmFja3MubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIHZhciBjYiA9IHJhZkNhbGxiYWNrc1tpXVxuICAgICAgaWYgKGNiKSB7XG4gICAgICAgIGNiKGNvbnRleHRTdGF0ZSwgbnVsbCwgMClcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBmbHVzaCBhbGwgcGVuZGluZyB3ZWJnbCBjYWxsc1xuICAgIGdsLmZsdXNoKClcblxuICAgIC8vIHBvbGwgR1BVIHRpbWVycyAqYWZ0ZXIqIGdsLmZsdXNoIHNvIHdlIGRvbid0IGRlbGF5IGNvbW1hbmQgZGlzcGF0Y2hcbiAgICBpZiAodGltZXIpIHtcbiAgICAgIHRpbWVyLnVwZGF0ZSgpXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc3RhcnRSQUYgKCkge1xuICAgIGlmICghYWN0aXZlUkFGICYmIHJhZkNhbGxiYWNrcy5sZW5ndGggPiAwKSB7XG4gICAgICBhY3RpdmVSQUYgPSByYWYubmV4dChoYW5kbGVSQUYpXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc3RvcFJBRiAoKSB7XG4gICAgaWYgKGFjdGl2ZVJBRikge1xuICAgICAgcmFmLmNhbmNlbChoYW5kbGVSQUYpXG4gICAgICBhY3RpdmVSQUYgPSBudWxsXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlQ29udGV4dExvc3MgKGV2ZW50KSB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKVxuXG4gICAgLy8gc2V0IGNvbnRleHQgbG9zdCBmbGFnXG4gICAgY29udGV4dExvc3QgPSB0cnVlXG5cbiAgICAvLyBwYXVzZSByZXF1ZXN0IGFuaW1hdGlvbiBmcmFtZVxuICAgIHN0b3BSQUYoKVxuXG4gICAgLy8gbG9zZSBjb250ZXh0XG4gICAgbG9zc0NhbGxiYWNrcy5mb3JFYWNoKGZ1bmN0aW9uIChjYikge1xuICAgICAgY2IoKVxuICAgIH0pXG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVDb250ZXh0UmVzdG9yZWQgKGV2ZW50KSB7XG4gICAgLy8gY2xlYXIgZXJyb3IgY29kZVxuICAgIGdsLmdldEVycm9yKClcblxuICAgIC8vIGNsZWFyIGNvbnRleHQgbG9zdCBmbGFnXG4gICAgY29udGV4dExvc3QgPSBmYWxzZVxuXG4gICAgLy8gcmVmcmVzaCBzdGF0ZVxuICAgIGV4dGVuc2lvblN0YXRlLnJlc3RvcmUoKVxuICAgIHNoYWRlclN0YXRlLnJlc3RvcmUoKVxuICAgIGJ1ZmZlclN0YXRlLnJlc3RvcmUoKVxuICAgIHRleHR1cmVTdGF0ZS5yZXN0b3JlKClcbiAgICByZW5kZXJidWZmZXJTdGF0ZS5yZXN0b3JlKClcbiAgICBmcmFtZWJ1ZmZlclN0YXRlLnJlc3RvcmUoKVxuICAgIGF0dHJpYnV0ZVN0YXRlLnJlc3RvcmUoKVxuICAgIGlmICh0aW1lcikge1xuICAgICAgdGltZXIucmVzdG9yZSgpXG4gICAgfVxuXG4gICAgLy8gcmVmcmVzaCBzdGF0ZVxuICAgIGNvcmUucHJvY3MucmVmcmVzaCgpXG5cbiAgICAvLyByZXN0YXJ0IFJBRlxuICAgIHN0YXJ0UkFGKClcblxuICAgIC8vIHJlc3RvcmUgY29udGV4dFxuICAgIHJlc3RvcmVDYWxsYmFja3MuZm9yRWFjaChmdW5jdGlvbiAoY2IpIHtcbiAgICAgIGNiKClcbiAgICB9KVxuICB9XG5cbiAgaWYgKGNhbnZhcykge1xuICAgIGNhbnZhcy5hZGRFdmVudExpc3RlbmVyKENPTlRFWFRfTE9TVF9FVkVOVCwgaGFuZGxlQ29udGV4dExvc3MsIGZhbHNlKVxuICAgIGNhbnZhcy5hZGRFdmVudExpc3RlbmVyKENPTlRFWFRfUkVTVE9SRURfRVZFTlQsIGhhbmRsZUNvbnRleHRSZXN0b3JlZCwgZmFsc2UpXG4gIH1cblxuICBmdW5jdGlvbiBkZXN0cm95ICgpIHtcbiAgICByYWZDYWxsYmFja3MubGVuZ3RoID0gMFxuICAgIHN0b3BSQUYoKVxuXG4gICAgaWYgKGNhbnZhcykge1xuICAgICAgY2FudmFzLnJlbW92ZUV2ZW50TGlzdGVuZXIoQ09OVEVYVF9MT1NUX0VWRU5ULCBoYW5kbGVDb250ZXh0TG9zcylcbiAgICAgIGNhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKENPTlRFWFRfUkVTVE9SRURfRVZFTlQsIGhhbmRsZUNvbnRleHRSZXN0b3JlZClcbiAgICB9XG5cbiAgICBzaGFkZXJTdGF0ZS5jbGVhcigpXG4gICAgZnJhbWVidWZmZXJTdGF0ZS5jbGVhcigpXG4gICAgcmVuZGVyYnVmZmVyU3RhdGUuY2xlYXIoKVxuICAgIHRleHR1cmVTdGF0ZS5jbGVhcigpXG4gICAgZWxlbWVudFN0YXRlLmNsZWFyKClcbiAgICBidWZmZXJTdGF0ZS5jbGVhcigpXG4gICAgYXR0cmlidXRlU3RhdGUuY2xlYXIoKVxuXG4gICAgaWYgKHRpbWVyKSB7XG4gICAgICB0aW1lci5jbGVhcigpXG4gICAgfVxuXG4gICAgZGVzdHJveUNhbGxiYWNrcy5mb3JFYWNoKGZ1bmN0aW9uIChjYikge1xuICAgICAgY2IoKVxuICAgIH0pXG4gIH1cblxuICBmdW5jdGlvbiBjb21waWxlUHJvY2VkdXJlIChvcHRpb25zKSB7XG4gICAgY2hlY2skMSghIW9wdGlvbnMsICdpbnZhbGlkIGFyZ3MgdG8gcmVnbCh7Li4ufSknKVxuICAgIGNoZWNrJDEudHlwZShvcHRpb25zLCAnb2JqZWN0JywgJ2ludmFsaWQgYXJncyB0byByZWdsKHsuLi59KScpXG5cbiAgICBmdW5jdGlvbiBmbGF0dGVuTmVzdGVkT3B0aW9ucyAob3B0aW9ucykge1xuICAgICAgdmFyIHJlc3VsdCA9IGV4dGVuZCh7fSwgb3B0aW9ucylcbiAgICAgIGRlbGV0ZSByZXN1bHQudW5pZm9ybXNcbiAgICAgIGRlbGV0ZSByZXN1bHQuYXR0cmlidXRlc1xuICAgICAgZGVsZXRlIHJlc3VsdC5jb250ZXh0XG4gICAgICBkZWxldGUgcmVzdWx0LnZhb1xuXG4gICAgICBpZiAoJ3N0ZW5jaWwnIGluIHJlc3VsdCAmJiByZXN1bHQuc3RlbmNpbC5vcCkge1xuICAgICAgICByZXN1bHQuc3RlbmNpbC5vcEJhY2sgPSByZXN1bHQuc3RlbmNpbC5vcEZyb250ID0gcmVzdWx0LnN0ZW5jaWwub3BcbiAgICAgICAgZGVsZXRlIHJlc3VsdC5zdGVuY2lsLm9wXG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIG1lcmdlIChuYW1lKSB7XG4gICAgICAgIGlmIChuYW1lIGluIHJlc3VsdCkge1xuICAgICAgICAgIHZhciBjaGlsZCA9IHJlc3VsdFtuYW1lXVxuICAgICAgICAgIGRlbGV0ZSByZXN1bHRbbmFtZV1cbiAgICAgICAgICBPYmplY3Qua2V5cyhjaGlsZCkuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgICAgICAgICAgcmVzdWx0W25hbWUgKyAnLicgKyBwcm9wXSA9IGNoaWxkW3Byb3BdXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbWVyZ2UoJ2JsZW5kJylcbiAgICAgIG1lcmdlKCdkZXB0aCcpXG4gICAgICBtZXJnZSgnY3VsbCcpXG4gICAgICBtZXJnZSgnc3RlbmNpbCcpXG4gICAgICBtZXJnZSgncG9seWdvbk9mZnNldCcpXG4gICAgICBtZXJnZSgnc2Npc3NvcicpXG4gICAgICBtZXJnZSgnc2FtcGxlJylcblxuICAgICAgaWYgKCd2YW8nIGluIG9wdGlvbnMpIHtcbiAgICAgICAgcmVzdWx0LnZhbyA9IG9wdGlvbnMudmFvXG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHRcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXBhcmF0ZUR5bmFtaWMgKG9iamVjdCwgdXNlQXJyYXlzKSB7XG4gICAgICB2YXIgc3RhdGljSXRlbXMgPSB7fVxuICAgICAgdmFyIGR5bmFtaWNJdGVtcyA9IHt9XG4gICAgICBPYmplY3Qua2V5cyhvYmplY3QpLmZvckVhY2goZnVuY3Rpb24gKG9wdGlvbikge1xuICAgICAgICB2YXIgdmFsdWUgPSBvYmplY3Rbb3B0aW9uXVxuICAgICAgICBpZiAoZHluYW1pYy5pc0R5bmFtaWModmFsdWUpKSB7XG4gICAgICAgICAgZHluYW1pY0l0ZW1zW29wdGlvbl0gPSBkeW5hbWljLnVuYm94KHZhbHVlLCBvcHRpb24pXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH0gZWxzZSBpZiAodXNlQXJyYXlzICYmIEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgaWYgKGR5bmFtaWMuaXNEeW5hbWljKHZhbHVlW2ldKSkge1xuICAgICAgICAgICAgICBkeW5hbWljSXRlbXNbb3B0aW9uXSA9IGR5bmFtaWMudW5ib3godmFsdWUsIG9wdGlvbilcbiAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN0YXRpY0l0ZW1zW29wdGlvbl0gPSB2YWx1ZVxuICAgICAgfSlcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGR5bmFtaWM6IGR5bmFtaWNJdGVtcyxcbiAgICAgICAgc3RhdGljOiBzdGF0aWNJdGVtc1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRyZWF0IGNvbnRleHQgdmFyaWFibGVzIHNlcGFyYXRlIGZyb20gb3RoZXIgZHluYW1pYyB2YXJpYWJsZXNcbiAgICB2YXIgY29udGV4dCA9IHNlcGFyYXRlRHluYW1pYyhvcHRpb25zLmNvbnRleHQgfHwge30sIHRydWUpXG4gICAgdmFyIHVuaWZvcm1zID0gc2VwYXJhdGVEeW5hbWljKG9wdGlvbnMudW5pZm9ybXMgfHwge30sIHRydWUpXG4gICAgdmFyIGF0dHJpYnV0ZXMgPSBzZXBhcmF0ZUR5bmFtaWMob3B0aW9ucy5hdHRyaWJ1dGVzIHx8IHt9LCBmYWxzZSlcbiAgICB2YXIgb3B0cyA9IHNlcGFyYXRlRHluYW1pYyhmbGF0dGVuTmVzdGVkT3B0aW9ucyhvcHRpb25zKSwgZmFsc2UpXG5cbiAgICB2YXIgc3RhdHMkJDEgPSB7XG4gICAgICBncHVUaW1lOiAwLjAsXG4gICAgICBjcHVUaW1lOiAwLjAsXG4gICAgICBjb3VudDogMFxuICAgIH1cblxuICAgIHZhciBjb21waWxlZCA9IGNvcmUuY29tcGlsZShvcHRzLCBhdHRyaWJ1dGVzLCB1bmlmb3JtcywgY29udGV4dCwgc3RhdHMkJDEpXG5cbiAgICB2YXIgZHJhdyA9IGNvbXBpbGVkLmRyYXdcbiAgICB2YXIgYmF0Y2ggPSBjb21waWxlZC5iYXRjaFxuICAgIHZhciBzY29wZSA9IGNvbXBpbGVkLnNjb3BlXG5cbiAgICAvLyBGSVhNRTogd2Ugc2hvdWxkIG1vZGlmeSBjb2RlIGdlbmVyYXRpb24gZm9yIGJhdGNoIGNvbW1hbmRzIHNvIHRoaXNcbiAgICAvLyBpc24ndCBuZWNlc3NhcnlcbiAgICB2YXIgRU1QVFlfQVJSQVkgPSBbXVxuICAgIGZ1bmN0aW9uIHJlc2VydmUgKGNvdW50KSB7XG4gICAgICB3aGlsZSAoRU1QVFlfQVJSQVkubGVuZ3RoIDwgY291bnQpIHtcbiAgICAgICAgRU1QVFlfQVJSQVkucHVzaChudWxsKVxuICAgICAgfVxuICAgICAgcmV0dXJuIEVNUFRZX0FSUkFZXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gUkVHTENvbW1hbmQgKGFyZ3MsIGJvZHkpIHtcbiAgICAgIHZhciBpXG4gICAgICBpZiAoY29udGV4dExvc3QpIHtcbiAgICAgICAgY2hlY2skMS5yYWlzZSgnY29udGV4dCBsb3N0JylcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgYXJncyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gc2NvcGUuY2FsbCh0aGlzLCBudWxsLCBhcmdzLCAwKVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgYm9keSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBpZiAodHlwZW9mIGFyZ3MgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IGFyZ3M7ICsraSkge1xuICAgICAgICAgICAgc2NvcGUuY2FsbCh0aGlzLCBudWxsLCBib2R5LCBpKVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGFyZ3MpKSB7XG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHNjb3BlLmNhbGwodGhpcywgYXJnc1tpXSwgYm9keSwgaSlcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHNjb3BlLmNhbGwodGhpcywgYXJncywgYm9keSwgMClcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgYXJncyA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgaWYgKGFyZ3MgPiAwKSB7XG4gICAgICAgICAgcmV0dXJuIGJhdGNoLmNhbGwodGhpcywgcmVzZXJ2ZShhcmdzIHwgMCksIGFyZ3MgfCAwKVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoYXJncykpIHtcbiAgICAgICAgaWYgKGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIGJhdGNoLmNhbGwodGhpcywgYXJncywgYXJncy5sZW5ndGgpXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBkcmF3LmNhbGwodGhpcywgYXJncylcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZXh0ZW5kKFJFR0xDb21tYW5kLCB7XG4gICAgICBzdGF0czogc3RhdHMkJDEsXG4gICAgICBkZXN0cm95OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbXBpbGVkLmRlc3Ryb3koKVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICB2YXIgc2V0RkJPID0gZnJhbWVidWZmZXJTdGF0ZS5zZXRGQk8gPSBjb21waWxlUHJvY2VkdXJlKHtcbiAgICBmcmFtZWJ1ZmZlcjogZHluYW1pYy5kZWZpbmUuY2FsbChudWxsLCBEWU5fUFJPUCwgJ2ZyYW1lYnVmZmVyJylcbiAgfSlcblxuICBmdW5jdGlvbiBjbGVhckltcGwgKF8sIG9wdGlvbnMpIHtcbiAgICB2YXIgY2xlYXJGbGFncyA9IDBcbiAgICBjb3JlLnByb2NzLnBvbGwoKVxuXG4gICAgdmFyIGMgPSBvcHRpb25zLmNvbG9yXG4gICAgaWYgKGMpIHtcbiAgICAgIGdsLmNsZWFyQ29sb3IoK2NbMF0gfHwgMCwgK2NbMV0gfHwgMCwgK2NbMl0gfHwgMCwgK2NbM10gfHwgMClcbiAgICAgIGNsZWFyRmxhZ3MgfD0gR0xfQ09MT1JfQlVGRkVSX0JJVFxuICAgIH1cbiAgICBpZiAoJ2RlcHRoJyBpbiBvcHRpb25zKSB7XG4gICAgICBnbC5jbGVhckRlcHRoKCtvcHRpb25zLmRlcHRoKVxuICAgICAgY2xlYXJGbGFncyB8PSBHTF9ERVBUSF9CVUZGRVJfQklUXG4gICAgfVxuICAgIGlmICgnc3RlbmNpbCcgaW4gb3B0aW9ucykge1xuICAgICAgZ2wuY2xlYXJTdGVuY2lsKG9wdGlvbnMuc3RlbmNpbCB8IDApXG4gICAgICBjbGVhckZsYWdzIHw9IEdMX1NURU5DSUxfQlVGRkVSX0JJVFxuICAgIH1cblxuICAgIGNoZWNrJDEoISFjbGVhckZsYWdzLCAnY2FsbGVkIHJlZ2wuY2xlYXIgd2l0aCBubyBidWZmZXIgc3BlY2lmaWVkJylcbiAgICBnbC5jbGVhcihjbGVhckZsYWdzKVxuICB9XG5cbiAgZnVuY3Rpb24gY2xlYXIgKG9wdGlvbnMpIHtcbiAgICBjaGVjayQxKFxuICAgICAgdHlwZW9mIG9wdGlvbnMgPT09ICdvYmplY3QnICYmIG9wdGlvbnMsXG4gICAgICAncmVnbC5jbGVhcigpIHRha2VzIGFuIG9iamVjdCBhcyBpbnB1dCcpXG4gICAgaWYgKCdmcmFtZWJ1ZmZlcicgaW4gb3B0aW9ucykge1xuICAgICAgaWYgKG9wdGlvbnMuZnJhbWVidWZmZXIgJiZcbiAgICAgICAgICBvcHRpb25zLmZyYW1lYnVmZmVyX3JlZ2xUeXBlID09PSAnZnJhbWVidWZmZXJDdWJlJykge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDY7ICsraSkge1xuICAgICAgICAgIHNldEZCTyhleHRlbmQoe1xuICAgICAgICAgICAgZnJhbWVidWZmZXI6IG9wdGlvbnMuZnJhbWVidWZmZXIuZmFjZXNbaV1cbiAgICAgICAgICB9LCBvcHRpb25zKSwgY2xlYXJJbXBsKVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXRGQk8ob3B0aW9ucywgY2xlYXJJbXBsKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjbGVhckltcGwobnVsbCwgb3B0aW9ucylcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBmcmFtZSAoY2IpIHtcbiAgICBjaGVjayQxLnR5cGUoY2IsICdmdW5jdGlvbicsICdyZWdsLmZyYW1lKCkgY2FsbGJhY2sgbXVzdCBiZSBhIGZ1bmN0aW9uJylcbiAgICByYWZDYWxsYmFja3MucHVzaChjYilcblxuICAgIGZ1bmN0aW9uIGNhbmNlbCAoKSB7XG4gICAgICAvLyBGSVhNRTogIHNob3VsZCB3ZSBjaGVjayBzb21ldGhpbmcgb3RoZXIgdGhhbiBlcXVhbHMgY2IgaGVyZT9cbiAgICAgIC8vIHdoYXQgaWYgYSB1c2VyIGNhbGxzIGZyYW1lIHR3aWNlIHdpdGggdGhlIHNhbWUgY2FsbGJhY2suLi5cbiAgICAgIC8vXG4gICAgICB2YXIgaSA9IGZpbmQocmFmQ2FsbGJhY2tzLCBjYilcbiAgICAgIGNoZWNrJDEoaSA+PSAwLCAnY2Fubm90IGNhbmNlbCBhIGZyYW1lIHR3aWNlJylcbiAgICAgIGZ1bmN0aW9uIHBlbmRpbmdDYW5jZWwgKCkge1xuICAgICAgICB2YXIgaW5kZXggPSBmaW5kKHJhZkNhbGxiYWNrcywgcGVuZGluZ0NhbmNlbClcbiAgICAgICAgcmFmQ2FsbGJhY2tzW2luZGV4XSA9IHJhZkNhbGxiYWNrc1tyYWZDYWxsYmFja3MubGVuZ3RoIC0gMV1cbiAgICAgICAgcmFmQ2FsbGJhY2tzLmxlbmd0aCAtPSAxXG4gICAgICAgIGlmIChyYWZDYWxsYmFja3MubGVuZ3RoIDw9IDApIHtcbiAgICAgICAgICBzdG9wUkFGKClcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmFmQ2FsbGJhY2tzW2ldID0gcGVuZGluZ0NhbmNlbFxuICAgIH1cblxuICAgIHN0YXJ0UkFGKClcblxuICAgIHJldHVybiB7XG4gICAgICBjYW5jZWw6IGNhbmNlbFxuICAgIH1cbiAgfVxuXG4gIC8vIHBvbGwgdmlld3BvcnRcbiAgZnVuY3Rpb24gcG9sbFZpZXdwb3J0ICgpIHtcbiAgICB2YXIgdmlld3BvcnQgPSBuZXh0U3RhdGUudmlld3BvcnRcbiAgICB2YXIgc2Npc3NvckJveCA9IG5leHRTdGF0ZS5zY2lzc29yX2JveFxuICAgIHZpZXdwb3J0WzBdID0gdmlld3BvcnRbMV0gPSBzY2lzc29yQm94WzBdID0gc2Npc3NvckJveFsxXSA9IDBcbiAgICBjb250ZXh0U3RhdGUudmlld3BvcnRXaWR0aCA9XG4gICAgICBjb250ZXh0U3RhdGUuZnJhbWVidWZmZXJXaWR0aCA9XG4gICAgICBjb250ZXh0U3RhdGUuZHJhd2luZ0J1ZmZlcldpZHRoID1cbiAgICAgIHZpZXdwb3J0WzJdID1cbiAgICAgIHNjaXNzb3JCb3hbMl0gPSBnbC5kcmF3aW5nQnVmZmVyV2lkdGhcbiAgICBjb250ZXh0U3RhdGUudmlld3BvcnRIZWlnaHQgPVxuICAgICAgY29udGV4dFN0YXRlLmZyYW1lYnVmZmVySGVpZ2h0ID1cbiAgICAgIGNvbnRleHRTdGF0ZS5kcmF3aW5nQnVmZmVySGVpZ2h0ID1cbiAgICAgIHZpZXdwb3J0WzNdID1cbiAgICAgIHNjaXNzb3JCb3hbM10gPSBnbC5kcmF3aW5nQnVmZmVySGVpZ2h0XG4gIH1cblxuICBmdW5jdGlvbiBwb2xsICgpIHtcbiAgICBjb250ZXh0U3RhdGUudGljayArPSAxXG4gICAgY29udGV4dFN0YXRlLnRpbWUgPSBub3coKVxuICAgIHBvbGxWaWV3cG9ydCgpXG4gICAgY29yZS5wcm9jcy5wb2xsKClcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlZnJlc2ggKCkge1xuICAgIHRleHR1cmVTdGF0ZS5yZWZyZXNoKClcbiAgICBwb2xsVmlld3BvcnQoKVxuICAgIGNvcmUucHJvY3MucmVmcmVzaCgpXG4gICAgaWYgKHRpbWVyKSB7XG4gICAgICB0aW1lci51cGRhdGUoKVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG5vdyAoKSB7XG4gICAgcmV0dXJuIChjbG9jaygpIC0gU1RBUlRfVElNRSkgLyAxMDAwLjBcbiAgfVxuXG4gIHJlZnJlc2goKVxuXG4gIGZ1bmN0aW9uIGFkZExpc3RlbmVyIChldmVudCwgY2FsbGJhY2spIHtcbiAgICBjaGVjayQxLnR5cGUoY2FsbGJhY2ssICdmdW5jdGlvbicsICdsaXN0ZW5lciBjYWxsYmFjayBtdXN0IGJlIGEgZnVuY3Rpb24nKVxuXG4gICAgdmFyIGNhbGxiYWNrc1xuICAgIHN3aXRjaCAoZXZlbnQpIHtcbiAgICAgIGNhc2UgJ2ZyYW1lJzpcbiAgICAgICAgcmV0dXJuIGZyYW1lKGNhbGxiYWNrKVxuICAgICAgY2FzZSAnbG9zdCc6XG4gICAgICAgIGNhbGxiYWNrcyA9IGxvc3NDYWxsYmFja3NcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ3Jlc3RvcmUnOlxuICAgICAgICBjYWxsYmFja3MgPSByZXN0b3JlQ2FsbGJhY2tzXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlICdkZXN0cm95JzpcbiAgICAgICAgY2FsbGJhY2tzID0gZGVzdHJveUNhbGxiYWNrc1xuICAgICAgICBicmVha1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgY2hlY2skMS5yYWlzZSgnaW52YWxpZCBldmVudCwgbXVzdCBiZSBvbmUgb2YgZnJhbWUsbG9zdCxyZXN0b3JlLGRlc3Ryb3knKVxuICAgIH1cblxuICAgIGNhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKVxuICAgIHJldHVybiB7XG4gICAgICBjYW5jZWw6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYWxsYmFja3MubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBpZiAoY2FsbGJhY2tzW2ldID09PSBjYWxsYmFjaykge1xuICAgICAgICAgICAgY2FsbGJhY2tzW2ldID0gY2FsbGJhY2tzW2NhbGxiYWNrcy5sZW5ndGggLSAxXVxuICAgICAgICAgICAgY2FsbGJhY2tzLnBvcCgpXG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgcmVnbCA9IGV4dGVuZChjb21waWxlUHJvY2VkdXJlLCB7XG4gICAgLy8gQ2xlYXIgY3VycmVudCBGQk9cbiAgICBjbGVhcjogY2xlYXIsXG5cbiAgICAvLyBTaG9ydCBjdXRzIGZvciBkeW5hbWljIHZhcmlhYmxlc1xuICAgIHByb3A6IGR5bmFtaWMuZGVmaW5lLmJpbmQobnVsbCwgRFlOX1BST1ApLFxuICAgIGNvbnRleHQ6IGR5bmFtaWMuZGVmaW5lLmJpbmQobnVsbCwgRFlOX0NPTlRFWFQpLFxuICAgIHRoaXM6IGR5bmFtaWMuZGVmaW5lLmJpbmQobnVsbCwgRFlOX1NUQVRFKSxcblxuICAgIC8vIGV4ZWN1dGVzIGFuIGVtcHR5IGRyYXcgY29tbWFuZFxuICAgIGRyYXc6IGNvbXBpbGVQcm9jZWR1cmUoe30pLFxuXG4gICAgLy8gUmVzb3VyY2VzXG4gICAgYnVmZmVyOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgcmV0dXJuIGJ1ZmZlclN0YXRlLmNyZWF0ZShvcHRpb25zLCBHTF9BUlJBWV9CVUZGRVIsIGZhbHNlLCBmYWxzZSlcbiAgICB9LFxuICAgIGVsZW1lbnRzOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgcmV0dXJuIGVsZW1lbnRTdGF0ZS5jcmVhdGUob3B0aW9ucywgZmFsc2UpXG4gICAgfSxcbiAgICB0ZXh0dXJlOiB0ZXh0dXJlU3RhdGUuY3JlYXRlMkQsXG4gICAgY3ViZTogdGV4dHVyZVN0YXRlLmNyZWF0ZUN1YmUsXG4gICAgcmVuZGVyYnVmZmVyOiByZW5kZXJidWZmZXJTdGF0ZS5jcmVhdGUsXG4gICAgZnJhbWVidWZmZXI6IGZyYW1lYnVmZmVyU3RhdGUuY3JlYXRlLFxuICAgIGZyYW1lYnVmZmVyQ3ViZTogZnJhbWVidWZmZXJTdGF0ZS5jcmVhdGVDdWJlLFxuICAgIHZhbzogYXR0cmlidXRlU3RhdGUuY3JlYXRlVkFPLFxuXG4gICAgLy8gRXhwb3NlIGNvbnRleHQgYXR0cmlidXRlc1xuICAgIGF0dHJpYnV0ZXM6IGdsQXR0cmlidXRlcyxcblxuICAgIC8vIEZyYW1lIHJlbmRlcmluZ1xuICAgIGZyYW1lOiBmcmFtZSxcbiAgICBvbjogYWRkTGlzdGVuZXIsXG5cbiAgICAvLyBTeXN0ZW0gbGltaXRzXG4gICAgbGltaXRzOiBsaW1pdHMsXG4gICAgaGFzRXh0ZW5zaW9uOiBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgcmV0dXJuIGxpbWl0cy5leHRlbnNpb25zLmluZGV4T2YobmFtZS50b0xvd2VyQ2FzZSgpKSA+PSAwXG4gICAgfSxcblxuICAgIC8vIFJlYWQgcGl4ZWxzXG4gICAgcmVhZDogcmVhZFBpeGVscyxcblxuICAgIC8vIERlc3Ryb3kgcmVnbCBhbmQgYWxsIGFzc29jaWF0ZWQgcmVzb3VyY2VzXG4gICAgZGVzdHJveTogZGVzdHJveSxcblxuICAgIC8vIERpcmVjdCBHTCBzdGF0ZSBtYW5pcHVsYXRpb25cbiAgICBfZ2w6IGdsLFxuICAgIF9yZWZyZXNoOiByZWZyZXNoLFxuXG4gICAgcG9sbDogZnVuY3Rpb24gKCkge1xuICAgICAgcG9sbCgpXG4gICAgICBpZiAodGltZXIpIHtcbiAgICAgICAgdGltZXIudXBkYXRlKClcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8gQ3VycmVudCB0aW1lXG4gICAgbm93OiBub3csXG5cbiAgICAvLyByZWdsIFN0YXRpc3RpY3MgSW5mb3JtYXRpb25cbiAgICBzdGF0czogc3RhdHMkJDFcbiAgfSlcblxuICBjb25maWcub25Eb25lKG51bGwsIHJlZ2wpXG5cbiAgcmV0dXJuIHJlZ2xcbn1cblxucmV0dXJuIHdyYXBSRUdMO1xuXG59KSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVnbC5qcy5tYXBcbiIsIm1vZHVsZS5leHBvcnRzID1cbiAgZ2xvYmFsLnBlcmZvcm1hbmNlICYmXG4gIGdsb2JhbC5wZXJmb3JtYW5jZS5ub3cgPyBmdW5jdGlvbiBub3coKSB7XG4gICAgcmV0dXJuIHBlcmZvcm1hbmNlLm5vdygpXG4gIH0gOiBEYXRlLm5vdyB8fCBmdW5jdGlvbiBub3coKSB7XG4gICAgcmV0dXJuICtuZXcgRGF0ZVxuICB9XG4iLCJcInVzZSBzdHJpY3RcIlxuXG52YXIgdHdvUHJvZHVjdCA9IHJlcXVpcmUoXCJ0d28tcHJvZHVjdFwiKVxudmFyIHJvYnVzdFN1bSA9IHJlcXVpcmUoXCJyb2J1c3Qtc3VtXCIpXG52YXIgcm9idXN0RGlmZiA9IHJlcXVpcmUoXCJyb2J1c3Qtc3VidHJhY3RcIilcbnZhciByb2J1c3RTY2FsZSA9IHJlcXVpcmUoXCJyb2J1c3Qtc2NhbGVcIilcblxudmFyIE5VTV9FWFBBTkQgPSA2XG5cbmZ1bmN0aW9uIG9yaWVudGF0aW9uKG4pIHtcbiAgdmFyIGZuID1cbiAgICBuID09PSAzID8gaW5TcGhlcmUzIDpcbiAgICBuID09PSA0ID8gaW5TcGhlcmU0IDpcbiAgICBuID09PSA1ID8gaW5TcGhlcmU1IDogaW5TcGhlcmU2O1xuXG4gIHJldHVybiBmbihyb2J1c3RTdW0sIHJvYnVzdERpZmYsIHR3b1Byb2R1Y3QsIHJvYnVzdFNjYWxlKVxufVxuXG5mdW5jdGlvbiBpblNwaGVyZTAoKSB7IHJldHVybiAwIH1cbmZ1bmN0aW9uIGluU3BoZXJlMSgpIHsgcmV0dXJuIDAgfVxuZnVuY3Rpb24gaW5TcGhlcmUyKCkgeyByZXR1cm4gMCB9XG5cbmZ1bmN0aW9uIGluU3BoZXJlMyhzdW0sIGRpZmYsIHByb2QsIHNjYWxlKSB7XG4gIGZ1bmN0aW9uIGV4YWN0SW5TcGhlcmUzKG0wLCBtMSwgbTIpIHtcbiAgICB2YXIgdzAgPSBwcm9kKG0wWzBdLCBtMFswXSlcbiAgICB2YXIgdzBtMSA9IHNjYWxlKHcwLCBtMVswXSlcbiAgICB2YXIgdzBtMiA9IHNjYWxlKHcwLCBtMlswXSlcbiAgICB2YXIgdzEgPSBwcm9kKG0xWzBdLCBtMVswXSlcbiAgICB2YXIgdzFtMCA9IHNjYWxlKHcxLCBtMFswXSlcbiAgICB2YXIgdzFtMiA9IHNjYWxlKHcxLCBtMlswXSlcbiAgICB2YXIgdzIgPSBwcm9kKG0yWzBdLCBtMlswXSlcbiAgICB2YXIgdzJtMCA9IHNjYWxlKHcyLCBtMFswXSlcbiAgICB2YXIgdzJtMSA9IHNjYWxlKHcyLCBtMVswXSlcbiAgICB2YXIgcCA9IHN1bShkaWZmKHcybTEsIHcxbTIpLCBkaWZmKHcxbTAsIHcwbTEpKVxuICAgIHZhciBuID0gZGlmZih3Mm0wLCB3MG0yKVxuICAgIHZhciBkID0gZGlmZihwLCBuKVxuICAgIHJldHVybiBkW2QubGVuZ3RoIC0gMV1cbiAgfVxuICByZXR1cm4gZXhhY3RJblNwaGVyZTNcbn1cblxuZnVuY3Rpb24gaW5TcGhlcmU0KHN1bSwgZGlmZiwgcHJvZCwgc2NhbGUpIHtcbiAgZnVuY3Rpb24gZXhhY3RJblNwaGVyZTQobTAsIG0xLCBtMiwgbTMpIHtcbiAgICB2YXIgdzAgPSBzdW0ocHJvZChtMFswXSwgbTBbMF0pLCBwcm9kKG0wWzFdLCBtMFsxXSkpXG4gICAgdmFyIHcwbTEgPSBzY2FsZSh3MCwgbTFbMF0pXG4gICAgdmFyIHcwbTIgPSBzY2FsZSh3MCwgbTJbMF0pXG4gICAgdmFyIHcwbTMgPSBzY2FsZSh3MCwgbTNbMF0pXG4gICAgdmFyIHcxID0gc3VtKHByb2QobTFbMF0sIG0xWzBdKSwgcHJvZChtMVsxXSwgbTFbMV0pKVxuICAgIHZhciB3MW0wID0gc2NhbGUodzEsIG0wWzBdKVxuICAgIHZhciB3MW0yID0gc2NhbGUodzEsIG0yWzBdKVxuICAgIHZhciB3MW0zID0gc2NhbGUodzEsIG0zWzBdKVxuICAgIHZhciB3MiA9IHN1bShwcm9kKG0yWzBdLCBtMlswXSksIHByb2QobTJbMV0sIG0yWzFdKSlcbiAgICB2YXIgdzJtMCA9IHNjYWxlKHcyLCBtMFswXSlcbiAgICB2YXIgdzJtMSA9IHNjYWxlKHcyLCBtMVswXSlcbiAgICB2YXIgdzJtMyA9IHNjYWxlKHcyLCBtM1swXSlcbiAgICB2YXIgdzMgPSBzdW0ocHJvZChtM1swXSwgbTNbMF0pLCBwcm9kKG0zWzFdLCBtM1sxXSkpXG4gICAgdmFyIHczbTAgPSBzY2FsZSh3MywgbTBbMF0pXG4gICAgdmFyIHczbTEgPSBzY2FsZSh3MywgbTFbMF0pXG4gICAgdmFyIHczbTIgPSBzY2FsZSh3MywgbTJbMF0pXG4gICAgdmFyIHAgPSBzdW0oc3VtKHNjYWxlKGRpZmYodzNtMiwgdzJtMyksIG0xWzFdKSwgc3VtKHNjYWxlKGRpZmYodzNtMSwgdzFtMyksIC1tMlsxXSksIHNjYWxlKGRpZmYodzJtMSwgdzFtMiksIG0zWzFdKSkpLCBzdW0oc2NhbGUoZGlmZih3M20xLCB3MW0zKSwgbTBbMV0pLCBzdW0oc2NhbGUoZGlmZih3M20wLCB3MG0zKSwgLW0xWzFdKSwgc2NhbGUoZGlmZih3MW0wLCB3MG0xKSwgbTNbMV0pKSkpXG4gICAgdmFyIG4gPSBzdW0oc3VtKHNjYWxlKGRpZmYodzNtMiwgdzJtMyksIG0wWzFdKSwgc3VtKHNjYWxlKGRpZmYodzNtMCwgdzBtMyksIC1tMlsxXSksIHNjYWxlKGRpZmYodzJtMCwgdzBtMiksIG0zWzFdKSkpLCBzdW0oc2NhbGUoZGlmZih3Mm0xLCB3MW0yKSwgbTBbMV0pLCBzdW0oc2NhbGUoZGlmZih3Mm0wLCB3MG0yKSwgLW0xWzFdKSwgc2NhbGUoZGlmZih3MW0wLCB3MG0xKSwgbTJbMV0pKSkpXG4gICAgdmFyIGQgPSBkaWZmKHAsIG4pXG4gICAgcmV0dXJuIGRbZC5sZW5ndGggLSAxXVxuICB9XG4gIHJldHVybiBleGFjdEluU3BoZXJlNFxufVxuXG5cbmZ1bmN0aW9uIGluU3BoZXJlNShzdW0sIGRpZmYsIHByb2QsIHNjYWxlKSB7XG4gIGZ1bmN0aW9uIGV4YWN0SW5TcGhlcmU1KG0wLCBtMSwgbTIsIG0zLCBtNCkge1xuICAgIHZhciB3MCA9IHN1bShwcm9kKG0wWzBdLCBtMFswXSksIHN1bShwcm9kKG0wWzFdLCBtMFsxXSksIHByb2QobTBbMl0sIG0wWzJdKSkpXG4gICAgdmFyIHcwbTEgPSBzY2FsZSh3MCwgbTFbMF0pXG4gICAgdmFyIHcwbTIgPSBzY2FsZSh3MCwgbTJbMF0pXG4gICAgdmFyIHcwbTMgPSBzY2FsZSh3MCwgbTNbMF0pXG4gICAgdmFyIHcwbTQgPSBzY2FsZSh3MCwgbTRbMF0pXG4gICAgdmFyIHcxID0gc3VtKHByb2QobTFbMF0sIG0xWzBdKSwgc3VtKHByb2QobTFbMV0sIG0xWzFdKSwgcHJvZChtMVsyXSwgbTFbMl0pKSlcbiAgICB2YXIgdzFtMCA9IHNjYWxlKHcxLCBtMFswXSlcbiAgICB2YXIgdzFtMiA9IHNjYWxlKHcxLCBtMlswXSlcbiAgICB2YXIgdzFtMyA9IHNjYWxlKHcxLCBtM1swXSlcbiAgICB2YXIgdzFtNCA9IHNjYWxlKHcxLCBtNFswXSlcbiAgICB2YXIgdzIgPSBzdW0ocHJvZChtMlswXSwgbTJbMF0pLCBzdW0ocHJvZChtMlsxXSwgbTJbMV0pLCBwcm9kKG0yWzJdLCBtMlsyXSkpKVxuICAgIHZhciB3Mm0wID0gc2NhbGUodzIsIG0wWzBdKVxuICAgIHZhciB3Mm0xID0gc2NhbGUodzIsIG0xWzBdKVxuICAgIHZhciB3Mm0zID0gc2NhbGUodzIsIG0zWzBdKVxuICAgIHZhciB3Mm00ID0gc2NhbGUodzIsIG00WzBdKVxuICAgIHZhciB3MyA9IHN1bShwcm9kKG0zWzBdLCBtM1swXSksIHN1bShwcm9kKG0zWzFdLCBtM1sxXSksIHByb2QobTNbMl0sIG0zWzJdKSkpXG4gICAgdmFyIHczbTAgPSBzY2FsZSh3MywgbTBbMF0pXG4gICAgdmFyIHczbTEgPSBzY2FsZSh3MywgbTFbMF0pXG4gICAgdmFyIHczbTIgPSBzY2FsZSh3MywgbTJbMF0pXG4gICAgdmFyIHczbTQgPSBzY2FsZSh3MywgbTRbMF0pXG4gICAgdmFyIHc0ID0gc3VtKHByb2QobTRbMF0sIG00WzBdKSwgc3VtKHByb2QobTRbMV0sIG00WzFdKSwgcHJvZChtNFsyXSwgbTRbMl0pKSlcbiAgICB2YXIgdzRtMCA9IHNjYWxlKHc0LCBtMFswXSlcbiAgICB2YXIgdzRtMSA9IHNjYWxlKHc0LCBtMVswXSlcbiAgICB2YXIgdzRtMiA9IHNjYWxlKHc0LCBtMlswXSlcbiAgICB2YXIgdzRtMyA9IHNjYWxlKHc0LCBtM1swXSlcbiAgICB2YXIgcCA9IHN1bShzdW0oc3VtKHNjYWxlKHN1bShzY2FsZShkaWZmKHc0bTMsIHczbTQpLCBtMlsxXSksIHN1bShzY2FsZShkaWZmKHc0bTIsIHcybTQpLCAtbTNbMV0pLCBzY2FsZShkaWZmKHczbTIsIHcybTMpLCBtNFsxXSkpKSwgbTFbMl0pLCBzdW0oc2NhbGUoc3VtKHNjYWxlKGRpZmYodzRtMywgdzNtNCksIG0xWzFdKSwgc3VtKHNjYWxlKGRpZmYodzRtMSwgdzFtNCksIC1tM1sxXSksIHNjYWxlKGRpZmYodzNtMSwgdzFtMyksIG00WzFdKSkpLCAtbTJbMl0pLCBzY2FsZShzdW0oc2NhbGUoZGlmZih3NG0yLCB3Mm00KSwgbTFbMV0pLCBzdW0oc2NhbGUoZGlmZih3NG0xLCB3MW00KSwgLW0yWzFdKSwgc2NhbGUoZGlmZih3Mm0xLCB3MW0yKSwgbTRbMV0pKSksIG0zWzJdKSkpLCBzdW0oc2NhbGUoc3VtKHNjYWxlKGRpZmYodzNtMiwgdzJtMyksIG0xWzFdKSwgc3VtKHNjYWxlKGRpZmYodzNtMSwgdzFtMyksIC1tMlsxXSksIHNjYWxlKGRpZmYodzJtMSwgdzFtMiksIG0zWzFdKSkpLCAtbTRbMl0pLCBzdW0oc2NhbGUoc3VtKHNjYWxlKGRpZmYodzRtMywgdzNtNCksIG0xWzFdKSwgc3VtKHNjYWxlKGRpZmYodzRtMSwgdzFtNCksIC1tM1sxXSksIHNjYWxlKGRpZmYodzNtMSwgdzFtMyksIG00WzFdKSkpLCBtMFsyXSksIHNjYWxlKHN1bShzY2FsZShkaWZmKHc0bTMsIHczbTQpLCBtMFsxXSksIHN1bShzY2FsZShkaWZmKHc0bTAsIHcwbTQpLCAtbTNbMV0pLCBzY2FsZShkaWZmKHczbTAsIHcwbTMpLCBtNFsxXSkpKSwgLW0xWzJdKSkpKSwgc3VtKHN1bShzY2FsZShzdW0oc2NhbGUoZGlmZih3NG0xLCB3MW00KSwgbTBbMV0pLCBzdW0oc2NhbGUoZGlmZih3NG0wLCB3MG00KSwgLW0xWzFdKSwgc2NhbGUoZGlmZih3MW0wLCB3MG0xKSwgbTRbMV0pKSksIG0zWzJdKSwgc3VtKHNjYWxlKHN1bShzY2FsZShkaWZmKHczbTEsIHcxbTMpLCBtMFsxXSksIHN1bShzY2FsZShkaWZmKHczbTAsIHcwbTMpLCAtbTFbMV0pLCBzY2FsZShkaWZmKHcxbTAsIHcwbTEpLCBtM1sxXSkpKSwgLW00WzJdKSwgc2NhbGUoc3VtKHNjYWxlKGRpZmYodzNtMiwgdzJtMyksIG0xWzFdKSwgc3VtKHNjYWxlKGRpZmYodzNtMSwgdzFtMyksIC1tMlsxXSksIHNjYWxlKGRpZmYodzJtMSwgdzFtMiksIG0zWzFdKSkpLCBtMFsyXSkpKSwgc3VtKHNjYWxlKHN1bShzY2FsZShkaWZmKHczbTIsIHcybTMpLCBtMFsxXSksIHN1bShzY2FsZShkaWZmKHczbTAsIHcwbTMpLCAtbTJbMV0pLCBzY2FsZShkaWZmKHcybTAsIHcwbTIpLCBtM1sxXSkpKSwgLW0xWzJdKSwgc3VtKHNjYWxlKHN1bShzY2FsZShkaWZmKHczbTEsIHcxbTMpLCBtMFsxXSksIHN1bShzY2FsZShkaWZmKHczbTAsIHcwbTMpLCAtbTFbMV0pLCBzY2FsZShkaWZmKHcxbTAsIHcwbTEpLCBtM1sxXSkpKSwgbTJbMl0pLCBzY2FsZShzdW0oc2NhbGUoZGlmZih3Mm0xLCB3MW0yKSwgbTBbMV0pLCBzdW0oc2NhbGUoZGlmZih3Mm0wLCB3MG0yKSwgLW0xWzFdKSwgc2NhbGUoZGlmZih3MW0wLCB3MG0xKSwgbTJbMV0pKSksIC1tM1syXSkpKSkpXG4gICAgdmFyIG4gPSBzdW0oc3VtKHN1bShzY2FsZShzdW0oc2NhbGUoZGlmZih3NG0zLCB3M200KSwgbTJbMV0pLCBzdW0oc2NhbGUoZGlmZih3NG0yLCB3Mm00KSwgLW0zWzFdKSwgc2NhbGUoZGlmZih3M20yLCB3Mm0zKSwgbTRbMV0pKSksIG0wWzJdKSwgc2NhbGUoc3VtKHNjYWxlKGRpZmYodzRtMywgdzNtNCksIG0wWzFdKSwgc3VtKHNjYWxlKGRpZmYodzRtMCwgdzBtNCksIC1tM1sxXSksIHNjYWxlKGRpZmYodzNtMCwgdzBtMyksIG00WzFdKSkpLCAtbTJbMl0pKSwgc3VtKHNjYWxlKHN1bShzY2FsZShkaWZmKHc0bTIsIHcybTQpLCBtMFsxXSksIHN1bShzY2FsZShkaWZmKHc0bTAsIHcwbTQpLCAtbTJbMV0pLCBzY2FsZShkaWZmKHcybTAsIHcwbTIpLCBtNFsxXSkpKSwgbTNbMl0pLCBzY2FsZShzdW0oc2NhbGUoZGlmZih3M20yLCB3Mm0zKSwgbTBbMV0pLCBzdW0oc2NhbGUoZGlmZih3M20wLCB3MG0zKSwgLW0yWzFdKSwgc2NhbGUoZGlmZih3Mm0wLCB3MG0yKSwgbTNbMV0pKSksIC1tNFsyXSkpKSwgc3VtKHN1bShzY2FsZShzdW0oc2NhbGUoZGlmZih3NG0yLCB3Mm00KSwgbTFbMV0pLCBzdW0oc2NhbGUoZGlmZih3NG0xLCB3MW00KSwgLW0yWzFdKSwgc2NhbGUoZGlmZih3Mm0xLCB3MW0yKSwgbTRbMV0pKSksIG0wWzJdKSwgc2NhbGUoc3VtKHNjYWxlKGRpZmYodzRtMiwgdzJtNCksIG0wWzFdKSwgc3VtKHNjYWxlKGRpZmYodzRtMCwgdzBtNCksIC1tMlsxXSksIHNjYWxlKGRpZmYodzJtMCwgdzBtMiksIG00WzFdKSkpLCAtbTFbMl0pKSwgc3VtKHNjYWxlKHN1bShzY2FsZShkaWZmKHc0bTEsIHcxbTQpLCBtMFsxXSksIHN1bShzY2FsZShkaWZmKHc0bTAsIHcwbTQpLCAtbTFbMV0pLCBzY2FsZShkaWZmKHcxbTAsIHcwbTEpLCBtNFsxXSkpKSwgbTJbMl0pLCBzY2FsZShzdW0oc2NhbGUoZGlmZih3Mm0xLCB3MW0yKSwgbTBbMV0pLCBzdW0oc2NhbGUoZGlmZih3Mm0wLCB3MG0yKSwgLW0xWzFdKSwgc2NhbGUoZGlmZih3MW0wLCB3MG0xKSwgbTJbMV0pKSksIC1tNFsyXSkpKSlcbiAgICB2YXIgZCA9IGRpZmYocCwgbilcbiAgICByZXR1cm4gZFtkLmxlbmd0aCAtIDFdXG4gIH1cblxuICAgIHJldHVybiBleGFjdEluU3BoZXJlNVxufVxuXG5mdW5jdGlvbiBpblNwaGVyZTYoc3VtLCBkaWZmLCBwcm9kLCBzY2FsZSkge1xuICBmdW5jdGlvbiBleGFjdEluU3BoZXJlNihtMCwgbTEsIG0yLCBtMywgbTQsIG01KSB7XG4gICAgdmFyIHcwID0gc3VtKHN1bShwcm9kKG0wWzBdLCBtMFswXSksIHByb2QobTBbMV0sIG0wWzFdKSksIHN1bShwcm9kKG0wWzJdLCBtMFsyXSksIHByb2QobTBbM10sIG0wWzNdKSkpXG4gICAgdmFyIHcwbTEgPSBzY2FsZSh3MCwgbTFbMF0pXG4gICAgdmFyIHcwbTIgPSBzY2FsZSh3MCwgbTJbMF0pXG4gICAgdmFyIHcwbTMgPSBzY2FsZSh3MCwgbTNbMF0pXG4gICAgdmFyIHcwbTQgPSBzY2FsZSh3MCwgbTRbMF0pXG4gICAgdmFyIHcwbTUgPSBzY2FsZSh3MCwgbTVbMF0pXG4gICAgdmFyIHcxID0gc3VtKHN1bShwcm9kKG0xWzBdLCBtMVswXSksIHByb2QobTFbMV0sIG0xWzFdKSksIHN1bShwcm9kKG0xWzJdLCBtMVsyXSksIHByb2QobTFbM10sIG0xWzNdKSkpXG4gICAgdmFyIHcxbTAgPSBzY2FsZSh3MSwgbTBbMF0pXG4gICAgdmFyIHcxbTIgPSBzY2FsZSh3MSwgbTJbMF0pXG4gICAgdmFyIHcxbTMgPSBzY2FsZSh3MSwgbTNbMF0pXG4gICAgdmFyIHcxbTQgPSBzY2FsZSh3MSwgbTRbMF0pXG4gICAgdmFyIHcxbTUgPSBzY2FsZSh3MSwgbTVbMF0pXG4gICAgdmFyIHcyID0gc3VtKHN1bShwcm9kKG0yWzBdLCBtMlswXSksIHByb2QobTJbMV0sIG0yWzFdKSksIHN1bShwcm9kKG0yWzJdLCBtMlsyXSksIHByb2QobTJbM10sIG0yWzNdKSkpXG4gICAgdmFyIHcybTAgPSBzY2FsZSh3MiwgbTBbMF0pXG4gICAgdmFyIHcybTEgPSBzY2FsZSh3MiwgbTFbMF0pXG4gICAgdmFyIHcybTMgPSBzY2FsZSh3MiwgbTNbMF0pXG4gICAgdmFyIHcybTQgPSBzY2FsZSh3MiwgbTRbMF0pXG4gICAgdmFyIHcybTUgPSBzY2FsZSh3MiwgbTVbMF0pXG4gICAgdmFyIHczID0gc3VtKHN1bShwcm9kKG0zWzBdLCBtM1swXSksIHByb2QobTNbMV0sIG0zWzFdKSksIHN1bShwcm9kKG0zWzJdLCBtM1syXSksIHByb2QobTNbM10sIG0zWzNdKSkpXG4gICAgdmFyIHczbTAgPSBzY2FsZSh3MywgbTBbMF0pXG4gICAgdmFyIHczbTEgPSBzY2FsZSh3MywgbTFbMF0pXG4gICAgdmFyIHczbTIgPSBzY2FsZSh3MywgbTJbMF0pXG4gICAgdmFyIHczbTQgPSBzY2FsZSh3MywgbTRbMF0pXG4gICAgdmFyIHczbTUgPSBzY2FsZSh3MywgbTVbMF0pXG4gICAgdmFyIHc0ID0gc3VtKHN1bShwcm9kKG00WzBdLCBtNFswXSksIHByb2QobTRbMV0sIG00WzFdKSksIHN1bShwcm9kKG00WzJdLCBtNFsyXSksIHByb2QobTRbM10sIG00WzNdKSkpXG4gICAgdmFyIHc0bTAgPSBzY2FsZSh3NCwgbTBbMF0pXG4gICAgdmFyIHc0bTEgPSBzY2FsZSh3NCwgbTFbMF0pXG4gICAgdmFyIHc0bTIgPSBzY2FsZSh3NCwgbTJbMF0pXG4gICAgdmFyIHc0bTMgPSBzY2FsZSh3NCwgbTNbMF0pXG4gICAgdmFyIHc0bTUgPSBzY2FsZSh3NCwgbTVbMF0pXG4gICAgdmFyIHc1ID0gc3VtKHN1bShwcm9kKG01WzBdLCBtNVswXSksIHByb2QobTVbMV0sIG01WzFdKSksIHN1bShwcm9kKG01WzJdLCBtNVsyXSksIHByb2QobTVbM10sIG01WzNdKSkpXG4gICAgdmFyIHc1bTAgPSBzY2FsZSh3NSwgbTBbMF0pXG4gICAgdmFyIHc1bTEgPSBzY2FsZSh3NSwgbTFbMF0pXG4gICAgdmFyIHc1bTIgPSBzY2FsZSh3NSwgbTJbMF0pXG4gICAgdmFyIHc1bTMgPSBzY2FsZSh3NSwgbTNbMF0pXG4gICAgdmFyIHc1bTQgPSBzY2FsZSh3NSwgbTRbMF0pXG4gICAgdmFyIHAgPSBzdW0oc3VtKHN1bShzY2FsZShzdW0oc3VtKHNjYWxlKHN1bShzY2FsZShkaWZmKHc1bTQsIHc0bTUpLCBtM1sxXSksIHN1bShzY2FsZShkaWZmKHc1bTMsIHczbTUpLCAtbTRbMV0pLCBzY2FsZShkaWZmKHc0bTMsIHczbTQpLCBtNVsxXSkpKSwgbTJbMl0pLCBzY2FsZShzdW0oc2NhbGUoZGlmZih3NW00LCB3NG01KSwgbTJbMV0pLCBzdW0oc2NhbGUoZGlmZih3NW0yLCB3Mm01KSwgLW00WzFdKSwgc2NhbGUoZGlmZih3NG0yLCB3Mm00KSwgbTVbMV0pKSksIC1tM1syXSkpLCBzdW0oc2NhbGUoc3VtKHNjYWxlKGRpZmYodzVtMywgdzNtNSksIG0yWzFdKSwgc3VtKHNjYWxlKGRpZmYodzVtMiwgdzJtNSksIC1tM1sxXSksIHNjYWxlKGRpZmYodzNtMiwgdzJtMyksIG01WzFdKSkpLCBtNFsyXSksIHNjYWxlKHN1bShzY2FsZShkaWZmKHc0bTMsIHczbTQpLCBtMlsxXSksIHN1bShzY2FsZShkaWZmKHc0bTIsIHcybTQpLCAtbTNbMV0pLCBzY2FsZShkaWZmKHczbTIsIHcybTMpLCBtNFsxXSkpKSwgLW01WzJdKSkpLCBtMVszXSksIHN1bShzY2FsZShzdW0oc3VtKHNjYWxlKHN1bShzY2FsZShkaWZmKHc1bTQsIHc0bTUpLCBtM1sxXSksIHN1bShzY2FsZShkaWZmKHc1bTMsIHczbTUpLCAtbTRbMV0pLCBzY2FsZShkaWZmKHc0bTMsIHczbTQpLCBtNVsxXSkpKSwgbTFbMl0pLCBzY2FsZShzdW0oc2NhbGUoZGlmZih3NW00LCB3NG01KSwgbTFbMV0pLCBzdW0oc2NhbGUoZGlmZih3NW0xLCB3MW01KSwgLW00WzFdKSwgc2NhbGUoZGlmZih3NG0xLCB3MW00KSwgbTVbMV0pKSksIC1tM1syXSkpLCBzdW0oc2NhbGUoc3VtKHNjYWxlKGRpZmYodzVtMywgdzNtNSksIG0xWzFdKSwgc3VtKHNjYWxlKGRpZmYodzVtMSwgdzFtNSksIC1tM1sxXSksIHNjYWxlKGRpZmYodzNtMSwgdzFtMyksIG01WzFdKSkpLCBtNFsyXSksIHNjYWxlKHN1bShzY2FsZShkaWZmKHc0bTMsIHczbTQpLCBtMVsxXSksIHN1bShzY2FsZShkaWZmKHc0bTEsIHcxbTQpLCAtbTNbMV0pLCBzY2FsZShkaWZmKHczbTEsIHcxbTMpLCBtNFsxXSkpKSwgLW01WzJdKSkpLCAtbTJbM10pLCBzY2FsZShzdW0oc3VtKHNjYWxlKHN1bShzY2FsZShkaWZmKHc1bTQsIHc0bTUpLCBtMlsxXSksIHN1bShzY2FsZShkaWZmKHc1bTIsIHcybTUpLCAtbTRbMV0pLCBzY2FsZShkaWZmKHc0bTIsIHcybTQpLCBtNVsxXSkpKSwgbTFbMl0pLCBzY2FsZShzdW0oc2NhbGUoZGlmZih3NW00LCB3NG01KSwgbTFbMV0pLCBzdW0oc2NhbGUoZGlmZih3NW0xLCB3MW01KSwgLW00WzFdKSwgc2NhbGUoZGlmZih3NG0xLCB3MW00KSwgbTVbMV0pKSksIC1tMlsyXSkpLCBzdW0oc2NhbGUoc3VtKHNjYWxlKGRpZmYodzVtMiwgdzJtNSksIG0xWzFdKSwgc3VtKHNjYWxlKGRpZmYodzVtMSwgdzFtNSksIC1tMlsxXSksIHNjYWxlKGRpZmYodzJtMSwgdzFtMiksIG01WzFdKSkpLCBtNFsyXSksIHNjYWxlKHN1bShzY2FsZShkaWZmKHc0bTIsIHcybTQpLCBtMVsxXSksIHN1bShzY2FsZShkaWZmKHc0bTEsIHcxbTQpLCAtbTJbMV0pLCBzY2FsZShkaWZmKHcybTEsIHcxbTIpLCBtNFsxXSkpKSwgLW01WzJdKSkpLCBtM1szXSkpKSwgc3VtKHN1bShzY2FsZShzdW0oc3VtKHNjYWxlKHN1bShzY2FsZShkaWZmKHc1bTMsIHczbTUpLCBtMlsxXSksIHN1bShzY2FsZShkaWZmKHc1bTIsIHcybTUpLCAtbTNbMV0pLCBzY2FsZShkaWZmKHczbTIsIHcybTMpLCBtNVsxXSkpKSwgbTFbMl0pLCBzY2FsZShzdW0oc2NhbGUoZGlmZih3NW0zLCB3M201KSwgbTFbMV0pLCBzdW0oc2NhbGUoZGlmZih3NW0xLCB3MW01KSwgLW0zWzFdKSwgc2NhbGUoZGlmZih3M20xLCB3MW0zKSwgbTVbMV0pKSksIC1tMlsyXSkpLCBzdW0oc2NhbGUoc3VtKHNjYWxlKGRpZmYodzVtMiwgdzJtNSksIG0xWzFdKSwgc3VtKHNjYWxlKGRpZmYodzVtMSwgdzFtNSksIC1tMlsxXSksIHNjYWxlKGRpZmYodzJtMSwgdzFtMiksIG01WzFdKSkpLCBtM1syXSksIHNjYWxlKHN1bShzY2FsZShkaWZmKHczbTIsIHcybTMpLCBtMVsxXSksIHN1bShzY2FsZShkaWZmKHczbTEsIHcxbTMpLCAtbTJbMV0pLCBzY2FsZShkaWZmKHcybTEsIHcxbTIpLCBtM1sxXSkpKSwgLW01WzJdKSkpLCAtbTRbM10pLCBzY2FsZShzdW0oc3VtKHNjYWxlKHN1bShzY2FsZShkaWZmKHc0bTMsIHczbTQpLCBtMlsxXSksIHN1bShzY2FsZShkaWZmKHc0bTIsIHcybTQpLCAtbTNbMV0pLCBzY2FsZShkaWZmKHczbTIsIHcybTMpLCBtNFsxXSkpKSwgbTFbMl0pLCBzY2FsZShzdW0oc2NhbGUoZGlmZih3NG0zLCB3M200KSwgbTFbMV0pLCBzdW0oc2NhbGUoZGlmZih3NG0xLCB3MW00KSwgLW0zWzFdKSwgc2NhbGUoZGlmZih3M20xLCB3MW0zKSwgbTRbMV0pKSksIC1tMlsyXSkpLCBzdW0oc2NhbGUoc3VtKHNjYWxlKGRpZmYodzRtMiwgdzJtNCksIG0xWzFdKSwgc3VtKHNjYWxlKGRpZmYodzRtMSwgdzFtNCksIC1tMlsxXSksIHNjYWxlKGRpZmYodzJtMSwgdzFtMiksIG00WzFdKSkpLCBtM1syXSksIHNjYWxlKHN1bShzY2FsZShkaWZmKHczbTIsIHcybTMpLCBtMVsxXSksIHN1bShzY2FsZShkaWZmKHczbTEsIHcxbTMpLCAtbTJbMV0pLCBzY2FsZShkaWZmKHcybTEsIHcxbTIpLCBtM1sxXSkpKSwgLW00WzJdKSkpLCBtNVszXSkpLCBzdW0oc2NhbGUoc3VtKHN1bShzY2FsZShzdW0oc2NhbGUoZGlmZih3NW00LCB3NG01KSwgbTNbMV0pLCBzdW0oc2NhbGUoZGlmZih3NW0zLCB3M201KSwgLW00WzFdKSwgc2NhbGUoZGlmZih3NG0zLCB3M200KSwgbTVbMV0pKSksIG0xWzJdKSwgc2NhbGUoc3VtKHNjYWxlKGRpZmYodzVtNCwgdzRtNSksIG0xWzFdKSwgc3VtKHNjYWxlKGRpZmYodzVtMSwgdzFtNSksIC1tNFsxXSksIHNjYWxlKGRpZmYodzRtMSwgdzFtNCksIG01WzFdKSkpLCAtbTNbMl0pKSwgc3VtKHNjYWxlKHN1bShzY2FsZShkaWZmKHc1bTMsIHczbTUpLCBtMVsxXSksIHN1bShzY2FsZShkaWZmKHc1bTEsIHcxbTUpLCAtbTNbMV0pLCBzY2FsZShkaWZmKHczbTEsIHcxbTMpLCBtNVsxXSkpKSwgbTRbMl0pLCBzY2FsZShzdW0oc2NhbGUoZGlmZih3NG0zLCB3M200KSwgbTFbMV0pLCBzdW0oc2NhbGUoZGlmZih3NG0xLCB3MW00KSwgLW0zWzFdKSwgc2NhbGUoZGlmZih3M20xLCB3MW0zKSwgbTRbMV0pKSksIC1tNVsyXSkpKSwgbTBbM10pLCBzY2FsZShzdW0oc3VtKHNjYWxlKHN1bShzY2FsZShkaWZmKHc1bTQsIHc0bTUpLCBtM1sxXSksIHN1bShzY2FsZShkaWZmKHc1bTMsIHczbTUpLCAtbTRbMV0pLCBzY2FsZShkaWZmKHc0bTMsIHczbTQpLCBtNVsxXSkpKSwgbTBbMl0pLCBzY2FsZShzdW0oc2NhbGUoZGlmZih3NW00LCB3NG01KSwgbTBbMV0pLCBzdW0oc2NhbGUoZGlmZih3NW0wLCB3MG01KSwgLW00WzFdKSwgc2NhbGUoZGlmZih3NG0wLCB3MG00KSwgbTVbMV0pKSksIC1tM1syXSkpLCBzdW0oc2NhbGUoc3VtKHNjYWxlKGRpZmYodzVtMywgdzNtNSksIG0wWzFdKSwgc3VtKHNjYWxlKGRpZmYodzVtMCwgdzBtNSksIC1tM1sxXSksIHNjYWxlKGRpZmYodzNtMCwgdzBtMyksIG01WzFdKSkpLCBtNFsyXSksIHNjYWxlKHN1bShzY2FsZShkaWZmKHc0bTMsIHczbTQpLCBtMFsxXSksIHN1bShzY2FsZShkaWZmKHc0bTAsIHcwbTQpLCAtbTNbMV0pLCBzY2FsZShkaWZmKHczbTAsIHcwbTMpLCBtNFsxXSkpKSwgLW01WzJdKSkpLCAtbTFbM10pKSkpLCBzdW0oc3VtKHN1bShzY2FsZShzdW0oc3VtKHNjYWxlKHN1bShzY2FsZShkaWZmKHc1bTQsIHc0bTUpLCBtMVsxXSksIHN1bShzY2FsZShkaWZmKHc1bTEsIHcxbTUpLCAtbTRbMV0pLCBzY2FsZShkaWZmKHc0bTEsIHcxbTQpLCBtNVsxXSkpKSwgbTBbMl0pLCBzY2FsZShzdW0oc2NhbGUoZGlmZih3NW00LCB3NG01KSwgbTBbMV0pLCBzdW0oc2NhbGUoZGlmZih3NW0wLCB3MG01KSwgLW00WzFdKSwgc2NhbGUoZGlmZih3NG0wLCB3MG00KSwgbTVbMV0pKSksIC1tMVsyXSkpLCBzdW0oc2NhbGUoc3VtKHNjYWxlKGRpZmYodzVtMSwgdzFtNSksIG0wWzFdKSwgc3VtKHNjYWxlKGRpZmYodzVtMCwgdzBtNSksIC1tMVsxXSksIHNjYWxlKGRpZmYodzFtMCwgdzBtMSksIG01WzFdKSkpLCBtNFsyXSksIHNjYWxlKHN1bShzY2FsZShkaWZmKHc0bTEsIHcxbTQpLCBtMFsxXSksIHN1bShzY2FsZShkaWZmKHc0bTAsIHcwbTQpLCAtbTFbMV0pLCBzY2FsZShkaWZmKHcxbTAsIHcwbTEpLCBtNFsxXSkpKSwgLW01WzJdKSkpLCBtM1szXSksIHNjYWxlKHN1bShzdW0oc2NhbGUoc3VtKHNjYWxlKGRpZmYodzVtMywgdzNtNSksIG0xWzFdKSwgc3VtKHNjYWxlKGRpZmYodzVtMSwgdzFtNSksIC1tM1sxXSksIHNjYWxlKGRpZmYodzNtMSwgdzFtMyksIG01WzFdKSkpLCBtMFsyXSksIHNjYWxlKHN1bShzY2FsZShkaWZmKHc1bTMsIHczbTUpLCBtMFsxXSksIHN1bShzY2FsZShkaWZmKHc1bTAsIHcwbTUpLCAtbTNbMV0pLCBzY2FsZShkaWZmKHczbTAsIHcwbTMpLCBtNVsxXSkpKSwgLW0xWzJdKSksIHN1bShzY2FsZShzdW0oc2NhbGUoZGlmZih3NW0xLCB3MW01KSwgbTBbMV0pLCBzdW0oc2NhbGUoZGlmZih3NW0wLCB3MG01KSwgLW0xWzFdKSwgc2NhbGUoZGlmZih3MW0wLCB3MG0xKSwgbTVbMV0pKSksIG0zWzJdKSwgc2NhbGUoc3VtKHNjYWxlKGRpZmYodzNtMSwgdzFtMyksIG0wWzFdKSwgc3VtKHNjYWxlKGRpZmYodzNtMCwgdzBtMyksIC1tMVsxXSksIHNjYWxlKGRpZmYodzFtMCwgdzBtMSksIG0zWzFdKSkpLCAtbTVbMl0pKSksIC1tNFszXSkpLCBzdW0oc2NhbGUoc3VtKHN1bShzY2FsZShzdW0oc2NhbGUoZGlmZih3NG0zLCB3M200KSwgbTFbMV0pLCBzdW0oc2NhbGUoZGlmZih3NG0xLCB3MW00KSwgLW0zWzFdKSwgc2NhbGUoZGlmZih3M20xLCB3MW0zKSwgbTRbMV0pKSksIG0wWzJdKSwgc2NhbGUoc3VtKHNjYWxlKGRpZmYodzRtMywgdzNtNCksIG0wWzFdKSwgc3VtKHNjYWxlKGRpZmYodzRtMCwgdzBtNCksIC1tM1sxXSksIHNjYWxlKGRpZmYodzNtMCwgdzBtMyksIG00WzFdKSkpLCAtbTFbMl0pKSwgc3VtKHNjYWxlKHN1bShzY2FsZShkaWZmKHc0bTEsIHcxbTQpLCBtMFsxXSksIHN1bShzY2FsZShkaWZmKHc0bTAsIHcwbTQpLCAtbTFbMV0pLCBzY2FsZShkaWZmKHcxbTAsIHcwbTEpLCBtNFsxXSkpKSwgbTNbMl0pLCBzY2FsZShzdW0oc2NhbGUoZGlmZih3M20xLCB3MW0zKSwgbTBbMV0pLCBzdW0oc2NhbGUoZGlmZih3M20wLCB3MG0zKSwgLW0xWzFdKSwgc2NhbGUoZGlmZih3MW0wLCB3MG0xKSwgbTNbMV0pKSksIC1tNFsyXSkpKSwgbTVbM10pLCBzY2FsZShzdW0oc3VtKHNjYWxlKHN1bShzY2FsZShkaWZmKHc1bTMsIHczbTUpLCBtMlsxXSksIHN1bShzY2FsZShkaWZmKHc1bTIsIHcybTUpLCAtbTNbMV0pLCBzY2FsZShkaWZmKHczbTIsIHcybTMpLCBtNVsxXSkpKSwgbTFbMl0pLCBzY2FsZShzdW0oc2NhbGUoZGlmZih3NW0zLCB3M201KSwgbTFbMV0pLCBzdW0oc2NhbGUoZGlmZih3NW0xLCB3MW01KSwgLW0zWzFdKSwgc2NhbGUoZGlmZih3M20xLCB3MW0zKSwgbTVbMV0pKSksIC1tMlsyXSkpLCBzdW0oc2NhbGUoc3VtKHNjYWxlKGRpZmYodzVtMiwgdzJtNSksIG0xWzFdKSwgc3VtKHNjYWxlKGRpZmYodzVtMSwgdzFtNSksIC1tMlsxXSksIHNjYWxlKGRpZmYodzJtMSwgdzFtMiksIG01WzFdKSkpLCBtM1syXSksIHNjYWxlKHN1bShzY2FsZShkaWZmKHczbTIsIHcybTMpLCBtMVsxXSksIHN1bShzY2FsZShkaWZmKHczbTEsIHcxbTMpLCAtbTJbMV0pLCBzY2FsZShkaWZmKHcybTEsIHcxbTIpLCBtM1sxXSkpKSwgLW01WzJdKSkpLCBtMFszXSkpKSwgc3VtKHN1bShzY2FsZShzdW0oc3VtKHNjYWxlKHN1bShzY2FsZShkaWZmKHc1bTMsIHczbTUpLCBtMlsxXSksIHN1bShzY2FsZShkaWZmKHc1bTIsIHcybTUpLCAtbTNbMV0pLCBzY2FsZShkaWZmKHczbTIsIHcybTMpLCBtNVsxXSkpKSwgbTBbMl0pLCBzY2FsZShzdW0oc2NhbGUoZGlmZih3NW0zLCB3M201KSwgbTBbMV0pLCBzdW0oc2NhbGUoZGlmZih3NW0wLCB3MG01KSwgLW0zWzFdKSwgc2NhbGUoZGlmZih3M20wLCB3MG0zKSwgbTVbMV0pKSksIC1tMlsyXSkpLCBzdW0oc2NhbGUoc3VtKHNjYWxlKGRpZmYodzVtMiwgdzJtNSksIG0wWzFdKSwgc3VtKHNjYWxlKGRpZmYodzVtMCwgdzBtNSksIC1tMlsxXSksIHNjYWxlKGRpZmYodzJtMCwgdzBtMiksIG01WzFdKSkpLCBtM1syXSksIHNjYWxlKHN1bShzY2FsZShkaWZmKHczbTIsIHcybTMpLCBtMFsxXSksIHN1bShzY2FsZShkaWZmKHczbTAsIHcwbTMpLCAtbTJbMV0pLCBzY2FsZShkaWZmKHcybTAsIHcwbTIpLCBtM1sxXSkpKSwgLW01WzJdKSkpLCAtbTFbM10pLCBzY2FsZShzdW0oc3VtKHNjYWxlKHN1bShzY2FsZShkaWZmKHc1bTMsIHczbTUpLCBtMVsxXSksIHN1bShzY2FsZShkaWZmKHc1bTEsIHcxbTUpLCAtbTNbMV0pLCBzY2FsZShkaWZmKHczbTEsIHcxbTMpLCBtNVsxXSkpKSwgbTBbMl0pLCBzY2FsZShzdW0oc2NhbGUoZGlmZih3NW0zLCB3M201KSwgbTBbMV0pLCBzdW0oc2NhbGUoZGlmZih3NW0wLCB3MG01KSwgLW0zWzFdKSwgc2NhbGUoZGlmZih3M20wLCB3MG0zKSwgbTVbMV0pKSksIC1tMVsyXSkpLCBzdW0oc2NhbGUoc3VtKHNjYWxlKGRpZmYodzVtMSwgdzFtNSksIG0wWzFdKSwgc3VtKHNjYWxlKGRpZmYodzVtMCwgdzBtNSksIC1tMVsxXSksIHNjYWxlKGRpZmYodzFtMCwgdzBtMSksIG01WzFdKSkpLCBtM1syXSksIHNjYWxlKHN1bShzY2FsZShkaWZmKHczbTEsIHcxbTMpLCBtMFsxXSksIHN1bShzY2FsZShkaWZmKHczbTAsIHcwbTMpLCAtbTFbMV0pLCBzY2FsZShkaWZmKHcxbTAsIHcwbTEpLCBtM1sxXSkpKSwgLW01WzJdKSkpLCBtMlszXSkpLCBzdW0oc2NhbGUoc3VtKHN1bShzY2FsZShzdW0oc2NhbGUoZGlmZih3NW0yLCB3Mm01KSwgbTFbMV0pLCBzdW0oc2NhbGUoZGlmZih3NW0xLCB3MW01KSwgLW0yWzFdKSwgc2NhbGUoZGlmZih3Mm0xLCB3MW0yKSwgbTVbMV0pKSksIG0wWzJdKSwgc2NhbGUoc3VtKHNjYWxlKGRpZmYodzVtMiwgdzJtNSksIG0wWzFdKSwgc3VtKHNjYWxlKGRpZmYodzVtMCwgdzBtNSksIC1tMlsxXSksIHNjYWxlKGRpZmYodzJtMCwgdzBtMiksIG01WzFdKSkpLCAtbTFbMl0pKSwgc3VtKHNjYWxlKHN1bShzY2FsZShkaWZmKHc1bTEsIHcxbTUpLCBtMFsxXSksIHN1bShzY2FsZShkaWZmKHc1bTAsIHcwbTUpLCAtbTFbMV0pLCBzY2FsZShkaWZmKHcxbTAsIHcwbTEpLCBtNVsxXSkpKSwgbTJbMl0pLCBzY2FsZShzdW0oc2NhbGUoZGlmZih3Mm0xLCB3MW0yKSwgbTBbMV0pLCBzdW0oc2NhbGUoZGlmZih3Mm0wLCB3MG0yKSwgLW0xWzFdKSwgc2NhbGUoZGlmZih3MW0wLCB3MG0xKSwgbTJbMV0pKSksIC1tNVsyXSkpKSwgLW0zWzNdKSwgc2NhbGUoc3VtKHN1bShzY2FsZShzdW0oc2NhbGUoZGlmZih3M20yLCB3Mm0zKSwgbTFbMV0pLCBzdW0oc2NhbGUoZGlmZih3M20xLCB3MW0zKSwgLW0yWzFdKSwgc2NhbGUoZGlmZih3Mm0xLCB3MW0yKSwgbTNbMV0pKSksIG0wWzJdKSwgc2NhbGUoc3VtKHNjYWxlKGRpZmYodzNtMiwgdzJtMyksIG0wWzFdKSwgc3VtKHNjYWxlKGRpZmYodzNtMCwgdzBtMyksIC1tMlsxXSksIHNjYWxlKGRpZmYodzJtMCwgdzBtMiksIG0zWzFdKSkpLCAtbTFbMl0pKSwgc3VtKHNjYWxlKHN1bShzY2FsZShkaWZmKHczbTEsIHcxbTMpLCBtMFsxXSksIHN1bShzY2FsZShkaWZmKHczbTAsIHcwbTMpLCAtbTFbMV0pLCBzY2FsZShkaWZmKHcxbTAsIHcwbTEpLCBtM1sxXSkpKSwgbTJbMl0pLCBzY2FsZShzdW0oc2NhbGUoZGlmZih3Mm0xLCB3MW0yKSwgbTBbMV0pLCBzdW0oc2NhbGUoZGlmZih3Mm0wLCB3MG0yKSwgLW0xWzFdKSwgc2NhbGUoZGlmZih3MW0wLCB3MG0xKSwgbTJbMV0pKSksIC1tM1syXSkpKSwgbTVbM10pKSkpKVxuICAgIHZhciBuID0gc3VtKHN1bShzdW0oc2NhbGUoc3VtKHN1bShzY2FsZShzdW0oc2NhbGUoZGlmZih3NW00LCB3NG01KSwgbTNbMV0pLCBzdW0oc2NhbGUoZGlmZih3NW0zLCB3M201KSwgLW00WzFdKSwgc2NhbGUoZGlmZih3NG0zLCB3M200KSwgbTVbMV0pKSksIG0yWzJdKSwgc2NhbGUoc3VtKHNjYWxlKGRpZmYodzVtNCwgdzRtNSksIG0yWzFdKSwgc3VtKHNjYWxlKGRpZmYodzVtMiwgdzJtNSksIC1tNFsxXSksIHNjYWxlKGRpZmYodzRtMiwgdzJtNCksIG01WzFdKSkpLCAtbTNbMl0pKSwgc3VtKHNjYWxlKHN1bShzY2FsZShkaWZmKHc1bTMsIHczbTUpLCBtMlsxXSksIHN1bShzY2FsZShkaWZmKHc1bTIsIHcybTUpLCAtbTNbMV0pLCBzY2FsZShkaWZmKHczbTIsIHcybTMpLCBtNVsxXSkpKSwgbTRbMl0pLCBzY2FsZShzdW0oc2NhbGUoZGlmZih3NG0zLCB3M200KSwgbTJbMV0pLCBzdW0oc2NhbGUoZGlmZih3NG0yLCB3Mm00KSwgLW0zWzFdKSwgc2NhbGUoZGlmZih3M20yLCB3Mm0zKSwgbTRbMV0pKSksIC1tNVsyXSkpKSwgbTBbM10pLCBzdW0oc2NhbGUoc3VtKHN1bShzY2FsZShzdW0oc2NhbGUoZGlmZih3NW00LCB3NG01KSwgbTNbMV0pLCBzdW0oc2NhbGUoZGlmZih3NW0zLCB3M201KSwgLW00WzFdKSwgc2NhbGUoZGlmZih3NG0zLCB3M200KSwgbTVbMV0pKSksIG0wWzJdKSwgc2NhbGUoc3VtKHNjYWxlKGRpZmYodzVtNCwgdzRtNSksIG0wWzFdKSwgc3VtKHNjYWxlKGRpZmYodzVtMCwgdzBtNSksIC1tNFsxXSksIHNjYWxlKGRpZmYodzRtMCwgdzBtNCksIG01WzFdKSkpLCAtbTNbMl0pKSwgc3VtKHNjYWxlKHN1bShzY2FsZShkaWZmKHc1bTMsIHczbTUpLCBtMFsxXSksIHN1bShzY2FsZShkaWZmKHc1bTAsIHcwbTUpLCAtbTNbMV0pLCBzY2FsZShkaWZmKHczbTAsIHcwbTMpLCBtNVsxXSkpKSwgbTRbMl0pLCBzY2FsZShzdW0oc2NhbGUoZGlmZih3NG0zLCB3M200KSwgbTBbMV0pLCBzdW0oc2NhbGUoZGlmZih3NG0wLCB3MG00KSwgLW0zWzFdKSwgc2NhbGUoZGlmZih3M20wLCB3MG0zKSwgbTRbMV0pKSksIC1tNVsyXSkpKSwgLW0yWzNdKSwgc2NhbGUoc3VtKHN1bShzY2FsZShzdW0oc2NhbGUoZGlmZih3NW00LCB3NG01KSwgbTJbMV0pLCBzdW0oc2NhbGUoZGlmZih3NW0yLCB3Mm01KSwgLW00WzFdKSwgc2NhbGUoZGlmZih3NG0yLCB3Mm00KSwgbTVbMV0pKSksIG0wWzJdKSwgc2NhbGUoc3VtKHNjYWxlKGRpZmYodzVtNCwgdzRtNSksIG0wWzFdKSwgc3VtKHNjYWxlKGRpZmYodzVtMCwgdzBtNSksIC1tNFsxXSksIHNjYWxlKGRpZmYodzRtMCwgdzBtNCksIG01WzFdKSkpLCAtbTJbMl0pKSwgc3VtKHNjYWxlKHN1bShzY2FsZShkaWZmKHc1bTIsIHcybTUpLCBtMFsxXSksIHN1bShzY2FsZShkaWZmKHc1bTAsIHcwbTUpLCAtbTJbMV0pLCBzY2FsZShkaWZmKHcybTAsIHcwbTIpLCBtNVsxXSkpKSwgbTRbMl0pLCBzY2FsZShzdW0oc2NhbGUoZGlmZih3NG0yLCB3Mm00KSwgbTBbMV0pLCBzdW0oc2NhbGUoZGlmZih3NG0wLCB3MG00KSwgLW0yWzFdKSwgc2NhbGUoZGlmZih3Mm0wLCB3MG0yKSwgbTRbMV0pKSksIC1tNVsyXSkpKSwgbTNbM10pKSksIHN1bShzdW0oc2NhbGUoc3VtKHN1bShzY2FsZShzdW0oc2NhbGUoZGlmZih3NW0zLCB3M201KSwgbTJbMV0pLCBzdW0oc2NhbGUoZGlmZih3NW0yLCB3Mm01KSwgLW0zWzFdKSwgc2NhbGUoZGlmZih3M20yLCB3Mm0zKSwgbTVbMV0pKSksIG0wWzJdKSwgc2NhbGUoc3VtKHNjYWxlKGRpZmYodzVtMywgdzNtNSksIG0wWzFdKSwgc3VtKHNjYWxlKGRpZmYodzVtMCwgdzBtNSksIC1tM1sxXSksIHNjYWxlKGRpZmYodzNtMCwgdzBtMyksIG01WzFdKSkpLCAtbTJbMl0pKSwgc3VtKHNjYWxlKHN1bShzY2FsZShkaWZmKHc1bTIsIHcybTUpLCBtMFsxXSksIHN1bShzY2FsZShkaWZmKHc1bTAsIHcwbTUpLCAtbTJbMV0pLCBzY2FsZShkaWZmKHcybTAsIHcwbTIpLCBtNVsxXSkpKSwgbTNbMl0pLCBzY2FsZShzdW0oc2NhbGUoZGlmZih3M20yLCB3Mm0zKSwgbTBbMV0pLCBzdW0oc2NhbGUoZGlmZih3M20wLCB3MG0zKSwgLW0yWzFdKSwgc2NhbGUoZGlmZih3Mm0wLCB3MG0yKSwgbTNbMV0pKSksIC1tNVsyXSkpKSwgLW00WzNdKSwgc2NhbGUoc3VtKHN1bShzY2FsZShzdW0oc2NhbGUoZGlmZih3NG0zLCB3M200KSwgbTJbMV0pLCBzdW0oc2NhbGUoZGlmZih3NG0yLCB3Mm00KSwgLW0zWzFdKSwgc2NhbGUoZGlmZih3M20yLCB3Mm0zKSwgbTRbMV0pKSksIG0wWzJdKSwgc2NhbGUoc3VtKHNjYWxlKGRpZmYodzRtMywgdzNtNCksIG0wWzFdKSwgc3VtKHNjYWxlKGRpZmYodzRtMCwgdzBtNCksIC1tM1sxXSksIHNjYWxlKGRpZmYodzNtMCwgdzBtMyksIG00WzFdKSkpLCAtbTJbMl0pKSwgc3VtKHNjYWxlKHN1bShzY2FsZShkaWZmKHc0bTIsIHcybTQpLCBtMFsxXSksIHN1bShzY2FsZShkaWZmKHc0bTAsIHcwbTQpLCAtbTJbMV0pLCBzY2FsZShkaWZmKHcybTAsIHcwbTIpLCBtNFsxXSkpKSwgbTNbMl0pLCBzY2FsZShzdW0oc2NhbGUoZGlmZih3M20yLCB3Mm0zKSwgbTBbMV0pLCBzdW0oc2NhbGUoZGlmZih3M20wLCB3MG0zKSwgLW0yWzFdKSwgc2NhbGUoZGlmZih3Mm0wLCB3MG0yKSwgbTNbMV0pKSksIC1tNFsyXSkpKSwgbTVbM10pKSwgc3VtKHNjYWxlKHN1bShzdW0oc2NhbGUoc3VtKHNjYWxlKGRpZmYodzVtNCwgdzRtNSksIG0yWzFdKSwgc3VtKHNjYWxlKGRpZmYodzVtMiwgdzJtNSksIC1tNFsxXSksIHNjYWxlKGRpZmYodzRtMiwgdzJtNCksIG01WzFdKSkpLCBtMVsyXSksIHNjYWxlKHN1bShzY2FsZShkaWZmKHc1bTQsIHc0bTUpLCBtMVsxXSksIHN1bShzY2FsZShkaWZmKHc1bTEsIHcxbTUpLCAtbTRbMV0pLCBzY2FsZShkaWZmKHc0bTEsIHcxbTQpLCBtNVsxXSkpKSwgLW0yWzJdKSksIHN1bShzY2FsZShzdW0oc2NhbGUoZGlmZih3NW0yLCB3Mm01KSwgbTFbMV0pLCBzdW0oc2NhbGUoZGlmZih3NW0xLCB3MW01KSwgLW0yWzFdKSwgc2NhbGUoZGlmZih3Mm0xLCB3MW0yKSwgbTVbMV0pKSksIG00WzJdKSwgc2NhbGUoc3VtKHNjYWxlKGRpZmYodzRtMiwgdzJtNCksIG0xWzFdKSwgc3VtKHNjYWxlKGRpZmYodzRtMSwgdzFtNCksIC1tMlsxXSksIHNjYWxlKGRpZmYodzJtMSwgdzFtMiksIG00WzFdKSkpLCAtbTVbMl0pKSksIG0wWzNdKSwgc2NhbGUoc3VtKHN1bShzY2FsZShzdW0oc2NhbGUoZGlmZih3NW00LCB3NG01KSwgbTJbMV0pLCBzdW0oc2NhbGUoZGlmZih3NW0yLCB3Mm01KSwgLW00WzFdKSwgc2NhbGUoZGlmZih3NG0yLCB3Mm00KSwgbTVbMV0pKSksIG0wWzJdKSwgc2NhbGUoc3VtKHNjYWxlKGRpZmYodzVtNCwgdzRtNSksIG0wWzFdKSwgc3VtKHNjYWxlKGRpZmYodzVtMCwgdzBtNSksIC1tNFsxXSksIHNjYWxlKGRpZmYodzRtMCwgdzBtNCksIG01WzFdKSkpLCAtbTJbMl0pKSwgc3VtKHNjYWxlKHN1bShzY2FsZShkaWZmKHc1bTIsIHcybTUpLCBtMFsxXSksIHN1bShzY2FsZShkaWZmKHc1bTAsIHcwbTUpLCAtbTJbMV0pLCBzY2FsZShkaWZmKHcybTAsIHcwbTIpLCBtNVsxXSkpKSwgbTRbMl0pLCBzY2FsZShzdW0oc2NhbGUoZGlmZih3NG0yLCB3Mm00KSwgbTBbMV0pLCBzdW0oc2NhbGUoZGlmZih3NG0wLCB3MG00KSwgLW0yWzFdKSwgc2NhbGUoZGlmZih3Mm0wLCB3MG0yKSwgbTRbMV0pKSksIC1tNVsyXSkpKSwgLW0xWzNdKSkpKSwgc3VtKHN1bShzdW0oc2NhbGUoc3VtKHN1bShzY2FsZShzdW0oc2NhbGUoZGlmZih3NW00LCB3NG01KSwgbTFbMV0pLCBzdW0oc2NhbGUoZGlmZih3NW0xLCB3MW01KSwgLW00WzFdKSwgc2NhbGUoZGlmZih3NG0xLCB3MW00KSwgbTVbMV0pKSksIG0wWzJdKSwgc2NhbGUoc3VtKHNjYWxlKGRpZmYodzVtNCwgdzRtNSksIG0wWzFdKSwgc3VtKHNjYWxlKGRpZmYodzVtMCwgdzBtNSksIC1tNFsxXSksIHNjYWxlKGRpZmYodzRtMCwgdzBtNCksIG01WzFdKSkpLCAtbTFbMl0pKSwgc3VtKHNjYWxlKHN1bShzY2FsZShkaWZmKHc1bTEsIHcxbTUpLCBtMFsxXSksIHN1bShzY2FsZShkaWZmKHc1bTAsIHcwbTUpLCAtbTFbMV0pLCBzY2FsZShkaWZmKHcxbTAsIHcwbTEpLCBtNVsxXSkpKSwgbTRbMl0pLCBzY2FsZShzdW0oc2NhbGUoZGlmZih3NG0xLCB3MW00KSwgbTBbMV0pLCBzdW0oc2NhbGUoZGlmZih3NG0wLCB3MG00KSwgLW0xWzFdKSwgc2NhbGUoZGlmZih3MW0wLCB3MG0xKSwgbTRbMV0pKSksIC1tNVsyXSkpKSwgbTJbM10pLCBzY2FsZShzdW0oc3VtKHNjYWxlKHN1bShzY2FsZShkaWZmKHc1bTIsIHcybTUpLCBtMVsxXSksIHN1bShzY2FsZShkaWZmKHc1bTEsIHcxbTUpLCAtbTJbMV0pLCBzY2FsZShkaWZmKHcybTEsIHcxbTIpLCBtNVsxXSkpKSwgbTBbMl0pLCBzY2FsZShzdW0oc2NhbGUoZGlmZih3NW0yLCB3Mm01KSwgbTBbMV0pLCBzdW0oc2NhbGUoZGlmZih3NW0wLCB3MG01KSwgLW0yWzFdKSwgc2NhbGUoZGlmZih3Mm0wLCB3MG0yKSwgbTVbMV0pKSksIC1tMVsyXSkpLCBzdW0oc2NhbGUoc3VtKHNjYWxlKGRpZmYodzVtMSwgdzFtNSksIG0wWzFdKSwgc3VtKHNjYWxlKGRpZmYodzVtMCwgdzBtNSksIC1tMVsxXSksIHNjYWxlKGRpZmYodzFtMCwgdzBtMSksIG01WzFdKSkpLCBtMlsyXSksIHNjYWxlKHN1bShzY2FsZShkaWZmKHcybTEsIHcxbTIpLCBtMFsxXSksIHN1bShzY2FsZShkaWZmKHcybTAsIHcwbTIpLCAtbTFbMV0pLCBzY2FsZShkaWZmKHcxbTAsIHcwbTEpLCBtMlsxXSkpKSwgLW01WzJdKSkpLCAtbTRbM10pKSwgc3VtKHNjYWxlKHN1bShzdW0oc2NhbGUoc3VtKHNjYWxlKGRpZmYodzRtMiwgdzJtNCksIG0xWzFdKSwgc3VtKHNjYWxlKGRpZmYodzRtMSwgdzFtNCksIC1tMlsxXSksIHNjYWxlKGRpZmYodzJtMSwgdzFtMiksIG00WzFdKSkpLCBtMFsyXSksIHNjYWxlKHN1bShzY2FsZShkaWZmKHc0bTIsIHcybTQpLCBtMFsxXSksIHN1bShzY2FsZShkaWZmKHc0bTAsIHcwbTQpLCAtbTJbMV0pLCBzY2FsZShkaWZmKHcybTAsIHcwbTIpLCBtNFsxXSkpKSwgLW0xWzJdKSksIHN1bShzY2FsZShzdW0oc2NhbGUoZGlmZih3NG0xLCB3MW00KSwgbTBbMV0pLCBzdW0oc2NhbGUoZGlmZih3NG0wLCB3MG00KSwgLW0xWzFdKSwgc2NhbGUoZGlmZih3MW0wLCB3MG0xKSwgbTRbMV0pKSksIG0yWzJdKSwgc2NhbGUoc3VtKHNjYWxlKGRpZmYodzJtMSwgdzFtMiksIG0wWzFdKSwgc3VtKHNjYWxlKGRpZmYodzJtMCwgdzBtMiksIC1tMVsxXSksIHNjYWxlKGRpZmYodzFtMCwgdzBtMSksIG0yWzFdKSkpLCAtbTRbMl0pKSksIG01WzNdKSwgc2NhbGUoc3VtKHN1bShzY2FsZShzdW0oc2NhbGUoZGlmZih3NG0zLCB3M200KSwgbTJbMV0pLCBzdW0oc2NhbGUoZGlmZih3NG0yLCB3Mm00KSwgLW0zWzFdKSwgc2NhbGUoZGlmZih3M20yLCB3Mm0zKSwgbTRbMV0pKSksIG0xWzJdKSwgc2NhbGUoc3VtKHNjYWxlKGRpZmYodzRtMywgdzNtNCksIG0xWzFdKSwgc3VtKHNjYWxlKGRpZmYodzRtMSwgdzFtNCksIC1tM1sxXSksIHNjYWxlKGRpZmYodzNtMSwgdzFtMyksIG00WzFdKSkpLCAtbTJbMl0pKSwgc3VtKHNjYWxlKHN1bShzY2FsZShkaWZmKHc0bTIsIHcybTQpLCBtMVsxXSksIHN1bShzY2FsZShkaWZmKHc0bTEsIHcxbTQpLCAtbTJbMV0pLCBzY2FsZShkaWZmKHcybTEsIHcxbTIpLCBtNFsxXSkpKSwgbTNbMl0pLCBzY2FsZShzdW0oc2NhbGUoZGlmZih3M20yLCB3Mm0zKSwgbTFbMV0pLCBzdW0oc2NhbGUoZGlmZih3M20xLCB3MW0zKSwgLW0yWzFdKSwgc2NhbGUoZGlmZih3Mm0xLCB3MW0yKSwgbTNbMV0pKSksIC1tNFsyXSkpKSwgbTBbM10pKSksIHN1bShzdW0oc2NhbGUoc3VtKHN1bShzY2FsZShzdW0oc2NhbGUoZGlmZih3NG0zLCB3M200KSwgbTJbMV0pLCBzdW0oc2NhbGUoZGlmZih3NG0yLCB3Mm00KSwgLW0zWzFdKSwgc2NhbGUoZGlmZih3M20yLCB3Mm0zKSwgbTRbMV0pKSksIG0wWzJdKSwgc2NhbGUoc3VtKHNjYWxlKGRpZmYodzRtMywgdzNtNCksIG0wWzFdKSwgc3VtKHNjYWxlKGRpZmYodzRtMCwgdzBtNCksIC1tM1sxXSksIHNjYWxlKGRpZmYodzNtMCwgdzBtMyksIG00WzFdKSkpLCAtbTJbMl0pKSwgc3VtKHNjYWxlKHN1bShzY2FsZShkaWZmKHc0bTIsIHcybTQpLCBtMFsxXSksIHN1bShzY2FsZShkaWZmKHc0bTAsIHcwbTQpLCAtbTJbMV0pLCBzY2FsZShkaWZmKHcybTAsIHcwbTIpLCBtNFsxXSkpKSwgbTNbMl0pLCBzY2FsZShzdW0oc2NhbGUoZGlmZih3M20yLCB3Mm0zKSwgbTBbMV0pLCBzdW0oc2NhbGUoZGlmZih3M20wLCB3MG0zKSwgLW0yWzFdKSwgc2NhbGUoZGlmZih3Mm0wLCB3MG0yKSwgbTNbMV0pKSksIC1tNFsyXSkpKSwgLW0xWzNdKSwgc2NhbGUoc3VtKHN1bShzY2FsZShzdW0oc2NhbGUoZGlmZih3NG0zLCB3M200KSwgbTFbMV0pLCBzdW0oc2NhbGUoZGlmZih3NG0xLCB3MW00KSwgLW0zWzFdKSwgc2NhbGUoZGlmZih3M20xLCB3MW0zKSwgbTRbMV0pKSksIG0wWzJdKSwgc2NhbGUoc3VtKHNjYWxlKGRpZmYodzRtMywgdzNtNCksIG0wWzFdKSwgc3VtKHNjYWxlKGRpZmYodzRtMCwgdzBtNCksIC1tM1sxXSksIHNjYWxlKGRpZmYodzNtMCwgdzBtMyksIG00WzFdKSkpLCAtbTFbMl0pKSwgc3VtKHNjYWxlKHN1bShzY2FsZShkaWZmKHc0bTEsIHcxbTQpLCBtMFsxXSksIHN1bShzY2FsZShkaWZmKHc0bTAsIHcwbTQpLCAtbTFbMV0pLCBzY2FsZShkaWZmKHcxbTAsIHcwbTEpLCBtNFsxXSkpKSwgbTNbMl0pLCBzY2FsZShzdW0oc2NhbGUoZGlmZih3M20xLCB3MW0zKSwgbTBbMV0pLCBzdW0oc2NhbGUoZGlmZih3M20wLCB3MG0zKSwgLW0xWzFdKSwgc2NhbGUoZGlmZih3MW0wLCB3MG0xKSwgbTNbMV0pKSksIC1tNFsyXSkpKSwgbTJbM10pKSwgc3VtKHNjYWxlKHN1bShzdW0oc2NhbGUoc3VtKHNjYWxlKGRpZmYodzRtMiwgdzJtNCksIG0xWzFdKSwgc3VtKHNjYWxlKGRpZmYodzRtMSwgdzFtNCksIC1tMlsxXSksIHNjYWxlKGRpZmYodzJtMSwgdzFtMiksIG00WzFdKSkpLCBtMFsyXSksIHNjYWxlKHN1bShzY2FsZShkaWZmKHc0bTIsIHcybTQpLCBtMFsxXSksIHN1bShzY2FsZShkaWZmKHc0bTAsIHcwbTQpLCAtbTJbMV0pLCBzY2FsZShkaWZmKHcybTAsIHcwbTIpLCBtNFsxXSkpKSwgLW0xWzJdKSksIHN1bShzY2FsZShzdW0oc2NhbGUoZGlmZih3NG0xLCB3MW00KSwgbTBbMV0pLCBzdW0oc2NhbGUoZGlmZih3NG0wLCB3MG00KSwgLW0xWzFdKSwgc2NhbGUoZGlmZih3MW0wLCB3MG0xKSwgbTRbMV0pKSksIG0yWzJdKSwgc2NhbGUoc3VtKHNjYWxlKGRpZmYodzJtMSwgdzFtMiksIG0wWzFdKSwgc3VtKHNjYWxlKGRpZmYodzJtMCwgdzBtMiksIC1tMVsxXSksIHNjYWxlKGRpZmYodzFtMCwgdzBtMSksIG0yWzFdKSkpLCAtbTRbMl0pKSksIC1tM1szXSksIHNjYWxlKHN1bShzdW0oc2NhbGUoc3VtKHNjYWxlKGRpZmYodzNtMiwgdzJtMyksIG0xWzFdKSwgc3VtKHNjYWxlKGRpZmYodzNtMSwgdzFtMyksIC1tMlsxXSksIHNjYWxlKGRpZmYodzJtMSwgdzFtMiksIG0zWzFdKSkpLCBtMFsyXSksIHNjYWxlKHN1bShzY2FsZShkaWZmKHczbTIsIHcybTMpLCBtMFsxXSksIHN1bShzY2FsZShkaWZmKHczbTAsIHcwbTMpLCAtbTJbMV0pLCBzY2FsZShkaWZmKHcybTAsIHcwbTIpLCBtM1sxXSkpKSwgLW0xWzJdKSksIHN1bShzY2FsZShzdW0oc2NhbGUoZGlmZih3M20xLCB3MW0zKSwgbTBbMV0pLCBzdW0oc2NhbGUoZGlmZih3M20wLCB3MG0zKSwgLW0xWzFdKSwgc2NhbGUoZGlmZih3MW0wLCB3MG0xKSwgbTNbMV0pKSksIG0yWzJdKSwgc2NhbGUoc3VtKHNjYWxlKGRpZmYodzJtMSwgdzFtMiksIG0wWzFdKSwgc3VtKHNjYWxlKGRpZmYodzJtMCwgdzBtMiksIC1tMVsxXSksIHNjYWxlKGRpZmYodzFtMCwgdzBtMSksIG0yWzFdKSkpLCAtbTNbMl0pKSksIG00WzNdKSkpKSlcbiAgICB2YXIgZCA9IGRpZmYocCwgbilcbiAgICByZXR1cm4gZFtkLmxlbmd0aCAtIDFdXG4gIH1cbiAgcmV0dXJuIGV4YWN0SW5TcGhlcmU2XG59XG5cbnZhciBDQUNIRUQgPSBbXG4gIGluU3BoZXJlMCxcbiAgaW5TcGhlcmUxLFxuICBpblNwaGVyZTJcbl1cblxuZnVuY3Rpb24gc2xvd0luU3BoZXJlKGFyZ3MpIHtcbiAgdmFyIHByb2MgPSBDQUNIRURbYXJncy5sZW5ndGhdXG4gIGlmKCFwcm9jKSB7XG4gICAgcHJvYyA9IENBQ0hFRFthcmdzLmxlbmd0aF0gPSBvcmllbnRhdGlvbihhcmdzLmxlbmd0aClcbiAgfVxuICByZXR1cm4gcHJvYy5hcHBseSh1bmRlZmluZWQsIGFyZ3MpXG59XG5cbmZ1bmN0aW9uIHByb2Moc2xvdywgbzAsIG8xLCBvMiwgbzMsIG80LCBvNSwgbzYpIHtcbiAgZnVuY3Rpb24gdGVzdEluU3BoZXJlKGEwLCBhMSwgYTIsIGEzLCBhNCwgYTUpIHtcbiAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIHJldHVybiBvMihhMCwgYTEpXG4gICAgICBjYXNlIDM6XG4gICAgICAgIHJldHVybiBvMyhhMCwgYTEsIGEyKVxuICAgICAgY2FzZSA0OlxuICAgICAgICByZXR1cm4gbzQoYTAsIGExLCBhMiwgYTMpXG4gICAgICBjYXNlIDU6XG4gICAgICAgIHJldHVybiBvNShhMCwgYTEsIGEyLCBhMywgYTQpXG4gICAgICBjYXNlIDY6XG4gICAgICAgIHJldHVybiBvNihhMCwgYTEsIGEyLCBhMywgYTQsIGE1KVxuICAgIH1cblxuICAgIHZhciBzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgpXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHNbaV0gPSBhcmd1bWVudHNbaV1cbiAgICB9XG4gICAgcmV0dXJuIHNsb3cocylcbiAgfVxuICByZXR1cm4gdGVzdEluU3BoZXJlXG59XG5cbmZ1bmN0aW9uIGdlbmVyYXRlSW5TcGhlcmVUZXN0KCkge1xuICB3aGlsZShDQUNIRUQubGVuZ3RoIDw9IE5VTV9FWFBBTkQpIHtcbiAgICBDQUNIRUQucHVzaChvcmllbnRhdGlvbihDQUNIRUQubGVuZ3RoKSlcbiAgfVxuXG4gIG1vZHVsZS5leHBvcnRzID0gcHJvYy5hcHBseSh1bmRlZmluZWQsIFtzbG93SW5TcGhlcmVdLmNvbmNhdChDQUNIRUQpKVxuICBmb3IodmFyIGk9MDsgaTw9TlVNX0VYUEFORDsgKytpKSB7XG4gICAgbW9kdWxlLmV4cG9ydHNbaV0gPSBDQUNIRURbaV1cbiAgfVxufVxuXG5nZW5lcmF0ZUluU3BoZXJlVGVzdCgpIiwiXCJ1c2Ugc3RyaWN0XCJcblxudmFyIHR3b1Byb2R1Y3QgPSByZXF1aXJlKFwidHdvLXByb2R1Y3RcIilcbnZhciByb2J1c3RTdW0gPSByZXF1aXJlKFwicm9idXN0LXN1bVwiKVxudmFyIHJvYnVzdFNjYWxlID0gcmVxdWlyZShcInJvYnVzdC1zY2FsZVwiKVxudmFyIHJvYnVzdFN1YnRyYWN0ID0gcmVxdWlyZShcInJvYnVzdC1zdWJ0cmFjdFwiKVxuXG52YXIgTlVNX0VYUEFORCA9IDVcblxudmFyIEVQU0lMT04gICAgID0gMS4xMTAyMjMwMjQ2MjUxNTY1ZS0xNlxudmFyIEVSUkJPVU5EMyAgID0gKDMuMCArIDE2LjAgKiBFUFNJTE9OKSAqIEVQU0lMT05cbnZhciBFUlJCT1VORDQgICA9ICg3LjAgKyA1Ni4wICogRVBTSUxPTikgKiBFUFNJTE9OXG5cbmZ1bmN0aW9uIG9yaWVudGF0aW9uXzMoc3VtLCBwcm9kLCBzY2FsZSwgc3ViKSB7XG4gIHJldHVybiBmdW5jdGlvbiBvcmllbnRhdGlvbjNFeGFjdChtMCwgbTEsIG0yKSB7XG4gICAgdmFyIHAgPSBzdW0oc3VtKHByb2QobTFbMV0sIG0yWzBdKSwgcHJvZCgtbTJbMV0sIG0xWzBdKSksIHN1bShwcm9kKG0wWzFdLCBtMVswXSksIHByb2QoLW0xWzFdLCBtMFswXSkpKVxuICAgIHZhciBuID0gc3VtKHByb2QobTBbMV0sIG0yWzBdKSwgcHJvZCgtbTJbMV0sIG0wWzBdKSlcbiAgICB2YXIgZCA9IHN1YihwLCBuKVxuICAgIHJldHVybiBkW2QubGVuZ3RoIC0gMV1cbiAgfVxufVxuXG5mdW5jdGlvbiBvcmllbnRhdGlvbl80KHN1bSwgcHJvZCwgc2NhbGUsIHN1Yikge1xuICByZXR1cm4gZnVuY3Rpb24gb3JpZW50YXRpb240RXhhY3QobTAsIG0xLCBtMiwgbTMpIHtcbiAgICB2YXIgcCA9IHN1bShzdW0oc2NhbGUoc3VtKHByb2QobTJbMV0sIG0zWzBdKSwgcHJvZCgtbTNbMV0sIG0yWzBdKSksIG0xWzJdKSwgc3VtKHNjYWxlKHN1bShwcm9kKG0xWzFdLCBtM1swXSksIHByb2QoLW0zWzFdLCBtMVswXSkpLCAtbTJbMl0pLCBzY2FsZShzdW0ocHJvZChtMVsxXSwgbTJbMF0pLCBwcm9kKC1tMlsxXSwgbTFbMF0pKSwgbTNbMl0pKSksIHN1bShzY2FsZShzdW0ocHJvZChtMVsxXSwgbTNbMF0pLCBwcm9kKC1tM1sxXSwgbTFbMF0pKSwgbTBbMl0pLCBzdW0oc2NhbGUoc3VtKHByb2QobTBbMV0sIG0zWzBdKSwgcHJvZCgtbTNbMV0sIG0wWzBdKSksIC1tMVsyXSksIHNjYWxlKHN1bShwcm9kKG0wWzFdLCBtMVswXSksIHByb2QoLW0xWzFdLCBtMFswXSkpLCBtM1syXSkpKSlcbiAgICB2YXIgbiA9IHN1bShzdW0oc2NhbGUoc3VtKHByb2QobTJbMV0sIG0zWzBdKSwgcHJvZCgtbTNbMV0sIG0yWzBdKSksIG0wWzJdKSwgc3VtKHNjYWxlKHN1bShwcm9kKG0wWzFdLCBtM1swXSksIHByb2QoLW0zWzFdLCBtMFswXSkpLCAtbTJbMl0pLCBzY2FsZShzdW0ocHJvZChtMFsxXSwgbTJbMF0pLCBwcm9kKC1tMlsxXSwgbTBbMF0pKSwgbTNbMl0pKSksIHN1bShzY2FsZShzdW0ocHJvZChtMVsxXSwgbTJbMF0pLCBwcm9kKC1tMlsxXSwgbTFbMF0pKSwgbTBbMl0pLCBzdW0oc2NhbGUoc3VtKHByb2QobTBbMV0sIG0yWzBdKSwgcHJvZCgtbTJbMV0sIG0wWzBdKSksIC1tMVsyXSksIHNjYWxlKHN1bShwcm9kKG0wWzFdLCBtMVswXSksIHByb2QoLW0xWzFdLCBtMFswXSkpLCBtMlsyXSkpKSlcbiAgICB2YXIgZCA9IHN1YihwLCBuKVxuICAgIHJldHVybiBkW2QubGVuZ3RoIC0gMV1cbiAgfVxufVxuXG5mdW5jdGlvbiBvcmllbnRhdGlvbl81KHN1bSwgcHJvZCwgc2NhbGUsIHN1Yikge1xuICByZXR1cm4gZnVuY3Rpb24gb3JpZW50YXRpb241RXhhY3QobTAsIG0xLCBtMiwgbTMsIG00KSB7XG4gICAgdmFyIHAgPSBzdW0oc3VtKHN1bShzY2FsZShzdW0oc2NhbGUoc3VtKHByb2QobTNbMV0sIG00WzBdKSwgcHJvZCgtbTRbMV0sIG0zWzBdKSksIG0yWzJdKSwgc3VtKHNjYWxlKHN1bShwcm9kKG0yWzFdLCBtNFswXSksIHByb2QoLW00WzFdLCBtMlswXSkpLCAtbTNbMl0pLCBzY2FsZShzdW0ocHJvZChtMlsxXSwgbTNbMF0pLCBwcm9kKC1tM1sxXSwgbTJbMF0pKSwgbTRbMl0pKSksIG0xWzNdKSwgc3VtKHNjYWxlKHN1bShzY2FsZShzdW0ocHJvZChtM1sxXSwgbTRbMF0pLCBwcm9kKC1tNFsxXSwgbTNbMF0pKSwgbTFbMl0pLCBzdW0oc2NhbGUoc3VtKHByb2QobTFbMV0sIG00WzBdKSwgcHJvZCgtbTRbMV0sIG0xWzBdKSksIC1tM1syXSksIHNjYWxlKHN1bShwcm9kKG0xWzFdLCBtM1swXSksIHByb2QoLW0zWzFdLCBtMVswXSkpLCBtNFsyXSkpKSwgLW0yWzNdKSwgc2NhbGUoc3VtKHNjYWxlKHN1bShwcm9kKG0yWzFdLCBtNFswXSksIHByb2QoLW00WzFdLCBtMlswXSkpLCBtMVsyXSksIHN1bShzY2FsZShzdW0ocHJvZChtMVsxXSwgbTRbMF0pLCBwcm9kKC1tNFsxXSwgbTFbMF0pKSwgLW0yWzJdKSwgc2NhbGUoc3VtKHByb2QobTFbMV0sIG0yWzBdKSwgcHJvZCgtbTJbMV0sIG0xWzBdKSksIG00WzJdKSkpLCBtM1szXSkpKSwgc3VtKHNjYWxlKHN1bShzY2FsZShzdW0ocHJvZChtMlsxXSwgbTNbMF0pLCBwcm9kKC1tM1sxXSwgbTJbMF0pKSwgbTFbMl0pLCBzdW0oc2NhbGUoc3VtKHByb2QobTFbMV0sIG0zWzBdKSwgcHJvZCgtbTNbMV0sIG0xWzBdKSksIC1tMlsyXSksIHNjYWxlKHN1bShwcm9kKG0xWzFdLCBtMlswXSksIHByb2QoLW0yWzFdLCBtMVswXSkpLCBtM1syXSkpKSwgLW00WzNdKSwgc3VtKHNjYWxlKHN1bShzY2FsZShzdW0ocHJvZChtM1sxXSwgbTRbMF0pLCBwcm9kKC1tNFsxXSwgbTNbMF0pKSwgbTFbMl0pLCBzdW0oc2NhbGUoc3VtKHByb2QobTFbMV0sIG00WzBdKSwgcHJvZCgtbTRbMV0sIG0xWzBdKSksIC1tM1syXSksIHNjYWxlKHN1bShwcm9kKG0xWzFdLCBtM1swXSksIHByb2QoLW0zWzFdLCBtMVswXSkpLCBtNFsyXSkpKSwgbTBbM10pLCBzY2FsZShzdW0oc2NhbGUoc3VtKHByb2QobTNbMV0sIG00WzBdKSwgcHJvZCgtbTRbMV0sIG0zWzBdKSksIG0wWzJdKSwgc3VtKHNjYWxlKHN1bShwcm9kKG0wWzFdLCBtNFswXSksIHByb2QoLW00WzFdLCBtMFswXSkpLCAtbTNbMl0pLCBzY2FsZShzdW0ocHJvZChtMFsxXSwgbTNbMF0pLCBwcm9kKC1tM1sxXSwgbTBbMF0pKSwgbTRbMl0pKSksIC1tMVszXSkpKSksIHN1bShzdW0oc2NhbGUoc3VtKHNjYWxlKHN1bShwcm9kKG0xWzFdLCBtNFswXSksIHByb2QoLW00WzFdLCBtMVswXSkpLCBtMFsyXSksIHN1bShzY2FsZShzdW0ocHJvZChtMFsxXSwgbTRbMF0pLCBwcm9kKC1tNFsxXSwgbTBbMF0pKSwgLW0xWzJdKSwgc2NhbGUoc3VtKHByb2QobTBbMV0sIG0xWzBdKSwgcHJvZCgtbTFbMV0sIG0wWzBdKSksIG00WzJdKSkpLCBtM1szXSksIHN1bShzY2FsZShzdW0oc2NhbGUoc3VtKHByb2QobTFbMV0sIG0zWzBdKSwgcHJvZCgtbTNbMV0sIG0xWzBdKSksIG0wWzJdKSwgc3VtKHNjYWxlKHN1bShwcm9kKG0wWzFdLCBtM1swXSksIHByb2QoLW0zWzFdLCBtMFswXSkpLCAtbTFbMl0pLCBzY2FsZShzdW0ocHJvZChtMFsxXSwgbTFbMF0pLCBwcm9kKC1tMVsxXSwgbTBbMF0pKSwgbTNbMl0pKSksIC1tNFszXSksIHNjYWxlKHN1bShzY2FsZShzdW0ocHJvZChtMlsxXSwgbTNbMF0pLCBwcm9kKC1tM1sxXSwgbTJbMF0pKSwgbTFbMl0pLCBzdW0oc2NhbGUoc3VtKHByb2QobTFbMV0sIG0zWzBdKSwgcHJvZCgtbTNbMV0sIG0xWzBdKSksIC1tMlsyXSksIHNjYWxlKHN1bShwcm9kKG0xWzFdLCBtMlswXSksIHByb2QoLW0yWzFdLCBtMVswXSkpLCBtM1syXSkpKSwgbTBbM10pKSksIHN1bShzY2FsZShzdW0oc2NhbGUoc3VtKHByb2QobTJbMV0sIG0zWzBdKSwgcHJvZCgtbTNbMV0sIG0yWzBdKSksIG0wWzJdKSwgc3VtKHNjYWxlKHN1bShwcm9kKG0wWzFdLCBtM1swXSksIHByb2QoLW0zWzFdLCBtMFswXSkpLCAtbTJbMl0pLCBzY2FsZShzdW0ocHJvZChtMFsxXSwgbTJbMF0pLCBwcm9kKC1tMlsxXSwgbTBbMF0pKSwgbTNbMl0pKSksIC1tMVszXSksIHN1bShzY2FsZShzdW0oc2NhbGUoc3VtKHByb2QobTFbMV0sIG0zWzBdKSwgcHJvZCgtbTNbMV0sIG0xWzBdKSksIG0wWzJdKSwgc3VtKHNjYWxlKHN1bShwcm9kKG0wWzFdLCBtM1swXSksIHByb2QoLW0zWzFdLCBtMFswXSkpLCAtbTFbMl0pLCBzY2FsZShzdW0ocHJvZChtMFsxXSwgbTFbMF0pLCBwcm9kKC1tMVsxXSwgbTBbMF0pKSwgbTNbMl0pKSksIG0yWzNdKSwgc2NhbGUoc3VtKHNjYWxlKHN1bShwcm9kKG0xWzFdLCBtMlswXSksIHByb2QoLW0yWzFdLCBtMVswXSkpLCBtMFsyXSksIHN1bShzY2FsZShzdW0ocHJvZChtMFsxXSwgbTJbMF0pLCBwcm9kKC1tMlsxXSwgbTBbMF0pKSwgLW0xWzJdKSwgc2NhbGUoc3VtKHByb2QobTBbMV0sIG0xWzBdKSwgcHJvZCgtbTFbMV0sIG0wWzBdKSksIG0yWzJdKSkpLCAtbTNbM10pKSkpKVxuICAgIHZhciBuID0gc3VtKHN1bShzdW0oc2NhbGUoc3VtKHNjYWxlKHN1bShwcm9kKG0zWzFdLCBtNFswXSksIHByb2QoLW00WzFdLCBtM1swXSkpLCBtMlsyXSksIHN1bShzY2FsZShzdW0ocHJvZChtMlsxXSwgbTRbMF0pLCBwcm9kKC1tNFsxXSwgbTJbMF0pKSwgLW0zWzJdKSwgc2NhbGUoc3VtKHByb2QobTJbMV0sIG0zWzBdKSwgcHJvZCgtbTNbMV0sIG0yWzBdKSksIG00WzJdKSkpLCBtMFszXSksIHNjYWxlKHN1bShzY2FsZShzdW0ocHJvZChtM1sxXSwgbTRbMF0pLCBwcm9kKC1tNFsxXSwgbTNbMF0pKSwgbTBbMl0pLCBzdW0oc2NhbGUoc3VtKHByb2QobTBbMV0sIG00WzBdKSwgcHJvZCgtbTRbMV0sIG0wWzBdKSksIC1tM1syXSksIHNjYWxlKHN1bShwcm9kKG0wWzFdLCBtM1swXSksIHByb2QoLW0zWzFdLCBtMFswXSkpLCBtNFsyXSkpKSwgLW0yWzNdKSksIHN1bShzY2FsZShzdW0oc2NhbGUoc3VtKHByb2QobTJbMV0sIG00WzBdKSwgcHJvZCgtbTRbMV0sIG0yWzBdKSksIG0wWzJdKSwgc3VtKHNjYWxlKHN1bShwcm9kKG0wWzFdLCBtNFswXSksIHByb2QoLW00WzFdLCBtMFswXSkpLCAtbTJbMl0pLCBzY2FsZShzdW0ocHJvZChtMFsxXSwgbTJbMF0pLCBwcm9kKC1tMlsxXSwgbTBbMF0pKSwgbTRbMl0pKSksIG0zWzNdKSwgc2NhbGUoc3VtKHNjYWxlKHN1bShwcm9kKG0yWzFdLCBtM1swXSksIHByb2QoLW0zWzFdLCBtMlswXSkpLCBtMFsyXSksIHN1bShzY2FsZShzdW0ocHJvZChtMFsxXSwgbTNbMF0pLCBwcm9kKC1tM1sxXSwgbTBbMF0pKSwgLW0yWzJdKSwgc2NhbGUoc3VtKHByb2QobTBbMV0sIG0yWzBdKSwgcHJvZCgtbTJbMV0sIG0wWzBdKSksIG0zWzJdKSkpLCAtbTRbM10pKSksIHN1bShzdW0oc2NhbGUoc3VtKHNjYWxlKHN1bShwcm9kKG0yWzFdLCBtNFswXSksIHByb2QoLW00WzFdLCBtMlswXSkpLCBtMVsyXSksIHN1bShzY2FsZShzdW0ocHJvZChtMVsxXSwgbTRbMF0pLCBwcm9kKC1tNFsxXSwgbTFbMF0pKSwgLW0yWzJdKSwgc2NhbGUoc3VtKHByb2QobTFbMV0sIG0yWzBdKSwgcHJvZCgtbTJbMV0sIG0xWzBdKSksIG00WzJdKSkpLCBtMFszXSksIHNjYWxlKHN1bShzY2FsZShzdW0ocHJvZChtMlsxXSwgbTRbMF0pLCBwcm9kKC1tNFsxXSwgbTJbMF0pKSwgbTBbMl0pLCBzdW0oc2NhbGUoc3VtKHByb2QobTBbMV0sIG00WzBdKSwgcHJvZCgtbTRbMV0sIG0wWzBdKSksIC1tMlsyXSksIHNjYWxlKHN1bShwcm9kKG0wWzFdLCBtMlswXSksIHByb2QoLW0yWzFdLCBtMFswXSkpLCBtNFsyXSkpKSwgLW0xWzNdKSksIHN1bShzY2FsZShzdW0oc2NhbGUoc3VtKHByb2QobTFbMV0sIG00WzBdKSwgcHJvZCgtbTRbMV0sIG0xWzBdKSksIG0wWzJdKSwgc3VtKHNjYWxlKHN1bShwcm9kKG0wWzFdLCBtNFswXSksIHByb2QoLW00WzFdLCBtMFswXSkpLCAtbTFbMl0pLCBzY2FsZShzdW0ocHJvZChtMFsxXSwgbTFbMF0pLCBwcm9kKC1tMVsxXSwgbTBbMF0pKSwgbTRbMl0pKSksIG0yWzNdKSwgc2NhbGUoc3VtKHNjYWxlKHN1bShwcm9kKG0xWzFdLCBtMlswXSksIHByb2QoLW0yWzFdLCBtMVswXSkpLCBtMFsyXSksIHN1bShzY2FsZShzdW0ocHJvZChtMFsxXSwgbTJbMF0pLCBwcm9kKC1tMlsxXSwgbTBbMF0pKSwgLW0xWzJdKSwgc2NhbGUoc3VtKHByb2QobTBbMV0sIG0xWzBdKSwgcHJvZCgtbTFbMV0sIG0wWzBdKSksIG0yWzJdKSkpLCAtbTRbM10pKSkpXG4gICAgdmFyIGQgPSBzdWIocCwgbilcbiAgICByZXR1cm4gZFtkLmxlbmd0aCAtIDFdXG4gIH1cbn1cblxuZnVuY3Rpb24gb3JpZW50YXRpb24obikge1xuICB2YXIgZm4gPVxuICAgIG4gPT09IDMgPyBvcmllbnRhdGlvbl8zIDpcbiAgICBuID09PSA0ID8gb3JpZW50YXRpb25fNCA6IG9yaWVudGF0aW9uXzVcblxuICByZXR1cm4gZm4ocm9idXN0U3VtLCB0d29Qcm9kdWN0LCByb2J1c3RTY2FsZSwgcm9idXN0U3VidHJhY3QpXG59XG5cbnZhciBvcmllbnRhdGlvbjNFeGFjdCA9IG9yaWVudGF0aW9uKDMpXG52YXIgb3JpZW50YXRpb240RXhhY3QgPSBvcmllbnRhdGlvbig0KVxuXG52YXIgQ0FDSEVEID0gW1xuICBmdW5jdGlvbiBvcmllbnRhdGlvbjAoKSB7IHJldHVybiAwIH0sXG4gIGZ1bmN0aW9uIG9yaWVudGF0aW9uMSgpIHsgcmV0dXJuIDAgfSxcbiAgZnVuY3Rpb24gb3JpZW50YXRpb24yKGEsIGIpIHtcbiAgICByZXR1cm4gYlswXSAtIGFbMF1cbiAgfSxcbiAgZnVuY3Rpb24gb3JpZW50YXRpb24zKGEsIGIsIGMpIHtcbiAgICB2YXIgbCA9IChhWzFdIC0gY1sxXSkgKiAoYlswXSAtIGNbMF0pXG4gICAgdmFyIHIgPSAoYVswXSAtIGNbMF0pICogKGJbMV0gLSBjWzFdKVxuICAgIHZhciBkZXQgPSBsIC0gclxuICAgIHZhciBzXG4gICAgaWYobCA+IDApIHtcbiAgICAgIGlmKHIgPD0gMCkge1xuICAgICAgICByZXR1cm4gZGV0XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzID0gbCArIHJcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYobCA8IDApIHtcbiAgICAgIGlmKHIgPj0gMCkge1xuICAgICAgICByZXR1cm4gZGV0XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzID0gLShsICsgcilcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGRldFxuICAgIH1cbiAgICB2YXIgdG9sID0gRVJSQk9VTkQzICogc1xuICAgIGlmKGRldCA+PSB0b2wgfHwgZGV0IDw9IC10b2wpIHtcbiAgICAgIHJldHVybiBkZXRcbiAgICB9XG4gICAgcmV0dXJuIG9yaWVudGF0aW9uM0V4YWN0KGEsIGIsIGMpXG4gIH0sXG4gIGZ1bmN0aW9uIG9yaWVudGF0aW9uNChhLGIsYyxkKSB7XG4gICAgdmFyIGFkeCA9IGFbMF0gLSBkWzBdXG4gICAgdmFyIGJkeCA9IGJbMF0gLSBkWzBdXG4gICAgdmFyIGNkeCA9IGNbMF0gLSBkWzBdXG4gICAgdmFyIGFkeSA9IGFbMV0gLSBkWzFdXG4gICAgdmFyIGJkeSA9IGJbMV0gLSBkWzFdXG4gICAgdmFyIGNkeSA9IGNbMV0gLSBkWzFdXG4gICAgdmFyIGFkeiA9IGFbMl0gLSBkWzJdXG4gICAgdmFyIGJkeiA9IGJbMl0gLSBkWzJdXG4gICAgdmFyIGNkeiA9IGNbMl0gLSBkWzJdXG4gICAgdmFyIGJkeGNkeSA9IGJkeCAqIGNkeVxuICAgIHZhciBjZHhiZHkgPSBjZHggKiBiZHlcbiAgICB2YXIgY2R4YWR5ID0gY2R4ICogYWR5XG4gICAgdmFyIGFkeGNkeSA9IGFkeCAqIGNkeVxuICAgIHZhciBhZHhiZHkgPSBhZHggKiBiZHlcbiAgICB2YXIgYmR4YWR5ID0gYmR4ICogYWR5XG4gICAgdmFyIGRldCA9IGFkeiAqIChiZHhjZHkgLSBjZHhiZHkpXG4gICAgICAgICAgICArIGJkeiAqIChjZHhhZHkgLSBhZHhjZHkpXG4gICAgICAgICAgICArIGNkeiAqIChhZHhiZHkgLSBiZHhhZHkpXG4gICAgdmFyIHBlcm1hbmVudCA9IChNYXRoLmFicyhiZHhjZHkpICsgTWF0aC5hYnMoY2R4YmR5KSkgKiBNYXRoLmFicyhhZHopXG4gICAgICAgICAgICAgICAgICArIChNYXRoLmFicyhjZHhhZHkpICsgTWF0aC5hYnMoYWR4Y2R5KSkgKiBNYXRoLmFicyhiZHopXG4gICAgICAgICAgICAgICAgICArIChNYXRoLmFicyhhZHhiZHkpICsgTWF0aC5hYnMoYmR4YWR5KSkgKiBNYXRoLmFicyhjZHopXG4gICAgdmFyIHRvbCA9IEVSUkJPVU5ENCAqIHBlcm1hbmVudFxuICAgIGlmICgoZGV0ID4gdG9sKSB8fCAoLWRldCA+IHRvbCkpIHtcbiAgICAgIHJldHVybiBkZXRcbiAgICB9XG4gICAgcmV0dXJuIG9yaWVudGF0aW9uNEV4YWN0KGEsYixjLGQpXG4gIH1cbl1cblxuZnVuY3Rpb24gc2xvd09yaWVudChhcmdzKSB7XG4gIHZhciBwcm9jID0gQ0FDSEVEW2FyZ3MubGVuZ3RoXVxuICBpZighcHJvYykge1xuICAgIHByb2MgPSBDQUNIRURbYXJncy5sZW5ndGhdID0gb3JpZW50YXRpb24oYXJncy5sZW5ndGgpXG4gIH1cbiAgcmV0dXJuIHByb2MuYXBwbHkodW5kZWZpbmVkLCBhcmdzKVxufVxuXG5mdW5jdGlvbiBwcm9jIChzbG93LCBvMCwgbzEsIG8yLCBvMywgbzQsIG81KSB7XG4gIHJldHVybiBmdW5jdGlvbiBnZXRPcmllbnRhdGlvbihhMCwgYTEsIGEyLCBhMywgYTQpIHtcbiAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIHJldHVybiBvMihhMCwgYTEpXG4gICAgICBjYXNlIDM6XG4gICAgICAgIHJldHVybiBvMyhhMCwgYTEsIGEyKVxuICAgICAgY2FzZSA0OlxuICAgICAgICByZXR1cm4gbzQoYTAsIGExLCBhMiwgYTMpXG4gICAgICBjYXNlIDU6XG4gICAgICAgIHJldHVybiBvNShhMCwgYTEsIGEyLCBhMywgYTQpXG4gICAgfVxuXG4gICAgdmFyIHMgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aClcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7ICsraSkge1xuICAgICAgc1tpXSA9IGFyZ3VtZW50c1tpXVxuICAgIH1cbiAgICByZXR1cm4gc2xvdyhzKVxuICB9XG59XG5cbmZ1bmN0aW9uIGdlbmVyYXRlT3JpZW50YXRpb25Qcm9jKCkge1xuICB3aGlsZShDQUNIRUQubGVuZ3RoIDw9IE5VTV9FWFBBTkQpIHtcbiAgICBDQUNIRUQucHVzaChvcmllbnRhdGlvbihDQUNIRUQubGVuZ3RoKSlcbiAgfVxuICBtb2R1bGUuZXhwb3J0cyA9IHByb2MuYXBwbHkodW5kZWZpbmVkLCBbc2xvd09yaWVudF0uY29uY2F0KENBQ0hFRCkpXG4gIGZvcih2YXIgaT0wOyBpPD1OVU1fRVhQQU5EOyArK2kpIHtcbiAgICBtb2R1bGUuZXhwb3J0c1tpXSA9IENBQ0hFRFtpXVxuICB9XG59XG5cbmdlbmVyYXRlT3JpZW50YXRpb25Qcm9jKCkiLCJcInVzZSBzdHJpY3RcIlxuXG52YXIgcm9idXN0U3VtID0gcmVxdWlyZShcInJvYnVzdC1zdW1cIilcbnZhciByb2J1c3RTY2FsZSA9IHJlcXVpcmUoXCJyb2J1c3Qtc2NhbGVcIilcblxubW9kdWxlLmV4cG9ydHMgPSByb2J1c3RQcm9kdWN0XG5cbmZ1bmN0aW9uIHJvYnVzdFByb2R1Y3QoYSwgYikge1xuICBpZihhLmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiByb2J1c3RTY2FsZShiLCBhWzBdKVxuICB9XG4gIGlmKGIubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIHJvYnVzdFNjYWxlKGEsIGJbMF0pXG4gIH1cbiAgaWYoYS5sZW5ndGggPT09IDAgfHwgYi5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gWzBdXG4gIH1cbiAgdmFyIHIgPSBbMF1cbiAgaWYoYS5sZW5ndGggPCBiLmxlbmd0aCkge1xuICAgIGZvcih2YXIgaT0wOyBpPGEubGVuZ3RoOyArK2kpIHtcbiAgICAgIHIgPSByb2J1c3RTdW0ociwgcm9idXN0U2NhbGUoYiwgYVtpXSkpXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZvcih2YXIgaT0wOyBpPGIubGVuZ3RoOyArK2kpIHtcbiAgICAgIHIgPSByb2J1c3RTdW0ociwgcm9idXN0U2NhbGUoYSwgYltpXSkpXG4gICAgfSAgICBcbiAgfVxuICByZXR1cm4gclxufSIsIlwidXNlIHN0cmljdFwiXG5cbnZhciB0d29Qcm9kdWN0ID0gcmVxdWlyZShcInR3by1wcm9kdWN0XCIpXG52YXIgdHdvU3VtID0gcmVxdWlyZShcInR3by1zdW1cIilcblxubW9kdWxlLmV4cG9ydHMgPSBzY2FsZUxpbmVhckV4cGFuc2lvblxuXG5mdW5jdGlvbiBzY2FsZUxpbmVhckV4cGFuc2lvbihlLCBzY2FsZSkge1xuICB2YXIgbiA9IGUubGVuZ3RoXG4gIGlmKG4gPT09IDEpIHtcbiAgICB2YXIgdHMgPSB0d29Qcm9kdWN0KGVbMF0sIHNjYWxlKVxuICAgIGlmKHRzWzBdKSB7XG4gICAgICByZXR1cm4gdHNcbiAgICB9XG4gICAgcmV0dXJuIFsgdHNbMV0gXVxuICB9XG4gIHZhciBnID0gbmV3IEFycmF5KDIgKiBuKVxuICB2YXIgcSA9IFswLjEsIDAuMV1cbiAgdmFyIHQgPSBbMC4xLCAwLjFdXG4gIHZhciBjb3VudCA9IDBcbiAgdHdvUHJvZHVjdChlWzBdLCBzY2FsZSwgcSlcbiAgaWYocVswXSkge1xuICAgIGdbY291bnQrK10gPSBxWzBdXG4gIH1cbiAgZm9yKHZhciBpPTE7IGk8bjsgKytpKSB7XG4gICAgdHdvUHJvZHVjdChlW2ldLCBzY2FsZSwgdClcbiAgICB2YXIgcHEgPSBxWzFdXG4gICAgdHdvU3VtKHBxLCB0WzBdLCBxKVxuICAgIGlmKHFbMF0pIHtcbiAgICAgIGdbY291bnQrK10gPSBxWzBdXG4gICAgfVxuICAgIHZhciBhID0gdFsxXVxuICAgIHZhciBiID0gcVsxXVxuICAgIHZhciB4ID0gYSArIGJcbiAgICB2YXIgYnYgPSB4IC0gYVxuICAgIHZhciB5ID0gYiAtIGJ2XG4gICAgcVsxXSA9IHhcbiAgICBpZih5KSB7XG4gICAgICBnW2NvdW50KytdID0geVxuICAgIH1cbiAgfVxuICBpZihxWzFdKSB7XG4gICAgZ1tjb3VudCsrXSA9IHFbMV1cbiAgfVxuICBpZihjb3VudCA9PT0gMCkge1xuICAgIGdbY291bnQrK10gPSAwLjBcbiAgfVxuICBnLmxlbmd0aCA9IGNvdW50XG4gIHJldHVybiBnXG59IiwiXCJ1c2Ugc3RyaWN0XCJcblxubW9kdWxlLmV4cG9ydHMgPSBzZWdtZW50c0ludGVyc2VjdFxuXG52YXIgb3JpZW50ID0gcmVxdWlyZShcInJvYnVzdC1vcmllbnRhdGlvblwiKVszXVxuXG5mdW5jdGlvbiBjaGVja0NvbGxpbmVhcihhMCwgYTEsIGIwLCBiMSkge1xuXG4gIGZvcih2YXIgZD0wOyBkPDI7ICsrZCkge1xuICAgIHZhciB4MCA9IGEwW2RdXG4gICAgdmFyIHkwID0gYTFbZF1cbiAgICB2YXIgbDAgPSBNYXRoLm1pbih4MCwgeTApXG4gICAgdmFyIGgwID0gTWF0aC5tYXgoeDAsIHkwKSAgICBcblxuICAgIHZhciB4MSA9IGIwW2RdXG4gICAgdmFyIHkxID0gYjFbZF1cbiAgICB2YXIgbDEgPSBNYXRoLm1pbih4MSwgeTEpXG4gICAgdmFyIGgxID0gTWF0aC5tYXgoeDEsIHkxKSAgICBcblxuICAgIGlmKGgxIDwgbDAgfHwgaDAgPCBsMSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWVcbn1cblxuZnVuY3Rpb24gc2VnbWVudHNJbnRlcnNlY3QoYTAsIGExLCBiMCwgYjEpIHtcbiAgdmFyIHgwID0gb3JpZW50KGEwLCBiMCwgYjEpXG4gIHZhciB5MCA9IG9yaWVudChhMSwgYjAsIGIxKVxuICBpZigoeDAgPiAwICYmIHkwID4gMCkgfHwgKHgwIDwgMCAmJiB5MCA8IDApKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICB2YXIgeDEgPSBvcmllbnQoYjAsIGEwLCBhMSlcbiAgdmFyIHkxID0gb3JpZW50KGIxLCBhMCwgYTEpXG4gIGlmKCh4MSA+IDAgJiYgeTEgPiAwKSB8fCAoeDEgPCAwICYmIHkxIDwgMCkpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIC8vQ2hlY2sgZm9yIGRlZ2VuZXJhdGUgY29sbGluZWFyIGNhc2VcbiAgaWYoeDAgPT09IDAgJiYgeTAgPT09IDAgJiYgeDEgPT09IDAgJiYgeTEgPT09IDApIHtcbiAgICByZXR1cm4gY2hlY2tDb2xsaW5lYXIoYTAsIGExLCBiMCwgYjEpXG4gIH1cblxuICByZXR1cm4gdHJ1ZVxufSIsIlwidXNlIHN0cmljdFwiXG5cbm1vZHVsZS5leHBvcnRzID0gcm9idXN0U3VidHJhY3RcblxuLy9FYXN5IGNhc2U6IEFkZCB0d28gc2NhbGFyc1xuZnVuY3Rpb24gc2NhbGFyU2NhbGFyKGEsIGIpIHtcbiAgdmFyIHggPSBhICsgYlxuICB2YXIgYnYgPSB4IC0gYVxuICB2YXIgYXYgPSB4IC0gYnZcbiAgdmFyIGJyID0gYiAtIGJ2XG4gIHZhciBhciA9IGEgLSBhdlxuICB2YXIgeSA9IGFyICsgYnJcbiAgaWYoeSkge1xuICAgIHJldHVybiBbeSwgeF1cbiAgfVxuICByZXR1cm4gW3hdXG59XG5cbmZ1bmN0aW9uIHJvYnVzdFN1YnRyYWN0KGUsIGYpIHtcbiAgdmFyIG5lID0gZS5sZW5ndGh8MFxuICB2YXIgbmYgPSBmLmxlbmd0aHwwXG4gIGlmKG5lID09PSAxICYmIG5mID09PSAxKSB7XG4gICAgcmV0dXJuIHNjYWxhclNjYWxhcihlWzBdLCAtZlswXSlcbiAgfVxuICB2YXIgbiA9IG5lICsgbmZcbiAgdmFyIGcgPSBuZXcgQXJyYXkobilcbiAgdmFyIGNvdW50ID0gMFxuICB2YXIgZXB0ciA9IDBcbiAgdmFyIGZwdHIgPSAwXG4gIHZhciBhYnMgPSBNYXRoLmFic1xuICB2YXIgZWkgPSBlW2VwdHJdXG4gIHZhciBlYSA9IGFicyhlaSlcbiAgdmFyIGZpID0gLWZbZnB0cl1cbiAgdmFyIGZhID0gYWJzKGZpKVxuICB2YXIgYSwgYlxuICBpZihlYSA8IGZhKSB7XG4gICAgYiA9IGVpXG4gICAgZXB0ciArPSAxXG4gICAgaWYoZXB0ciA8IG5lKSB7XG4gICAgICBlaSA9IGVbZXB0cl1cbiAgICAgIGVhID0gYWJzKGVpKVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBiID0gZmlcbiAgICBmcHRyICs9IDFcbiAgICBpZihmcHRyIDwgbmYpIHtcbiAgICAgIGZpID0gLWZbZnB0cl1cbiAgICAgIGZhID0gYWJzKGZpKVxuICAgIH1cbiAgfVxuICBpZigoZXB0ciA8IG5lICYmIGVhIDwgZmEpIHx8IChmcHRyID49IG5mKSkge1xuICAgIGEgPSBlaVxuICAgIGVwdHIgKz0gMVxuICAgIGlmKGVwdHIgPCBuZSkge1xuICAgICAgZWkgPSBlW2VwdHJdXG4gICAgICBlYSA9IGFicyhlaSlcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgYSA9IGZpXG4gICAgZnB0ciArPSAxXG4gICAgaWYoZnB0ciA8IG5mKSB7XG4gICAgICBmaSA9IC1mW2ZwdHJdXG4gICAgICBmYSA9IGFicyhmaSlcbiAgICB9XG4gIH1cbiAgdmFyIHggPSBhICsgYlxuICB2YXIgYnYgPSB4IC0gYVxuICB2YXIgeSA9IGIgLSBidlxuICB2YXIgcTAgPSB5XG4gIHZhciBxMSA9IHhcbiAgdmFyIF94LCBfYnYsIF9hdiwgX2JyLCBfYXJcbiAgd2hpbGUoZXB0ciA8IG5lICYmIGZwdHIgPCBuZikge1xuICAgIGlmKGVhIDwgZmEpIHtcbiAgICAgIGEgPSBlaVxuICAgICAgZXB0ciArPSAxXG4gICAgICBpZihlcHRyIDwgbmUpIHtcbiAgICAgICAgZWkgPSBlW2VwdHJdXG4gICAgICAgIGVhID0gYWJzKGVpKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBhID0gZmlcbiAgICAgIGZwdHIgKz0gMVxuICAgICAgaWYoZnB0ciA8IG5mKSB7XG4gICAgICAgIGZpID0gLWZbZnB0cl1cbiAgICAgICAgZmEgPSBhYnMoZmkpXG4gICAgICB9XG4gICAgfVxuICAgIGIgPSBxMFxuICAgIHggPSBhICsgYlxuICAgIGJ2ID0geCAtIGFcbiAgICB5ID0gYiAtIGJ2XG4gICAgaWYoeSkge1xuICAgICAgZ1tjb3VudCsrXSA9IHlcbiAgICB9XG4gICAgX3ggPSBxMSArIHhcbiAgICBfYnYgPSBfeCAtIHExXG4gICAgX2F2ID0gX3ggLSBfYnZcbiAgICBfYnIgPSB4IC0gX2J2XG4gICAgX2FyID0gcTEgLSBfYXZcbiAgICBxMCA9IF9hciArIF9iclxuICAgIHExID0gX3hcbiAgfVxuICB3aGlsZShlcHRyIDwgbmUpIHtcbiAgICBhID0gZWlcbiAgICBiID0gcTBcbiAgICB4ID0gYSArIGJcbiAgICBidiA9IHggLSBhXG4gICAgeSA9IGIgLSBidlxuICAgIGlmKHkpIHtcbiAgICAgIGdbY291bnQrK10gPSB5XG4gICAgfVxuICAgIF94ID0gcTEgKyB4XG4gICAgX2J2ID0gX3ggLSBxMVxuICAgIF9hdiA9IF94IC0gX2J2XG4gICAgX2JyID0geCAtIF9idlxuICAgIF9hciA9IHExIC0gX2F2XG4gICAgcTAgPSBfYXIgKyBfYnJcbiAgICBxMSA9IF94XG4gICAgZXB0ciArPSAxXG4gICAgaWYoZXB0ciA8IG5lKSB7XG4gICAgICBlaSA9IGVbZXB0cl1cbiAgICB9XG4gIH1cbiAgd2hpbGUoZnB0ciA8IG5mKSB7XG4gICAgYSA9IGZpXG4gICAgYiA9IHEwXG4gICAgeCA9IGEgKyBiXG4gICAgYnYgPSB4IC0gYVxuICAgIHkgPSBiIC0gYnZcbiAgICBpZih5KSB7XG4gICAgICBnW2NvdW50KytdID0geVxuICAgIH0gXG4gICAgX3ggPSBxMSArIHhcbiAgICBfYnYgPSBfeCAtIHExXG4gICAgX2F2ID0gX3ggLSBfYnZcbiAgICBfYnIgPSB4IC0gX2J2XG4gICAgX2FyID0gcTEgLSBfYXZcbiAgICBxMCA9IF9hciArIF9iclxuICAgIHExID0gX3hcbiAgICBmcHRyICs9IDFcbiAgICBpZihmcHRyIDwgbmYpIHtcbiAgICAgIGZpID0gLWZbZnB0cl1cbiAgICB9XG4gIH1cbiAgaWYocTApIHtcbiAgICBnW2NvdW50KytdID0gcTBcbiAgfVxuICBpZihxMSkge1xuICAgIGdbY291bnQrK10gPSBxMVxuICB9XG4gIGlmKCFjb3VudCkge1xuICAgIGdbY291bnQrK10gPSAwLjAgIFxuICB9XG4gIGcubGVuZ3RoID0gY291bnRcbiAgcmV0dXJuIGdcbn0iLCJcInVzZSBzdHJpY3RcIlxuXG5tb2R1bGUuZXhwb3J0cyA9IGxpbmVhckV4cGFuc2lvblN1bVxuXG4vL0Vhc3kgY2FzZTogQWRkIHR3byBzY2FsYXJzXG5mdW5jdGlvbiBzY2FsYXJTY2FsYXIoYSwgYikge1xuICB2YXIgeCA9IGEgKyBiXG4gIHZhciBidiA9IHggLSBhXG4gIHZhciBhdiA9IHggLSBidlxuICB2YXIgYnIgPSBiIC0gYnZcbiAgdmFyIGFyID0gYSAtIGF2XG4gIHZhciB5ID0gYXIgKyBiclxuICBpZih5KSB7XG4gICAgcmV0dXJuIFt5LCB4XVxuICB9XG4gIHJldHVybiBbeF1cbn1cblxuZnVuY3Rpb24gbGluZWFyRXhwYW5zaW9uU3VtKGUsIGYpIHtcbiAgdmFyIG5lID0gZS5sZW5ndGh8MFxuICB2YXIgbmYgPSBmLmxlbmd0aHwwXG4gIGlmKG5lID09PSAxICYmIG5mID09PSAxKSB7XG4gICAgcmV0dXJuIHNjYWxhclNjYWxhcihlWzBdLCBmWzBdKVxuICB9XG4gIHZhciBuID0gbmUgKyBuZlxuICB2YXIgZyA9IG5ldyBBcnJheShuKVxuICB2YXIgY291bnQgPSAwXG4gIHZhciBlcHRyID0gMFxuICB2YXIgZnB0ciA9IDBcbiAgdmFyIGFicyA9IE1hdGguYWJzXG4gIHZhciBlaSA9IGVbZXB0cl1cbiAgdmFyIGVhID0gYWJzKGVpKVxuICB2YXIgZmkgPSBmW2ZwdHJdXG4gIHZhciBmYSA9IGFicyhmaSlcbiAgdmFyIGEsIGJcbiAgaWYoZWEgPCBmYSkge1xuICAgIGIgPSBlaVxuICAgIGVwdHIgKz0gMVxuICAgIGlmKGVwdHIgPCBuZSkge1xuICAgICAgZWkgPSBlW2VwdHJdXG4gICAgICBlYSA9IGFicyhlaSlcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgYiA9IGZpXG4gICAgZnB0ciArPSAxXG4gICAgaWYoZnB0ciA8IG5mKSB7XG4gICAgICBmaSA9IGZbZnB0cl1cbiAgICAgIGZhID0gYWJzKGZpKVxuICAgIH1cbiAgfVxuICBpZigoZXB0ciA8IG5lICYmIGVhIDwgZmEpIHx8IChmcHRyID49IG5mKSkge1xuICAgIGEgPSBlaVxuICAgIGVwdHIgKz0gMVxuICAgIGlmKGVwdHIgPCBuZSkge1xuICAgICAgZWkgPSBlW2VwdHJdXG4gICAgICBlYSA9IGFicyhlaSlcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgYSA9IGZpXG4gICAgZnB0ciArPSAxXG4gICAgaWYoZnB0ciA8IG5mKSB7XG4gICAgICBmaSA9IGZbZnB0cl1cbiAgICAgIGZhID0gYWJzKGZpKVxuICAgIH1cbiAgfVxuICB2YXIgeCA9IGEgKyBiXG4gIHZhciBidiA9IHggLSBhXG4gIHZhciB5ID0gYiAtIGJ2XG4gIHZhciBxMCA9IHlcbiAgdmFyIHExID0geFxuICB2YXIgX3gsIF9idiwgX2F2LCBfYnIsIF9hclxuICB3aGlsZShlcHRyIDwgbmUgJiYgZnB0ciA8IG5mKSB7XG4gICAgaWYoZWEgPCBmYSkge1xuICAgICAgYSA9IGVpXG4gICAgICBlcHRyICs9IDFcbiAgICAgIGlmKGVwdHIgPCBuZSkge1xuICAgICAgICBlaSA9IGVbZXB0cl1cbiAgICAgICAgZWEgPSBhYnMoZWkpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGEgPSBmaVxuICAgICAgZnB0ciArPSAxXG4gICAgICBpZihmcHRyIDwgbmYpIHtcbiAgICAgICAgZmkgPSBmW2ZwdHJdXG4gICAgICAgIGZhID0gYWJzKGZpKVxuICAgICAgfVxuICAgIH1cbiAgICBiID0gcTBcbiAgICB4ID0gYSArIGJcbiAgICBidiA9IHggLSBhXG4gICAgeSA9IGIgLSBidlxuICAgIGlmKHkpIHtcbiAgICAgIGdbY291bnQrK10gPSB5XG4gICAgfVxuICAgIF94ID0gcTEgKyB4XG4gICAgX2J2ID0gX3ggLSBxMVxuICAgIF9hdiA9IF94IC0gX2J2XG4gICAgX2JyID0geCAtIF9idlxuICAgIF9hciA9IHExIC0gX2F2XG4gICAgcTAgPSBfYXIgKyBfYnJcbiAgICBxMSA9IF94XG4gIH1cbiAgd2hpbGUoZXB0ciA8IG5lKSB7XG4gICAgYSA9IGVpXG4gICAgYiA9IHEwXG4gICAgeCA9IGEgKyBiXG4gICAgYnYgPSB4IC0gYVxuICAgIHkgPSBiIC0gYnZcbiAgICBpZih5KSB7XG4gICAgICBnW2NvdW50KytdID0geVxuICAgIH1cbiAgICBfeCA9IHExICsgeFxuICAgIF9idiA9IF94IC0gcTFcbiAgICBfYXYgPSBfeCAtIF9idlxuICAgIF9iciA9IHggLSBfYnZcbiAgICBfYXIgPSBxMSAtIF9hdlxuICAgIHEwID0gX2FyICsgX2JyXG4gICAgcTEgPSBfeFxuICAgIGVwdHIgKz0gMVxuICAgIGlmKGVwdHIgPCBuZSkge1xuICAgICAgZWkgPSBlW2VwdHJdXG4gICAgfVxuICB9XG4gIHdoaWxlKGZwdHIgPCBuZikge1xuICAgIGEgPSBmaVxuICAgIGIgPSBxMFxuICAgIHggPSBhICsgYlxuICAgIGJ2ID0geCAtIGFcbiAgICB5ID0gYiAtIGJ2XG4gICAgaWYoeSkge1xuICAgICAgZ1tjb3VudCsrXSA9IHlcbiAgICB9IFxuICAgIF94ID0gcTEgKyB4XG4gICAgX2J2ID0gX3ggLSBxMVxuICAgIF9hdiA9IF94IC0gX2J2XG4gICAgX2JyID0geCAtIF9idlxuICAgIF9hciA9IHExIC0gX2F2XG4gICAgcTAgPSBfYXIgKyBfYnJcbiAgICBxMSA9IF94XG4gICAgZnB0ciArPSAxXG4gICAgaWYoZnB0ciA8IG5mKSB7XG4gICAgICBmaSA9IGZbZnB0cl1cbiAgICB9XG4gIH1cbiAgaWYocTApIHtcbiAgICBnW2NvdW50KytdID0gcTBcbiAgfVxuICBpZihxMSkge1xuICAgIGdbY291bnQrK10gPSBxMVxuICB9XG4gIGlmKCFjb3VudCkge1xuICAgIGdbY291bnQrK10gPSAwLjAgIFxuICB9XG4gIGcubGVuZ3RoID0gY291bnRcbiAgcmV0dXJuIGdcbn0iLCJcInVzZSBzdHJpY3RcIlxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHNpZ251bSh4KSB7XG4gIGlmKHggPCAwKSB7IHJldHVybiAtMSB9XG4gIGlmKHggPiAwKSB7IHJldHVybiAxIH1cbiAgcmV0dXJuIDAuMFxufSIsIlwidXNlIHN0cmljdFwiOyBcInVzZSByZXN0cmljdFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFVuaW9uRmluZDtcblxuZnVuY3Rpb24gVW5pb25GaW5kKGNvdW50KSB7XG4gIHRoaXMucm9vdHMgPSBuZXcgQXJyYXkoY291bnQpO1xuICB0aGlzLnJhbmtzID0gbmV3IEFycmF5KGNvdW50KTtcbiAgXG4gIGZvcih2YXIgaT0wOyBpPGNvdW50OyArK2kpIHtcbiAgICB0aGlzLnJvb3RzW2ldID0gaTtcbiAgICB0aGlzLnJhbmtzW2ldID0gMDtcbiAgfVxufVxuXG5VbmlvbkZpbmQucHJvdG90eXBlLmxlbmd0aCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5yb290cy5sZW5ndGg7XG59XG5cblVuaW9uRmluZC5wcm90b3R5cGUubWFrZVNldCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgbiA9IHRoaXMucm9vdHMubGVuZ3RoO1xuICB0aGlzLnJvb3RzLnB1c2gobik7XG4gIHRoaXMucmFua3MucHVzaCgwKTtcbiAgcmV0dXJuIG47XG59XG5cblVuaW9uRmluZC5wcm90b3R5cGUuZmluZCA9IGZ1bmN0aW9uKHgpIHtcbiAgdmFyIHJvb3RzID0gdGhpcy5yb290cztcbiAgd2hpbGUocm9vdHNbeF0gIT09IHgpIHtcbiAgICB2YXIgeSA9IHJvb3RzW3hdO1xuICAgIHJvb3RzW3hdID0gcm9vdHNbeV07XG4gICAgeCA9IHk7XG4gIH1cbiAgcmV0dXJuIHg7XG59XG5cblVuaW9uRmluZC5wcm90b3R5cGUubGluayA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgdmFyIHhyID0gdGhpcy5maW5kKHgpXG4gICAgLCB5ciA9IHRoaXMuZmluZCh5KTtcbiAgaWYoeHIgPT09IHlyKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciByYW5rcyA9IHRoaXMucmFua3NcbiAgICAsIHJvb3RzID0gdGhpcy5yb290c1xuICAgICwgeGQgICAgPSByYW5rc1t4cl1cbiAgICAsIHlkICAgID0gcmFua3NbeXJdO1xuICBpZih4ZCA8IHlkKSB7XG4gICAgcm9vdHNbeHJdID0geXI7XG4gIH0gZWxzZSBpZih5ZCA8IHhkKSB7XG4gICAgcm9vdHNbeXJdID0geHI7XG4gIH0gZWxzZSB7XG4gICAgcm9vdHNbeXJdID0geHI7XG4gICAgKytyYW5rc1t4cl07XG4gIH1cbn1cblxuIiwiXCJ1c2Ugc3RyaWN0XCI7IFwidXNlIHJlc3RyaWN0XCI7XG5cbnZhciBiaXRzICAgICAgPSByZXF1aXJlKFwiYml0LXR3aWRkbGVcIilcbiAgLCBVbmlvbkZpbmQgPSByZXF1aXJlKFwidW5pb24tZmluZFwiKVxuXG4vL1JldHVybnMgdGhlIGRpbWVuc2lvbiBvZiBhIGNlbGwgY29tcGxleFxuZnVuY3Rpb24gZGltZW5zaW9uKGNlbGxzKSB7XG4gIHZhciBkID0gMFxuICAgICwgbWF4ID0gTWF0aC5tYXhcbiAgZm9yKHZhciBpPTAsIGlsPWNlbGxzLmxlbmd0aDsgaTxpbDsgKytpKSB7XG4gICAgZCA9IG1heChkLCBjZWxsc1tpXS5sZW5ndGgpXG4gIH1cbiAgcmV0dXJuIGQtMVxufVxuZXhwb3J0cy5kaW1lbnNpb24gPSBkaW1lbnNpb25cblxuLy9Db3VudHMgdGhlIG51bWJlciBvZiB2ZXJ0aWNlcyBpbiBmYWNlc1xuZnVuY3Rpb24gY291bnRWZXJ0aWNlcyhjZWxscykge1xuICB2YXIgdmMgPSAtMVxuICAgICwgbWF4ID0gTWF0aC5tYXhcbiAgZm9yKHZhciBpPTAsIGlsPWNlbGxzLmxlbmd0aDsgaTxpbDsgKytpKSB7XG4gICAgdmFyIGMgPSBjZWxsc1tpXVxuICAgIGZvcih2YXIgaj0wLCBqbD1jLmxlbmd0aDsgajxqbDsgKytqKSB7XG4gICAgICB2YyA9IG1heCh2YywgY1tqXSlcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHZjKzFcbn1cbmV4cG9ydHMuY291bnRWZXJ0aWNlcyA9IGNvdW50VmVydGljZXNcblxuLy9SZXR1cm5zIGEgZGVlcCBjb3B5IG9mIGNlbGxzXG5mdW5jdGlvbiBjbG9uZUNlbGxzKGNlbGxzKSB7XG4gIHZhciBuY2VsbHMgPSBuZXcgQXJyYXkoY2VsbHMubGVuZ3RoKVxuICBmb3IodmFyIGk9MCwgaWw9Y2VsbHMubGVuZ3RoOyBpPGlsOyArK2kpIHtcbiAgICBuY2VsbHNbaV0gPSBjZWxsc1tpXS5zbGljZSgwKVxuICB9XG4gIHJldHVybiBuY2VsbHNcbn1cbmV4cG9ydHMuY2xvbmVDZWxscyA9IGNsb25lQ2VsbHNcblxuLy9SYW5rcyBhIHBhaXIgb2YgY2VsbHMgdXAgdG8gcGVybXV0YXRpb25cbmZ1bmN0aW9uIGNvbXBhcmVDZWxscyhhLCBiKSB7XG4gIHZhciBuID0gYS5sZW5ndGhcbiAgICAsIHQgPSBhLmxlbmd0aCAtIGIubGVuZ3RoXG4gICAgLCBtaW4gPSBNYXRoLm1pblxuICBpZih0KSB7XG4gICAgcmV0dXJuIHRcbiAgfVxuICBzd2l0Y2gobikge1xuICAgIGNhc2UgMDpcbiAgICAgIHJldHVybiAwO1xuICAgIGNhc2UgMTpcbiAgICAgIHJldHVybiBhWzBdIC0gYlswXTtcbiAgICBjYXNlIDI6XG4gICAgICB2YXIgZCA9IGFbMF0rYVsxXS1iWzBdLWJbMV1cbiAgICAgIGlmKGQpIHtcbiAgICAgICAgcmV0dXJuIGRcbiAgICAgIH1cbiAgICAgIHJldHVybiBtaW4oYVswXSxhWzFdKSAtIG1pbihiWzBdLGJbMV0pXG4gICAgY2FzZSAzOlxuICAgICAgdmFyIGwxID0gYVswXSthWzFdXG4gICAgICAgICwgbTEgPSBiWzBdK2JbMV1cbiAgICAgIGQgPSBsMSthWzJdIC0gKG0xK2JbMl0pXG4gICAgICBpZihkKSB7XG4gICAgICAgIHJldHVybiBkXG4gICAgICB9XG4gICAgICB2YXIgbDAgPSBtaW4oYVswXSwgYVsxXSlcbiAgICAgICAgLCBtMCA9IG1pbihiWzBdLCBiWzFdKVxuICAgICAgICAsIGQgID0gbWluKGwwLCBhWzJdKSAtIG1pbihtMCwgYlsyXSlcbiAgICAgIGlmKGQpIHtcbiAgICAgICAgcmV0dXJuIGRcbiAgICAgIH1cbiAgICAgIHJldHVybiBtaW4obDArYVsyXSwgbDEpIC0gbWluKG0wK2JbMl0sIG0xKVxuICAgIFxuICAgIC8vVE9ETzogTWF5YmUgb3B0aW1pemUgbj00IGFzIHdlbGw/XG4gICAgXG4gICAgZGVmYXVsdDpcbiAgICAgIHZhciBhcyA9IGEuc2xpY2UoMClcbiAgICAgIGFzLnNvcnQoKVxuICAgICAgdmFyIGJzID0gYi5zbGljZSgwKVxuICAgICAgYnMuc29ydCgpXG4gICAgICBmb3IodmFyIGk9MDsgaTxuOyArK2kpIHtcbiAgICAgICAgdCA9IGFzW2ldIC0gYnNbaV1cbiAgICAgICAgaWYodCkge1xuICAgICAgICAgIHJldHVybiB0XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiAwXG4gIH1cbn1cbmV4cG9ydHMuY29tcGFyZUNlbGxzID0gY29tcGFyZUNlbGxzXG5cbmZ1bmN0aW9uIGNvbXBhcmVaaXBwZWQoYSwgYikge1xuICByZXR1cm4gY29tcGFyZUNlbGxzKGFbMF0sIGJbMF0pXG59XG5cbi8vUHV0cyBhIGNlbGwgY29tcGxleCBpbnRvIG5vcm1hbCBvcmRlciBmb3IgdGhlIHB1cnBvc2VzIG9mIGZpbmRDZWxsIHF1ZXJpZXNcbmZ1bmN0aW9uIG5vcm1hbGl6ZShjZWxscywgYXR0cikge1xuICBpZihhdHRyKSB7XG4gICAgdmFyIGxlbiA9IGNlbGxzLmxlbmd0aFxuICAgIHZhciB6aXBwZWQgPSBuZXcgQXJyYXkobGVuKVxuICAgIGZvcih2YXIgaT0wOyBpPGxlbjsgKytpKSB7XG4gICAgICB6aXBwZWRbaV0gPSBbY2VsbHNbaV0sIGF0dHJbaV1dXG4gICAgfVxuICAgIHppcHBlZC5zb3J0KGNvbXBhcmVaaXBwZWQpXG4gICAgZm9yKHZhciBpPTA7IGk8bGVuOyArK2kpIHtcbiAgICAgIGNlbGxzW2ldID0gemlwcGVkW2ldWzBdXG4gICAgICBhdHRyW2ldID0gemlwcGVkW2ldWzFdXG4gICAgfVxuICAgIHJldHVybiBjZWxsc1xuICB9IGVsc2Uge1xuICAgIGNlbGxzLnNvcnQoY29tcGFyZUNlbGxzKVxuICAgIHJldHVybiBjZWxsc1xuICB9XG59XG5leHBvcnRzLm5vcm1hbGl6ZSA9IG5vcm1hbGl6ZVxuXG4vL1JlbW92ZXMgYWxsIGR1cGxpY2F0ZSBjZWxscyBpbiB0aGUgY29tcGxleFxuZnVuY3Rpb24gdW5pcXVlKGNlbGxzKSB7XG4gIGlmKGNlbGxzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBbXVxuICB9XG4gIHZhciBwdHIgPSAxXG4gICAgLCBsZW4gPSBjZWxscy5sZW5ndGhcbiAgZm9yKHZhciBpPTE7IGk8bGVuOyArK2kpIHtcbiAgICB2YXIgYSA9IGNlbGxzW2ldXG4gICAgaWYoY29tcGFyZUNlbGxzKGEsIGNlbGxzW2ktMV0pKSB7XG4gICAgICBpZihpID09PSBwdHIpIHtcbiAgICAgICAgcHRyKytcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cbiAgICAgIGNlbGxzW3B0cisrXSA9IGFcbiAgICB9XG4gIH1cbiAgY2VsbHMubGVuZ3RoID0gcHRyXG4gIHJldHVybiBjZWxsc1xufVxuZXhwb3J0cy51bmlxdWUgPSB1bmlxdWU7XG5cbi8vRmluZHMgYSBjZWxsIGluIGEgbm9ybWFsaXplZCBjZWxsIGNvbXBsZXhcbmZ1bmN0aW9uIGZpbmRDZWxsKGNlbGxzLCBjKSB7XG4gIHZhciBsbyA9IDBcbiAgICAsIGhpID0gY2VsbHMubGVuZ3RoLTFcbiAgICAsIHIgID0gLTFcbiAgd2hpbGUgKGxvIDw9IGhpKSB7XG4gICAgdmFyIG1pZCA9IChsbyArIGhpKSA+PiAxXG4gICAgICAsIHMgICA9IGNvbXBhcmVDZWxscyhjZWxsc1ttaWRdLCBjKVxuICAgIGlmKHMgPD0gMCkge1xuICAgICAgaWYocyA9PT0gMCkge1xuICAgICAgICByID0gbWlkXG4gICAgICB9XG4gICAgICBsbyA9IG1pZCArIDFcbiAgICB9IGVsc2UgaWYocyA+IDApIHtcbiAgICAgIGhpID0gbWlkIC0gMVxuICAgIH1cbiAgfVxuICByZXR1cm4gclxufVxuZXhwb3J0cy5maW5kQ2VsbCA9IGZpbmRDZWxsO1xuXG4vL0J1aWxkcyBhbiBpbmRleCBmb3IgYW4gbi1jZWxsLiAgVGhpcyBpcyBtb3JlIGdlbmVyYWwgdGhhbiBkdWFsLCBidXQgbGVzcyBlZmZpY2llbnRcbmZ1bmN0aW9uIGluY2lkZW5jZShmcm9tX2NlbGxzLCB0b19jZWxscykge1xuICB2YXIgaW5kZXggPSBuZXcgQXJyYXkoZnJvbV9jZWxscy5sZW5ndGgpXG4gIGZvcih2YXIgaT0wLCBpbD1pbmRleC5sZW5ndGg7IGk8aWw7ICsraSkge1xuICAgIGluZGV4W2ldID0gW11cbiAgfVxuICB2YXIgYiA9IFtdXG4gIGZvcih2YXIgaT0wLCBuPXRvX2NlbGxzLmxlbmd0aDsgaTxuOyArK2kpIHtcbiAgICB2YXIgYyA9IHRvX2NlbGxzW2ldXG4gICAgdmFyIGNsID0gYy5sZW5ndGhcbiAgICBmb3IodmFyIGs9MSwga249KDE8PGNsKTsgazxrbjsgKytrKSB7XG4gICAgICBiLmxlbmd0aCA9IGJpdHMucG9wQ291bnQoaylcbiAgICAgIHZhciBsID0gMFxuICAgICAgZm9yKHZhciBqPTA7IGo8Y2w7ICsraikge1xuICAgICAgICBpZihrICYgKDE8PGopKSB7XG4gICAgICAgICAgYltsKytdID0gY1tqXVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgaWR4PWZpbmRDZWxsKGZyb21fY2VsbHMsIGIpXG4gICAgICBpZihpZHggPCAwKSB7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG4gICAgICB3aGlsZSh0cnVlKSB7XG4gICAgICAgIGluZGV4W2lkeCsrXS5wdXNoKGkpXG4gICAgICAgIGlmKGlkeCA+PSBmcm9tX2NlbGxzLmxlbmd0aCB8fCBjb21wYXJlQ2VsbHMoZnJvbV9jZWxsc1tpZHhdLCBiKSAhPT0gMCkge1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGluZGV4XG59XG5leHBvcnRzLmluY2lkZW5jZSA9IGluY2lkZW5jZVxuXG4vL0NvbXB1dGVzIHRoZSBkdWFsIG9mIHRoZSBtZXNoLiAgVGhpcyBpcyBiYXNpY2FsbHkgYW4gb3B0aW1pemVkIHZlcnNpb24gb2YgYnVpbGRJbmRleCBmb3IgdGhlIHNpdHVhdGlvbiB3aGVyZSBmcm9tX2NlbGxzIGlzIGp1c3QgdGhlIGxpc3Qgb2YgdmVydGljZXNcbmZ1bmN0aW9uIGR1YWwoY2VsbHMsIHZlcnRleF9jb3VudCkge1xuICBpZighdmVydGV4X2NvdW50KSB7XG4gICAgcmV0dXJuIGluY2lkZW5jZSh1bmlxdWUoc2tlbGV0b24oY2VsbHMsIDApKSwgY2VsbHMsIDApXG4gIH1cbiAgdmFyIHJlcyA9IG5ldyBBcnJheSh2ZXJ0ZXhfY291bnQpXG4gIGZvcih2YXIgaT0wOyBpPHZlcnRleF9jb3VudDsgKytpKSB7XG4gICAgcmVzW2ldID0gW11cbiAgfVxuICBmb3IodmFyIGk9MCwgbGVuPWNlbGxzLmxlbmd0aDsgaTxsZW47ICsraSkge1xuICAgIHZhciBjID0gY2VsbHNbaV1cbiAgICBmb3IodmFyIGo9MCwgY2w9Yy5sZW5ndGg7IGo8Y2w7ICsraikge1xuICAgICAgcmVzW2Nbal1dLnB1c2goaSlcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuZXhwb3J0cy5kdWFsID0gZHVhbFxuXG4vL0VudW1lcmF0ZXMgYWxsIGNlbGxzIGluIHRoZSBjb21wbGV4XG5mdW5jdGlvbiBleHBsb2RlKGNlbGxzKSB7XG4gIHZhciByZXN1bHQgPSBbXVxuICBmb3IodmFyIGk9MCwgaWw9Y2VsbHMubGVuZ3RoOyBpPGlsOyArK2kpIHtcbiAgICB2YXIgYyA9IGNlbGxzW2ldXG4gICAgICAsIGNsID0gYy5sZW5ndGh8MFxuICAgIGZvcih2YXIgaj0xLCBqbD0oMTw8Y2wpOyBqPGpsOyArK2opIHtcbiAgICAgIHZhciBiID0gW11cbiAgICAgIGZvcih2YXIgaz0wOyBrPGNsOyArK2spIHtcbiAgICAgICAgaWYoKGogPj4+IGspICYgMSkge1xuICAgICAgICAgIGIucHVzaChjW2tdKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXN1bHQucHVzaChiKVxuICAgIH1cbiAgfVxuICByZXR1cm4gbm9ybWFsaXplKHJlc3VsdClcbn1cbmV4cG9ydHMuZXhwbG9kZSA9IGV4cGxvZGVcblxuLy9FbnVtZXJhdGVzIGFsbCBvZiB0aGUgbi1jZWxscyBvZiBhIGNlbGwgY29tcGxleFxuZnVuY3Rpb24gc2tlbGV0b24oY2VsbHMsIG4pIHtcbiAgaWYobiA8IDApIHtcbiAgICByZXR1cm4gW11cbiAgfVxuICB2YXIgcmVzdWx0ID0gW11cbiAgICAsIGswICAgICA9ICgxPDwobisxKSktMVxuICBmb3IodmFyIGk9MDsgaTxjZWxscy5sZW5ndGg7ICsraSkge1xuICAgIHZhciBjID0gY2VsbHNbaV1cbiAgICBmb3IodmFyIGs9azA7IGs8KDE8PGMubGVuZ3RoKTsgaz1iaXRzLm5leHRDb21iaW5hdGlvbihrKSkge1xuICAgICAgdmFyIGIgPSBuZXcgQXJyYXkobisxKVxuICAgICAgICAsIGwgPSAwXG4gICAgICBmb3IodmFyIGo9MDsgajxjLmxlbmd0aDsgKytqKSB7XG4gICAgICAgIGlmKGsgJiAoMTw8aikpIHtcbiAgICAgICAgICBiW2wrK10gPSBjW2pdXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJlc3VsdC5wdXNoKGIpXG4gICAgfVxuICB9XG4gIHJldHVybiBub3JtYWxpemUocmVzdWx0KVxufVxuZXhwb3J0cy5za2VsZXRvbiA9IHNrZWxldG9uO1xuXG4vL0NvbXB1dGVzIHRoZSBib3VuZGFyeSBvZiBhbGwgY2VsbHMsIGRvZXMgbm90IHJlbW92ZSBkdXBsaWNhdGVzXG5mdW5jdGlvbiBib3VuZGFyeShjZWxscykge1xuICB2YXIgcmVzID0gW11cbiAgZm9yKHZhciBpPTAsaWw9Y2VsbHMubGVuZ3RoOyBpPGlsOyArK2kpIHtcbiAgICB2YXIgYyA9IGNlbGxzW2ldXG4gICAgZm9yKHZhciBqPTAsY2w9Yy5sZW5ndGg7IGo8Y2w7ICsraikge1xuICAgICAgdmFyIGIgPSBuZXcgQXJyYXkoYy5sZW5ndGgtMSlcbiAgICAgIGZvcih2YXIgaz0wLCBsPTA7IGs8Y2w7ICsraykge1xuICAgICAgICBpZihrICE9PSBqKSB7XG4gICAgICAgICAgYltsKytdID0gY1trXVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXMucHVzaChiKVxuICAgIH1cbiAgfVxuICByZXR1cm4gbm9ybWFsaXplKHJlcylcbn1cbmV4cG9ydHMuYm91bmRhcnkgPSBib3VuZGFyeTtcblxuLy9Db21wdXRlcyBjb25uZWN0ZWQgY29tcG9uZW50cyBmb3IgYSBkZW5zZSBjZWxsIGNvbXBsZXhcbmZ1bmN0aW9uIGNvbm5lY3RlZENvbXBvbmVudHNfZGVuc2UoY2VsbHMsIHZlcnRleF9jb3VudCkge1xuICB2YXIgbGFiZWxzID0gbmV3IFVuaW9uRmluZCh2ZXJ0ZXhfY291bnQpXG4gIGZvcih2YXIgaT0wOyBpPGNlbGxzLmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGMgPSBjZWxsc1tpXVxuICAgIGZvcih2YXIgaj0wOyBqPGMubGVuZ3RoOyArK2opIHtcbiAgICAgIGZvcih2YXIgaz1qKzE7IGs8Yy5sZW5ndGg7ICsraykge1xuICAgICAgICBsYWJlbHMubGluayhjW2pdLCBjW2tdKVxuICAgICAgfVxuICAgIH1cbiAgfVxuICB2YXIgY29tcG9uZW50cyA9IFtdXG4gICAgLCBjb21wb25lbnRfbGFiZWxzID0gbGFiZWxzLnJhbmtzXG4gIGZvcih2YXIgaT0wOyBpPGNvbXBvbmVudF9sYWJlbHMubGVuZ3RoOyArK2kpIHtcbiAgICBjb21wb25lbnRfbGFiZWxzW2ldID0gLTFcbiAgfVxuICBmb3IodmFyIGk9MDsgaTxjZWxscy5sZW5ndGg7ICsraSkge1xuICAgIHZhciBsID0gbGFiZWxzLmZpbmQoY2VsbHNbaV1bMF0pXG4gICAgaWYoY29tcG9uZW50X2xhYmVsc1tsXSA8IDApIHtcbiAgICAgIGNvbXBvbmVudF9sYWJlbHNbbF0gPSBjb21wb25lbnRzLmxlbmd0aFxuICAgICAgY29tcG9uZW50cy5wdXNoKFtjZWxsc1tpXS5zbGljZSgwKV0pXG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbXBvbmVudHNbY29tcG9uZW50X2xhYmVsc1tsXV0ucHVzaChjZWxsc1tpXS5zbGljZSgwKSlcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNvbXBvbmVudHNcbn1cblxuLy9Db21wdXRlcyBjb25uZWN0ZWQgY29tcG9uZW50cyBmb3IgYSBzcGFyc2UgZ3JhcGhcbmZ1bmN0aW9uIGNvbm5lY3RlZENvbXBvbmVudHNfc3BhcnNlKGNlbGxzKSB7XG4gIHZhciB2ZXJ0aWNlcyAgPSB1bmlxdWUobm9ybWFsaXplKHNrZWxldG9uKGNlbGxzLCAwKSkpXG4gICAgLCBsYWJlbHMgICAgPSBuZXcgVW5pb25GaW5kKHZlcnRpY2VzLmxlbmd0aClcbiAgZm9yKHZhciBpPTA7IGk8Y2VsbHMubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgYyA9IGNlbGxzW2ldXG4gICAgZm9yKHZhciBqPTA7IGo8Yy5sZW5ndGg7ICsraikge1xuICAgICAgdmFyIHZqID0gZmluZENlbGwodmVydGljZXMsIFtjW2pdXSlcbiAgICAgIGZvcih2YXIgaz1qKzE7IGs8Yy5sZW5ndGg7ICsraykge1xuICAgICAgICBsYWJlbHMubGluayh2aiwgZmluZENlbGwodmVydGljZXMsIFtjW2tdXSkpXG4gICAgICB9XG4gICAgfVxuICB9XG4gIHZhciBjb21wb25lbnRzICAgICAgICA9IFtdXG4gICAgLCBjb21wb25lbnRfbGFiZWxzICA9IGxhYmVscy5yYW5rc1xuICBmb3IodmFyIGk9MDsgaTxjb21wb25lbnRfbGFiZWxzLmxlbmd0aDsgKytpKSB7XG4gICAgY29tcG9uZW50X2xhYmVsc1tpXSA9IC0xXG4gIH1cbiAgZm9yKHZhciBpPTA7IGk8Y2VsbHMubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgbCA9IGxhYmVscy5maW5kKGZpbmRDZWxsKHZlcnRpY2VzLCBbY2VsbHNbaV1bMF1dKSk7XG4gICAgaWYoY29tcG9uZW50X2xhYmVsc1tsXSA8IDApIHtcbiAgICAgIGNvbXBvbmVudF9sYWJlbHNbbF0gPSBjb21wb25lbnRzLmxlbmd0aFxuICAgICAgY29tcG9uZW50cy5wdXNoKFtjZWxsc1tpXS5zbGljZSgwKV0pXG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbXBvbmVudHNbY29tcG9uZW50X2xhYmVsc1tsXV0ucHVzaChjZWxsc1tpXS5zbGljZSgwKSlcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNvbXBvbmVudHNcbn1cblxuLy9Db21wdXRlcyBjb25uZWN0ZWQgY29tcG9uZW50cyBmb3IgYSBjZWxsIGNvbXBsZXhcbmZ1bmN0aW9uIGNvbm5lY3RlZENvbXBvbmVudHMoY2VsbHMsIHZlcnRleF9jb3VudCkge1xuICBpZih2ZXJ0ZXhfY291bnQpIHtcbiAgICByZXR1cm4gY29ubmVjdGVkQ29tcG9uZW50c19kZW5zZShjZWxscywgdmVydGV4X2NvdW50KVxuICB9XG4gIHJldHVybiBjb25uZWN0ZWRDb21wb25lbnRzX3NwYXJzZShjZWxscylcbn1cbmV4cG9ydHMuY29ubmVjdGVkQ29tcG9uZW50cyA9IGNvbm5lY3RlZENvbXBvbmVudHNcbiIsIlwidXNlIHN0cmljdFwiXG5cbm1vZHVsZS5leHBvcnRzID0gc2ltcGxpZnlQb2x5Z29uXG5cbnZhciBvcmllbnQgPSByZXF1aXJlKFwicm9idXN0LW9yaWVudGF0aW9uXCIpXG52YXIgc2MgPSByZXF1aXJlKFwic2ltcGxpY2lhbC1jb21wbGV4XCIpXG5cbmZ1bmN0aW9uIGVycm9yV2VpZ2h0KGJhc2UsIGEsIGIpIHtcbiAgdmFyIGFyZWEgPSBNYXRoLmFicyhvcmllbnQoYmFzZSwgYSwgYikpXG4gIHZhciBwZXJpbSA9IE1hdGguc3FydChNYXRoLnBvdyhhWzBdIC0gYlswXSwgMikgKyBNYXRoLnBvdyhhWzFdLWJbMV0sIDIpKVxuICByZXR1cm4gYXJlYSAvIHBlcmltXG59XG5cbmZ1bmN0aW9uIHNpbXBsaWZ5UG9seWdvbihjZWxscywgcG9zaXRpb25zLCBtaW5BcmVhKSB7XG5cbiAgdmFyIG4gPSBwb3NpdGlvbnMubGVuZ3RoXG4gIHZhciBuYyA9IGNlbGxzLmxlbmd0aFxuICB2YXIgaW52ID0gbmV3IEFycmF5KG4pXG4gIHZhciBvdXR2ID0gbmV3IEFycmF5KG4pXG4gIHZhciB3ZWlnaHRzID0gbmV3IEFycmF5KG4pXG4gIHZhciBkZWFkID0gbmV3IEFycmF5KG4pXG4gIFxuICAvL0luaXRpYWxpemUgdGFibGVzXG4gIGZvcih2YXIgaT0wOyBpPG47ICsraSkge1xuICAgIGludltpXSA9IG91dHZbaV0gPSAtMVxuICAgIHdlaWdodHNbaV0gPSBJbmZpbml0eVxuICAgIGRlYWRbaV0gPSBmYWxzZVxuICB9XG5cbiAgLy9Db21wdXRlIG5laWdoYm9yc1xuICBmb3IodmFyIGk9MDsgaTxuYzsgKytpKSB7XG4gICAgdmFyIGMgPSBjZWxsc1tpXVxuICAgIGlmKGMubGVuZ3RoICE9PSAyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnB1dCBtdXN0IGJlIGEgZ3JhcGhcIilcbiAgICB9XG4gICAgdmFyIHMgPSBjWzFdXG4gICAgdmFyIHQgPSBjWzBdXG4gICAgaWYob3V0dlt0XSAhPT0gLTEpIHtcbiAgICAgIG91dHZbdF0gPSAtMlxuICAgIH0gZWxzZSB7XG4gICAgICBvdXR2W3RdID0gc1xuICAgIH1cbiAgICBpZihpbnZbc10gIT09IC0xKSB7XG4gICAgICBpbnZbc10gPSAtMlxuICAgIH0gZWxzZSB7XG4gICAgICBpbnZbc10gPSB0XG4gICAgfVxuICB9XG5cbiAgLy9VcGRhdGVzIHRoZSB3ZWlnaHQgZm9yIHZlcnRleCBpXG4gIGZ1bmN0aW9uIGNvbXB1dGVXZWlnaHQoaSkge1xuICAgIGlmKGRlYWRbaV0pIHtcbiAgICAgIHJldHVybiBJbmZpbml0eVxuICAgIH1cbiAgICAvL1RPRE86IENoZWNrIHRoYXQgdGhlIGxpbmUgc2VnbWVudCBkb2Vzbid0IGNyb3NzIG9uY2Ugc2ltcGxpZmllZFxuICAgIHZhciBzID0gaW52W2ldXG4gICAgdmFyIHQgPSBvdXR2W2ldXG4gICAgaWYoKHM8MCkgfHwgKHQ8MCkpIHtcbiAgICAgIHJldHVybiBJbmZpbml0eVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZXJyb3JXZWlnaHQocG9zaXRpb25zW2ldLCBwb3NpdGlvbnNbc10sIHBvc2l0aW9uc1t0XSlcbiAgICB9XG4gIH1cblxuICAvL1N3YXBzIHR3byBub2RlcyBvbiB0aGUgaGVhcCAoaSxqKSBhcmUgdGhlIGluZGV4IG9mIHRoZSBub2Rlc1xuICBmdW5jdGlvbiBoZWFwU3dhcChpLGopIHtcbiAgICB2YXIgYSA9IGhlYXBbaV1cbiAgICB2YXIgYiA9IGhlYXBbal1cbiAgICBoZWFwW2ldID0gYlxuICAgIGhlYXBbal0gPSBhXG4gICAgaW5kZXhbYV0gPSBqXG4gICAgaW5kZXhbYl0gPSBpXG4gIH1cblxuICAvL1JldHVybnMgdGhlIHdlaWdodCBvZiBub2RlIGkgb24gdGhlIGhlYXBcbiAgZnVuY3Rpb24gaGVhcFdlaWdodChpKSB7XG4gICAgcmV0dXJuIHdlaWdodHNbaGVhcFtpXV1cbiAgfVxuXG4gIGZ1bmN0aW9uIGhlYXBQYXJlbnQoaSkge1xuICAgIGlmKGkgJiAxKSB7XG4gICAgICByZXR1cm4gKGkgLSAxKSA+PiAxXG4gICAgfVxuICAgIHJldHVybiAoaSA+PiAxKSAtIDFcbiAgfVxuXG4gIC8vQnViYmxlIGVsZW1lbnQgaSBkb3duIHRoZSBoZWFwXG4gIGZ1bmN0aW9uIGhlYXBEb3duKGkpIHtcbiAgICB2YXIgdyA9IGhlYXBXZWlnaHQoaSlcbiAgICB3aGlsZSh0cnVlKSB7XG4gICAgICB2YXIgdHcgPSB3XG4gICAgICB2YXIgbGVmdCAgPSAyKmkgKyAxXG4gICAgICB2YXIgcmlnaHQgPSAyKihpICsgMSlcbiAgICAgIHZhciBuZXh0ID0gaVxuICAgICAgaWYobGVmdCA8IGhlYXBDb3VudCkge1xuICAgICAgICB2YXIgbHcgPSBoZWFwV2VpZ2h0KGxlZnQpXG4gICAgICAgIGlmKGx3IDwgdHcpIHtcbiAgICAgICAgICBuZXh0ID0gbGVmdFxuICAgICAgICAgIHR3ID0gbHdcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYocmlnaHQgPCBoZWFwQ291bnQpIHtcbiAgICAgICAgdmFyIHJ3ID0gaGVhcFdlaWdodChyaWdodClcbiAgICAgICAgaWYocncgPCB0dykge1xuICAgICAgICAgIG5leHQgPSByaWdodFxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZihuZXh0ID09PSBpKSB7XG4gICAgICAgIHJldHVybiBpXG4gICAgICB9XG4gICAgICBoZWFwU3dhcChpLCBuZXh0KVxuICAgICAgaSA9IG5leHQgICAgICBcbiAgICB9XG4gIH1cblxuICAvL0J1YmJsZXMgZWxlbWVudCBpIHVwIHRoZSBoZWFwXG4gIGZ1bmN0aW9uIGhlYXBVcChpKSB7XG4gICAgdmFyIHcgPSBoZWFwV2VpZ2h0KGkpXG4gICAgd2hpbGUoaSA+IDApIHtcbiAgICAgIHZhciBwYXJlbnQgPSBoZWFwUGFyZW50KGkpXG4gICAgICBpZihwYXJlbnQgPj0gMCkge1xuICAgICAgICB2YXIgcHcgPSBoZWFwV2VpZ2h0KHBhcmVudClcbiAgICAgICAgaWYodyA8IHB3KSB7XG4gICAgICAgICAgaGVhcFN3YXAoaSwgcGFyZW50KVxuICAgICAgICAgIGkgPSBwYXJlbnRcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gaVxuICAgIH1cbiAgfVxuXG4gIC8vUG9wIG1pbmltdW0gZWxlbWVudFxuICBmdW5jdGlvbiBoZWFwUG9wKCkge1xuICAgIGlmKGhlYXBDb3VudCA+IDApIHtcbiAgICAgIHZhciBoZWFkID0gaGVhcFswXVxuICAgICAgaGVhcFN3YXAoMCwgaGVhcENvdW50LTEpXG4gICAgICBoZWFwQ291bnQgLT0gMVxuICAgICAgaGVhcERvd24oMClcbiAgICAgIHJldHVybiBoZWFkXG4gICAgfVxuICAgIHJldHVybiAtMVxuICB9XG5cbiAgLy9VcGRhdGUgaGVhcCBpdGVtIGlcbiAgZnVuY3Rpb24gaGVhcFVwZGF0ZShpLCB3KSB7XG4gICAgdmFyIGEgPSBoZWFwW2ldXG4gICAgaWYod2VpZ2h0c1thXSA9PT0gdykge1xuICAgICAgcmV0dXJuIGlcbiAgICB9XG4gICAgd2VpZ2h0c1thXSA9IC1JbmZpbml0eVxuICAgIGhlYXBVcChpKVxuICAgIGhlYXBQb3AoKVxuICAgIHdlaWdodHNbYV0gPSB3XG4gICAgaGVhcENvdW50ICs9IDFcbiAgICByZXR1cm4gaGVhcFVwKGhlYXBDb3VudC0xKVxuICB9XG5cbiAgLy9LaWxscyBhIHZlcnRleCAoYXNzdW1lIHZlcnRleCBhbHJlYWR5IHJlbW92ZWQgZnJvbSBoZWFwKVxuICBmdW5jdGlvbiBraWxsKGkpIHtcbiAgICBpZihkZWFkW2ldKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgLy9LaWxsIHZlcnRleFxuICAgIGRlYWRbaV0gPSB0cnVlXG4gICAgLy9GaXh1cCB0b3BvbG9neVxuICAgIHZhciBzID0gaW52W2ldXG4gICAgdmFyIHQgPSBvdXR2W2ldXG4gICAgaWYoaW52W3RdID49IDApIHtcbiAgICAgIGludlt0XSA9IHNcbiAgICB9XG4gICAgaWYob3V0dltzXSA+PSAwKSB7XG4gICAgICBvdXR2W3NdID0gdFxuICAgIH1cblxuICAgIC8vVXBkYXRlIHdlaWdodHMgb24gcyBhbmQgdFxuICAgIGlmKGluZGV4W3NdID49IDApIHtcbiAgICAgIGhlYXBVcGRhdGUoaW5kZXhbc10sIGNvbXB1dGVXZWlnaHQocykpXG4gICAgfVxuICAgIGlmKGluZGV4W3RdID49IDApIHtcbiAgICAgIGhlYXBVcGRhdGUoaW5kZXhbdF0sIGNvbXB1dGVXZWlnaHQodCkpXG4gICAgfVxuICB9XG5cbiAgLy9Jbml0aWFsaXplIHdlaWdodHMgYW5kIGhlYXBcbiAgdmFyIGhlYXAgPSBbXVxuICB2YXIgaW5kZXggPSBuZXcgQXJyYXkobilcbiAgZm9yKHZhciBpPTA7IGk8bjsgKytpKSB7XG4gICAgdmFyIHcgPSB3ZWlnaHRzW2ldID0gY29tcHV0ZVdlaWdodChpKVxuICAgIGlmKHcgPCBJbmZpbml0eSkge1xuICAgICAgaW5kZXhbaV0gPSBoZWFwLmxlbmd0aFxuICAgICAgaGVhcC5wdXNoKGkpXG4gICAgfSBlbHNlIHtcbiAgICAgIGluZGV4W2ldID0gLTFcbiAgICB9XG4gIH1cbiAgdmFyIGhlYXBDb3VudCA9IGhlYXAubGVuZ3RoXG4gIGZvcih2YXIgaT1oZWFwQ291bnQ+PjE7IGk+PTA7IC0taSkge1xuICAgIGhlYXBEb3duKGkpXG4gIH1cbiAgXG4gIC8vS2lsbCB2ZXJ0aWNlc1xuICB3aGlsZSh0cnVlKSB7XG4gICAgdmFyIGhtaW4gPSBoZWFwUG9wKClcbiAgICBpZigoaG1pbiA8IDApIHx8ICh3ZWlnaHRzW2htaW5dID4gbWluQXJlYSkpIHtcbiAgICAgIGJyZWFrXG4gICAgfVxuICAgIGtpbGwoaG1pbilcbiAgfVxuXG4gIC8vQnVpbGQgY29sbGFwc2VkIHZlcnRleCB0YWJsZVxuICB2YXIgbnBvc2l0aW9ucyA9IFtdXG4gIGZvcih2YXIgaT0wOyBpPG47ICsraSkge1xuICAgIGlmKCFkZWFkW2ldKSB7XG4gICAgICBpbmRleFtpXSA9IG5wb3NpdGlvbnMubGVuZ3RoXG4gICAgICBucG9zaXRpb25zLnB1c2gocG9zaXRpb25zW2ldLnNsaWNlKCkpXG4gICAgfVxuICB9XG4gIHZhciBudiA9IG5wb3NpdGlvbnMubGVuZ3RoXG5cbiAgZnVuY3Rpb24gdG9ydG9pc2VIYXJlKHNlcSwgc3RhcnQpIHtcbiAgICBpZihzZXFbc3RhcnRdIDwgMCkge1xuICAgICAgcmV0dXJuIHN0YXJ0XG4gICAgfVxuICAgIHZhciB0ID0gc3RhcnRcbiAgICB2YXIgaCA9IHN0YXJ0XG4gICAgZG8ge1xuICAgICAgLy9XYWxrIHR3byBzdGVwcyB3aXRoIGhcbiAgICAgIHZhciBuaCA9IHNlcVtoXVxuICAgICAgaWYoIWRlYWRbaF0gfHwgbmggPCAwIHx8IG5oID09PSBoKSB7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICBoID0gbmhcbiAgICAgIG5oID0gc2VxW2hdXG4gICAgICBpZighZGVhZFtoXSB8fCBuaCA8IDAgfHwgbmggPT09IGgpIHtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIGggPSBuaFxuXG4gICAgICAvL1dhbGsgb25lIHN0ZXAgd2l0aCB0XG4gICAgICB0ID0gc2VxW3RdXG4gICAgfSB3aGlsZSh0ICE9PSBoKVxuICAgIC8vQ29tcHJlc3MgY3ljbGVzXG4gICAgZm9yKHZhciB2PXN0YXJ0OyB2IT09aDsgdiA9IHNlcVt2XSkge1xuICAgICAgc2VxW3ZdID0gaFxuICAgIH1cbiAgICByZXR1cm4gaFxuICB9XG5cbiAgdmFyIG5jZWxscyA9IFtdXG4gIGNlbGxzLmZvckVhY2goZnVuY3Rpb24oYykge1xuICAgIHZhciB0aW4gPSB0b3J0b2lzZUhhcmUoaW52LCBjWzBdKVxuICAgIHZhciB0b3V0ID0gdG9ydG9pc2VIYXJlKG91dHYsIGNbMV0pXG4gICAgaWYodGluID49IDAgJiYgdG91dCA+PSAwICYmIHRpbiAhPT0gdG91dCkge1xuICAgICAgdmFyIGNpbiA9IGluZGV4W3Rpbl1cbiAgICAgIHZhciBjb3V0ID0gaW5kZXhbdG91dF1cbiAgICAgIGlmKGNpbiAhPT0gY291dCkge1xuICAgICAgICBuY2VsbHMucHVzaChbIGNpbiwgY291dCBdKVxuICAgICAgfVxuICAgIH1cbiAgfSlcblxuICAvL05vcm1hbGl6ZSByZXN1bHRcbiAgc2MudW5pcXVlKHNjLm5vcm1hbGl6ZShuY2VsbHMpKVxuXG4gIC8vUmV0dXJuIGZpbmFsIGxpc3Qgb2YgY2VsbHNcbiAgcmV0dXJuIHtcbiAgICBwb3NpdGlvbnM6IG5wb3NpdGlvbnMsXG4gICAgZWRnZXM6IG5jZWxsc1xuICB9XG59IiwiXCJ1c2Ugc3RyaWN0XCJcblxubW9kdWxlLmV4cG9ydHMgPSBvcmRlclNlZ21lbnRzXG5cbnZhciBvcmllbnQgPSByZXF1aXJlKFwicm9idXN0LW9yaWVudGF0aW9uXCIpXG5cbmZ1bmN0aW9uIGhvcml6b250YWxPcmRlcihhLCBiKSB7XG4gIHZhciBibCwgYnJcbiAgaWYoYlswXVswXSA8IGJbMV1bMF0pIHtcbiAgICBibCA9IGJbMF1cbiAgICBiciA9IGJbMV1cbiAgfSBlbHNlIGlmKGJbMF1bMF0gPiBiWzFdWzBdKSB7XG4gICAgYmwgPSBiWzFdXG4gICAgYnIgPSBiWzBdXG4gIH0gZWxzZSB7XG4gICAgdmFyIGFsbyA9IE1hdGgubWluKGFbMF1bMV0sIGFbMV1bMV0pXG4gICAgdmFyIGFoaSA9IE1hdGgubWF4KGFbMF1bMV0sIGFbMV1bMV0pXG4gICAgdmFyIGJsbyA9IE1hdGgubWluKGJbMF1bMV0sIGJbMV1bMV0pXG4gICAgdmFyIGJoaSA9IE1hdGgubWF4KGJbMF1bMV0sIGJbMV1bMV0pXG4gICAgaWYoYWhpIDwgYmxvKSB7XG4gICAgICByZXR1cm4gYWhpIC0gYmxvXG4gICAgfVxuICAgIGlmKGFsbyA+IGJoaSkge1xuICAgICAgcmV0dXJuIGFsbyAtIGJoaVxuICAgIH1cbiAgICByZXR1cm4gYWhpIC0gYmhpXG4gIH1cbiAgdmFyIGFsLCBhclxuICBpZihhWzBdWzFdIDwgYVsxXVsxXSkge1xuICAgIGFsID0gYVswXVxuICAgIGFyID0gYVsxXVxuICB9IGVsc2Uge1xuICAgIGFsID0gYVsxXVxuICAgIGFyID0gYVswXVxuICB9XG4gIHZhciBkID0gb3JpZW50KGJyLCBibCwgYWwpXG4gIGlmKGQpIHtcbiAgICByZXR1cm4gZFxuICB9XG4gIGQgPSBvcmllbnQoYnIsIGJsLCBhcilcbiAgaWYoZCkge1xuICAgIHJldHVybiBkXG4gIH1cbiAgcmV0dXJuIGFyIC0gYnJcbn1cblxuZnVuY3Rpb24gb3JkZXJTZWdtZW50cyhiLCBhKSB7XG4gIHZhciBhbCwgYXJcbiAgaWYoYVswXVswXSA8IGFbMV1bMF0pIHtcbiAgICBhbCA9IGFbMF1cbiAgICBhciA9IGFbMV1cbiAgfSBlbHNlIGlmKGFbMF1bMF0gPiBhWzFdWzBdKSB7XG4gICAgYWwgPSBhWzFdXG4gICAgYXIgPSBhWzBdXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGhvcml6b250YWxPcmRlcihhLCBiKVxuICB9XG4gIHZhciBibCwgYnJcbiAgaWYoYlswXVswXSA8IGJbMV1bMF0pIHtcbiAgICBibCA9IGJbMF1cbiAgICBiciA9IGJbMV1cbiAgfSBlbHNlIGlmKGJbMF1bMF0gPiBiWzFdWzBdKSB7XG4gICAgYmwgPSBiWzFdXG4gICAgYnIgPSBiWzBdXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIC1ob3Jpem9udGFsT3JkZXIoYiwgYSlcbiAgfVxuICB2YXIgZDEgPSBvcmllbnQoYWwsIGFyLCBicilcbiAgdmFyIGQyID0gb3JpZW50KGFsLCBhciwgYmwpXG4gIGlmKGQxIDwgMCkge1xuICAgIGlmKGQyIDw9IDApIHtcbiAgICAgIHJldHVybiBkMVxuICAgIH1cbiAgfSBlbHNlIGlmKGQxID4gMCkge1xuICAgIGlmKGQyID49IDApIHtcbiAgICAgIHJldHVybiBkMVxuICAgIH1cbiAgfSBlbHNlIGlmKGQyKSB7XG4gICAgcmV0dXJuIGQyXG4gIH1cbiAgZDEgPSBvcmllbnQoYnIsIGJsLCBhcilcbiAgZDIgPSBvcmllbnQoYnIsIGJsLCBhbClcbiAgaWYoZDEgPCAwKSB7XG4gICAgaWYoZDIgPD0gMCkge1xuICAgICAgcmV0dXJuIGQxXG4gICAgfVxuICB9IGVsc2UgaWYoZDEgPiAwKSB7XG4gICAgaWYoZDIgPj0gMCkge1xuICAgICAgcmV0dXJuIGQxXG4gICAgfVxuICB9IGVsc2UgaWYoZDIpIHtcbiAgICByZXR1cm4gZDJcbiAgfVxuICByZXR1cm4gYXJbMF0gLSBiclswXVxufSIsIlwidXNlIHN0cmljdFwiXG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlU2xhYkRlY29tcG9zaXRpb25cblxudmFyIGJvdW5kcyA9IHJlcXVpcmUoXCJiaW5hcnktc2VhcmNoLWJvdW5kc1wiKVxudmFyIGNyZWF0ZVJCVHJlZSA9IHJlcXVpcmUoXCJmdW5jdGlvbmFsLXJlZC1ibGFjay10cmVlXCIpXG52YXIgb3JpZW50ID0gcmVxdWlyZShcInJvYnVzdC1vcmllbnRhdGlvblwiKVxudmFyIG9yZGVyU2VnbWVudHMgPSByZXF1aXJlKFwiLi9saWIvb3JkZXItc2VnbWVudHNcIilcblxuZnVuY3Rpb24gU2xhYkRlY29tcG9zaXRpb24oc2xhYnMsIGNvb3JkaW5hdGVzLCBob3Jpem9udGFsKSB7XG4gIHRoaXMuc2xhYnMgPSBzbGFic1xuICB0aGlzLmNvb3JkaW5hdGVzID0gY29vcmRpbmF0ZXNcbiAgdGhpcy5ob3Jpem9udGFsID0gaG9yaXpvbnRhbFxufVxuXG52YXIgcHJvdG8gPSBTbGFiRGVjb21wb3NpdGlvbi5wcm90b3R5cGVcblxuZnVuY3Rpb24gY29tcGFyZUhvcml6b250YWwoZSwgeSkge1xuICByZXR1cm4gZS55IC0geVxufVxuXG5mdW5jdGlvbiBzZWFyY2hCdWNrZXQocm9vdCwgcCkge1xuICB2YXIgbGFzdE5vZGUgPSBudWxsXG4gIHdoaWxlKHJvb3QpIHtcbiAgICB2YXIgc2VnID0gcm9vdC5rZXlcbiAgICB2YXIgbCwgclxuICAgIGlmKHNlZ1swXVswXSA8IHNlZ1sxXVswXSkge1xuICAgICAgbCA9IHNlZ1swXVxuICAgICAgciA9IHNlZ1sxXVxuICAgIH0gZWxzZSB7XG4gICAgICBsID0gc2VnWzFdXG4gICAgICByID0gc2VnWzBdXG4gICAgfVxuICAgIHZhciBvID0gb3JpZW50KGwsIHIsIHApXG4gICAgaWYobyA8IDApIHtcbiAgICAgIHJvb3QgPSByb290LmxlZnRcbiAgICB9IGVsc2UgaWYobyA+IDApIHtcbiAgICAgIGlmKHBbMF0gIT09IHNlZ1sxXVswXSkge1xuICAgICAgICBsYXN0Tm9kZSA9IHJvb3RcbiAgICAgICAgcm9vdCA9IHJvb3QucmlnaHRcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciB2YWwgPSBzZWFyY2hCdWNrZXQocm9vdC5yaWdodCwgcClcbiAgICAgICAgaWYodmFsKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbFxuICAgICAgICB9XG4gICAgICAgIHJvb3QgPSByb290LmxlZnRcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYocFswXSAhPT0gc2VnWzFdWzBdKSB7XG4gICAgICAgIHJldHVybiByb290XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgdmFsID0gc2VhcmNoQnVja2V0KHJvb3QucmlnaHQsIHApXG4gICAgICAgIGlmKHZhbCkge1xuICAgICAgICAgIHJldHVybiB2YWxcbiAgICAgICAgfVxuICAgICAgICByb290ID0gcm9vdC5sZWZ0XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBsYXN0Tm9kZVxufVxuXG5wcm90by5jYXN0VXAgPSBmdW5jdGlvbihwKSB7XG4gIHZhciBidWNrZXQgPSBib3VuZHMubGUodGhpcy5jb29yZGluYXRlcywgcFswXSlcbiAgaWYoYnVja2V0IDwgMCkge1xuICAgIHJldHVybiAtMVxuICB9XG4gIHZhciByb290ID0gdGhpcy5zbGFic1tidWNrZXRdXG4gIHZhciBoaXROb2RlID0gc2VhcmNoQnVja2V0KHRoaXMuc2xhYnNbYnVja2V0XSwgcClcbiAgdmFyIGxhc3RIaXQgPSAtMVxuICBpZihoaXROb2RlKSB7XG4gICAgbGFzdEhpdCA9IGhpdE5vZGUudmFsdWVcbiAgfVxuICAvL0VkZ2UgY2FzZTogbmVlZCB0byBoYW5kbGUgaG9yaXpvbnRhbCBzZWdtZW50cyAoc3Vja3MpXG4gIGlmKHRoaXMuY29vcmRpbmF0ZXNbYnVja2V0XSA9PT0gcFswXSkge1xuICAgIHZhciBsYXN0U2VnbWVudCA9IG51bGxcbiAgICBpZihoaXROb2RlKSB7XG4gICAgICBsYXN0U2VnbWVudCA9IGhpdE5vZGUua2V5XG4gICAgfVxuICAgIGlmKGJ1Y2tldCA+IDApIHtcbiAgICAgIHZhciBvdGhlckhpdE5vZGUgPSBzZWFyY2hCdWNrZXQodGhpcy5zbGFic1tidWNrZXQtMV0sIHApXG4gICAgICBpZihvdGhlckhpdE5vZGUpIHtcbiAgICAgICAgaWYobGFzdFNlZ21lbnQpIHtcbiAgICAgICAgICBpZihvcmRlclNlZ21lbnRzKG90aGVySGl0Tm9kZS5rZXksIGxhc3RTZWdtZW50KSA+IDApIHtcbiAgICAgICAgICAgIGxhc3RTZWdtZW50ID0gb3RoZXJIaXROb2RlLmtleVxuICAgICAgICAgICAgbGFzdEhpdCA9IG90aGVySGl0Tm9kZS52YWx1ZVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsYXN0SGl0ID0gb3RoZXJIaXROb2RlLnZhbHVlXG4gICAgICAgICAgbGFzdFNlZ21lbnQgPSBvdGhlckhpdE5vZGUua2V5XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIGhvcml6ID0gdGhpcy5ob3Jpem9udGFsW2J1Y2tldF1cbiAgICBpZihob3Jpei5sZW5ndGggPiAwKSB7XG4gICAgICB2YXIgaGJ1Y2tldCA9IGJvdW5kcy5nZShob3JpeiwgcFsxXSwgY29tcGFyZUhvcml6b250YWwpXG4gICAgICBpZihoYnVja2V0IDwgaG9yaXoubGVuZ3RoKSB7XG4gICAgICAgIHZhciBlID0gaG9yaXpbaGJ1Y2tldF1cbiAgICAgICAgaWYocFsxXSA9PT0gZS55KSB7XG4gICAgICAgICAgaWYoZS5jbG9zZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBlLmluZGV4XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHdoaWxlKGhidWNrZXQgPCBob3Jpei5sZW5ndGgtMSAmJiBob3JpeltoYnVja2V0KzFdLnkgPT09IHBbMV0pIHtcbiAgICAgICAgICAgICAgaGJ1Y2tldCA9IGhidWNrZXQrMVxuICAgICAgICAgICAgICBlID0gaG9yaXpbaGJ1Y2tldF1cbiAgICAgICAgICAgICAgaWYoZS5jbG9zZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZS5pbmRleFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZihlLnkgPT09IHBbMV0gJiYgIWUuc3RhcnQpIHtcbiAgICAgICAgICAgICAgaGJ1Y2tldCA9IGhidWNrZXQrMVxuICAgICAgICAgICAgICBpZihoYnVja2V0ID49IGhvcml6Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBsYXN0SGl0XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZSA9IGhvcml6W2hidWNrZXRdXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vQ2hlY2sgaWYgZSBpcyBhYm92ZS9iZWxvdyBsYXN0IHNlZ21lbnRcbiAgICAgICAgaWYoZS5zdGFydCkge1xuICAgICAgICAgIGlmKGxhc3RTZWdtZW50KSB7XG4gICAgICAgICAgICB2YXIgbyA9IG9yaWVudChsYXN0U2VnbWVudFswXSwgbGFzdFNlZ21lbnRbMV0sIFtwWzBdLCBlLnldKVxuICAgICAgICAgICAgaWYobGFzdFNlZ21lbnRbMF1bMF0gPiBsYXN0U2VnbWVudFsxXVswXSkge1xuICAgICAgICAgICAgICBvID0gLW9cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKG8gPiAwKSB7XG4gICAgICAgICAgICAgIGxhc3RIaXQgPSBlLmluZGV4XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxhc3RIaXQgPSBlLmluZGV4XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYoZS55ICE9PSBwWzFdKSB7XG4gICAgICAgICAgbGFzdEhpdCA9IGUuaW5kZXhcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gbGFzdEhpdFxufVxuXG5mdW5jdGlvbiBJbnRlcnZhbFNlZ21lbnQoeSwgaW5kZXgsIHN0YXJ0LCBjbG9zZWQpIHtcbiAgdGhpcy55ID0geVxuICB0aGlzLmluZGV4ID0gaW5kZXhcbiAgdGhpcy5zdGFydCA9IHN0YXJ0XG4gIHRoaXMuY2xvc2VkID0gY2xvc2VkXG59XG5cbmZ1bmN0aW9uIEV2ZW50KHgsIHNlZ21lbnQsIGNyZWF0ZSwgaW5kZXgpIHtcbiAgdGhpcy54ID0geFxuICB0aGlzLnNlZ21lbnQgPSBzZWdtZW50XG4gIHRoaXMuY3JlYXRlID0gY3JlYXRlXG4gIHRoaXMuaW5kZXggPSBpbmRleFxufVxuXG5cbmZ1bmN0aW9uIGNyZWF0ZVNsYWJEZWNvbXBvc2l0aW9uKHNlZ21lbnRzKSB7XG4gIHZhciBudW1TZWdtZW50cyA9IHNlZ21lbnRzLmxlbmd0aFxuICB2YXIgbnVtRXZlbnRzID0gMiAqIG51bVNlZ21lbnRzXG4gIHZhciBldmVudHMgPSBuZXcgQXJyYXkobnVtRXZlbnRzKVxuICBmb3IodmFyIGk9MDsgaTxudW1TZWdtZW50czsgKytpKSB7XG4gICAgdmFyIHMgPSBzZWdtZW50c1tpXVxuICAgIHZhciBmID0gc1swXVswXSA8IHNbMV1bMF1cbiAgICBldmVudHNbMippXSA9IG5ldyBFdmVudChzWzBdWzBdLCBzLCBmLCBpKVxuICAgIGV2ZW50c1syKmkrMV0gPSBuZXcgRXZlbnQoc1sxXVswXSwgcywgIWYsIGkpXG4gIH1cbiAgZXZlbnRzLnNvcnQoZnVuY3Rpb24oYSxiKSB7XG4gICAgdmFyIGQgPSBhLnggLSBiLnhcbiAgICBpZihkKSB7XG4gICAgICByZXR1cm4gZFxuICAgIH1cbiAgICBkID0gYS5jcmVhdGUgLSBiLmNyZWF0ZVxuICAgIGlmKGQpIHtcbiAgICAgIHJldHVybiBkXG4gICAgfVxuICAgIHJldHVybiBNYXRoLm1pbihhLnNlZ21lbnRbMF1bMV0sIGEuc2VnbWVudFsxXVsxXSkgLSBNYXRoLm1pbihiLnNlZ21lbnRbMF1bMV0sIGIuc2VnbWVudFsxXVsxXSlcbiAgfSlcbiAgdmFyIHRyZWUgPSBjcmVhdGVSQlRyZWUob3JkZXJTZWdtZW50cylcbiAgdmFyIHNsYWJzID0gW11cbiAgdmFyIGxpbmVzID0gW11cbiAgdmFyIGhvcml6b250YWwgPSBbXVxuICB2YXIgbGFzdFggPSAtSW5maW5pdHlcbiAgZm9yKHZhciBpPTA7IGk8bnVtRXZlbnRzOyApIHtcbiAgICB2YXIgeCA9IGV2ZW50c1tpXS54XG4gICAgdmFyIGhvcml6ID0gW11cbiAgICB3aGlsZShpIDwgbnVtRXZlbnRzKSB7XG4gICAgICB2YXIgZSA9IGV2ZW50c1tpXVxuICAgICAgaWYoZS54ICE9PSB4KSB7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICBpICs9IDFcbiAgICAgIGlmKGUuc2VnbWVudFswXVswXSA9PT0gZS54ICYmIGUuc2VnbWVudFsxXVswXSA9PT0gZS54KSB7XG4gICAgICAgIGlmKGUuY3JlYXRlKSB7XG4gICAgICAgICAgaWYoZS5zZWdtZW50WzBdWzFdIDwgZS5zZWdtZW50WzFdWzFdKSB7XG4gICAgICAgICAgICBob3Jpei5wdXNoKG5ldyBJbnRlcnZhbFNlZ21lbnQoXG4gICAgICAgICAgICAgICAgZS5zZWdtZW50WzBdWzFdLFxuICAgICAgICAgICAgICAgIGUuaW5kZXgsXG4gICAgICAgICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAgICAgICB0cnVlKSlcbiAgICAgICAgICAgIGhvcml6LnB1c2gobmV3IEludGVydmFsU2VnbWVudChcbiAgICAgICAgICAgICAgICBlLnNlZ21lbnRbMV1bMV0sXG4gICAgICAgICAgICAgICAgZS5pbmRleCxcbiAgICAgICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICAgICBmYWxzZSkpXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGhvcml6LnB1c2gobmV3IEludGVydmFsU2VnbWVudChcbiAgICAgICAgICAgICAgICBlLnNlZ21lbnRbMV1bMV0sXG4gICAgICAgICAgICAgICAgZS5pbmRleCxcbiAgICAgICAgICAgICAgICB0cnVlLFxuICAgICAgICAgICAgICAgIGZhbHNlKSlcbiAgICAgICAgICAgIGhvcml6LnB1c2gobmV3IEludGVydmFsU2VnbWVudChcbiAgICAgICAgICAgICAgICBlLnNlZ21lbnRbMF1bMV0sXG4gICAgICAgICAgICAgICAgZS5pbmRleCxcbiAgICAgICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICAgICB0cnVlKSlcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmKGUuY3JlYXRlKSB7XG4gICAgICAgICAgdHJlZSA9IHRyZWUuaW5zZXJ0KGUuc2VnbWVudCwgZS5pbmRleClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0cmVlID0gdHJlZS5yZW1vdmUoZS5zZWdtZW50KVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHNsYWJzLnB1c2godHJlZS5yb290KVxuICAgIGxpbmVzLnB1c2goeClcbiAgICBob3Jpem9udGFsLnB1c2goaG9yaXopXG4gIH1cbiAgcmV0dXJuIG5ldyBTbGFiRGVjb21wb3NpdGlvbihzbGFicywgbGluZXMsIGhvcml6b250YWwpXG59IiwiXCJ1c2Ugc3RyaWN0XCJcblxubW9kdWxlLmV4cG9ydHMgPSBzdXJmYWNlTmV0c1xuXG52YXIgZ2VuZXJhdGVDb250b3VyRXh0cmFjdG9yID0gcmVxdWlyZShcIm5kYXJyYXktZXh0cmFjdC1jb250b3VyXCIpXG52YXIgdHJpYW5ndWxhdGVDdWJlID0gcmVxdWlyZShcInRyaWFuZ3VsYXRlLWh5cGVyY3ViZVwiKVxudmFyIHplcm9Dcm9zc2luZ3MgPSByZXF1aXJlKFwiemVyby1jcm9zc2luZ3NcIilcblxuZnVuY3Rpb24gYnVpbGRTdXJmYWNlTmV0cyhvcmRlciwgZHR5cGUpIHtcbiAgdmFyIGRpbWVuc2lvbiA9IG9yZGVyLmxlbmd0aFxuICB2YXIgY29kZSA9IFtcIid1c2Ugc3RyaWN0JztcIl1cbiAgdmFyIGZ1bmNOYW1lID0gXCJzdXJmYWNlTmV0c1wiICsgb3JkZXIuam9pbihcIl9cIikgKyBcImRcIiArIGR0eXBlXG5cbiAgLy9Db250b3VyIGV4dHJhY3Rpb24gZnVuY3Rpb25cbiAgY29kZS5wdXNoKFxuICAgIFwidmFyIGNvbnRvdXI9Z2VuQ29udG91cih7XCIsXG4gICAgICBcIm9yZGVyOltcIiwgb3JkZXIuam9pbigpLCBcIl0sXCIsXG4gICAgICBcInNjYWxhckFyZ3VtZW50czogMyxcIixcbiAgICAgIFwicGhhc2U6ZnVuY3Rpb24gcGhhc2VGdW5jKHAsYSxiLGMpIHsgcmV0dXJuIChwID4gYyl8MCB9LFwiKVxuICBpZihkdHlwZSA9PT0gXCJnZW5lcmljXCIpIHtcbiAgICBjb2RlLnB1c2goXCJnZXR0ZXJzOlswXSxcIilcbiAgfVxuXG4gIC8vR2VuZXJhdGUgdmVydGV4IGZ1bmN0aW9uXG4gIHZhciBjdWJlQXJncyA9IFtdXG4gIHZhciBleHRyYUFyZ3MgPSBbXVxuICBmb3IodmFyIGk9MDsgaTxkaW1lbnNpb247ICsraSkge1xuICAgIGN1YmVBcmdzLnB1c2goXCJkXCIgKyBpKVxuICAgIGV4dHJhQXJncy5wdXNoKFwiZFwiICsgaSlcbiAgfVxuICBmb3IodmFyIGk9MDsgaTwoMTw8ZGltZW5zaW9uKTsgKytpKSB7XG4gICAgY3ViZUFyZ3MucHVzaChcInZcIiArIGkpXG4gICAgZXh0cmFBcmdzLnB1c2goXCJ2XCIgKyBpKVxuICB9XG4gIGZvcih2YXIgaT0wOyBpPCgxPDxkaW1lbnNpb24pOyArK2kpIHtcbiAgICBjdWJlQXJncy5wdXNoKFwicFwiICsgaSlcbiAgICBleHRyYUFyZ3MucHVzaChcInBcIiArIGkpXG4gIH1cbiAgY3ViZUFyZ3MucHVzaChcImFcIiwgXCJiXCIsIFwiY1wiKVxuICBleHRyYUFyZ3MucHVzaChcImFcIiwgXCJjXCIpXG4gIGNvZGUucHVzaChcInZlcnRleDpmdW5jdGlvbiB2ZXJ0ZXhGdW5jKFwiLCBjdWJlQXJncy5qb2luKCksIFwiKXtcIilcbiAgLy9NYXNrIGFyZ3MgdG9nZXRoZXJcbiAgdmFyIG1hc2tTdHIgPSBbXVxuICBmb3IodmFyIGk9MDsgaTwoMTw8ZGltZW5zaW9uKTsgKytpKSB7XG4gICAgbWFza1N0ci5wdXNoKFwiKHBcIiArIGkgKyBcIjw8XCIgKyBpICsgXCIpXCIpXG4gIH1cbiAgLy9HZW5lcmF0ZSB2YXJpYWJsZXMgYW5kIGdpZ2FudG8gc3dpdGNoIHN0YXRlbWVudFxuICBjb2RlLnB1c2goXCJ2YXIgbT0oXCIsIG1hc2tTdHIuam9pbihcIitcIiksIFwiKXwwO2lmKG09PT0wfHxtPT09XCIsICgxPDwoMTw8ZGltZW5zaW9uKSktMSwgXCIpe3JldHVybn1cIilcbiAgdmFyIGV4dHJhRnVuY3MgPSBbXVxuICB2YXIgY3VycmVudEZ1bmMgPSBbXVxuICBpZigxPDwoMTw8ZGltZW5zaW9uKSA8PSAxMjgpIHtcbiAgICBjb2RlLnB1c2goXCJzd2l0Y2gobSl7XCIpXG4gICAgY3VycmVudEZ1bmMgPSBjb2RlXG4gIH0gZWxzZSB7XG4gICAgY29kZS5wdXNoKFwic3dpdGNoKG0+Pj43KXtcIilcbiAgfVxuICBmb3IodmFyIGk9MDsgaTwxPDwoMTw8ZGltZW5zaW9uKTsgKytpKSB7XG4gICAgaWYoMTw8KDE8PGRpbWVuc2lvbikgPiAxMjgpIHtcbiAgICAgIGlmKChpJTEyOCk9PT0wKSB7XG4gICAgICAgIGlmKGV4dHJhRnVuY3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGN1cnJlbnRGdW5jLnB1c2goXCJ9fVwiKVxuICAgICAgICB9XG4gICAgICAgIHZhciBlZk5hbWUgPSBcInZFeHRyYVwiICsgZXh0cmFGdW5jcy5sZW5ndGhcbiAgICAgICAgY29kZS5wdXNoKFwiY2FzZSBcIiwgKGk+Pj43KSwgXCI6XCIsIGVmTmFtZSwgXCIobSYweDdmLFwiLCBleHRyYUFyZ3Muam9pbigpLCBcIik7YnJlYWs7XCIpXG4gICAgICAgIGN1cnJlbnRGdW5jID0gW1xuICAgICAgICAgIFwiZnVuY3Rpb24gXCIsIGVmTmFtZSwgXCIobSxcIiwgZXh0cmFBcmdzLmpvaW4oKSwgXCIpe3N3aXRjaChtKXtcIlxuICAgICAgICBdXG4gICAgICAgIGV4dHJhRnVuY3MucHVzaChjdXJyZW50RnVuYylcbiAgICAgIH0gIFxuICAgIH1cbiAgICBjdXJyZW50RnVuYy5wdXNoKFwiY2FzZSBcIiwgKGkmMHg3ZiksIFwiOlwiKVxuICAgIHZhciBjcm9zc2luZ3MgPSBuZXcgQXJyYXkoZGltZW5zaW9uKVxuICAgIHZhciBkZW5vbXMgPSBuZXcgQXJyYXkoZGltZW5zaW9uKVxuICAgIHZhciBjcm9zc2luZ0NvdW50ID0gbmV3IEFycmF5KGRpbWVuc2lvbilcbiAgICB2YXIgYmlhcyA9IG5ldyBBcnJheShkaW1lbnNpb24pXG4gICAgdmFyIHRvdGFsQ3Jvc3NpbmdzID0gMFxuICAgIGZvcih2YXIgaj0wOyBqPGRpbWVuc2lvbjsgKytqKSB7XG4gICAgICBjcm9zc2luZ3Nbal0gPSBbXVxuICAgICAgZGVub21zW2pdID0gW11cbiAgICAgIGNyb3NzaW5nQ291bnRbal0gPSAwXG4gICAgICBiaWFzW2pdID0gMFxuICAgIH1cbiAgICBmb3IodmFyIGo9MDsgajwoMTw8ZGltZW5zaW9uKTsgKytqKSB7XG4gICAgICBmb3IodmFyIGs9MDsgazxkaW1lbnNpb247ICsraykge1xuICAgICAgICB2YXIgdSA9IGogXiAoMTw8aylcbiAgICAgICAgaWYodSA+IGopIHtcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG4gICAgICAgIGlmKCEoaSYoMTw8dSkpICE9PSAhKGkmKDE8PGopKSkge1xuICAgICAgICAgIHZhciBzaWduID0gMVxuICAgICAgICAgIGlmKGkmKDE8PHUpKSB7XG4gICAgICAgICAgICBkZW5vbXNba10ucHVzaChcInZcIiArIHUgKyBcIi12XCIgKyBqKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkZW5vbXNba10ucHVzaChcInZcIiArIGogKyBcIi12XCIgKyB1KVxuICAgICAgICAgICAgc2lnbiA9IC1zaWduXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmKHNpZ24gPCAwKSB7XG4gICAgICAgICAgICBjcm9zc2luZ3Nba10ucHVzaChcIi12XCIgKyBqICsgXCItdlwiICsgdSlcbiAgICAgICAgICAgIGNyb3NzaW5nQ291bnRba10gKz0gMlxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjcm9zc2luZ3Nba10ucHVzaChcInZcIiArIGogKyBcIit2XCIgKyB1KVxuICAgICAgICAgICAgY3Jvc3NpbmdDb3VudFtrXSAtPSAyICAgICAgICAgICAgXG4gICAgICAgICAgfVxuICAgICAgICAgIHRvdGFsQ3Jvc3NpbmdzICs9IDFcbiAgICAgICAgICBmb3IodmFyIGw9MDsgbDxkaW1lbnNpb247ICsrbCkge1xuICAgICAgICAgICAgaWYobCA9PT0gaykge1xuICAgICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYodSYoMTw8bCkpIHtcbiAgICAgICAgICAgICAgYmlhc1tsXSArPSAxXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBiaWFzW2xdIC09IDFcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIHZlcnRleFN0ciA9IFtdXG4gICAgZm9yKHZhciBrPTA7IGs8ZGltZW5zaW9uOyArK2spIHtcbiAgICAgIGlmKGNyb3NzaW5nc1trXS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdmVydGV4U3RyLnB1c2goXCJkXCIgKyBrICsgXCItMC41XCIpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgY1N0ciA9IFwiXCJcbiAgICAgICAgaWYoY3Jvc3NpbmdDb3VudFtrXSA8IDApIHtcbiAgICAgICAgICBjU3RyID0gY3Jvc3NpbmdDb3VudFtrXSArIFwiKmNcIlxuICAgICAgICB9IGVsc2UgaWYoY3Jvc3NpbmdDb3VudFtrXSA+IDApIHtcbiAgICAgICAgICBjU3RyID0gXCIrXCIgKyBjcm9zc2luZ0NvdW50W2tdICsgXCIqY1wiXG4gICAgICAgIH1cbiAgICAgICAgdmFyIHdlaWdodCA9IDAuNSAqIChjcm9zc2luZ3Nba10ubGVuZ3RoIC8gdG90YWxDcm9zc2luZ3MpXG4gICAgICAgIHZhciBzaGlmdCA9IDAuNSArIDAuNSAqIChiaWFzW2tdIC8gdG90YWxDcm9zc2luZ3MpXG4gICAgICAgIHZlcnRleFN0ci5wdXNoKFwiZFwiICsgayArIFwiLVwiICsgc2hpZnQgKyBcIi1cIiArIHdlaWdodCArIFwiKihcIiArIGNyb3NzaW5nc1trXS5qb2luKFwiK1wiKSArIGNTdHIgKyBcIikvKFwiICsgZGVub21zW2tdLmpvaW4oXCIrXCIpICsgXCIpXCIpXG4gICAgICAgIFxuICAgICAgfVxuICAgIH1cbiAgICBjdXJyZW50RnVuYy5wdXNoKFwiYS5wdXNoKFtcIiwgdmVydGV4U3RyLmpvaW4oKSwgXCJdKTtcIixcbiAgICAgIFwiYnJlYWs7XCIpXG4gIH1cbiAgY29kZS5wdXNoKFwifX0sXCIpXG4gIGlmKGV4dHJhRnVuY3MubGVuZ3RoID4gMCkge1xuICAgIGN1cnJlbnRGdW5jLnB1c2goXCJ9fVwiKVxuICB9XG5cbiAgLy9DcmVhdGUgZmFjZSBmdW5jdGlvblxuICB2YXIgZmFjZUFyZ3MgPSBbXVxuICBmb3IodmFyIGk9MDsgaTwoMTw8KGRpbWVuc2lvbi0xKSk7ICsraSkge1xuICAgIGZhY2VBcmdzLnB1c2goXCJ2XCIgKyBpKVxuICB9XG4gIGZhY2VBcmdzLnB1c2goXCJjMFwiLCBcImMxXCIsIFwicDBcIiwgXCJwMVwiLCBcImFcIiwgXCJiXCIsIFwiY1wiKVxuICBjb2RlLnB1c2goXCJjZWxsOmZ1bmN0aW9uIGNlbGxGdW5jKFwiLCBmYWNlQXJncy5qb2luKCksIFwiKXtcIilcblxuICB2YXIgZmFjZXRzID0gdHJpYW5ndWxhdGVDdWJlKGRpbWVuc2lvbi0xKVxuICBjb2RlLnB1c2goXCJpZihwMCl7Yi5wdXNoKFwiLFxuICAgIGZhY2V0cy5tYXAoZnVuY3Rpb24oZikge1xuICAgICAgcmV0dXJuIFwiW1wiICsgZi5tYXAoZnVuY3Rpb24odikge1xuICAgICAgICByZXR1cm4gXCJ2XCIgKyB2XG4gICAgICB9KSArIFwiXVwiXG4gICAgfSkuam9pbigpLCBcIil9ZWxzZXtiLnB1c2goXCIsXG4gICAgZmFjZXRzLm1hcChmdW5jdGlvbihmKSB7XG4gICAgICB2YXIgZSA9IGYuc2xpY2UoKVxuICAgICAgZS5yZXZlcnNlKClcbiAgICAgIHJldHVybiBcIltcIiArIGUubWFwKGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgcmV0dXJuIFwidlwiICsgdlxuICAgICAgfSkgKyBcIl1cIlxuICAgIH0pLmpvaW4oKSxcbiAgICBcIil9fX0pO2Z1bmN0aW9uIFwiLCBmdW5jTmFtZSwgXCIoYXJyYXksbGV2ZWwpe3ZhciB2ZXJ0cz1bXSxjZWxscz1bXTtjb250b3VyKGFycmF5LHZlcnRzLGNlbGxzLGxldmVsKTtyZXR1cm4ge3Bvc2l0aW9uczp2ZXJ0cyxjZWxsczpjZWxsc307fSByZXR1cm4gXCIsIGZ1bmNOYW1lLCBcIjtcIilcblxuICBmb3IodmFyIGk9MDsgaTxleHRyYUZ1bmNzLmxlbmd0aDsgKytpKSB7XG4gICAgY29kZS5wdXNoKGV4dHJhRnVuY3NbaV0uam9pbihcIlwiKSlcbiAgfVxuXG4gIC8vQ29tcGlsZSBhbmQgbGlua1xuICB2YXIgcHJvYyA9IG5ldyBGdW5jdGlvbihcImdlbkNvbnRvdXJcIiwgY29kZS5qb2luKFwiXCIpKVxuICByZXR1cm4gcHJvYyhnZW5lcmF0ZUNvbnRvdXJFeHRyYWN0b3IpXG59XG5cbi8vMUQgY2FzZTogTmVlZCB0byBoYW5kbGUgc3BlY2lhbGx5XG5mdW5jdGlvbiBtZXNoMUQoYXJyYXksIGxldmVsKSB7XG4gIHZhciB6YyA9IHplcm9Dcm9zc2luZ3MoYXJyYXksIGxldmVsKVxuICB2YXIgbiA9IHpjLmxlbmd0aFxuICB2YXIgbnBvcyA9IG5ldyBBcnJheShuKVxuICB2YXIgbmNlbCA9IG5ldyBBcnJheShuKVxuICBmb3IodmFyIGk9MDsgaTxuOyArK2kpIHtcbiAgICBucG9zW2ldID0gWyB6Y1tpXSBdXG4gICAgbmNlbFtpXSA9IFsgaSBdXG4gIH1cbiAgcmV0dXJuIHtcbiAgICBwb3NpdGlvbnM6IG5wb3MsXG4gICAgY2VsbHM6IG5jZWxcbiAgfVxufVxuXG52YXIgQ0FDSEUgPSB7fVxuXG5mdW5jdGlvbiBzdXJmYWNlTmV0cyhhcnJheSxsZXZlbCkge1xuICBpZihhcnJheS5kaW1lbnNpb24gPD0gMCkge1xuICAgIHJldHVybiB7IHBvc2l0aW9uczogW10sIGNlbGxzOiBbXSB9XG4gIH0gZWxzZSBpZihhcnJheS5kaW1lbnNpb24gPT09IDEpIHtcbiAgICByZXR1cm4gbWVzaDFEKGFycmF5LCBsZXZlbClcbiAgfVxuICB2YXIgdHlwZXNpZyA9IGFycmF5Lm9yZGVyLmpvaW4oKSArIFwiLVwiICsgYXJyYXkuZHR5cGVcbiAgdmFyIHByb2MgPSBDQUNIRVt0eXBlc2lnXVxuICB2YXIgbGV2ZWwgPSAoK2xldmVsKSB8fCAwLjBcbiAgaWYoIXByb2MpIHtcbiAgICBwcm9jID0gQ0FDSEVbdHlwZXNpZ10gPSBidWlsZFN1cmZhY2VOZXRzKGFycmF5Lm9yZGVyLCBhcnJheS5kdHlwZSlcbiAgfVxuICByZXR1cm4gcHJvYyhhcnJheSxsZXZlbClcbn0iLCJleHBvcnQgY29uc3QgUkVWSVNJT04gPSAnMTU2JztcblxuZXhwb3J0IGNvbnN0IE1PVVNFID0geyBMRUZUOiAwLCBNSURETEU6IDEsIFJJR0hUOiAyLCBST1RBVEU6IDAsIERPTExZOiAxLCBQQU46IDIgfTtcbmV4cG9ydCBjb25zdCBUT1VDSCA9IHsgUk9UQVRFOiAwLCBQQU46IDEsIERPTExZX1BBTjogMiwgRE9MTFlfUk9UQVRFOiAzIH07XG5leHBvcnQgY29uc3QgQ3VsbEZhY2VOb25lID0gMDtcbmV4cG9ydCBjb25zdCBDdWxsRmFjZUJhY2sgPSAxO1xuZXhwb3J0IGNvbnN0IEN1bGxGYWNlRnJvbnQgPSAyO1xuZXhwb3J0IGNvbnN0IEN1bGxGYWNlRnJvbnRCYWNrID0gMztcbmV4cG9ydCBjb25zdCBCYXNpY1NoYWRvd01hcCA9IDA7XG5leHBvcnQgY29uc3QgUENGU2hhZG93TWFwID0gMTtcbmV4cG9ydCBjb25zdCBQQ0ZTb2Z0U2hhZG93TWFwID0gMjtcbmV4cG9ydCBjb25zdCBWU01TaGFkb3dNYXAgPSAzO1xuZXhwb3J0IGNvbnN0IEZyb250U2lkZSA9IDA7XG5leHBvcnQgY29uc3QgQmFja1NpZGUgPSAxO1xuZXhwb3J0IGNvbnN0IERvdWJsZVNpZGUgPSAyO1xuZXhwb3J0IGNvbnN0IFR3b1Bhc3NEb3VibGVTaWRlID0gMjsgLy8gcjE0OVxuZXhwb3J0IGNvbnN0IE5vQmxlbmRpbmcgPSAwO1xuZXhwb3J0IGNvbnN0IE5vcm1hbEJsZW5kaW5nID0gMTtcbmV4cG9ydCBjb25zdCBBZGRpdGl2ZUJsZW5kaW5nID0gMjtcbmV4cG9ydCBjb25zdCBTdWJ0cmFjdGl2ZUJsZW5kaW5nID0gMztcbmV4cG9ydCBjb25zdCBNdWx0aXBseUJsZW5kaW5nID0gNDtcbmV4cG9ydCBjb25zdCBDdXN0b21CbGVuZGluZyA9IDU7XG5leHBvcnQgY29uc3QgQWRkRXF1YXRpb24gPSAxMDA7XG5leHBvcnQgY29uc3QgU3VidHJhY3RFcXVhdGlvbiA9IDEwMTtcbmV4cG9ydCBjb25zdCBSZXZlcnNlU3VidHJhY3RFcXVhdGlvbiA9IDEwMjtcbmV4cG9ydCBjb25zdCBNaW5FcXVhdGlvbiA9IDEwMztcbmV4cG9ydCBjb25zdCBNYXhFcXVhdGlvbiA9IDEwNDtcbmV4cG9ydCBjb25zdCBaZXJvRmFjdG9yID0gMjAwO1xuZXhwb3J0IGNvbnN0IE9uZUZhY3RvciA9IDIwMTtcbmV4cG9ydCBjb25zdCBTcmNDb2xvckZhY3RvciA9IDIwMjtcbmV4cG9ydCBjb25zdCBPbmVNaW51c1NyY0NvbG9yRmFjdG9yID0gMjAzO1xuZXhwb3J0IGNvbnN0IFNyY0FscGhhRmFjdG9yID0gMjA0O1xuZXhwb3J0IGNvbnN0IE9uZU1pbnVzU3JjQWxwaGFGYWN0b3IgPSAyMDU7XG5leHBvcnQgY29uc3QgRHN0QWxwaGFGYWN0b3IgPSAyMDY7XG5leHBvcnQgY29uc3QgT25lTWludXNEc3RBbHBoYUZhY3RvciA9IDIwNztcbmV4cG9ydCBjb25zdCBEc3RDb2xvckZhY3RvciA9IDIwODtcbmV4cG9ydCBjb25zdCBPbmVNaW51c0RzdENvbG9yRmFjdG9yID0gMjA5O1xuZXhwb3J0IGNvbnN0IFNyY0FscGhhU2F0dXJhdGVGYWN0b3IgPSAyMTA7XG5leHBvcnQgY29uc3QgTmV2ZXJEZXB0aCA9IDA7XG5leHBvcnQgY29uc3QgQWx3YXlzRGVwdGggPSAxO1xuZXhwb3J0IGNvbnN0IExlc3NEZXB0aCA9IDI7XG5leHBvcnQgY29uc3QgTGVzc0VxdWFsRGVwdGggPSAzO1xuZXhwb3J0IGNvbnN0IEVxdWFsRGVwdGggPSA0O1xuZXhwb3J0IGNvbnN0IEdyZWF0ZXJFcXVhbERlcHRoID0gNTtcbmV4cG9ydCBjb25zdCBHcmVhdGVyRGVwdGggPSA2O1xuZXhwb3J0IGNvbnN0IE5vdEVxdWFsRGVwdGggPSA3O1xuZXhwb3J0IGNvbnN0IE11bHRpcGx5T3BlcmF0aW9uID0gMDtcbmV4cG9ydCBjb25zdCBNaXhPcGVyYXRpb24gPSAxO1xuZXhwb3J0IGNvbnN0IEFkZE9wZXJhdGlvbiA9IDI7XG5leHBvcnQgY29uc3QgTm9Ub25lTWFwcGluZyA9IDA7XG5leHBvcnQgY29uc3QgTGluZWFyVG9uZU1hcHBpbmcgPSAxO1xuZXhwb3J0IGNvbnN0IFJlaW5oYXJkVG9uZU1hcHBpbmcgPSAyO1xuZXhwb3J0IGNvbnN0IENpbmVvblRvbmVNYXBwaW5nID0gMztcbmV4cG9ydCBjb25zdCBBQ0VTRmlsbWljVG9uZU1hcHBpbmcgPSA0O1xuZXhwb3J0IGNvbnN0IEN1c3RvbVRvbmVNYXBwaW5nID0gNTtcblxuZXhwb3J0IGNvbnN0IFVWTWFwcGluZyA9IDMwMDtcbmV4cG9ydCBjb25zdCBDdWJlUmVmbGVjdGlvbk1hcHBpbmcgPSAzMDE7XG5leHBvcnQgY29uc3QgQ3ViZVJlZnJhY3Rpb25NYXBwaW5nID0gMzAyO1xuZXhwb3J0IGNvbnN0IEVxdWlyZWN0YW5ndWxhclJlZmxlY3Rpb25NYXBwaW5nID0gMzAzO1xuZXhwb3J0IGNvbnN0IEVxdWlyZWN0YW5ndWxhclJlZnJhY3Rpb25NYXBwaW5nID0gMzA0O1xuZXhwb3J0IGNvbnN0IEN1YmVVVlJlZmxlY3Rpb25NYXBwaW5nID0gMzA2O1xuZXhwb3J0IGNvbnN0IFJlcGVhdFdyYXBwaW5nID0gMTAwMDtcbmV4cG9ydCBjb25zdCBDbGFtcFRvRWRnZVdyYXBwaW5nID0gMTAwMTtcbmV4cG9ydCBjb25zdCBNaXJyb3JlZFJlcGVhdFdyYXBwaW5nID0gMTAwMjtcbmV4cG9ydCBjb25zdCBOZWFyZXN0RmlsdGVyID0gMTAwMztcbmV4cG9ydCBjb25zdCBOZWFyZXN0TWlwbWFwTmVhcmVzdEZpbHRlciA9IDEwMDQ7XG5leHBvcnQgY29uc3QgTmVhcmVzdE1pcE1hcE5lYXJlc3RGaWx0ZXIgPSAxMDA0O1xuZXhwb3J0IGNvbnN0IE5lYXJlc3RNaXBtYXBMaW5lYXJGaWx0ZXIgPSAxMDA1O1xuZXhwb3J0IGNvbnN0IE5lYXJlc3RNaXBNYXBMaW5lYXJGaWx0ZXIgPSAxMDA1O1xuZXhwb3J0IGNvbnN0IExpbmVhckZpbHRlciA9IDEwMDY7XG5leHBvcnQgY29uc3QgTGluZWFyTWlwbWFwTmVhcmVzdEZpbHRlciA9IDEwMDc7XG5leHBvcnQgY29uc3QgTGluZWFyTWlwTWFwTmVhcmVzdEZpbHRlciA9IDEwMDc7XG5leHBvcnQgY29uc3QgTGluZWFyTWlwbWFwTGluZWFyRmlsdGVyID0gMTAwODtcbmV4cG9ydCBjb25zdCBMaW5lYXJNaXBNYXBMaW5lYXJGaWx0ZXIgPSAxMDA4O1xuZXhwb3J0IGNvbnN0IFVuc2lnbmVkQnl0ZVR5cGUgPSAxMDA5O1xuZXhwb3J0IGNvbnN0IEJ5dGVUeXBlID0gMTAxMDtcbmV4cG9ydCBjb25zdCBTaG9ydFR5cGUgPSAxMDExO1xuZXhwb3J0IGNvbnN0IFVuc2lnbmVkU2hvcnRUeXBlID0gMTAxMjtcbmV4cG9ydCBjb25zdCBJbnRUeXBlID0gMTAxMztcbmV4cG9ydCBjb25zdCBVbnNpZ25lZEludFR5cGUgPSAxMDE0O1xuZXhwb3J0IGNvbnN0IEZsb2F0VHlwZSA9IDEwMTU7XG5leHBvcnQgY29uc3QgSGFsZkZsb2F0VHlwZSA9IDEwMTY7XG5leHBvcnQgY29uc3QgVW5zaWduZWRTaG9ydDQ0NDRUeXBlID0gMTAxNztcbmV4cG9ydCBjb25zdCBVbnNpZ25lZFNob3J0NTU1MVR5cGUgPSAxMDE4O1xuZXhwb3J0IGNvbnN0IFVuc2lnbmVkSW50MjQ4VHlwZSA9IDEwMjA7XG5leHBvcnQgY29uc3QgQWxwaGFGb3JtYXQgPSAxMDIxO1xuZXhwb3J0IGNvbnN0IFJHQkFGb3JtYXQgPSAxMDIzO1xuZXhwb3J0IGNvbnN0IEx1bWluYW5jZUZvcm1hdCA9IDEwMjQ7XG5leHBvcnQgY29uc3QgTHVtaW5hbmNlQWxwaGFGb3JtYXQgPSAxMDI1O1xuZXhwb3J0IGNvbnN0IERlcHRoRm9ybWF0ID0gMTAyNjtcbmV4cG9ydCBjb25zdCBEZXB0aFN0ZW5jaWxGb3JtYXQgPSAxMDI3O1xuZXhwb3J0IGNvbnN0IFJlZEZvcm1hdCA9IDEwMjg7XG5leHBvcnQgY29uc3QgUmVkSW50ZWdlckZvcm1hdCA9IDEwMjk7XG5leHBvcnQgY29uc3QgUkdGb3JtYXQgPSAxMDMwO1xuZXhwb3J0IGNvbnN0IFJHSW50ZWdlckZvcm1hdCA9IDEwMzE7XG5leHBvcnQgY29uc3QgUkdCQUludGVnZXJGb3JtYXQgPSAxMDMzO1xuXG5leHBvcnQgY29uc3QgUkdCX1MzVENfRFhUMV9Gb3JtYXQgPSAzMzc3NjtcbmV4cG9ydCBjb25zdCBSR0JBX1MzVENfRFhUMV9Gb3JtYXQgPSAzMzc3NztcbmV4cG9ydCBjb25zdCBSR0JBX1MzVENfRFhUM19Gb3JtYXQgPSAzMzc3ODtcbmV4cG9ydCBjb25zdCBSR0JBX1MzVENfRFhUNV9Gb3JtYXQgPSAzMzc3OTtcbmV4cG9ydCBjb25zdCBSR0JfUFZSVENfNEJQUFYxX0Zvcm1hdCA9IDM1ODQwO1xuZXhwb3J0IGNvbnN0IFJHQl9QVlJUQ18yQlBQVjFfRm9ybWF0ID0gMzU4NDE7XG5leHBvcnQgY29uc3QgUkdCQV9QVlJUQ180QlBQVjFfRm9ybWF0ID0gMzU4NDI7XG5leHBvcnQgY29uc3QgUkdCQV9QVlJUQ18yQlBQVjFfRm9ybWF0ID0gMzU4NDM7XG5leHBvcnQgY29uc3QgUkdCX0VUQzFfRm9ybWF0ID0gMzYxOTY7XG5leHBvcnQgY29uc3QgUkdCX0VUQzJfRm9ybWF0ID0gMzc0OTI7XG5leHBvcnQgY29uc3QgUkdCQV9FVEMyX0VBQ19Gb3JtYXQgPSAzNzQ5NjtcbmV4cG9ydCBjb25zdCBSR0JBX0FTVENfNHg0X0Zvcm1hdCA9IDM3ODA4O1xuZXhwb3J0IGNvbnN0IFJHQkFfQVNUQ181eDRfRm9ybWF0ID0gMzc4MDk7XG5leHBvcnQgY29uc3QgUkdCQV9BU1RDXzV4NV9Gb3JtYXQgPSAzNzgxMDtcbmV4cG9ydCBjb25zdCBSR0JBX0FTVENfNng1X0Zvcm1hdCA9IDM3ODExO1xuZXhwb3J0IGNvbnN0IFJHQkFfQVNUQ182eDZfRm9ybWF0ID0gMzc4MTI7XG5leHBvcnQgY29uc3QgUkdCQV9BU1RDXzh4NV9Gb3JtYXQgPSAzNzgxMztcbmV4cG9ydCBjb25zdCBSR0JBX0FTVENfOHg2X0Zvcm1hdCA9IDM3ODE0O1xuZXhwb3J0IGNvbnN0IFJHQkFfQVNUQ184eDhfRm9ybWF0ID0gMzc4MTU7XG5leHBvcnQgY29uc3QgUkdCQV9BU1RDXzEweDVfRm9ybWF0ID0gMzc4MTY7XG5leHBvcnQgY29uc3QgUkdCQV9BU1RDXzEweDZfRm9ybWF0ID0gMzc4MTc7XG5leHBvcnQgY29uc3QgUkdCQV9BU1RDXzEweDhfRm9ybWF0ID0gMzc4MTg7XG5leHBvcnQgY29uc3QgUkdCQV9BU1RDXzEweDEwX0Zvcm1hdCA9IDM3ODE5O1xuZXhwb3J0IGNvbnN0IFJHQkFfQVNUQ18xMngxMF9Gb3JtYXQgPSAzNzgyMDtcbmV4cG9ydCBjb25zdCBSR0JBX0FTVENfMTJ4MTJfRm9ybWF0ID0gMzc4MjE7XG5leHBvcnQgY29uc3QgUkdCQV9CUFRDX0Zvcm1hdCA9IDM2NDkyO1xuZXhwb3J0IGNvbnN0IFJHQl9CUFRDX1NJR05FRF9Gb3JtYXQgPSAzNjQ5NDtcbmV4cG9ydCBjb25zdCBSR0JfQlBUQ19VTlNJR05FRF9Gb3JtYXQgPSAzNjQ5NTtcbmV4cG9ydCBjb25zdCBSRURfUkdUQzFfRm9ybWF0ID0gMzYyODM7XG5leHBvcnQgY29uc3QgU0lHTkVEX1JFRF9SR1RDMV9Gb3JtYXQgPSAzNjI4NDtcbmV4cG9ydCBjb25zdCBSRURfR1JFRU5fUkdUQzJfRm9ybWF0ID0gMzYyODU7XG5leHBvcnQgY29uc3QgU0lHTkVEX1JFRF9HUkVFTl9SR1RDMl9Gb3JtYXQgPSAzNjI4NjtcbmV4cG9ydCBjb25zdCBMb29wT25jZSA9IDIyMDA7XG5leHBvcnQgY29uc3QgTG9vcFJlcGVhdCA9IDIyMDE7XG5leHBvcnQgY29uc3QgTG9vcFBpbmdQb25nID0gMjIwMjtcbmV4cG9ydCBjb25zdCBJbnRlcnBvbGF0ZURpc2NyZXRlID0gMjMwMDtcbmV4cG9ydCBjb25zdCBJbnRlcnBvbGF0ZUxpbmVhciA9IDIzMDE7XG5leHBvcnQgY29uc3QgSW50ZXJwb2xhdGVTbW9vdGggPSAyMzAyO1xuZXhwb3J0IGNvbnN0IFplcm9DdXJ2YXR1cmVFbmRpbmcgPSAyNDAwO1xuZXhwb3J0IGNvbnN0IFplcm9TbG9wZUVuZGluZyA9IDI0MDE7XG5leHBvcnQgY29uc3QgV3JhcEFyb3VuZEVuZGluZyA9IDI0MDI7XG5leHBvcnQgY29uc3QgTm9ybWFsQW5pbWF0aW9uQmxlbmRNb2RlID0gMjUwMDtcbmV4cG9ydCBjb25zdCBBZGRpdGl2ZUFuaW1hdGlvbkJsZW5kTW9kZSA9IDI1MDE7XG5leHBvcnQgY29uc3QgVHJpYW5nbGVzRHJhd01vZGUgPSAwO1xuZXhwb3J0IGNvbnN0IFRyaWFuZ2xlU3RyaXBEcmF3TW9kZSA9IDE7XG5leHBvcnQgY29uc3QgVHJpYW5nbGVGYW5EcmF3TW9kZSA9IDI7XG4vKiogQGRlcHJlY2F0ZWQgVXNlIExpbmVhclNSR0JDb2xvclNwYWNlIG9yIE5vQ29sb3JTcGFjZSBpbiB0aHJlZS5qcyByMTUyKy4gKi9cbmV4cG9ydCBjb25zdCBMaW5lYXJFbmNvZGluZyA9IDMwMDA7XG4vKiogQGRlcHJlY2F0ZWQgVXNlIFNSR0JDb2xvclNwYWNlIGluIHRocmVlLmpzIHIxNTIrLiAqL1xuZXhwb3J0IGNvbnN0IHNSR0JFbmNvZGluZyA9IDMwMDE7XG5leHBvcnQgY29uc3QgQmFzaWNEZXB0aFBhY2tpbmcgPSAzMjAwO1xuZXhwb3J0IGNvbnN0IFJHQkFEZXB0aFBhY2tpbmcgPSAzMjAxO1xuZXhwb3J0IGNvbnN0IFRhbmdlbnRTcGFjZU5vcm1hbE1hcCA9IDA7XG5leHBvcnQgY29uc3QgT2JqZWN0U3BhY2VOb3JtYWxNYXAgPSAxO1xuXG4vLyBDb2xvciBzcGFjZSBzdHJpbmcgaWRlbnRpZmllcnMsIG1hdGNoaW5nIENTUyBDb2xvciBNb2R1bGUgTGV2ZWwgNCBhbmQgV2ViR1BVIG5hbWVzIHdoZXJlIGF2YWlsYWJsZS5cbmV4cG9ydCBjb25zdCBOb0NvbG9yU3BhY2UgPSAnJztcbmV4cG9ydCBjb25zdCBTUkdCQ29sb3JTcGFjZSA9ICdzcmdiJztcbmV4cG9ydCBjb25zdCBMaW5lYXJTUkdCQ29sb3JTcGFjZSA9ICdzcmdiLWxpbmVhcic7XG5leHBvcnQgY29uc3QgRGlzcGxheVAzQ29sb3JTcGFjZSA9ICdkaXNwbGF5LXAzJztcbmV4cG9ydCBjb25zdCBMaW5lYXJEaXNwbGF5UDNDb2xvclNwYWNlID0gJ2Rpc3BsYXktcDMtbGluZWFyJztcblxuZXhwb3J0IGNvbnN0IFplcm9TdGVuY2lsT3AgPSAwO1xuZXhwb3J0IGNvbnN0IEtlZXBTdGVuY2lsT3AgPSA3NjgwO1xuZXhwb3J0IGNvbnN0IFJlcGxhY2VTdGVuY2lsT3AgPSA3NjgxO1xuZXhwb3J0IGNvbnN0IEluY3JlbWVudFN0ZW5jaWxPcCA9IDc2ODI7XG5leHBvcnQgY29uc3QgRGVjcmVtZW50U3RlbmNpbE9wID0gNzY4MztcbmV4cG9ydCBjb25zdCBJbmNyZW1lbnRXcmFwU3RlbmNpbE9wID0gMzQwNTU7XG5leHBvcnQgY29uc3QgRGVjcmVtZW50V3JhcFN0ZW5jaWxPcCA9IDM0MDU2O1xuZXhwb3J0IGNvbnN0IEludmVydFN0ZW5jaWxPcCA9IDUzODY7XG5cbmV4cG9ydCBjb25zdCBOZXZlclN0ZW5jaWxGdW5jID0gNTEyO1xuZXhwb3J0IGNvbnN0IExlc3NTdGVuY2lsRnVuYyA9IDUxMztcbmV4cG9ydCBjb25zdCBFcXVhbFN0ZW5jaWxGdW5jID0gNTE0O1xuZXhwb3J0IGNvbnN0IExlc3NFcXVhbFN0ZW5jaWxGdW5jID0gNTE1O1xuZXhwb3J0IGNvbnN0IEdyZWF0ZXJTdGVuY2lsRnVuYyA9IDUxNjtcbmV4cG9ydCBjb25zdCBOb3RFcXVhbFN0ZW5jaWxGdW5jID0gNTE3O1xuZXhwb3J0IGNvbnN0IEdyZWF0ZXJFcXVhbFN0ZW5jaWxGdW5jID0gNTE4O1xuZXhwb3J0IGNvbnN0IEFsd2F5c1N0ZW5jaWxGdW5jID0gNTE5O1xuXG5leHBvcnQgY29uc3QgTmV2ZXJDb21wYXJlID0gNTEyO1xuZXhwb3J0IGNvbnN0IExlc3NDb21wYXJlID0gNTEzO1xuZXhwb3J0IGNvbnN0IEVxdWFsQ29tcGFyZSA9IDUxNDtcbmV4cG9ydCBjb25zdCBMZXNzRXF1YWxDb21wYXJlID0gNTE1O1xuZXhwb3J0IGNvbnN0IEdyZWF0ZXJDb21wYXJlID0gNTE2O1xuZXhwb3J0IGNvbnN0IE5vdEVxdWFsQ29tcGFyZSA9IDUxNztcbmV4cG9ydCBjb25zdCBHcmVhdGVyRXF1YWxDb21wYXJlID0gNTE4O1xuZXhwb3J0IGNvbnN0IEFsd2F5c0NvbXBhcmUgPSA1MTk7XG5cbmV4cG9ydCBjb25zdCBTdGF0aWNEcmF3VXNhZ2UgPSAzNTA0NDtcbmV4cG9ydCBjb25zdCBEeW5hbWljRHJhd1VzYWdlID0gMzUwNDg7XG5leHBvcnQgY29uc3QgU3RyZWFtRHJhd1VzYWdlID0gMzUwNDA7XG5leHBvcnQgY29uc3QgU3RhdGljUmVhZFVzYWdlID0gMzUwNDU7XG5leHBvcnQgY29uc3QgRHluYW1pY1JlYWRVc2FnZSA9IDM1MDQ5O1xuZXhwb3J0IGNvbnN0IFN0cmVhbVJlYWRVc2FnZSA9IDM1MDQxO1xuZXhwb3J0IGNvbnN0IFN0YXRpY0NvcHlVc2FnZSA9IDM1MDQ2O1xuZXhwb3J0IGNvbnN0IER5bmFtaWNDb3B5VXNhZ2UgPSAzNTA1MDtcbmV4cG9ydCBjb25zdCBTdHJlYW1Db3B5VXNhZ2UgPSAzNTA0MjtcblxuZXhwb3J0IGNvbnN0IEdMU0wxID0gJzEwMCc7XG5leHBvcnQgY29uc3QgR0xTTDMgPSAnMzAwIGVzJztcblxuZXhwb3J0IGNvbnN0IF9TUkdCQUZvcm1hdCA9IDEwMzU7IC8vIGZhbGxiYWNrIGZvciBXZWJHTCAxXG5cbmV4cG9ydCBjb25zdCBXZWJHTENvb3JkaW5hdGVTeXN0ZW0gPSAyMDAwO1xuZXhwb3J0IGNvbnN0IFdlYkdQVUNvb3JkaW5hdGVTeXN0ZW0gPSAyMDAxO1xuIiwiaW1wb3J0IHsgVmVjdG9yMyB9IGZyb20gJy4uL21hdGgvVmVjdG9yMy5qcyc7XG5pbXBvcnQgeyBWZWN0b3IyIH0gZnJvbSAnLi4vbWF0aC9WZWN0b3IyLmpzJztcbmltcG9ydCB7IGRlbm9ybWFsaXplLCBub3JtYWxpemUgfSBmcm9tICcuLi9tYXRoL01hdGhVdGlscy5qcyc7XG5pbXBvcnQgeyBTdGF0aWNEcmF3VXNhZ2UsIEZsb2F0VHlwZSB9IGZyb20gJy4uL2NvbnN0YW50cy5qcyc7XG5pbXBvcnQgeyBmcm9tSGFsZkZsb2F0LCB0b0hhbGZGbG9hdCB9IGZyb20gJy4uL2V4dHJhcy9EYXRhVXRpbHMuanMnO1xuXG5jb25zdCBfdmVjdG9yID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xuY29uc3QgX3ZlY3RvcjIgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IyKCk7XG5cbmNsYXNzIEJ1ZmZlckF0dHJpYnV0ZSB7XG5cblx0Y29uc3RydWN0b3IoIGFycmF5LCBpdGVtU2l6ZSwgbm9ybWFsaXplZCA9IGZhbHNlICkge1xuXG5cdFx0aWYgKCBBcnJheS5pc0FycmF5KCBhcnJheSApICkge1xuXG5cdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCAnVEhSRUUuQnVmZmVyQXR0cmlidXRlOiBhcnJheSBzaG91bGQgYmUgYSBUeXBlZCBBcnJheS4nICk7XG5cblx0XHR9XG5cblx0XHR0aGlzLmlzQnVmZmVyQXR0cmlidXRlID0gdHJ1ZTtcblxuXHRcdHRoaXMubmFtZSA9ICcnO1xuXG5cdFx0dGhpcy5hcnJheSA9IGFycmF5O1xuXHRcdHRoaXMuaXRlbVNpemUgPSBpdGVtU2l6ZTtcblx0XHR0aGlzLmNvdW50ID0gYXJyYXkgIT09IHVuZGVmaW5lZCA/IGFycmF5Lmxlbmd0aCAvIGl0ZW1TaXplIDogMDtcblx0XHR0aGlzLm5vcm1hbGl6ZWQgPSBub3JtYWxpemVkO1xuXG5cdFx0dGhpcy51c2FnZSA9IFN0YXRpY0RyYXdVc2FnZTtcblx0XHR0aGlzLnVwZGF0ZVJhbmdlID0geyBvZmZzZXQ6IDAsIGNvdW50OiAtIDEgfTtcblx0XHR0aGlzLmdwdVR5cGUgPSBGbG9hdFR5cGU7XG5cblx0XHR0aGlzLnZlcnNpb24gPSAwO1xuXG5cdH1cblxuXHRvblVwbG9hZENhbGxiYWNrKCkge31cblxuXHRzZXQgbmVlZHNVcGRhdGUoIHZhbHVlICkge1xuXG5cdFx0aWYgKCB2YWx1ZSA9PT0gdHJ1ZSApIHRoaXMudmVyc2lvbiArKztcblxuXHR9XG5cblx0c2V0VXNhZ2UoIHZhbHVlICkge1xuXG5cdFx0dGhpcy51c2FnZSA9IHZhbHVlO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGNvcHkoIHNvdXJjZSApIHtcblxuXHRcdHRoaXMubmFtZSA9IHNvdXJjZS5uYW1lO1xuXHRcdHRoaXMuYXJyYXkgPSBuZXcgc291cmNlLmFycmF5LmNvbnN0cnVjdG9yKCBzb3VyY2UuYXJyYXkgKTtcblx0XHR0aGlzLml0ZW1TaXplID0gc291cmNlLml0ZW1TaXplO1xuXHRcdHRoaXMuY291bnQgPSBzb3VyY2UuY291bnQ7XG5cdFx0dGhpcy5ub3JtYWxpemVkID0gc291cmNlLm5vcm1hbGl6ZWQ7XG5cblx0XHR0aGlzLnVzYWdlID0gc291cmNlLnVzYWdlO1xuXHRcdHRoaXMuZ3B1VHlwZSA9IHNvdXJjZS5ncHVUeXBlO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGNvcHlBdCggaW5kZXgxLCBhdHRyaWJ1dGUsIGluZGV4MiApIHtcblxuXHRcdGluZGV4MSAqPSB0aGlzLml0ZW1TaXplO1xuXHRcdGluZGV4MiAqPSBhdHRyaWJ1dGUuaXRlbVNpemU7XG5cblx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSB0aGlzLml0ZW1TaXplOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0dGhpcy5hcnJheVsgaW5kZXgxICsgaSBdID0gYXR0cmlidXRlLmFycmF5WyBpbmRleDIgKyBpIF07XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Y29weUFycmF5KCBhcnJheSApIHtcblxuXHRcdHRoaXMuYXJyYXkuc2V0KCBhcnJheSApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGFwcGx5TWF0cml4MyggbSApIHtcblxuXHRcdGlmICggdGhpcy5pdGVtU2l6ZSA9PT0gMiApIHtcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gdGhpcy5jb3VudDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0X3ZlY3RvcjIuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggdGhpcywgaSApO1xuXHRcdFx0XHRfdmVjdG9yMi5hcHBseU1hdHJpeDMoIG0gKTtcblxuXHRcdFx0XHR0aGlzLnNldFhZKCBpLCBfdmVjdG9yMi54LCBfdmVjdG9yMi55ICk7XG5cblx0XHRcdH1cblxuXHRcdH0gZWxzZSBpZiAoIHRoaXMuaXRlbVNpemUgPT09IDMgKSB7XG5cblx0XHRcdGZvciAoIGxldCBpID0gMCwgbCA9IHRoaXMuY291bnQ7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdF92ZWN0b3IuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggdGhpcywgaSApO1xuXHRcdFx0XHRfdmVjdG9yLmFwcGx5TWF0cml4MyggbSApO1xuXG5cdFx0XHRcdHRoaXMuc2V0WFlaKCBpLCBfdmVjdG9yLngsIF92ZWN0b3IueSwgX3ZlY3Rvci56ICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRhcHBseU1hdHJpeDQoIG0gKSB7XG5cblx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSB0aGlzLmNvdW50OyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0X3ZlY3Rvci5mcm9tQnVmZmVyQXR0cmlidXRlKCB0aGlzLCBpICk7XG5cblx0XHRcdF92ZWN0b3IuYXBwbHlNYXRyaXg0KCBtICk7XG5cblx0XHRcdHRoaXMuc2V0WFlaKCBpLCBfdmVjdG9yLngsIF92ZWN0b3IueSwgX3ZlY3Rvci56ICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0YXBwbHlOb3JtYWxNYXRyaXgoIG0gKSB7XG5cblx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSB0aGlzLmNvdW50OyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0X3ZlY3Rvci5mcm9tQnVmZmVyQXR0cmlidXRlKCB0aGlzLCBpICk7XG5cblx0XHRcdF92ZWN0b3IuYXBwbHlOb3JtYWxNYXRyaXgoIG0gKTtcblxuXHRcdFx0dGhpcy5zZXRYWVooIGksIF92ZWN0b3IueCwgX3ZlY3Rvci55LCBfdmVjdG9yLnogKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHR0cmFuc2Zvcm1EaXJlY3Rpb24oIG0gKSB7XG5cblx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSB0aGlzLmNvdW50OyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0X3ZlY3Rvci5mcm9tQnVmZmVyQXR0cmlidXRlKCB0aGlzLCBpICk7XG5cblx0XHRcdF92ZWN0b3IudHJhbnNmb3JtRGlyZWN0aW9uKCBtICk7XG5cblx0XHRcdHRoaXMuc2V0WFlaKCBpLCBfdmVjdG9yLngsIF92ZWN0b3IueSwgX3ZlY3Rvci56ICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c2V0KCB2YWx1ZSwgb2Zmc2V0ID0gMCApIHtcblxuXHRcdC8vIE1hdGNoaW5nIEJ1ZmZlckF0dHJpYnV0ZSBjb25zdHJ1Y3RvciwgZG8gbm90IG5vcm1hbGl6ZSB0aGUgYXJyYXkuXG5cdFx0dGhpcy5hcnJheS5zZXQoIHZhbHVlLCBvZmZzZXQgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRnZXRDb21wb25lbnQoIGluZGV4LCBjb21wb25lbnQgKSB7XG5cblx0XHRsZXQgdmFsdWUgPSB0aGlzLmFycmF5WyBpbmRleCAqIHRoaXMuaXRlbVNpemUgKyBjb21wb25lbnQgXTtcblxuXHRcdGlmICggdGhpcy5ub3JtYWxpemVkICkgdmFsdWUgPSBkZW5vcm1hbGl6ZSggdmFsdWUsIHRoaXMuYXJyYXkgKTtcblxuXHRcdHJldHVybiB2YWx1ZTtcblxuXHR9XG5cblx0c2V0Q29tcG9uZW50KCBpbmRleCwgY29tcG9uZW50LCB2YWx1ZSApIHtcblxuXHRcdGlmICggdGhpcy5ub3JtYWxpemVkICkgdmFsdWUgPSBub3JtYWxpemUoIHZhbHVlLCB0aGlzLmFycmF5ICk7XG5cblx0XHR0aGlzLmFycmF5WyBpbmRleCAqIHRoaXMuaXRlbVNpemUgKyBjb21wb25lbnQgXSA9IHZhbHVlO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGdldFgoIGluZGV4ICkge1xuXG5cdFx0bGV0IHggPSB0aGlzLmFycmF5WyBpbmRleCAqIHRoaXMuaXRlbVNpemUgXTtcblxuXHRcdGlmICggdGhpcy5ub3JtYWxpemVkICkgeCA9IGRlbm9ybWFsaXplKCB4LCB0aGlzLmFycmF5ICk7XG5cblx0XHRyZXR1cm4geDtcblxuXHR9XG5cblx0c2V0WCggaW5kZXgsIHggKSB7XG5cblx0XHRpZiAoIHRoaXMubm9ybWFsaXplZCApIHggPSBub3JtYWxpemUoIHgsIHRoaXMuYXJyYXkgKTtcblxuXHRcdHRoaXMuYXJyYXlbIGluZGV4ICogdGhpcy5pdGVtU2l6ZSBdID0geDtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRnZXRZKCBpbmRleCApIHtcblxuXHRcdGxldCB5ID0gdGhpcy5hcnJheVsgaW5kZXggKiB0aGlzLml0ZW1TaXplICsgMSBdO1xuXG5cdFx0aWYgKCB0aGlzLm5vcm1hbGl6ZWQgKSB5ID0gZGVub3JtYWxpemUoIHksIHRoaXMuYXJyYXkgKTtcblxuXHRcdHJldHVybiB5O1xuXG5cdH1cblxuXHRzZXRZKCBpbmRleCwgeSApIHtcblxuXHRcdGlmICggdGhpcy5ub3JtYWxpemVkICkgeSA9IG5vcm1hbGl6ZSggeSwgdGhpcy5hcnJheSApO1xuXG5cdFx0dGhpcy5hcnJheVsgaW5kZXggKiB0aGlzLml0ZW1TaXplICsgMSBdID0geTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRnZXRaKCBpbmRleCApIHtcblxuXHRcdGxldCB6ID0gdGhpcy5hcnJheVsgaW5kZXggKiB0aGlzLml0ZW1TaXplICsgMiBdO1xuXG5cdFx0aWYgKCB0aGlzLm5vcm1hbGl6ZWQgKSB6ID0gZGVub3JtYWxpemUoIHosIHRoaXMuYXJyYXkgKTtcblxuXHRcdHJldHVybiB6O1xuXG5cdH1cblxuXHRzZXRaKCBpbmRleCwgeiApIHtcblxuXHRcdGlmICggdGhpcy5ub3JtYWxpemVkICkgeiA9IG5vcm1hbGl6ZSggeiwgdGhpcy5hcnJheSApO1xuXG5cdFx0dGhpcy5hcnJheVsgaW5kZXggKiB0aGlzLml0ZW1TaXplICsgMiBdID0gejtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRnZXRXKCBpbmRleCApIHtcblxuXHRcdGxldCB3ID0gdGhpcy5hcnJheVsgaW5kZXggKiB0aGlzLml0ZW1TaXplICsgMyBdO1xuXG5cdFx0aWYgKCB0aGlzLm5vcm1hbGl6ZWQgKSB3ID0gZGVub3JtYWxpemUoIHcsIHRoaXMuYXJyYXkgKTtcblxuXHRcdHJldHVybiB3O1xuXG5cdH1cblxuXHRzZXRXKCBpbmRleCwgdyApIHtcblxuXHRcdGlmICggdGhpcy5ub3JtYWxpemVkICkgdyA9IG5vcm1hbGl6ZSggdywgdGhpcy5hcnJheSApO1xuXG5cdFx0dGhpcy5hcnJheVsgaW5kZXggKiB0aGlzLml0ZW1TaXplICsgMyBdID0gdztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzZXRYWSggaW5kZXgsIHgsIHkgKSB7XG5cblx0XHRpbmRleCAqPSB0aGlzLml0ZW1TaXplO1xuXG5cdFx0aWYgKCB0aGlzLm5vcm1hbGl6ZWQgKSB7XG5cblx0XHRcdHggPSBub3JtYWxpemUoIHgsIHRoaXMuYXJyYXkgKTtcblx0XHRcdHkgPSBub3JtYWxpemUoIHksIHRoaXMuYXJyYXkgKTtcblxuXHRcdH1cblxuXHRcdHRoaXMuYXJyYXlbIGluZGV4ICsgMCBdID0geDtcblx0XHR0aGlzLmFycmF5WyBpbmRleCArIDEgXSA9IHk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c2V0WFlaKCBpbmRleCwgeCwgeSwgeiApIHtcblxuXHRcdGluZGV4ICo9IHRoaXMuaXRlbVNpemU7XG5cblx0XHRpZiAoIHRoaXMubm9ybWFsaXplZCApIHtcblxuXHRcdFx0eCA9IG5vcm1hbGl6ZSggeCwgdGhpcy5hcnJheSApO1xuXHRcdFx0eSA9IG5vcm1hbGl6ZSggeSwgdGhpcy5hcnJheSApO1xuXHRcdFx0eiA9IG5vcm1hbGl6ZSggeiwgdGhpcy5hcnJheSApO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5hcnJheVsgaW5kZXggKyAwIF0gPSB4O1xuXHRcdHRoaXMuYXJyYXlbIGluZGV4ICsgMSBdID0geTtcblx0XHR0aGlzLmFycmF5WyBpbmRleCArIDIgXSA9IHo7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c2V0WFlaVyggaW5kZXgsIHgsIHksIHosIHcgKSB7XG5cblx0XHRpbmRleCAqPSB0aGlzLml0ZW1TaXplO1xuXG5cdFx0aWYgKCB0aGlzLm5vcm1hbGl6ZWQgKSB7XG5cblx0XHRcdHggPSBub3JtYWxpemUoIHgsIHRoaXMuYXJyYXkgKTtcblx0XHRcdHkgPSBub3JtYWxpemUoIHksIHRoaXMuYXJyYXkgKTtcblx0XHRcdHogPSBub3JtYWxpemUoIHosIHRoaXMuYXJyYXkgKTtcblx0XHRcdHcgPSBub3JtYWxpemUoIHcsIHRoaXMuYXJyYXkgKTtcblxuXHRcdH1cblxuXHRcdHRoaXMuYXJyYXlbIGluZGV4ICsgMCBdID0geDtcblx0XHR0aGlzLmFycmF5WyBpbmRleCArIDEgXSA9IHk7XG5cdFx0dGhpcy5hcnJheVsgaW5kZXggKyAyIF0gPSB6O1xuXHRcdHRoaXMuYXJyYXlbIGluZGV4ICsgMyBdID0gdztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRvblVwbG9hZCggY2FsbGJhY2sgKSB7XG5cblx0XHR0aGlzLm9uVXBsb2FkQ2FsbGJhY2sgPSBjYWxsYmFjaztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRjbG9uZSgpIHtcblxuXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvciggdGhpcy5hcnJheSwgdGhpcy5pdGVtU2l6ZSApLmNvcHkoIHRoaXMgKTtcblxuXHR9XG5cblx0dG9KU09OKCkge1xuXG5cdFx0Y29uc3QgZGF0YSA9IHtcblx0XHRcdGl0ZW1TaXplOiB0aGlzLml0ZW1TaXplLFxuXHRcdFx0dHlwZTogdGhpcy5hcnJheS5jb25zdHJ1Y3Rvci5uYW1lLFxuXHRcdFx0YXJyYXk6IEFycmF5LmZyb20oIHRoaXMuYXJyYXkgKSxcblx0XHRcdG5vcm1hbGl6ZWQ6IHRoaXMubm9ybWFsaXplZFxuXHRcdH07XG5cblx0XHRpZiAoIHRoaXMubmFtZSAhPT0gJycgKSBkYXRhLm5hbWUgPSB0aGlzLm5hbWU7XG5cdFx0aWYgKCB0aGlzLnVzYWdlICE9PSBTdGF0aWNEcmF3VXNhZ2UgKSBkYXRhLnVzYWdlID0gdGhpcy51c2FnZTtcblx0XHRpZiAoIHRoaXMudXBkYXRlUmFuZ2Uub2Zmc2V0ICE9PSAwIHx8IHRoaXMudXBkYXRlUmFuZ2UuY291bnQgIT09IC0gMSApIGRhdGEudXBkYXRlUmFuZ2UgPSB0aGlzLnVwZGF0ZVJhbmdlO1xuXG5cdFx0cmV0dXJuIGRhdGE7XG5cblx0fVxuXG59XG5cbi8vXG5cbmNsYXNzIEludDhCdWZmZXJBdHRyaWJ1dGUgZXh0ZW5kcyBCdWZmZXJBdHRyaWJ1dGUge1xuXG5cdGNvbnN0cnVjdG9yKCBhcnJheSwgaXRlbVNpemUsIG5vcm1hbGl6ZWQgKSB7XG5cblx0XHRzdXBlciggbmV3IEludDhBcnJheSggYXJyYXkgKSwgaXRlbVNpemUsIG5vcm1hbGl6ZWQgKTtcblxuXHR9XG5cbn1cblxuY2xhc3MgVWludDhCdWZmZXJBdHRyaWJ1dGUgZXh0ZW5kcyBCdWZmZXJBdHRyaWJ1dGUge1xuXG5cdGNvbnN0cnVjdG9yKCBhcnJheSwgaXRlbVNpemUsIG5vcm1hbGl6ZWQgKSB7XG5cblx0XHRzdXBlciggbmV3IFVpbnQ4QXJyYXkoIGFycmF5ICksIGl0ZW1TaXplLCBub3JtYWxpemVkICk7XG5cblx0fVxuXG59XG5cbmNsYXNzIFVpbnQ4Q2xhbXBlZEJ1ZmZlckF0dHJpYnV0ZSBleHRlbmRzIEJ1ZmZlckF0dHJpYnV0ZSB7XG5cblx0Y29uc3RydWN0b3IoIGFycmF5LCBpdGVtU2l6ZSwgbm9ybWFsaXplZCApIHtcblxuXHRcdHN1cGVyKCBuZXcgVWludDhDbGFtcGVkQXJyYXkoIGFycmF5ICksIGl0ZW1TaXplLCBub3JtYWxpemVkICk7XG5cblx0fVxuXG59XG5cbmNsYXNzIEludDE2QnVmZmVyQXR0cmlidXRlIGV4dGVuZHMgQnVmZmVyQXR0cmlidXRlIHtcblxuXHRjb25zdHJ1Y3RvciggYXJyYXksIGl0ZW1TaXplLCBub3JtYWxpemVkICkge1xuXG5cdFx0c3VwZXIoIG5ldyBJbnQxNkFycmF5KCBhcnJheSApLCBpdGVtU2l6ZSwgbm9ybWFsaXplZCApO1xuXG5cdH1cblxufVxuXG5jbGFzcyBVaW50MTZCdWZmZXJBdHRyaWJ1dGUgZXh0ZW5kcyBCdWZmZXJBdHRyaWJ1dGUge1xuXG5cdGNvbnN0cnVjdG9yKCBhcnJheSwgaXRlbVNpemUsIG5vcm1hbGl6ZWQgKSB7XG5cblx0XHRzdXBlciggbmV3IFVpbnQxNkFycmF5KCBhcnJheSApLCBpdGVtU2l6ZSwgbm9ybWFsaXplZCApO1xuXG5cdH1cblxufVxuXG5jbGFzcyBJbnQzMkJ1ZmZlckF0dHJpYnV0ZSBleHRlbmRzIEJ1ZmZlckF0dHJpYnV0ZSB7XG5cblx0Y29uc3RydWN0b3IoIGFycmF5LCBpdGVtU2l6ZSwgbm9ybWFsaXplZCApIHtcblxuXHRcdHN1cGVyKCBuZXcgSW50MzJBcnJheSggYXJyYXkgKSwgaXRlbVNpemUsIG5vcm1hbGl6ZWQgKTtcblxuXHR9XG5cbn1cblxuY2xhc3MgVWludDMyQnVmZmVyQXR0cmlidXRlIGV4dGVuZHMgQnVmZmVyQXR0cmlidXRlIHtcblxuXHRjb25zdHJ1Y3RvciggYXJyYXksIGl0ZW1TaXplLCBub3JtYWxpemVkICkge1xuXG5cdFx0c3VwZXIoIG5ldyBVaW50MzJBcnJheSggYXJyYXkgKSwgaXRlbVNpemUsIG5vcm1hbGl6ZWQgKTtcblxuXHR9XG5cbn1cblxuY2xhc3MgRmxvYXQxNkJ1ZmZlckF0dHJpYnV0ZSBleHRlbmRzIEJ1ZmZlckF0dHJpYnV0ZSB7XG5cblx0Y29uc3RydWN0b3IoIGFycmF5LCBpdGVtU2l6ZSwgbm9ybWFsaXplZCApIHtcblxuXHRcdHN1cGVyKCBuZXcgVWludDE2QXJyYXkoIGFycmF5ICksIGl0ZW1TaXplLCBub3JtYWxpemVkICk7XG5cblx0XHR0aGlzLmlzRmxvYXQxNkJ1ZmZlckF0dHJpYnV0ZSA9IHRydWU7XG5cblx0fVxuXG5cdGdldFgoIGluZGV4ICkge1xuXG5cdFx0bGV0IHggPSBmcm9tSGFsZkZsb2F0KCB0aGlzLmFycmF5WyBpbmRleCAqIHRoaXMuaXRlbVNpemUgXSApO1xuXG5cdFx0aWYgKCB0aGlzLm5vcm1hbGl6ZWQgKSB4ID0gZGVub3JtYWxpemUoIHgsIHRoaXMuYXJyYXkgKTtcblxuXHRcdHJldHVybiB4O1xuXG5cdH1cblxuXHRzZXRYKCBpbmRleCwgeCApIHtcblxuXHRcdGlmICggdGhpcy5ub3JtYWxpemVkICkgeCA9IG5vcm1hbGl6ZSggeCwgdGhpcy5hcnJheSApO1xuXG5cdFx0dGhpcy5hcnJheVsgaW5kZXggKiB0aGlzLml0ZW1TaXplIF0gPSB0b0hhbGZGbG9hdCggeCApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGdldFkoIGluZGV4ICkge1xuXG5cdFx0bGV0IHkgPSBmcm9tSGFsZkZsb2F0KCB0aGlzLmFycmF5WyBpbmRleCAqIHRoaXMuaXRlbVNpemUgKyAxIF0gKTtcblxuXHRcdGlmICggdGhpcy5ub3JtYWxpemVkICkgeSA9IGRlbm9ybWFsaXplKCB5LCB0aGlzLmFycmF5ICk7XG5cblx0XHRyZXR1cm4geTtcblxuXHR9XG5cblx0c2V0WSggaW5kZXgsIHkgKSB7XG5cblx0XHRpZiAoIHRoaXMubm9ybWFsaXplZCApIHkgPSBub3JtYWxpemUoIHksIHRoaXMuYXJyYXkgKTtcblxuXHRcdHRoaXMuYXJyYXlbIGluZGV4ICogdGhpcy5pdGVtU2l6ZSArIDEgXSA9IHRvSGFsZkZsb2F0KCB5ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Z2V0WiggaW5kZXggKSB7XG5cblx0XHRsZXQgeiA9IGZyb21IYWxmRmxvYXQoIHRoaXMuYXJyYXlbIGluZGV4ICogdGhpcy5pdGVtU2l6ZSArIDIgXSApO1xuXG5cdFx0aWYgKCB0aGlzLm5vcm1hbGl6ZWQgKSB6ID0gZGVub3JtYWxpemUoIHosIHRoaXMuYXJyYXkgKTtcblxuXHRcdHJldHVybiB6O1xuXG5cdH1cblxuXHRzZXRaKCBpbmRleCwgeiApIHtcblxuXHRcdGlmICggdGhpcy5ub3JtYWxpemVkICkgeiA9IG5vcm1hbGl6ZSggeiwgdGhpcy5hcnJheSApO1xuXG5cdFx0dGhpcy5hcnJheVsgaW5kZXggKiB0aGlzLml0ZW1TaXplICsgMiBdID0gdG9IYWxmRmxvYXQoIHogKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRnZXRXKCBpbmRleCApIHtcblxuXHRcdGxldCB3ID0gZnJvbUhhbGZGbG9hdCggdGhpcy5hcnJheVsgaW5kZXggKiB0aGlzLml0ZW1TaXplICsgMyBdICk7XG5cblx0XHRpZiAoIHRoaXMubm9ybWFsaXplZCApIHcgPSBkZW5vcm1hbGl6ZSggdywgdGhpcy5hcnJheSApO1xuXG5cdFx0cmV0dXJuIHc7XG5cblx0fVxuXG5cdHNldFcoIGluZGV4LCB3ICkge1xuXG5cdFx0aWYgKCB0aGlzLm5vcm1hbGl6ZWQgKSB3ID0gbm9ybWFsaXplKCB3LCB0aGlzLmFycmF5ICk7XG5cblx0XHR0aGlzLmFycmF5WyBpbmRleCAqIHRoaXMuaXRlbVNpemUgKyAzIF0gPSB0b0hhbGZGbG9hdCggdyApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHNldFhZKCBpbmRleCwgeCwgeSApIHtcblxuXHRcdGluZGV4ICo9IHRoaXMuaXRlbVNpemU7XG5cblx0XHRpZiAoIHRoaXMubm9ybWFsaXplZCApIHtcblxuXHRcdFx0eCA9IG5vcm1hbGl6ZSggeCwgdGhpcy5hcnJheSApO1xuXHRcdFx0eSA9IG5vcm1hbGl6ZSggeSwgdGhpcy5hcnJheSApO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5hcnJheVsgaW5kZXggKyAwIF0gPSB0b0hhbGZGbG9hdCggeCApO1xuXHRcdHRoaXMuYXJyYXlbIGluZGV4ICsgMSBdID0gdG9IYWxmRmxvYXQoIHkgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzZXRYWVooIGluZGV4LCB4LCB5LCB6ICkge1xuXG5cdFx0aW5kZXggKj0gdGhpcy5pdGVtU2l6ZTtcblxuXHRcdGlmICggdGhpcy5ub3JtYWxpemVkICkge1xuXG5cdFx0XHR4ID0gbm9ybWFsaXplKCB4LCB0aGlzLmFycmF5ICk7XG5cdFx0XHR5ID0gbm9ybWFsaXplKCB5LCB0aGlzLmFycmF5ICk7XG5cdFx0XHR6ID0gbm9ybWFsaXplKCB6LCB0aGlzLmFycmF5ICk7XG5cblx0XHR9XG5cblx0XHR0aGlzLmFycmF5WyBpbmRleCArIDAgXSA9IHRvSGFsZkZsb2F0KCB4ICk7XG5cdFx0dGhpcy5hcnJheVsgaW5kZXggKyAxIF0gPSB0b0hhbGZGbG9hdCggeSApO1xuXHRcdHRoaXMuYXJyYXlbIGluZGV4ICsgMiBdID0gdG9IYWxmRmxvYXQoIHogKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzZXRYWVpXKCBpbmRleCwgeCwgeSwgeiwgdyApIHtcblxuXHRcdGluZGV4ICo9IHRoaXMuaXRlbVNpemU7XG5cblx0XHRpZiAoIHRoaXMubm9ybWFsaXplZCApIHtcblxuXHRcdFx0eCA9IG5vcm1hbGl6ZSggeCwgdGhpcy5hcnJheSApO1xuXHRcdFx0eSA9IG5vcm1hbGl6ZSggeSwgdGhpcy5hcnJheSApO1xuXHRcdFx0eiA9IG5vcm1hbGl6ZSggeiwgdGhpcy5hcnJheSApO1xuXHRcdFx0dyA9IG5vcm1hbGl6ZSggdywgdGhpcy5hcnJheSApO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5hcnJheVsgaW5kZXggKyAwIF0gPSB0b0hhbGZGbG9hdCggeCApO1xuXHRcdHRoaXMuYXJyYXlbIGluZGV4ICsgMSBdID0gdG9IYWxmRmxvYXQoIHkgKTtcblx0XHR0aGlzLmFycmF5WyBpbmRleCArIDIgXSA9IHRvSGFsZkZsb2F0KCB6ICk7XG5cdFx0dGhpcy5hcnJheVsgaW5kZXggKyAzIF0gPSB0b0hhbGZGbG9hdCggdyApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG59XG5cblxuY2xhc3MgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSBleHRlbmRzIEJ1ZmZlckF0dHJpYnV0ZSB7XG5cblx0Y29uc3RydWN0b3IoIGFycmF5LCBpdGVtU2l6ZSwgbm9ybWFsaXplZCApIHtcblxuXHRcdHN1cGVyKCBuZXcgRmxvYXQzMkFycmF5KCBhcnJheSApLCBpdGVtU2l6ZSwgbm9ybWFsaXplZCApO1xuXG5cdH1cblxufVxuXG5jbGFzcyBGbG9hdDY0QnVmZmVyQXR0cmlidXRlIGV4dGVuZHMgQnVmZmVyQXR0cmlidXRlIHtcblxuXHRjb25zdHJ1Y3RvciggYXJyYXksIGl0ZW1TaXplLCBub3JtYWxpemVkICkge1xuXG5cdFx0c3VwZXIoIG5ldyBGbG9hdDY0QXJyYXkoIGFycmF5ICksIGl0ZW1TaXplLCBub3JtYWxpemVkICk7XG5cblx0fVxuXG59XG5cbi8vXG5cbmV4cG9ydCB7XG5cdEZsb2F0NjRCdWZmZXJBdHRyaWJ1dGUsXG5cdEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUsXG5cdEZsb2F0MTZCdWZmZXJBdHRyaWJ1dGUsXG5cdFVpbnQzMkJ1ZmZlckF0dHJpYnV0ZSxcblx0SW50MzJCdWZmZXJBdHRyaWJ1dGUsXG5cdFVpbnQxNkJ1ZmZlckF0dHJpYnV0ZSxcblx0SW50MTZCdWZmZXJBdHRyaWJ1dGUsXG5cdFVpbnQ4Q2xhbXBlZEJ1ZmZlckF0dHJpYnV0ZSxcblx0VWludDhCdWZmZXJBdHRyaWJ1dGUsXG5cdEludDhCdWZmZXJBdHRyaWJ1dGUsXG5cdEJ1ZmZlckF0dHJpYnV0ZVxufTtcbiIsImltcG9ydCB7IFZlY3RvcjMgfSBmcm9tICcuLi9tYXRoL1ZlY3RvcjMuanMnO1xuaW1wb3J0IHsgVmVjdG9yMiB9IGZyb20gJy4uL21hdGgvVmVjdG9yMi5qcyc7XG5pbXBvcnQgeyBCb3gzIH0gZnJvbSAnLi4vbWF0aC9Cb3gzLmpzJztcbmltcG9ydCB7IEV2ZW50RGlzcGF0Y2hlciB9IGZyb20gJy4vRXZlbnREaXNwYXRjaGVyLmpzJztcbmltcG9ydCB7IEJ1ZmZlckF0dHJpYnV0ZSwgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSwgVWludDE2QnVmZmVyQXR0cmlidXRlLCBVaW50MzJCdWZmZXJBdHRyaWJ1dGUgfSBmcm9tICcuL0J1ZmZlckF0dHJpYnV0ZS5qcyc7XG5pbXBvcnQgeyBTcGhlcmUgfSBmcm9tICcuLi9tYXRoL1NwaGVyZS5qcyc7XG5pbXBvcnQgeyBPYmplY3QzRCB9IGZyb20gJy4vT2JqZWN0M0QuanMnO1xuaW1wb3J0IHsgTWF0cml4NCB9IGZyb20gJy4uL21hdGgvTWF0cml4NC5qcyc7XG5pbXBvcnQgeyBNYXRyaXgzIH0gZnJvbSAnLi4vbWF0aC9NYXRyaXgzLmpzJztcbmltcG9ydCAqIGFzIE1hdGhVdGlscyBmcm9tICcuLi9tYXRoL01hdGhVdGlscy5qcyc7XG5pbXBvcnQgeyBhcnJheU5lZWRzVWludDMyIH0gZnJvbSAnLi4vdXRpbHMuanMnO1xuXG5sZXQgX2lkID0gMDtcblxuY29uc3QgX20xID0gLypAX19QVVJFX18qLyBuZXcgTWF0cml4NCgpO1xuY29uc3QgX29iaiA9IC8qQF9fUFVSRV9fKi8gbmV3IE9iamVjdDNEKCk7XG5jb25zdCBfb2Zmc2V0ID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xuY29uc3QgX2JveCA9IC8qQF9fUFVSRV9fKi8gbmV3IEJveDMoKTtcbmNvbnN0IF9ib3hNb3JwaFRhcmdldHMgPSAvKkBfX1BVUkVfXyovIG5ldyBCb3gzKCk7XG5jb25zdCBfdmVjdG9yID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xuXG5jbGFzcyBCdWZmZXJHZW9tZXRyeSBleHRlbmRzIEV2ZW50RGlzcGF0Y2hlciB7XG5cblx0Y29uc3RydWN0b3IoKSB7XG5cblx0XHRzdXBlcigpO1xuXG5cdFx0dGhpcy5pc0J1ZmZlckdlb21ldHJ5ID0gdHJ1ZTtcblxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggdGhpcywgJ2lkJywgeyB2YWx1ZTogX2lkICsrIH0gKTtcblxuXHRcdHRoaXMudXVpZCA9IE1hdGhVdGlscy5nZW5lcmF0ZVVVSUQoKTtcblxuXHRcdHRoaXMubmFtZSA9ICcnO1xuXHRcdHRoaXMudHlwZSA9ICdCdWZmZXJHZW9tZXRyeSc7XG5cblx0XHR0aGlzLmluZGV4ID0gbnVsbDtcblx0XHR0aGlzLmF0dHJpYnV0ZXMgPSB7fTtcblxuXHRcdHRoaXMubW9ycGhBdHRyaWJ1dGVzID0ge307XG5cdFx0dGhpcy5tb3JwaFRhcmdldHNSZWxhdGl2ZSA9IGZhbHNlO1xuXG5cdFx0dGhpcy5ncm91cHMgPSBbXTtcblxuXHRcdHRoaXMuYm91bmRpbmdCb3ggPSBudWxsO1xuXHRcdHRoaXMuYm91bmRpbmdTcGhlcmUgPSBudWxsO1xuXG5cdFx0dGhpcy5kcmF3UmFuZ2UgPSB7IHN0YXJ0OiAwLCBjb3VudDogSW5maW5pdHkgfTtcblxuXHRcdHRoaXMudXNlckRhdGEgPSB7fTtcblxuXHR9XG5cblx0Z2V0SW5kZXgoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5pbmRleDtcblxuXHR9XG5cblx0c2V0SW5kZXgoIGluZGV4ICkge1xuXG5cdFx0aWYgKCBBcnJheS5pc0FycmF5KCBpbmRleCApICkge1xuXG5cdFx0XHR0aGlzLmluZGV4ID0gbmV3ICggYXJyYXlOZWVkc1VpbnQzMiggaW5kZXggKSA/IFVpbnQzMkJ1ZmZlckF0dHJpYnV0ZSA6IFVpbnQxNkJ1ZmZlckF0dHJpYnV0ZSApKCBpbmRleCwgMSApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0dGhpcy5pbmRleCA9IGluZGV4O1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGdldEF0dHJpYnV0ZSggbmFtZSApIHtcblxuXHRcdHJldHVybiB0aGlzLmF0dHJpYnV0ZXNbIG5hbWUgXTtcblxuXHR9XG5cblx0c2V0QXR0cmlidXRlKCBuYW1lLCBhdHRyaWJ1dGUgKSB7XG5cblx0XHR0aGlzLmF0dHJpYnV0ZXNbIG5hbWUgXSA9IGF0dHJpYnV0ZTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRkZWxldGVBdHRyaWJ1dGUoIG5hbWUgKSB7XG5cblx0XHRkZWxldGUgdGhpcy5hdHRyaWJ1dGVzWyBuYW1lIF07XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0aGFzQXR0cmlidXRlKCBuYW1lICkge1xuXG5cdFx0cmV0dXJuIHRoaXMuYXR0cmlidXRlc1sgbmFtZSBdICE9PSB1bmRlZmluZWQ7XG5cblx0fVxuXG5cdGFkZEdyb3VwKCBzdGFydCwgY291bnQsIG1hdGVyaWFsSW5kZXggPSAwICkge1xuXG5cdFx0dGhpcy5ncm91cHMucHVzaCgge1xuXG5cdFx0XHRzdGFydDogc3RhcnQsXG5cdFx0XHRjb3VudDogY291bnQsXG5cdFx0XHRtYXRlcmlhbEluZGV4OiBtYXRlcmlhbEluZGV4XG5cblx0XHR9ICk7XG5cblx0fVxuXG5cdGNsZWFyR3JvdXBzKCkge1xuXG5cdFx0dGhpcy5ncm91cHMgPSBbXTtcblxuXHR9XG5cblx0c2V0RHJhd1JhbmdlKCBzdGFydCwgY291bnQgKSB7XG5cblx0XHR0aGlzLmRyYXdSYW5nZS5zdGFydCA9IHN0YXJ0O1xuXHRcdHRoaXMuZHJhd1JhbmdlLmNvdW50ID0gY291bnQ7XG5cblx0fVxuXG5cdGFwcGx5TWF0cml4NCggbWF0cml4ICkge1xuXG5cdFx0Y29uc3QgcG9zaXRpb24gPSB0aGlzLmF0dHJpYnV0ZXMucG9zaXRpb247XG5cblx0XHRpZiAoIHBvc2l0aW9uICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdHBvc2l0aW9uLmFwcGx5TWF0cml4NCggbWF0cml4ICk7XG5cblx0XHRcdHBvc2l0aW9uLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdH1cblxuXHRcdGNvbnN0IG5vcm1hbCA9IHRoaXMuYXR0cmlidXRlcy5ub3JtYWw7XG5cblx0XHRpZiAoIG5vcm1hbCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRjb25zdCBub3JtYWxNYXRyaXggPSBuZXcgTWF0cml4MygpLmdldE5vcm1hbE1hdHJpeCggbWF0cml4ICk7XG5cblx0XHRcdG5vcm1hbC5hcHBseU5vcm1hbE1hdHJpeCggbm9ybWFsTWF0cml4ICk7XG5cblx0XHRcdG5vcm1hbC5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0XHR9XG5cblx0XHRjb25zdCB0YW5nZW50ID0gdGhpcy5hdHRyaWJ1dGVzLnRhbmdlbnQ7XG5cblx0XHRpZiAoIHRhbmdlbnQgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0dGFuZ2VudC50cmFuc2Zvcm1EaXJlY3Rpb24oIG1hdHJpeCApO1xuXG5cdFx0XHR0YW5nZW50Lm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdH1cblxuXHRcdGlmICggdGhpcy5ib3VuZGluZ0JveCAhPT0gbnVsbCApIHtcblxuXHRcdFx0dGhpcy5jb21wdXRlQm91bmRpbmdCb3goKTtcblxuXHRcdH1cblxuXHRcdGlmICggdGhpcy5ib3VuZGluZ1NwaGVyZSAhPT0gbnVsbCApIHtcblxuXHRcdFx0dGhpcy5jb21wdXRlQm91bmRpbmdTcGhlcmUoKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRhcHBseVF1YXRlcm5pb24oIHEgKSB7XG5cblx0XHRfbTEubWFrZVJvdGF0aW9uRnJvbVF1YXRlcm5pb24oIHEgKTtcblxuXHRcdHRoaXMuYXBwbHlNYXRyaXg0KCBfbTEgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRyb3RhdGVYKCBhbmdsZSApIHtcblxuXHRcdC8vIHJvdGF0ZSBnZW9tZXRyeSBhcm91bmQgd29ybGQgeC1heGlzXG5cblx0XHRfbTEubWFrZVJvdGF0aW9uWCggYW5nbGUgKTtcblxuXHRcdHRoaXMuYXBwbHlNYXRyaXg0KCBfbTEgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRyb3RhdGVZKCBhbmdsZSApIHtcblxuXHRcdC8vIHJvdGF0ZSBnZW9tZXRyeSBhcm91bmQgd29ybGQgeS1heGlzXG5cblx0XHRfbTEubWFrZVJvdGF0aW9uWSggYW5nbGUgKTtcblxuXHRcdHRoaXMuYXBwbHlNYXRyaXg0KCBfbTEgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRyb3RhdGVaKCBhbmdsZSApIHtcblxuXHRcdC8vIHJvdGF0ZSBnZW9tZXRyeSBhcm91bmQgd29ybGQgei1heGlzXG5cblx0XHRfbTEubWFrZVJvdGF0aW9uWiggYW5nbGUgKTtcblxuXHRcdHRoaXMuYXBwbHlNYXRyaXg0KCBfbTEgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHR0cmFuc2xhdGUoIHgsIHksIHogKSB7XG5cblx0XHQvLyB0cmFuc2xhdGUgZ2VvbWV0cnlcblxuXHRcdF9tMS5tYWtlVHJhbnNsYXRpb24oIHgsIHksIHogKTtcblxuXHRcdHRoaXMuYXBwbHlNYXRyaXg0KCBfbTEgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzY2FsZSggeCwgeSwgeiApIHtcblxuXHRcdC8vIHNjYWxlIGdlb21ldHJ5XG5cblx0XHRfbTEubWFrZVNjYWxlKCB4LCB5LCB6ICk7XG5cblx0XHR0aGlzLmFwcGx5TWF0cml4NCggX20xICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0bG9va0F0KCB2ZWN0b3IgKSB7XG5cblx0XHRfb2JqLmxvb2tBdCggdmVjdG9yICk7XG5cblx0XHRfb2JqLnVwZGF0ZU1hdHJpeCgpO1xuXG5cdFx0dGhpcy5hcHBseU1hdHJpeDQoIF9vYmoubWF0cml4ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Y2VudGVyKCkge1xuXG5cdFx0dGhpcy5jb21wdXRlQm91bmRpbmdCb3goKTtcblxuXHRcdHRoaXMuYm91bmRpbmdCb3guZ2V0Q2VudGVyKCBfb2Zmc2V0ICkubmVnYXRlKCk7XG5cblx0XHR0aGlzLnRyYW5zbGF0ZSggX29mZnNldC54LCBfb2Zmc2V0LnksIF9vZmZzZXQueiApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHNldEZyb21Qb2ludHMoIHBvaW50cyApIHtcblxuXHRcdGNvbnN0IHBvc2l0aW9uID0gW107XG5cblx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBwb2ludHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0Y29uc3QgcG9pbnQgPSBwb2ludHNbIGkgXTtcblx0XHRcdHBvc2l0aW9uLnB1c2goIHBvaW50LngsIHBvaW50LnksIHBvaW50LnogfHwgMCApO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5zZXRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBwb3NpdGlvbiwgMyApICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Y29tcHV0ZUJvdW5kaW5nQm94KCkge1xuXG5cdFx0aWYgKCB0aGlzLmJvdW5kaW5nQm94ID09PSBudWxsICkge1xuXG5cdFx0XHR0aGlzLmJvdW5kaW5nQm94ID0gbmV3IEJveDMoKTtcblxuXHRcdH1cblxuXHRcdGNvbnN0IHBvc2l0aW9uID0gdGhpcy5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xuXHRcdGNvbnN0IG1vcnBoQXR0cmlidXRlc1Bvc2l0aW9uID0gdGhpcy5tb3JwaEF0dHJpYnV0ZXMucG9zaXRpb247XG5cblx0XHRpZiAoIHBvc2l0aW9uICYmIHBvc2l0aW9uLmlzR0xCdWZmZXJBdHRyaWJ1dGUgKSB7XG5cblx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5CdWZmZXJHZW9tZXRyeS5jb21wdXRlQm91bmRpbmdCb3goKTogR0xCdWZmZXJBdHRyaWJ1dGUgcmVxdWlyZXMgYSBtYW51YWwgYm91bmRpbmcgYm94LiBBbHRlcm5hdGl2ZWx5IHNldCBcIm1lc2guZnJ1c3R1bUN1bGxlZFwiIHRvIFwiZmFsc2VcIi4nLCB0aGlzICk7XG5cblx0XHRcdHRoaXMuYm91bmRpbmdCb3guc2V0KFxuXHRcdFx0XHRuZXcgVmVjdG9yMyggLSBJbmZpbml0eSwgLSBJbmZpbml0eSwgLSBJbmZpbml0eSApLFxuXHRcdFx0XHRuZXcgVmVjdG9yMyggKyBJbmZpbml0eSwgKyBJbmZpbml0eSwgKyBJbmZpbml0eSApXG5cdFx0XHQpO1xuXG5cdFx0XHRyZXR1cm47XG5cblx0XHR9XG5cblx0XHRpZiAoIHBvc2l0aW9uICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdHRoaXMuYm91bmRpbmdCb3guc2V0RnJvbUJ1ZmZlckF0dHJpYnV0ZSggcG9zaXRpb24gKTtcblxuXHRcdFx0Ly8gcHJvY2VzcyBtb3JwaCBhdHRyaWJ1dGVzIGlmIHByZXNlbnRcblxuXHRcdFx0aWYgKCBtb3JwaEF0dHJpYnV0ZXNQb3NpdGlvbiApIHtcblxuXHRcdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGlsID0gbW9ycGhBdHRyaWJ1dGVzUG9zaXRpb24ubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRjb25zdCBtb3JwaEF0dHJpYnV0ZSA9IG1vcnBoQXR0cmlidXRlc1Bvc2l0aW9uWyBpIF07XG5cdFx0XHRcdFx0X2JveC5zZXRGcm9tQnVmZmVyQXR0cmlidXRlKCBtb3JwaEF0dHJpYnV0ZSApO1xuXG5cdFx0XHRcdFx0aWYgKCB0aGlzLm1vcnBoVGFyZ2V0c1JlbGF0aXZlICkge1xuXG5cdFx0XHRcdFx0XHRfdmVjdG9yLmFkZFZlY3RvcnMoIHRoaXMuYm91bmRpbmdCb3gubWluLCBfYm94Lm1pbiApO1xuXHRcdFx0XHRcdFx0dGhpcy5ib3VuZGluZ0JveC5leHBhbmRCeVBvaW50KCBfdmVjdG9yICk7XG5cblx0XHRcdFx0XHRcdF92ZWN0b3IuYWRkVmVjdG9ycyggdGhpcy5ib3VuZGluZ0JveC5tYXgsIF9ib3gubWF4ICk7XG5cdFx0XHRcdFx0XHR0aGlzLmJvdW5kaW5nQm94LmV4cGFuZEJ5UG9pbnQoIF92ZWN0b3IgKTtcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdHRoaXMuYm91bmRpbmdCb3guZXhwYW5kQnlQb2ludCggX2JveC5taW4gKTtcblx0XHRcdFx0XHRcdHRoaXMuYm91bmRpbmdCb3guZXhwYW5kQnlQb2ludCggX2JveC5tYXggKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHRoaXMuYm91bmRpbmdCb3gubWFrZUVtcHR5KCk7XG5cblx0XHR9XG5cblx0XHRpZiAoIGlzTmFOKCB0aGlzLmJvdW5kaW5nQm94Lm1pbi54ICkgfHwgaXNOYU4oIHRoaXMuYm91bmRpbmdCb3gubWluLnkgKSB8fCBpc05hTiggdGhpcy5ib3VuZGluZ0JveC5taW4ueiApICkge1xuXG5cdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuQnVmZmVyR2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nQm94KCk6IENvbXB1dGVkIG1pbi9tYXggaGF2ZSBOYU4gdmFsdWVzLiBUaGUgXCJwb3NpdGlvblwiIGF0dHJpYnV0ZSBpcyBsaWtlbHkgdG8gaGF2ZSBOYU4gdmFsdWVzLicsIHRoaXMgKTtcblxuXHRcdH1cblxuXHR9XG5cblx0Y29tcHV0ZUJvdW5kaW5nU3BoZXJlKCkge1xuXG5cdFx0aWYgKCB0aGlzLmJvdW5kaW5nU3BoZXJlID09PSBudWxsICkge1xuXG5cdFx0XHR0aGlzLmJvdW5kaW5nU3BoZXJlID0gbmV3IFNwaGVyZSgpO1xuXG5cdFx0fVxuXG5cdFx0Y29uc3QgcG9zaXRpb24gPSB0aGlzLmF0dHJpYnV0ZXMucG9zaXRpb247XG5cdFx0Y29uc3QgbW9ycGhBdHRyaWJ1dGVzUG9zaXRpb24gPSB0aGlzLm1vcnBoQXR0cmlidXRlcy5wb3NpdGlvbjtcblxuXHRcdGlmICggcG9zaXRpb24gJiYgcG9zaXRpb24uaXNHTEJ1ZmZlckF0dHJpYnV0ZSApIHtcblxuXHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLkJ1ZmZlckdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpOiBHTEJ1ZmZlckF0dHJpYnV0ZSByZXF1aXJlcyBhIG1hbnVhbCBib3VuZGluZyBzcGhlcmUuIEFsdGVybmF0aXZlbHkgc2V0IFwibWVzaC5mcnVzdHVtQ3VsbGVkXCIgdG8gXCJmYWxzZVwiLicsIHRoaXMgKTtcblxuXHRcdFx0dGhpcy5ib3VuZGluZ1NwaGVyZS5zZXQoIG5ldyBWZWN0b3IzKCksIEluZmluaXR5ICk7XG5cblx0XHRcdHJldHVybjtcblxuXHRcdH1cblxuXHRcdGlmICggcG9zaXRpb24gKSB7XG5cblx0XHRcdC8vIGZpcnN0LCBmaW5kIHRoZSBjZW50ZXIgb2YgdGhlIGJvdW5kaW5nIHNwaGVyZVxuXG5cdFx0XHRjb25zdCBjZW50ZXIgPSB0aGlzLmJvdW5kaW5nU3BoZXJlLmNlbnRlcjtcblxuXHRcdFx0X2JveC5zZXRGcm9tQnVmZmVyQXR0cmlidXRlKCBwb3NpdGlvbiApO1xuXG5cdFx0XHQvLyBwcm9jZXNzIG1vcnBoIGF0dHJpYnV0ZXMgaWYgcHJlc2VudFxuXG5cdFx0XHRpZiAoIG1vcnBoQXR0cmlidXRlc1Bvc2l0aW9uICkge1xuXG5cdFx0XHRcdGZvciAoIGxldCBpID0gMCwgaWwgPSBtb3JwaEF0dHJpYnV0ZXNQb3NpdGlvbi5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdGNvbnN0IG1vcnBoQXR0cmlidXRlID0gbW9ycGhBdHRyaWJ1dGVzUG9zaXRpb25bIGkgXTtcblx0XHRcdFx0XHRfYm94TW9ycGhUYXJnZXRzLnNldEZyb21CdWZmZXJBdHRyaWJ1dGUoIG1vcnBoQXR0cmlidXRlICk7XG5cblx0XHRcdFx0XHRpZiAoIHRoaXMubW9ycGhUYXJnZXRzUmVsYXRpdmUgKSB7XG5cblx0XHRcdFx0XHRcdF92ZWN0b3IuYWRkVmVjdG9ycyggX2JveC5taW4sIF9ib3hNb3JwaFRhcmdldHMubWluICk7XG5cdFx0XHRcdFx0XHRfYm94LmV4cGFuZEJ5UG9pbnQoIF92ZWN0b3IgKTtcblxuXHRcdFx0XHRcdFx0X3ZlY3Rvci5hZGRWZWN0b3JzKCBfYm94Lm1heCwgX2JveE1vcnBoVGFyZ2V0cy5tYXggKTtcblx0XHRcdFx0XHRcdF9ib3guZXhwYW5kQnlQb2ludCggX3ZlY3RvciApO1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0X2JveC5leHBhbmRCeVBvaW50KCBfYm94TW9ycGhUYXJnZXRzLm1pbiApO1xuXHRcdFx0XHRcdFx0X2JveC5leHBhbmRCeVBvaW50KCBfYm94TW9ycGhUYXJnZXRzLm1heCApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRfYm94LmdldENlbnRlciggY2VudGVyICk7XG5cblx0XHRcdC8vIHNlY29uZCwgdHJ5IHRvIGZpbmQgYSBib3VuZGluZ1NwaGVyZSB3aXRoIGEgcmFkaXVzIHNtYWxsZXIgdGhhbiB0aGVcblx0XHRcdC8vIGJvdW5kaW5nU3BoZXJlIG9mIHRoZSBib3VuZGluZ0JveDogc3FydCgzKSBzbWFsbGVyIGluIHRoZSBiZXN0IGNhc2VcblxuXHRcdFx0bGV0IG1heFJhZGl1c1NxID0gMDtcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwLCBpbCA9IHBvc2l0aW9uLmNvdW50OyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdFx0X3ZlY3Rvci5mcm9tQnVmZmVyQXR0cmlidXRlKCBwb3NpdGlvbiwgaSApO1xuXG5cdFx0XHRcdG1heFJhZGl1c1NxID0gTWF0aC5tYXgoIG1heFJhZGl1c1NxLCBjZW50ZXIuZGlzdGFuY2VUb1NxdWFyZWQoIF92ZWN0b3IgKSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIHByb2Nlc3MgbW9ycGggYXR0cmlidXRlcyBpZiBwcmVzZW50XG5cblx0XHRcdGlmICggbW9ycGhBdHRyaWJ1dGVzUG9zaXRpb24gKSB7XG5cblx0XHRcdFx0Zm9yICggbGV0IGkgPSAwLCBpbCA9IG1vcnBoQXR0cmlidXRlc1Bvc2l0aW9uLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0Y29uc3QgbW9ycGhBdHRyaWJ1dGUgPSBtb3JwaEF0dHJpYnV0ZXNQb3NpdGlvblsgaSBdO1xuXHRcdFx0XHRcdGNvbnN0IG1vcnBoVGFyZ2V0c1JlbGF0aXZlID0gdGhpcy5tb3JwaFRhcmdldHNSZWxhdGl2ZTtcblxuXHRcdFx0XHRcdGZvciAoIGxldCBqID0gMCwgamwgPSBtb3JwaEF0dHJpYnV0ZS5jb3VudDsgaiA8IGpsOyBqICsrICkge1xuXG5cdFx0XHRcdFx0XHRfdmVjdG9yLmZyb21CdWZmZXJBdHRyaWJ1dGUoIG1vcnBoQXR0cmlidXRlLCBqICk7XG5cblx0XHRcdFx0XHRcdGlmICggbW9ycGhUYXJnZXRzUmVsYXRpdmUgKSB7XG5cblx0XHRcdFx0XHRcdFx0X29mZnNldC5mcm9tQnVmZmVyQXR0cmlidXRlKCBwb3NpdGlvbiwgaiApO1xuXHRcdFx0XHRcdFx0XHRfdmVjdG9yLmFkZCggX29mZnNldCApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdG1heFJhZGl1c1NxID0gTWF0aC5tYXgoIG1heFJhZGl1c1NxLCBjZW50ZXIuZGlzdGFuY2VUb1NxdWFyZWQoIF92ZWN0b3IgKSApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLmJvdW5kaW5nU3BoZXJlLnJhZGl1cyA9IE1hdGguc3FydCggbWF4UmFkaXVzU3EgKTtcblxuXHRcdFx0aWYgKCBpc05hTiggdGhpcy5ib3VuZGluZ1NwaGVyZS5yYWRpdXMgKSApIHtcblxuXHRcdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuQnVmZmVyR2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk6IENvbXB1dGVkIHJhZGl1cyBpcyBOYU4uIFRoZSBcInBvc2l0aW9uXCIgYXR0cmlidXRlIGlzIGxpa2VseSB0byBoYXZlIE5hTiB2YWx1ZXMuJywgdGhpcyApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fVxuXG5cdGNvbXB1dGVUYW5nZW50cygpIHtcblxuXHRcdGNvbnN0IGluZGV4ID0gdGhpcy5pbmRleDtcblx0XHRjb25zdCBhdHRyaWJ1dGVzID0gdGhpcy5hdHRyaWJ1dGVzO1xuXG5cdFx0Ly8gYmFzZWQgb24gaHR0cDovL3d3dy50ZXJhdGhvbi5jb20vY29kZS90YW5nZW50Lmh0bWxcblx0XHQvLyAocGVyIHZlcnRleCB0YW5nZW50cylcblxuXHRcdGlmICggaW5kZXggPT09IG51bGwgfHxcblx0XHRcdCBhdHRyaWJ1dGVzLnBvc2l0aW9uID09PSB1bmRlZmluZWQgfHxcblx0XHRcdCBhdHRyaWJ1dGVzLm5vcm1hbCA9PT0gdW5kZWZpbmVkIHx8XG5cdFx0XHQgYXR0cmlidXRlcy51diA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuQnVmZmVyR2VvbWV0cnk6IC5jb21wdXRlVGFuZ2VudHMoKSBmYWlsZWQuIE1pc3NpbmcgcmVxdWlyZWQgYXR0cmlidXRlcyAoaW5kZXgsIHBvc2l0aW9uLCBub3JtYWwgb3IgdXYpJyApO1xuXHRcdFx0cmV0dXJuO1xuXG5cdFx0fVxuXG5cdFx0Y29uc3QgaW5kaWNlcyA9IGluZGV4LmFycmF5O1xuXHRcdGNvbnN0IHBvc2l0aW9ucyA9IGF0dHJpYnV0ZXMucG9zaXRpb24uYXJyYXk7XG5cdFx0Y29uc3Qgbm9ybWFscyA9IGF0dHJpYnV0ZXMubm9ybWFsLmFycmF5O1xuXHRcdGNvbnN0IHV2cyA9IGF0dHJpYnV0ZXMudXYuYXJyYXk7XG5cblx0XHRjb25zdCBuVmVydGljZXMgPSBwb3NpdGlvbnMubGVuZ3RoIC8gMztcblxuXHRcdGlmICggdGhpcy5oYXNBdHRyaWJ1dGUoICd0YW5nZW50JyApID09PSBmYWxzZSApIHtcblxuXHRcdFx0dGhpcy5zZXRBdHRyaWJ1dGUoICd0YW5nZW50JywgbmV3IEJ1ZmZlckF0dHJpYnV0ZSggbmV3IEZsb2F0MzJBcnJheSggNCAqIG5WZXJ0aWNlcyApLCA0ICkgKTtcblxuXHRcdH1cblxuXHRcdGNvbnN0IHRhbmdlbnRzID0gdGhpcy5nZXRBdHRyaWJ1dGUoICd0YW5nZW50JyApLmFycmF5O1xuXG5cdFx0Y29uc3QgdGFuMSA9IFtdLCB0YW4yID0gW107XG5cblx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBuVmVydGljZXM7IGkgKysgKSB7XG5cblx0XHRcdHRhbjFbIGkgXSA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0XHR0YW4yWyBpIF0gPSBuZXcgVmVjdG9yMygpO1xuXG5cdFx0fVxuXG5cdFx0Y29uc3QgdkEgPSBuZXcgVmVjdG9yMygpLFxuXHRcdFx0dkIgPSBuZXcgVmVjdG9yMygpLFxuXHRcdFx0dkMgPSBuZXcgVmVjdG9yMygpLFxuXG5cdFx0XHR1dkEgPSBuZXcgVmVjdG9yMigpLFxuXHRcdFx0dXZCID0gbmV3IFZlY3RvcjIoKSxcblx0XHRcdHV2QyA9IG5ldyBWZWN0b3IyKCksXG5cblx0XHRcdHNkaXIgPSBuZXcgVmVjdG9yMygpLFxuXHRcdFx0dGRpciA9IG5ldyBWZWN0b3IzKCk7XG5cblx0XHRmdW5jdGlvbiBoYW5kbGVUcmlhbmdsZSggYSwgYiwgYyApIHtcblxuXHRcdFx0dkEuZnJvbUFycmF5KCBwb3NpdGlvbnMsIGEgKiAzICk7XG5cdFx0XHR2Qi5mcm9tQXJyYXkoIHBvc2l0aW9ucywgYiAqIDMgKTtcblx0XHRcdHZDLmZyb21BcnJheSggcG9zaXRpb25zLCBjICogMyApO1xuXG5cdFx0XHR1dkEuZnJvbUFycmF5KCB1dnMsIGEgKiAyICk7XG5cdFx0XHR1dkIuZnJvbUFycmF5KCB1dnMsIGIgKiAyICk7XG5cdFx0XHR1dkMuZnJvbUFycmF5KCB1dnMsIGMgKiAyICk7XG5cblx0XHRcdHZCLnN1YiggdkEgKTtcblx0XHRcdHZDLnN1YiggdkEgKTtcblxuXHRcdFx0dXZCLnN1YiggdXZBICk7XG5cdFx0XHR1dkMuc3ViKCB1dkEgKTtcblxuXHRcdFx0Y29uc3QgciA9IDEuMCAvICggdXZCLnggKiB1dkMueSAtIHV2Qy54ICogdXZCLnkgKTtcblxuXHRcdFx0Ly8gc2lsZW50bHkgaWdub3JlIGRlZ2VuZXJhdGUgdXYgdHJpYW5nbGVzIGhhdmluZyBjb2luY2lkZW50IG9yIGNvbGluZWFyIHZlcnRpY2VzXG5cblx0XHRcdGlmICggISBpc0Zpbml0ZSggciApICkgcmV0dXJuO1xuXG5cdFx0XHRzZGlyLmNvcHkoIHZCICkubXVsdGlwbHlTY2FsYXIoIHV2Qy55ICkuYWRkU2NhbGVkVmVjdG9yKCB2QywgLSB1dkIueSApLm11bHRpcGx5U2NhbGFyKCByICk7XG5cdFx0XHR0ZGlyLmNvcHkoIHZDICkubXVsdGlwbHlTY2FsYXIoIHV2Qi54ICkuYWRkU2NhbGVkVmVjdG9yKCB2QiwgLSB1dkMueCApLm11bHRpcGx5U2NhbGFyKCByICk7XG5cblx0XHRcdHRhbjFbIGEgXS5hZGQoIHNkaXIgKTtcblx0XHRcdHRhbjFbIGIgXS5hZGQoIHNkaXIgKTtcblx0XHRcdHRhbjFbIGMgXS5hZGQoIHNkaXIgKTtcblxuXHRcdFx0dGFuMlsgYSBdLmFkZCggdGRpciApO1xuXHRcdFx0dGFuMlsgYiBdLmFkZCggdGRpciApO1xuXHRcdFx0dGFuMlsgYyBdLmFkZCggdGRpciApO1xuXG5cdFx0fVxuXG5cdFx0bGV0IGdyb3VwcyA9IHRoaXMuZ3JvdXBzO1xuXG5cdFx0aWYgKCBncm91cHMubGVuZ3RoID09PSAwICkge1xuXG5cdFx0XHRncm91cHMgPSBbIHtcblx0XHRcdFx0c3RhcnQ6IDAsXG5cdFx0XHRcdGNvdW50OiBpbmRpY2VzLmxlbmd0aFxuXHRcdFx0fSBdO1xuXG5cdFx0fVxuXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBpbCA9IGdyb3Vwcy5sZW5ndGg7IGkgPCBpbDsgKysgaSApIHtcblxuXHRcdFx0Y29uc3QgZ3JvdXAgPSBncm91cHNbIGkgXTtcblxuXHRcdFx0Y29uc3Qgc3RhcnQgPSBncm91cC5zdGFydDtcblx0XHRcdGNvbnN0IGNvdW50ID0gZ3JvdXAuY291bnQ7XG5cblx0XHRcdGZvciAoIGxldCBqID0gc3RhcnQsIGpsID0gc3RhcnQgKyBjb3VudDsgaiA8IGpsOyBqICs9IDMgKSB7XG5cblx0XHRcdFx0aGFuZGxlVHJpYW5nbGUoXG5cdFx0XHRcdFx0aW5kaWNlc1sgaiArIDAgXSxcblx0XHRcdFx0XHRpbmRpY2VzWyBqICsgMSBdLFxuXHRcdFx0XHRcdGluZGljZXNbIGogKyAyIF1cblx0XHRcdFx0KTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Y29uc3QgdG1wID0gbmV3IFZlY3RvcjMoKSwgdG1wMiA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0Y29uc3QgbiA9IG5ldyBWZWN0b3IzKCksIG4yID0gbmV3IFZlY3RvcjMoKTtcblxuXHRcdGZ1bmN0aW9uIGhhbmRsZVZlcnRleCggdiApIHtcblxuXHRcdFx0bi5mcm9tQXJyYXkoIG5vcm1hbHMsIHYgKiAzICk7XG5cdFx0XHRuMi5jb3B5KCBuICk7XG5cblx0XHRcdGNvbnN0IHQgPSB0YW4xWyB2IF07XG5cblx0XHRcdC8vIEdyYW0tU2NobWlkdCBvcnRob2dvbmFsaXplXG5cblx0XHRcdHRtcC5jb3B5KCB0ICk7XG5cdFx0XHR0bXAuc3ViKCBuLm11bHRpcGx5U2NhbGFyKCBuLmRvdCggdCApICkgKS5ub3JtYWxpemUoKTtcblxuXHRcdFx0Ly8gQ2FsY3VsYXRlIGhhbmRlZG5lc3NcblxuXHRcdFx0dG1wMi5jcm9zc1ZlY3RvcnMoIG4yLCB0ICk7XG5cdFx0XHRjb25zdCB0ZXN0ID0gdG1wMi5kb3QoIHRhbjJbIHYgXSApO1xuXHRcdFx0Y29uc3QgdyA9ICggdGVzdCA8IDAuMCApID8gLSAxLjAgOiAxLjA7XG5cblx0XHRcdHRhbmdlbnRzWyB2ICogNCBdID0gdG1wLng7XG5cdFx0XHR0YW5nZW50c1sgdiAqIDQgKyAxIF0gPSB0bXAueTtcblx0XHRcdHRhbmdlbnRzWyB2ICogNCArIDIgXSA9IHRtcC56O1xuXHRcdFx0dGFuZ2VudHNbIHYgKiA0ICsgMyBdID0gdztcblxuXHRcdH1cblxuXHRcdGZvciAoIGxldCBpID0gMCwgaWwgPSBncm91cHMubGVuZ3RoOyBpIDwgaWw7ICsrIGkgKSB7XG5cblx0XHRcdGNvbnN0IGdyb3VwID0gZ3JvdXBzWyBpIF07XG5cblx0XHRcdGNvbnN0IHN0YXJ0ID0gZ3JvdXAuc3RhcnQ7XG5cdFx0XHRjb25zdCBjb3VudCA9IGdyb3VwLmNvdW50O1xuXG5cdFx0XHRmb3IgKCBsZXQgaiA9IHN0YXJ0LCBqbCA9IHN0YXJ0ICsgY291bnQ7IGogPCBqbDsgaiArPSAzICkge1xuXG5cdFx0XHRcdGhhbmRsZVZlcnRleCggaW5kaWNlc1sgaiArIDAgXSApO1xuXHRcdFx0XHRoYW5kbGVWZXJ0ZXgoIGluZGljZXNbIGogKyAxIF0gKTtcblx0XHRcdFx0aGFuZGxlVmVydGV4KCBpbmRpY2VzWyBqICsgMiBdICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9XG5cblx0Y29tcHV0ZVZlcnRleE5vcm1hbHMoKSB7XG5cblx0XHRjb25zdCBpbmRleCA9IHRoaXMuaW5kZXg7XG5cdFx0Y29uc3QgcG9zaXRpb25BdHRyaWJ1dGUgPSB0aGlzLmdldEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJyApO1xuXG5cdFx0aWYgKCBwb3NpdGlvbkF0dHJpYnV0ZSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRsZXQgbm9ybWFsQXR0cmlidXRlID0gdGhpcy5nZXRBdHRyaWJ1dGUoICdub3JtYWwnICk7XG5cblx0XHRcdGlmICggbm9ybWFsQXR0cmlidXRlID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0bm9ybWFsQXR0cmlidXRlID0gbmV3IEJ1ZmZlckF0dHJpYnV0ZSggbmV3IEZsb2F0MzJBcnJheSggcG9zaXRpb25BdHRyaWJ1dGUuY291bnQgKiAzICksIDMgKTtcblx0XHRcdFx0dGhpcy5zZXRBdHRyaWJ1dGUoICdub3JtYWwnLCBub3JtYWxBdHRyaWJ1dGUgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyByZXNldCBleGlzdGluZyBub3JtYWxzIHRvIHplcm9cblxuXHRcdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGlsID0gbm9ybWFsQXR0cmlidXRlLmNvdW50OyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRub3JtYWxBdHRyaWJ1dGUuc2V0WFlaKCBpLCAwLCAwLCAwICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IHBBID0gbmV3IFZlY3RvcjMoKSwgcEIgPSBuZXcgVmVjdG9yMygpLCBwQyA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0XHRjb25zdCBuQSA9IG5ldyBWZWN0b3IzKCksIG5CID0gbmV3IFZlY3RvcjMoKSwgbkMgPSBuZXcgVmVjdG9yMygpO1xuXHRcdFx0Y29uc3QgY2IgPSBuZXcgVmVjdG9yMygpLCBhYiA9IG5ldyBWZWN0b3IzKCk7XG5cblx0XHRcdC8vIGluZGV4ZWQgZWxlbWVudHNcblxuXHRcdFx0aWYgKCBpbmRleCApIHtcblxuXHRcdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGlsID0gaW5kZXguY291bnQ7IGkgPCBpbDsgaSArPSAzICkge1xuXG5cdFx0XHRcdFx0Y29uc3QgdkEgPSBpbmRleC5nZXRYKCBpICsgMCApO1xuXHRcdFx0XHRcdGNvbnN0IHZCID0gaW5kZXguZ2V0WCggaSArIDEgKTtcblx0XHRcdFx0XHRjb25zdCB2QyA9IGluZGV4LmdldFgoIGkgKyAyICk7XG5cblx0XHRcdFx0XHRwQS5mcm9tQnVmZmVyQXR0cmlidXRlKCBwb3NpdGlvbkF0dHJpYnV0ZSwgdkEgKTtcblx0XHRcdFx0XHRwQi5mcm9tQnVmZmVyQXR0cmlidXRlKCBwb3NpdGlvbkF0dHJpYnV0ZSwgdkIgKTtcblx0XHRcdFx0XHRwQy5mcm9tQnVmZmVyQXR0cmlidXRlKCBwb3NpdGlvbkF0dHJpYnV0ZSwgdkMgKTtcblxuXHRcdFx0XHRcdGNiLnN1YlZlY3RvcnMoIHBDLCBwQiApO1xuXHRcdFx0XHRcdGFiLnN1YlZlY3RvcnMoIHBBLCBwQiApO1xuXHRcdFx0XHRcdGNiLmNyb3NzKCBhYiApO1xuXG5cdFx0XHRcdFx0bkEuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggbm9ybWFsQXR0cmlidXRlLCB2QSApO1xuXHRcdFx0XHRcdG5CLmZyb21CdWZmZXJBdHRyaWJ1dGUoIG5vcm1hbEF0dHJpYnV0ZSwgdkIgKTtcblx0XHRcdFx0XHRuQy5mcm9tQnVmZmVyQXR0cmlidXRlKCBub3JtYWxBdHRyaWJ1dGUsIHZDICk7XG5cblx0XHRcdFx0XHRuQS5hZGQoIGNiICk7XG5cdFx0XHRcdFx0bkIuYWRkKCBjYiApO1xuXHRcdFx0XHRcdG5DLmFkZCggY2IgKTtcblxuXHRcdFx0XHRcdG5vcm1hbEF0dHJpYnV0ZS5zZXRYWVooIHZBLCBuQS54LCBuQS55LCBuQS56ICk7XG5cdFx0XHRcdFx0bm9ybWFsQXR0cmlidXRlLnNldFhZWiggdkIsIG5CLngsIG5CLnksIG5CLnogKTtcblx0XHRcdFx0XHRub3JtYWxBdHRyaWJ1dGUuc2V0WFlaKCB2QywgbkMueCwgbkMueSwgbkMueiApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyBub24taW5kZXhlZCBlbGVtZW50cyAodW5jb25uZWN0ZWQgdHJpYW5nbGUgc291cClcblxuXHRcdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGlsID0gcG9zaXRpb25BdHRyaWJ1dGUuY291bnQ7IGkgPCBpbDsgaSArPSAzICkge1xuXG5cdFx0XHRcdFx0cEEuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggcG9zaXRpb25BdHRyaWJ1dGUsIGkgKyAwICk7XG5cdFx0XHRcdFx0cEIuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggcG9zaXRpb25BdHRyaWJ1dGUsIGkgKyAxICk7XG5cdFx0XHRcdFx0cEMuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggcG9zaXRpb25BdHRyaWJ1dGUsIGkgKyAyICk7XG5cblx0XHRcdFx0XHRjYi5zdWJWZWN0b3JzKCBwQywgcEIgKTtcblx0XHRcdFx0XHRhYi5zdWJWZWN0b3JzKCBwQSwgcEIgKTtcblx0XHRcdFx0XHRjYi5jcm9zcyggYWIgKTtcblxuXHRcdFx0XHRcdG5vcm1hbEF0dHJpYnV0ZS5zZXRYWVooIGkgKyAwLCBjYi54LCBjYi55LCBjYi56ICk7XG5cdFx0XHRcdFx0bm9ybWFsQXR0cmlidXRlLnNldFhZWiggaSArIDEsIGNiLngsIGNiLnksIGNiLnogKTtcblx0XHRcdFx0XHRub3JtYWxBdHRyaWJ1dGUuc2V0WFlaKCBpICsgMiwgY2IueCwgY2IueSwgY2IueiApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLm5vcm1hbGl6ZU5vcm1hbHMoKTtcblxuXHRcdFx0bm9ybWFsQXR0cmlidXRlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdH1cblxuXHR9XG5cblx0bm9ybWFsaXplTm9ybWFscygpIHtcblxuXHRcdGNvbnN0IG5vcm1hbHMgPSB0aGlzLmF0dHJpYnV0ZXMubm9ybWFsO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBpbCA9IG5vcm1hbHMuY291bnQ7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0X3ZlY3Rvci5mcm9tQnVmZmVyQXR0cmlidXRlKCBub3JtYWxzLCBpICk7XG5cblx0XHRcdF92ZWN0b3Iubm9ybWFsaXplKCk7XG5cblx0XHRcdG5vcm1hbHMuc2V0WFlaKCBpLCBfdmVjdG9yLngsIF92ZWN0b3IueSwgX3ZlY3Rvci56ICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdHRvTm9uSW5kZXhlZCgpIHtcblxuXHRcdGZ1bmN0aW9uIGNvbnZlcnRCdWZmZXJBdHRyaWJ1dGUoIGF0dHJpYnV0ZSwgaW5kaWNlcyApIHtcblxuXHRcdFx0Y29uc3QgYXJyYXkgPSBhdHRyaWJ1dGUuYXJyYXk7XG5cdFx0XHRjb25zdCBpdGVtU2l6ZSA9IGF0dHJpYnV0ZS5pdGVtU2l6ZTtcblx0XHRcdGNvbnN0IG5vcm1hbGl6ZWQgPSBhdHRyaWJ1dGUubm9ybWFsaXplZDtcblxuXHRcdFx0Y29uc3QgYXJyYXkyID0gbmV3IGFycmF5LmNvbnN0cnVjdG9yKCBpbmRpY2VzLmxlbmd0aCAqIGl0ZW1TaXplICk7XG5cblx0XHRcdGxldCBpbmRleCA9IDAsIGluZGV4MiA9IDA7XG5cblx0XHRcdGZvciAoIGxldCBpID0gMCwgbCA9IGluZGljZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRpZiAoIGF0dHJpYnV0ZS5pc0ludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlICkge1xuXG5cdFx0XHRcdFx0aW5kZXggPSBpbmRpY2VzWyBpIF0gKiBhdHRyaWJ1dGUuZGF0YS5zdHJpZGUgKyBhdHRyaWJ1dGUub2Zmc2V0O1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRpbmRleCA9IGluZGljZXNbIGkgXSAqIGl0ZW1TaXplO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRmb3IgKCBsZXQgaiA9IDA7IGogPCBpdGVtU2l6ZTsgaiArKyApIHtcblxuXHRcdFx0XHRcdGFycmF5MlsgaW5kZXgyICsrIF0gPSBhcnJheVsgaW5kZXggKysgXTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG5ldyBCdWZmZXJBdHRyaWJ1dGUoIGFycmF5MiwgaXRlbVNpemUsIG5vcm1hbGl6ZWQgKTtcblxuXHRcdH1cblxuXHRcdC8vXG5cblx0XHRpZiAoIHRoaXMuaW5kZXggPT09IG51bGwgKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkJ1ZmZlckdlb21ldHJ5LnRvTm9uSW5kZXhlZCgpOiBCdWZmZXJHZW9tZXRyeSBpcyBhbHJlYWR5IG5vbi1pbmRleGVkLicgKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fVxuXG5cdFx0Y29uc3QgZ2VvbWV0cnkyID0gbmV3IEJ1ZmZlckdlb21ldHJ5KCk7XG5cblx0XHRjb25zdCBpbmRpY2VzID0gdGhpcy5pbmRleC5hcnJheTtcblx0XHRjb25zdCBhdHRyaWJ1dGVzID0gdGhpcy5hdHRyaWJ1dGVzO1xuXG5cdFx0Ly8gYXR0cmlidXRlc1xuXG5cdFx0Zm9yICggY29uc3QgbmFtZSBpbiBhdHRyaWJ1dGVzICkge1xuXG5cdFx0XHRjb25zdCBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzWyBuYW1lIF07XG5cblx0XHRcdGNvbnN0IG5ld0F0dHJpYnV0ZSA9IGNvbnZlcnRCdWZmZXJBdHRyaWJ1dGUoIGF0dHJpYnV0ZSwgaW5kaWNlcyApO1xuXG5cdFx0XHRnZW9tZXRyeTIuc2V0QXR0cmlidXRlKCBuYW1lLCBuZXdBdHRyaWJ1dGUgKTtcblxuXHRcdH1cblxuXHRcdC8vIG1vcnBoIGF0dHJpYnV0ZXNcblxuXHRcdGNvbnN0IG1vcnBoQXR0cmlidXRlcyA9IHRoaXMubW9ycGhBdHRyaWJ1dGVzO1xuXG5cdFx0Zm9yICggY29uc3QgbmFtZSBpbiBtb3JwaEF0dHJpYnV0ZXMgKSB7XG5cblx0XHRcdGNvbnN0IG1vcnBoQXJyYXkgPSBbXTtcblx0XHRcdGNvbnN0IG1vcnBoQXR0cmlidXRlID0gbW9ycGhBdHRyaWJ1dGVzWyBuYW1lIF07IC8vIG1vcnBoQXR0cmlidXRlOiBhcnJheSBvZiBGbG9hdDMyQnVmZmVyQXR0cmlidXRlc1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGlsID0gbW9ycGhBdHRyaWJ1dGUubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdFx0Y29uc3QgYXR0cmlidXRlID0gbW9ycGhBdHRyaWJ1dGVbIGkgXTtcblxuXHRcdFx0XHRjb25zdCBuZXdBdHRyaWJ1dGUgPSBjb252ZXJ0QnVmZmVyQXR0cmlidXRlKCBhdHRyaWJ1dGUsIGluZGljZXMgKTtcblxuXHRcdFx0XHRtb3JwaEFycmF5LnB1c2goIG5ld0F0dHJpYnV0ZSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGdlb21ldHJ5Mi5tb3JwaEF0dHJpYnV0ZXNbIG5hbWUgXSA9IG1vcnBoQXJyYXk7XG5cblx0XHR9XG5cblx0XHRnZW9tZXRyeTIubW9ycGhUYXJnZXRzUmVsYXRpdmUgPSB0aGlzLm1vcnBoVGFyZ2V0c1JlbGF0aXZlO1xuXG5cdFx0Ly8gZ3JvdXBzXG5cblx0XHRjb25zdCBncm91cHMgPSB0aGlzLmdyb3VwcztcblxuXHRcdGZvciAoIGxldCBpID0gMCwgbCA9IGdyb3Vwcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRjb25zdCBncm91cCA9IGdyb3Vwc1sgaSBdO1xuXHRcdFx0Z2VvbWV0cnkyLmFkZEdyb3VwKCBncm91cC5zdGFydCwgZ3JvdXAuY291bnQsIGdyb3VwLm1hdGVyaWFsSW5kZXggKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBnZW9tZXRyeTI7XG5cblx0fVxuXG5cdHRvSlNPTigpIHtcblxuXHRcdGNvbnN0IGRhdGEgPSB7XG5cdFx0XHRtZXRhZGF0YToge1xuXHRcdFx0XHR2ZXJzaW9uOiA0LjYsXG5cdFx0XHRcdHR5cGU6ICdCdWZmZXJHZW9tZXRyeScsXG5cdFx0XHRcdGdlbmVyYXRvcjogJ0J1ZmZlckdlb21ldHJ5LnRvSlNPTidcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0Ly8gc3RhbmRhcmQgQnVmZmVyR2VvbWV0cnkgc2VyaWFsaXphdGlvblxuXG5cdFx0ZGF0YS51dWlkID0gdGhpcy51dWlkO1xuXHRcdGRhdGEudHlwZSA9IHRoaXMudHlwZTtcblx0XHRpZiAoIHRoaXMubmFtZSAhPT0gJycgKSBkYXRhLm5hbWUgPSB0aGlzLm5hbWU7XG5cdFx0aWYgKCBPYmplY3Qua2V5cyggdGhpcy51c2VyRGF0YSApLmxlbmd0aCA+IDAgKSBkYXRhLnVzZXJEYXRhID0gdGhpcy51c2VyRGF0YTtcblxuXHRcdGlmICggdGhpcy5wYXJhbWV0ZXJzICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGNvbnN0IHBhcmFtZXRlcnMgPSB0aGlzLnBhcmFtZXRlcnM7XG5cblx0XHRcdGZvciAoIGNvbnN0IGtleSBpbiBwYXJhbWV0ZXJzICkge1xuXG5cdFx0XHRcdGlmICggcGFyYW1ldGVyc1sga2V5IF0gIT09IHVuZGVmaW5lZCApIGRhdGFbIGtleSBdID0gcGFyYW1ldGVyc1sga2V5IF07XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGRhdGE7XG5cblx0XHR9XG5cblx0XHQvLyBmb3Igc2ltcGxpY2l0eSB0aGUgY29kZSBhc3N1bWVzIGF0dHJpYnV0ZXMgYXJlIG5vdCBzaGFyZWQgYWNyb3NzIGdlb21ldHJpZXMsIHNlZSAjMTU4MTFcblxuXHRcdGRhdGEuZGF0YSA9IHsgYXR0cmlidXRlczoge30gfTtcblxuXHRcdGNvbnN0IGluZGV4ID0gdGhpcy5pbmRleDtcblxuXHRcdGlmICggaW5kZXggIT09IG51bGwgKSB7XG5cblx0XHRcdGRhdGEuZGF0YS5pbmRleCA9IHtcblx0XHRcdFx0dHlwZTogaW5kZXguYXJyYXkuY29uc3RydWN0b3IubmFtZSxcblx0XHRcdFx0YXJyYXk6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKCBpbmRleC5hcnJheSApXG5cdFx0XHR9O1xuXG5cdFx0fVxuXG5cdFx0Y29uc3QgYXR0cmlidXRlcyA9IHRoaXMuYXR0cmlidXRlcztcblxuXHRcdGZvciAoIGNvbnN0IGtleSBpbiBhdHRyaWJ1dGVzICkge1xuXG5cdFx0XHRjb25zdCBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzWyBrZXkgXTtcblxuXHRcdFx0ZGF0YS5kYXRhLmF0dHJpYnV0ZXNbIGtleSBdID0gYXR0cmlidXRlLnRvSlNPTiggZGF0YS5kYXRhICk7XG5cblx0XHR9XG5cblx0XHRjb25zdCBtb3JwaEF0dHJpYnV0ZXMgPSB7fTtcblx0XHRsZXQgaGFzTW9ycGhBdHRyaWJ1dGVzID0gZmFsc2U7XG5cblx0XHRmb3IgKCBjb25zdCBrZXkgaW4gdGhpcy5tb3JwaEF0dHJpYnV0ZXMgKSB7XG5cblx0XHRcdGNvbnN0IGF0dHJpYnV0ZUFycmF5ID0gdGhpcy5tb3JwaEF0dHJpYnV0ZXNbIGtleSBdO1xuXG5cdFx0XHRjb25zdCBhcnJheSA9IFtdO1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGlsID0gYXR0cmlidXRlQXJyYXkubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdFx0Y29uc3QgYXR0cmlidXRlID0gYXR0cmlidXRlQXJyYXlbIGkgXTtcblxuXHRcdFx0XHRhcnJheS5wdXNoKCBhdHRyaWJ1dGUudG9KU09OKCBkYXRhLmRhdGEgKSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggYXJyYXkubGVuZ3RoID4gMCApIHtcblxuXHRcdFx0XHRtb3JwaEF0dHJpYnV0ZXNbIGtleSBdID0gYXJyYXk7XG5cblx0XHRcdFx0aGFzTW9ycGhBdHRyaWJ1dGVzID0gdHJ1ZTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0aWYgKCBoYXNNb3JwaEF0dHJpYnV0ZXMgKSB7XG5cblx0XHRcdGRhdGEuZGF0YS5tb3JwaEF0dHJpYnV0ZXMgPSBtb3JwaEF0dHJpYnV0ZXM7XG5cdFx0XHRkYXRhLmRhdGEubW9ycGhUYXJnZXRzUmVsYXRpdmUgPSB0aGlzLm1vcnBoVGFyZ2V0c1JlbGF0aXZlO1xuXG5cdFx0fVxuXG5cdFx0Y29uc3QgZ3JvdXBzID0gdGhpcy5ncm91cHM7XG5cblx0XHRpZiAoIGdyb3Vwcy5sZW5ndGggPiAwICkge1xuXG5cdFx0XHRkYXRhLmRhdGEuZ3JvdXBzID0gSlNPTi5wYXJzZSggSlNPTi5zdHJpbmdpZnkoIGdyb3VwcyApICk7XG5cblx0XHR9XG5cblx0XHRjb25zdCBib3VuZGluZ1NwaGVyZSA9IHRoaXMuYm91bmRpbmdTcGhlcmU7XG5cblx0XHRpZiAoIGJvdW5kaW5nU3BoZXJlICE9PSBudWxsICkge1xuXG5cdFx0XHRkYXRhLmRhdGEuYm91bmRpbmdTcGhlcmUgPSB7XG5cdFx0XHRcdGNlbnRlcjogYm91bmRpbmdTcGhlcmUuY2VudGVyLnRvQXJyYXkoKSxcblx0XHRcdFx0cmFkaXVzOiBib3VuZGluZ1NwaGVyZS5yYWRpdXNcblx0XHRcdH07XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gZGF0YTtcblxuXHR9XG5cblx0Y2xvbmUoKSB7XG5cblx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzICk7XG5cblx0fVxuXG5cdGNvcHkoIHNvdXJjZSApIHtcblxuXHRcdC8vIHJlc2V0XG5cblx0XHR0aGlzLmluZGV4ID0gbnVsbDtcblx0XHR0aGlzLmF0dHJpYnV0ZXMgPSB7fTtcblx0XHR0aGlzLm1vcnBoQXR0cmlidXRlcyA9IHt9O1xuXHRcdHRoaXMuZ3JvdXBzID0gW107XG5cdFx0dGhpcy5ib3VuZGluZ0JveCA9IG51bGw7XG5cdFx0dGhpcy5ib3VuZGluZ1NwaGVyZSA9IG51bGw7XG5cblx0XHQvLyB1c2VkIGZvciBzdG9yaW5nIGNsb25lZCwgc2hhcmVkIGRhdGFcblxuXHRcdGNvbnN0IGRhdGEgPSB7fTtcblxuXHRcdC8vIG5hbWVcblxuXHRcdHRoaXMubmFtZSA9IHNvdXJjZS5uYW1lO1xuXG5cdFx0Ly8gaW5kZXhcblxuXHRcdGNvbnN0IGluZGV4ID0gc291cmNlLmluZGV4O1xuXG5cdFx0aWYgKCBpbmRleCAhPT0gbnVsbCApIHtcblxuXHRcdFx0dGhpcy5zZXRJbmRleCggaW5kZXguY2xvbmUoIGRhdGEgKSApO1xuXG5cdFx0fVxuXG5cdFx0Ly8gYXR0cmlidXRlc1xuXG5cdFx0Y29uc3QgYXR0cmlidXRlcyA9IHNvdXJjZS5hdHRyaWJ1dGVzO1xuXG5cdFx0Zm9yICggY29uc3QgbmFtZSBpbiBhdHRyaWJ1dGVzICkge1xuXG5cdFx0XHRjb25zdCBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzWyBuYW1lIF07XG5cdFx0XHR0aGlzLnNldEF0dHJpYnV0ZSggbmFtZSwgYXR0cmlidXRlLmNsb25lKCBkYXRhICkgKTtcblxuXHRcdH1cblxuXHRcdC8vIG1vcnBoIGF0dHJpYnV0ZXNcblxuXHRcdGNvbnN0IG1vcnBoQXR0cmlidXRlcyA9IHNvdXJjZS5tb3JwaEF0dHJpYnV0ZXM7XG5cblx0XHRmb3IgKCBjb25zdCBuYW1lIGluIG1vcnBoQXR0cmlidXRlcyApIHtcblxuXHRcdFx0Y29uc3QgYXJyYXkgPSBbXTtcblx0XHRcdGNvbnN0IG1vcnBoQXR0cmlidXRlID0gbW9ycGhBdHRyaWJ1dGVzWyBuYW1lIF07IC8vIG1vcnBoQXR0cmlidXRlOiBhcnJheSBvZiBGbG9hdDMyQnVmZmVyQXR0cmlidXRlc1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBtb3JwaEF0dHJpYnV0ZS5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdGFycmF5LnB1c2goIG1vcnBoQXR0cmlidXRlWyBpIF0uY2xvbmUoIGRhdGEgKSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHRoaXMubW9ycGhBdHRyaWJ1dGVzWyBuYW1lIF0gPSBhcnJheTtcblxuXHRcdH1cblxuXHRcdHRoaXMubW9ycGhUYXJnZXRzUmVsYXRpdmUgPSBzb3VyY2UubW9ycGhUYXJnZXRzUmVsYXRpdmU7XG5cblx0XHQvLyBncm91cHNcblxuXHRcdGNvbnN0IGdyb3VwcyA9IHNvdXJjZS5ncm91cHM7XG5cblx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBncm91cHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0Y29uc3QgZ3JvdXAgPSBncm91cHNbIGkgXTtcblx0XHRcdHRoaXMuYWRkR3JvdXAoIGdyb3VwLnN0YXJ0LCBncm91cC5jb3VudCwgZ3JvdXAubWF0ZXJpYWxJbmRleCApO1xuXG5cdFx0fVxuXG5cdFx0Ly8gYm91bmRpbmcgYm94XG5cblx0XHRjb25zdCBib3VuZGluZ0JveCA9IHNvdXJjZS5ib3VuZGluZ0JveDtcblxuXHRcdGlmICggYm91bmRpbmdCb3ggIT09IG51bGwgKSB7XG5cblx0XHRcdHRoaXMuYm91bmRpbmdCb3ggPSBib3VuZGluZ0JveC5jbG9uZSgpO1xuXG5cdFx0fVxuXG5cdFx0Ly8gYm91bmRpbmcgc3BoZXJlXG5cblx0XHRjb25zdCBib3VuZGluZ1NwaGVyZSA9IHNvdXJjZS5ib3VuZGluZ1NwaGVyZTtcblxuXHRcdGlmICggYm91bmRpbmdTcGhlcmUgIT09IG51bGwgKSB7XG5cblx0XHRcdHRoaXMuYm91bmRpbmdTcGhlcmUgPSBib3VuZGluZ1NwaGVyZS5jbG9uZSgpO1xuXG5cdFx0fVxuXG5cdFx0Ly8gZHJhdyByYW5nZVxuXG5cdFx0dGhpcy5kcmF3UmFuZ2Uuc3RhcnQgPSBzb3VyY2UuZHJhd1JhbmdlLnN0YXJ0O1xuXHRcdHRoaXMuZHJhd1JhbmdlLmNvdW50ID0gc291cmNlLmRyYXdSYW5nZS5jb3VudDtcblxuXHRcdC8vIHVzZXIgZGF0YVxuXG5cdFx0dGhpcy51c2VyRGF0YSA9IHNvdXJjZS51c2VyRGF0YTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRkaXNwb3NlKCkge1xuXG5cdFx0dGhpcy5kaXNwYXRjaEV2ZW50KCB7IHR5cGU6ICdkaXNwb3NlJyB9ICk7XG5cblx0fVxuXG59XG5cbmV4cG9ydCB7IEJ1ZmZlckdlb21ldHJ5IH07XG4iLCIvKipcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9tcmRvb2IvZXZlbnRkaXNwYXRjaGVyLmpzL1xuICovXG5cbmNsYXNzIEV2ZW50RGlzcGF0Y2hlciB7XG5cblx0YWRkRXZlbnRMaXN0ZW5lciggdHlwZSwgbGlzdGVuZXIgKSB7XG5cblx0XHRpZiAoIHRoaXMuX2xpc3RlbmVycyA9PT0gdW5kZWZpbmVkICkgdGhpcy5fbGlzdGVuZXJzID0ge307XG5cblx0XHRjb25zdCBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnM7XG5cblx0XHRpZiAoIGxpc3RlbmVyc1sgdHlwZSBdID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGxpc3RlbmVyc1sgdHlwZSBdID0gW107XG5cblx0XHR9XG5cblx0XHRpZiAoIGxpc3RlbmVyc1sgdHlwZSBdLmluZGV4T2YoIGxpc3RlbmVyICkgPT09IC0gMSApIHtcblxuXHRcdFx0bGlzdGVuZXJzWyB0eXBlIF0ucHVzaCggbGlzdGVuZXIgKTtcblxuXHRcdH1cblxuXHR9XG5cblx0aGFzRXZlbnRMaXN0ZW5lciggdHlwZSwgbGlzdGVuZXIgKSB7XG5cblx0XHRpZiAoIHRoaXMuX2xpc3RlbmVycyA9PT0gdW5kZWZpbmVkICkgcmV0dXJuIGZhbHNlO1xuXG5cdFx0Y29uc3QgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzO1xuXG5cdFx0cmV0dXJuIGxpc3RlbmVyc1sgdHlwZSBdICE9PSB1bmRlZmluZWQgJiYgbGlzdGVuZXJzWyB0eXBlIF0uaW5kZXhPZiggbGlzdGVuZXIgKSAhPT0gLSAxO1xuXG5cdH1cblxuXHRyZW1vdmVFdmVudExpc3RlbmVyKCB0eXBlLCBsaXN0ZW5lciApIHtcblxuXHRcdGlmICggdGhpcy5fbGlzdGVuZXJzID09PSB1bmRlZmluZWQgKSByZXR1cm47XG5cblx0XHRjb25zdCBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnM7XG5cdFx0Y29uc3QgbGlzdGVuZXJBcnJheSA9IGxpc3RlbmVyc1sgdHlwZSBdO1xuXG5cdFx0aWYgKCBsaXN0ZW5lckFycmF5ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGNvbnN0IGluZGV4ID0gbGlzdGVuZXJBcnJheS5pbmRleE9mKCBsaXN0ZW5lciApO1xuXG5cdFx0XHRpZiAoIGluZGV4ICE9PSAtIDEgKSB7XG5cblx0XHRcdFx0bGlzdGVuZXJBcnJheS5zcGxpY2UoIGluZGV4LCAxICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9XG5cblx0ZGlzcGF0Y2hFdmVudCggZXZlbnQgKSB7XG5cblx0XHRpZiAoIHRoaXMuX2xpc3RlbmVycyA9PT0gdW5kZWZpbmVkICkgcmV0dXJuO1xuXG5cdFx0Y29uc3QgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzO1xuXHRcdGNvbnN0IGxpc3RlbmVyQXJyYXkgPSBsaXN0ZW5lcnNbIGV2ZW50LnR5cGUgXTtcblxuXHRcdGlmICggbGlzdGVuZXJBcnJheSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRldmVudC50YXJnZXQgPSB0aGlzO1xuXG5cdFx0XHQvLyBNYWtlIGEgY29weSwgaW4gY2FzZSBsaXN0ZW5lcnMgYXJlIHJlbW92ZWQgd2hpbGUgaXRlcmF0aW5nLlxuXHRcdFx0Y29uc3QgYXJyYXkgPSBsaXN0ZW5lckFycmF5LnNsaWNlKCAwICk7XG5cblx0XHRcdGZvciAoIGxldCBpID0gMCwgbCA9IGFycmF5Lmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0YXJyYXlbIGkgXS5jYWxsKCB0aGlzLCBldmVudCApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGV2ZW50LnRhcmdldCA9IG51bGw7XG5cblx0XHR9XG5cblx0fVxuXG59XG5cblxuZXhwb3J0IHsgRXZlbnREaXNwYXRjaGVyIH07XG4iLCJjbGFzcyBMYXllcnMge1xuXG5cdGNvbnN0cnVjdG9yKCkge1xuXG5cdFx0dGhpcy5tYXNrID0gMSB8IDA7XG5cblx0fVxuXG5cdHNldCggY2hhbm5lbCApIHtcblxuXHRcdHRoaXMubWFzayA9ICggMSA8PCBjaGFubmVsIHwgMCApID4+PiAwO1xuXG5cdH1cblxuXHRlbmFibGUoIGNoYW5uZWwgKSB7XG5cblx0XHR0aGlzLm1hc2sgfD0gMSA8PCBjaGFubmVsIHwgMDtcblxuXHR9XG5cblx0ZW5hYmxlQWxsKCkge1xuXG5cdFx0dGhpcy5tYXNrID0gMHhmZmZmZmZmZiB8IDA7XG5cblx0fVxuXG5cdHRvZ2dsZSggY2hhbm5lbCApIHtcblxuXHRcdHRoaXMubWFzayBePSAxIDw8IGNoYW5uZWwgfCAwO1xuXG5cdH1cblxuXHRkaXNhYmxlKCBjaGFubmVsICkge1xuXG5cdFx0dGhpcy5tYXNrICY9IH4gKCAxIDw8IGNoYW5uZWwgfCAwICk7XG5cblx0fVxuXG5cdGRpc2FibGVBbGwoKSB7XG5cblx0XHR0aGlzLm1hc2sgPSAwO1xuXG5cdH1cblxuXHR0ZXN0KCBsYXllcnMgKSB7XG5cblx0XHRyZXR1cm4gKCB0aGlzLm1hc2sgJiBsYXllcnMubWFzayApICE9PSAwO1xuXG5cdH1cblxuXHRpc0VuYWJsZWQoIGNoYW5uZWwgKSB7XG5cblx0XHRyZXR1cm4gKCB0aGlzLm1hc2sgJiAoIDEgPDwgY2hhbm5lbCB8IDAgKSApICE9PSAwO1xuXG5cdH1cblxufVxuXG5cbmV4cG9ydCB7IExheWVycyB9O1xuIiwiaW1wb3J0IHsgUXVhdGVybmlvbiB9IGZyb20gJy4uL21hdGgvUXVhdGVybmlvbi5qcyc7XG5pbXBvcnQgeyBWZWN0b3IzIH0gZnJvbSAnLi4vbWF0aC9WZWN0b3IzLmpzJztcbmltcG9ydCB7IE1hdHJpeDQgfSBmcm9tICcuLi9tYXRoL01hdHJpeDQuanMnO1xuaW1wb3J0IHsgRXZlbnREaXNwYXRjaGVyIH0gZnJvbSAnLi9FdmVudERpc3BhdGNoZXIuanMnO1xuaW1wb3J0IHsgRXVsZXIgfSBmcm9tICcuLi9tYXRoL0V1bGVyLmpzJztcbmltcG9ydCB7IExheWVycyB9IGZyb20gJy4vTGF5ZXJzLmpzJztcbmltcG9ydCB7IE1hdHJpeDMgfSBmcm9tICcuLi9tYXRoL01hdHJpeDMuanMnO1xuaW1wb3J0ICogYXMgTWF0aFV0aWxzIGZyb20gJy4uL21hdGgvTWF0aFV0aWxzLmpzJztcblxubGV0IF9vYmplY3QzRElkID0gMDtcblxuY29uc3QgX3YxID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xuY29uc3QgX3ExID0gLypAX19QVVJFX18qLyBuZXcgUXVhdGVybmlvbigpO1xuY29uc3QgX20xID0gLypAX19QVVJFX18qLyBuZXcgTWF0cml4NCgpO1xuY29uc3QgX3RhcmdldCA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcblxuY29uc3QgX3Bvc2l0aW9uID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xuY29uc3QgX3NjYWxlID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xuY29uc3QgX3F1YXRlcm5pb24gPSAvKkBfX1BVUkVfXyovIG5ldyBRdWF0ZXJuaW9uKCk7XG5cbmNvbnN0IF94QXhpcyA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoIDEsIDAsIDAgKTtcbmNvbnN0IF95QXhpcyA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoIDAsIDEsIDAgKTtcbmNvbnN0IF96QXhpcyA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoIDAsIDAsIDEgKTtcblxuY29uc3QgX2FkZGVkRXZlbnQgPSB7IHR5cGU6ICdhZGRlZCcgfTtcbmNvbnN0IF9yZW1vdmVkRXZlbnQgPSB7IHR5cGU6ICdyZW1vdmVkJyB9O1xuXG5jbGFzcyBPYmplY3QzRCBleHRlbmRzIEV2ZW50RGlzcGF0Y2hlciB7XG5cblx0Y29uc3RydWN0b3IoKSB7XG5cblx0XHRzdXBlcigpO1xuXG5cdFx0dGhpcy5pc09iamVjdDNEID0gdHJ1ZTtcblxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggdGhpcywgJ2lkJywgeyB2YWx1ZTogX29iamVjdDNESWQgKysgfSApO1xuXG5cdFx0dGhpcy51dWlkID0gTWF0aFV0aWxzLmdlbmVyYXRlVVVJRCgpO1xuXG5cdFx0dGhpcy5uYW1lID0gJyc7XG5cdFx0dGhpcy50eXBlID0gJ09iamVjdDNEJztcblxuXHRcdHRoaXMucGFyZW50ID0gbnVsbDtcblx0XHR0aGlzLmNoaWxkcmVuID0gW107XG5cblx0XHR0aGlzLnVwID0gT2JqZWN0M0QuREVGQVVMVF9VUC5jbG9uZSgpO1xuXG5cdFx0Y29uc3QgcG9zaXRpb24gPSBuZXcgVmVjdG9yMygpO1xuXHRcdGNvbnN0IHJvdGF0aW9uID0gbmV3IEV1bGVyKCk7XG5cdFx0Y29uc3QgcXVhdGVybmlvbiA9IG5ldyBRdWF0ZXJuaW9uKCk7XG5cdFx0Y29uc3Qgc2NhbGUgPSBuZXcgVmVjdG9yMyggMSwgMSwgMSApO1xuXG5cdFx0ZnVuY3Rpb24gb25Sb3RhdGlvbkNoYW5nZSgpIHtcblxuXHRcdFx0cXVhdGVybmlvbi5zZXRGcm9tRXVsZXIoIHJvdGF0aW9uLCBmYWxzZSApO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gb25RdWF0ZXJuaW9uQ2hhbmdlKCkge1xuXG5cdFx0XHRyb3RhdGlvbi5zZXRGcm9tUXVhdGVybmlvbiggcXVhdGVybmlvbiwgdW5kZWZpbmVkLCBmYWxzZSApO1xuXG5cdFx0fVxuXG5cdFx0cm90YXRpb24uX29uQ2hhbmdlKCBvblJvdGF0aW9uQ2hhbmdlICk7XG5cdFx0cXVhdGVybmlvbi5fb25DaGFuZ2UoIG9uUXVhdGVybmlvbkNoYW5nZSApO1xuXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIHRoaXMsIHtcblx0XHRcdHBvc2l0aW9uOiB7XG5cdFx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdFx0dmFsdWU6IHBvc2l0aW9uXG5cdFx0XHR9LFxuXHRcdFx0cm90YXRpb246IHtcblx0XHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlLFxuXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0XHR2YWx1ZTogcm90YXRpb25cblx0XHRcdH0sXG5cdFx0XHRxdWF0ZXJuaW9uOiB7XG5cdFx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdFx0dmFsdWU6IHF1YXRlcm5pb25cblx0XHRcdH0sXG5cdFx0XHRzY2FsZToge1xuXHRcdFx0XHRjb25maWd1cmFibGU6IHRydWUsXG5cdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRcdHZhbHVlOiBzY2FsZVxuXHRcdFx0fSxcblx0XHRcdG1vZGVsVmlld01hdHJpeDoge1xuXHRcdFx0XHR2YWx1ZTogbmV3IE1hdHJpeDQoKVxuXHRcdFx0fSxcblx0XHRcdG5vcm1hbE1hdHJpeDoge1xuXHRcdFx0XHR2YWx1ZTogbmV3IE1hdHJpeDMoKVxuXHRcdFx0fVxuXHRcdH0gKTtcblxuXHRcdHRoaXMubWF0cml4ID0gbmV3IE1hdHJpeDQoKTtcblx0XHR0aGlzLm1hdHJpeFdvcmxkID0gbmV3IE1hdHJpeDQoKTtcblxuXHRcdHRoaXMubWF0cml4QXV0b1VwZGF0ZSA9IE9iamVjdDNELkRFRkFVTFRfTUFUUklYX0FVVE9fVVBEQVRFO1xuXHRcdHRoaXMubWF0cml4V29ybGROZWVkc1VwZGF0ZSA9IGZhbHNlO1xuXG5cdFx0dGhpcy5tYXRyaXhXb3JsZEF1dG9VcGRhdGUgPSBPYmplY3QzRC5ERUZBVUxUX01BVFJJWF9XT1JMRF9BVVRPX1VQREFURTsgLy8gY2hlY2tlZCBieSB0aGUgcmVuZGVyZXJcblxuXHRcdHRoaXMubGF5ZXJzID0gbmV3IExheWVycygpO1xuXHRcdHRoaXMudmlzaWJsZSA9IHRydWU7XG5cblx0XHR0aGlzLmNhc3RTaGFkb3cgPSBmYWxzZTtcblx0XHR0aGlzLnJlY2VpdmVTaGFkb3cgPSBmYWxzZTtcblxuXHRcdHRoaXMuZnJ1c3R1bUN1bGxlZCA9IHRydWU7XG5cdFx0dGhpcy5yZW5kZXJPcmRlciA9IDA7XG5cblx0XHR0aGlzLmFuaW1hdGlvbnMgPSBbXTtcblxuXHRcdHRoaXMudXNlckRhdGEgPSB7fTtcblxuXHR9XG5cblx0b25CZWZvcmVSZW5kZXIoIC8qIHJlbmRlcmVyLCBzY2VuZSwgY2FtZXJhLCBnZW9tZXRyeSwgbWF0ZXJpYWwsIGdyb3VwICovICkge31cblxuXHRvbkFmdGVyUmVuZGVyKCAvKiByZW5kZXJlciwgc2NlbmUsIGNhbWVyYSwgZ2VvbWV0cnksIG1hdGVyaWFsLCBncm91cCAqLyApIHt9XG5cblx0YXBwbHlNYXRyaXg0KCBtYXRyaXggKSB7XG5cblx0XHRpZiAoIHRoaXMubWF0cml4QXV0b1VwZGF0ZSApIHRoaXMudXBkYXRlTWF0cml4KCk7XG5cblx0XHR0aGlzLm1hdHJpeC5wcmVtdWx0aXBseSggbWF0cml4ICk7XG5cblx0XHR0aGlzLm1hdHJpeC5kZWNvbXBvc2UoIHRoaXMucG9zaXRpb24sIHRoaXMucXVhdGVybmlvbiwgdGhpcy5zY2FsZSApO1xuXG5cdH1cblxuXHRhcHBseVF1YXRlcm5pb24oIHEgKSB7XG5cblx0XHR0aGlzLnF1YXRlcm5pb24ucHJlbXVsdGlwbHkoIHEgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzZXRSb3RhdGlvbkZyb21BeGlzQW5nbGUoIGF4aXMsIGFuZ2xlICkge1xuXG5cdFx0Ly8gYXNzdW1lcyBheGlzIGlzIG5vcm1hbGl6ZWRcblxuXHRcdHRoaXMucXVhdGVybmlvbi5zZXRGcm9tQXhpc0FuZ2xlKCBheGlzLCBhbmdsZSApO1xuXG5cdH1cblxuXHRzZXRSb3RhdGlvbkZyb21FdWxlciggZXVsZXIgKSB7XG5cblx0XHR0aGlzLnF1YXRlcm5pb24uc2V0RnJvbUV1bGVyKCBldWxlciwgdHJ1ZSApO1xuXG5cdH1cblxuXHRzZXRSb3RhdGlvbkZyb21NYXRyaXgoIG0gKSB7XG5cblx0XHQvLyBhc3N1bWVzIHRoZSB1cHBlciAzeDMgb2YgbSBpcyBhIHB1cmUgcm90YXRpb24gbWF0cml4IChpLmUsIHVuc2NhbGVkKVxuXG5cdFx0dGhpcy5xdWF0ZXJuaW9uLnNldEZyb21Sb3RhdGlvbk1hdHJpeCggbSApO1xuXG5cdH1cblxuXHRzZXRSb3RhdGlvbkZyb21RdWF0ZXJuaW9uKCBxICkge1xuXG5cdFx0Ly8gYXNzdW1lcyBxIGlzIG5vcm1hbGl6ZWRcblxuXHRcdHRoaXMucXVhdGVybmlvbi5jb3B5KCBxICk7XG5cblx0fVxuXG5cdHJvdGF0ZU9uQXhpcyggYXhpcywgYW5nbGUgKSB7XG5cblx0XHQvLyByb3RhdGUgb2JqZWN0IG9uIGF4aXMgaW4gb2JqZWN0IHNwYWNlXG5cdFx0Ly8gYXhpcyBpcyBhc3N1bWVkIHRvIGJlIG5vcm1hbGl6ZWRcblxuXHRcdF9xMS5zZXRGcm9tQXhpc0FuZ2xlKCBheGlzLCBhbmdsZSApO1xuXG5cdFx0dGhpcy5xdWF0ZXJuaW9uLm11bHRpcGx5KCBfcTEgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRyb3RhdGVPbldvcmxkQXhpcyggYXhpcywgYW5nbGUgKSB7XG5cblx0XHQvLyByb3RhdGUgb2JqZWN0IG9uIGF4aXMgaW4gd29ybGQgc3BhY2Vcblx0XHQvLyBheGlzIGlzIGFzc3VtZWQgdG8gYmUgbm9ybWFsaXplZFxuXHRcdC8vIG1ldGhvZCBhc3N1bWVzIG5vIHJvdGF0ZWQgcGFyZW50XG5cblx0XHRfcTEuc2V0RnJvbUF4aXNBbmdsZSggYXhpcywgYW5nbGUgKTtcblxuXHRcdHRoaXMucXVhdGVybmlvbi5wcmVtdWx0aXBseSggX3ExICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0cm90YXRlWCggYW5nbGUgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5yb3RhdGVPbkF4aXMoIF94QXhpcywgYW5nbGUgKTtcblxuXHR9XG5cblx0cm90YXRlWSggYW5nbGUgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5yb3RhdGVPbkF4aXMoIF95QXhpcywgYW5nbGUgKTtcblxuXHR9XG5cblx0cm90YXRlWiggYW5nbGUgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5yb3RhdGVPbkF4aXMoIF96QXhpcywgYW5nbGUgKTtcblxuXHR9XG5cblx0dHJhbnNsYXRlT25BeGlzKCBheGlzLCBkaXN0YW5jZSApIHtcblxuXHRcdC8vIHRyYW5zbGF0ZSBvYmplY3QgYnkgZGlzdGFuY2UgYWxvbmcgYXhpcyBpbiBvYmplY3Qgc3BhY2Vcblx0XHQvLyBheGlzIGlzIGFzc3VtZWQgdG8gYmUgbm9ybWFsaXplZFxuXG5cdFx0X3YxLmNvcHkoIGF4aXMgKS5hcHBseVF1YXRlcm5pb24oIHRoaXMucXVhdGVybmlvbiApO1xuXG5cdFx0dGhpcy5wb3NpdGlvbi5hZGQoIF92MS5tdWx0aXBseVNjYWxhciggZGlzdGFuY2UgKSApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHRyYW5zbGF0ZVgoIGRpc3RhbmNlICkge1xuXG5cdFx0cmV0dXJuIHRoaXMudHJhbnNsYXRlT25BeGlzKCBfeEF4aXMsIGRpc3RhbmNlICk7XG5cblx0fVxuXG5cdHRyYW5zbGF0ZVkoIGRpc3RhbmNlICkge1xuXG5cdFx0cmV0dXJuIHRoaXMudHJhbnNsYXRlT25BeGlzKCBfeUF4aXMsIGRpc3RhbmNlICk7XG5cblx0fVxuXG5cdHRyYW5zbGF0ZVooIGRpc3RhbmNlICkge1xuXG5cdFx0cmV0dXJuIHRoaXMudHJhbnNsYXRlT25BeGlzKCBfekF4aXMsIGRpc3RhbmNlICk7XG5cblx0fVxuXG5cdGxvY2FsVG9Xb3JsZCggdmVjdG9yICkge1xuXG5cdFx0dGhpcy51cGRhdGVXb3JsZE1hdHJpeCggdHJ1ZSwgZmFsc2UgKTtcblxuXHRcdHJldHVybiB2ZWN0b3IuYXBwbHlNYXRyaXg0KCB0aGlzLm1hdHJpeFdvcmxkICk7XG5cblx0fVxuXG5cdHdvcmxkVG9Mb2NhbCggdmVjdG9yICkge1xuXG5cdFx0dGhpcy51cGRhdGVXb3JsZE1hdHJpeCggdHJ1ZSwgZmFsc2UgKTtcblxuXHRcdHJldHVybiB2ZWN0b3IuYXBwbHlNYXRyaXg0KCBfbTEuY29weSggdGhpcy5tYXRyaXhXb3JsZCApLmludmVydCgpICk7XG5cblx0fVxuXG5cdGxvb2tBdCggeCwgeSwgeiApIHtcblxuXHRcdC8vIFRoaXMgbWV0aG9kIGRvZXMgbm90IHN1cHBvcnQgb2JqZWN0cyBoYXZpbmcgbm9uLXVuaWZvcm1seS1zY2FsZWQgcGFyZW50KHMpXG5cblx0XHRpZiAoIHguaXNWZWN0b3IzICkge1xuXG5cdFx0XHRfdGFyZ2V0LmNvcHkoIHggKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdF90YXJnZXQuc2V0KCB4LCB5LCB6ICk7XG5cblx0XHR9XG5cblx0XHRjb25zdCBwYXJlbnQgPSB0aGlzLnBhcmVudDtcblxuXHRcdHRoaXMudXBkYXRlV29ybGRNYXRyaXgoIHRydWUsIGZhbHNlICk7XG5cblx0XHRfcG9zaXRpb24uc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCB0aGlzLm1hdHJpeFdvcmxkICk7XG5cblx0XHRpZiAoIHRoaXMuaXNDYW1lcmEgfHwgdGhpcy5pc0xpZ2h0ICkge1xuXG5cdFx0XHRfbTEubG9va0F0KCBfcG9zaXRpb24sIF90YXJnZXQsIHRoaXMudXAgKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdF9tMS5sb29rQXQoIF90YXJnZXQsIF9wb3NpdGlvbiwgdGhpcy51cCApO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5xdWF0ZXJuaW9uLnNldEZyb21Sb3RhdGlvbk1hdHJpeCggX20xICk7XG5cblx0XHRpZiAoIHBhcmVudCApIHtcblxuXHRcdFx0X20xLmV4dHJhY3RSb3RhdGlvbiggcGFyZW50Lm1hdHJpeFdvcmxkICk7XG5cdFx0XHRfcTEuc2V0RnJvbVJvdGF0aW9uTWF0cml4KCBfbTEgKTtcblx0XHRcdHRoaXMucXVhdGVybmlvbi5wcmVtdWx0aXBseSggX3ExLmludmVydCgpICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdGFkZCggb2JqZWN0ICkge1xuXG5cdFx0aWYgKCBhcmd1bWVudHMubGVuZ3RoID4gMSApIHtcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0XHR0aGlzLmFkZCggYXJndW1lbnRzWyBpIF0gKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH1cblxuXHRcdGlmICggb2JqZWN0ID09PSB0aGlzICkge1xuXG5cdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuT2JqZWN0M0QuYWRkOiBvYmplY3QgY2FuXFwndCBiZSBhZGRlZCBhcyBhIGNoaWxkIG9mIGl0c2VsZi4nLCBvYmplY3QgKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBvYmplY3QgJiYgb2JqZWN0LmlzT2JqZWN0M0QgKSB7XG5cblx0XHRcdGlmICggb2JqZWN0LnBhcmVudCAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHRvYmplY3QucGFyZW50LnJlbW92ZSggb2JqZWN0ICk7XG5cblx0XHRcdH1cblxuXHRcdFx0b2JqZWN0LnBhcmVudCA9IHRoaXM7XG5cdFx0XHR0aGlzLmNoaWxkcmVuLnB1c2goIG9iamVjdCApO1xuXG5cdFx0XHRvYmplY3QuZGlzcGF0Y2hFdmVudCggX2FkZGVkRXZlbnQgKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5PYmplY3QzRC5hZGQ6IG9iamVjdCBub3QgYW4gaW5zdGFuY2Ugb2YgVEhSRUUuT2JqZWN0M0QuJywgb2JqZWN0ICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0cmVtb3ZlKCBvYmplY3QgKSB7XG5cblx0XHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggPiAxICkge1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdHRoaXMucmVtb3ZlKCBhcmd1bWVudHNbIGkgXSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fVxuXG5cdFx0Y29uc3QgaW5kZXggPSB0aGlzLmNoaWxkcmVuLmluZGV4T2YoIG9iamVjdCApO1xuXG5cdFx0aWYgKCBpbmRleCAhPT0gLSAxICkge1xuXG5cdFx0XHRvYmplY3QucGFyZW50ID0gbnVsbDtcblx0XHRcdHRoaXMuY2hpbGRyZW4uc3BsaWNlKCBpbmRleCwgMSApO1xuXG5cdFx0XHRvYmplY3QuZGlzcGF0Y2hFdmVudCggX3JlbW92ZWRFdmVudCApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHJlbW92ZUZyb21QYXJlbnQoKSB7XG5cblx0XHRjb25zdCBwYXJlbnQgPSB0aGlzLnBhcmVudDtcblxuXHRcdGlmICggcGFyZW50ICE9PSBudWxsICkge1xuXG5cdFx0XHRwYXJlbnQucmVtb3ZlKCB0aGlzICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Y2xlYXIoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5yZW1vdmUoIC4uLiB0aGlzLmNoaWxkcmVuICk7XG5cblx0fVxuXG5cdGF0dGFjaCggb2JqZWN0ICkge1xuXG5cdFx0Ly8gYWRkcyBvYmplY3QgYXMgYSBjaGlsZCBvZiB0aGlzLCB3aGlsZSBtYWludGFpbmluZyB0aGUgb2JqZWN0J3Mgd29ybGQgdHJhbnNmb3JtXG5cblx0XHQvLyBOb3RlOiBUaGlzIG1ldGhvZCBkb2VzIG5vdCBzdXBwb3J0IHNjZW5lIGdyYXBocyBoYXZpbmcgbm9uLXVuaWZvcm1seS1zY2FsZWQgbm9kZXMocylcblxuXHRcdHRoaXMudXBkYXRlV29ybGRNYXRyaXgoIHRydWUsIGZhbHNlICk7XG5cblx0XHRfbTEuY29weSggdGhpcy5tYXRyaXhXb3JsZCApLmludmVydCgpO1xuXG5cdFx0aWYgKCBvYmplY3QucGFyZW50ICE9PSBudWxsICkge1xuXG5cdFx0XHRvYmplY3QucGFyZW50LnVwZGF0ZVdvcmxkTWF0cml4KCB0cnVlLCBmYWxzZSApO1xuXG5cdFx0XHRfbTEubXVsdGlwbHkoIG9iamVjdC5wYXJlbnQubWF0cml4V29ybGQgKTtcblxuXHRcdH1cblxuXHRcdG9iamVjdC5hcHBseU1hdHJpeDQoIF9tMSApO1xuXG5cdFx0dGhpcy5hZGQoIG9iamVjdCApO1xuXG5cdFx0b2JqZWN0LnVwZGF0ZVdvcmxkTWF0cml4KCBmYWxzZSwgdHJ1ZSApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGdldE9iamVjdEJ5SWQoIGlkICkge1xuXG5cdFx0cmV0dXJuIHRoaXMuZ2V0T2JqZWN0QnlQcm9wZXJ0eSggJ2lkJywgaWQgKTtcblxuXHR9XG5cblx0Z2V0T2JqZWN0QnlOYW1lKCBuYW1lICkge1xuXG5cdFx0cmV0dXJuIHRoaXMuZ2V0T2JqZWN0QnlQcm9wZXJ0eSggJ25hbWUnLCBuYW1lICk7XG5cblx0fVxuXG5cdGdldE9iamVjdEJ5UHJvcGVydHkoIG5hbWUsIHZhbHVlICkge1xuXG5cdFx0aWYgKCB0aGlzWyBuYW1lIF0gPT09IHZhbHVlICkgcmV0dXJuIHRoaXM7XG5cblx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdGNvbnN0IGNoaWxkID0gdGhpcy5jaGlsZHJlblsgaSBdO1xuXHRcdFx0Y29uc3Qgb2JqZWN0ID0gY2hpbGQuZ2V0T2JqZWN0QnlQcm9wZXJ0eSggbmFtZSwgdmFsdWUgKTtcblxuXHRcdFx0aWYgKCBvYmplY3QgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRyZXR1cm4gb2JqZWN0O1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdW5kZWZpbmVkO1xuXG5cdH1cblxuXHRnZXRPYmplY3RzQnlQcm9wZXJ0eSggbmFtZSwgdmFsdWUgKSB7XG5cblx0XHRsZXQgcmVzdWx0ID0gW107XG5cblx0XHRpZiAoIHRoaXNbIG5hbWUgXSA9PT0gdmFsdWUgKSByZXN1bHQucHVzaCggdGhpcyApO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRjb25zdCBjaGlsZFJlc3VsdCA9IHRoaXMuY2hpbGRyZW5bIGkgXS5nZXRPYmplY3RzQnlQcm9wZXJ0eSggbmFtZSwgdmFsdWUgKTtcblxuXHRcdFx0aWYgKCBjaGlsZFJlc3VsdC5sZW5ndGggPiAwICkge1xuXG5cdFx0XHRcdHJlc3VsdCA9IHJlc3VsdC5jb25jYXQoIGNoaWxkUmVzdWx0ICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHJldHVybiByZXN1bHQ7XG5cblx0fVxuXG5cdGdldFdvcmxkUG9zaXRpb24oIHRhcmdldCApIHtcblxuXHRcdHRoaXMudXBkYXRlV29ybGRNYXRyaXgoIHRydWUsIGZhbHNlICk7XG5cblx0XHRyZXR1cm4gdGFyZ2V0LnNldEZyb21NYXRyaXhQb3NpdGlvbiggdGhpcy5tYXRyaXhXb3JsZCApO1xuXG5cdH1cblxuXHRnZXRXb3JsZFF1YXRlcm5pb24oIHRhcmdldCApIHtcblxuXHRcdHRoaXMudXBkYXRlV29ybGRNYXRyaXgoIHRydWUsIGZhbHNlICk7XG5cblx0XHR0aGlzLm1hdHJpeFdvcmxkLmRlY29tcG9zZSggX3Bvc2l0aW9uLCB0YXJnZXQsIF9zY2FsZSApO1xuXG5cdFx0cmV0dXJuIHRhcmdldDtcblxuXHR9XG5cblx0Z2V0V29ybGRTY2FsZSggdGFyZ2V0ICkge1xuXG5cdFx0dGhpcy51cGRhdGVXb3JsZE1hdHJpeCggdHJ1ZSwgZmFsc2UgKTtcblxuXHRcdHRoaXMubWF0cml4V29ybGQuZGVjb21wb3NlKCBfcG9zaXRpb24sIF9xdWF0ZXJuaW9uLCB0YXJnZXQgKTtcblxuXHRcdHJldHVybiB0YXJnZXQ7XG5cblx0fVxuXG5cdGdldFdvcmxkRGlyZWN0aW9uKCB0YXJnZXQgKSB7XG5cblx0XHR0aGlzLnVwZGF0ZVdvcmxkTWF0cml4KCB0cnVlLCBmYWxzZSApO1xuXG5cdFx0Y29uc3QgZSA9IHRoaXMubWF0cml4V29ybGQuZWxlbWVudHM7XG5cblx0XHRyZXR1cm4gdGFyZ2V0LnNldCggZVsgOCBdLCBlWyA5IF0sIGVbIDEwIF0gKS5ub3JtYWxpemUoKTtcblxuXHR9XG5cblx0cmF5Y2FzdCggLyogcmF5Y2FzdGVyLCBpbnRlcnNlY3RzICovICkge31cblxuXHR0cmF2ZXJzZSggY2FsbGJhY2sgKSB7XG5cblx0XHRjYWxsYmFjayggdGhpcyApO1xuXG5cdFx0Y29uc3QgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0Y2hpbGRyZW5bIGkgXS50cmF2ZXJzZSggY2FsbGJhY2sgKTtcblxuXHRcdH1cblxuXHR9XG5cblx0dHJhdmVyc2VWaXNpYmxlKCBjYWxsYmFjayApIHtcblxuXHRcdGlmICggdGhpcy52aXNpYmxlID09PSBmYWxzZSApIHJldHVybjtcblxuXHRcdGNhbGxiYWNrKCB0aGlzICk7XG5cblx0XHRjb25zdCBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW47XG5cblx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRjaGlsZHJlblsgaSBdLnRyYXZlcnNlVmlzaWJsZSggY2FsbGJhY2sgKTtcblxuXHRcdH1cblxuXHR9XG5cblx0dHJhdmVyc2VBbmNlc3RvcnMoIGNhbGxiYWNrICkge1xuXG5cdFx0Y29uc3QgcGFyZW50ID0gdGhpcy5wYXJlbnQ7XG5cblx0XHRpZiAoIHBhcmVudCAhPT0gbnVsbCApIHtcblxuXHRcdFx0Y2FsbGJhY2soIHBhcmVudCApO1xuXG5cdFx0XHRwYXJlbnQudHJhdmVyc2VBbmNlc3RvcnMoIGNhbGxiYWNrICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdHVwZGF0ZU1hdHJpeCgpIHtcblxuXHRcdHRoaXMubWF0cml4LmNvbXBvc2UoIHRoaXMucG9zaXRpb24sIHRoaXMucXVhdGVybmlvbiwgdGhpcy5zY2FsZSApO1xuXG5cdFx0dGhpcy5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHR9XG5cblx0dXBkYXRlTWF0cml4V29ybGQoIGZvcmNlICkge1xuXG5cdFx0aWYgKCB0aGlzLm1hdHJpeEF1dG9VcGRhdGUgKSB0aGlzLnVwZGF0ZU1hdHJpeCgpO1xuXG5cdFx0aWYgKCB0aGlzLm1hdHJpeFdvcmxkTmVlZHNVcGRhdGUgfHwgZm9yY2UgKSB7XG5cblx0XHRcdGlmICggdGhpcy5wYXJlbnQgPT09IG51bGwgKSB7XG5cblx0XHRcdFx0dGhpcy5tYXRyaXhXb3JsZC5jb3B5KCB0aGlzLm1hdHJpeCApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdHRoaXMubWF0cml4V29ybGQubXVsdGlwbHlNYXRyaWNlcyggdGhpcy5wYXJlbnQubWF0cml4V29ybGQsIHRoaXMubWF0cml4ICk7XG5cblx0XHRcdH1cblxuXHRcdFx0dGhpcy5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlID0gZmFsc2U7XG5cblx0XHRcdGZvcmNlID0gdHJ1ZTtcblxuXHRcdH1cblxuXHRcdC8vIHVwZGF0ZSBjaGlsZHJlblxuXG5cdFx0Y29uc3QgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0Y29uc3QgY2hpbGQgPSBjaGlsZHJlblsgaSBdO1xuXG5cdFx0XHRpZiAoIGNoaWxkLm1hdHJpeFdvcmxkQXV0b1VwZGF0ZSA9PT0gdHJ1ZSB8fCBmb3JjZSA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRjaGlsZC51cGRhdGVNYXRyaXhXb3JsZCggZm9yY2UgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH1cblxuXHR1cGRhdGVXb3JsZE1hdHJpeCggdXBkYXRlUGFyZW50cywgdXBkYXRlQ2hpbGRyZW4gKSB7XG5cblx0XHRjb25zdCBwYXJlbnQgPSB0aGlzLnBhcmVudDtcblxuXHRcdGlmICggdXBkYXRlUGFyZW50cyA9PT0gdHJ1ZSAmJiBwYXJlbnQgIT09IG51bGwgJiYgcGFyZW50Lm1hdHJpeFdvcmxkQXV0b1VwZGF0ZSA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0cGFyZW50LnVwZGF0ZVdvcmxkTWF0cml4KCB0cnVlLCBmYWxzZSApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLm1hdHJpeEF1dG9VcGRhdGUgKSB0aGlzLnVwZGF0ZU1hdHJpeCgpO1xuXG5cdFx0aWYgKCB0aGlzLnBhcmVudCA9PT0gbnVsbCApIHtcblxuXHRcdFx0dGhpcy5tYXRyaXhXb3JsZC5jb3B5KCB0aGlzLm1hdHJpeCApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0dGhpcy5tYXRyaXhXb3JsZC5tdWx0aXBseU1hdHJpY2VzKCB0aGlzLnBhcmVudC5tYXRyaXhXb3JsZCwgdGhpcy5tYXRyaXggKTtcblxuXHRcdH1cblxuXHRcdC8vIHVwZGF0ZSBjaGlsZHJlblxuXG5cdFx0aWYgKCB1cGRhdGVDaGlsZHJlbiA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0Y29uc3QgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuO1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdGNvbnN0IGNoaWxkID0gY2hpbGRyZW5bIGkgXTtcblxuXHRcdFx0XHRpZiAoIGNoaWxkLm1hdHJpeFdvcmxkQXV0b1VwZGF0ZSA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRcdGNoaWxkLnVwZGF0ZVdvcmxkTWF0cml4KCBmYWxzZSwgdHJ1ZSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH1cblxuXHR0b0pTT04oIG1ldGEgKSB7XG5cblx0XHQvLyBtZXRhIGlzIGEgc3RyaW5nIHdoZW4gY2FsbGVkIGZyb20gSlNPTi5zdHJpbmdpZnlcblx0XHRjb25zdCBpc1Jvb3RPYmplY3QgPSAoIG1ldGEgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgbWV0YSA9PT0gJ3N0cmluZycgKTtcblxuXHRcdGNvbnN0IG91dHB1dCA9IHt9O1xuXG5cdFx0Ly8gbWV0YSBpcyBhIGhhc2ggdXNlZCB0byBjb2xsZWN0IGdlb21ldHJpZXMsIG1hdGVyaWFscy5cblx0XHQvLyBub3QgcHJvdmlkaW5nIGl0IGltcGxpZXMgdGhhdCB0aGlzIGlzIHRoZSByb290IG9iamVjdFxuXHRcdC8vIGJlaW5nIHNlcmlhbGl6ZWQuXG5cdFx0aWYgKCBpc1Jvb3RPYmplY3QgKSB7XG5cblx0XHRcdC8vIGluaXRpYWxpemUgbWV0YSBvYmpcblx0XHRcdG1ldGEgPSB7XG5cdFx0XHRcdGdlb21ldHJpZXM6IHt9LFxuXHRcdFx0XHRtYXRlcmlhbHM6IHt9LFxuXHRcdFx0XHR0ZXh0dXJlczoge30sXG5cdFx0XHRcdGltYWdlczoge30sXG5cdFx0XHRcdHNoYXBlczoge30sXG5cdFx0XHRcdHNrZWxldG9uczoge30sXG5cdFx0XHRcdGFuaW1hdGlvbnM6IHt9LFxuXHRcdFx0XHRub2Rlczoge31cblx0XHRcdH07XG5cblx0XHRcdG91dHB1dC5tZXRhZGF0YSA9IHtcblx0XHRcdFx0dmVyc2lvbjogNC42LFxuXHRcdFx0XHR0eXBlOiAnT2JqZWN0Jyxcblx0XHRcdFx0Z2VuZXJhdG9yOiAnT2JqZWN0M0QudG9KU09OJ1xuXHRcdFx0fTtcblxuXHRcdH1cblxuXHRcdC8vIHN0YW5kYXJkIE9iamVjdDNEIHNlcmlhbGl6YXRpb25cblxuXHRcdGNvbnN0IG9iamVjdCA9IHt9O1xuXG5cdFx0b2JqZWN0LnV1aWQgPSB0aGlzLnV1aWQ7XG5cdFx0b2JqZWN0LnR5cGUgPSB0aGlzLnR5cGU7XG5cblx0XHRpZiAoIHRoaXMubmFtZSAhPT0gJycgKSBvYmplY3QubmFtZSA9IHRoaXMubmFtZTtcblx0XHRpZiAoIHRoaXMuY2FzdFNoYWRvdyA9PT0gdHJ1ZSApIG9iamVjdC5jYXN0U2hhZG93ID0gdHJ1ZTtcblx0XHRpZiAoIHRoaXMucmVjZWl2ZVNoYWRvdyA9PT0gdHJ1ZSApIG9iamVjdC5yZWNlaXZlU2hhZG93ID0gdHJ1ZTtcblx0XHRpZiAoIHRoaXMudmlzaWJsZSA9PT0gZmFsc2UgKSBvYmplY3QudmlzaWJsZSA9IGZhbHNlO1xuXHRcdGlmICggdGhpcy5mcnVzdHVtQ3VsbGVkID09PSBmYWxzZSApIG9iamVjdC5mcnVzdHVtQ3VsbGVkID0gZmFsc2U7XG5cdFx0aWYgKCB0aGlzLnJlbmRlck9yZGVyICE9PSAwICkgb2JqZWN0LnJlbmRlck9yZGVyID0gdGhpcy5yZW5kZXJPcmRlcjtcblx0XHRpZiAoIE9iamVjdC5rZXlzKCB0aGlzLnVzZXJEYXRhICkubGVuZ3RoID4gMCApIG9iamVjdC51c2VyRGF0YSA9IHRoaXMudXNlckRhdGE7XG5cblx0XHRvYmplY3QubGF5ZXJzID0gdGhpcy5sYXllcnMubWFzaztcblx0XHRvYmplY3QubWF0cml4ID0gdGhpcy5tYXRyaXgudG9BcnJheSgpO1xuXHRcdG9iamVjdC51cCA9IHRoaXMudXAudG9BcnJheSgpO1xuXG5cdFx0aWYgKCB0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPT09IGZhbHNlICkgb2JqZWN0Lm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcblxuXHRcdC8vIG9iamVjdCBzcGVjaWZpYyBwcm9wZXJ0aWVzXG5cblx0XHRpZiAoIHRoaXMuaXNJbnN0YW5jZWRNZXNoICkge1xuXG5cdFx0XHRvYmplY3QudHlwZSA9ICdJbnN0YW5jZWRNZXNoJztcblx0XHRcdG9iamVjdC5jb3VudCA9IHRoaXMuY291bnQ7XG5cdFx0XHRvYmplY3QuaW5zdGFuY2VNYXRyaXggPSB0aGlzLmluc3RhbmNlTWF0cml4LnRvSlNPTigpO1xuXHRcdFx0aWYgKCB0aGlzLmluc3RhbmNlQ29sb3IgIT09IG51bGwgKSBvYmplY3QuaW5zdGFuY2VDb2xvciA9IHRoaXMuaW5zdGFuY2VDb2xvci50b0pTT04oKTtcblxuXHRcdH1cblxuXHRcdC8vXG5cblx0XHRmdW5jdGlvbiBzZXJpYWxpemUoIGxpYnJhcnksIGVsZW1lbnQgKSB7XG5cblx0XHRcdGlmICggbGlicmFyeVsgZWxlbWVudC51dWlkIF0gPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRsaWJyYXJ5WyBlbGVtZW50LnV1aWQgXSA9IGVsZW1lbnQudG9KU09OKCBtZXRhICk7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGVsZW1lbnQudXVpZDtcblxuXHRcdH1cblxuXHRcdGlmICggdGhpcy5pc1NjZW5lICkge1xuXG5cdFx0XHRpZiAoIHRoaXMuYmFja2dyb3VuZCApIHtcblxuXHRcdFx0XHRpZiAoIHRoaXMuYmFja2dyb3VuZC5pc0NvbG9yICkge1xuXG5cdFx0XHRcdFx0b2JqZWN0LmJhY2tncm91bmQgPSB0aGlzLmJhY2tncm91bmQudG9KU09OKCk7XG5cblx0XHRcdFx0fSBlbHNlIGlmICggdGhpcy5iYWNrZ3JvdW5kLmlzVGV4dHVyZSApIHtcblxuXHRcdFx0XHRcdG9iamVjdC5iYWNrZ3JvdW5kID0gdGhpcy5iYWNrZ3JvdW5kLnRvSlNPTiggbWV0YSApLnV1aWQ7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggdGhpcy5lbnZpcm9ubWVudCAmJiB0aGlzLmVudmlyb25tZW50LmlzVGV4dHVyZSAmJiB0aGlzLmVudmlyb25tZW50LmlzUmVuZGVyVGFyZ2V0VGV4dHVyZSAhPT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRvYmplY3QuZW52aXJvbm1lbnQgPSB0aGlzLmVudmlyb25tZW50LnRvSlNPTiggbWV0YSApLnV1aWQ7XG5cblx0XHRcdH1cblxuXHRcdH0gZWxzZSBpZiAoIHRoaXMuaXNNZXNoIHx8IHRoaXMuaXNMaW5lIHx8IHRoaXMuaXNQb2ludHMgKSB7XG5cblx0XHRcdG9iamVjdC5nZW9tZXRyeSA9IHNlcmlhbGl6ZSggbWV0YS5nZW9tZXRyaWVzLCB0aGlzLmdlb21ldHJ5ICk7XG5cblx0XHRcdGNvbnN0IHBhcmFtZXRlcnMgPSB0aGlzLmdlb21ldHJ5LnBhcmFtZXRlcnM7XG5cblx0XHRcdGlmICggcGFyYW1ldGVycyAhPT0gdW5kZWZpbmVkICYmIHBhcmFtZXRlcnMuc2hhcGVzICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0Y29uc3Qgc2hhcGVzID0gcGFyYW1ldGVycy5zaGFwZXM7XG5cblx0XHRcdFx0aWYgKCBBcnJheS5pc0FycmF5KCBzaGFwZXMgKSApIHtcblxuXHRcdFx0XHRcdGZvciAoIGxldCBpID0gMCwgbCA9IHNoYXBlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0XHRjb25zdCBzaGFwZSA9IHNoYXBlc1sgaSBdO1xuXG5cdFx0XHRcdFx0XHRzZXJpYWxpemUoIG1ldGEuc2hhcGVzLCBzaGFwZSApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRzZXJpYWxpemUoIG1ldGEuc2hhcGVzLCBzaGFwZXMgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGlmICggdGhpcy5pc1NraW5uZWRNZXNoICkge1xuXG5cdFx0XHRvYmplY3QuYmluZE1vZGUgPSB0aGlzLmJpbmRNb2RlO1xuXHRcdFx0b2JqZWN0LmJpbmRNYXRyaXggPSB0aGlzLmJpbmRNYXRyaXgudG9BcnJheSgpO1xuXG5cdFx0XHRpZiAoIHRoaXMuc2tlbGV0b24gIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRzZXJpYWxpemUoIG1ldGEuc2tlbGV0b25zLCB0aGlzLnNrZWxldG9uICk7XG5cblx0XHRcdFx0b2JqZWN0LnNrZWxldG9uID0gdGhpcy5za2VsZXRvbi51dWlkO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRpZiAoIHRoaXMubWF0ZXJpYWwgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0aWYgKCBBcnJheS5pc0FycmF5KCB0aGlzLm1hdGVyaWFsICkgKSB7XG5cblx0XHRcdFx0Y29uc3QgdXVpZHMgPSBbXTtcblxuXHRcdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSB0aGlzLm1hdGVyaWFsLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHR1dWlkcy5wdXNoKCBzZXJpYWxpemUoIG1ldGEubWF0ZXJpYWxzLCB0aGlzLm1hdGVyaWFsWyBpIF0gKSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRvYmplY3QubWF0ZXJpYWwgPSB1dWlkcztcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRvYmplY3QubWF0ZXJpYWwgPSBzZXJpYWxpemUoIG1ldGEubWF0ZXJpYWxzLCB0aGlzLm1hdGVyaWFsICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdC8vXG5cblx0XHRpZiAoIHRoaXMuY2hpbGRyZW4ubGVuZ3RoID4gMCApIHtcblxuXHRcdFx0b2JqZWN0LmNoaWxkcmVuID0gW107XG5cblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdG9iamVjdC5jaGlsZHJlbi5wdXNoKCB0aGlzLmNoaWxkcmVuWyBpIF0udG9KU09OKCBtZXRhICkub2JqZWN0ICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdC8vXG5cblx0XHRpZiAoIHRoaXMuYW5pbWF0aW9ucy5sZW5ndGggPiAwICkge1xuXG5cdFx0XHRvYmplY3QuYW5pbWF0aW9ucyA9IFtdO1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCB0aGlzLmFuaW1hdGlvbnMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdGNvbnN0IGFuaW1hdGlvbiA9IHRoaXMuYW5pbWF0aW9uc1sgaSBdO1xuXG5cdFx0XHRcdG9iamVjdC5hbmltYXRpb25zLnB1c2goIHNlcmlhbGl6ZSggbWV0YS5hbmltYXRpb25zLCBhbmltYXRpb24gKSApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRpZiAoIGlzUm9vdE9iamVjdCApIHtcblxuXHRcdFx0Y29uc3QgZ2VvbWV0cmllcyA9IGV4dHJhY3RGcm9tQ2FjaGUoIG1ldGEuZ2VvbWV0cmllcyApO1xuXHRcdFx0Y29uc3QgbWF0ZXJpYWxzID0gZXh0cmFjdEZyb21DYWNoZSggbWV0YS5tYXRlcmlhbHMgKTtcblx0XHRcdGNvbnN0IHRleHR1cmVzID0gZXh0cmFjdEZyb21DYWNoZSggbWV0YS50ZXh0dXJlcyApO1xuXHRcdFx0Y29uc3QgaW1hZ2VzID0gZXh0cmFjdEZyb21DYWNoZSggbWV0YS5pbWFnZXMgKTtcblx0XHRcdGNvbnN0IHNoYXBlcyA9IGV4dHJhY3RGcm9tQ2FjaGUoIG1ldGEuc2hhcGVzICk7XG5cdFx0XHRjb25zdCBza2VsZXRvbnMgPSBleHRyYWN0RnJvbUNhY2hlKCBtZXRhLnNrZWxldG9ucyApO1xuXHRcdFx0Y29uc3QgYW5pbWF0aW9ucyA9IGV4dHJhY3RGcm9tQ2FjaGUoIG1ldGEuYW5pbWF0aW9ucyApO1xuXHRcdFx0Y29uc3Qgbm9kZXMgPSBleHRyYWN0RnJvbUNhY2hlKCBtZXRhLm5vZGVzICk7XG5cblx0XHRcdGlmICggZ2VvbWV0cmllcy5sZW5ndGggPiAwICkgb3V0cHV0Lmdlb21ldHJpZXMgPSBnZW9tZXRyaWVzO1xuXHRcdFx0aWYgKCBtYXRlcmlhbHMubGVuZ3RoID4gMCApIG91dHB1dC5tYXRlcmlhbHMgPSBtYXRlcmlhbHM7XG5cdFx0XHRpZiAoIHRleHR1cmVzLmxlbmd0aCA+IDAgKSBvdXRwdXQudGV4dHVyZXMgPSB0ZXh0dXJlcztcblx0XHRcdGlmICggaW1hZ2VzLmxlbmd0aCA+IDAgKSBvdXRwdXQuaW1hZ2VzID0gaW1hZ2VzO1xuXHRcdFx0aWYgKCBzaGFwZXMubGVuZ3RoID4gMCApIG91dHB1dC5zaGFwZXMgPSBzaGFwZXM7XG5cdFx0XHRpZiAoIHNrZWxldG9ucy5sZW5ndGggPiAwICkgb3V0cHV0LnNrZWxldG9ucyA9IHNrZWxldG9ucztcblx0XHRcdGlmICggYW5pbWF0aW9ucy5sZW5ndGggPiAwICkgb3V0cHV0LmFuaW1hdGlvbnMgPSBhbmltYXRpb25zO1xuXHRcdFx0aWYgKCBub2Rlcy5sZW5ndGggPiAwICkgb3V0cHV0Lm5vZGVzID0gbm9kZXM7XG5cblx0XHR9XG5cblx0XHRvdXRwdXQub2JqZWN0ID0gb2JqZWN0O1xuXG5cdFx0cmV0dXJuIG91dHB1dDtcblxuXHRcdC8vIGV4dHJhY3QgZGF0YSBmcm9tIHRoZSBjYWNoZSBoYXNoXG5cdFx0Ly8gcmVtb3ZlIG1ldGFkYXRhIG9uIGVhY2ggaXRlbVxuXHRcdC8vIGFuZCByZXR1cm4gYXMgYXJyYXlcblx0XHRmdW5jdGlvbiBleHRyYWN0RnJvbUNhY2hlKCBjYWNoZSApIHtcblxuXHRcdFx0Y29uc3QgdmFsdWVzID0gW107XG5cdFx0XHRmb3IgKCBjb25zdCBrZXkgaW4gY2FjaGUgKSB7XG5cblx0XHRcdFx0Y29uc3QgZGF0YSA9IGNhY2hlWyBrZXkgXTtcblx0XHRcdFx0ZGVsZXRlIGRhdGEubWV0YWRhdGE7XG5cdFx0XHRcdHZhbHVlcy5wdXNoKCBkYXRhICk7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHZhbHVlcztcblxuXHRcdH1cblxuXHR9XG5cblx0Y2xvbmUoIHJlY3Vyc2l2ZSApIHtcblxuXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMsIHJlY3Vyc2l2ZSApO1xuXG5cdH1cblxuXHRjb3B5KCBzb3VyY2UsIHJlY3Vyc2l2ZSA9IHRydWUgKSB7XG5cblx0XHR0aGlzLm5hbWUgPSBzb3VyY2UubmFtZTtcblxuXHRcdHRoaXMudXAuY29weSggc291cmNlLnVwICk7XG5cblx0XHR0aGlzLnBvc2l0aW9uLmNvcHkoIHNvdXJjZS5wb3NpdGlvbiApO1xuXHRcdHRoaXMucm90YXRpb24ub3JkZXIgPSBzb3VyY2Uucm90YXRpb24ub3JkZXI7XG5cdFx0dGhpcy5xdWF0ZXJuaW9uLmNvcHkoIHNvdXJjZS5xdWF0ZXJuaW9uICk7XG5cdFx0dGhpcy5zY2FsZS5jb3B5KCBzb3VyY2Uuc2NhbGUgKTtcblxuXHRcdHRoaXMubWF0cml4LmNvcHkoIHNvdXJjZS5tYXRyaXggKTtcblx0XHR0aGlzLm1hdHJpeFdvcmxkLmNvcHkoIHNvdXJjZS5tYXRyaXhXb3JsZCApO1xuXG5cdFx0dGhpcy5tYXRyaXhBdXRvVXBkYXRlID0gc291cmNlLm1hdHJpeEF1dG9VcGRhdGU7XG5cdFx0dGhpcy5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlID0gc291cmNlLm1hdHJpeFdvcmxkTmVlZHNVcGRhdGU7XG5cblx0XHR0aGlzLm1hdHJpeFdvcmxkQXV0b1VwZGF0ZSA9IHNvdXJjZS5tYXRyaXhXb3JsZEF1dG9VcGRhdGU7XG5cblx0XHR0aGlzLmxheWVycy5tYXNrID0gc291cmNlLmxheWVycy5tYXNrO1xuXHRcdHRoaXMudmlzaWJsZSA9IHNvdXJjZS52aXNpYmxlO1xuXG5cdFx0dGhpcy5jYXN0U2hhZG93ID0gc291cmNlLmNhc3RTaGFkb3c7XG5cdFx0dGhpcy5yZWNlaXZlU2hhZG93ID0gc291cmNlLnJlY2VpdmVTaGFkb3c7XG5cblx0XHR0aGlzLmZydXN0dW1DdWxsZWQgPSBzb3VyY2UuZnJ1c3R1bUN1bGxlZDtcblx0XHR0aGlzLnJlbmRlck9yZGVyID0gc291cmNlLnJlbmRlck9yZGVyO1xuXG5cdFx0dGhpcy5hbmltYXRpb25zID0gc291cmNlLmFuaW1hdGlvbnMuc2xpY2UoKTtcblxuXHRcdHRoaXMudXNlckRhdGEgPSBKU09OLnBhcnNlKCBKU09OLnN0cmluZ2lmeSggc291cmNlLnVzZXJEYXRhICkgKTtcblxuXHRcdGlmICggcmVjdXJzaXZlID09PSB0cnVlICkge1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBzb3VyY2UuY2hpbGRyZW4ubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdGNvbnN0IGNoaWxkID0gc291cmNlLmNoaWxkcmVuWyBpIF07XG5cdFx0XHRcdHRoaXMuYWRkKCBjaGlsZC5jbG9uZSgpICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxufVxuXG5PYmplY3QzRC5ERUZBVUxUX1VQID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMyggMCwgMSwgMCApO1xuT2JqZWN0M0QuREVGQVVMVF9NQVRSSVhfQVVUT19VUERBVEUgPSB0cnVlO1xuT2JqZWN0M0QuREVGQVVMVF9NQVRSSVhfV09STERfQVVUT19VUERBVEUgPSB0cnVlO1xuXG5leHBvcnQgeyBPYmplY3QzRCB9O1xuIiwiaW1wb3J0IHsgY2xhbXAgfSBmcm9tICcuLi9tYXRoL01hdGhVdGlscy5qcyc7XG5cbi8vIEZhc3QgSGFsZiBGbG9hdCBDb252ZXJzaW9ucywgaHR0cDovL3d3dy5mb3gtdG9vbGtpdC5vcmcvZnRwL2Zhc3RoYWxmZmxvYXRjb252ZXJzaW9uLnBkZlxuXG5jb25zdCBfdGFibGVzID0gLypAX19QVVJFX18qLyBfZ2VuZXJhdGVUYWJsZXMoKTtcblxuZnVuY3Rpb24gX2dlbmVyYXRlVGFibGVzKCkge1xuXG5cdC8vIGZsb2F0MzIgdG8gZmxvYXQxNiBoZWxwZXJzXG5cblx0Y29uc3QgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKCA0ICk7XG5cdGNvbnN0IGZsb2F0VmlldyA9IG5ldyBGbG9hdDMyQXJyYXkoIGJ1ZmZlciApO1xuXHRjb25zdCB1aW50MzJWaWV3ID0gbmV3IFVpbnQzMkFycmF5KCBidWZmZXIgKTtcblxuXHRjb25zdCBiYXNlVGFibGUgPSBuZXcgVWludDMyQXJyYXkoIDUxMiApO1xuXHRjb25zdCBzaGlmdFRhYmxlID0gbmV3IFVpbnQzMkFycmF5KCA1MTIgKTtcblxuXHRmb3IgKCBsZXQgaSA9IDA7IGkgPCAyNTY7ICsrIGkgKSB7XG5cblx0XHRjb25zdCBlID0gaSAtIDEyNztcblxuXHRcdC8vIHZlcnkgc21hbGwgbnVtYmVyICgwLCAtMClcblxuXHRcdGlmICggZSA8IC0gMjcgKSB7XG5cblx0XHRcdGJhc2VUYWJsZVsgaSBdID0gMHgwMDAwO1xuXHRcdFx0YmFzZVRhYmxlWyBpIHwgMHgxMDAgXSA9IDB4ODAwMDtcblx0XHRcdHNoaWZ0VGFibGVbIGkgXSA9IDI0O1xuXHRcdFx0c2hpZnRUYWJsZVsgaSB8IDB4MTAwIF0gPSAyNDtcblxuXHRcdFx0Ly8gc21hbGwgbnVtYmVyIChkZW5vcm0pXG5cblx0XHR9IGVsc2UgaWYgKCBlIDwgLSAxNCApIHtcblxuXHRcdFx0YmFzZVRhYmxlWyBpIF0gPSAweDA0MDAgPj4gKCAtIGUgLSAxNCApO1xuXHRcdFx0YmFzZVRhYmxlWyBpIHwgMHgxMDAgXSA9ICggMHgwNDAwID4+ICggLSBlIC0gMTQgKSApIHwgMHg4MDAwO1xuXHRcdFx0c2hpZnRUYWJsZVsgaSBdID0gLSBlIC0gMTtcblx0XHRcdHNoaWZ0VGFibGVbIGkgfCAweDEwMCBdID0gLSBlIC0gMTtcblxuXHRcdFx0Ly8gbm9ybWFsIG51bWJlclxuXG5cdFx0fSBlbHNlIGlmICggZSA8PSAxNSApIHtcblxuXHRcdFx0YmFzZVRhYmxlWyBpIF0gPSAoIGUgKyAxNSApIDw8IDEwO1xuXHRcdFx0YmFzZVRhYmxlWyBpIHwgMHgxMDAgXSA9ICggKCBlICsgMTUgKSA8PCAxMCApIHwgMHg4MDAwO1xuXHRcdFx0c2hpZnRUYWJsZVsgaSBdID0gMTM7XG5cdFx0XHRzaGlmdFRhYmxlWyBpIHwgMHgxMDAgXSA9IDEzO1xuXG5cdFx0XHQvLyBsYXJnZSBudW1iZXIgKEluZmluaXR5LCAtSW5maW5pdHkpXG5cblx0XHR9IGVsc2UgaWYgKCBlIDwgMTI4ICkge1xuXG5cdFx0XHRiYXNlVGFibGVbIGkgXSA9IDB4N2MwMDtcblx0XHRcdGJhc2VUYWJsZVsgaSB8IDB4MTAwIF0gPSAweGZjMDA7XG5cdFx0XHRzaGlmdFRhYmxlWyBpIF0gPSAyNDtcblx0XHRcdHNoaWZ0VGFibGVbIGkgfCAweDEwMCBdID0gMjQ7XG5cblx0XHRcdC8vIHN0YXkgKE5hTiwgSW5maW5pdHksIC1JbmZpbml0eSlcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGJhc2VUYWJsZVsgaSBdID0gMHg3YzAwO1xuXHRcdFx0YmFzZVRhYmxlWyBpIHwgMHgxMDAgXSA9IDB4ZmMwMDtcblx0XHRcdHNoaWZ0VGFibGVbIGkgXSA9IDEzO1xuXHRcdFx0c2hpZnRUYWJsZVsgaSB8IDB4MTAwIF0gPSAxMztcblxuXHRcdH1cblxuXHR9XG5cblx0Ly8gZmxvYXQxNiB0byBmbG9hdDMyIGhlbHBlcnNcblxuXHRjb25zdCBtYW50aXNzYVRhYmxlID0gbmV3IFVpbnQzMkFycmF5KCAyMDQ4ICk7XG5cdGNvbnN0IGV4cG9uZW50VGFibGUgPSBuZXcgVWludDMyQXJyYXkoIDY0ICk7XG5cdGNvbnN0IG9mZnNldFRhYmxlID0gbmV3IFVpbnQzMkFycmF5KCA2NCApO1xuXG5cdGZvciAoIGxldCBpID0gMTsgaSA8IDEwMjQ7ICsrIGkgKSB7XG5cblx0XHRsZXQgbSA9IGkgPDwgMTM7IC8vIHplcm8gcGFkIG1hbnRpc3NhIGJpdHNcblx0XHRsZXQgZSA9IDA7IC8vIHplcm8gZXhwb25lbnRcblxuXHRcdC8vIG5vcm1hbGl6ZWRcblx0XHR3aGlsZSAoICggbSAmIDB4MDA4MDAwMDAgKSA9PT0gMCApIHtcblxuXHRcdFx0bSA8PD0gMTtcblx0XHRcdGUgLT0gMHgwMDgwMDAwMDsgLy8gZGVjcmVtZW50IGV4cG9uZW50XG5cblx0XHR9XG5cblx0XHRtICY9IH4gMHgwMDgwMDAwMDsgLy8gY2xlYXIgbGVhZGluZyAxIGJpdFxuXHRcdGUgKz0gMHgzODgwMDAwMDsgLy8gYWRqdXN0IGJpYXNcblxuXHRcdG1hbnRpc3NhVGFibGVbIGkgXSA9IG0gfCBlO1xuXG5cdH1cblxuXHRmb3IgKCBsZXQgaSA9IDEwMjQ7IGkgPCAyMDQ4OyArKyBpICkge1xuXG5cdFx0bWFudGlzc2FUYWJsZVsgaSBdID0gMHgzODAwMDAwMCArICggKCBpIC0gMTAyNCApIDw8IDEzICk7XG5cblx0fVxuXG5cdGZvciAoIGxldCBpID0gMTsgaSA8IDMxOyArKyBpICkge1xuXG5cdFx0ZXhwb25lbnRUYWJsZVsgaSBdID0gaSA8PCAyMztcblxuXHR9XG5cblx0ZXhwb25lbnRUYWJsZVsgMzEgXSA9IDB4NDc4MDAwMDA7XG5cdGV4cG9uZW50VGFibGVbIDMyIF0gPSAweDgwMDAwMDAwO1xuXG5cdGZvciAoIGxldCBpID0gMzM7IGkgPCA2MzsgKysgaSApIHtcblxuXHRcdGV4cG9uZW50VGFibGVbIGkgXSA9IDB4ODAwMDAwMDAgKyAoICggaSAtIDMyICkgPDwgMjMgKTtcblxuXHR9XG5cblx0ZXhwb25lbnRUYWJsZVsgNjMgXSA9IDB4Yzc4MDAwMDA7XG5cblx0Zm9yICggbGV0IGkgPSAxOyBpIDwgNjQ7ICsrIGkgKSB7XG5cblx0XHRpZiAoIGkgIT09IDMyICkge1xuXG5cdFx0XHRvZmZzZXRUYWJsZVsgaSBdID0gMTAyNDtcblxuXHRcdH1cblxuXHR9XG5cblx0cmV0dXJuIHtcblx0XHRmbG9hdFZpZXc6IGZsb2F0Vmlldyxcblx0XHR1aW50MzJWaWV3OiB1aW50MzJWaWV3LFxuXHRcdGJhc2VUYWJsZTogYmFzZVRhYmxlLFxuXHRcdHNoaWZ0VGFibGU6IHNoaWZ0VGFibGUsXG5cdFx0bWFudGlzc2FUYWJsZTogbWFudGlzc2FUYWJsZSxcblx0XHRleHBvbmVudFRhYmxlOiBleHBvbmVudFRhYmxlLFxuXHRcdG9mZnNldFRhYmxlOiBvZmZzZXRUYWJsZVxuXHR9O1xuXG59XG5cbi8vIGZsb2F0MzIgdG8gZmxvYXQxNlxuXG5mdW5jdGlvbiB0b0hhbGZGbG9hdCggdmFsICkge1xuXG5cdGlmICggTWF0aC5hYnMoIHZhbCApID4gNjU1MDQgKSBjb25zb2xlLndhcm4oICdUSFJFRS5EYXRhVXRpbHMudG9IYWxmRmxvYXQoKTogVmFsdWUgb3V0IG9mIHJhbmdlLicgKTtcblxuXHR2YWwgPSBjbGFtcCggdmFsLCAtIDY1NTA0LCA2NTUwNCApO1xuXG5cdF90YWJsZXMuZmxvYXRWaWV3WyAwIF0gPSB2YWw7XG5cdGNvbnN0IGYgPSBfdGFibGVzLnVpbnQzMlZpZXdbIDAgXTtcblx0Y29uc3QgZSA9ICggZiA+PiAyMyApICYgMHgxZmY7XG5cdHJldHVybiBfdGFibGVzLmJhc2VUYWJsZVsgZSBdICsgKCAoIGYgJiAweDAwN2ZmZmZmICkgPj4gX3RhYmxlcy5zaGlmdFRhYmxlWyBlIF0gKTtcblxufVxuXG4vLyBmbG9hdDE2IHRvIGZsb2F0MzJcblxuZnVuY3Rpb24gZnJvbUhhbGZGbG9hdCggdmFsICkge1xuXG5cdGNvbnN0IG0gPSB2YWwgPj4gMTA7XG5cdF90YWJsZXMudWludDMyVmlld1sgMCBdID0gX3RhYmxlcy5tYW50aXNzYVRhYmxlWyBfdGFibGVzLm9mZnNldFRhYmxlWyBtIF0gKyAoIHZhbCAmIDB4M2ZmICkgXSArIF90YWJsZXMuZXhwb25lbnRUYWJsZVsgbSBdO1xuXHRyZXR1cm4gX3RhYmxlcy5mbG9hdFZpZXdbIDAgXTtcblxufVxuXG5jb25zdCBEYXRhVXRpbHMgPSB7XG5cdHRvSGFsZkZsb2F0OiB0b0hhbGZGbG9hdCxcblx0ZnJvbUhhbGZGbG9hdDogZnJvbUhhbGZGbG9hdCxcbn07XG5cbmV4cG9ydCB7XG5cdHRvSGFsZkZsb2F0LFxuXHRmcm9tSGFsZkZsb2F0LFxuXHREYXRhVXRpbHNcbn07XG4iLCIvKipcbiAqIFBvcnQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vbWFwYm94L2VhcmN1dCAodjIuMi40KVxuICovXG5cbmNvbnN0IEVhcmN1dCA9IHtcblxuXHR0cmlhbmd1bGF0ZTogZnVuY3Rpb24gKCBkYXRhLCBob2xlSW5kaWNlcywgZGltID0gMiApIHtcblxuXHRcdGNvbnN0IGhhc0hvbGVzID0gaG9sZUluZGljZXMgJiYgaG9sZUluZGljZXMubGVuZ3RoO1xuXHRcdGNvbnN0IG91dGVyTGVuID0gaGFzSG9sZXMgPyBob2xlSW5kaWNlc1sgMCBdICogZGltIDogZGF0YS5sZW5ndGg7XG5cdFx0bGV0IG91dGVyTm9kZSA9IGxpbmtlZExpc3QoIGRhdGEsIDAsIG91dGVyTGVuLCBkaW0sIHRydWUgKTtcblx0XHRjb25zdCB0cmlhbmdsZXMgPSBbXTtcblxuXHRcdGlmICggISBvdXRlck5vZGUgfHwgb3V0ZXJOb2RlLm5leHQgPT09IG91dGVyTm9kZS5wcmV2ICkgcmV0dXJuIHRyaWFuZ2xlcztcblxuXHRcdGxldCBtaW5YLCBtaW5ZLCBtYXhYLCBtYXhZLCB4LCB5LCBpbnZTaXplO1xuXG5cdFx0aWYgKCBoYXNIb2xlcyApIG91dGVyTm9kZSA9IGVsaW1pbmF0ZUhvbGVzKCBkYXRhLCBob2xlSW5kaWNlcywgb3V0ZXJOb2RlLCBkaW0gKTtcblxuXHRcdC8vIGlmIHRoZSBzaGFwZSBpcyBub3QgdG9vIHNpbXBsZSwgd2UnbGwgdXNlIHotb3JkZXIgY3VydmUgaGFzaCBsYXRlcjsgY2FsY3VsYXRlIHBvbHlnb24gYmJveFxuXHRcdGlmICggZGF0YS5sZW5ndGggPiA4MCAqIGRpbSApIHtcblxuXHRcdFx0bWluWCA9IG1heFggPSBkYXRhWyAwIF07XG5cdFx0XHRtaW5ZID0gbWF4WSA9IGRhdGFbIDEgXTtcblxuXHRcdFx0Zm9yICggbGV0IGkgPSBkaW07IGkgPCBvdXRlckxlbjsgaSArPSBkaW0gKSB7XG5cblx0XHRcdFx0eCA9IGRhdGFbIGkgXTtcblx0XHRcdFx0eSA9IGRhdGFbIGkgKyAxIF07XG5cdFx0XHRcdGlmICggeCA8IG1pblggKSBtaW5YID0geDtcblx0XHRcdFx0aWYgKCB5IDwgbWluWSApIG1pblkgPSB5O1xuXHRcdFx0XHRpZiAoIHggPiBtYXhYICkgbWF4WCA9IHg7XG5cdFx0XHRcdGlmICggeSA+IG1heFkgKSBtYXhZID0geTtcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBtaW5YLCBtaW5ZIGFuZCBpbnZTaXplIGFyZSBsYXRlciB1c2VkIHRvIHRyYW5zZm9ybSBjb29yZHMgaW50byBpbnRlZ2VycyBmb3Igei1vcmRlciBjYWxjdWxhdGlvblxuXHRcdFx0aW52U2l6ZSA9IE1hdGgubWF4KCBtYXhYIC0gbWluWCwgbWF4WSAtIG1pblkgKTtcblx0XHRcdGludlNpemUgPSBpbnZTaXplICE9PSAwID8gMzI3NjcgLyBpbnZTaXplIDogMDtcblxuXHRcdH1cblxuXHRcdGVhcmN1dExpbmtlZCggb3V0ZXJOb2RlLCB0cmlhbmdsZXMsIGRpbSwgbWluWCwgbWluWSwgaW52U2l6ZSwgMCApO1xuXG5cdFx0cmV0dXJuIHRyaWFuZ2xlcztcblxuXHR9XG5cbn07XG5cbi8vIGNyZWF0ZSBhIGNpcmN1bGFyIGRvdWJseSBsaW5rZWQgbGlzdCBmcm9tIHBvbHlnb24gcG9pbnRzIGluIHRoZSBzcGVjaWZpZWQgd2luZGluZyBvcmRlclxuZnVuY3Rpb24gbGlua2VkTGlzdCggZGF0YSwgc3RhcnQsIGVuZCwgZGltLCBjbG9ja3dpc2UgKSB7XG5cblx0bGV0IGksIGxhc3Q7XG5cblx0aWYgKCBjbG9ja3dpc2UgPT09ICggc2lnbmVkQXJlYSggZGF0YSwgc3RhcnQsIGVuZCwgZGltICkgPiAwICkgKSB7XG5cblx0XHRmb3IgKCBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkgKz0gZGltICkgbGFzdCA9IGluc2VydE5vZGUoIGksIGRhdGFbIGkgXSwgZGF0YVsgaSArIDEgXSwgbGFzdCApO1xuXG5cdH0gZWxzZSB7XG5cblx0XHRmb3IgKCBpID0gZW5kIC0gZGltOyBpID49IHN0YXJ0OyBpIC09IGRpbSApIGxhc3QgPSBpbnNlcnROb2RlKCBpLCBkYXRhWyBpIF0sIGRhdGFbIGkgKyAxIF0sIGxhc3QgKTtcblxuXHR9XG5cblx0aWYgKCBsYXN0ICYmIGVxdWFscyggbGFzdCwgbGFzdC5uZXh0ICkgKSB7XG5cblx0XHRyZW1vdmVOb2RlKCBsYXN0ICk7XG5cdFx0bGFzdCA9IGxhc3QubmV4dDtcblxuXHR9XG5cblx0cmV0dXJuIGxhc3Q7XG5cbn1cblxuLy8gZWxpbWluYXRlIGNvbGluZWFyIG9yIGR1cGxpY2F0ZSBwb2ludHNcbmZ1bmN0aW9uIGZpbHRlclBvaW50cyggc3RhcnQsIGVuZCApIHtcblxuXHRpZiAoICEgc3RhcnQgKSByZXR1cm4gc3RhcnQ7XG5cdGlmICggISBlbmQgKSBlbmQgPSBzdGFydDtcblxuXHRsZXQgcCA9IHN0YXJ0LFxuXHRcdGFnYWluO1xuXHRkbyB7XG5cblx0XHRhZ2FpbiA9IGZhbHNlO1xuXG5cdFx0aWYgKCAhIHAuc3RlaW5lciAmJiAoIGVxdWFscyggcCwgcC5uZXh0ICkgfHwgYXJlYSggcC5wcmV2LCBwLCBwLm5leHQgKSA9PT0gMCApICkge1xuXG5cdFx0XHRyZW1vdmVOb2RlKCBwICk7XG5cdFx0XHRwID0gZW5kID0gcC5wcmV2O1xuXHRcdFx0aWYgKCBwID09PSBwLm5leHQgKSBicmVhaztcblx0XHRcdGFnYWluID0gdHJ1ZTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHAgPSBwLm5leHQ7XG5cblx0XHR9XG5cblx0fSB3aGlsZSAoIGFnYWluIHx8IHAgIT09IGVuZCApO1xuXG5cdHJldHVybiBlbmQ7XG5cbn1cblxuLy8gbWFpbiBlYXIgc2xpY2luZyBsb29wIHdoaWNoIHRyaWFuZ3VsYXRlcyBhIHBvbHlnb24gKGdpdmVuIGFzIGEgbGlua2VkIGxpc3QpXG5mdW5jdGlvbiBlYXJjdXRMaW5rZWQoIGVhciwgdHJpYW5nbGVzLCBkaW0sIG1pblgsIG1pblksIGludlNpemUsIHBhc3MgKSB7XG5cblx0aWYgKCAhIGVhciApIHJldHVybjtcblxuXHQvLyBpbnRlcmxpbmsgcG9seWdvbiBub2RlcyBpbiB6LW9yZGVyXG5cdGlmICggISBwYXNzICYmIGludlNpemUgKSBpbmRleEN1cnZlKCBlYXIsIG1pblgsIG1pblksIGludlNpemUgKTtcblxuXHRsZXQgc3RvcCA9IGVhcixcblx0XHRwcmV2LCBuZXh0O1xuXG5cdC8vIGl0ZXJhdGUgdGhyb3VnaCBlYXJzLCBzbGljaW5nIHRoZW0gb25lIGJ5IG9uZVxuXHR3aGlsZSAoIGVhci5wcmV2ICE9PSBlYXIubmV4dCApIHtcblxuXHRcdHByZXYgPSBlYXIucHJldjtcblx0XHRuZXh0ID0gZWFyLm5leHQ7XG5cblx0XHRpZiAoIGludlNpemUgPyBpc0Vhckhhc2hlZCggZWFyLCBtaW5YLCBtaW5ZLCBpbnZTaXplICkgOiBpc0VhciggZWFyICkgKSB7XG5cblx0XHRcdC8vIGN1dCBvZmYgdGhlIHRyaWFuZ2xlXG5cdFx0XHR0cmlhbmdsZXMucHVzaCggcHJldi5pIC8gZGltIHwgMCApO1xuXHRcdFx0dHJpYW5nbGVzLnB1c2goIGVhci5pIC8gZGltIHwgMCApO1xuXHRcdFx0dHJpYW5nbGVzLnB1c2goIG5leHQuaSAvIGRpbSB8IDAgKTtcblxuXHRcdFx0cmVtb3ZlTm9kZSggZWFyICk7XG5cblx0XHRcdC8vIHNraXBwaW5nIHRoZSBuZXh0IHZlcnRleCBsZWFkcyB0byBsZXNzIHNsaXZlciB0cmlhbmdsZXNcblx0XHRcdGVhciA9IG5leHQubmV4dDtcblx0XHRcdHN0b3AgPSBuZXh0Lm5leHQ7XG5cblx0XHRcdGNvbnRpbnVlO1xuXG5cdFx0fVxuXG5cdFx0ZWFyID0gbmV4dDtcblxuXHRcdC8vIGlmIHdlIGxvb3BlZCB0aHJvdWdoIHRoZSB3aG9sZSByZW1haW5pbmcgcG9seWdvbiBhbmQgY2FuJ3QgZmluZCBhbnkgbW9yZSBlYXJzXG5cdFx0aWYgKCBlYXIgPT09IHN0b3AgKSB7XG5cblx0XHRcdC8vIHRyeSBmaWx0ZXJpbmcgcG9pbnRzIGFuZCBzbGljaW5nIGFnYWluXG5cdFx0XHRpZiAoICEgcGFzcyApIHtcblxuXHRcdFx0XHRlYXJjdXRMaW5rZWQoIGZpbHRlclBvaW50cyggZWFyICksIHRyaWFuZ2xlcywgZGltLCBtaW5YLCBtaW5ZLCBpbnZTaXplLCAxICk7XG5cblx0XHRcdFx0Ly8gaWYgdGhpcyBkaWRuJ3Qgd29yaywgdHJ5IGN1cmluZyBhbGwgc21hbGwgc2VsZi1pbnRlcnNlY3Rpb25zIGxvY2FsbHlcblxuXHRcdFx0fSBlbHNlIGlmICggcGFzcyA9PT0gMSApIHtcblxuXHRcdFx0XHRlYXIgPSBjdXJlTG9jYWxJbnRlcnNlY3Rpb25zKCBmaWx0ZXJQb2ludHMoIGVhciApLCB0cmlhbmdsZXMsIGRpbSApO1xuXHRcdFx0XHRlYXJjdXRMaW5rZWQoIGVhciwgdHJpYW5nbGVzLCBkaW0sIG1pblgsIG1pblksIGludlNpemUsIDIgKTtcblxuXHRcdFx0XHQvLyBhcyBhIGxhc3QgcmVzb3J0LCB0cnkgc3BsaXR0aW5nIHRoZSByZW1haW5pbmcgcG9seWdvbiBpbnRvIHR3b1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBwYXNzID09PSAyICkge1xuXG5cdFx0XHRcdHNwbGl0RWFyY3V0KCBlYXIsIHRyaWFuZ2xlcywgZGltLCBtaW5YLCBtaW5ZLCBpbnZTaXplICk7XG5cblx0XHRcdH1cblxuXHRcdFx0YnJlYWs7XG5cblx0XHR9XG5cblx0fVxuXG59XG5cbi8vIGNoZWNrIHdoZXRoZXIgYSBwb2x5Z29uIG5vZGUgZm9ybXMgYSB2YWxpZCBlYXIgd2l0aCBhZGphY2VudCBub2Rlc1xuZnVuY3Rpb24gaXNFYXIoIGVhciApIHtcblxuXHRjb25zdCBhID0gZWFyLnByZXYsXG5cdFx0YiA9IGVhcixcblx0XHRjID0gZWFyLm5leHQ7XG5cblx0aWYgKCBhcmVhKCBhLCBiLCBjICkgPj0gMCApIHJldHVybiBmYWxzZTsgLy8gcmVmbGV4LCBjYW4ndCBiZSBhbiBlYXJcblxuXHQvLyBub3cgbWFrZSBzdXJlIHdlIGRvbid0IGhhdmUgb3RoZXIgcG9pbnRzIGluc2lkZSB0aGUgcG90ZW50aWFsIGVhclxuXHRjb25zdCBheCA9IGEueCwgYnggPSBiLngsIGN4ID0gYy54LCBheSA9IGEueSwgYnkgPSBiLnksIGN5ID0gYy55O1xuXG5cdC8vIHRyaWFuZ2xlIGJib3g7IG1pbiAmIG1heCBhcmUgY2FsY3VsYXRlZCBsaWtlIHRoaXMgZm9yIHNwZWVkXG5cdGNvbnN0IHgwID0gYXggPCBieCA/ICggYXggPCBjeCA/IGF4IDogY3ggKSA6ICggYnggPCBjeCA/IGJ4IDogY3ggKSxcblx0XHR5MCA9IGF5IDwgYnkgPyAoIGF5IDwgY3kgPyBheSA6IGN5ICkgOiAoIGJ5IDwgY3kgPyBieSA6IGN5ICksXG5cdFx0eDEgPSBheCA+IGJ4ID8gKCBheCA+IGN4ID8gYXggOiBjeCApIDogKCBieCA+IGN4ID8gYnggOiBjeCApLFxuXHRcdHkxID0gYXkgPiBieSA/ICggYXkgPiBjeSA/IGF5IDogY3kgKSA6ICggYnkgPiBjeSA/IGJ5IDogY3kgKTtcblxuXHRsZXQgcCA9IGMubmV4dDtcblx0d2hpbGUgKCBwICE9PSBhICkge1xuXG5cdFx0aWYgKCBwLnggPj0geDAgJiYgcC54IDw9IHgxICYmIHAueSA+PSB5MCAmJiBwLnkgPD0geTEgJiZcblx0XHRcdHBvaW50SW5UcmlhbmdsZSggYXgsIGF5LCBieCwgYnksIGN4LCBjeSwgcC54LCBwLnkgKSAmJlxuXHRcdFx0YXJlYSggcC5wcmV2LCBwLCBwLm5leHQgKSA+PSAwICkgcmV0dXJuIGZhbHNlO1xuXHRcdHAgPSBwLm5leHQ7XG5cblx0fVxuXG5cdHJldHVybiB0cnVlO1xuXG59XG5cbmZ1bmN0aW9uIGlzRWFySGFzaGVkKCBlYXIsIG1pblgsIG1pblksIGludlNpemUgKSB7XG5cblx0Y29uc3QgYSA9IGVhci5wcmV2LFxuXHRcdGIgPSBlYXIsXG5cdFx0YyA9IGVhci5uZXh0O1xuXG5cdGlmICggYXJlYSggYSwgYiwgYyApID49IDAgKSByZXR1cm4gZmFsc2U7IC8vIHJlZmxleCwgY2FuJ3QgYmUgYW4gZWFyXG5cblx0Y29uc3QgYXggPSBhLngsIGJ4ID0gYi54LCBjeCA9IGMueCwgYXkgPSBhLnksIGJ5ID0gYi55LCBjeSA9IGMueTtcblxuXHQvLyB0cmlhbmdsZSBiYm94OyBtaW4gJiBtYXggYXJlIGNhbGN1bGF0ZWQgbGlrZSB0aGlzIGZvciBzcGVlZFxuXHRjb25zdCB4MCA9IGF4IDwgYnggPyAoIGF4IDwgY3ggPyBheCA6IGN4ICkgOiAoIGJ4IDwgY3ggPyBieCA6IGN4ICksXG5cdFx0eTAgPSBheSA8IGJ5ID8gKCBheSA8IGN5ID8gYXkgOiBjeSApIDogKCBieSA8IGN5ID8gYnkgOiBjeSApLFxuXHRcdHgxID0gYXggPiBieCA/ICggYXggPiBjeCA/IGF4IDogY3ggKSA6ICggYnggPiBjeCA/IGJ4IDogY3ggKSxcblx0XHR5MSA9IGF5ID4gYnkgPyAoIGF5ID4gY3kgPyBheSA6IGN5ICkgOiAoIGJ5ID4gY3kgPyBieSA6IGN5ICk7XG5cblx0Ly8gei1vcmRlciByYW5nZSBmb3IgdGhlIGN1cnJlbnQgdHJpYW5nbGUgYmJveDtcblx0Y29uc3QgbWluWiA9IHpPcmRlciggeDAsIHkwLCBtaW5YLCBtaW5ZLCBpbnZTaXplICksXG5cdFx0bWF4WiA9IHpPcmRlciggeDEsIHkxLCBtaW5YLCBtaW5ZLCBpbnZTaXplICk7XG5cblx0bGV0IHAgPSBlYXIucHJldlosXG5cdFx0biA9IGVhci5uZXh0WjtcblxuXHQvLyBsb29rIGZvciBwb2ludHMgaW5zaWRlIHRoZSB0cmlhbmdsZSBpbiBib3RoIGRpcmVjdGlvbnNcblx0d2hpbGUgKCBwICYmIHAueiA+PSBtaW5aICYmIG4gJiYgbi56IDw9IG1heFogKSB7XG5cblx0XHRpZiAoIHAueCA+PSB4MCAmJiBwLnggPD0geDEgJiYgcC55ID49IHkwICYmIHAueSA8PSB5MSAmJiBwICE9PSBhICYmIHAgIT09IGMgJiZcblx0XHRcdHBvaW50SW5UcmlhbmdsZSggYXgsIGF5LCBieCwgYnksIGN4LCBjeSwgcC54LCBwLnkgKSAmJiBhcmVhKCBwLnByZXYsIHAsIHAubmV4dCApID49IDAgKSByZXR1cm4gZmFsc2U7XG5cdFx0cCA9IHAucHJldlo7XG5cblx0XHRpZiAoIG4ueCA+PSB4MCAmJiBuLnggPD0geDEgJiYgbi55ID49IHkwICYmIG4ueSA8PSB5MSAmJiBuICE9PSBhICYmIG4gIT09IGMgJiZcblx0XHRcdHBvaW50SW5UcmlhbmdsZSggYXgsIGF5LCBieCwgYnksIGN4LCBjeSwgbi54LCBuLnkgKSAmJiBhcmVhKCBuLnByZXYsIG4sIG4ubmV4dCApID49IDAgKSByZXR1cm4gZmFsc2U7XG5cdFx0biA9IG4ubmV4dFo7XG5cblx0fVxuXG5cdC8vIGxvb2sgZm9yIHJlbWFpbmluZyBwb2ludHMgaW4gZGVjcmVhc2luZyB6LW9yZGVyXG5cdHdoaWxlICggcCAmJiBwLnogPj0gbWluWiApIHtcblxuXHRcdGlmICggcC54ID49IHgwICYmIHAueCA8PSB4MSAmJiBwLnkgPj0geTAgJiYgcC55IDw9IHkxICYmIHAgIT09IGEgJiYgcCAhPT0gYyAmJlxuXHRcdFx0cG9pbnRJblRyaWFuZ2xlKCBheCwgYXksIGJ4LCBieSwgY3gsIGN5LCBwLngsIHAueSApICYmIGFyZWEoIHAucHJldiwgcCwgcC5uZXh0ICkgPj0gMCApIHJldHVybiBmYWxzZTtcblx0XHRwID0gcC5wcmV2WjtcblxuXHR9XG5cblx0Ly8gbG9vayBmb3IgcmVtYWluaW5nIHBvaW50cyBpbiBpbmNyZWFzaW5nIHotb3JkZXJcblx0d2hpbGUgKCBuICYmIG4ueiA8PSBtYXhaICkge1xuXG5cdFx0aWYgKCBuLnggPj0geDAgJiYgbi54IDw9IHgxICYmIG4ueSA+PSB5MCAmJiBuLnkgPD0geTEgJiYgbiAhPT0gYSAmJiBuICE9PSBjICYmXG5cdFx0XHRwb2ludEluVHJpYW5nbGUoIGF4LCBheSwgYngsIGJ5LCBjeCwgY3ksIG4ueCwgbi55ICkgJiYgYXJlYSggbi5wcmV2LCBuLCBuLm5leHQgKSA+PSAwICkgcmV0dXJuIGZhbHNlO1xuXHRcdG4gPSBuLm5leHRaO1xuXG5cdH1cblxuXHRyZXR1cm4gdHJ1ZTtcblxufVxuXG4vLyBnbyB0aHJvdWdoIGFsbCBwb2x5Z29uIG5vZGVzIGFuZCBjdXJlIHNtYWxsIGxvY2FsIHNlbGYtaW50ZXJzZWN0aW9uc1xuZnVuY3Rpb24gY3VyZUxvY2FsSW50ZXJzZWN0aW9ucyggc3RhcnQsIHRyaWFuZ2xlcywgZGltICkge1xuXG5cdGxldCBwID0gc3RhcnQ7XG5cdGRvIHtcblxuXHRcdGNvbnN0IGEgPSBwLnByZXYsXG5cdFx0XHRiID0gcC5uZXh0Lm5leHQ7XG5cblx0XHRpZiAoICEgZXF1YWxzKCBhLCBiICkgJiYgaW50ZXJzZWN0cyggYSwgcCwgcC5uZXh0LCBiICkgJiYgbG9jYWxseUluc2lkZSggYSwgYiApICYmIGxvY2FsbHlJbnNpZGUoIGIsIGEgKSApIHtcblxuXHRcdFx0dHJpYW5nbGVzLnB1c2goIGEuaSAvIGRpbSB8IDAgKTtcblx0XHRcdHRyaWFuZ2xlcy5wdXNoKCBwLmkgLyBkaW0gfCAwICk7XG5cdFx0XHR0cmlhbmdsZXMucHVzaCggYi5pIC8gZGltIHwgMCApO1xuXG5cdFx0XHQvLyByZW1vdmUgdHdvIG5vZGVzIGludm9sdmVkXG5cdFx0XHRyZW1vdmVOb2RlKCBwICk7XG5cdFx0XHRyZW1vdmVOb2RlKCBwLm5leHQgKTtcblxuXHRcdFx0cCA9IHN0YXJ0ID0gYjtcblxuXHRcdH1cblxuXHRcdHAgPSBwLm5leHQ7XG5cblx0fSB3aGlsZSAoIHAgIT09IHN0YXJ0ICk7XG5cblx0cmV0dXJuIGZpbHRlclBvaW50cyggcCApO1xuXG59XG5cbi8vIHRyeSBzcGxpdHRpbmcgcG9seWdvbiBpbnRvIHR3byBhbmQgdHJpYW5ndWxhdGUgdGhlbSBpbmRlcGVuZGVudGx5XG5mdW5jdGlvbiBzcGxpdEVhcmN1dCggc3RhcnQsIHRyaWFuZ2xlcywgZGltLCBtaW5YLCBtaW5ZLCBpbnZTaXplICkge1xuXG5cdC8vIGxvb2sgZm9yIGEgdmFsaWQgZGlhZ29uYWwgdGhhdCBkaXZpZGVzIHRoZSBwb2x5Z29uIGludG8gdHdvXG5cdGxldCBhID0gc3RhcnQ7XG5cdGRvIHtcblxuXHRcdGxldCBiID0gYS5uZXh0Lm5leHQ7XG5cdFx0d2hpbGUgKCBiICE9PSBhLnByZXYgKSB7XG5cblx0XHRcdGlmICggYS5pICE9PSBiLmkgJiYgaXNWYWxpZERpYWdvbmFsKCBhLCBiICkgKSB7XG5cblx0XHRcdFx0Ly8gc3BsaXQgdGhlIHBvbHlnb24gaW4gdHdvIGJ5IHRoZSBkaWFnb25hbFxuXHRcdFx0XHRsZXQgYyA9IHNwbGl0UG9seWdvbiggYSwgYiApO1xuXG5cdFx0XHRcdC8vIGZpbHRlciBjb2xpbmVhciBwb2ludHMgYXJvdW5kIHRoZSBjdXRzXG5cdFx0XHRcdGEgPSBmaWx0ZXJQb2ludHMoIGEsIGEubmV4dCApO1xuXHRcdFx0XHRjID0gZmlsdGVyUG9pbnRzKCBjLCBjLm5leHQgKTtcblxuXHRcdFx0XHQvLyBydW4gZWFyY3V0IG9uIGVhY2ggaGFsZlxuXHRcdFx0XHRlYXJjdXRMaW5rZWQoIGEsIHRyaWFuZ2xlcywgZGltLCBtaW5YLCBtaW5ZLCBpbnZTaXplLCAwICk7XG5cdFx0XHRcdGVhcmN1dExpbmtlZCggYywgdHJpYW5nbGVzLCBkaW0sIG1pblgsIG1pblksIGludlNpemUsIDAgKTtcblx0XHRcdFx0cmV0dXJuO1xuXG5cdFx0XHR9XG5cblx0XHRcdGIgPSBiLm5leHQ7XG5cblx0XHR9XG5cblx0XHRhID0gYS5uZXh0O1xuXG5cdH0gd2hpbGUgKCBhICE9PSBzdGFydCApO1xuXG59XG5cbi8vIGxpbmsgZXZlcnkgaG9sZSBpbnRvIHRoZSBvdXRlciBsb29wLCBwcm9kdWNpbmcgYSBzaW5nbGUtcmluZyBwb2x5Z29uIHdpdGhvdXQgaG9sZXNcbmZ1bmN0aW9uIGVsaW1pbmF0ZUhvbGVzKCBkYXRhLCBob2xlSW5kaWNlcywgb3V0ZXJOb2RlLCBkaW0gKSB7XG5cblx0Y29uc3QgcXVldWUgPSBbXTtcblx0bGV0IGksIGxlbiwgc3RhcnQsIGVuZCwgbGlzdDtcblxuXHRmb3IgKCBpID0gMCwgbGVuID0gaG9sZUluZGljZXMubGVuZ3RoOyBpIDwgbGVuOyBpICsrICkge1xuXG5cdFx0c3RhcnQgPSBob2xlSW5kaWNlc1sgaSBdICogZGltO1xuXHRcdGVuZCA9IGkgPCBsZW4gLSAxID8gaG9sZUluZGljZXNbIGkgKyAxIF0gKiBkaW0gOiBkYXRhLmxlbmd0aDtcblx0XHRsaXN0ID0gbGlua2VkTGlzdCggZGF0YSwgc3RhcnQsIGVuZCwgZGltLCBmYWxzZSApO1xuXHRcdGlmICggbGlzdCA9PT0gbGlzdC5uZXh0ICkgbGlzdC5zdGVpbmVyID0gdHJ1ZTtcblx0XHRxdWV1ZS5wdXNoKCBnZXRMZWZ0bW9zdCggbGlzdCApICk7XG5cblx0fVxuXG5cdHF1ZXVlLnNvcnQoIGNvbXBhcmVYICk7XG5cblx0Ly8gcHJvY2VzcyBob2xlcyBmcm9tIGxlZnQgdG8gcmlnaHRcblx0Zm9yICggaSA9IDA7IGkgPCBxdWV1ZS5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRvdXRlck5vZGUgPSBlbGltaW5hdGVIb2xlKCBxdWV1ZVsgaSBdLCBvdXRlck5vZGUgKTtcblxuXHR9XG5cblx0cmV0dXJuIG91dGVyTm9kZTtcblxufVxuXG5mdW5jdGlvbiBjb21wYXJlWCggYSwgYiApIHtcblxuXHRyZXR1cm4gYS54IC0gYi54O1xuXG59XG5cbi8vIGZpbmQgYSBicmlkZ2UgYmV0d2VlbiB2ZXJ0aWNlcyB0aGF0IGNvbm5lY3RzIGhvbGUgd2l0aCBhbiBvdXRlciByaW5nIGFuZCBsaW5rIGl0XG5mdW5jdGlvbiBlbGltaW5hdGVIb2xlKCBob2xlLCBvdXRlck5vZGUgKSB7XG5cblx0Y29uc3QgYnJpZGdlID0gZmluZEhvbGVCcmlkZ2UoIGhvbGUsIG91dGVyTm9kZSApO1xuXHRpZiAoICEgYnJpZGdlICkge1xuXG5cdFx0cmV0dXJuIG91dGVyTm9kZTtcblxuXHR9XG5cblx0Y29uc3QgYnJpZGdlUmV2ZXJzZSA9IHNwbGl0UG9seWdvbiggYnJpZGdlLCBob2xlICk7XG5cblx0Ly8gZmlsdGVyIGNvbGxpbmVhciBwb2ludHMgYXJvdW5kIHRoZSBjdXRzXG5cdGZpbHRlclBvaW50cyggYnJpZGdlUmV2ZXJzZSwgYnJpZGdlUmV2ZXJzZS5uZXh0ICk7XG5cdHJldHVybiBmaWx0ZXJQb2ludHMoIGJyaWRnZSwgYnJpZGdlLm5leHQgKTtcblxufVxuXG4vLyBEYXZpZCBFYmVybHkncyBhbGdvcml0aG0gZm9yIGZpbmRpbmcgYSBicmlkZ2UgYmV0d2VlbiBob2xlIGFuZCBvdXRlciBwb2x5Z29uXG5mdW5jdGlvbiBmaW5kSG9sZUJyaWRnZSggaG9sZSwgb3V0ZXJOb2RlICkge1xuXG5cdGxldCBwID0gb3V0ZXJOb2RlLFxuXHRcdHF4ID0gLSBJbmZpbml0eSxcblx0XHRtO1xuXG5cdGNvbnN0IGh4ID0gaG9sZS54LCBoeSA9IGhvbGUueTtcblxuXHQvLyBmaW5kIGEgc2VnbWVudCBpbnRlcnNlY3RlZCBieSBhIHJheSBmcm9tIHRoZSBob2xlJ3MgbGVmdG1vc3QgcG9pbnQgdG8gdGhlIGxlZnQ7XG5cdC8vIHNlZ21lbnQncyBlbmRwb2ludCB3aXRoIGxlc3NlciB4IHdpbGwgYmUgcG90ZW50aWFsIGNvbm5lY3Rpb24gcG9pbnRcblx0ZG8ge1xuXG5cdFx0aWYgKCBoeSA8PSBwLnkgJiYgaHkgPj0gcC5uZXh0LnkgJiYgcC5uZXh0LnkgIT09IHAueSApIHtcblxuXHRcdFx0Y29uc3QgeCA9IHAueCArICggaHkgLSBwLnkgKSAqICggcC5uZXh0LnggLSBwLnggKSAvICggcC5uZXh0LnkgLSBwLnkgKTtcblx0XHRcdGlmICggeCA8PSBoeCAmJiB4ID4gcXggKSB7XG5cblx0XHRcdFx0cXggPSB4O1xuXHRcdFx0XHRtID0gcC54IDwgcC5uZXh0LnggPyBwIDogcC5uZXh0O1xuXHRcdFx0XHRpZiAoIHggPT09IGh4ICkgcmV0dXJuIG07IC8vIGhvbGUgdG91Y2hlcyBvdXRlciBzZWdtZW50OyBwaWNrIGxlZnRtb3N0IGVuZHBvaW50XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHAgPSBwLm5leHQ7XG5cblx0fSB3aGlsZSAoIHAgIT09IG91dGVyTm9kZSApO1xuXG5cdGlmICggISBtICkgcmV0dXJuIG51bGw7XG5cblx0Ly8gbG9vayBmb3IgcG9pbnRzIGluc2lkZSB0aGUgdHJpYW5nbGUgb2YgaG9sZSBwb2ludCwgc2VnbWVudCBpbnRlcnNlY3Rpb24gYW5kIGVuZHBvaW50O1xuXHQvLyBpZiB0aGVyZSBhcmUgbm8gcG9pbnRzIGZvdW5kLCB3ZSBoYXZlIGEgdmFsaWQgY29ubmVjdGlvbjtcblx0Ly8gb3RoZXJ3aXNlIGNob29zZSB0aGUgcG9pbnQgb2YgdGhlIG1pbmltdW0gYW5nbGUgd2l0aCB0aGUgcmF5IGFzIGNvbm5lY3Rpb24gcG9pbnRcblxuXHRjb25zdCBzdG9wID0gbSxcblx0XHRteCA9IG0ueCxcblx0XHRteSA9IG0ueTtcblx0bGV0IHRhbk1pbiA9IEluZmluaXR5LCB0YW47XG5cblx0cCA9IG07XG5cblx0ZG8ge1xuXG5cdFx0aWYgKCBoeCA+PSBwLnggJiYgcC54ID49IG14ICYmIGh4ICE9PSBwLnggJiZcblx0XHRcdFx0cG9pbnRJblRyaWFuZ2xlKCBoeSA8IG15ID8gaHggOiBxeCwgaHksIG14LCBteSwgaHkgPCBteSA/IHF4IDogaHgsIGh5LCBwLngsIHAueSApICkge1xuXG5cdFx0XHR0YW4gPSBNYXRoLmFicyggaHkgLSBwLnkgKSAvICggaHggLSBwLnggKTsgLy8gdGFuZ2VudGlhbFxuXG5cdFx0XHRpZiAoIGxvY2FsbHlJbnNpZGUoIHAsIGhvbGUgKSAmJiAoIHRhbiA8IHRhbk1pbiB8fCAoIHRhbiA9PT0gdGFuTWluICYmICggcC54ID4gbS54IHx8ICggcC54ID09PSBtLnggJiYgc2VjdG9yQ29udGFpbnNTZWN0b3IoIG0sIHAgKSApICkgKSApICkge1xuXG5cdFx0XHRcdG0gPSBwO1xuXHRcdFx0XHR0YW5NaW4gPSB0YW47XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHAgPSBwLm5leHQ7XG5cblx0fSB3aGlsZSAoIHAgIT09IHN0b3AgKTtcblxuXHRyZXR1cm4gbTtcblxufVxuXG4vLyB3aGV0aGVyIHNlY3RvciBpbiB2ZXJ0ZXggbSBjb250YWlucyBzZWN0b3IgaW4gdmVydGV4IHAgaW4gdGhlIHNhbWUgY29vcmRpbmF0ZXNcbmZ1bmN0aW9uIHNlY3RvckNvbnRhaW5zU2VjdG9yKCBtLCBwICkge1xuXG5cdHJldHVybiBhcmVhKCBtLnByZXYsIG0sIHAucHJldiApIDwgMCAmJiBhcmVhKCBwLm5leHQsIG0sIG0ubmV4dCApIDwgMDtcblxufVxuXG4vLyBpbnRlcmxpbmsgcG9seWdvbiBub2RlcyBpbiB6LW9yZGVyXG5mdW5jdGlvbiBpbmRleEN1cnZlKCBzdGFydCwgbWluWCwgbWluWSwgaW52U2l6ZSApIHtcblxuXHRsZXQgcCA9IHN0YXJ0O1xuXHRkbyB7XG5cblx0XHRpZiAoIHAueiA9PT0gMCApIHAueiA9IHpPcmRlciggcC54LCBwLnksIG1pblgsIG1pblksIGludlNpemUgKTtcblx0XHRwLnByZXZaID0gcC5wcmV2O1xuXHRcdHAubmV4dFogPSBwLm5leHQ7XG5cdFx0cCA9IHAubmV4dDtcblxuXHR9IHdoaWxlICggcCAhPT0gc3RhcnQgKTtcblxuXHRwLnByZXZaLm5leHRaID0gbnVsbDtcblx0cC5wcmV2WiA9IG51bGw7XG5cblx0c29ydExpbmtlZCggcCApO1xuXG59XG5cbi8vIFNpbW9uIFRhdGhhbSdzIGxpbmtlZCBsaXN0IG1lcmdlIHNvcnQgYWxnb3JpdGhtXG4vLyBodHRwOi8vd3d3LmNoaWFyay5ncmVlbmVuZC5vcmcudWsvfnNndGF0aGFtL2FsZ29yaXRobXMvbGlzdHNvcnQuaHRtbFxuZnVuY3Rpb24gc29ydExpbmtlZCggbGlzdCApIHtcblxuXHRsZXQgaSwgcCwgcSwgZSwgdGFpbCwgbnVtTWVyZ2VzLCBwU2l6ZSwgcVNpemUsXG5cdFx0aW5TaXplID0gMTtcblxuXHRkbyB7XG5cblx0XHRwID0gbGlzdDtcblx0XHRsaXN0ID0gbnVsbDtcblx0XHR0YWlsID0gbnVsbDtcblx0XHRudW1NZXJnZXMgPSAwO1xuXG5cdFx0d2hpbGUgKCBwICkge1xuXG5cdFx0XHRudW1NZXJnZXMgKys7XG5cdFx0XHRxID0gcDtcblx0XHRcdHBTaXplID0gMDtcblx0XHRcdGZvciAoIGkgPSAwOyBpIDwgaW5TaXplOyBpICsrICkge1xuXG5cdFx0XHRcdHBTaXplICsrO1xuXHRcdFx0XHRxID0gcS5uZXh0Wjtcblx0XHRcdFx0aWYgKCAhIHEgKSBicmVhaztcblxuXHRcdFx0fVxuXG5cdFx0XHRxU2l6ZSA9IGluU2l6ZTtcblxuXHRcdFx0d2hpbGUgKCBwU2l6ZSA+IDAgfHwgKCBxU2l6ZSA+IDAgJiYgcSApICkge1xuXG5cdFx0XHRcdGlmICggcFNpemUgIT09IDAgJiYgKCBxU2l6ZSA9PT0gMCB8fCAhIHEgfHwgcC56IDw9IHEueiApICkge1xuXG5cdFx0XHRcdFx0ZSA9IHA7XG5cdFx0XHRcdFx0cCA9IHAubmV4dFo7XG5cdFx0XHRcdFx0cFNpemUgLS07XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdGUgPSBxO1xuXHRcdFx0XHRcdHEgPSBxLm5leHRaO1xuXHRcdFx0XHRcdHFTaXplIC0tO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIHRhaWwgKSB0YWlsLm5leHRaID0gZTtcblx0XHRcdFx0ZWxzZSBsaXN0ID0gZTtcblxuXHRcdFx0XHRlLnByZXZaID0gdGFpbDtcblx0XHRcdFx0dGFpbCA9IGU7XG5cblx0XHRcdH1cblxuXHRcdFx0cCA9IHE7XG5cblx0XHR9XG5cblx0XHR0YWlsLm5leHRaID0gbnVsbDtcblx0XHRpblNpemUgKj0gMjtcblxuXHR9IHdoaWxlICggbnVtTWVyZ2VzID4gMSApO1xuXG5cdHJldHVybiBsaXN0O1xuXG59XG5cbi8vIHotb3JkZXIgb2YgYSBwb2ludCBnaXZlbiBjb29yZHMgYW5kIGludmVyc2Ugb2YgdGhlIGxvbmdlciBzaWRlIG9mIGRhdGEgYmJveFxuZnVuY3Rpb24gek9yZGVyKCB4LCB5LCBtaW5YLCBtaW5ZLCBpbnZTaXplICkge1xuXG5cdC8vIGNvb3JkcyBhcmUgdHJhbnNmb3JtZWQgaW50byBub24tbmVnYXRpdmUgMTUtYml0IGludGVnZXIgcmFuZ2Vcblx0eCA9ICggeCAtIG1pblggKSAqIGludlNpemUgfCAwO1xuXHR5ID0gKCB5IC0gbWluWSApICogaW52U2l6ZSB8IDA7XG5cblx0eCA9ICggeCB8ICggeCA8PCA4ICkgKSAmIDB4MDBGRjAwRkY7XG5cdHggPSAoIHggfCAoIHggPDwgNCApICkgJiAweDBGMEYwRjBGO1xuXHR4ID0gKCB4IHwgKCB4IDw8IDIgKSApICYgMHgzMzMzMzMzMztcblx0eCA9ICggeCB8ICggeCA8PCAxICkgKSAmIDB4NTU1NTU1NTU7XG5cblx0eSA9ICggeSB8ICggeSA8PCA4ICkgKSAmIDB4MDBGRjAwRkY7XG5cdHkgPSAoIHkgfCAoIHkgPDwgNCApICkgJiAweDBGMEYwRjBGO1xuXHR5ID0gKCB5IHwgKCB5IDw8IDIgKSApICYgMHgzMzMzMzMzMztcblx0eSA9ICggeSB8ICggeSA8PCAxICkgKSAmIDB4NTU1NTU1NTU7XG5cblx0cmV0dXJuIHggfCAoIHkgPDwgMSApO1xuXG59XG5cbi8vIGZpbmQgdGhlIGxlZnRtb3N0IG5vZGUgb2YgYSBwb2x5Z29uIHJpbmdcbmZ1bmN0aW9uIGdldExlZnRtb3N0KCBzdGFydCApIHtcblxuXHRsZXQgcCA9IHN0YXJ0LFxuXHRcdGxlZnRtb3N0ID0gc3RhcnQ7XG5cdGRvIHtcblxuXHRcdGlmICggcC54IDwgbGVmdG1vc3QueCB8fCAoIHAueCA9PT0gbGVmdG1vc3QueCAmJiBwLnkgPCBsZWZ0bW9zdC55ICkgKSBsZWZ0bW9zdCA9IHA7XG5cdFx0cCA9IHAubmV4dDtcblxuXHR9IHdoaWxlICggcCAhPT0gc3RhcnQgKTtcblxuXHRyZXR1cm4gbGVmdG1vc3Q7XG5cbn1cblxuLy8gY2hlY2sgaWYgYSBwb2ludCBsaWVzIHdpdGhpbiBhIGNvbnZleCB0cmlhbmdsZVxuZnVuY3Rpb24gcG9pbnRJblRyaWFuZ2xlKCBheCwgYXksIGJ4LCBieSwgY3gsIGN5LCBweCwgcHkgKSB7XG5cblx0cmV0dXJuICggY3ggLSBweCApICogKCBheSAtIHB5ICkgPj0gKCBheCAtIHB4ICkgKiAoIGN5IC0gcHkgKSAmJlxuICAgICAgICAgICAoIGF4IC0gcHggKSAqICggYnkgLSBweSApID49ICggYnggLSBweCApICogKCBheSAtIHB5ICkgJiZcbiAgICAgICAgICAgKCBieCAtIHB4ICkgKiAoIGN5IC0gcHkgKSA+PSAoIGN4IC0gcHggKSAqICggYnkgLSBweSApO1xuXG59XG5cbi8vIGNoZWNrIGlmIGEgZGlhZ29uYWwgYmV0d2VlbiB0d28gcG9seWdvbiBub2RlcyBpcyB2YWxpZCAobGllcyBpbiBwb2x5Z29uIGludGVyaW9yKVxuZnVuY3Rpb24gaXNWYWxpZERpYWdvbmFsKCBhLCBiICkge1xuXG5cdHJldHVybiBhLm5leHQuaSAhPT0gYi5pICYmIGEucHJldi5pICE9PSBiLmkgJiYgISBpbnRlcnNlY3RzUG9seWdvbiggYSwgYiApICYmIC8vIGRvbmVzJ3QgaW50ZXJzZWN0IG90aGVyIGVkZ2VzXG4gICAgICAgICAgICggbG9jYWxseUluc2lkZSggYSwgYiApICYmIGxvY2FsbHlJbnNpZGUoIGIsIGEgKSAmJiBtaWRkbGVJbnNpZGUoIGEsIGIgKSAmJiAvLyBsb2NhbGx5IHZpc2libGVcbiAgICAgICAgICAgICggYXJlYSggYS5wcmV2LCBhLCBiLnByZXYgKSB8fCBhcmVhKCBhLCBiLnByZXYsIGIgKSApIHx8IC8vIGRvZXMgbm90IGNyZWF0ZSBvcHBvc2l0ZS1mYWNpbmcgc2VjdG9yc1xuICAgICAgICAgICAgZXF1YWxzKCBhLCBiICkgJiYgYXJlYSggYS5wcmV2LCBhLCBhLm5leHQgKSA+IDAgJiYgYXJlYSggYi5wcmV2LCBiLCBiLm5leHQgKSA+IDAgKTsgLy8gc3BlY2lhbCB6ZXJvLWxlbmd0aCBjYXNlXG5cbn1cblxuLy8gc2lnbmVkIGFyZWEgb2YgYSB0cmlhbmdsZVxuZnVuY3Rpb24gYXJlYSggcCwgcSwgciApIHtcblxuXHRyZXR1cm4gKCBxLnkgLSBwLnkgKSAqICggci54IC0gcS54ICkgLSAoIHEueCAtIHAueCApICogKCByLnkgLSBxLnkgKTtcblxufVxuXG4vLyBjaGVjayBpZiB0d28gcG9pbnRzIGFyZSBlcXVhbFxuZnVuY3Rpb24gZXF1YWxzKCBwMSwgcDIgKSB7XG5cblx0cmV0dXJuIHAxLnggPT09IHAyLnggJiYgcDEueSA9PT0gcDIueTtcblxufVxuXG4vLyBjaGVjayBpZiB0d28gc2VnbWVudHMgaW50ZXJzZWN0XG5mdW5jdGlvbiBpbnRlcnNlY3RzKCBwMSwgcTEsIHAyLCBxMiApIHtcblxuXHRjb25zdCBvMSA9IHNpZ24oIGFyZWEoIHAxLCBxMSwgcDIgKSApO1xuXHRjb25zdCBvMiA9IHNpZ24oIGFyZWEoIHAxLCBxMSwgcTIgKSApO1xuXHRjb25zdCBvMyA9IHNpZ24oIGFyZWEoIHAyLCBxMiwgcDEgKSApO1xuXHRjb25zdCBvNCA9IHNpZ24oIGFyZWEoIHAyLCBxMiwgcTEgKSApO1xuXG5cdGlmICggbzEgIT09IG8yICYmIG8zICE9PSBvNCApIHJldHVybiB0cnVlOyAvLyBnZW5lcmFsIGNhc2VcblxuXHRpZiAoIG8xID09PSAwICYmIG9uU2VnbWVudCggcDEsIHAyLCBxMSApICkgcmV0dXJuIHRydWU7IC8vIHAxLCBxMSBhbmQgcDIgYXJlIGNvbGxpbmVhciBhbmQgcDIgbGllcyBvbiBwMXExXG5cdGlmICggbzIgPT09IDAgJiYgb25TZWdtZW50KCBwMSwgcTIsIHExICkgKSByZXR1cm4gdHJ1ZTsgLy8gcDEsIHExIGFuZCBxMiBhcmUgY29sbGluZWFyIGFuZCBxMiBsaWVzIG9uIHAxcTFcblx0aWYgKCBvMyA9PT0gMCAmJiBvblNlZ21lbnQoIHAyLCBwMSwgcTIgKSApIHJldHVybiB0cnVlOyAvLyBwMiwgcTIgYW5kIHAxIGFyZSBjb2xsaW5lYXIgYW5kIHAxIGxpZXMgb24gcDJxMlxuXHRpZiAoIG80ID09PSAwICYmIG9uU2VnbWVudCggcDIsIHExLCBxMiApICkgcmV0dXJuIHRydWU7IC8vIHAyLCBxMiBhbmQgcTEgYXJlIGNvbGxpbmVhciBhbmQgcTEgbGllcyBvbiBwMnEyXG5cblx0cmV0dXJuIGZhbHNlO1xuXG59XG5cbi8vIGZvciBjb2xsaW5lYXIgcG9pbnRzIHAsIHEsIHIsIGNoZWNrIGlmIHBvaW50IHEgbGllcyBvbiBzZWdtZW50IHByXG5mdW5jdGlvbiBvblNlZ21lbnQoIHAsIHEsIHIgKSB7XG5cblx0cmV0dXJuIHEueCA8PSBNYXRoLm1heCggcC54LCByLnggKSAmJiBxLnggPj0gTWF0aC5taW4oIHAueCwgci54ICkgJiYgcS55IDw9IE1hdGgubWF4KCBwLnksIHIueSApICYmIHEueSA+PSBNYXRoLm1pbiggcC55LCByLnkgKTtcblxufVxuXG5mdW5jdGlvbiBzaWduKCBudW0gKSB7XG5cblx0cmV0dXJuIG51bSA+IDAgPyAxIDogbnVtIDwgMCA/IC0gMSA6IDA7XG5cbn1cblxuLy8gY2hlY2sgaWYgYSBwb2x5Z29uIGRpYWdvbmFsIGludGVyc2VjdHMgYW55IHBvbHlnb24gc2VnbWVudHNcbmZ1bmN0aW9uIGludGVyc2VjdHNQb2x5Z29uKCBhLCBiICkge1xuXG5cdGxldCBwID0gYTtcblx0ZG8ge1xuXG5cdFx0aWYgKCBwLmkgIT09IGEuaSAmJiBwLm5leHQuaSAhPT0gYS5pICYmIHAuaSAhPT0gYi5pICYmIHAubmV4dC5pICE9PSBiLmkgJiZcblx0XHRcdGludGVyc2VjdHMoIHAsIHAubmV4dCwgYSwgYiApICkgcmV0dXJuIHRydWU7XG5cdFx0cCA9IHAubmV4dDtcblxuXHR9IHdoaWxlICggcCAhPT0gYSApO1xuXG5cdHJldHVybiBmYWxzZTtcblxufVxuXG4vLyBjaGVjayBpZiBhIHBvbHlnb24gZGlhZ29uYWwgaXMgbG9jYWxseSBpbnNpZGUgdGhlIHBvbHlnb25cbmZ1bmN0aW9uIGxvY2FsbHlJbnNpZGUoIGEsIGIgKSB7XG5cblx0cmV0dXJuIGFyZWEoIGEucHJldiwgYSwgYS5uZXh0ICkgPCAwID9cblx0XHRhcmVhKCBhLCBiLCBhLm5leHQgKSA+PSAwICYmIGFyZWEoIGEsIGEucHJldiwgYiApID49IDAgOlxuXHRcdGFyZWEoIGEsIGIsIGEucHJldiApIDwgMCB8fCBhcmVhKCBhLCBhLm5leHQsIGIgKSA8IDA7XG5cbn1cblxuLy8gY2hlY2sgaWYgdGhlIG1pZGRsZSBwb2ludCBvZiBhIHBvbHlnb24gZGlhZ29uYWwgaXMgaW5zaWRlIHRoZSBwb2x5Z29uXG5mdW5jdGlvbiBtaWRkbGVJbnNpZGUoIGEsIGIgKSB7XG5cblx0bGV0IHAgPSBhLFxuXHRcdGluc2lkZSA9IGZhbHNlO1xuXHRjb25zdCBweCA9ICggYS54ICsgYi54ICkgLyAyLFxuXHRcdHB5ID0gKCBhLnkgKyBiLnkgKSAvIDI7XG5cdGRvIHtcblxuXHRcdGlmICggKCAoIHAueSA+IHB5ICkgIT09ICggcC5uZXh0LnkgPiBweSApICkgJiYgcC5uZXh0LnkgIT09IHAueSAmJlxuXHRcdFx0KCBweCA8ICggcC5uZXh0LnggLSBwLnggKSAqICggcHkgLSBwLnkgKSAvICggcC5uZXh0LnkgLSBwLnkgKSArIHAueCApIClcblx0XHRcdGluc2lkZSA9ICEgaW5zaWRlO1xuXHRcdHAgPSBwLm5leHQ7XG5cblx0fSB3aGlsZSAoIHAgIT09IGEgKTtcblxuXHRyZXR1cm4gaW5zaWRlO1xuXG59XG5cbi8vIGxpbmsgdHdvIHBvbHlnb24gdmVydGljZXMgd2l0aCBhIGJyaWRnZTsgaWYgdGhlIHZlcnRpY2VzIGJlbG9uZyB0byB0aGUgc2FtZSByaW5nLCBpdCBzcGxpdHMgcG9seWdvbiBpbnRvIHR3bztcbi8vIGlmIG9uZSBiZWxvbmdzIHRvIHRoZSBvdXRlciByaW5nIGFuZCBhbm90aGVyIHRvIGEgaG9sZSwgaXQgbWVyZ2VzIGl0IGludG8gYSBzaW5nbGUgcmluZ1xuZnVuY3Rpb24gc3BsaXRQb2x5Z29uKCBhLCBiICkge1xuXG5cdGNvbnN0IGEyID0gbmV3IE5vZGUoIGEuaSwgYS54LCBhLnkgKSxcblx0XHRiMiA9IG5ldyBOb2RlKCBiLmksIGIueCwgYi55ICksXG5cdFx0YW4gPSBhLm5leHQsXG5cdFx0YnAgPSBiLnByZXY7XG5cblx0YS5uZXh0ID0gYjtcblx0Yi5wcmV2ID0gYTtcblxuXHRhMi5uZXh0ID0gYW47XG5cdGFuLnByZXYgPSBhMjtcblxuXHRiMi5uZXh0ID0gYTI7XG5cdGEyLnByZXYgPSBiMjtcblxuXHRicC5uZXh0ID0gYjI7XG5cdGIyLnByZXYgPSBicDtcblxuXHRyZXR1cm4gYjI7XG5cbn1cblxuLy8gY3JlYXRlIGEgbm9kZSBhbmQgb3B0aW9uYWxseSBsaW5rIGl0IHdpdGggcHJldmlvdXMgb25lIChpbiBhIGNpcmN1bGFyIGRvdWJseSBsaW5rZWQgbGlzdClcbmZ1bmN0aW9uIGluc2VydE5vZGUoIGksIHgsIHksIGxhc3QgKSB7XG5cblx0Y29uc3QgcCA9IG5ldyBOb2RlKCBpLCB4LCB5ICk7XG5cblx0aWYgKCAhIGxhc3QgKSB7XG5cblx0XHRwLnByZXYgPSBwO1xuXHRcdHAubmV4dCA9IHA7XG5cblx0fSBlbHNlIHtcblxuXHRcdHAubmV4dCA9IGxhc3QubmV4dDtcblx0XHRwLnByZXYgPSBsYXN0O1xuXHRcdGxhc3QubmV4dC5wcmV2ID0gcDtcblx0XHRsYXN0Lm5leHQgPSBwO1xuXG5cdH1cblxuXHRyZXR1cm4gcDtcblxufVxuXG5mdW5jdGlvbiByZW1vdmVOb2RlKCBwICkge1xuXG5cdHAubmV4dC5wcmV2ID0gcC5wcmV2O1xuXHRwLnByZXYubmV4dCA9IHAubmV4dDtcblxuXHRpZiAoIHAucHJldlogKSBwLnByZXZaLm5leHRaID0gcC5uZXh0Wjtcblx0aWYgKCBwLm5leHRaICkgcC5uZXh0Wi5wcmV2WiA9IHAucHJldlo7XG5cbn1cblxuZnVuY3Rpb24gTm9kZSggaSwgeCwgeSApIHtcblxuXHQvLyB2ZXJ0ZXggaW5kZXggaW4gY29vcmRpbmF0ZXMgYXJyYXlcblx0dGhpcy5pID0gaTtcblxuXHQvLyB2ZXJ0ZXggY29vcmRpbmF0ZXNcblx0dGhpcy54ID0geDtcblx0dGhpcy55ID0geTtcblxuXHQvLyBwcmV2aW91cyBhbmQgbmV4dCB2ZXJ0ZXggbm9kZXMgaW4gYSBwb2x5Z29uIHJpbmdcblx0dGhpcy5wcmV2ID0gbnVsbDtcblx0dGhpcy5uZXh0ID0gbnVsbDtcblxuXHQvLyB6LW9yZGVyIGN1cnZlIHZhbHVlXG5cdHRoaXMueiA9IDA7XG5cblx0Ly8gcHJldmlvdXMgYW5kIG5leHQgbm9kZXMgaW4gei1vcmRlclxuXHR0aGlzLnByZXZaID0gbnVsbDtcblx0dGhpcy5uZXh0WiA9IG51bGw7XG5cblx0Ly8gaW5kaWNhdGVzIHdoZXRoZXIgdGhpcyBpcyBhIHN0ZWluZXIgcG9pbnRcblx0dGhpcy5zdGVpbmVyID0gZmFsc2U7XG5cbn1cblxuZnVuY3Rpb24gc2lnbmVkQXJlYSggZGF0YSwgc3RhcnQsIGVuZCwgZGltICkge1xuXG5cdGxldCBzdW0gPSAwO1xuXHRmb3IgKCBsZXQgaSA9IHN0YXJ0LCBqID0gZW5kIC0gZGltOyBpIDwgZW5kOyBpICs9IGRpbSApIHtcblxuXHRcdHN1bSArPSAoIGRhdGFbIGogXSAtIGRhdGFbIGkgXSApICogKCBkYXRhWyBpICsgMSBdICsgZGF0YVsgaiArIDEgXSApO1xuXHRcdGogPSBpO1xuXG5cdH1cblxuXHRyZXR1cm4gc3VtO1xuXG59XG5cbmV4cG9ydCB7IEVhcmN1dCB9O1xuIiwiaW1wb3J0IHsgRWFyY3V0IH0gZnJvbSAnLi9FYXJjdXQuanMnO1xuXG5jbGFzcyBTaGFwZVV0aWxzIHtcblxuXHQvLyBjYWxjdWxhdGUgYXJlYSBvZiB0aGUgY29udG91ciBwb2x5Z29uXG5cblx0c3RhdGljIGFyZWEoIGNvbnRvdXIgKSB7XG5cblx0XHRjb25zdCBuID0gY29udG91ci5sZW5ndGg7XG5cdFx0bGV0IGEgPSAwLjA7XG5cblx0XHRmb3IgKCBsZXQgcCA9IG4gLSAxLCBxID0gMDsgcSA8IG47IHAgPSBxICsrICkge1xuXG5cdFx0XHRhICs9IGNvbnRvdXJbIHAgXS54ICogY29udG91clsgcSBdLnkgLSBjb250b3VyWyBxIF0ueCAqIGNvbnRvdXJbIHAgXS55O1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGEgKiAwLjU7XG5cblx0fVxuXG5cdHN0YXRpYyBpc0Nsb2NrV2lzZSggcHRzICkge1xuXG5cdFx0cmV0dXJuIFNoYXBlVXRpbHMuYXJlYSggcHRzICkgPCAwO1xuXG5cdH1cblxuXHRzdGF0aWMgdHJpYW5ndWxhdGVTaGFwZSggY29udG91ciwgaG9sZXMgKSB7XG5cblx0XHRjb25zdCB2ZXJ0aWNlcyA9IFtdOyAvLyBmbGF0IGFycmF5IG9mIHZlcnRpY2VzIGxpa2UgWyB4MCx5MCwgeDEseTEsIHgyLHkyLCAuLi4gXVxuXHRcdGNvbnN0IGhvbGVJbmRpY2VzID0gW107IC8vIGFycmF5IG9mIGhvbGUgaW5kaWNlc1xuXHRcdGNvbnN0IGZhY2VzID0gW107IC8vIGZpbmFsIGFycmF5IG9mIHZlcnRleCBpbmRpY2VzIGxpa2UgWyBbIGEsYixkIF0sIFsgYixjLGQgXSBdXG5cblx0XHRyZW1vdmVEdXBFbmRQdHMoIGNvbnRvdXIgKTtcblx0XHRhZGRDb250b3VyKCB2ZXJ0aWNlcywgY29udG91ciApO1xuXG5cdFx0Ly9cblxuXHRcdGxldCBob2xlSW5kZXggPSBjb250b3VyLmxlbmd0aDtcblxuXHRcdGhvbGVzLmZvckVhY2goIHJlbW92ZUR1cEVuZFB0cyApO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgaG9sZXMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRob2xlSW5kaWNlcy5wdXNoKCBob2xlSW5kZXggKTtcblx0XHRcdGhvbGVJbmRleCArPSBob2xlc1sgaSBdLmxlbmd0aDtcblx0XHRcdGFkZENvbnRvdXIoIHZlcnRpY2VzLCBob2xlc1sgaSBdICk7XG5cblx0XHR9XG5cblx0XHQvL1xuXG5cdFx0Y29uc3QgdHJpYW5nbGVzID0gRWFyY3V0LnRyaWFuZ3VsYXRlKCB2ZXJ0aWNlcywgaG9sZUluZGljZXMgKTtcblxuXHRcdC8vXG5cblx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCB0cmlhbmdsZXMubGVuZ3RoOyBpICs9IDMgKSB7XG5cblx0XHRcdGZhY2VzLnB1c2goIHRyaWFuZ2xlcy5zbGljZSggaSwgaSArIDMgKSApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhY2VzO1xuXG5cdH1cblxufVxuXG5mdW5jdGlvbiByZW1vdmVEdXBFbmRQdHMoIHBvaW50cyApIHtcblxuXHRjb25zdCBsID0gcG9pbnRzLmxlbmd0aDtcblxuXHRpZiAoIGwgPiAyICYmIHBvaW50c1sgbCAtIDEgXS5lcXVhbHMoIHBvaW50c1sgMCBdICkgKSB7XG5cblx0XHRwb2ludHMucG9wKCk7XG5cblx0fVxuXG59XG5cbmZ1bmN0aW9uIGFkZENvbnRvdXIoIHZlcnRpY2VzLCBjb250b3VyICkge1xuXG5cdGZvciAoIGxldCBpID0gMDsgaSA8IGNvbnRvdXIubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0dmVydGljZXMucHVzaCggY29udG91clsgaSBdLnggKTtcblx0XHR2ZXJ0aWNlcy5wdXNoKCBjb250b3VyWyBpIF0ueSApO1xuXG5cdH1cblxufVxuXG5leHBvcnQgeyBTaGFwZVV0aWxzIH07XG4iLCJpbXBvcnQgKiBhcyBNYXRoVXRpbHMgZnJvbSAnLi4vLi4vbWF0aC9NYXRoVXRpbHMuanMnO1xuaW1wb3J0IHsgVmVjdG9yMiB9IGZyb20gJy4uLy4uL21hdGgvVmVjdG9yMi5qcyc7XG5pbXBvcnQgeyBWZWN0b3IzIH0gZnJvbSAnLi4vLi4vbWF0aC9WZWN0b3IzLmpzJztcbmltcG9ydCB7IE1hdHJpeDQgfSBmcm9tICcuLi8uLi9tYXRoL01hdHJpeDQuanMnO1xuXG4vKipcbiAqIEV4dGVuc2libGUgY3VydmUgb2JqZWN0LlxuICpcbiAqIFNvbWUgY29tbW9uIG9mIGN1cnZlIG1ldGhvZHM6XG4gKiAuZ2V0UG9pbnQoIHQsIG9wdGlvbmFsVGFyZ2V0ICksIC5nZXRUYW5nZW50KCB0LCBvcHRpb25hbFRhcmdldCApXG4gKiAuZ2V0UG9pbnRBdCggdSwgb3B0aW9uYWxUYXJnZXQgKSwgLmdldFRhbmdlbnRBdCggdSwgb3B0aW9uYWxUYXJnZXQgKVxuICogLmdldFBvaW50cygpLCAuZ2V0U3BhY2VkUG9pbnRzKClcbiAqIC5nZXRMZW5ndGgoKVxuICogLnVwZGF0ZUFyY0xlbmd0aHMoKVxuICpcbiAqIFRoaXMgZm9sbG93aW5nIGN1cnZlcyBpbmhlcml0IGZyb20gVEhSRUUuQ3VydmU6XG4gKlxuICogLS0gMkQgY3VydmVzIC0tXG4gKiBUSFJFRS5BcmNDdXJ2ZVxuICogVEhSRUUuQ3ViaWNCZXppZXJDdXJ2ZVxuICogVEhSRUUuRWxsaXBzZUN1cnZlXG4gKiBUSFJFRS5MaW5lQ3VydmVcbiAqIFRIUkVFLlF1YWRyYXRpY0JlemllckN1cnZlXG4gKiBUSFJFRS5TcGxpbmVDdXJ2ZVxuICpcbiAqIC0tIDNEIGN1cnZlcyAtLVxuICogVEhSRUUuQ2F0bXVsbFJvbUN1cnZlM1xuICogVEhSRUUuQ3ViaWNCZXppZXJDdXJ2ZTNcbiAqIFRIUkVFLkxpbmVDdXJ2ZTNcbiAqIFRIUkVFLlF1YWRyYXRpY0JlemllckN1cnZlM1xuICpcbiAqIEEgc2VyaWVzIG9mIGN1cnZlcyBjYW4gYmUgcmVwcmVzZW50ZWQgYXMgYSBUSFJFRS5DdXJ2ZVBhdGguXG4gKlxuICoqL1xuXG5jbGFzcyBDdXJ2ZSB7XG5cblx0Y29uc3RydWN0b3IoKSB7XG5cblx0XHR0aGlzLnR5cGUgPSAnQ3VydmUnO1xuXG5cdFx0dGhpcy5hcmNMZW5ndGhEaXZpc2lvbnMgPSAyMDA7XG5cblx0fVxuXG5cdC8vIFZpcnR1YWwgYmFzZSBjbGFzcyBtZXRob2QgdG8gb3ZlcndyaXRlIGFuZCBpbXBsZW1lbnQgaW4gc3ViY2xhc3Nlc1xuXHQvL1x0LSB0IFswIC4uIDFdXG5cblx0Z2V0UG9pbnQoIC8qIHQsIG9wdGlvbmFsVGFyZ2V0ICovICkge1xuXG5cdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQ3VydmU6IC5nZXRQb2ludCgpIG5vdCBpbXBsZW1lbnRlZC4nICk7XG5cdFx0cmV0dXJuIG51bGw7XG5cblx0fVxuXG5cdC8vIEdldCBwb2ludCBhdCByZWxhdGl2ZSBwb3NpdGlvbiBpbiBjdXJ2ZSBhY2NvcmRpbmcgdG8gYXJjIGxlbmd0aFxuXHQvLyAtIHUgWzAgLi4gMV1cblxuXHRnZXRQb2ludEF0KCB1LCBvcHRpb25hbFRhcmdldCApIHtcblxuXHRcdGNvbnN0IHQgPSB0aGlzLmdldFV0b1RtYXBwaW5nKCB1ICk7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0UG9pbnQoIHQsIG9wdGlvbmFsVGFyZ2V0ICk7XG5cblx0fVxuXG5cdC8vIEdldCBzZXF1ZW5jZSBvZiBwb2ludHMgdXNpbmcgZ2V0UG9pbnQoIHQgKVxuXG5cdGdldFBvaW50cyggZGl2aXNpb25zID0gNSApIHtcblxuXHRcdGNvbnN0IHBvaW50cyA9IFtdO1xuXG5cdFx0Zm9yICggbGV0IGQgPSAwOyBkIDw9IGRpdmlzaW9uczsgZCArKyApIHtcblxuXHRcdFx0cG9pbnRzLnB1c2goIHRoaXMuZ2V0UG9pbnQoIGQgLyBkaXZpc2lvbnMgKSApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHBvaW50cztcblxuXHR9XG5cblx0Ly8gR2V0IHNlcXVlbmNlIG9mIHBvaW50cyB1c2luZyBnZXRQb2ludEF0KCB1IClcblxuXHRnZXRTcGFjZWRQb2ludHMoIGRpdmlzaW9ucyA9IDUgKSB7XG5cblx0XHRjb25zdCBwb2ludHMgPSBbXTtcblxuXHRcdGZvciAoIGxldCBkID0gMDsgZCA8PSBkaXZpc2lvbnM7IGQgKysgKSB7XG5cblx0XHRcdHBvaW50cy5wdXNoKCB0aGlzLmdldFBvaW50QXQoIGQgLyBkaXZpc2lvbnMgKSApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHBvaW50cztcblxuXHR9XG5cblx0Ly8gR2V0IHRvdGFsIGN1cnZlIGFyYyBsZW5ndGhcblxuXHRnZXRMZW5ndGgoKSB7XG5cblx0XHRjb25zdCBsZW5ndGhzID0gdGhpcy5nZXRMZW5ndGhzKCk7XG5cdFx0cmV0dXJuIGxlbmd0aHNbIGxlbmd0aHMubGVuZ3RoIC0gMSBdO1xuXG5cdH1cblxuXHQvLyBHZXQgbGlzdCBvZiBjdW11bGF0aXZlIHNlZ21lbnQgbGVuZ3Roc1xuXG5cdGdldExlbmd0aHMoIGRpdmlzaW9ucyA9IHRoaXMuYXJjTGVuZ3RoRGl2aXNpb25zICkge1xuXG5cdFx0aWYgKCB0aGlzLmNhY2hlQXJjTGVuZ3RocyAmJlxuXHRcdFx0KCB0aGlzLmNhY2hlQXJjTGVuZ3Rocy5sZW5ndGggPT09IGRpdmlzaW9ucyArIDEgKSAmJlxuXHRcdFx0ISB0aGlzLm5lZWRzVXBkYXRlICkge1xuXG5cdFx0XHRyZXR1cm4gdGhpcy5jYWNoZUFyY0xlbmd0aHM7XG5cblx0XHR9XG5cblx0XHR0aGlzLm5lZWRzVXBkYXRlID0gZmFsc2U7XG5cblx0XHRjb25zdCBjYWNoZSA9IFtdO1xuXHRcdGxldCBjdXJyZW50LCBsYXN0ID0gdGhpcy5nZXRQb2ludCggMCApO1xuXHRcdGxldCBzdW0gPSAwO1xuXG5cdFx0Y2FjaGUucHVzaCggMCApO1xuXG5cdFx0Zm9yICggbGV0IHAgPSAxOyBwIDw9IGRpdmlzaW9uczsgcCArKyApIHtcblxuXHRcdFx0Y3VycmVudCA9IHRoaXMuZ2V0UG9pbnQoIHAgLyBkaXZpc2lvbnMgKTtcblx0XHRcdHN1bSArPSBjdXJyZW50LmRpc3RhbmNlVG8oIGxhc3QgKTtcblx0XHRcdGNhY2hlLnB1c2goIHN1bSApO1xuXHRcdFx0bGFzdCA9IGN1cnJlbnQ7XG5cblx0XHR9XG5cblx0XHR0aGlzLmNhY2hlQXJjTGVuZ3RocyA9IGNhY2hlO1xuXG5cdFx0cmV0dXJuIGNhY2hlOyAvLyB7IHN1bXM6IGNhY2hlLCBzdW06IHN1bSB9OyBTdW0gaXMgaW4gdGhlIGxhc3QgZWxlbWVudC5cblxuXHR9XG5cblx0dXBkYXRlQXJjTGVuZ3RocygpIHtcblxuXHRcdHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xuXHRcdHRoaXMuZ2V0TGVuZ3RocygpO1xuXG5cdH1cblxuXHQvLyBHaXZlbiB1ICggMCAuLiAxICksIGdldCBhIHQgdG8gZmluZCBwLiBUaGlzIGdpdmVzIHlvdSBwb2ludHMgd2hpY2ggYXJlIGVxdWlkaXN0YW50XG5cblx0Z2V0VXRvVG1hcHBpbmcoIHUsIGRpc3RhbmNlICkge1xuXG5cdFx0Y29uc3QgYXJjTGVuZ3RocyA9IHRoaXMuZ2V0TGVuZ3RocygpO1xuXG5cdFx0bGV0IGkgPSAwO1xuXHRcdGNvbnN0IGlsID0gYXJjTGVuZ3Rocy5sZW5ndGg7XG5cblx0XHRsZXQgdGFyZ2V0QXJjTGVuZ3RoOyAvLyBUaGUgdGFyZ2V0ZWQgdSBkaXN0YW5jZSB2YWx1ZSB0byBnZXRcblxuXHRcdGlmICggZGlzdGFuY2UgKSB7XG5cblx0XHRcdHRhcmdldEFyY0xlbmd0aCA9IGRpc3RhbmNlO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0dGFyZ2V0QXJjTGVuZ3RoID0gdSAqIGFyY0xlbmd0aHNbIGlsIC0gMSBdO1xuXG5cdFx0fVxuXG5cdFx0Ly8gYmluYXJ5IHNlYXJjaCBmb3IgdGhlIGluZGV4IHdpdGggbGFyZ2VzdCB2YWx1ZSBzbWFsbGVyIHRoYW4gdGFyZ2V0IHUgZGlzdGFuY2VcblxuXHRcdGxldCBsb3cgPSAwLCBoaWdoID0gaWwgLSAxLCBjb21wYXJpc29uO1xuXG5cdFx0d2hpbGUgKCBsb3cgPD0gaGlnaCApIHtcblxuXHRcdFx0aSA9IE1hdGguZmxvb3IoIGxvdyArICggaGlnaCAtIGxvdyApIC8gMiApOyAvLyBsZXNzIGxpa2VseSB0byBvdmVyZmxvdywgdGhvdWdoIHByb2JhYmx5IG5vdCBpc3N1ZSBoZXJlLCBKUyBkb2Vzbid0IHJlYWxseSBoYXZlIGludGVnZXJzLCBhbGwgbnVtYmVycyBhcmUgZmxvYXRzXG5cblx0XHRcdGNvbXBhcmlzb24gPSBhcmNMZW5ndGhzWyBpIF0gLSB0YXJnZXRBcmNMZW5ndGg7XG5cblx0XHRcdGlmICggY29tcGFyaXNvbiA8IDAgKSB7XG5cblx0XHRcdFx0bG93ID0gaSArIDE7XG5cblx0XHRcdH0gZWxzZSBpZiAoIGNvbXBhcmlzb24gPiAwICkge1xuXG5cdFx0XHRcdGhpZ2ggPSBpIC0gMTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRoaWdoID0gaTtcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Ly8gRE9ORVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRpID0gaGlnaDtcblxuXHRcdGlmICggYXJjTGVuZ3Roc1sgaSBdID09PSB0YXJnZXRBcmNMZW5ndGggKSB7XG5cblx0XHRcdHJldHVybiBpIC8gKCBpbCAtIDEgKTtcblxuXHRcdH1cblxuXHRcdC8vIHdlIGNvdWxkIGdldCBmaW5lciBncmFpbiBhdCBsZW5ndGhzLCBvciB1c2Ugc2ltcGxlIGludGVycG9sYXRpb24gYmV0d2VlbiB0d28gcG9pbnRzXG5cblx0XHRjb25zdCBsZW5ndGhCZWZvcmUgPSBhcmNMZW5ndGhzWyBpIF07XG5cdFx0Y29uc3QgbGVuZ3RoQWZ0ZXIgPSBhcmNMZW5ndGhzWyBpICsgMSBdO1xuXG5cdFx0Y29uc3Qgc2VnbWVudExlbmd0aCA9IGxlbmd0aEFmdGVyIC0gbGVuZ3RoQmVmb3JlO1xuXG5cdFx0Ly8gZGV0ZXJtaW5lIHdoZXJlIHdlIGFyZSBiZXR3ZWVuIHRoZSAnYmVmb3JlJyBhbmQgJ2FmdGVyJyBwb2ludHNcblxuXHRcdGNvbnN0IHNlZ21lbnRGcmFjdGlvbiA9ICggdGFyZ2V0QXJjTGVuZ3RoIC0gbGVuZ3RoQmVmb3JlICkgLyBzZWdtZW50TGVuZ3RoO1xuXG5cdFx0Ly8gYWRkIHRoYXQgZnJhY3Rpb25hbCBhbW91bnQgdG8gdFxuXG5cdFx0Y29uc3QgdCA9ICggaSArIHNlZ21lbnRGcmFjdGlvbiApIC8gKCBpbCAtIDEgKTtcblxuXHRcdHJldHVybiB0O1xuXG5cdH1cblxuXHQvLyBSZXR1cm5zIGEgdW5pdCB2ZWN0b3IgdGFuZ2VudCBhdCB0XG5cdC8vIEluIGNhc2UgYW55IHN1YiBjdXJ2ZSBkb2VzIG5vdCBpbXBsZW1lbnQgaXRzIHRhbmdlbnQgZGVyaXZhdGlvbixcblx0Ly8gMiBwb2ludHMgYSBzbWFsbCBkZWx0YSBhcGFydCB3aWxsIGJlIHVzZWQgdG8gZmluZCBpdHMgZ3JhZGllbnRcblx0Ly8gd2hpY2ggc2VlbXMgdG8gZ2l2ZSBhIHJlYXNvbmFibGUgYXBwcm94aW1hdGlvblxuXG5cdGdldFRhbmdlbnQoIHQsIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG5cdFx0Y29uc3QgZGVsdGEgPSAwLjAwMDE7XG5cdFx0bGV0IHQxID0gdCAtIGRlbHRhO1xuXHRcdGxldCB0MiA9IHQgKyBkZWx0YTtcblxuXHRcdC8vIENhcHBpbmcgaW4gY2FzZSBvZiBkYW5nZXJcblxuXHRcdGlmICggdDEgPCAwICkgdDEgPSAwO1xuXHRcdGlmICggdDIgPiAxICkgdDIgPSAxO1xuXG5cdFx0Y29uc3QgcHQxID0gdGhpcy5nZXRQb2ludCggdDEgKTtcblx0XHRjb25zdCBwdDIgPSB0aGlzLmdldFBvaW50KCB0MiApO1xuXG5cdFx0Y29uc3QgdGFuZ2VudCA9IG9wdGlvbmFsVGFyZ2V0IHx8ICggKCBwdDEuaXNWZWN0b3IyICkgPyBuZXcgVmVjdG9yMigpIDogbmV3IFZlY3RvcjMoKSApO1xuXG5cdFx0dGFuZ2VudC5jb3B5KCBwdDIgKS5zdWIoIHB0MSApLm5vcm1hbGl6ZSgpO1xuXG5cdFx0cmV0dXJuIHRhbmdlbnQ7XG5cblx0fVxuXG5cdGdldFRhbmdlbnRBdCggdSwgb3B0aW9uYWxUYXJnZXQgKSB7XG5cblx0XHRjb25zdCB0ID0gdGhpcy5nZXRVdG9UbWFwcGluZyggdSApO1xuXHRcdHJldHVybiB0aGlzLmdldFRhbmdlbnQoIHQsIG9wdGlvbmFsVGFyZ2V0ICk7XG5cblx0fVxuXG5cdGNvbXB1dGVGcmVuZXRGcmFtZXMoIHNlZ21lbnRzLCBjbG9zZWQgKSB7XG5cblx0XHQvLyBzZWUgaHR0cDovL3d3dy5jcy5pbmRpYW5hLmVkdS9wdWIvdGVjaHJlcG9ydHMvVFI0MjUucGRmXG5cblx0XHRjb25zdCBub3JtYWwgPSBuZXcgVmVjdG9yMygpO1xuXG5cdFx0Y29uc3QgdGFuZ2VudHMgPSBbXTtcblx0XHRjb25zdCBub3JtYWxzID0gW107XG5cdFx0Y29uc3QgYmlub3JtYWxzID0gW107XG5cblx0XHRjb25zdCB2ZWMgPSBuZXcgVmVjdG9yMygpO1xuXHRcdGNvbnN0IG1hdCA9IG5ldyBNYXRyaXg0KCk7XG5cblx0XHQvLyBjb21wdXRlIHRoZSB0YW5nZW50IHZlY3RvcnMgZm9yIGVhY2ggc2VnbWVudCBvbiB0aGUgY3VydmVcblxuXHRcdGZvciAoIGxldCBpID0gMDsgaSA8PSBzZWdtZW50czsgaSArKyApIHtcblxuXHRcdFx0Y29uc3QgdSA9IGkgLyBzZWdtZW50cztcblxuXHRcdFx0dGFuZ2VudHNbIGkgXSA9IHRoaXMuZ2V0VGFuZ2VudEF0KCB1LCBuZXcgVmVjdG9yMygpICk7XG5cblx0XHR9XG5cblx0XHQvLyBzZWxlY3QgYW4gaW5pdGlhbCBub3JtYWwgdmVjdG9yIHBlcnBlbmRpY3VsYXIgdG8gdGhlIGZpcnN0IHRhbmdlbnQgdmVjdG9yLFxuXHRcdC8vIGFuZCBpbiB0aGUgZGlyZWN0aW9uIG9mIHRoZSBtaW5pbXVtIHRhbmdlbnQgeHl6IGNvbXBvbmVudFxuXG5cdFx0bm9ybWFsc1sgMCBdID0gbmV3IFZlY3RvcjMoKTtcblx0XHRiaW5vcm1hbHNbIDAgXSA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0bGV0IG1pbiA9IE51bWJlci5NQVhfVkFMVUU7XG5cdFx0Y29uc3QgdHggPSBNYXRoLmFicyggdGFuZ2VudHNbIDAgXS54ICk7XG5cdFx0Y29uc3QgdHkgPSBNYXRoLmFicyggdGFuZ2VudHNbIDAgXS55ICk7XG5cdFx0Y29uc3QgdHogPSBNYXRoLmFicyggdGFuZ2VudHNbIDAgXS56ICk7XG5cblx0XHRpZiAoIHR4IDw9IG1pbiApIHtcblxuXHRcdFx0bWluID0gdHg7XG5cdFx0XHRub3JtYWwuc2V0KCAxLCAwLCAwICk7XG5cblx0XHR9XG5cblx0XHRpZiAoIHR5IDw9IG1pbiApIHtcblxuXHRcdFx0bWluID0gdHk7XG5cdFx0XHRub3JtYWwuc2V0KCAwLCAxLCAwICk7XG5cblx0XHR9XG5cblx0XHRpZiAoIHR6IDw9IG1pbiApIHtcblxuXHRcdFx0bm9ybWFsLnNldCggMCwgMCwgMSApO1xuXG5cdFx0fVxuXG5cdFx0dmVjLmNyb3NzVmVjdG9ycyggdGFuZ2VudHNbIDAgXSwgbm9ybWFsICkubm9ybWFsaXplKCk7XG5cblx0XHRub3JtYWxzWyAwIF0uY3Jvc3NWZWN0b3JzKCB0YW5nZW50c1sgMCBdLCB2ZWMgKTtcblx0XHRiaW5vcm1hbHNbIDAgXS5jcm9zc1ZlY3RvcnMoIHRhbmdlbnRzWyAwIF0sIG5vcm1hbHNbIDAgXSApO1xuXG5cblx0XHQvLyBjb21wdXRlIHRoZSBzbG93bHktdmFyeWluZyBub3JtYWwgYW5kIGJpbm9ybWFsIHZlY3RvcnMgZm9yIGVhY2ggc2VnbWVudCBvbiB0aGUgY3VydmVcblxuXHRcdGZvciAoIGxldCBpID0gMTsgaSA8PSBzZWdtZW50czsgaSArKyApIHtcblxuXHRcdFx0bm9ybWFsc1sgaSBdID0gbm9ybWFsc1sgaSAtIDEgXS5jbG9uZSgpO1xuXG5cdFx0XHRiaW5vcm1hbHNbIGkgXSA9IGJpbm9ybWFsc1sgaSAtIDEgXS5jbG9uZSgpO1xuXG5cdFx0XHR2ZWMuY3Jvc3NWZWN0b3JzKCB0YW5nZW50c1sgaSAtIDEgXSwgdGFuZ2VudHNbIGkgXSApO1xuXG5cdFx0XHRpZiAoIHZlYy5sZW5ndGgoKSA+IE51bWJlci5FUFNJTE9OICkge1xuXG5cdFx0XHRcdHZlYy5ub3JtYWxpemUoKTtcblxuXHRcdFx0XHRjb25zdCB0aGV0YSA9IE1hdGguYWNvcyggTWF0aFV0aWxzLmNsYW1wKCB0YW5nZW50c1sgaSAtIDEgXS5kb3QoIHRhbmdlbnRzWyBpIF0gKSwgLSAxLCAxICkgKTsgLy8gY2xhbXAgZm9yIGZsb2F0aW5nIHB0IGVycm9yc1xuXG5cdFx0XHRcdG5vcm1hbHNbIGkgXS5hcHBseU1hdHJpeDQoIG1hdC5tYWtlUm90YXRpb25BeGlzKCB2ZWMsIHRoZXRhICkgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRiaW5vcm1hbHNbIGkgXS5jcm9zc1ZlY3RvcnMoIHRhbmdlbnRzWyBpIF0sIG5vcm1hbHNbIGkgXSApO1xuXG5cdFx0fVxuXG5cdFx0Ly8gaWYgdGhlIGN1cnZlIGlzIGNsb3NlZCwgcG9zdHByb2Nlc3MgdGhlIHZlY3RvcnMgc28gdGhlIGZpcnN0IGFuZCBsYXN0IG5vcm1hbCB2ZWN0b3JzIGFyZSB0aGUgc2FtZVxuXG5cdFx0aWYgKCBjbG9zZWQgPT09IHRydWUgKSB7XG5cblx0XHRcdGxldCB0aGV0YSA9IE1hdGguYWNvcyggTWF0aFV0aWxzLmNsYW1wKCBub3JtYWxzWyAwIF0uZG90KCBub3JtYWxzWyBzZWdtZW50cyBdICksIC0gMSwgMSApICk7XG5cdFx0XHR0aGV0YSAvPSBzZWdtZW50cztcblxuXHRcdFx0aWYgKCB0YW5nZW50c1sgMCBdLmRvdCggdmVjLmNyb3NzVmVjdG9ycyggbm9ybWFsc1sgMCBdLCBub3JtYWxzWyBzZWdtZW50cyBdICkgKSA+IDAgKSB7XG5cblx0XHRcdFx0dGhldGEgPSAtIHRoZXRhO1xuXG5cdFx0XHR9XG5cblx0XHRcdGZvciAoIGxldCBpID0gMTsgaSA8PSBzZWdtZW50czsgaSArKyApIHtcblxuXHRcdFx0XHQvLyB0d2lzdCBhIGxpdHRsZS4uLlxuXHRcdFx0XHRub3JtYWxzWyBpIF0uYXBwbHlNYXRyaXg0KCBtYXQubWFrZVJvdGF0aW9uQXhpcyggdGFuZ2VudHNbIGkgXSwgdGhldGEgKiBpICkgKTtcblx0XHRcdFx0Ymlub3JtYWxzWyBpIF0uY3Jvc3NWZWN0b3JzKCB0YW5nZW50c1sgaSBdLCBub3JtYWxzWyBpIF0gKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHtcblx0XHRcdHRhbmdlbnRzOiB0YW5nZW50cyxcblx0XHRcdG5vcm1hbHM6IG5vcm1hbHMsXG5cdFx0XHRiaW5vcm1hbHM6IGJpbm9ybWFsc1xuXHRcdH07XG5cblx0fVxuXG5cdGNsb25lKCkge1xuXG5cdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSggdGhpcyApO1xuXG5cdH1cblxuXHRjb3B5KCBzb3VyY2UgKSB7XG5cblx0XHR0aGlzLmFyY0xlbmd0aERpdmlzaW9ucyA9IHNvdXJjZS5hcmNMZW5ndGhEaXZpc2lvbnM7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0dG9KU09OKCkge1xuXG5cdFx0Y29uc3QgZGF0YSA9IHtcblx0XHRcdG1ldGFkYXRhOiB7XG5cdFx0XHRcdHZlcnNpb246IDQuNixcblx0XHRcdFx0dHlwZTogJ0N1cnZlJyxcblx0XHRcdFx0Z2VuZXJhdG9yOiAnQ3VydmUudG9KU09OJ1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRkYXRhLmFyY0xlbmd0aERpdmlzaW9ucyA9IHRoaXMuYXJjTGVuZ3RoRGl2aXNpb25zO1xuXHRcdGRhdGEudHlwZSA9IHRoaXMudHlwZTtcblxuXHRcdHJldHVybiBkYXRhO1xuXG5cdH1cblxuXHRmcm9tSlNPTigganNvbiApIHtcblxuXHRcdHRoaXMuYXJjTGVuZ3RoRGl2aXNpb25zID0ganNvbi5hcmNMZW5ndGhEaXZpc2lvbnM7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cbn1cblxuXG5leHBvcnQgeyBDdXJ2ZSB9O1xuIiwiaW1wb3J0IHsgQ3VydmUgfSBmcm9tICcuL0N1cnZlLmpzJztcbmltcG9ydCAqIGFzIEN1cnZlcyBmcm9tICcuLi9jdXJ2ZXMvQ3VydmVzLmpzJztcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKlx0Q3VydmVkIFBhdGggLSBhIGN1cnZlIHBhdGggaXMgc2ltcGx5IGEgYXJyYXkgb2YgY29ubmVjdGVkXG4gKiAgY3VydmVzLCBidXQgcmV0YWlucyB0aGUgYXBpIG9mIGEgY3VydmVcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuY2xhc3MgQ3VydmVQYXRoIGV4dGVuZHMgQ3VydmUge1xuXG5cdGNvbnN0cnVjdG9yKCkge1xuXG5cdFx0c3VwZXIoKTtcblxuXHRcdHRoaXMudHlwZSA9ICdDdXJ2ZVBhdGgnO1xuXG5cdFx0dGhpcy5jdXJ2ZXMgPSBbXTtcblx0XHR0aGlzLmF1dG9DbG9zZSA9IGZhbHNlOyAvLyBBdXRvbWF0aWNhbGx5IGNsb3NlcyB0aGUgcGF0aFxuXG5cdH1cblxuXHRhZGQoIGN1cnZlICkge1xuXG5cdFx0dGhpcy5jdXJ2ZXMucHVzaCggY3VydmUgKTtcblxuXHR9XG5cblx0Y2xvc2VQYXRoKCkge1xuXG5cdFx0Ly8gQWRkIGEgbGluZSBjdXJ2ZSBpZiBzdGFydCBhbmQgZW5kIG9mIGxpbmVzIGFyZSBub3QgY29ubmVjdGVkXG5cdFx0Y29uc3Qgc3RhcnRQb2ludCA9IHRoaXMuY3VydmVzWyAwIF0uZ2V0UG9pbnQoIDAgKTtcblx0XHRjb25zdCBlbmRQb2ludCA9IHRoaXMuY3VydmVzWyB0aGlzLmN1cnZlcy5sZW5ndGggLSAxIF0uZ2V0UG9pbnQoIDEgKTtcblxuXHRcdGlmICggISBzdGFydFBvaW50LmVxdWFscyggZW5kUG9pbnQgKSApIHtcblxuXHRcdFx0dGhpcy5jdXJ2ZXMucHVzaCggbmV3IEN1cnZlc1sgJ0xpbmVDdXJ2ZScgXSggZW5kUG9pbnQsIHN0YXJ0UG9pbnQgKSApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHQvLyBUbyBnZXQgYWNjdXJhdGUgcG9pbnQgd2l0aCByZWZlcmVuY2UgdG9cblx0Ly8gZW50aXJlIHBhdGggZGlzdGFuY2UgYXQgdGltZSB0LFxuXHQvLyBmb2xsb3dpbmcgaGFzIHRvIGJlIGRvbmU6XG5cblx0Ly8gMS4gTGVuZ3RoIG9mIGVhY2ggc3ViIHBhdGggaGF2ZSB0byBiZSBrbm93blxuXHQvLyAyLiBMb2NhdGUgYW5kIGlkZW50aWZ5IHR5cGUgb2YgY3VydmVcblx0Ly8gMy4gR2V0IHQgZm9yIHRoZSBjdXJ2ZVxuXHQvLyA0LiBSZXR1cm4gY3VydmUuZ2V0UG9pbnRBdCh0JylcblxuXHRnZXRQb2ludCggdCwgb3B0aW9uYWxUYXJnZXQgKSB7XG5cblx0XHRjb25zdCBkID0gdCAqIHRoaXMuZ2V0TGVuZ3RoKCk7XG5cdFx0Y29uc3QgY3VydmVMZW5ndGhzID0gdGhpcy5nZXRDdXJ2ZUxlbmd0aHMoKTtcblx0XHRsZXQgaSA9IDA7XG5cblx0XHQvLyBUbyB0aGluayBhYm91dCBib3VuZGFyaWVzIHBvaW50cy5cblxuXHRcdHdoaWxlICggaSA8IGN1cnZlTGVuZ3Rocy5sZW5ndGggKSB7XG5cblx0XHRcdGlmICggY3VydmVMZW5ndGhzWyBpIF0gPj0gZCApIHtcblxuXHRcdFx0XHRjb25zdCBkaWZmID0gY3VydmVMZW5ndGhzWyBpIF0gLSBkO1xuXHRcdFx0XHRjb25zdCBjdXJ2ZSA9IHRoaXMuY3VydmVzWyBpIF07XG5cblx0XHRcdFx0Y29uc3Qgc2VnbWVudExlbmd0aCA9IGN1cnZlLmdldExlbmd0aCgpO1xuXHRcdFx0XHRjb25zdCB1ID0gc2VnbWVudExlbmd0aCA9PT0gMCA/IDAgOiAxIC0gZGlmZiAvIHNlZ21lbnRMZW5ndGg7XG5cblx0XHRcdFx0cmV0dXJuIGN1cnZlLmdldFBvaW50QXQoIHUsIG9wdGlvbmFsVGFyZ2V0ICk7XG5cblx0XHRcdH1cblxuXHRcdFx0aSArKztcblxuXHRcdH1cblxuXHRcdHJldHVybiBudWxsO1xuXG5cdFx0Ly8gbG9vcCB3aGVyZSBzdW0gIT0gMCwgc3VtID4gZCAsIHN1bSsxIDxkXG5cblx0fVxuXG5cdC8vIFdlIGNhbm5vdCB1c2UgdGhlIGRlZmF1bHQgVEhSRUUuQ3VydmUgZ2V0UG9pbnQoKSB3aXRoIGdldExlbmd0aCgpIGJlY2F1c2UgaW5cblx0Ly8gVEhSRUUuQ3VydmUsIGdldExlbmd0aCgpIGRlcGVuZHMgb24gZ2V0UG9pbnQoKSBidXQgaW4gVEhSRUUuQ3VydmVQYXRoXG5cdC8vIGdldFBvaW50KCkgZGVwZW5kcyBvbiBnZXRMZW5ndGhcblxuXHRnZXRMZW5ndGgoKSB7XG5cblx0XHRjb25zdCBsZW5zID0gdGhpcy5nZXRDdXJ2ZUxlbmd0aHMoKTtcblx0XHRyZXR1cm4gbGVuc1sgbGVucy5sZW5ndGggLSAxIF07XG5cblx0fVxuXG5cdC8vIGNhY2hlTGVuZ3RocyBtdXN0IGJlIHJlY2FsY3VsYXRlZC5cblx0dXBkYXRlQXJjTGVuZ3RocygpIHtcblxuXHRcdHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xuXHRcdHRoaXMuY2FjaGVMZW5ndGhzID0gbnVsbDtcblx0XHR0aGlzLmdldEN1cnZlTGVuZ3RocygpO1xuXG5cdH1cblxuXHQvLyBDb21wdXRlIGxlbmd0aHMgYW5kIGNhY2hlIHRoZW1cblx0Ly8gV2UgY2Fubm90IG92ZXJ3cml0ZSBnZXRMZW5ndGhzKCkgYmVjYXVzZSBVdG9UIG1hcHBpbmcgdXNlcyBpdC5cblxuXHRnZXRDdXJ2ZUxlbmd0aHMoKSB7XG5cblx0XHQvLyBXZSB1c2UgY2FjaGUgdmFsdWVzIGlmIGN1cnZlcyBhbmQgY2FjaGUgYXJyYXkgYXJlIHNhbWUgbGVuZ3RoXG5cblx0XHRpZiAoIHRoaXMuY2FjaGVMZW5ndGhzICYmIHRoaXMuY2FjaGVMZW5ndGhzLmxlbmd0aCA9PT0gdGhpcy5jdXJ2ZXMubGVuZ3RoICkge1xuXG5cdFx0XHRyZXR1cm4gdGhpcy5jYWNoZUxlbmd0aHM7XG5cblx0XHR9XG5cblx0XHQvLyBHZXQgbGVuZ3RoIG9mIHN1Yi1jdXJ2ZVxuXHRcdC8vIFB1c2ggc3VtcyBpbnRvIGNhY2hlZCBhcnJheVxuXG5cdFx0Y29uc3QgbGVuZ3RocyA9IFtdO1xuXHRcdGxldCBzdW1zID0gMDtcblxuXHRcdGZvciAoIGxldCBpID0gMCwgbCA9IHRoaXMuY3VydmVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdHN1bXMgKz0gdGhpcy5jdXJ2ZXNbIGkgXS5nZXRMZW5ndGgoKTtcblx0XHRcdGxlbmd0aHMucHVzaCggc3VtcyApO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5jYWNoZUxlbmd0aHMgPSBsZW5ndGhzO1xuXG5cdFx0cmV0dXJuIGxlbmd0aHM7XG5cblx0fVxuXG5cdGdldFNwYWNlZFBvaW50cyggZGl2aXNpb25zID0gNDAgKSB7XG5cblx0XHRjb25zdCBwb2ludHMgPSBbXTtcblxuXHRcdGZvciAoIGxldCBpID0gMDsgaSA8PSBkaXZpc2lvbnM7IGkgKysgKSB7XG5cblx0XHRcdHBvaW50cy5wdXNoKCB0aGlzLmdldFBvaW50KCBpIC8gZGl2aXNpb25zICkgKTtcblxuXHRcdH1cblxuXHRcdGlmICggdGhpcy5hdXRvQ2xvc2UgKSB7XG5cblx0XHRcdHBvaW50cy5wdXNoKCBwb2ludHNbIDAgXSApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHBvaW50cztcblxuXHR9XG5cblx0Z2V0UG9pbnRzKCBkaXZpc2lvbnMgPSAxMiApIHtcblxuXHRcdGNvbnN0IHBvaW50cyA9IFtdO1xuXHRcdGxldCBsYXN0O1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBjdXJ2ZXMgPSB0aGlzLmN1cnZlczsgaSA8IGN1cnZlcy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdGNvbnN0IGN1cnZlID0gY3VydmVzWyBpIF07XG5cdFx0XHRjb25zdCByZXNvbHV0aW9uID0gY3VydmUuaXNFbGxpcHNlQ3VydmUgPyBkaXZpc2lvbnMgKiAyXG5cdFx0XHRcdDogKCBjdXJ2ZS5pc0xpbmVDdXJ2ZSB8fCBjdXJ2ZS5pc0xpbmVDdXJ2ZTMgKSA/IDFcblx0XHRcdFx0XHQ6IGN1cnZlLmlzU3BsaW5lQ3VydmUgPyBkaXZpc2lvbnMgKiBjdXJ2ZS5wb2ludHMubGVuZ3RoXG5cdFx0XHRcdFx0XHQ6IGRpdmlzaW9ucztcblxuXHRcdFx0Y29uc3QgcHRzID0gY3VydmUuZ2V0UG9pbnRzKCByZXNvbHV0aW9uICk7XG5cblx0XHRcdGZvciAoIGxldCBqID0gMDsgaiA8IHB0cy5sZW5ndGg7IGogKysgKSB7XG5cblx0XHRcdFx0Y29uc3QgcG9pbnQgPSBwdHNbIGogXTtcblxuXHRcdFx0XHRpZiAoIGxhc3QgJiYgbGFzdC5lcXVhbHMoIHBvaW50ICkgKSBjb250aW51ZTsgLy8gZW5zdXJlcyBubyBjb25zZWN1dGl2ZSBwb2ludHMgYXJlIGR1cGxpY2F0ZXNcblxuXHRcdFx0XHRwb2ludHMucHVzaCggcG9pbnQgKTtcblx0XHRcdFx0bGFzdCA9IHBvaW50O1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRpZiAoIHRoaXMuYXV0b0Nsb3NlICYmIHBvaW50cy5sZW5ndGggPiAxICYmICEgcG9pbnRzWyBwb2ludHMubGVuZ3RoIC0gMSBdLmVxdWFscyggcG9pbnRzWyAwIF0gKSApIHtcblxuXHRcdFx0cG9pbnRzLnB1c2goIHBvaW50c1sgMCBdICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gcG9pbnRzO1xuXG5cdH1cblxuXHRjb3B5KCBzb3VyY2UgKSB7XG5cblx0XHRzdXBlci5jb3B5KCBzb3VyY2UgKTtcblxuXHRcdHRoaXMuY3VydmVzID0gW107XG5cblx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBzb3VyY2UuY3VydmVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdGNvbnN0IGN1cnZlID0gc291cmNlLmN1cnZlc1sgaSBdO1xuXG5cdFx0XHR0aGlzLmN1cnZlcy5wdXNoKCBjdXJ2ZS5jbG9uZSgpICk7XG5cblx0XHR9XG5cblx0XHR0aGlzLmF1dG9DbG9zZSA9IHNvdXJjZS5hdXRvQ2xvc2U7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0dG9KU09OKCkge1xuXG5cdFx0Y29uc3QgZGF0YSA9IHN1cGVyLnRvSlNPTigpO1xuXG5cdFx0ZGF0YS5hdXRvQ2xvc2UgPSB0aGlzLmF1dG9DbG9zZTtcblx0XHRkYXRhLmN1cnZlcyA9IFtdO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gdGhpcy5jdXJ2ZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0Y29uc3QgY3VydmUgPSB0aGlzLmN1cnZlc1sgaSBdO1xuXHRcdFx0ZGF0YS5jdXJ2ZXMucHVzaCggY3VydmUudG9KU09OKCkgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBkYXRhO1xuXG5cdH1cblxuXHRmcm9tSlNPTigganNvbiApIHtcblxuXHRcdHN1cGVyLmZyb21KU09OKCBqc29uICk7XG5cblx0XHR0aGlzLmF1dG9DbG9zZSA9IGpzb24uYXV0b0Nsb3NlO1xuXHRcdHRoaXMuY3VydmVzID0gW107XG5cblx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBqc29uLmN1cnZlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRjb25zdCBjdXJ2ZSA9IGpzb24uY3VydmVzWyBpIF07XG5cdFx0XHR0aGlzLmN1cnZlcy5wdXNoKCBuZXcgQ3VydmVzWyBjdXJ2ZS50eXBlIF0oKS5mcm9tSlNPTiggY3VydmUgKSApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG59XG5cblxuZXhwb3J0IHsgQ3VydmVQYXRoIH07XG4iLCIvKipcbiAqIEJlemllciBDdXJ2ZXMgZm9ybXVsYXMgb2J0YWluZWQgZnJvbVxuICogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQiVDMyVBOXppZXJfY3VydmVcbiAqL1xuXG5mdW5jdGlvbiBDYXRtdWxsUm9tKCB0LCBwMCwgcDEsIHAyLCBwMyApIHtcblxuXHRjb25zdCB2MCA9ICggcDIgLSBwMCApICogMC41O1xuXHRjb25zdCB2MSA9ICggcDMgLSBwMSApICogMC41O1xuXHRjb25zdCB0MiA9IHQgKiB0O1xuXHRjb25zdCB0MyA9IHQgKiB0Mjtcblx0cmV0dXJuICggMiAqIHAxIC0gMiAqIHAyICsgdjAgKyB2MSApICogdDMgKyAoIC0gMyAqIHAxICsgMyAqIHAyIC0gMiAqIHYwIC0gdjEgKSAqIHQyICsgdjAgKiB0ICsgcDE7XG5cbn1cblxuLy9cblxuZnVuY3Rpb24gUXVhZHJhdGljQmV6aWVyUDAoIHQsIHAgKSB7XG5cblx0Y29uc3QgayA9IDEgLSB0O1xuXHRyZXR1cm4gayAqIGsgKiBwO1xuXG59XG5cbmZ1bmN0aW9uIFF1YWRyYXRpY0JlemllclAxKCB0LCBwICkge1xuXG5cdHJldHVybiAyICogKCAxIC0gdCApICogdCAqIHA7XG5cbn1cblxuZnVuY3Rpb24gUXVhZHJhdGljQmV6aWVyUDIoIHQsIHAgKSB7XG5cblx0cmV0dXJuIHQgKiB0ICogcDtcblxufVxuXG5mdW5jdGlvbiBRdWFkcmF0aWNCZXppZXIoIHQsIHAwLCBwMSwgcDIgKSB7XG5cblx0cmV0dXJuIFF1YWRyYXRpY0JlemllclAwKCB0LCBwMCApICsgUXVhZHJhdGljQmV6aWVyUDEoIHQsIHAxICkgK1xuXHRcdFF1YWRyYXRpY0JlemllclAyKCB0LCBwMiApO1xuXG59XG5cbi8vXG5cbmZ1bmN0aW9uIEN1YmljQmV6aWVyUDAoIHQsIHAgKSB7XG5cblx0Y29uc3QgayA9IDEgLSB0O1xuXHRyZXR1cm4gayAqIGsgKiBrICogcDtcblxufVxuXG5mdW5jdGlvbiBDdWJpY0JlemllclAxKCB0LCBwICkge1xuXG5cdGNvbnN0IGsgPSAxIC0gdDtcblx0cmV0dXJuIDMgKiBrICogayAqIHQgKiBwO1xuXG59XG5cbmZ1bmN0aW9uIEN1YmljQmV6aWVyUDIoIHQsIHAgKSB7XG5cblx0cmV0dXJuIDMgKiAoIDEgLSB0ICkgKiB0ICogdCAqIHA7XG5cbn1cblxuZnVuY3Rpb24gQ3ViaWNCZXppZXJQMyggdCwgcCApIHtcblxuXHRyZXR1cm4gdCAqIHQgKiB0ICogcDtcblxufVxuXG5mdW5jdGlvbiBDdWJpY0JlemllciggdCwgcDAsIHAxLCBwMiwgcDMgKSB7XG5cblx0cmV0dXJuIEN1YmljQmV6aWVyUDAoIHQsIHAwICkgKyBDdWJpY0JlemllclAxKCB0LCBwMSApICsgQ3ViaWNCZXppZXJQMiggdCwgcDIgKSArXG5cdFx0Q3ViaWNCZXppZXJQMyggdCwgcDMgKTtcblxufVxuXG5leHBvcnQgeyBDYXRtdWxsUm9tLCBRdWFkcmF0aWNCZXppZXIsIEN1YmljQmV6aWVyIH07XG4iLCJpbXBvcnQgeyBWZWN0b3IyIH0gZnJvbSAnLi4vLi4vbWF0aC9WZWN0b3IyLmpzJztcbmltcG9ydCB7IEN1cnZlUGF0aCB9IGZyb20gJy4vQ3VydmVQYXRoLmpzJztcbmltcG9ydCB7IEVsbGlwc2VDdXJ2ZSB9IGZyb20gJy4uL2N1cnZlcy9FbGxpcHNlQ3VydmUuanMnO1xuaW1wb3J0IHsgU3BsaW5lQ3VydmUgfSBmcm9tICcuLi9jdXJ2ZXMvU3BsaW5lQ3VydmUuanMnO1xuaW1wb3J0IHsgQ3ViaWNCZXppZXJDdXJ2ZSB9IGZyb20gJy4uL2N1cnZlcy9DdWJpY0JlemllckN1cnZlLmpzJztcbmltcG9ydCB7IFF1YWRyYXRpY0JlemllckN1cnZlIH0gZnJvbSAnLi4vY3VydmVzL1F1YWRyYXRpY0JlemllckN1cnZlLmpzJztcbmltcG9ydCB7IExpbmVDdXJ2ZSB9IGZyb20gJy4uL2N1cnZlcy9MaW5lQ3VydmUuanMnO1xuXG5jbGFzcyBQYXRoIGV4dGVuZHMgQ3VydmVQYXRoIHtcblxuXHRjb25zdHJ1Y3RvciggcG9pbnRzICkge1xuXG5cdFx0c3VwZXIoKTtcblxuXHRcdHRoaXMudHlwZSA9ICdQYXRoJztcblxuXHRcdHRoaXMuY3VycmVudFBvaW50ID0gbmV3IFZlY3RvcjIoKTtcblxuXHRcdGlmICggcG9pbnRzICkge1xuXG5cdFx0XHR0aGlzLnNldEZyb21Qb2ludHMoIHBvaW50cyApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRzZXRGcm9tUG9pbnRzKCBwb2ludHMgKSB7XG5cblx0XHR0aGlzLm1vdmVUbyggcG9pbnRzWyAwIF0ueCwgcG9pbnRzWyAwIF0ueSApO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAxLCBsID0gcG9pbnRzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdHRoaXMubGluZVRvKCBwb2ludHNbIGkgXS54LCBwb2ludHNbIGkgXS55ICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0bW92ZVRvKCB4LCB5ICkge1xuXG5cdFx0dGhpcy5jdXJyZW50UG9pbnQuc2V0KCB4LCB5ICk7IC8vIFRPRE8gY29uc2lkZXIgcmVmZXJlbmNpbmcgdmVjdG9ycyBpbnN0ZWFkIG9mIGNvcHlpbmc/XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0bGluZVRvKCB4LCB5ICkge1xuXG5cdFx0Y29uc3QgY3VydmUgPSBuZXcgTGluZUN1cnZlKCB0aGlzLmN1cnJlbnRQb2ludC5jbG9uZSgpLCBuZXcgVmVjdG9yMiggeCwgeSApICk7XG5cdFx0dGhpcy5jdXJ2ZXMucHVzaCggY3VydmUgKTtcblxuXHRcdHRoaXMuY3VycmVudFBvaW50LnNldCggeCwgeSApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHF1YWRyYXRpY0N1cnZlVG8oIGFDUHgsIGFDUHksIGFYLCBhWSApIHtcblxuXHRcdGNvbnN0IGN1cnZlID0gbmV3IFF1YWRyYXRpY0JlemllckN1cnZlKFxuXHRcdFx0dGhpcy5jdXJyZW50UG9pbnQuY2xvbmUoKSxcblx0XHRcdG5ldyBWZWN0b3IyKCBhQ1B4LCBhQ1B5ICksXG5cdFx0XHRuZXcgVmVjdG9yMiggYVgsIGFZIClcblx0XHQpO1xuXG5cdFx0dGhpcy5jdXJ2ZXMucHVzaCggY3VydmUgKTtcblxuXHRcdHRoaXMuY3VycmVudFBvaW50LnNldCggYVgsIGFZICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0YmV6aWVyQ3VydmVUbyggYUNQMXgsIGFDUDF5LCBhQ1AyeCwgYUNQMnksIGFYLCBhWSApIHtcblxuXHRcdGNvbnN0IGN1cnZlID0gbmV3IEN1YmljQmV6aWVyQ3VydmUoXG5cdFx0XHR0aGlzLmN1cnJlbnRQb2ludC5jbG9uZSgpLFxuXHRcdFx0bmV3IFZlY3RvcjIoIGFDUDF4LCBhQ1AxeSApLFxuXHRcdFx0bmV3IFZlY3RvcjIoIGFDUDJ4LCBhQ1AyeSApLFxuXHRcdFx0bmV3IFZlY3RvcjIoIGFYLCBhWSApXG5cdFx0KTtcblxuXHRcdHRoaXMuY3VydmVzLnB1c2goIGN1cnZlICk7XG5cblx0XHR0aGlzLmN1cnJlbnRQb2ludC5zZXQoIGFYLCBhWSApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHNwbGluZVRocnUoIHB0cyAvKkFycmF5IG9mIFZlY3RvciovICkge1xuXG5cdFx0Y29uc3QgbnB0cyA9IFsgdGhpcy5jdXJyZW50UG9pbnQuY2xvbmUoKSBdLmNvbmNhdCggcHRzICk7XG5cblx0XHRjb25zdCBjdXJ2ZSA9IG5ldyBTcGxpbmVDdXJ2ZSggbnB0cyApO1xuXHRcdHRoaXMuY3VydmVzLnB1c2goIGN1cnZlICk7XG5cblx0XHR0aGlzLmN1cnJlbnRQb2ludC5jb3B5KCBwdHNbIHB0cy5sZW5ndGggLSAxIF0gKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRhcmMoIGFYLCBhWSwgYVJhZGl1cywgYVN0YXJ0QW5nbGUsIGFFbmRBbmdsZSwgYUNsb2Nrd2lzZSApIHtcblxuXHRcdGNvbnN0IHgwID0gdGhpcy5jdXJyZW50UG9pbnQueDtcblx0XHRjb25zdCB5MCA9IHRoaXMuY3VycmVudFBvaW50Lnk7XG5cblx0XHR0aGlzLmFic2FyYyggYVggKyB4MCwgYVkgKyB5MCwgYVJhZGl1cyxcblx0XHRcdGFTdGFydEFuZ2xlLCBhRW5kQW5nbGUsIGFDbG9ja3dpc2UgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRhYnNhcmMoIGFYLCBhWSwgYVJhZGl1cywgYVN0YXJ0QW5nbGUsIGFFbmRBbmdsZSwgYUNsb2Nrd2lzZSApIHtcblxuXHRcdHRoaXMuYWJzZWxsaXBzZSggYVgsIGFZLCBhUmFkaXVzLCBhUmFkaXVzLCBhU3RhcnRBbmdsZSwgYUVuZEFuZ2xlLCBhQ2xvY2t3aXNlICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0ZWxsaXBzZSggYVgsIGFZLCB4UmFkaXVzLCB5UmFkaXVzLCBhU3RhcnRBbmdsZSwgYUVuZEFuZ2xlLCBhQ2xvY2t3aXNlLCBhUm90YXRpb24gKSB7XG5cblx0XHRjb25zdCB4MCA9IHRoaXMuY3VycmVudFBvaW50Lng7XG5cdFx0Y29uc3QgeTAgPSB0aGlzLmN1cnJlbnRQb2ludC55O1xuXG5cdFx0dGhpcy5hYnNlbGxpcHNlKCBhWCArIHgwLCBhWSArIHkwLCB4UmFkaXVzLCB5UmFkaXVzLCBhU3RhcnRBbmdsZSwgYUVuZEFuZ2xlLCBhQ2xvY2t3aXNlLCBhUm90YXRpb24gKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRhYnNlbGxpcHNlKCBhWCwgYVksIHhSYWRpdXMsIHlSYWRpdXMsIGFTdGFydEFuZ2xlLCBhRW5kQW5nbGUsIGFDbG9ja3dpc2UsIGFSb3RhdGlvbiApIHtcblxuXHRcdGNvbnN0IGN1cnZlID0gbmV3IEVsbGlwc2VDdXJ2ZSggYVgsIGFZLCB4UmFkaXVzLCB5UmFkaXVzLCBhU3RhcnRBbmdsZSwgYUVuZEFuZ2xlLCBhQ2xvY2t3aXNlLCBhUm90YXRpb24gKTtcblxuXHRcdGlmICggdGhpcy5jdXJ2ZXMubGVuZ3RoID4gMCApIHtcblxuXHRcdFx0Ly8gaWYgYSBwcmV2aW91cyBjdXJ2ZSBpcyBwcmVzZW50LCBhdHRlbXB0IHRvIGpvaW5cblx0XHRcdGNvbnN0IGZpcnN0UG9pbnQgPSBjdXJ2ZS5nZXRQb2ludCggMCApO1xuXG5cdFx0XHRpZiAoICEgZmlyc3RQb2ludC5lcXVhbHMoIHRoaXMuY3VycmVudFBvaW50ICkgKSB7XG5cblx0XHRcdFx0dGhpcy5saW5lVG8oIGZpcnN0UG9pbnQueCwgZmlyc3RQb2ludC55ICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHRoaXMuY3VydmVzLnB1c2goIGN1cnZlICk7XG5cblx0XHRjb25zdCBsYXN0UG9pbnQgPSBjdXJ2ZS5nZXRQb2ludCggMSApO1xuXHRcdHRoaXMuY3VycmVudFBvaW50LmNvcHkoIGxhc3RQb2ludCApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGNvcHkoIHNvdXJjZSApIHtcblxuXHRcdHN1cGVyLmNvcHkoIHNvdXJjZSApO1xuXG5cdFx0dGhpcy5jdXJyZW50UG9pbnQuY29weSggc291cmNlLmN1cnJlbnRQb2ludCApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHRvSlNPTigpIHtcblxuXHRcdGNvbnN0IGRhdGEgPSBzdXBlci50b0pTT04oKTtcblxuXHRcdGRhdGEuY3VycmVudFBvaW50ID0gdGhpcy5jdXJyZW50UG9pbnQudG9BcnJheSgpO1xuXG5cdFx0cmV0dXJuIGRhdGE7XG5cblx0fVxuXG5cdGZyb21KU09OKCBqc29uICkge1xuXG5cdFx0c3VwZXIuZnJvbUpTT04oIGpzb24gKTtcblxuXHRcdHRoaXMuY3VycmVudFBvaW50LmZyb21BcnJheSgganNvbi5jdXJyZW50UG9pbnQgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxufVxuXG5cbmV4cG9ydCB7IFBhdGggfTtcbiIsImltcG9ydCB7IFBhdGggfSBmcm9tICcuL1BhdGguanMnO1xuaW1wb3J0ICogYXMgTWF0aFV0aWxzIGZyb20gJy4uLy4uL21hdGgvTWF0aFV0aWxzLmpzJztcblxuY2xhc3MgU2hhcGUgZXh0ZW5kcyBQYXRoIHtcblxuXHRjb25zdHJ1Y3RvciggcG9pbnRzICkge1xuXG5cdFx0c3VwZXIoIHBvaW50cyApO1xuXG5cdFx0dGhpcy51dWlkID0gTWF0aFV0aWxzLmdlbmVyYXRlVVVJRCgpO1xuXG5cdFx0dGhpcy50eXBlID0gJ1NoYXBlJztcblxuXHRcdHRoaXMuaG9sZXMgPSBbXTtcblxuXHR9XG5cblx0Z2V0UG9pbnRzSG9sZXMoIGRpdmlzaW9ucyApIHtcblxuXHRcdGNvbnN0IGhvbGVzUHRzID0gW107XG5cblx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSB0aGlzLmhvbGVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdGhvbGVzUHRzWyBpIF0gPSB0aGlzLmhvbGVzWyBpIF0uZ2V0UG9pbnRzKCBkaXZpc2lvbnMgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBob2xlc1B0cztcblxuXHR9XG5cblx0Ly8gZ2V0IHBvaW50cyBvZiBzaGFwZSBhbmQgaG9sZXMgKGtleXBvaW50cyBiYXNlZCBvbiBzZWdtZW50cyBwYXJhbWV0ZXIpXG5cblx0ZXh0cmFjdFBvaW50cyggZGl2aXNpb25zICkge1xuXG5cdFx0cmV0dXJuIHtcblxuXHRcdFx0c2hhcGU6IHRoaXMuZ2V0UG9pbnRzKCBkaXZpc2lvbnMgKSxcblx0XHRcdGhvbGVzOiB0aGlzLmdldFBvaW50c0hvbGVzKCBkaXZpc2lvbnMgKVxuXG5cdFx0fTtcblxuXHR9XG5cblx0Y29weSggc291cmNlICkge1xuXG5cdFx0c3VwZXIuY29weSggc291cmNlICk7XG5cblx0XHR0aGlzLmhvbGVzID0gW107XG5cblx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBzb3VyY2UuaG9sZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0Y29uc3QgaG9sZSA9IHNvdXJjZS5ob2xlc1sgaSBdO1xuXG5cdFx0XHR0aGlzLmhvbGVzLnB1c2goIGhvbGUuY2xvbmUoKSApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHRvSlNPTigpIHtcblxuXHRcdGNvbnN0IGRhdGEgPSBzdXBlci50b0pTT04oKTtcblxuXHRcdGRhdGEudXVpZCA9IHRoaXMudXVpZDtcblx0XHRkYXRhLmhvbGVzID0gW107XG5cblx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSB0aGlzLmhvbGVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdGNvbnN0IGhvbGUgPSB0aGlzLmhvbGVzWyBpIF07XG5cdFx0XHRkYXRhLmhvbGVzLnB1c2goIGhvbGUudG9KU09OKCkgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBkYXRhO1xuXG5cdH1cblxuXHRmcm9tSlNPTigganNvbiApIHtcblxuXHRcdHN1cGVyLmZyb21KU09OKCBqc29uICk7XG5cblx0XHR0aGlzLnV1aWQgPSBqc29uLnV1aWQ7XG5cdFx0dGhpcy5ob2xlcyA9IFtdO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBsID0ganNvbi5ob2xlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRjb25zdCBob2xlID0ganNvbi5ob2xlc1sgaSBdO1xuXHRcdFx0dGhpcy5ob2xlcy5wdXNoKCBuZXcgUGF0aCgpLmZyb21KU09OKCBob2xlICkgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxufVxuXG5cbmV4cG9ydCB7IFNoYXBlIH07XG4iLCJpbXBvcnQgeyBFbGxpcHNlQ3VydmUgfSBmcm9tICcuL0VsbGlwc2VDdXJ2ZS5qcyc7XG5cbmNsYXNzIEFyY0N1cnZlIGV4dGVuZHMgRWxsaXBzZUN1cnZlIHtcblxuXHRjb25zdHJ1Y3RvciggYVgsIGFZLCBhUmFkaXVzLCBhU3RhcnRBbmdsZSwgYUVuZEFuZ2xlLCBhQ2xvY2t3aXNlICkge1xuXG5cdFx0c3VwZXIoIGFYLCBhWSwgYVJhZGl1cywgYVJhZGl1cywgYVN0YXJ0QW5nbGUsIGFFbmRBbmdsZSwgYUNsb2Nrd2lzZSApO1xuXG5cdFx0dGhpcy5pc0FyY0N1cnZlID0gdHJ1ZTtcblxuXHRcdHRoaXMudHlwZSA9ICdBcmNDdXJ2ZSc7XG5cblx0fVxuXG59XG5cbmV4cG9ydCB7IEFyY0N1cnZlIH07XG4iLCJpbXBvcnQgeyBWZWN0b3IzIH0gZnJvbSAnLi4vLi4vbWF0aC9WZWN0b3IzLmpzJztcbmltcG9ydCB7IEN1cnZlIH0gZnJvbSAnLi4vY29yZS9DdXJ2ZS5qcyc7XG5cbi8qKlxuICogQ2VudHJpcGV0YWwgQ2F0bXVsbFJvbSBDdXJ2ZSAtIHdoaWNoIGlzIHVzZWZ1bCBmb3IgYXZvaWRpbmdcbiAqIGN1c3BzIGFuZCBzZWxmLWludGVyc2VjdGlvbnMgaW4gbm9uLXVuaWZvcm0gY2F0bXVsbCByb20gY3VydmVzLlxuICogaHR0cDovL3d3dy5jZW15dWtzZWwuY29tL3Jlc2VhcmNoL2NhdG11bGxyb21fcGFyYW0vY2F0bXVsbHJvbS5wZGZcbiAqXG4gKiBjdXJ2ZS50eXBlIGFjY2VwdHMgY2VudHJpcGV0YWwoZGVmYXVsdCksIGNob3JkYWwgYW5kIGNhdG11bGxyb21cbiAqIGN1cnZlLnRlbnNpb24gaXMgdXNlZCBmb3IgY2F0bXVsbHJvbSB3aGljaCBkZWZhdWx0cyB0byAwLjVcbiAqL1xuXG5cbi8qXG5CYXNlZCBvbiBhbiBvcHRpbWl6ZWQgYysrIHNvbHV0aW9uIGluXG4gLSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzk0ODk3MzYvY2F0bXVsbC1yb20tY3VydmUtd2l0aC1uby1jdXNwcy1hbmQtbm8tc2VsZi1pbnRlcnNlY3Rpb25zL1xuIC0gaHR0cDovL2lkZW9uZS5jb20vTm9FYlZNXG5cblRoaXMgQ3ViaWNQb2x5IGNsYXNzIGNvdWxkIGJlIHVzZWQgZm9yIHJldXNpbmcgc29tZSB2YXJpYWJsZXMgYW5kIGNhbGN1bGF0aW9ucyxcbmJ1dCBmb3IgdGhyZWUuanMgY3VydmUgdXNlLCBpdCBjb3VsZCBiZSBwb3NzaWJsZSBpbmxpbmVkIGFuZCBmbGF0dGVuIGludG8gYSBzaW5nbGUgZnVuY3Rpb24gY2FsbFxud2hpY2ggY2FuIGJlIHBsYWNlZCBpbiBDdXJ2ZVV0aWxzLlxuKi9cblxuZnVuY3Rpb24gQ3ViaWNQb2x5KCkge1xuXG5cdGxldCBjMCA9IDAsIGMxID0gMCwgYzIgPSAwLCBjMyA9IDA7XG5cblx0Lypcblx0ICogQ29tcHV0ZSBjb2VmZmljaWVudHMgZm9yIGEgY3ViaWMgcG9seW5vbWlhbFxuXHQgKiAgIHAocykgPSBjMCArIGMxKnMgKyBjMipzXjIgKyBjMypzXjNcblx0ICogc3VjaCB0aGF0XG5cdCAqICAgcCgwKSA9IHgwLCBwKDEpID0geDFcblx0ICogIGFuZFxuXHQgKiAgIHAnKDApID0gdDAsIHAnKDEpID0gdDEuXG5cdCAqL1xuXHRmdW5jdGlvbiBpbml0KCB4MCwgeDEsIHQwLCB0MSApIHtcblxuXHRcdGMwID0geDA7XG5cdFx0YzEgPSB0MDtcblx0XHRjMiA9IC0gMyAqIHgwICsgMyAqIHgxIC0gMiAqIHQwIC0gdDE7XG5cdFx0YzMgPSAyICogeDAgLSAyICogeDEgKyB0MCArIHQxO1xuXG5cdH1cblxuXHRyZXR1cm4ge1xuXG5cdFx0aW5pdENhdG11bGxSb206IGZ1bmN0aW9uICggeDAsIHgxLCB4MiwgeDMsIHRlbnNpb24gKSB7XG5cblx0XHRcdGluaXQoIHgxLCB4MiwgdGVuc2lvbiAqICggeDIgLSB4MCApLCB0ZW5zaW9uICogKCB4MyAtIHgxICkgKTtcblxuXHRcdH0sXG5cblx0XHRpbml0Tm9udW5pZm9ybUNhdG11bGxSb206IGZ1bmN0aW9uICggeDAsIHgxLCB4MiwgeDMsIGR0MCwgZHQxLCBkdDIgKSB7XG5cblx0XHRcdC8vIGNvbXB1dGUgdGFuZ2VudHMgd2hlbiBwYXJhbWV0ZXJpemVkIGluIFt0MSx0Ml1cblx0XHRcdGxldCB0MSA9ICggeDEgLSB4MCApIC8gZHQwIC0gKCB4MiAtIHgwICkgLyAoIGR0MCArIGR0MSApICsgKCB4MiAtIHgxICkgLyBkdDE7XG5cdFx0XHRsZXQgdDIgPSAoIHgyIC0geDEgKSAvIGR0MSAtICggeDMgLSB4MSApIC8gKCBkdDEgKyBkdDIgKSArICggeDMgLSB4MiApIC8gZHQyO1xuXG5cdFx0XHQvLyByZXNjYWxlIHRhbmdlbnRzIGZvciBwYXJhbWV0cml6YXRpb24gaW4gWzAsMV1cblx0XHRcdHQxICo9IGR0MTtcblx0XHRcdHQyICo9IGR0MTtcblxuXHRcdFx0aW5pdCggeDEsIHgyLCB0MSwgdDIgKTtcblxuXHRcdH0sXG5cblx0XHRjYWxjOiBmdW5jdGlvbiAoIHQgKSB7XG5cblx0XHRcdGNvbnN0IHQyID0gdCAqIHQ7XG5cdFx0XHRjb25zdCB0MyA9IHQyICogdDtcblx0XHRcdHJldHVybiBjMCArIGMxICogdCArIGMyICogdDIgKyBjMyAqIHQzO1xuXG5cdFx0fVxuXG5cdH07XG5cbn1cblxuLy9cblxuY29uc3QgdG1wID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xuY29uc3QgcHggPSAvKkBfX1BVUkVfXyovIG5ldyBDdWJpY1BvbHkoKTtcbmNvbnN0IHB5ID0gLypAX19QVVJFX18qLyBuZXcgQ3ViaWNQb2x5KCk7XG5jb25zdCBweiA9IC8qQF9fUFVSRV9fKi8gbmV3IEN1YmljUG9seSgpO1xuXG5jbGFzcyBDYXRtdWxsUm9tQ3VydmUzIGV4dGVuZHMgQ3VydmUge1xuXG5cdGNvbnN0cnVjdG9yKCBwb2ludHMgPSBbXSwgY2xvc2VkID0gZmFsc2UsIGN1cnZlVHlwZSA9ICdjZW50cmlwZXRhbCcsIHRlbnNpb24gPSAwLjUgKSB7XG5cblx0XHRzdXBlcigpO1xuXG5cdFx0dGhpcy5pc0NhdG11bGxSb21DdXJ2ZTMgPSB0cnVlO1xuXG5cdFx0dGhpcy50eXBlID0gJ0NhdG11bGxSb21DdXJ2ZTMnO1xuXG5cdFx0dGhpcy5wb2ludHMgPSBwb2ludHM7XG5cdFx0dGhpcy5jbG9zZWQgPSBjbG9zZWQ7XG5cdFx0dGhpcy5jdXJ2ZVR5cGUgPSBjdXJ2ZVR5cGU7XG5cdFx0dGhpcy50ZW5zaW9uID0gdGVuc2lvbjtcblxuXHR9XG5cblx0Z2V0UG9pbnQoIHQsIG9wdGlvbmFsVGFyZ2V0ID0gbmV3IFZlY3RvcjMoKSApIHtcblxuXHRcdGNvbnN0IHBvaW50ID0gb3B0aW9uYWxUYXJnZXQ7XG5cblx0XHRjb25zdCBwb2ludHMgPSB0aGlzLnBvaW50cztcblx0XHRjb25zdCBsID0gcG9pbnRzLmxlbmd0aDtcblxuXHRcdGNvbnN0IHAgPSAoIGwgLSAoIHRoaXMuY2xvc2VkID8gMCA6IDEgKSApICogdDtcblx0XHRsZXQgaW50UG9pbnQgPSBNYXRoLmZsb29yKCBwICk7XG5cdFx0bGV0IHdlaWdodCA9IHAgLSBpbnRQb2ludDtcblxuXHRcdGlmICggdGhpcy5jbG9zZWQgKSB7XG5cblx0XHRcdGludFBvaW50ICs9IGludFBvaW50ID4gMCA/IDAgOiAoIE1hdGguZmxvb3IoIE1hdGguYWJzKCBpbnRQb2ludCApIC8gbCApICsgMSApICogbDtcblxuXHRcdH0gZWxzZSBpZiAoIHdlaWdodCA9PT0gMCAmJiBpbnRQb2ludCA9PT0gbCAtIDEgKSB7XG5cblx0XHRcdGludFBvaW50ID0gbCAtIDI7XG5cdFx0XHR3ZWlnaHQgPSAxO1xuXG5cdFx0fVxuXG5cdFx0bGV0IHAwLCBwMzsgLy8gNCBwb2ludHMgKHAxICYgcDIgZGVmaW5lZCBiZWxvdylcblxuXHRcdGlmICggdGhpcy5jbG9zZWQgfHwgaW50UG9pbnQgPiAwICkge1xuXG5cdFx0XHRwMCA9IHBvaW50c1sgKCBpbnRQb2ludCAtIDEgKSAlIGwgXTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIGV4dHJhcG9sYXRlIGZpcnN0IHBvaW50XG5cdFx0XHR0bXAuc3ViVmVjdG9ycyggcG9pbnRzWyAwIF0sIHBvaW50c1sgMSBdICkuYWRkKCBwb2ludHNbIDAgXSApO1xuXHRcdFx0cDAgPSB0bXA7XG5cblx0XHR9XG5cblx0XHRjb25zdCBwMSA9IHBvaW50c1sgaW50UG9pbnQgJSBsIF07XG5cdFx0Y29uc3QgcDIgPSBwb2ludHNbICggaW50UG9pbnQgKyAxICkgJSBsIF07XG5cblx0XHRpZiAoIHRoaXMuY2xvc2VkIHx8IGludFBvaW50ICsgMiA8IGwgKSB7XG5cblx0XHRcdHAzID0gcG9pbnRzWyAoIGludFBvaW50ICsgMiApICUgbCBdO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gZXh0cmFwb2xhdGUgbGFzdCBwb2ludFxuXHRcdFx0dG1wLnN1YlZlY3RvcnMoIHBvaW50c1sgbCAtIDEgXSwgcG9pbnRzWyBsIC0gMiBdICkuYWRkKCBwb2ludHNbIGwgLSAxIF0gKTtcblx0XHRcdHAzID0gdG1wO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLmN1cnZlVHlwZSA9PT0gJ2NlbnRyaXBldGFsJyB8fCB0aGlzLmN1cnZlVHlwZSA9PT0gJ2Nob3JkYWwnICkge1xuXG5cdFx0XHQvLyBpbml0IENlbnRyaXBldGFsIC8gQ2hvcmRhbCBDYXRtdWxsLVJvbVxuXHRcdFx0Y29uc3QgcG93ID0gdGhpcy5jdXJ2ZVR5cGUgPT09ICdjaG9yZGFsJyA/IDAuNSA6IDAuMjU7XG5cdFx0XHRsZXQgZHQwID0gTWF0aC5wb3coIHAwLmRpc3RhbmNlVG9TcXVhcmVkKCBwMSApLCBwb3cgKTtcblx0XHRcdGxldCBkdDEgPSBNYXRoLnBvdyggcDEuZGlzdGFuY2VUb1NxdWFyZWQoIHAyICksIHBvdyApO1xuXHRcdFx0bGV0IGR0MiA9IE1hdGgucG93KCBwMi5kaXN0YW5jZVRvU3F1YXJlZCggcDMgKSwgcG93ICk7XG5cblx0XHRcdC8vIHNhZmV0eSBjaGVjayBmb3IgcmVwZWF0ZWQgcG9pbnRzXG5cdFx0XHRpZiAoIGR0MSA8IDFlLTQgKSBkdDEgPSAxLjA7XG5cdFx0XHRpZiAoIGR0MCA8IDFlLTQgKSBkdDAgPSBkdDE7XG5cdFx0XHRpZiAoIGR0MiA8IDFlLTQgKSBkdDIgPSBkdDE7XG5cblx0XHRcdHB4LmluaXROb251bmlmb3JtQ2F0bXVsbFJvbSggcDAueCwgcDEueCwgcDIueCwgcDMueCwgZHQwLCBkdDEsIGR0MiApO1xuXHRcdFx0cHkuaW5pdE5vbnVuaWZvcm1DYXRtdWxsUm9tKCBwMC55LCBwMS55LCBwMi55LCBwMy55LCBkdDAsIGR0MSwgZHQyICk7XG5cdFx0XHRwei5pbml0Tm9udW5pZm9ybUNhdG11bGxSb20oIHAwLnosIHAxLnosIHAyLnosIHAzLnosIGR0MCwgZHQxLCBkdDIgKTtcblxuXHRcdH0gZWxzZSBpZiAoIHRoaXMuY3VydmVUeXBlID09PSAnY2F0bXVsbHJvbScgKSB7XG5cblx0XHRcdHB4LmluaXRDYXRtdWxsUm9tKCBwMC54LCBwMS54LCBwMi54LCBwMy54LCB0aGlzLnRlbnNpb24gKTtcblx0XHRcdHB5LmluaXRDYXRtdWxsUm9tKCBwMC55LCBwMS55LCBwMi55LCBwMy55LCB0aGlzLnRlbnNpb24gKTtcblx0XHRcdHB6LmluaXRDYXRtdWxsUm9tKCBwMC56LCBwMS56LCBwMi56LCBwMy56LCB0aGlzLnRlbnNpb24gKTtcblxuXHRcdH1cblxuXHRcdHBvaW50LnNldChcblx0XHRcdHB4LmNhbGMoIHdlaWdodCApLFxuXHRcdFx0cHkuY2FsYyggd2VpZ2h0ICksXG5cdFx0XHRwei5jYWxjKCB3ZWlnaHQgKVxuXHRcdCk7XG5cblx0XHRyZXR1cm4gcG9pbnQ7XG5cblx0fVxuXG5cdGNvcHkoIHNvdXJjZSApIHtcblxuXHRcdHN1cGVyLmNvcHkoIHNvdXJjZSApO1xuXG5cdFx0dGhpcy5wb2ludHMgPSBbXTtcblxuXHRcdGZvciAoIGxldCBpID0gMCwgbCA9IHNvdXJjZS5wb2ludHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0Y29uc3QgcG9pbnQgPSBzb3VyY2UucG9pbnRzWyBpIF07XG5cblx0XHRcdHRoaXMucG9pbnRzLnB1c2goIHBvaW50LmNsb25lKCkgKTtcblxuXHRcdH1cblxuXHRcdHRoaXMuY2xvc2VkID0gc291cmNlLmNsb3NlZDtcblx0XHR0aGlzLmN1cnZlVHlwZSA9IHNvdXJjZS5jdXJ2ZVR5cGU7XG5cdFx0dGhpcy50ZW5zaW9uID0gc291cmNlLnRlbnNpb247XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0dG9KU09OKCkge1xuXG5cdFx0Y29uc3QgZGF0YSA9IHN1cGVyLnRvSlNPTigpO1xuXG5cdFx0ZGF0YS5wb2ludHMgPSBbXTtcblxuXHRcdGZvciAoIGxldCBpID0gMCwgbCA9IHRoaXMucG9pbnRzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdGNvbnN0IHBvaW50ID0gdGhpcy5wb2ludHNbIGkgXTtcblx0XHRcdGRhdGEucG9pbnRzLnB1c2goIHBvaW50LnRvQXJyYXkoKSApO1xuXG5cdFx0fVxuXG5cdFx0ZGF0YS5jbG9zZWQgPSB0aGlzLmNsb3NlZDtcblx0XHRkYXRhLmN1cnZlVHlwZSA9IHRoaXMuY3VydmVUeXBlO1xuXHRcdGRhdGEudGVuc2lvbiA9IHRoaXMudGVuc2lvbjtcblxuXHRcdHJldHVybiBkYXRhO1xuXG5cdH1cblxuXHRmcm9tSlNPTigganNvbiApIHtcblxuXHRcdHN1cGVyLmZyb21KU09OKCBqc29uICk7XG5cblx0XHR0aGlzLnBvaW50cyA9IFtdO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBsID0ganNvbi5wb2ludHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0Y29uc3QgcG9pbnQgPSBqc29uLnBvaW50c1sgaSBdO1xuXHRcdFx0dGhpcy5wb2ludHMucHVzaCggbmV3IFZlY3RvcjMoKS5mcm9tQXJyYXkoIHBvaW50ICkgKTtcblxuXHRcdH1cblxuXHRcdHRoaXMuY2xvc2VkID0ganNvbi5jbG9zZWQ7XG5cdFx0dGhpcy5jdXJ2ZVR5cGUgPSBqc29uLmN1cnZlVHlwZTtcblx0XHR0aGlzLnRlbnNpb24gPSBqc29uLnRlbnNpb247XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cbn1cblxuZXhwb3J0IHsgQ2F0bXVsbFJvbUN1cnZlMyB9O1xuIiwiaW1wb3J0IHsgQ3VydmUgfSBmcm9tICcuLi9jb3JlL0N1cnZlLmpzJztcbmltcG9ydCB7IEN1YmljQmV6aWVyIH0gZnJvbSAnLi4vY29yZS9JbnRlcnBvbGF0aW9ucy5qcyc7XG5pbXBvcnQgeyBWZWN0b3IyIH0gZnJvbSAnLi4vLi4vbWF0aC9WZWN0b3IyLmpzJztcblxuY2xhc3MgQ3ViaWNCZXppZXJDdXJ2ZSBleHRlbmRzIEN1cnZlIHtcblxuXHRjb25zdHJ1Y3RvciggdjAgPSBuZXcgVmVjdG9yMigpLCB2MSA9IG5ldyBWZWN0b3IyKCksIHYyID0gbmV3IFZlY3RvcjIoKSwgdjMgPSBuZXcgVmVjdG9yMigpICkge1xuXG5cdFx0c3VwZXIoKTtcblxuXHRcdHRoaXMuaXNDdWJpY0JlemllckN1cnZlID0gdHJ1ZTtcblxuXHRcdHRoaXMudHlwZSA9ICdDdWJpY0JlemllckN1cnZlJztcblxuXHRcdHRoaXMudjAgPSB2MDtcblx0XHR0aGlzLnYxID0gdjE7XG5cdFx0dGhpcy52MiA9IHYyO1xuXHRcdHRoaXMudjMgPSB2MztcblxuXHR9XG5cblx0Z2V0UG9pbnQoIHQsIG9wdGlvbmFsVGFyZ2V0ID0gbmV3IFZlY3RvcjIoKSApIHtcblxuXHRcdGNvbnN0IHBvaW50ID0gb3B0aW9uYWxUYXJnZXQ7XG5cblx0XHRjb25zdCB2MCA9IHRoaXMudjAsIHYxID0gdGhpcy52MSwgdjIgPSB0aGlzLnYyLCB2MyA9IHRoaXMudjM7XG5cblx0XHRwb2ludC5zZXQoXG5cdFx0XHRDdWJpY0JlemllciggdCwgdjAueCwgdjEueCwgdjIueCwgdjMueCApLFxuXHRcdFx0Q3ViaWNCZXppZXIoIHQsIHYwLnksIHYxLnksIHYyLnksIHYzLnkgKVxuXHRcdCk7XG5cblx0XHRyZXR1cm4gcG9pbnQ7XG5cblx0fVxuXG5cdGNvcHkoIHNvdXJjZSApIHtcblxuXHRcdHN1cGVyLmNvcHkoIHNvdXJjZSApO1xuXG5cdFx0dGhpcy52MC5jb3B5KCBzb3VyY2UudjAgKTtcblx0XHR0aGlzLnYxLmNvcHkoIHNvdXJjZS52MSApO1xuXHRcdHRoaXMudjIuY29weSggc291cmNlLnYyICk7XG5cdFx0dGhpcy52My5jb3B5KCBzb3VyY2UudjMgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHR0b0pTT04oKSB7XG5cblx0XHRjb25zdCBkYXRhID0gc3VwZXIudG9KU09OKCk7XG5cblx0XHRkYXRhLnYwID0gdGhpcy52MC50b0FycmF5KCk7XG5cdFx0ZGF0YS52MSA9IHRoaXMudjEudG9BcnJheSgpO1xuXHRcdGRhdGEudjIgPSB0aGlzLnYyLnRvQXJyYXkoKTtcblx0XHRkYXRhLnYzID0gdGhpcy52My50b0FycmF5KCk7XG5cblx0XHRyZXR1cm4gZGF0YTtcblxuXHR9XG5cblx0ZnJvbUpTT04oIGpzb24gKSB7XG5cblx0XHRzdXBlci5mcm9tSlNPTigganNvbiApO1xuXG5cdFx0dGhpcy52MC5mcm9tQXJyYXkoIGpzb24udjAgKTtcblx0XHR0aGlzLnYxLmZyb21BcnJheSgganNvbi52MSApO1xuXHRcdHRoaXMudjIuZnJvbUFycmF5KCBqc29uLnYyICk7XG5cdFx0dGhpcy52My5mcm9tQXJyYXkoIGpzb24udjMgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxufVxuXG5leHBvcnQgeyBDdWJpY0JlemllckN1cnZlIH07XG4iLCJpbXBvcnQgeyBDdXJ2ZSB9IGZyb20gJy4uL2NvcmUvQ3VydmUuanMnO1xuaW1wb3J0IHsgQ3ViaWNCZXppZXIgfSBmcm9tICcuLi9jb3JlL0ludGVycG9sYXRpb25zLmpzJztcbmltcG9ydCB7IFZlY3RvcjMgfSBmcm9tICcuLi8uLi9tYXRoL1ZlY3RvcjMuanMnO1xuXG5jbGFzcyBDdWJpY0JlemllckN1cnZlMyBleHRlbmRzIEN1cnZlIHtcblxuXHRjb25zdHJ1Y3RvciggdjAgPSBuZXcgVmVjdG9yMygpLCB2MSA9IG5ldyBWZWN0b3IzKCksIHYyID0gbmV3IFZlY3RvcjMoKSwgdjMgPSBuZXcgVmVjdG9yMygpICkge1xuXG5cdFx0c3VwZXIoKTtcblxuXHRcdHRoaXMuaXNDdWJpY0JlemllckN1cnZlMyA9IHRydWU7XG5cblx0XHR0aGlzLnR5cGUgPSAnQ3ViaWNCZXppZXJDdXJ2ZTMnO1xuXG5cdFx0dGhpcy52MCA9IHYwO1xuXHRcdHRoaXMudjEgPSB2MTtcblx0XHR0aGlzLnYyID0gdjI7XG5cdFx0dGhpcy52MyA9IHYzO1xuXG5cdH1cblxuXHRnZXRQb2ludCggdCwgb3B0aW9uYWxUYXJnZXQgPSBuZXcgVmVjdG9yMygpICkge1xuXG5cdFx0Y29uc3QgcG9pbnQgPSBvcHRpb25hbFRhcmdldDtcblxuXHRcdGNvbnN0IHYwID0gdGhpcy52MCwgdjEgPSB0aGlzLnYxLCB2MiA9IHRoaXMudjIsIHYzID0gdGhpcy52MztcblxuXHRcdHBvaW50LnNldChcblx0XHRcdEN1YmljQmV6aWVyKCB0LCB2MC54LCB2MS54LCB2Mi54LCB2My54ICksXG5cdFx0XHRDdWJpY0JlemllciggdCwgdjAueSwgdjEueSwgdjIueSwgdjMueSApLFxuXHRcdFx0Q3ViaWNCZXppZXIoIHQsIHYwLnosIHYxLnosIHYyLnosIHYzLnogKVxuXHRcdCk7XG5cblx0XHRyZXR1cm4gcG9pbnQ7XG5cblx0fVxuXG5cdGNvcHkoIHNvdXJjZSApIHtcblxuXHRcdHN1cGVyLmNvcHkoIHNvdXJjZSApO1xuXG5cdFx0dGhpcy52MC5jb3B5KCBzb3VyY2UudjAgKTtcblx0XHR0aGlzLnYxLmNvcHkoIHNvdXJjZS52MSApO1xuXHRcdHRoaXMudjIuY29weSggc291cmNlLnYyICk7XG5cdFx0dGhpcy52My5jb3B5KCBzb3VyY2UudjMgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHR0b0pTT04oKSB7XG5cblx0XHRjb25zdCBkYXRhID0gc3VwZXIudG9KU09OKCk7XG5cblx0XHRkYXRhLnYwID0gdGhpcy52MC50b0FycmF5KCk7XG5cdFx0ZGF0YS52MSA9IHRoaXMudjEudG9BcnJheSgpO1xuXHRcdGRhdGEudjIgPSB0aGlzLnYyLnRvQXJyYXkoKTtcblx0XHRkYXRhLnYzID0gdGhpcy52My50b0FycmF5KCk7XG5cblx0XHRyZXR1cm4gZGF0YTtcblxuXHR9XG5cblx0ZnJvbUpTT04oIGpzb24gKSB7XG5cblx0XHRzdXBlci5mcm9tSlNPTigganNvbiApO1xuXG5cdFx0dGhpcy52MC5mcm9tQXJyYXkoIGpzb24udjAgKTtcblx0XHR0aGlzLnYxLmZyb21BcnJheSgganNvbi52MSApO1xuXHRcdHRoaXMudjIuZnJvbUFycmF5KCBqc29uLnYyICk7XG5cdFx0dGhpcy52My5mcm9tQXJyYXkoIGpzb24udjMgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxufVxuXG5leHBvcnQgeyBDdWJpY0JlemllckN1cnZlMyB9O1xuIiwiZXhwb3J0IHsgQXJjQ3VydmUgfSBmcm9tICcuL0FyY0N1cnZlLmpzJztcbmV4cG9ydCB7IENhdG11bGxSb21DdXJ2ZTMgfSBmcm9tICcuL0NhdG11bGxSb21DdXJ2ZTMuanMnO1xuZXhwb3J0IHsgQ3ViaWNCZXppZXJDdXJ2ZSB9IGZyb20gJy4vQ3ViaWNCZXppZXJDdXJ2ZS5qcyc7XG5leHBvcnQgeyBDdWJpY0JlemllckN1cnZlMyB9IGZyb20gJy4vQ3ViaWNCZXppZXJDdXJ2ZTMuanMnO1xuZXhwb3J0IHsgRWxsaXBzZUN1cnZlIH0gZnJvbSAnLi9FbGxpcHNlQ3VydmUuanMnO1xuZXhwb3J0IHsgTGluZUN1cnZlIH0gZnJvbSAnLi9MaW5lQ3VydmUuanMnO1xuZXhwb3J0IHsgTGluZUN1cnZlMyB9IGZyb20gJy4vTGluZUN1cnZlMy5qcyc7XG5leHBvcnQgeyBRdWFkcmF0aWNCZXppZXJDdXJ2ZSB9IGZyb20gJy4vUXVhZHJhdGljQmV6aWVyQ3VydmUuanMnO1xuZXhwb3J0IHsgUXVhZHJhdGljQmV6aWVyQ3VydmUzIH0gZnJvbSAnLi9RdWFkcmF0aWNCZXppZXJDdXJ2ZTMuanMnO1xuZXhwb3J0IHsgU3BsaW5lQ3VydmUgfSBmcm9tICcuL1NwbGluZUN1cnZlLmpzJztcbiIsImltcG9ydCB7IEN1cnZlIH0gZnJvbSAnLi4vY29yZS9DdXJ2ZS5qcyc7XG5pbXBvcnQgeyBWZWN0b3IyIH0gZnJvbSAnLi4vLi4vbWF0aC9WZWN0b3IyLmpzJztcblxuY2xhc3MgRWxsaXBzZUN1cnZlIGV4dGVuZHMgQ3VydmUge1xuXG5cdGNvbnN0cnVjdG9yKCBhWCA9IDAsIGFZID0gMCwgeFJhZGl1cyA9IDEsIHlSYWRpdXMgPSAxLCBhU3RhcnRBbmdsZSA9IDAsIGFFbmRBbmdsZSA9IE1hdGguUEkgKiAyLCBhQ2xvY2t3aXNlID0gZmFsc2UsIGFSb3RhdGlvbiA9IDAgKSB7XG5cblx0XHRzdXBlcigpO1xuXG5cdFx0dGhpcy5pc0VsbGlwc2VDdXJ2ZSA9IHRydWU7XG5cblx0XHR0aGlzLnR5cGUgPSAnRWxsaXBzZUN1cnZlJztcblxuXHRcdHRoaXMuYVggPSBhWDtcblx0XHR0aGlzLmFZID0gYVk7XG5cblx0XHR0aGlzLnhSYWRpdXMgPSB4UmFkaXVzO1xuXHRcdHRoaXMueVJhZGl1cyA9IHlSYWRpdXM7XG5cblx0XHR0aGlzLmFTdGFydEFuZ2xlID0gYVN0YXJ0QW5nbGU7XG5cdFx0dGhpcy5hRW5kQW5nbGUgPSBhRW5kQW5nbGU7XG5cblx0XHR0aGlzLmFDbG9ja3dpc2UgPSBhQ2xvY2t3aXNlO1xuXG5cdFx0dGhpcy5hUm90YXRpb24gPSBhUm90YXRpb247XG5cblx0fVxuXG5cdGdldFBvaW50KCB0LCBvcHRpb25hbFRhcmdldCApIHtcblxuXHRcdGNvbnN0IHBvaW50ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFZlY3RvcjIoKTtcblxuXHRcdGNvbnN0IHR3b1BpID0gTWF0aC5QSSAqIDI7XG5cdFx0bGV0IGRlbHRhQW5nbGUgPSB0aGlzLmFFbmRBbmdsZSAtIHRoaXMuYVN0YXJ0QW5nbGU7XG5cdFx0Y29uc3Qgc2FtZVBvaW50cyA9IE1hdGguYWJzKCBkZWx0YUFuZ2xlICkgPCBOdW1iZXIuRVBTSUxPTjtcblxuXHRcdC8vIGVuc3VyZXMgdGhhdCBkZWx0YUFuZ2xlIGlzIDAgLi4gMiBQSVxuXHRcdHdoaWxlICggZGVsdGFBbmdsZSA8IDAgKSBkZWx0YUFuZ2xlICs9IHR3b1BpO1xuXHRcdHdoaWxlICggZGVsdGFBbmdsZSA+IHR3b1BpICkgZGVsdGFBbmdsZSAtPSB0d29QaTtcblxuXHRcdGlmICggZGVsdGFBbmdsZSA8IE51bWJlci5FUFNJTE9OICkge1xuXG5cdFx0XHRpZiAoIHNhbWVQb2ludHMgKSB7XG5cblx0XHRcdFx0ZGVsdGFBbmdsZSA9IDA7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0ZGVsdGFBbmdsZSA9IHR3b1BpO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRpZiAoIHRoaXMuYUNsb2Nrd2lzZSA9PT0gdHJ1ZSAmJiAhIHNhbWVQb2ludHMgKSB7XG5cblx0XHRcdGlmICggZGVsdGFBbmdsZSA9PT0gdHdvUGkgKSB7XG5cblx0XHRcdFx0ZGVsdGFBbmdsZSA9IC0gdHdvUGk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0ZGVsdGFBbmdsZSA9IGRlbHRhQW5nbGUgLSB0d29QaTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Y29uc3QgYW5nbGUgPSB0aGlzLmFTdGFydEFuZ2xlICsgdCAqIGRlbHRhQW5nbGU7XG5cdFx0bGV0IHggPSB0aGlzLmFYICsgdGhpcy54UmFkaXVzICogTWF0aC5jb3MoIGFuZ2xlICk7XG5cdFx0bGV0IHkgPSB0aGlzLmFZICsgdGhpcy55UmFkaXVzICogTWF0aC5zaW4oIGFuZ2xlICk7XG5cblx0XHRpZiAoIHRoaXMuYVJvdGF0aW9uICE9PSAwICkge1xuXG5cdFx0XHRjb25zdCBjb3MgPSBNYXRoLmNvcyggdGhpcy5hUm90YXRpb24gKTtcblx0XHRcdGNvbnN0IHNpbiA9IE1hdGguc2luKCB0aGlzLmFSb3RhdGlvbiApO1xuXG5cdFx0XHRjb25zdCB0eCA9IHggLSB0aGlzLmFYO1xuXHRcdFx0Y29uc3QgdHkgPSB5IC0gdGhpcy5hWTtcblxuXHRcdFx0Ly8gUm90YXRlIHRoZSBwb2ludCBhYm91dCB0aGUgY2VudGVyIG9mIHRoZSBlbGxpcHNlLlxuXHRcdFx0eCA9IHR4ICogY29zIC0gdHkgKiBzaW4gKyB0aGlzLmFYO1xuXHRcdFx0eSA9IHR4ICogc2luICsgdHkgKiBjb3MgKyB0aGlzLmFZO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHBvaW50LnNldCggeCwgeSApO1xuXG5cdH1cblxuXHRjb3B5KCBzb3VyY2UgKSB7XG5cblx0XHRzdXBlci5jb3B5KCBzb3VyY2UgKTtcblxuXHRcdHRoaXMuYVggPSBzb3VyY2UuYVg7XG5cdFx0dGhpcy5hWSA9IHNvdXJjZS5hWTtcblxuXHRcdHRoaXMueFJhZGl1cyA9IHNvdXJjZS54UmFkaXVzO1xuXHRcdHRoaXMueVJhZGl1cyA9IHNvdXJjZS55UmFkaXVzO1xuXG5cdFx0dGhpcy5hU3RhcnRBbmdsZSA9IHNvdXJjZS5hU3RhcnRBbmdsZTtcblx0XHR0aGlzLmFFbmRBbmdsZSA9IHNvdXJjZS5hRW5kQW5nbGU7XG5cblx0XHR0aGlzLmFDbG9ja3dpc2UgPSBzb3VyY2UuYUNsb2Nrd2lzZTtcblxuXHRcdHRoaXMuYVJvdGF0aW9uID0gc291cmNlLmFSb3RhdGlvbjtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHR0b0pTT04oKSB7XG5cblx0XHRjb25zdCBkYXRhID0gc3VwZXIudG9KU09OKCk7XG5cblx0XHRkYXRhLmFYID0gdGhpcy5hWDtcblx0XHRkYXRhLmFZID0gdGhpcy5hWTtcblxuXHRcdGRhdGEueFJhZGl1cyA9IHRoaXMueFJhZGl1cztcblx0XHRkYXRhLnlSYWRpdXMgPSB0aGlzLnlSYWRpdXM7XG5cblx0XHRkYXRhLmFTdGFydEFuZ2xlID0gdGhpcy5hU3RhcnRBbmdsZTtcblx0XHRkYXRhLmFFbmRBbmdsZSA9IHRoaXMuYUVuZEFuZ2xlO1xuXG5cdFx0ZGF0YS5hQ2xvY2t3aXNlID0gdGhpcy5hQ2xvY2t3aXNlO1xuXG5cdFx0ZGF0YS5hUm90YXRpb24gPSB0aGlzLmFSb3RhdGlvbjtcblxuXHRcdHJldHVybiBkYXRhO1xuXG5cdH1cblxuXHRmcm9tSlNPTigganNvbiApIHtcblxuXHRcdHN1cGVyLmZyb21KU09OKCBqc29uICk7XG5cblx0XHR0aGlzLmFYID0ganNvbi5hWDtcblx0XHR0aGlzLmFZID0ganNvbi5hWTtcblxuXHRcdHRoaXMueFJhZGl1cyA9IGpzb24ueFJhZGl1cztcblx0XHR0aGlzLnlSYWRpdXMgPSBqc29uLnlSYWRpdXM7XG5cblx0XHR0aGlzLmFTdGFydEFuZ2xlID0ganNvbi5hU3RhcnRBbmdsZTtcblx0XHR0aGlzLmFFbmRBbmdsZSA9IGpzb24uYUVuZEFuZ2xlO1xuXG5cdFx0dGhpcy5hQ2xvY2t3aXNlID0ganNvbi5hQ2xvY2t3aXNlO1xuXG5cdFx0dGhpcy5hUm90YXRpb24gPSBqc29uLmFSb3RhdGlvbjtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxufVxuXG5leHBvcnQgeyBFbGxpcHNlQ3VydmUgfTtcbiIsImltcG9ydCB7IFZlY3RvcjIgfSBmcm9tICcuLi8uLi9tYXRoL1ZlY3RvcjIuanMnO1xuaW1wb3J0IHsgQ3VydmUgfSBmcm9tICcuLi9jb3JlL0N1cnZlLmpzJztcblxuY2xhc3MgTGluZUN1cnZlIGV4dGVuZHMgQ3VydmUge1xuXG5cdGNvbnN0cnVjdG9yKCB2MSA9IG5ldyBWZWN0b3IyKCksIHYyID0gbmV3IFZlY3RvcjIoKSApIHtcblxuXHRcdHN1cGVyKCk7XG5cblx0XHR0aGlzLmlzTGluZUN1cnZlID0gdHJ1ZTtcblxuXHRcdHRoaXMudHlwZSA9ICdMaW5lQ3VydmUnO1xuXG5cdFx0dGhpcy52MSA9IHYxO1xuXHRcdHRoaXMudjIgPSB2MjtcblxuXHR9XG5cblx0Z2V0UG9pbnQoIHQsIG9wdGlvbmFsVGFyZ2V0ID0gbmV3IFZlY3RvcjIoKSApIHtcblxuXHRcdGNvbnN0IHBvaW50ID0gb3B0aW9uYWxUYXJnZXQ7XG5cblx0XHRpZiAoIHQgPT09IDEgKSB7XG5cblx0XHRcdHBvaW50LmNvcHkoIHRoaXMudjIgKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHBvaW50LmNvcHkoIHRoaXMudjIgKS5zdWIoIHRoaXMudjEgKTtcblx0XHRcdHBvaW50Lm11bHRpcGx5U2NhbGFyKCB0ICkuYWRkKCB0aGlzLnYxICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gcG9pbnQ7XG5cblx0fVxuXG5cdC8vIExpbmUgY3VydmUgaXMgbGluZWFyLCBzbyB3ZSBjYW4gb3ZlcndyaXRlIGRlZmF1bHQgZ2V0UG9pbnRBdFxuXHRnZXRQb2ludEF0KCB1LCBvcHRpb25hbFRhcmdldCApIHtcblxuXHRcdHJldHVybiB0aGlzLmdldFBvaW50KCB1LCBvcHRpb25hbFRhcmdldCApO1xuXG5cdH1cblxuXHRnZXRUYW5nZW50KCB0LCBvcHRpb25hbFRhcmdldCA9IG5ldyBWZWN0b3IyKCkgKSB7XG5cblx0XHRyZXR1cm4gb3B0aW9uYWxUYXJnZXQuc3ViVmVjdG9ycyggdGhpcy52MiwgdGhpcy52MSApLm5vcm1hbGl6ZSgpO1xuXG5cdH1cblxuXHRnZXRUYW5nZW50QXQoIHUsIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG5cdFx0cmV0dXJuIHRoaXMuZ2V0VGFuZ2VudCggdSwgb3B0aW9uYWxUYXJnZXQgKTtcblxuXHR9XG5cblx0Y29weSggc291cmNlICkge1xuXG5cdFx0c3VwZXIuY29weSggc291cmNlICk7XG5cblx0XHR0aGlzLnYxLmNvcHkoIHNvdXJjZS52MSApO1xuXHRcdHRoaXMudjIuY29weSggc291cmNlLnYyICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0dG9KU09OKCkge1xuXG5cdFx0Y29uc3QgZGF0YSA9IHN1cGVyLnRvSlNPTigpO1xuXG5cdFx0ZGF0YS52MSA9IHRoaXMudjEudG9BcnJheSgpO1xuXHRcdGRhdGEudjIgPSB0aGlzLnYyLnRvQXJyYXkoKTtcblxuXHRcdHJldHVybiBkYXRhO1xuXG5cdH1cblxuXHRmcm9tSlNPTigganNvbiApIHtcblxuXHRcdHN1cGVyLmZyb21KU09OKCBqc29uICk7XG5cblx0XHR0aGlzLnYxLmZyb21BcnJheSgganNvbi52MSApO1xuXHRcdHRoaXMudjIuZnJvbUFycmF5KCBqc29uLnYyICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cbn1cblxuZXhwb3J0IHsgTGluZUN1cnZlIH07XG4iLCJpbXBvcnQgeyBWZWN0b3IzIH0gZnJvbSAnLi4vLi4vbWF0aC9WZWN0b3IzLmpzJztcbmltcG9ydCB7IEN1cnZlIH0gZnJvbSAnLi4vY29yZS9DdXJ2ZS5qcyc7XG5cbmNsYXNzIExpbmVDdXJ2ZTMgZXh0ZW5kcyBDdXJ2ZSB7XG5cblx0Y29uc3RydWN0b3IoIHYxID0gbmV3IFZlY3RvcjMoKSwgdjIgPSBuZXcgVmVjdG9yMygpICkge1xuXG5cdFx0c3VwZXIoKTtcblxuXHRcdHRoaXMuaXNMaW5lQ3VydmUzID0gdHJ1ZTtcblxuXHRcdHRoaXMudHlwZSA9ICdMaW5lQ3VydmUzJztcblxuXHRcdHRoaXMudjEgPSB2MTtcblx0XHR0aGlzLnYyID0gdjI7XG5cblx0fVxuXHRnZXRQb2ludCggdCwgb3B0aW9uYWxUYXJnZXQgPSBuZXcgVmVjdG9yMygpICkge1xuXG5cdFx0Y29uc3QgcG9pbnQgPSBvcHRpb25hbFRhcmdldDtcblxuXHRcdGlmICggdCA9PT0gMSApIHtcblxuXHRcdFx0cG9pbnQuY29weSggdGhpcy52MiApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0cG9pbnQuY29weSggdGhpcy52MiApLnN1YiggdGhpcy52MSApO1xuXHRcdFx0cG9pbnQubXVsdGlwbHlTY2FsYXIoIHQgKS5hZGQoIHRoaXMudjEgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBwb2ludDtcblxuXHR9XG5cdC8vIExpbmUgY3VydmUgaXMgbGluZWFyLCBzbyB3ZSBjYW4gb3ZlcndyaXRlIGRlZmF1bHQgZ2V0UG9pbnRBdFxuXHRnZXRQb2ludEF0KCB1LCBvcHRpb25hbFRhcmdldCApIHtcblxuXHRcdHJldHVybiB0aGlzLmdldFBvaW50KCB1LCBvcHRpb25hbFRhcmdldCApO1xuXG5cdH1cblxuXHRnZXRUYW5nZW50KCB0LCBvcHRpb25hbFRhcmdldCA9IG5ldyBWZWN0b3IzKCkgKSB7XG5cblx0XHRyZXR1cm4gb3B0aW9uYWxUYXJnZXQuc3ViVmVjdG9ycyggdGhpcy52MiwgdGhpcy52MSApLm5vcm1hbGl6ZSgpO1xuXG5cdH1cblxuXHRnZXRUYW5nZW50QXQoIHUsIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG5cdFx0cmV0dXJuIHRoaXMuZ2V0VGFuZ2VudCggdSwgb3B0aW9uYWxUYXJnZXQgKTtcblxuXHR9XG5cblx0Y29weSggc291cmNlICkge1xuXG5cdFx0c3VwZXIuY29weSggc291cmNlICk7XG5cblx0XHR0aGlzLnYxLmNvcHkoIHNvdXJjZS52MSApO1xuXHRcdHRoaXMudjIuY29weSggc291cmNlLnYyICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cdHRvSlNPTigpIHtcblxuXHRcdGNvbnN0IGRhdGEgPSBzdXBlci50b0pTT04oKTtcblxuXHRcdGRhdGEudjEgPSB0aGlzLnYxLnRvQXJyYXkoKTtcblx0XHRkYXRhLnYyID0gdGhpcy52Mi50b0FycmF5KCk7XG5cblx0XHRyZXR1cm4gZGF0YTtcblxuXHR9XG5cdGZyb21KU09OKCBqc29uICkge1xuXG5cdFx0c3VwZXIuZnJvbUpTT04oIGpzb24gKTtcblxuXHRcdHRoaXMudjEuZnJvbUFycmF5KCBqc29uLnYxICk7XG5cdFx0dGhpcy52Mi5mcm9tQXJyYXkoIGpzb24udjIgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxufVxuXG5leHBvcnQgeyBMaW5lQ3VydmUzIH07XG4iLCJpbXBvcnQgeyBDdXJ2ZSB9IGZyb20gJy4uL2NvcmUvQ3VydmUuanMnO1xuaW1wb3J0IHsgUXVhZHJhdGljQmV6aWVyIH0gZnJvbSAnLi4vY29yZS9JbnRlcnBvbGF0aW9ucy5qcyc7XG5pbXBvcnQgeyBWZWN0b3IyIH0gZnJvbSAnLi4vLi4vbWF0aC9WZWN0b3IyLmpzJztcblxuY2xhc3MgUXVhZHJhdGljQmV6aWVyQ3VydmUgZXh0ZW5kcyBDdXJ2ZSB7XG5cblx0Y29uc3RydWN0b3IoIHYwID0gbmV3IFZlY3RvcjIoKSwgdjEgPSBuZXcgVmVjdG9yMigpLCB2MiA9IG5ldyBWZWN0b3IyKCkgKSB7XG5cblx0XHRzdXBlcigpO1xuXG5cdFx0dGhpcy5pc1F1YWRyYXRpY0JlemllckN1cnZlID0gdHJ1ZTtcblxuXHRcdHRoaXMudHlwZSA9ICdRdWFkcmF0aWNCZXppZXJDdXJ2ZSc7XG5cblx0XHR0aGlzLnYwID0gdjA7XG5cdFx0dGhpcy52MSA9IHYxO1xuXHRcdHRoaXMudjIgPSB2MjtcblxuXHR9XG5cblx0Z2V0UG9pbnQoIHQsIG9wdGlvbmFsVGFyZ2V0ID0gbmV3IFZlY3RvcjIoKSApIHtcblxuXHRcdGNvbnN0IHBvaW50ID0gb3B0aW9uYWxUYXJnZXQ7XG5cblx0XHRjb25zdCB2MCA9IHRoaXMudjAsIHYxID0gdGhpcy52MSwgdjIgPSB0aGlzLnYyO1xuXG5cdFx0cG9pbnQuc2V0KFxuXHRcdFx0UXVhZHJhdGljQmV6aWVyKCB0LCB2MC54LCB2MS54LCB2Mi54ICksXG5cdFx0XHRRdWFkcmF0aWNCZXppZXIoIHQsIHYwLnksIHYxLnksIHYyLnkgKVxuXHRcdCk7XG5cblx0XHRyZXR1cm4gcG9pbnQ7XG5cblx0fVxuXG5cdGNvcHkoIHNvdXJjZSApIHtcblxuXHRcdHN1cGVyLmNvcHkoIHNvdXJjZSApO1xuXG5cdFx0dGhpcy52MC5jb3B5KCBzb3VyY2UudjAgKTtcblx0XHR0aGlzLnYxLmNvcHkoIHNvdXJjZS52MSApO1xuXHRcdHRoaXMudjIuY29weSggc291cmNlLnYyICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0dG9KU09OKCkge1xuXG5cdFx0Y29uc3QgZGF0YSA9IHN1cGVyLnRvSlNPTigpO1xuXG5cdFx0ZGF0YS52MCA9IHRoaXMudjAudG9BcnJheSgpO1xuXHRcdGRhdGEudjEgPSB0aGlzLnYxLnRvQXJyYXkoKTtcblx0XHRkYXRhLnYyID0gdGhpcy52Mi50b0FycmF5KCk7XG5cblx0XHRyZXR1cm4gZGF0YTtcblxuXHR9XG5cblx0ZnJvbUpTT04oIGpzb24gKSB7XG5cblx0XHRzdXBlci5mcm9tSlNPTigganNvbiApO1xuXG5cdFx0dGhpcy52MC5mcm9tQXJyYXkoIGpzb24udjAgKTtcblx0XHR0aGlzLnYxLmZyb21BcnJheSgganNvbi52MSApO1xuXHRcdHRoaXMudjIuZnJvbUFycmF5KCBqc29uLnYyICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cbn1cblxuZXhwb3J0IHsgUXVhZHJhdGljQmV6aWVyQ3VydmUgfTtcbiIsImltcG9ydCB7IEN1cnZlIH0gZnJvbSAnLi4vY29yZS9DdXJ2ZS5qcyc7XG5pbXBvcnQgeyBRdWFkcmF0aWNCZXppZXIgfSBmcm9tICcuLi9jb3JlL0ludGVycG9sYXRpb25zLmpzJztcbmltcG9ydCB7IFZlY3RvcjMgfSBmcm9tICcuLi8uLi9tYXRoL1ZlY3RvcjMuanMnO1xuXG5jbGFzcyBRdWFkcmF0aWNCZXppZXJDdXJ2ZTMgZXh0ZW5kcyBDdXJ2ZSB7XG5cblx0Y29uc3RydWN0b3IoIHYwID0gbmV3IFZlY3RvcjMoKSwgdjEgPSBuZXcgVmVjdG9yMygpLCB2MiA9IG5ldyBWZWN0b3IzKCkgKSB7XG5cblx0XHRzdXBlcigpO1xuXG5cdFx0dGhpcy5pc1F1YWRyYXRpY0JlemllckN1cnZlMyA9IHRydWU7XG5cblx0XHR0aGlzLnR5cGUgPSAnUXVhZHJhdGljQmV6aWVyQ3VydmUzJztcblxuXHRcdHRoaXMudjAgPSB2MDtcblx0XHR0aGlzLnYxID0gdjE7XG5cdFx0dGhpcy52MiA9IHYyO1xuXG5cdH1cblxuXHRnZXRQb2ludCggdCwgb3B0aW9uYWxUYXJnZXQgPSBuZXcgVmVjdG9yMygpICkge1xuXG5cdFx0Y29uc3QgcG9pbnQgPSBvcHRpb25hbFRhcmdldDtcblxuXHRcdGNvbnN0IHYwID0gdGhpcy52MCwgdjEgPSB0aGlzLnYxLCB2MiA9IHRoaXMudjI7XG5cblx0XHRwb2ludC5zZXQoXG5cdFx0XHRRdWFkcmF0aWNCZXppZXIoIHQsIHYwLngsIHYxLngsIHYyLnggKSxcblx0XHRcdFF1YWRyYXRpY0JlemllciggdCwgdjAueSwgdjEueSwgdjIueSApLFxuXHRcdFx0UXVhZHJhdGljQmV6aWVyKCB0LCB2MC56LCB2MS56LCB2Mi56IClcblx0XHQpO1xuXG5cdFx0cmV0dXJuIHBvaW50O1xuXG5cdH1cblxuXHRjb3B5KCBzb3VyY2UgKSB7XG5cblx0XHRzdXBlci5jb3B5KCBzb3VyY2UgKTtcblxuXHRcdHRoaXMudjAuY29weSggc291cmNlLnYwICk7XG5cdFx0dGhpcy52MS5jb3B5KCBzb3VyY2UudjEgKTtcblx0XHR0aGlzLnYyLmNvcHkoIHNvdXJjZS52MiApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHRvSlNPTigpIHtcblxuXHRcdGNvbnN0IGRhdGEgPSBzdXBlci50b0pTT04oKTtcblxuXHRcdGRhdGEudjAgPSB0aGlzLnYwLnRvQXJyYXkoKTtcblx0XHRkYXRhLnYxID0gdGhpcy52MS50b0FycmF5KCk7XG5cdFx0ZGF0YS52MiA9IHRoaXMudjIudG9BcnJheSgpO1xuXG5cdFx0cmV0dXJuIGRhdGE7XG5cblx0fVxuXG5cdGZyb21KU09OKCBqc29uICkge1xuXG5cdFx0c3VwZXIuZnJvbUpTT04oIGpzb24gKTtcblxuXHRcdHRoaXMudjAuZnJvbUFycmF5KCBqc29uLnYwICk7XG5cdFx0dGhpcy52MS5mcm9tQXJyYXkoIGpzb24udjEgKTtcblx0XHR0aGlzLnYyLmZyb21BcnJheSgganNvbi52MiApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG59XG5cbmV4cG9ydCB7IFF1YWRyYXRpY0JlemllckN1cnZlMyB9O1xuIiwiaW1wb3J0IHsgQ3VydmUgfSBmcm9tICcuLi9jb3JlL0N1cnZlLmpzJztcbmltcG9ydCB7IENhdG11bGxSb20gfSBmcm9tICcuLi9jb3JlL0ludGVycG9sYXRpb25zLmpzJztcbmltcG9ydCB7IFZlY3RvcjIgfSBmcm9tICcuLi8uLi9tYXRoL1ZlY3RvcjIuanMnO1xuXG5jbGFzcyBTcGxpbmVDdXJ2ZSBleHRlbmRzIEN1cnZlIHtcblxuXHRjb25zdHJ1Y3RvciggcG9pbnRzID0gW10gKSB7XG5cblx0XHRzdXBlcigpO1xuXG5cdFx0dGhpcy5pc1NwbGluZUN1cnZlID0gdHJ1ZTtcblxuXHRcdHRoaXMudHlwZSA9ICdTcGxpbmVDdXJ2ZSc7XG5cblx0XHR0aGlzLnBvaW50cyA9IHBvaW50cztcblxuXHR9XG5cblx0Z2V0UG9pbnQoIHQsIG9wdGlvbmFsVGFyZ2V0ID0gbmV3IFZlY3RvcjIoKSApIHtcblxuXHRcdGNvbnN0IHBvaW50ID0gb3B0aW9uYWxUYXJnZXQ7XG5cblx0XHRjb25zdCBwb2ludHMgPSB0aGlzLnBvaW50cztcblx0XHRjb25zdCBwID0gKCBwb2ludHMubGVuZ3RoIC0gMSApICogdDtcblxuXHRcdGNvbnN0IGludFBvaW50ID0gTWF0aC5mbG9vciggcCApO1xuXHRcdGNvbnN0IHdlaWdodCA9IHAgLSBpbnRQb2ludDtcblxuXHRcdGNvbnN0IHAwID0gcG9pbnRzWyBpbnRQb2ludCA9PT0gMCA/IGludFBvaW50IDogaW50UG9pbnQgLSAxIF07XG5cdFx0Y29uc3QgcDEgPSBwb2ludHNbIGludFBvaW50IF07XG5cdFx0Y29uc3QgcDIgPSBwb2ludHNbIGludFBvaW50ID4gcG9pbnRzLmxlbmd0aCAtIDIgPyBwb2ludHMubGVuZ3RoIC0gMSA6IGludFBvaW50ICsgMSBdO1xuXHRcdGNvbnN0IHAzID0gcG9pbnRzWyBpbnRQb2ludCA+IHBvaW50cy5sZW5ndGggLSAzID8gcG9pbnRzLmxlbmd0aCAtIDEgOiBpbnRQb2ludCArIDIgXTtcblxuXHRcdHBvaW50LnNldChcblx0XHRcdENhdG11bGxSb20oIHdlaWdodCwgcDAueCwgcDEueCwgcDIueCwgcDMueCApLFxuXHRcdFx0Q2F0bXVsbFJvbSggd2VpZ2h0LCBwMC55LCBwMS55LCBwMi55LCBwMy55IClcblx0XHQpO1xuXG5cdFx0cmV0dXJuIHBvaW50O1xuXG5cdH1cblxuXHRjb3B5KCBzb3VyY2UgKSB7XG5cblx0XHRzdXBlci5jb3B5KCBzb3VyY2UgKTtcblxuXHRcdHRoaXMucG9pbnRzID0gW107XG5cblx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBzb3VyY2UucG9pbnRzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdGNvbnN0IHBvaW50ID0gc291cmNlLnBvaW50c1sgaSBdO1xuXG5cdFx0XHR0aGlzLnBvaW50cy5wdXNoKCBwb2ludC5jbG9uZSgpICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0dG9KU09OKCkge1xuXG5cdFx0Y29uc3QgZGF0YSA9IHN1cGVyLnRvSlNPTigpO1xuXG5cdFx0ZGF0YS5wb2ludHMgPSBbXTtcblxuXHRcdGZvciAoIGxldCBpID0gMCwgbCA9IHRoaXMucG9pbnRzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdGNvbnN0IHBvaW50ID0gdGhpcy5wb2ludHNbIGkgXTtcblx0XHRcdGRhdGEucG9pbnRzLnB1c2goIHBvaW50LnRvQXJyYXkoKSApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGRhdGE7XG5cblx0fVxuXG5cdGZyb21KU09OKCBqc29uICkge1xuXG5cdFx0c3VwZXIuZnJvbUpTT04oIGpzb24gKTtcblxuXHRcdHRoaXMucG9pbnRzID0gW107XG5cblx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBqc29uLnBvaW50cy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRjb25zdCBwb2ludCA9IGpzb24ucG9pbnRzWyBpIF07XG5cdFx0XHR0aGlzLnBvaW50cy5wdXNoKCBuZXcgVmVjdG9yMigpLmZyb21BcnJheSggcG9pbnQgKSApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG59XG5cbmV4cG9ydCB7IFNwbGluZUN1cnZlIH07XG4iLCJpbXBvcnQgeyBCdWZmZXJHZW9tZXRyeSB9IGZyb20gJy4uL2NvcmUvQnVmZmVyR2VvbWV0cnkuanMnO1xuaW1wb3J0IHsgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSB9IGZyb20gJy4uL2NvcmUvQnVmZmVyQXR0cmlidXRlLmpzJztcbmltcG9ydCB7IFZlY3RvcjMgfSBmcm9tICcuLi9tYXRoL1ZlY3RvcjMuanMnO1xuXG5jbGFzcyBCb3hHZW9tZXRyeSBleHRlbmRzIEJ1ZmZlckdlb21ldHJ5IHtcblxuXHRjb25zdHJ1Y3Rvciggd2lkdGggPSAxLCBoZWlnaHQgPSAxLCBkZXB0aCA9IDEsIHdpZHRoU2VnbWVudHMgPSAxLCBoZWlnaHRTZWdtZW50cyA9IDEsIGRlcHRoU2VnbWVudHMgPSAxICkge1xuXG5cdFx0c3VwZXIoKTtcblxuXHRcdHRoaXMudHlwZSA9ICdCb3hHZW9tZXRyeSc7XG5cblx0XHR0aGlzLnBhcmFtZXRlcnMgPSB7XG5cdFx0XHR3aWR0aDogd2lkdGgsXG5cdFx0XHRoZWlnaHQ6IGhlaWdodCxcblx0XHRcdGRlcHRoOiBkZXB0aCxcblx0XHRcdHdpZHRoU2VnbWVudHM6IHdpZHRoU2VnbWVudHMsXG5cdFx0XHRoZWlnaHRTZWdtZW50czogaGVpZ2h0U2VnbWVudHMsXG5cdFx0XHRkZXB0aFNlZ21lbnRzOiBkZXB0aFNlZ21lbnRzXG5cdFx0fTtcblxuXHRcdGNvbnN0IHNjb3BlID0gdGhpcztcblxuXHRcdC8vIHNlZ21lbnRzXG5cblx0XHR3aWR0aFNlZ21lbnRzID0gTWF0aC5mbG9vciggd2lkdGhTZWdtZW50cyApO1xuXHRcdGhlaWdodFNlZ21lbnRzID0gTWF0aC5mbG9vciggaGVpZ2h0U2VnbWVudHMgKTtcblx0XHRkZXB0aFNlZ21lbnRzID0gTWF0aC5mbG9vciggZGVwdGhTZWdtZW50cyApO1xuXG5cdFx0Ly8gYnVmZmVyc1xuXG5cdFx0Y29uc3QgaW5kaWNlcyA9IFtdO1xuXHRcdGNvbnN0IHZlcnRpY2VzID0gW107XG5cdFx0Y29uc3Qgbm9ybWFscyA9IFtdO1xuXHRcdGNvbnN0IHV2cyA9IFtdO1xuXG5cdFx0Ly8gaGVscGVyIHZhcmlhYmxlc1xuXG5cdFx0bGV0IG51bWJlck9mVmVydGljZXMgPSAwO1xuXHRcdGxldCBncm91cFN0YXJ0ID0gMDtcblxuXHRcdC8vIGJ1aWxkIGVhY2ggc2lkZSBvZiB0aGUgYm94IGdlb21ldHJ5XG5cblx0XHRidWlsZFBsYW5lKCAneicsICd5JywgJ3gnLCAtIDEsIC0gMSwgZGVwdGgsIGhlaWdodCwgd2lkdGgsIGRlcHRoU2VnbWVudHMsIGhlaWdodFNlZ21lbnRzLCAwICk7IC8vIHB4XG5cdFx0YnVpbGRQbGFuZSggJ3onLCAneScsICd4JywgMSwgLSAxLCBkZXB0aCwgaGVpZ2h0LCAtIHdpZHRoLCBkZXB0aFNlZ21lbnRzLCBoZWlnaHRTZWdtZW50cywgMSApOyAvLyBueFxuXHRcdGJ1aWxkUGxhbmUoICd4JywgJ3onLCAneScsIDEsIDEsIHdpZHRoLCBkZXB0aCwgaGVpZ2h0LCB3aWR0aFNlZ21lbnRzLCBkZXB0aFNlZ21lbnRzLCAyICk7IC8vIHB5XG5cdFx0YnVpbGRQbGFuZSggJ3gnLCAneicsICd5JywgMSwgLSAxLCB3aWR0aCwgZGVwdGgsIC0gaGVpZ2h0LCB3aWR0aFNlZ21lbnRzLCBkZXB0aFNlZ21lbnRzLCAzICk7IC8vIG55XG5cdFx0YnVpbGRQbGFuZSggJ3gnLCAneScsICd6JywgMSwgLSAxLCB3aWR0aCwgaGVpZ2h0LCBkZXB0aCwgd2lkdGhTZWdtZW50cywgaGVpZ2h0U2VnbWVudHMsIDQgKTsgLy8gcHpcblx0XHRidWlsZFBsYW5lKCAneCcsICd5JywgJ3onLCAtIDEsIC0gMSwgd2lkdGgsIGhlaWdodCwgLSBkZXB0aCwgd2lkdGhTZWdtZW50cywgaGVpZ2h0U2VnbWVudHMsIDUgKTsgLy8gbnpcblxuXHRcdC8vIGJ1aWxkIGdlb21ldHJ5XG5cblx0XHR0aGlzLnNldEluZGV4KCBpbmRpY2VzICk7XG5cdFx0dGhpcy5zZXRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCB2ZXJ0aWNlcywgMyApICk7XG5cdFx0dGhpcy5zZXRBdHRyaWJ1dGUoICdub3JtYWwnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggbm9ybWFscywgMyApICk7XG5cdFx0dGhpcy5zZXRBdHRyaWJ1dGUoICd1dicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCB1dnMsIDIgKSApO1xuXG5cdFx0ZnVuY3Rpb24gYnVpbGRQbGFuZSggdSwgdiwgdywgdWRpciwgdmRpciwgd2lkdGgsIGhlaWdodCwgZGVwdGgsIGdyaWRYLCBncmlkWSwgbWF0ZXJpYWxJbmRleCApIHtcblxuXHRcdFx0Y29uc3Qgc2VnbWVudFdpZHRoID0gd2lkdGggLyBncmlkWDtcblx0XHRcdGNvbnN0IHNlZ21lbnRIZWlnaHQgPSBoZWlnaHQgLyBncmlkWTtcblxuXHRcdFx0Y29uc3Qgd2lkdGhIYWxmID0gd2lkdGggLyAyO1xuXHRcdFx0Y29uc3QgaGVpZ2h0SGFsZiA9IGhlaWdodCAvIDI7XG5cdFx0XHRjb25zdCBkZXB0aEhhbGYgPSBkZXB0aCAvIDI7XG5cblx0XHRcdGNvbnN0IGdyaWRYMSA9IGdyaWRYICsgMTtcblx0XHRcdGNvbnN0IGdyaWRZMSA9IGdyaWRZICsgMTtcblxuXHRcdFx0bGV0IHZlcnRleENvdW50ZXIgPSAwO1xuXHRcdFx0bGV0IGdyb3VwQ291bnQgPSAwO1xuXG5cdFx0XHRjb25zdCB2ZWN0b3IgPSBuZXcgVmVjdG9yMygpO1xuXG5cdFx0XHQvLyBnZW5lcmF0ZSB2ZXJ0aWNlcywgbm9ybWFscyBhbmQgdXZzXG5cblx0XHRcdGZvciAoIGxldCBpeSA9IDA7IGl5IDwgZ3JpZFkxOyBpeSArKyApIHtcblxuXHRcdFx0XHRjb25zdCB5ID0gaXkgKiBzZWdtZW50SGVpZ2h0IC0gaGVpZ2h0SGFsZjtcblxuXHRcdFx0XHRmb3IgKCBsZXQgaXggPSAwOyBpeCA8IGdyaWRYMTsgaXggKysgKSB7XG5cblx0XHRcdFx0XHRjb25zdCB4ID0gaXggKiBzZWdtZW50V2lkdGggLSB3aWR0aEhhbGY7XG5cblx0XHRcdFx0XHQvLyBzZXQgdmFsdWVzIHRvIGNvcnJlY3QgdmVjdG9yIGNvbXBvbmVudFxuXG5cdFx0XHRcdFx0dmVjdG9yWyB1IF0gPSB4ICogdWRpcjtcblx0XHRcdFx0XHR2ZWN0b3JbIHYgXSA9IHkgKiB2ZGlyO1xuXHRcdFx0XHRcdHZlY3RvclsgdyBdID0gZGVwdGhIYWxmO1xuXG5cdFx0XHRcdFx0Ly8gbm93IGFwcGx5IHZlY3RvciB0byB2ZXJ0ZXggYnVmZmVyXG5cblx0XHRcdFx0XHR2ZXJ0aWNlcy5wdXNoKCB2ZWN0b3IueCwgdmVjdG9yLnksIHZlY3Rvci56ICk7XG5cblx0XHRcdFx0XHQvLyBzZXQgdmFsdWVzIHRvIGNvcnJlY3QgdmVjdG9yIGNvbXBvbmVudFxuXG5cdFx0XHRcdFx0dmVjdG9yWyB1IF0gPSAwO1xuXHRcdFx0XHRcdHZlY3RvclsgdiBdID0gMDtcblx0XHRcdFx0XHR2ZWN0b3JbIHcgXSA9IGRlcHRoID4gMCA/IDEgOiAtIDE7XG5cblx0XHRcdFx0XHQvLyBub3cgYXBwbHkgdmVjdG9yIHRvIG5vcm1hbCBidWZmZXJcblxuXHRcdFx0XHRcdG5vcm1hbHMucHVzaCggdmVjdG9yLngsIHZlY3Rvci55LCB2ZWN0b3IueiApO1xuXG5cdFx0XHRcdFx0Ly8gdXZzXG5cblx0XHRcdFx0XHR1dnMucHVzaCggaXggLyBncmlkWCApO1xuXHRcdFx0XHRcdHV2cy5wdXNoKCAxIC0gKCBpeSAvIGdyaWRZICkgKTtcblxuXHRcdFx0XHRcdC8vIGNvdW50ZXJzXG5cblx0XHRcdFx0XHR2ZXJ0ZXhDb3VudGVyICs9IDE7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdC8vIGluZGljZXNcblxuXHRcdFx0Ly8gMS4geW91IG5lZWQgdGhyZWUgaW5kaWNlcyB0byBkcmF3IGEgc2luZ2xlIGZhY2Vcblx0XHRcdC8vIDIuIGEgc2luZ2xlIHNlZ21lbnQgY29uc2lzdHMgb2YgdHdvIGZhY2VzXG5cdFx0XHQvLyAzLiBzbyB3ZSBuZWVkIHRvIGdlbmVyYXRlIHNpeCAoMiozKSBpbmRpY2VzIHBlciBzZWdtZW50XG5cblx0XHRcdGZvciAoIGxldCBpeSA9IDA7IGl5IDwgZ3JpZFk7IGl5ICsrICkge1xuXG5cdFx0XHRcdGZvciAoIGxldCBpeCA9IDA7IGl4IDwgZ3JpZFg7IGl4ICsrICkge1xuXG5cdFx0XHRcdFx0Y29uc3QgYSA9IG51bWJlck9mVmVydGljZXMgKyBpeCArIGdyaWRYMSAqIGl5O1xuXHRcdFx0XHRcdGNvbnN0IGIgPSBudW1iZXJPZlZlcnRpY2VzICsgaXggKyBncmlkWDEgKiAoIGl5ICsgMSApO1xuXHRcdFx0XHRcdGNvbnN0IGMgPSBudW1iZXJPZlZlcnRpY2VzICsgKCBpeCArIDEgKSArIGdyaWRYMSAqICggaXkgKyAxICk7XG5cdFx0XHRcdFx0Y29uc3QgZCA9IG51bWJlck9mVmVydGljZXMgKyAoIGl4ICsgMSApICsgZ3JpZFgxICogaXk7XG5cblx0XHRcdFx0XHQvLyBmYWNlc1xuXG5cdFx0XHRcdFx0aW5kaWNlcy5wdXNoKCBhLCBiLCBkICk7XG5cdFx0XHRcdFx0aW5kaWNlcy5wdXNoKCBiLCBjLCBkICk7XG5cblx0XHRcdFx0XHQvLyBpbmNyZWFzZSBjb3VudGVyXG5cblx0XHRcdFx0XHRncm91cENvdW50ICs9IDY7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdC8vIGFkZCBhIGdyb3VwIHRvIHRoZSBnZW9tZXRyeS4gdGhpcyB3aWxsIGVuc3VyZSBtdWx0aSBtYXRlcmlhbCBzdXBwb3J0XG5cblx0XHRcdHNjb3BlLmFkZEdyb3VwKCBncm91cFN0YXJ0LCBncm91cENvdW50LCBtYXRlcmlhbEluZGV4ICk7XG5cblx0XHRcdC8vIGNhbGN1bGF0ZSBuZXcgc3RhcnQgdmFsdWUgZm9yIGdyb3Vwc1xuXG5cdFx0XHRncm91cFN0YXJ0ICs9IGdyb3VwQ291bnQ7XG5cblx0XHRcdC8vIHVwZGF0ZSB0b3RhbCBudW1iZXIgb2YgdmVydGljZXNcblxuXHRcdFx0bnVtYmVyT2ZWZXJ0aWNlcyArPSB2ZXJ0ZXhDb3VudGVyO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRjb3B5KCBzb3VyY2UgKSB7XG5cblx0XHRzdXBlci5jb3B5KCBzb3VyY2UgKTtcblxuXHRcdHRoaXMucGFyYW1ldGVycyA9IE9iamVjdC5hc3NpZ24oIHt9LCBzb3VyY2UucGFyYW1ldGVycyApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHN0YXRpYyBmcm9tSlNPTiggZGF0YSApIHtcblxuXHRcdHJldHVybiBuZXcgQm94R2VvbWV0cnkoIGRhdGEud2lkdGgsIGRhdGEuaGVpZ2h0LCBkYXRhLmRlcHRoLCBkYXRhLndpZHRoU2VnbWVudHMsIGRhdGEuaGVpZ2h0U2VnbWVudHMsIGRhdGEuZGVwdGhTZWdtZW50cyApO1xuXG5cdH1cblxufVxuXG5leHBvcnQgeyBCb3hHZW9tZXRyeSB9O1xuIiwiaW1wb3J0IHsgUGF0aCB9IGZyb20gJy4uL2V4dHJhcy9jb3JlL1BhdGguanMnO1xuaW1wb3J0IHsgTGF0aGVHZW9tZXRyeSB9IGZyb20gJy4vTGF0aGVHZW9tZXRyeS5qcyc7XG5cbmNsYXNzIENhcHN1bGVHZW9tZXRyeSBleHRlbmRzIExhdGhlR2VvbWV0cnkge1xuXG5cdGNvbnN0cnVjdG9yKCByYWRpdXMgPSAxLCBsZW5ndGggPSAxLCBjYXBTZWdtZW50cyA9IDQsIHJhZGlhbFNlZ21lbnRzID0gOCApIHtcblxuXHRcdGNvbnN0IHBhdGggPSBuZXcgUGF0aCgpO1xuXHRcdHBhdGguYWJzYXJjKCAwLCAtIGxlbmd0aCAvIDIsIHJhZGl1cywgTWF0aC5QSSAqIDEuNSwgMCApO1xuXHRcdHBhdGguYWJzYXJjKCAwLCBsZW5ndGggLyAyLCByYWRpdXMsIDAsIE1hdGguUEkgKiAwLjUgKTtcblxuXHRcdHN1cGVyKCBwYXRoLmdldFBvaW50cyggY2FwU2VnbWVudHMgKSwgcmFkaWFsU2VnbWVudHMgKTtcblxuXHRcdHRoaXMudHlwZSA9ICdDYXBzdWxlR2VvbWV0cnknO1xuXG5cdFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xuXHRcdFx0cmFkaXVzOiByYWRpdXMsXG5cdFx0XHRsZW5ndGg6IGxlbmd0aCxcblx0XHRcdGNhcFNlZ21lbnRzOiBjYXBTZWdtZW50cyxcblx0XHRcdHJhZGlhbFNlZ21lbnRzOiByYWRpYWxTZWdtZW50cyxcblx0XHR9O1xuXG5cdH1cblxuXHRzdGF0aWMgZnJvbUpTT04oIGRhdGEgKSB7XG5cblx0XHRyZXR1cm4gbmV3IENhcHN1bGVHZW9tZXRyeSggZGF0YS5yYWRpdXMsIGRhdGEubGVuZ3RoLCBkYXRhLmNhcFNlZ21lbnRzLCBkYXRhLnJhZGlhbFNlZ21lbnRzICk7XG5cblx0fVxuXG59XG5cbmV4cG9ydCB7IENhcHN1bGVHZW9tZXRyeSB9O1xuIiwiaW1wb3J0IHsgQnVmZmVyR2VvbWV0cnkgfSBmcm9tICcuLi9jb3JlL0J1ZmZlckdlb21ldHJ5LmpzJztcbmltcG9ydCB7IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUgfSBmcm9tICcuLi9jb3JlL0J1ZmZlckF0dHJpYnV0ZS5qcyc7XG5pbXBvcnQgeyBWZWN0b3IzIH0gZnJvbSAnLi4vbWF0aC9WZWN0b3IzLmpzJztcbmltcG9ydCB7IFZlY3RvcjIgfSBmcm9tICcuLi9tYXRoL1ZlY3RvcjIuanMnO1xuXG5jbGFzcyBDaXJjbGVHZW9tZXRyeSBleHRlbmRzIEJ1ZmZlckdlb21ldHJ5IHtcblxuXHRjb25zdHJ1Y3RvciggcmFkaXVzID0gMSwgc2VnbWVudHMgPSAzMiwgdGhldGFTdGFydCA9IDAsIHRoZXRhTGVuZ3RoID0gTWF0aC5QSSAqIDIgKSB7XG5cblx0XHRzdXBlcigpO1xuXG5cdFx0dGhpcy50eXBlID0gJ0NpcmNsZUdlb21ldHJ5JztcblxuXHRcdHRoaXMucGFyYW1ldGVycyA9IHtcblx0XHRcdHJhZGl1czogcmFkaXVzLFxuXHRcdFx0c2VnbWVudHM6IHNlZ21lbnRzLFxuXHRcdFx0dGhldGFTdGFydDogdGhldGFTdGFydCxcblx0XHRcdHRoZXRhTGVuZ3RoOiB0aGV0YUxlbmd0aFxuXHRcdH07XG5cblx0XHRzZWdtZW50cyA9IE1hdGgubWF4KCAzLCBzZWdtZW50cyApO1xuXG5cdFx0Ly8gYnVmZmVyc1xuXG5cdFx0Y29uc3QgaW5kaWNlcyA9IFtdO1xuXHRcdGNvbnN0IHZlcnRpY2VzID0gW107XG5cdFx0Y29uc3Qgbm9ybWFscyA9IFtdO1xuXHRcdGNvbnN0IHV2cyA9IFtdO1xuXG5cdFx0Ly8gaGVscGVyIHZhcmlhYmxlc1xuXG5cdFx0Y29uc3QgdmVydGV4ID0gbmV3IFZlY3RvcjMoKTtcblx0XHRjb25zdCB1diA9IG5ldyBWZWN0b3IyKCk7XG5cblx0XHQvLyBjZW50ZXIgcG9pbnRcblxuXHRcdHZlcnRpY2VzLnB1c2goIDAsIDAsIDAgKTtcblx0XHRub3JtYWxzLnB1c2goIDAsIDAsIDEgKTtcblx0XHR1dnMucHVzaCggMC41LCAwLjUgKTtcblxuXHRcdGZvciAoIGxldCBzID0gMCwgaSA9IDM7IHMgPD0gc2VnbWVudHM7IHMgKyssIGkgKz0gMyApIHtcblxuXHRcdFx0Y29uc3Qgc2VnbWVudCA9IHRoZXRhU3RhcnQgKyBzIC8gc2VnbWVudHMgKiB0aGV0YUxlbmd0aDtcblxuXHRcdFx0Ly8gdmVydGV4XG5cblx0XHRcdHZlcnRleC54ID0gcmFkaXVzICogTWF0aC5jb3MoIHNlZ21lbnQgKTtcblx0XHRcdHZlcnRleC55ID0gcmFkaXVzICogTWF0aC5zaW4oIHNlZ21lbnQgKTtcblxuXHRcdFx0dmVydGljZXMucHVzaCggdmVydGV4LngsIHZlcnRleC55LCB2ZXJ0ZXgueiApO1xuXG5cdFx0XHQvLyBub3JtYWxcblxuXHRcdFx0bm9ybWFscy5wdXNoKCAwLCAwLCAxICk7XG5cblx0XHRcdC8vIHV2c1xuXG5cdFx0XHR1di54ID0gKCB2ZXJ0aWNlc1sgaSBdIC8gcmFkaXVzICsgMSApIC8gMjtcblx0XHRcdHV2LnkgPSAoIHZlcnRpY2VzWyBpICsgMSBdIC8gcmFkaXVzICsgMSApIC8gMjtcblxuXHRcdFx0dXZzLnB1c2goIHV2LngsIHV2LnkgKTtcblxuXHRcdH1cblxuXHRcdC8vIGluZGljZXNcblxuXHRcdGZvciAoIGxldCBpID0gMTsgaSA8PSBzZWdtZW50czsgaSArKyApIHtcblxuXHRcdFx0aW5kaWNlcy5wdXNoKCBpLCBpICsgMSwgMCApO1xuXG5cdFx0fVxuXG5cdFx0Ly8gYnVpbGQgZ2VvbWV0cnlcblxuXHRcdHRoaXMuc2V0SW5kZXgoIGluZGljZXMgKTtcblx0XHR0aGlzLnNldEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHZlcnRpY2VzLCAzICkgKTtcblx0XHR0aGlzLnNldEF0dHJpYnV0ZSggJ25vcm1hbCcsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBub3JtYWxzLCAzICkgKTtcblx0XHR0aGlzLnNldEF0dHJpYnV0ZSggJ3V2JywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHV2cywgMiApICk7XG5cblx0fVxuXG5cdGNvcHkoIHNvdXJjZSApIHtcblxuXHRcdHN1cGVyLmNvcHkoIHNvdXJjZSApO1xuXG5cdFx0dGhpcy5wYXJhbWV0ZXJzID0gT2JqZWN0LmFzc2lnbigge30sIHNvdXJjZS5wYXJhbWV0ZXJzICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c3RhdGljIGZyb21KU09OKCBkYXRhICkge1xuXG5cdFx0cmV0dXJuIG5ldyBDaXJjbGVHZW9tZXRyeSggZGF0YS5yYWRpdXMsIGRhdGEuc2VnbWVudHMsIGRhdGEudGhldGFTdGFydCwgZGF0YS50aGV0YUxlbmd0aCApO1xuXG5cdH1cblxufVxuXG5cbmV4cG9ydCB7IENpcmNsZUdlb21ldHJ5IH07XG4iLCJpbXBvcnQgeyBDeWxpbmRlckdlb21ldHJ5IH0gZnJvbSAnLi9DeWxpbmRlckdlb21ldHJ5LmpzJztcblxuY2xhc3MgQ29uZUdlb21ldHJ5IGV4dGVuZHMgQ3lsaW5kZXJHZW9tZXRyeSB7XG5cblx0Y29uc3RydWN0b3IoIHJhZGl1cyA9IDEsIGhlaWdodCA9IDEsIHJhZGlhbFNlZ21lbnRzID0gMzIsIGhlaWdodFNlZ21lbnRzID0gMSwgb3BlbkVuZGVkID0gZmFsc2UsIHRoZXRhU3RhcnQgPSAwLCB0aGV0YUxlbmd0aCA9IE1hdGguUEkgKiAyICkge1xuXG5cdFx0c3VwZXIoIDAsIHJhZGl1cywgaGVpZ2h0LCByYWRpYWxTZWdtZW50cywgaGVpZ2h0U2VnbWVudHMsIG9wZW5FbmRlZCwgdGhldGFTdGFydCwgdGhldGFMZW5ndGggKTtcblxuXHRcdHRoaXMudHlwZSA9ICdDb25lR2VvbWV0cnknO1xuXG5cdFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xuXHRcdFx0cmFkaXVzOiByYWRpdXMsXG5cdFx0XHRoZWlnaHQ6IGhlaWdodCxcblx0XHRcdHJhZGlhbFNlZ21lbnRzOiByYWRpYWxTZWdtZW50cyxcblx0XHRcdGhlaWdodFNlZ21lbnRzOiBoZWlnaHRTZWdtZW50cyxcblx0XHRcdG9wZW5FbmRlZDogb3BlbkVuZGVkLFxuXHRcdFx0dGhldGFTdGFydDogdGhldGFTdGFydCxcblx0XHRcdHRoZXRhTGVuZ3RoOiB0aGV0YUxlbmd0aFxuXHRcdH07XG5cblx0fVxuXG5cdHN0YXRpYyBmcm9tSlNPTiggZGF0YSApIHtcblxuXHRcdHJldHVybiBuZXcgQ29uZUdlb21ldHJ5KCBkYXRhLnJhZGl1cywgZGF0YS5oZWlnaHQsIGRhdGEucmFkaWFsU2VnbWVudHMsIGRhdGEuaGVpZ2h0U2VnbWVudHMsIGRhdGEub3BlbkVuZGVkLCBkYXRhLnRoZXRhU3RhcnQsIGRhdGEudGhldGFMZW5ndGggKTtcblxuXHR9XG5cbn1cblxuZXhwb3J0IHsgQ29uZUdlb21ldHJ5IH07XG4iLCJpbXBvcnQgeyBCdWZmZXJHZW9tZXRyeSB9IGZyb20gJy4uL2NvcmUvQnVmZmVyR2VvbWV0cnkuanMnO1xuaW1wb3J0IHsgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSB9IGZyb20gJy4uL2NvcmUvQnVmZmVyQXR0cmlidXRlLmpzJztcbmltcG9ydCB7IFZlY3RvcjMgfSBmcm9tICcuLi9tYXRoL1ZlY3RvcjMuanMnO1xuaW1wb3J0IHsgVmVjdG9yMiB9IGZyb20gJy4uL21hdGgvVmVjdG9yMi5qcyc7XG5cbmNsYXNzIEN5bGluZGVyR2VvbWV0cnkgZXh0ZW5kcyBCdWZmZXJHZW9tZXRyeSB7XG5cblx0Y29uc3RydWN0b3IoIHJhZGl1c1RvcCA9IDEsIHJhZGl1c0JvdHRvbSA9IDEsIGhlaWdodCA9IDEsIHJhZGlhbFNlZ21lbnRzID0gMzIsIGhlaWdodFNlZ21lbnRzID0gMSwgb3BlbkVuZGVkID0gZmFsc2UsIHRoZXRhU3RhcnQgPSAwLCB0aGV0YUxlbmd0aCA9IE1hdGguUEkgKiAyICkge1xuXG5cdFx0c3VwZXIoKTtcblxuXHRcdHRoaXMudHlwZSA9ICdDeWxpbmRlckdlb21ldHJ5JztcblxuXHRcdHRoaXMucGFyYW1ldGVycyA9IHtcblx0XHRcdHJhZGl1c1RvcDogcmFkaXVzVG9wLFxuXHRcdFx0cmFkaXVzQm90dG9tOiByYWRpdXNCb3R0b20sXG5cdFx0XHRoZWlnaHQ6IGhlaWdodCxcblx0XHRcdHJhZGlhbFNlZ21lbnRzOiByYWRpYWxTZWdtZW50cyxcblx0XHRcdGhlaWdodFNlZ21lbnRzOiBoZWlnaHRTZWdtZW50cyxcblx0XHRcdG9wZW5FbmRlZDogb3BlbkVuZGVkLFxuXHRcdFx0dGhldGFTdGFydDogdGhldGFTdGFydCxcblx0XHRcdHRoZXRhTGVuZ3RoOiB0aGV0YUxlbmd0aFxuXHRcdH07XG5cblx0XHRjb25zdCBzY29wZSA9IHRoaXM7XG5cblx0XHRyYWRpYWxTZWdtZW50cyA9IE1hdGguZmxvb3IoIHJhZGlhbFNlZ21lbnRzICk7XG5cdFx0aGVpZ2h0U2VnbWVudHMgPSBNYXRoLmZsb29yKCBoZWlnaHRTZWdtZW50cyApO1xuXG5cdFx0Ly8gYnVmZmVyc1xuXG5cdFx0Y29uc3QgaW5kaWNlcyA9IFtdO1xuXHRcdGNvbnN0IHZlcnRpY2VzID0gW107XG5cdFx0Y29uc3Qgbm9ybWFscyA9IFtdO1xuXHRcdGNvbnN0IHV2cyA9IFtdO1xuXG5cdFx0Ly8gaGVscGVyIHZhcmlhYmxlc1xuXG5cdFx0bGV0IGluZGV4ID0gMDtcblx0XHRjb25zdCBpbmRleEFycmF5ID0gW107XG5cdFx0Y29uc3QgaGFsZkhlaWdodCA9IGhlaWdodCAvIDI7XG5cdFx0bGV0IGdyb3VwU3RhcnQgPSAwO1xuXG5cdFx0Ly8gZ2VuZXJhdGUgZ2VvbWV0cnlcblxuXHRcdGdlbmVyYXRlVG9yc28oKTtcblxuXHRcdGlmICggb3BlbkVuZGVkID09PSBmYWxzZSApIHtcblxuXHRcdFx0aWYgKCByYWRpdXNUb3AgPiAwICkgZ2VuZXJhdGVDYXAoIHRydWUgKTtcblx0XHRcdGlmICggcmFkaXVzQm90dG9tID4gMCApIGdlbmVyYXRlQ2FwKCBmYWxzZSApO1xuXG5cdFx0fVxuXG5cdFx0Ly8gYnVpbGQgZ2VvbWV0cnlcblxuXHRcdHRoaXMuc2V0SW5kZXgoIGluZGljZXMgKTtcblx0XHR0aGlzLnNldEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHZlcnRpY2VzLCAzICkgKTtcblx0XHR0aGlzLnNldEF0dHJpYnV0ZSggJ25vcm1hbCcsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBub3JtYWxzLCAzICkgKTtcblx0XHR0aGlzLnNldEF0dHJpYnV0ZSggJ3V2JywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHV2cywgMiApICk7XG5cblx0XHRmdW5jdGlvbiBnZW5lcmF0ZVRvcnNvKCkge1xuXG5cdFx0XHRjb25zdCBub3JtYWwgPSBuZXcgVmVjdG9yMygpO1xuXHRcdFx0Y29uc3QgdmVydGV4ID0gbmV3IFZlY3RvcjMoKTtcblxuXHRcdFx0bGV0IGdyb3VwQ291bnQgPSAwO1xuXG5cdFx0XHQvLyB0aGlzIHdpbGwgYmUgdXNlZCB0byBjYWxjdWxhdGUgdGhlIG5vcm1hbFxuXHRcdFx0Y29uc3Qgc2xvcGUgPSAoIHJhZGl1c0JvdHRvbSAtIHJhZGl1c1RvcCApIC8gaGVpZ2h0O1xuXG5cdFx0XHQvLyBnZW5lcmF0ZSB2ZXJ0aWNlcywgbm9ybWFscyBhbmQgdXZzXG5cblx0XHRcdGZvciAoIGxldCB5ID0gMDsgeSA8PSBoZWlnaHRTZWdtZW50czsgeSArKyApIHtcblxuXHRcdFx0XHRjb25zdCBpbmRleFJvdyA9IFtdO1xuXG5cdFx0XHRcdGNvbnN0IHYgPSB5IC8gaGVpZ2h0U2VnbWVudHM7XG5cblx0XHRcdFx0Ly8gY2FsY3VsYXRlIHRoZSByYWRpdXMgb2YgdGhlIGN1cnJlbnQgcm93XG5cblx0XHRcdFx0Y29uc3QgcmFkaXVzID0gdiAqICggcmFkaXVzQm90dG9tIC0gcmFkaXVzVG9wICkgKyByYWRpdXNUb3A7XG5cblx0XHRcdFx0Zm9yICggbGV0IHggPSAwOyB4IDw9IHJhZGlhbFNlZ21lbnRzOyB4ICsrICkge1xuXG5cdFx0XHRcdFx0Y29uc3QgdSA9IHggLyByYWRpYWxTZWdtZW50cztcblxuXHRcdFx0XHRcdGNvbnN0IHRoZXRhID0gdSAqIHRoZXRhTGVuZ3RoICsgdGhldGFTdGFydDtcblxuXHRcdFx0XHRcdGNvbnN0IHNpblRoZXRhID0gTWF0aC5zaW4oIHRoZXRhICk7XG5cdFx0XHRcdFx0Y29uc3QgY29zVGhldGEgPSBNYXRoLmNvcyggdGhldGEgKTtcblxuXHRcdFx0XHRcdC8vIHZlcnRleFxuXG5cdFx0XHRcdFx0dmVydGV4LnggPSByYWRpdXMgKiBzaW5UaGV0YTtcblx0XHRcdFx0XHR2ZXJ0ZXgueSA9IC0gdiAqIGhlaWdodCArIGhhbGZIZWlnaHQ7XG5cdFx0XHRcdFx0dmVydGV4LnogPSByYWRpdXMgKiBjb3NUaGV0YTtcblx0XHRcdFx0XHR2ZXJ0aWNlcy5wdXNoKCB2ZXJ0ZXgueCwgdmVydGV4LnksIHZlcnRleC56ICk7XG5cblx0XHRcdFx0XHQvLyBub3JtYWxcblxuXHRcdFx0XHRcdG5vcm1hbC5zZXQoIHNpblRoZXRhLCBzbG9wZSwgY29zVGhldGEgKS5ub3JtYWxpemUoKTtcblx0XHRcdFx0XHRub3JtYWxzLnB1c2goIG5vcm1hbC54LCBub3JtYWwueSwgbm9ybWFsLnogKTtcblxuXHRcdFx0XHRcdC8vIHV2XG5cblx0XHRcdFx0XHR1dnMucHVzaCggdSwgMSAtIHYgKTtcblxuXHRcdFx0XHRcdC8vIHNhdmUgaW5kZXggb2YgdmVydGV4IGluIHJlc3BlY3RpdmUgcm93XG5cblx0XHRcdFx0XHRpbmRleFJvdy5wdXNoKCBpbmRleCArKyApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBub3cgc2F2ZSB2ZXJ0aWNlcyBvZiB0aGUgcm93IGluIG91ciBpbmRleCBhcnJheVxuXG5cdFx0XHRcdGluZGV4QXJyYXkucHVzaCggaW5kZXhSb3cgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBnZW5lcmF0ZSBpbmRpY2VzXG5cblx0XHRcdGZvciAoIGxldCB4ID0gMDsgeCA8IHJhZGlhbFNlZ21lbnRzOyB4ICsrICkge1xuXG5cdFx0XHRcdGZvciAoIGxldCB5ID0gMDsgeSA8IGhlaWdodFNlZ21lbnRzOyB5ICsrICkge1xuXG5cdFx0XHRcdFx0Ly8gd2UgdXNlIHRoZSBpbmRleCBhcnJheSB0byBhY2Nlc3MgdGhlIGNvcnJlY3QgaW5kaWNlc1xuXG5cdFx0XHRcdFx0Y29uc3QgYSA9IGluZGV4QXJyYXlbIHkgXVsgeCBdO1xuXHRcdFx0XHRcdGNvbnN0IGIgPSBpbmRleEFycmF5WyB5ICsgMSBdWyB4IF07XG5cdFx0XHRcdFx0Y29uc3QgYyA9IGluZGV4QXJyYXlbIHkgKyAxIF1bIHggKyAxIF07XG5cdFx0XHRcdFx0Y29uc3QgZCA9IGluZGV4QXJyYXlbIHkgXVsgeCArIDEgXTtcblxuXHRcdFx0XHRcdC8vIGZhY2VzXG5cblx0XHRcdFx0XHRpbmRpY2VzLnB1c2goIGEsIGIsIGQgKTtcblx0XHRcdFx0XHRpbmRpY2VzLnB1c2goIGIsIGMsIGQgKTtcblxuXHRcdFx0XHRcdC8vIHVwZGF0ZSBncm91cCBjb3VudGVyXG5cblx0XHRcdFx0XHRncm91cENvdW50ICs9IDY7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdC8vIGFkZCBhIGdyb3VwIHRvIHRoZSBnZW9tZXRyeS4gdGhpcyB3aWxsIGVuc3VyZSBtdWx0aSBtYXRlcmlhbCBzdXBwb3J0XG5cblx0XHRcdHNjb3BlLmFkZEdyb3VwKCBncm91cFN0YXJ0LCBncm91cENvdW50LCAwICk7XG5cblx0XHRcdC8vIGNhbGN1bGF0ZSBuZXcgc3RhcnQgdmFsdWUgZm9yIGdyb3Vwc1xuXG5cdFx0XHRncm91cFN0YXJ0ICs9IGdyb3VwQ291bnQ7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBnZW5lcmF0ZUNhcCggdG9wICkge1xuXG5cdFx0XHQvLyBzYXZlIHRoZSBpbmRleCBvZiB0aGUgZmlyc3QgY2VudGVyIHZlcnRleFxuXHRcdFx0Y29uc3QgY2VudGVySW5kZXhTdGFydCA9IGluZGV4O1xuXG5cdFx0XHRjb25zdCB1diA9IG5ldyBWZWN0b3IyKCk7XG5cdFx0XHRjb25zdCB2ZXJ0ZXggPSBuZXcgVmVjdG9yMygpO1xuXG5cdFx0XHRsZXQgZ3JvdXBDb3VudCA9IDA7XG5cblx0XHRcdGNvbnN0IHJhZGl1cyA9ICggdG9wID09PSB0cnVlICkgPyByYWRpdXNUb3AgOiByYWRpdXNCb3R0b207XG5cdFx0XHRjb25zdCBzaWduID0gKCB0b3AgPT09IHRydWUgKSA/IDEgOiAtIDE7XG5cblx0XHRcdC8vIGZpcnN0IHdlIGdlbmVyYXRlIHRoZSBjZW50ZXIgdmVydGV4IGRhdGEgb2YgdGhlIGNhcC5cblx0XHRcdC8vIGJlY2F1c2UgdGhlIGdlb21ldHJ5IG5lZWRzIG9uZSBzZXQgb2YgdXZzIHBlciBmYWNlLFxuXHRcdFx0Ly8gd2UgbXVzdCBnZW5lcmF0ZSBhIGNlbnRlciB2ZXJ0ZXggcGVyIGZhY2Uvc2VnbWVudFxuXG5cdFx0XHRmb3IgKCBsZXQgeCA9IDE7IHggPD0gcmFkaWFsU2VnbWVudHM7IHggKysgKSB7XG5cblx0XHRcdFx0Ly8gdmVydGV4XG5cblx0XHRcdFx0dmVydGljZXMucHVzaCggMCwgaGFsZkhlaWdodCAqIHNpZ24sIDAgKTtcblxuXHRcdFx0XHQvLyBub3JtYWxcblxuXHRcdFx0XHRub3JtYWxzLnB1c2goIDAsIHNpZ24sIDAgKTtcblxuXHRcdFx0XHQvLyB1dlxuXG5cdFx0XHRcdHV2cy5wdXNoKCAwLjUsIDAuNSApO1xuXG5cdFx0XHRcdC8vIGluY3JlYXNlIGluZGV4XG5cblx0XHRcdFx0aW5kZXggKys7XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gc2F2ZSB0aGUgaW5kZXggb2YgdGhlIGxhc3QgY2VudGVyIHZlcnRleFxuXHRcdFx0Y29uc3QgY2VudGVySW5kZXhFbmQgPSBpbmRleDtcblxuXHRcdFx0Ly8gbm93IHdlIGdlbmVyYXRlIHRoZSBzdXJyb3VuZGluZyB2ZXJ0aWNlcywgbm9ybWFscyBhbmQgdXZzXG5cblx0XHRcdGZvciAoIGxldCB4ID0gMDsgeCA8PSByYWRpYWxTZWdtZW50czsgeCArKyApIHtcblxuXHRcdFx0XHRjb25zdCB1ID0geCAvIHJhZGlhbFNlZ21lbnRzO1xuXHRcdFx0XHRjb25zdCB0aGV0YSA9IHUgKiB0aGV0YUxlbmd0aCArIHRoZXRhU3RhcnQ7XG5cblx0XHRcdFx0Y29uc3QgY29zVGhldGEgPSBNYXRoLmNvcyggdGhldGEgKTtcblx0XHRcdFx0Y29uc3Qgc2luVGhldGEgPSBNYXRoLnNpbiggdGhldGEgKTtcblxuXHRcdFx0XHQvLyB2ZXJ0ZXhcblxuXHRcdFx0XHR2ZXJ0ZXgueCA9IHJhZGl1cyAqIHNpblRoZXRhO1xuXHRcdFx0XHR2ZXJ0ZXgueSA9IGhhbGZIZWlnaHQgKiBzaWduO1xuXHRcdFx0XHR2ZXJ0ZXgueiA9IHJhZGl1cyAqIGNvc1RoZXRhO1xuXHRcdFx0XHR2ZXJ0aWNlcy5wdXNoKCB2ZXJ0ZXgueCwgdmVydGV4LnksIHZlcnRleC56ICk7XG5cblx0XHRcdFx0Ly8gbm9ybWFsXG5cblx0XHRcdFx0bm9ybWFscy5wdXNoKCAwLCBzaWduLCAwICk7XG5cblx0XHRcdFx0Ly8gdXZcblxuXHRcdFx0XHR1di54ID0gKCBjb3NUaGV0YSAqIDAuNSApICsgMC41O1xuXHRcdFx0XHR1di55ID0gKCBzaW5UaGV0YSAqIDAuNSAqIHNpZ24gKSArIDAuNTtcblx0XHRcdFx0dXZzLnB1c2goIHV2LngsIHV2LnkgKTtcblxuXHRcdFx0XHQvLyBpbmNyZWFzZSBpbmRleFxuXG5cdFx0XHRcdGluZGV4ICsrO1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIGdlbmVyYXRlIGluZGljZXNcblxuXHRcdFx0Zm9yICggbGV0IHggPSAwOyB4IDwgcmFkaWFsU2VnbWVudHM7IHggKysgKSB7XG5cblx0XHRcdFx0Y29uc3QgYyA9IGNlbnRlckluZGV4U3RhcnQgKyB4O1xuXHRcdFx0XHRjb25zdCBpID0gY2VudGVySW5kZXhFbmQgKyB4O1xuXG5cdFx0XHRcdGlmICggdG9wID09PSB0cnVlICkge1xuXG5cdFx0XHRcdFx0Ly8gZmFjZSB0b3BcblxuXHRcdFx0XHRcdGluZGljZXMucHVzaCggaSwgaSArIDEsIGMgKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0Ly8gZmFjZSBib3R0b21cblxuXHRcdFx0XHRcdGluZGljZXMucHVzaCggaSArIDEsIGksIGMgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Z3JvdXBDb3VudCArPSAzO1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIGFkZCBhIGdyb3VwIHRvIHRoZSBnZW9tZXRyeS4gdGhpcyB3aWxsIGVuc3VyZSBtdWx0aSBtYXRlcmlhbCBzdXBwb3J0XG5cblx0XHRcdHNjb3BlLmFkZEdyb3VwKCBncm91cFN0YXJ0LCBncm91cENvdW50LCB0b3AgPT09IHRydWUgPyAxIDogMiApO1xuXG5cdFx0XHQvLyBjYWxjdWxhdGUgbmV3IHN0YXJ0IHZhbHVlIGZvciBncm91cHNcblxuXHRcdFx0Z3JvdXBTdGFydCArPSBncm91cENvdW50O1xuXG5cdFx0fVxuXG5cdH1cblxuXHRjb3B5KCBzb3VyY2UgKSB7XG5cblx0XHRzdXBlci5jb3B5KCBzb3VyY2UgKTtcblxuXHRcdHRoaXMucGFyYW1ldGVycyA9IE9iamVjdC5hc3NpZ24oIHt9LCBzb3VyY2UucGFyYW1ldGVycyApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHN0YXRpYyBmcm9tSlNPTiggZGF0YSApIHtcblxuXHRcdHJldHVybiBuZXcgQ3lsaW5kZXJHZW9tZXRyeSggZGF0YS5yYWRpdXNUb3AsIGRhdGEucmFkaXVzQm90dG9tLCBkYXRhLmhlaWdodCwgZGF0YS5yYWRpYWxTZWdtZW50cywgZGF0YS5oZWlnaHRTZWdtZW50cywgZGF0YS5vcGVuRW5kZWQsIGRhdGEudGhldGFTdGFydCwgZGF0YS50aGV0YUxlbmd0aCApO1xuXG5cdH1cblxufVxuXG5cbmV4cG9ydCB7IEN5bGluZGVyR2VvbWV0cnkgfTtcbiIsImltcG9ydCB7IFBvbHloZWRyb25HZW9tZXRyeSB9IGZyb20gJy4vUG9seWhlZHJvbkdlb21ldHJ5LmpzJztcblxuY2xhc3MgRG9kZWNhaGVkcm9uR2VvbWV0cnkgZXh0ZW5kcyBQb2x5aGVkcm9uR2VvbWV0cnkge1xuXG5cdGNvbnN0cnVjdG9yKCByYWRpdXMgPSAxLCBkZXRhaWwgPSAwICkge1xuXG5cdFx0Y29uc3QgdCA9ICggMSArIE1hdGguc3FydCggNSApICkgLyAyO1xuXHRcdGNvbnN0IHIgPSAxIC8gdDtcblxuXHRcdGNvbnN0IHZlcnRpY2VzID0gW1xuXG5cdFx0XHQvLyAowrExLCDCsTEsIMKxMSlcblx0XHRcdC0gMSwgLSAxLCAtIDEsXHQtIDEsIC0gMSwgMSxcblx0XHRcdC0gMSwgMSwgLSAxLCAtIDEsIDEsIDEsXG5cdFx0XHQxLCAtIDEsIC0gMSwgMSwgLSAxLCAxLFxuXHRcdFx0MSwgMSwgLSAxLCAxLCAxLCAxLFxuXG5cdFx0XHQvLyAoMCwgwrExL8+GLCDCsc+GKVxuXHRcdFx0MCwgLSByLCAtIHQsIDAsIC0gciwgdCxcblx0XHRcdDAsIHIsIC0gdCwgMCwgciwgdCxcblxuXHRcdFx0Ly8gKMKxMS/PhiwgwrHPhiwgMClcblx0XHRcdC0gciwgLSB0LCAwLCAtIHIsIHQsIDAsXG5cdFx0XHRyLCAtIHQsIDAsIHIsIHQsIDAsXG5cblx0XHRcdC8vICjCsc+GLCAwLCDCsTEvz4YpXG5cdFx0XHQtIHQsIDAsIC0gciwgdCwgMCwgLSByLFxuXHRcdFx0LSB0LCAwLCByLCB0LCAwLCByXG5cdFx0XTtcblxuXHRcdGNvbnN0IGluZGljZXMgPSBbXG5cdFx0XHQzLCAxMSwgNywgXHQzLCA3LCAxNSwgXHQzLCAxNSwgMTMsXG5cdFx0XHQ3LCAxOSwgMTcsIFx0NywgMTcsIDYsIFx0NywgNiwgMTUsXG5cdFx0XHQxNywgNCwgOCwgXHQxNywgOCwgMTAsIFx0MTcsIDEwLCA2LFxuXHRcdFx0OCwgMCwgMTYsIFx0OCwgMTYsIDIsIFx0OCwgMiwgMTAsXG5cdFx0XHQwLCAxMiwgMSwgXHQwLCAxLCAxOCwgXHQwLCAxOCwgMTYsXG5cdFx0XHQ2LCAxMCwgMiwgXHQ2LCAyLCAxMywgXHQ2LCAxMywgMTUsXG5cdFx0XHQyLCAxNiwgMTgsIFx0MiwgMTgsIDMsIFx0MiwgMywgMTMsXG5cdFx0XHQxOCwgMSwgOSwgXHQxOCwgOSwgMTEsIFx0MTgsIDExLCAzLFxuXHRcdFx0NCwgMTQsIDEyLCBcdDQsIDEyLCAwLCBcdDQsIDAsIDgsXG5cdFx0XHQxMSwgOSwgNSwgXHQxMSwgNSwgMTksIFx0MTEsIDE5LCA3LFxuXHRcdFx0MTksIDUsIDE0LCBcdDE5LCAxNCwgNCwgXHQxOSwgNCwgMTcsXG5cdFx0XHQxLCAxMiwgMTQsIFx0MSwgMTQsIDUsIFx0MSwgNSwgOVxuXHRcdF07XG5cblx0XHRzdXBlciggdmVydGljZXMsIGluZGljZXMsIHJhZGl1cywgZGV0YWlsICk7XG5cblx0XHR0aGlzLnR5cGUgPSAnRG9kZWNhaGVkcm9uR2VvbWV0cnknO1xuXG5cdFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xuXHRcdFx0cmFkaXVzOiByYWRpdXMsXG5cdFx0XHRkZXRhaWw6IGRldGFpbFxuXHRcdH07XG5cblx0fVxuXG5cdHN0YXRpYyBmcm9tSlNPTiggZGF0YSApIHtcblxuXHRcdHJldHVybiBuZXcgRG9kZWNhaGVkcm9uR2VvbWV0cnkoIGRhdGEucmFkaXVzLCBkYXRhLmRldGFpbCApO1xuXG5cdH1cblxufVxuXG5cbmV4cG9ydCB7IERvZGVjYWhlZHJvbkdlb21ldHJ5IH07XG4iLCJpbXBvcnQgeyBCdWZmZXJHZW9tZXRyeSB9IGZyb20gJy4uL2NvcmUvQnVmZmVyR2VvbWV0cnkuanMnO1xuaW1wb3J0IHsgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSB9IGZyb20gJy4uL2NvcmUvQnVmZmVyQXR0cmlidXRlLmpzJztcbmltcG9ydCAqIGFzIE1hdGhVdGlscyBmcm9tICcuLi9tYXRoL01hdGhVdGlscy5qcyc7XG5pbXBvcnQgeyBUcmlhbmdsZSB9IGZyb20gJy4uL21hdGgvVHJpYW5nbGUuanMnO1xuaW1wb3J0IHsgVmVjdG9yMyB9IGZyb20gJy4uL21hdGgvVmVjdG9yMy5qcyc7XG5cbmNvbnN0IF92MCA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcbmNvbnN0IF92MSA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcbmNvbnN0IF9ub3JtYWwgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XG5jb25zdCBfdHJpYW5nbGUgPSAvKkBfX1BVUkVfXyovIG5ldyBUcmlhbmdsZSgpO1xuXG5jbGFzcyBFZGdlc0dlb21ldHJ5IGV4dGVuZHMgQnVmZmVyR2VvbWV0cnkge1xuXG5cdGNvbnN0cnVjdG9yKCBnZW9tZXRyeSA9IG51bGwsIHRocmVzaG9sZEFuZ2xlID0gMSApIHtcblxuXHRcdHN1cGVyKCk7XG5cblx0XHR0aGlzLnR5cGUgPSAnRWRnZXNHZW9tZXRyeSc7XG5cblx0XHR0aGlzLnBhcmFtZXRlcnMgPSB7XG5cdFx0XHRnZW9tZXRyeTogZ2VvbWV0cnksXG5cdFx0XHR0aHJlc2hvbGRBbmdsZTogdGhyZXNob2xkQW5nbGVcblx0XHR9O1xuXG5cdFx0aWYgKCBnZW9tZXRyeSAhPT0gbnVsbCApIHtcblxuXHRcdFx0Y29uc3QgcHJlY2lzaW9uUG9pbnRzID0gNDtcblx0XHRcdGNvbnN0IHByZWNpc2lvbiA9IE1hdGgucG93KCAxMCwgcHJlY2lzaW9uUG9pbnRzICk7XG5cdFx0XHRjb25zdCB0aHJlc2hvbGREb3QgPSBNYXRoLmNvcyggTWF0aFV0aWxzLkRFRzJSQUQgKiB0aHJlc2hvbGRBbmdsZSApO1xuXG5cdFx0XHRjb25zdCBpbmRleEF0dHIgPSBnZW9tZXRyeS5nZXRJbmRleCgpO1xuXHRcdFx0Y29uc3QgcG9zaXRpb25BdHRyID0gZ2VvbWV0cnkuZ2V0QXR0cmlidXRlKCAncG9zaXRpb24nICk7XG5cdFx0XHRjb25zdCBpbmRleENvdW50ID0gaW5kZXhBdHRyID8gaW5kZXhBdHRyLmNvdW50IDogcG9zaXRpb25BdHRyLmNvdW50O1xuXG5cdFx0XHRjb25zdCBpbmRleEFyciA9IFsgMCwgMCwgMCBdO1xuXHRcdFx0Y29uc3QgdmVydEtleXMgPSBbICdhJywgJ2InLCAnYycgXTtcblx0XHRcdGNvbnN0IGhhc2hlcyA9IG5ldyBBcnJheSggMyApO1xuXG5cdFx0XHRjb25zdCBlZGdlRGF0YSA9IHt9O1xuXHRcdFx0Y29uc3QgdmVydGljZXMgPSBbXTtcblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IGluZGV4Q291bnQ7IGkgKz0gMyApIHtcblxuXHRcdFx0XHRpZiAoIGluZGV4QXR0ciApIHtcblxuXHRcdFx0XHRcdGluZGV4QXJyWyAwIF0gPSBpbmRleEF0dHIuZ2V0WCggaSApO1xuXHRcdFx0XHRcdGluZGV4QXJyWyAxIF0gPSBpbmRleEF0dHIuZ2V0WCggaSArIDEgKTtcblx0XHRcdFx0XHRpbmRleEFyclsgMiBdID0gaW5kZXhBdHRyLmdldFgoIGkgKyAyICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdGluZGV4QXJyWyAwIF0gPSBpO1xuXHRcdFx0XHRcdGluZGV4QXJyWyAxIF0gPSBpICsgMTtcblx0XHRcdFx0XHRpbmRleEFyclsgMiBdID0gaSArIDI7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNvbnN0IHsgYSwgYiwgYyB9ID0gX3RyaWFuZ2xlO1xuXHRcdFx0XHRhLmZyb21CdWZmZXJBdHRyaWJ1dGUoIHBvc2l0aW9uQXR0ciwgaW5kZXhBcnJbIDAgXSApO1xuXHRcdFx0XHRiLmZyb21CdWZmZXJBdHRyaWJ1dGUoIHBvc2l0aW9uQXR0ciwgaW5kZXhBcnJbIDEgXSApO1xuXHRcdFx0XHRjLmZyb21CdWZmZXJBdHRyaWJ1dGUoIHBvc2l0aW9uQXR0ciwgaW5kZXhBcnJbIDIgXSApO1xuXHRcdFx0XHRfdHJpYW5nbGUuZ2V0Tm9ybWFsKCBfbm9ybWFsICk7XG5cblx0XHRcdFx0Ly8gY3JlYXRlIGhhc2hlcyBmb3IgdGhlIGVkZ2UgZnJvbSB0aGUgdmVydGljZXNcblx0XHRcdFx0aGFzaGVzWyAwIF0gPSBgJHsgTWF0aC5yb3VuZCggYS54ICogcHJlY2lzaW9uICkgfSwkeyBNYXRoLnJvdW5kKCBhLnkgKiBwcmVjaXNpb24gKSB9LCR7IE1hdGgucm91bmQoIGEueiAqIHByZWNpc2lvbiApIH1gO1xuXHRcdFx0XHRoYXNoZXNbIDEgXSA9IGAkeyBNYXRoLnJvdW5kKCBiLnggKiBwcmVjaXNpb24gKSB9LCR7IE1hdGgucm91bmQoIGIueSAqIHByZWNpc2lvbiApIH0sJHsgTWF0aC5yb3VuZCggYi56ICogcHJlY2lzaW9uICkgfWA7XG5cdFx0XHRcdGhhc2hlc1sgMiBdID0gYCR7IE1hdGgucm91bmQoIGMueCAqIHByZWNpc2lvbiApIH0sJHsgTWF0aC5yb3VuZCggYy55ICogcHJlY2lzaW9uICkgfSwkeyBNYXRoLnJvdW5kKCBjLnogKiBwcmVjaXNpb24gKSB9YDtcblxuXHRcdFx0XHQvLyBza2lwIGRlZ2VuZXJhdGUgdHJpYW5nbGVzXG5cdFx0XHRcdGlmICggaGFzaGVzWyAwIF0gPT09IGhhc2hlc1sgMSBdIHx8IGhhc2hlc1sgMSBdID09PSBoYXNoZXNbIDIgXSB8fCBoYXNoZXNbIDIgXSA9PT0gaGFzaGVzWyAwIF0gKSB7XG5cblx0XHRcdFx0XHRjb250aW51ZTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gaXRlcmF0ZSBvdmVyIGV2ZXJ5IGVkZ2Vcblx0XHRcdFx0Zm9yICggbGV0IGogPSAwOyBqIDwgMzsgaiArKyApIHtcblxuXHRcdFx0XHRcdC8vIGdldCB0aGUgZmlyc3QgYW5kIG5leHQgdmVydGV4IG1ha2luZyB1cCB0aGUgZWRnZVxuXHRcdFx0XHRcdGNvbnN0IGpOZXh0ID0gKCBqICsgMSApICUgMztcblx0XHRcdFx0XHRjb25zdCB2ZWNIYXNoMCA9IGhhc2hlc1sgaiBdO1xuXHRcdFx0XHRcdGNvbnN0IHZlY0hhc2gxID0gaGFzaGVzWyBqTmV4dCBdO1xuXHRcdFx0XHRcdGNvbnN0IHYwID0gX3RyaWFuZ2xlWyB2ZXJ0S2V5c1sgaiBdIF07XG5cdFx0XHRcdFx0Y29uc3QgdjEgPSBfdHJpYW5nbGVbIHZlcnRLZXlzWyBqTmV4dCBdIF07XG5cblx0XHRcdFx0XHRjb25zdCBoYXNoID0gYCR7IHZlY0hhc2gwIH1fJHsgdmVjSGFzaDEgfWA7XG5cdFx0XHRcdFx0Y29uc3QgcmV2ZXJzZUhhc2ggPSBgJHsgdmVjSGFzaDEgfV8keyB2ZWNIYXNoMCB9YDtcblxuXHRcdFx0XHRcdGlmICggcmV2ZXJzZUhhc2ggaW4gZWRnZURhdGEgJiYgZWRnZURhdGFbIHJldmVyc2VIYXNoIF0gKSB7XG5cblx0XHRcdFx0XHRcdC8vIGlmIHdlIGZvdW5kIGEgc2libGluZyBlZGdlIGFkZCBpdCBpbnRvIHRoZSB2ZXJ0ZXggYXJyYXkgaWZcblx0XHRcdFx0XHRcdC8vIGl0IG1lZXRzIHRoZSBhbmdsZSB0aHJlc2hvbGQgYW5kIGRlbGV0ZSB0aGUgZWRnZSBmcm9tIHRoZSBtYXAuXG5cdFx0XHRcdFx0XHRpZiAoIF9ub3JtYWwuZG90KCBlZGdlRGF0YVsgcmV2ZXJzZUhhc2ggXS5ub3JtYWwgKSA8PSB0aHJlc2hvbGREb3QgKSB7XG5cblx0XHRcdFx0XHRcdFx0dmVydGljZXMucHVzaCggdjAueCwgdjAueSwgdjAueiApO1xuXHRcdFx0XHRcdFx0XHR2ZXJ0aWNlcy5wdXNoKCB2MS54LCB2MS55LCB2MS56ICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0ZWRnZURhdGFbIHJldmVyc2VIYXNoIF0gPSBudWxsO1xuXG5cdFx0XHRcdFx0fSBlbHNlIGlmICggISAoIGhhc2ggaW4gZWRnZURhdGEgKSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gaWYgd2UndmUgYWxyZWFkeSBnb3QgYW4gZWRnZSBoZXJlIHRoZW4gc2tpcCBhZGRpbmcgYSBuZXcgb25lXG5cdFx0XHRcdFx0XHRlZGdlRGF0YVsgaGFzaCBdID0ge1xuXG5cdFx0XHRcdFx0XHRcdGluZGV4MDogaW5kZXhBcnJbIGogXSxcblx0XHRcdFx0XHRcdFx0aW5kZXgxOiBpbmRleEFyclsgak5leHQgXSxcblx0XHRcdFx0XHRcdFx0bm9ybWFsOiBfbm9ybWFsLmNsb25lKCksXG5cblx0XHRcdFx0XHRcdH07XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdC8vIGl0ZXJhdGUgb3ZlciBhbGwgcmVtYWluaW5nLCB1bm1hdGNoZWQgZWRnZXMgYW5kIGFkZCB0aGVtIHRvIHRoZSB2ZXJ0ZXggYXJyYXlcblx0XHRcdGZvciAoIGNvbnN0IGtleSBpbiBlZGdlRGF0YSApIHtcblxuXHRcdFx0XHRpZiAoIGVkZ2VEYXRhWyBrZXkgXSApIHtcblxuXHRcdFx0XHRcdGNvbnN0IHsgaW5kZXgwLCBpbmRleDEgfSA9IGVkZ2VEYXRhWyBrZXkgXTtcblx0XHRcdFx0XHRfdjAuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggcG9zaXRpb25BdHRyLCBpbmRleDAgKTtcblx0XHRcdFx0XHRfdjEuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggcG9zaXRpb25BdHRyLCBpbmRleDEgKTtcblxuXHRcdFx0XHRcdHZlcnRpY2VzLnB1c2goIF92MC54LCBfdjAueSwgX3YwLnogKTtcblx0XHRcdFx0XHR2ZXJ0aWNlcy5wdXNoKCBfdjEueCwgX3YxLnksIF92MS56ICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuc2V0QXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggdmVydGljZXMsIDMgKSApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRjb3B5KCBzb3VyY2UgKSB7XG5cblx0XHRzdXBlci5jb3B5KCBzb3VyY2UgKTtcblxuXHRcdHRoaXMucGFyYW1ldGVycyA9IE9iamVjdC5hc3NpZ24oIHt9LCBzb3VyY2UucGFyYW1ldGVycyApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG59XG5cbmV4cG9ydCB7IEVkZ2VzR2VvbWV0cnkgfTtcbiIsIi8qKlxuICogQ3JlYXRlcyBleHRydWRlZCBnZW9tZXRyeSBmcm9tIGEgcGF0aCBzaGFwZS5cbiAqXG4gKiBwYXJhbWV0ZXJzID0ge1xuICpcbiAqICBjdXJ2ZVNlZ21lbnRzOiA8aW50PiwgLy8gbnVtYmVyIG9mIHBvaW50cyBvbiB0aGUgY3VydmVzXG4gKiAgc3RlcHM6IDxpbnQ+LCAvLyBudW1iZXIgb2YgcG9pbnRzIGZvciB6LXNpZGUgZXh0cnVzaW9ucyAvIHVzZWQgZm9yIHN1YmRpdmlkaW5nIHNlZ21lbnRzIG9mIGV4dHJ1ZGUgc3BsaW5lIHRvb1xuICogIGRlcHRoOiA8ZmxvYXQ+LCAvLyBEZXB0aCB0byBleHRydWRlIHRoZSBzaGFwZVxuICpcbiAqICBiZXZlbEVuYWJsZWQ6IDxib29sPiwgLy8gdHVybiBvbiBiZXZlbFxuICogIGJldmVsVGhpY2tuZXNzOiA8ZmxvYXQ+LCAvLyBob3cgZGVlcCBpbnRvIHRoZSBvcmlnaW5hbCBzaGFwZSBiZXZlbCBnb2VzXG4gKiAgYmV2ZWxTaXplOiA8ZmxvYXQ+LCAvLyBob3cgZmFyIGZyb20gc2hhcGUgb3V0bGluZSAoaW5jbHVkaW5nIGJldmVsT2Zmc2V0KSBpcyBiZXZlbFxuICogIGJldmVsT2Zmc2V0OiA8ZmxvYXQ+LCAvLyBob3cgZmFyIGZyb20gc2hhcGUgb3V0bGluZSBkb2VzIGJldmVsIHN0YXJ0XG4gKiAgYmV2ZWxTZWdtZW50czogPGludD4sIC8vIG51bWJlciBvZiBiZXZlbCBsYXllcnNcbiAqXG4gKiAgZXh0cnVkZVBhdGg6IDxUSFJFRS5DdXJ2ZT4gLy8gY3VydmUgdG8gZXh0cnVkZSBzaGFwZSBhbG9uZ1xuICpcbiAqICBVVkdlbmVyYXRvcjogPE9iamVjdD4gLy8gb2JqZWN0IHRoYXQgcHJvdmlkZXMgVVYgZ2VuZXJhdG9yIGZ1bmN0aW9uc1xuICpcbiAqIH1cbiAqL1xuXG5pbXBvcnQgeyBCdWZmZXJHZW9tZXRyeSB9IGZyb20gJy4uL2NvcmUvQnVmZmVyR2VvbWV0cnkuanMnO1xuaW1wb3J0IHsgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSB9IGZyb20gJy4uL2NvcmUvQnVmZmVyQXR0cmlidXRlLmpzJztcbmltcG9ydCAqIGFzIEN1cnZlcyBmcm9tICcuLi9leHRyYXMvY3VydmVzL0N1cnZlcy5qcyc7XG5pbXBvcnQgeyBWZWN0b3IyIH0gZnJvbSAnLi4vbWF0aC9WZWN0b3IyLmpzJztcbmltcG9ydCB7IFZlY3RvcjMgfSBmcm9tICcuLi9tYXRoL1ZlY3RvcjMuanMnO1xuaW1wb3J0IHsgU2hhcGUgfSBmcm9tICcuLi9leHRyYXMvY29yZS9TaGFwZS5qcyc7XG5pbXBvcnQgeyBTaGFwZVV0aWxzIH0gZnJvbSAnLi4vZXh0cmFzL1NoYXBlVXRpbHMuanMnO1xuXG5jbGFzcyBFeHRydWRlR2VvbWV0cnkgZXh0ZW5kcyBCdWZmZXJHZW9tZXRyeSB7XG5cblx0Y29uc3RydWN0b3IoIHNoYXBlcyA9IG5ldyBTaGFwZSggWyBuZXcgVmVjdG9yMiggMC41LCAwLjUgKSwgbmV3IFZlY3RvcjIoIC0gMC41LCAwLjUgKSwgbmV3IFZlY3RvcjIoIC0gMC41LCAtIDAuNSApLCBuZXcgVmVjdG9yMiggMC41LCAtIDAuNSApIF0gKSwgb3B0aW9ucyA9IHt9ICkge1xuXG5cdFx0c3VwZXIoKTtcblxuXHRcdHRoaXMudHlwZSA9ICdFeHRydWRlR2VvbWV0cnknO1xuXG5cdFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xuXHRcdFx0c2hhcGVzOiBzaGFwZXMsXG5cdFx0XHRvcHRpb25zOiBvcHRpb25zXG5cdFx0fTtcblxuXHRcdHNoYXBlcyA9IEFycmF5LmlzQXJyYXkoIHNoYXBlcyApID8gc2hhcGVzIDogWyBzaGFwZXMgXTtcblxuXHRcdGNvbnN0IHNjb3BlID0gdGhpcztcblxuXHRcdGNvbnN0IHZlcnRpY2VzQXJyYXkgPSBbXTtcblx0XHRjb25zdCB1dkFycmF5ID0gW107XG5cblx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBzaGFwZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0Y29uc3Qgc2hhcGUgPSBzaGFwZXNbIGkgXTtcblx0XHRcdGFkZFNoYXBlKCBzaGFwZSApO1xuXG5cdFx0fVxuXG5cdFx0Ly8gYnVpbGQgZ2VvbWV0cnlcblxuXHRcdHRoaXMuc2V0QXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggdmVydGljZXNBcnJheSwgMyApICk7XG5cdFx0dGhpcy5zZXRBdHRyaWJ1dGUoICd1dicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCB1dkFycmF5LCAyICkgKTtcblxuXHRcdHRoaXMuY29tcHV0ZVZlcnRleE5vcm1hbHMoKTtcblxuXHRcdC8vIGZ1bmN0aW9uc1xuXG5cdFx0ZnVuY3Rpb24gYWRkU2hhcGUoIHNoYXBlICkge1xuXG5cdFx0XHRjb25zdCBwbGFjZWhvbGRlciA9IFtdO1xuXG5cdFx0XHQvLyBvcHRpb25zXG5cblx0XHRcdGNvbnN0IGN1cnZlU2VnbWVudHMgPSBvcHRpb25zLmN1cnZlU2VnbWVudHMgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuY3VydmVTZWdtZW50cyA6IDEyO1xuXHRcdFx0Y29uc3Qgc3RlcHMgPSBvcHRpb25zLnN0ZXBzICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnN0ZXBzIDogMTtcblx0XHRcdGNvbnN0IGRlcHRoID0gb3B0aW9ucy5kZXB0aCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5kZXB0aCA6IDE7XG5cblx0XHRcdGxldCBiZXZlbEVuYWJsZWQgPSBvcHRpb25zLmJldmVsRW5hYmxlZCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5iZXZlbEVuYWJsZWQgOiB0cnVlO1xuXHRcdFx0bGV0IGJldmVsVGhpY2tuZXNzID0gb3B0aW9ucy5iZXZlbFRoaWNrbmVzcyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5iZXZlbFRoaWNrbmVzcyA6IDAuMjtcblx0XHRcdGxldCBiZXZlbFNpemUgPSBvcHRpb25zLmJldmVsU2l6ZSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5iZXZlbFNpemUgOiBiZXZlbFRoaWNrbmVzcyAtIDAuMTtcblx0XHRcdGxldCBiZXZlbE9mZnNldCA9IG9wdGlvbnMuYmV2ZWxPZmZzZXQgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuYmV2ZWxPZmZzZXQgOiAwO1xuXHRcdFx0bGV0IGJldmVsU2VnbWVudHMgPSBvcHRpb25zLmJldmVsU2VnbWVudHMgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuYmV2ZWxTZWdtZW50cyA6IDM7XG5cblx0XHRcdGNvbnN0IGV4dHJ1ZGVQYXRoID0gb3B0aW9ucy5leHRydWRlUGF0aDtcblxuXHRcdFx0Y29uc3QgdXZnZW4gPSBvcHRpb25zLlVWR2VuZXJhdG9yICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLlVWR2VuZXJhdG9yIDogV29ybGRVVkdlbmVyYXRvcjtcblxuXHRcdFx0Ly9cblxuXHRcdFx0bGV0IGV4dHJ1ZGVQdHMsIGV4dHJ1ZGVCeVBhdGggPSBmYWxzZTtcblx0XHRcdGxldCBzcGxpbmVUdWJlLCBiaW5vcm1hbCwgbm9ybWFsLCBwb3NpdGlvbjI7XG5cblx0XHRcdGlmICggZXh0cnVkZVBhdGggKSB7XG5cblx0XHRcdFx0ZXh0cnVkZVB0cyA9IGV4dHJ1ZGVQYXRoLmdldFNwYWNlZFBvaW50cyggc3RlcHMgKTtcblxuXHRcdFx0XHRleHRydWRlQnlQYXRoID0gdHJ1ZTtcblx0XHRcdFx0YmV2ZWxFbmFibGVkID0gZmFsc2U7IC8vIGJldmVscyBub3Qgc3VwcG9ydGVkIGZvciBwYXRoIGV4dHJ1c2lvblxuXG5cdFx0XHRcdC8vIFNFVFVQIFROQiB2YXJpYWJsZXNcblxuXHRcdFx0XHQvLyBUT0RPMSAtIGhhdmUgYSAuaXNDbG9zZWQgaW4gc3BsaW5lP1xuXG5cdFx0XHRcdHNwbGluZVR1YmUgPSBleHRydWRlUGF0aC5jb21wdXRlRnJlbmV0RnJhbWVzKCBzdGVwcywgZmFsc2UgKTtcblxuXHRcdFx0XHQvLyBjb25zb2xlLmxvZyhzcGxpbmVUdWJlLCAnc3BsaW5lVHViZScsIHNwbGluZVR1YmUubm9ybWFscy5sZW5ndGgsICdzdGVwcycsIHN0ZXBzLCAnZXh0cnVkZVB0cycsIGV4dHJ1ZGVQdHMubGVuZ3RoKTtcblxuXHRcdFx0XHRiaW5vcm1hbCA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0XHRcdG5vcm1hbCA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0XHRcdHBvc2l0aW9uMiA9IG5ldyBWZWN0b3IzKCk7XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gU2FmZWd1YXJkcyBpZiBiZXZlbHMgYXJlIG5vdCBlbmFibGVkXG5cblx0XHRcdGlmICggISBiZXZlbEVuYWJsZWQgKSB7XG5cblx0XHRcdFx0YmV2ZWxTZWdtZW50cyA9IDA7XG5cdFx0XHRcdGJldmVsVGhpY2tuZXNzID0gMDtcblx0XHRcdFx0YmV2ZWxTaXplID0gMDtcblx0XHRcdFx0YmV2ZWxPZmZzZXQgPSAwO1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIFZhcmlhYmxlcyBpbml0aWFsaXphdGlvblxuXG5cdFx0XHRjb25zdCBzaGFwZVBvaW50cyA9IHNoYXBlLmV4dHJhY3RQb2ludHMoIGN1cnZlU2VnbWVudHMgKTtcblxuXHRcdFx0bGV0IHZlcnRpY2VzID0gc2hhcGVQb2ludHMuc2hhcGU7XG5cdFx0XHRjb25zdCBob2xlcyA9IHNoYXBlUG9pbnRzLmhvbGVzO1xuXG5cdFx0XHRjb25zdCByZXZlcnNlID0gISBTaGFwZVV0aWxzLmlzQ2xvY2tXaXNlKCB2ZXJ0aWNlcyApO1xuXG5cdFx0XHRpZiAoIHJldmVyc2UgKSB7XG5cblx0XHRcdFx0dmVydGljZXMgPSB2ZXJ0aWNlcy5yZXZlcnNlKCk7XG5cblx0XHRcdFx0Ly8gTWF5YmUgd2Ugc2hvdWxkIGFsc28gY2hlY2sgaWYgaG9sZXMgYXJlIGluIHRoZSBvcHBvc2l0ZSBkaXJlY3Rpb24sIGp1c3QgdG8gYmUgc2FmZSAuLi5cblxuXHRcdFx0XHRmb3IgKCBsZXQgaCA9IDAsIGhsID0gaG9sZXMubGVuZ3RoOyBoIDwgaGw7IGggKysgKSB7XG5cblx0XHRcdFx0XHRjb25zdCBhaG9sZSA9IGhvbGVzWyBoIF07XG5cblx0XHRcdFx0XHRpZiAoIFNoYXBlVXRpbHMuaXNDbG9ja1dpc2UoIGFob2xlICkgKSB7XG5cblx0XHRcdFx0XHRcdGhvbGVzWyBoIF0gPSBhaG9sZS5yZXZlcnNlKCk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblxuXHRcdFx0Y29uc3QgZmFjZXMgPSBTaGFwZVV0aWxzLnRyaWFuZ3VsYXRlU2hhcGUoIHZlcnRpY2VzLCBob2xlcyApO1xuXG5cdFx0XHQvKiBWZXJ0aWNlcyAqL1xuXG5cdFx0XHRjb25zdCBjb250b3VyID0gdmVydGljZXM7IC8vIHZlcnRpY2VzIGhhcyBhbGwgcG9pbnRzIGJ1dCBjb250b3VyIGhhcyBvbmx5IHBvaW50cyBvZiBjaXJjdW1mZXJlbmNlXG5cblx0XHRcdGZvciAoIGxldCBoID0gMCwgaGwgPSBob2xlcy5sZW5ndGg7IGggPCBobDsgaCArKyApIHtcblxuXHRcdFx0XHRjb25zdCBhaG9sZSA9IGhvbGVzWyBoIF07XG5cblx0XHRcdFx0dmVydGljZXMgPSB2ZXJ0aWNlcy5jb25jYXQoIGFob2xlICk7XG5cblx0XHRcdH1cblxuXG5cdFx0XHRmdW5jdGlvbiBzY2FsZVB0MiggcHQsIHZlYywgc2l6ZSApIHtcblxuXHRcdFx0XHRpZiAoICEgdmVjICkgY29uc29sZS5lcnJvciggJ1RIUkVFLkV4dHJ1ZGVHZW9tZXRyeTogdmVjIGRvZXMgbm90IGV4aXN0JyApO1xuXG5cdFx0XHRcdHJldHVybiBwdC5jbG9uZSgpLmFkZFNjYWxlZFZlY3RvciggdmVjLCBzaXplICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgdmxlbiA9IHZlcnRpY2VzLmxlbmd0aCwgZmxlbiA9IGZhY2VzLmxlbmd0aDtcblxuXG5cdFx0XHQvLyBGaW5kIGRpcmVjdGlvbnMgZm9yIHBvaW50IG1vdmVtZW50XG5cblxuXHRcdFx0ZnVuY3Rpb24gZ2V0QmV2ZWxWZWMoIGluUHQsIGluUHJldiwgaW5OZXh0ICkge1xuXG5cdFx0XHRcdC8vIGNvbXB1dGVzIGZvciBpblB0IHRoZSBjb3JyZXNwb25kaW5nIHBvaW50IGluUHQnIG9uIGEgbmV3IGNvbnRvdXJcblx0XHRcdFx0Ly8gICBzaGlmdGVkIGJ5IDEgdW5pdCAobGVuZ3RoIG9mIG5vcm1hbGl6ZWQgdmVjdG9yKSB0byB0aGUgbGVmdFxuXHRcdFx0XHQvLyBpZiB3ZSB3YWxrIGFsb25nIGNvbnRvdXIgY2xvY2t3aXNlLCB0aGlzIG5ldyBjb250b3VyIGlzIG91dHNpZGUgdGhlIG9sZCBvbmVcblx0XHRcdFx0Ly9cblx0XHRcdFx0Ly8gaW5QdCcgaXMgdGhlIGludGVyc2VjdGlvbiBvZiB0aGUgdHdvIGxpbmVzIHBhcmFsbGVsIHRvIHRoZSB0d29cblx0XHRcdFx0Ly8gIGFkamFjZW50IGVkZ2VzIG9mIGluUHQgYXQgYSBkaXN0YW5jZSBvZiAxIHVuaXQgb24gdGhlIGxlZnQgc2lkZS5cblxuXHRcdFx0XHRsZXQgdl90cmFuc194LCB2X3RyYW5zX3ksIHNocmlua19ieTsgLy8gcmVzdWx0aW5nIHRyYW5zbGF0aW9uIHZlY3RvciBmb3IgaW5QdFxuXG5cdFx0XHRcdC8vIGdvb2QgcmVhZGluZyBmb3IgZ2VvbWV0cnkgYWxnb3JpdGhtcyAoaGVyZTogbGluZS1saW5lIGludGVyc2VjdGlvbilcblx0XHRcdFx0Ly8gaHR0cDovL2dlb21hbGdvcml0aG1zLmNvbS9hMDUtX2ludGVyc2VjdC0xLmh0bWxcblxuXHRcdFx0XHRjb25zdCB2X3ByZXZfeCA9IGluUHQueCAtIGluUHJldi54LFxuXHRcdFx0XHRcdHZfcHJldl95ID0gaW5QdC55IC0gaW5QcmV2Lnk7XG5cdFx0XHRcdGNvbnN0IHZfbmV4dF94ID0gaW5OZXh0LnggLSBpblB0LngsXG5cdFx0XHRcdFx0dl9uZXh0X3kgPSBpbk5leHQueSAtIGluUHQueTtcblxuXHRcdFx0XHRjb25zdCB2X3ByZXZfbGVuc3EgPSAoIHZfcHJldl94ICogdl9wcmV2X3ggKyB2X3ByZXZfeSAqIHZfcHJldl95ICk7XG5cblx0XHRcdFx0Ly8gY2hlY2sgZm9yIGNvbGxpbmVhciBlZGdlc1xuXHRcdFx0XHRjb25zdCBjb2xsaW5lYXIwID0gKCB2X3ByZXZfeCAqIHZfbmV4dF95IC0gdl9wcmV2X3kgKiB2X25leHRfeCApO1xuXG5cdFx0XHRcdGlmICggTWF0aC5hYnMoIGNvbGxpbmVhcjAgKSA+IE51bWJlci5FUFNJTE9OICkge1xuXG5cdFx0XHRcdFx0Ly8gbm90IGNvbGxpbmVhclxuXG5cdFx0XHRcdFx0Ly8gbGVuZ3RoIG9mIHZlY3RvcnMgZm9yIG5vcm1hbGl6aW5nXG5cblx0XHRcdFx0XHRjb25zdCB2X3ByZXZfbGVuID0gTWF0aC5zcXJ0KCB2X3ByZXZfbGVuc3EgKTtcblx0XHRcdFx0XHRjb25zdCB2X25leHRfbGVuID0gTWF0aC5zcXJ0KCB2X25leHRfeCAqIHZfbmV4dF94ICsgdl9uZXh0X3kgKiB2X25leHRfeSApO1xuXG5cdFx0XHRcdFx0Ly8gc2hpZnQgYWRqYWNlbnQgcG9pbnRzIGJ5IHVuaXQgdmVjdG9ycyB0byB0aGUgbGVmdFxuXG5cdFx0XHRcdFx0Y29uc3QgcHRQcmV2U2hpZnRfeCA9ICggaW5QcmV2LnggLSB2X3ByZXZfeSAvIHZfcHJldl9sZW4gKTtcblx0XHRcdFx0XHRjb25zdCBwdFByZXZTaGlmdF95ID0gKCBpblByZXYueSArIHZfcHJldl94IC8gdl9wcmV2X2xlbiApO1xuXG5cdFx0XHRcdFx0Y29uc3QgcHROZXh0U2hpZnRfeCA9ICggaW5OZXh0LnggLSB2X25leHRfeSAvIHZfbmV4dF9sZW4gKTtcblx0XHRcdFx0XHRjb25zdCBwdE5leHRTaGlmdF95ID0gKCBpbk5leHQueSArIHZfbmV4dF94IC8gdl9uZXh0X2xlbiApO1xuXG5cdFx0XHRcdFx0Ly8gc2NhbGluZyBmYWN0b3IgZm9yIHZfcHJldiB0byBpbnRlcnNlY3Rpb24gcG9pbnRcblxuXHRcdFx0XHRcdGNvbnN0IHNmID0gKCAoIHB0TmV4dFNoaWZ0X3ggLSBwdFByZXZTaGlmdF94ICkgKiB2X25leHRfeSAtXG5cdFx0XHRcdFx0XHRcdCggcHROZXh0U2hpZnRfeSAtIHB0UHJldlNoaWZ0X3kgKSAqIHZfbmV4dF94ICkgL1xuXHRcdFx0XHRcdFx0KCB2X3ByZXZfeCAqIHZfbmV4dF95IC0gdl9wcmV2X3kgKiB2X25leHRfeCApO1xuXG5cdFx0XHRcdFx0Ly8gdmVjdG9yIGZyb20gaW5QdCB0byBpbnRlcnNlY3Rpb24gcG9pbnRcblxuXHRcdFx0XHRcdHZfdHJhbnNfeCA9ICggcHRQcmV2U2hpZnRfeCArIHZfcHJldl94ICogc2YgLSBpblB0LnggKTtcblx0XHRcdFx0XHR2X3RyYW5zX3kgPSAoIHB0UHJldlNoaWZ0X3kgKyB2X3ByZXZfeSAqIHNmIC0gaW5QdC55ICk7XG5cblx0XHRcdFx0XHQvLyBEb24ndCBub3JtYWxpemUhLCBvdGhlcndpc2Ugc2hhcnAgY29ybmVycyBiZWNvbWUgdWdseVxuXHRcdFx0XHRcdC8vICBidXQgcHJldmVudCBjcmF6eSBzcGlrZXNcblx0XHRcdFx0XHRjb25zdCB2X3RyYW5zX2xlbnNxID0gKCB2X3RyYW5zX3ggKiB2X3RyYW5zX3ggKyB2X3RyYW5zX3kgKiB2X3RyYW5zX3kgKTtcblx0XHRcdFx0XHRpZiAoIHZfdHJhbnNfbGVuc3EgPD0gMiApIHtcblxuXHRcdFx0XHRcdFx0cmV0dXJuIG5ldyBWZWN0b3IyKCB2X3RyYW5zX3gsIHZfdHJhbnNfeSApO1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0c2hyaW5rX2J5ID0gTWF0aC5zcXJ0KCB2X3RyYW5zX2xlbnNxIC8gMiApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHQvLyBoYW5kbGUgc3BlY2lhbCBjYXNlIG9mIGNvbGxpbmVhciBlZGdlc1xuXG5cdFx0XHRcdFx0bGV0IGRpcmVjdGlvbl9lcSA9IGZhbHNlOyAvLyBhc3N1bWVzOiBvcHBvc2l0ZVxuXG5cdFx0XHRcdFx0aWYgKCB2X3ByZXZfeCA+IE51bWJlci5FUFNJTE9OICkge1xuXG5cdFx0XHRcdFx0XHRpZiAoIHZfbmV4dF94ID4gTnVtYmVyLkVQU0lMT04gKSB7XG5cblx0XHRcdFx0XHRcdFx0ZGlyZWN0aW9uX2VxID0gdHJ1ZTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0aWYgKCB2X3ByZXZfeCA8IC0gTnVtYmVyLkVQU0lMT04gKSB7XG5cblx0XHRcdFx0XHRcdFx0aWYgKCB2X25leHRfeCA8IC0gTnVtYmVyLkVQU0lMT04gKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRkaXJlY3Rpb25fZXEgPSB0cnVlO1xuXG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIE1hdGguc2lnbiggdl9wcmV2X3kgKSA9PT0gTWF0aC5zaWduKCB2X25leHRfeSApICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0ZGlyZWN0aW9uX2VxID0gdHJ1ZTtcblxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmICggZGlyZWN0aW9uX2VxICkge1xuXG5cdFx0XHRcdFx0XHQvLyBjb25zb2xlLmxvZyhcIldhcm5pbmc6IGxpbmVzIGFyZSBhIHN0cmFpZ2h0IHNlcXVlbmNlXCIpO1xuXHRcdFx0XHRcdFx0dl90cmFuc194ID0gLSB2X3ByZXZfeTtcblx0XHRcdFx0XHRcdHZfdHJhbnNfeSA9IHZfcHJldl94O1xuXHRcdFx0XHRcdFx0c2hyaW5rX2J5ID0gTWF0aC5zcXJ0KCB2X3ByZXZfbGVuc3EgKTtcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdC8vIGNvbnNvbGUubG9nKFwiV2FybmluZzogbGluZXMgYXJlIGEgc3RyYWlnaHQgc3Bpa2VcIik7XG5cdFx0XHRcdFx0XHR2X3RyYW5zX3ggPSB2X3ByZXZfeDtcblx0XHRcdFx0XHRcdHZfdHJhbnNfeSA9IHZfcHJldl95O1xuXHRcdFx0XHRcdFx0c2hyaW5rX2J5ID0gTWF0aC5zcXJ0KCB2X3ByZXZfbGVuc3EgLyAyICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBuZXcgVmVjdG9yMiggdl90cmFuc194IC8gc2hyaW5rX2J5LCB2X3RyYW5zX3kgLyBzaHJpbmtfYnkgKTtcblxuXHRcdFx0fVxuXG5cblx0XHRcdGNvbnN0IGNvbnRvdXJNb3ZlbWVudHMgPSBbXTtcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwLCBpbCA9IGNvbnRvdXIubGVuZ3RoLCBqID0gaWwgLSAxLCBrID0gaSArIDE7IGkgPCBpbDsgaSArKywgaiArKywgayArKyApIHtcblxuXHRcdFx0XHRpZiAoIGogPT09IGlsICkgaiA9IDA7XG5cdFx0XHRcdGlmICggayA9PT0gaWwgKSBrID0gMDtcblxuXHRcdFx0XHQvLyAgKGopLS0tKGkpLS0tKGspXG5cdFx0XHRcdC8vIGNvbnNvbGUubG9nKCdpLGosaycsIGksIGogLCBrKVxuXG5cdFx0XHRcdGNvbnRvdXJNb3ZlbWVudHNbIGkgXSA9IGdldEJldmVsVmVjKCBjb250b3VyWyBpIF0sIGNvbnRvdXJbIGogXSwgY29udG91clsgayBdICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgaG9sZXNNb3ZlbWVudHMgPSBbXTtcblx0XHRcdGxldCBvbmVIb2xlTW92ZW1lbnRzLCB2ZXJ0aWNlc01vdmVtZW50cyA9IGNvbnRvdXJNb3ZlbWVudHMuY29uY2F0KCk7XG5cblx0XHRcdGZvciAoIGxldCBoID0gMCwgaGwgPSBob2xlcy5sZW5ndGg7IGggPCBobDsgaCArKyApIHtcblxuXHRcdFx0XHRjb25zdCBhaG9sZSA9IGhvbGVzWyBoIF07XG5cblx0XHRcdFx0b25lSG9sZU1vdmVtZW50cyA9IFtdO1xuXG5cdFx0XHRcdGZvciAoIGxldCBpID0gMCwgaWwgPSBhaG9sZS5sZW5ndGgsIGogPSBpbCAtIDEsIGsgPSBpICsgMTsgaSA8IGlsOyBpICsrLCBqICsrLCBrICsrICkge1xuXG5cdFx0XHRcdFx0aWYgKCBqID09PSBpbCApIGogPSAwO1xuXHRcdFx0XHRcdGlmICggayA9PT0gaWwgKSBrID0gMDtcblxuXHRcdFx0XHRcdC8vICAoaiktLS0oaSktLS0oaylcblx0XHRcdFx0XHRvbmVIb2xlTW92ZW1lbnRzWyBpIF0gPSBnZXRCZXZlbFZlYyggYWhvbGVbIGkgXSwgYWhvbGVbIGogXSwgYWhvbGVbIGsgXSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRob2xlc01vdmVtZW50cy5wdXNoKCBvbmVIb2xlTW92ZW1lbnRzICk7XG5cdFx0XHRcdHZlcnRpY2VzTW92ZW1lbnRzID0gdmVydGljZXNNb3ZlbWVudHMuY29uY2F0KCBvbmVIb2xlTW92ZW1lbnRzICk7XG5cblx0XHRcdH1cblxuXG5cdFx0XHQvLyBMb29wIGJldmVsU2VnbWVudHMsIDEgZm9yIHRoZSBmcm9udCwgMSBmb3IgdGhlIGJhY2tcblxuXHRcdFx0Zm9yICggbGV0IGIgPSAwOyBiIDwgYmV2ZWxTZWdtZW50czsgYiArKyApIHtcblxuXHRcdFx0XHQvL2ZvciAoIGIgPSBiZXZlbFNlZ21lbnRzOyBiID4gMDsgYiAtLSApIHtcblxuXHRcdFx0XHRjb25zdCB0ID0gYiAvIGJldmVsU2VnbWVudHM7XG5cdFx0XHRcdGNvbnN0IHogPSBiZXZlbFRoaWNrbmVzcyAqIE1hdGguY29zKCB0ICogTWF0aC5QSSAvIDIgKTtcblx0XHRcdFx0Y29uc3QgYnMgPSBiZXZlbFNpemUgKiBNYXRoLnNpbiggdCAqIE1hdGguUEkgLyAyICkgKyBiZXZlbE9mZnNldDtcblxuXHRcdFx0XHQvLyBjb250cmFjdCBzaGFwZVxuXG5cdFx0XHRcdGZvciAoIGxldCBpID0gMCwgaWwgPSBjb250b3VyLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0Y29uc3QgdmVydCA9IHNjYWxlUHQyKCBjb250b3VyWyBpIF0sIGNvbnRvdXJNb3ZlbWVudHNbIGkgXSwgYnMgKTtcblxuXHRcdFx0XHRcdHYoIHZlcnQueCwgdmVydC55LCAtIHogKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gZXhwYW5kIGhvbGVzXG5cblx0XHRcdFx0Zm9yICggbGV0IGggPSAwLCBobCA9IGhvbGVzLmxlbmd0aDsgaCA8IGhsOyBoICsrICkge1xuXG5cdFx0XHRcdFx0Y29uc3QgYWhvbGUgPSBob2xlc1sgaCBdO1xuXHRcdFx0XHRcdG9uZUhvbGVNb3ZlbWVudHMgPSBob2xlc01vdmVtZW50c1sgaCBdO1xuXG5cdFx0XHRcdFx0Zm9yICggbGV0IGkgPSAwLCBpbCA9IGFob2xlLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0XHRjb25zdCB2ZXJ0ID0gc2NhbGVQdDIoIGFob2xlWyBpIF0sIG9uZUhvbGVNb3ZlbWVudHNbIGkgXSwgYnMgKTtcblxuXHRcdFx0XHRcdFx0diggdmVydC54LCB2ZXJ0LnksIC0geiApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBicyA9IGJldmVsU2l6ZSArIGJldmVsT2Zmc2V0O1xuXG5cdFx0XHQvLyBCYWNrIGZhY2luZyB2ZXJ0aWNlc1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCB2bGVuOyBpICsrICkge1xuXG5cdFx0XHRcdGNvbnN0IHZlcnQgPSBiZXZlbEVuYWJsZWQgPyBzY2FsZVB0MiggdmVydGljZXNbIGkgXSwgdmVydGljZXNNb3ZlbWVudHNbIGkgXSwgYnMgKSA6IHZlcnRpY2VzWyBpIF07XG5cblx0XHRcdFx0aWYgKCAhIGV4dHJ1ZGVCeVBhdGggKSB7XG5cblx0XHRcdFx0XHR2KCB2ZXJ0LngsIHZlcnQueSwgMCApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHQvLyB2KCB2ZXJ0LngsIHZlcnQueSArIGV4dHJ1ZGVQdHNbIDAgXS55LCBleHRydWRlUHRzWyAwIF0ueCApO1xuXG5cdFx0XHRcdFx0bm9ybWFsLmNvcHkoIHNwbGluZVR1YmUubm9ybWFsc1sgMCBdICkubXVsdGlwbHlTY2FsYXIoIHZlcnQueCApO1xuXHRcdFx0XHRcdGJpbm9ybWFsLmNvcHkoIHNwbGluZVR1YmUuYmlub3JtYWxzWyAwIF0gKS5tdWx0aXBseVNjYWxhciggdmVydC55ICk7XG5cblx0XHRcdFx0XHRwb3NpdGlvbjIuY29weSggZXh0cnVkZVB0c1sgMCBdICkuYWRkKCBub3JtYWwgKS5hZGQoIGJpbm9ybWFsICk7XG5cblx0XHRcdFx0XHR2KCBwb3NpdGlvbjIueCwgcG9zaXRpb24yLnksIHBvc2l0aW9uMi56ICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdC8vIEFkZCBzdGVwcGVkIHZlcnRpY2VzLi4uXG5cdFx0XHQvLyBJbmNsdWRpbmcgZnJvbnQgZmFjaW5nIHZlcnRpY2VzXG5cblx0XHRcdGZvciAoIGxldCBzID0gMTsgcyA8PSBzdGVwczsgcyArKyApIHtcblxuXHRcdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCB2bGVuOyBpICsrICkge1xuXG5cdFx0XHRcdFx0Y29uc3QgdmVydCA9IGJldmVsRW5hYmxlZCA/IHNjYWxlUHQyKCB2ZXJ0aWNlc1sgaSBdLCB2ZXJ0aWNlc01vdmVtZW50c1sgaSBdLCBicyApIDogdmVydGljZXNbIGkgXTtcblxuXHRcdFx0XHRcdGlmICggISBleHRydWRlQnlQYXRoICkge1xuXG5cdFx0XHRcdFx0XHR2KCB2ZXJ0LngsIHZlcnQueSwgZGVwdGggLyBzdGVwcyAqIHMgKTtcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdC8vIHYoIHZlcnQueCwgdmVydC55ICsgZXh0cnVkZVB0c1sgcyAtIDEgXS55LCBleHRydWRlUHRzWyBzIC0gMSBdLnggKTtcblxuXHRcdFx0XHRcdFx0bm9ybWFsLmNvcHkoIHNwbGluZVR1YmUubm9ybWFsc1sgcyBdICkubXVsdGlwbHlTY2FsYXIoIHZlcnQueCApO1xuXHRcdFx0XHRcdFx0Ymlub3JtYWwuY29weSggc3BsaW5lVHViZS5iaW5vcm1hbHNbIHMgXSApLm11bHRpcGx5U2NhbGFyKCB2ZXJ0LnkgKTtcblxuXHRcdFx0XHRcdFx0cG9zaXRpb24yLmNvcHkoIGV4dHJ1ZGVQdHNbIHMgXSApLmFkZCggbm9ybWFsICkuYWRkKCBiaW5vcm1hbCApO1xuXG5cdFx0XHRcdFx0XHR2KCBwb3NpdGlvbjIueCwgcG9zaXRpb24yLnksIHBvc2l0aW9uMi56ICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblxuXHRcdFx0Ly8gQWRkIGJldmVsIHNlZ21lbnRzIHBsYW5lc1xuXG5cdFx0XHQvL2ZvciAoIGIgPSAxOyBiIDw9IGJldmVsU2VnbWVudHM7IGIgKysgKSB7XG5cdFx0XHRmb3IgKCBsZXQgYiA9IGJldmVsU2VnbWVudHMgLSAxOyBiID49IDA7IGIgLS0gKSB7XG5cblx0XHRcdFx0Y29uc3QgdCA9IGIgLyBiZXZlbFNlZ21lbnRzO1xuXHRcdFx0XHRjb25zdCB6ID0gYmV2ZWxUaGlja25lc3MgKiBNYXRoLmNvcyggdCAqIE1hdGguUEkgLyAyICk7XG5cdFx0XHRcdGNvbnN0IGJzID0gYmV2ZWxTaXplICogTWF0aC5zaW4oIHQgKiBNYXRoLlBJIC8gMiApICsgYmV2ZWxPZmZzZXQ7XG5cblx0XHRcdFx0Ly8gY29udHJhY3Qgc2hhcGVcblxuXHRcdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGlsID0gY29udG91ci5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdGNvbnN0IHZlcnQgPSBzY2FsZVB0MiggY29udG91clsgaSBdLCBjb250b3VyTW92ZW1lbnRzWyBpIF0sIGJzICk7XG5cdFx0XHRcdFx0diggdmVydC54LCB2ZXJ0LnksIGRlcHRoICsgeiApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBleHBhbmQgaG9sZXNcblxuXHRcdFx0XHRmb3IgKCBsZXQgaCA9IDAsIGhsID0gaG9sZXMubGVuZ3RoOyBoIDwgaGw7IGggKysgKSB7XG5cblx0XHRcdFx0XHRjb25zdCBhaG9sZSA9IGhvbGVzWyBoIF07XG5cdFx0XHRcdFx0b25lSG9sZU1vdmVtZW50cyA9IGhvbGVzTW92ZW1lbnRzWyBoIF07XG5cblx0XHRcdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGlsID0gYWhvbGUubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRcdGNvbnN0IHZlcnQgPSBzY2FsZVB0MiggYWhvbGVbIGkgXSwgb25lSG9sZU1vdmVtZW50c1sgaSBdLCBicyApO1xuXG5cdFx0XHRcdFx0XHRpZiAoICEgZXh0cnVkZUJ5UGF0aCApIHtcblxuXHRcdFx0XHRcdFx0XHR2KCB2ZXJ0LngsIHZlcnQueSwgZGVwdGggKyB6ICk7XG5cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0diggdmVydC54LCB2ZXJ0LnkgKyBleHRydWRlUHRzWyBzdGVwcyAtIDEgXS55LCBleHRydWRlUHRzWyBzdGVwcyAtIDEgXS54ICsgeiApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdC8qIEZhY2VzICovXG5cblx0XHRcdC8vIFRvcCBhbmQgYm90dG9tIGZhY2VzXG5cblx0XHRcdGJ1aWxkTGlkRmFjZXMoKTtcblxuXHRcdFx0Ly8gU2lkZXMgZmFjZXNcblxuXHRcdFx0YnVpbGRTaWRlRmFjZXMoKTtcblxuXG5cdFx0XHQvLy8vLyAgSW50ZXJuYWwgZnVuY3Rpb25zXG5cblx0XHRcdGZ1bmN0aW9uIGJ1aWxkTGlkRmFjZXMoKSB7XG5cblx0XHRcdFx0Y29uc3Qgc3RhcnQgPSB2ZXJ0aWNlc0FycmF5Lmxlbmd0aCAvIDM7XG5cblx0XHRcdFx0aWYgKCBiZXZlbEVuYWJsZWQgKSB7XG5cblx0XHRcdFx0XHRsZXQgbGF5ZXIgPSAwOyAvLyBzdGVwcyArIDFcblx0XHRcdFx0XHRsZXQgb2Zmc2V0ID0gdmxlbiAqIGxheWVyO1xuXG5cdFx0XHRcdFx0Ly8gQm90dG9tIGZhY2VzXG5cblx0XHRcdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBmbGVuOyBpICsrICkge1xuXG5cdFx0XHRcdFx0XHRjb25zdCBmYWNlID0gZmFjZXNbIGkgXTtcblx0XHRcdFx0XHRcdGYzKCBmYWNlWyAyIF0gKyBvZmZzZXQsIGZhY2VbIDEgXSArIG9mZnNldCwgZmFjZVsgMCBdICsgb2Zmc2V0ICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRsYXllciA9IHN0ZXBzICsgYmV2ZWxTZWdtZW50cyAqIDI7XG5cdFx0XHRcdFx0b2Zmc2V0ID0gdmxlbiAqIGxheWVyO1xuXG5cdFx0XHRcdFx0Ly8gVG9wIGZhY2VzXG5cblx0XHRcdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBmbGVuOyBpICsrICkge1xuXG5cdFx0XHRcdFx0XHRjb25zdCBmYWNlID0gZmFjZXNbIGkgXTtcblx0XHRcdFx0XHRcdGYzKCBmYWNlWyAwIF0gKyBvZmZzZXQsIGZhY2VbIDEgXSArIG9mZnNldCwgZmFjZVsgMiBdICsgb2Zmc2V0ICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdC8vIEJvdHRvbSBmYWNlc1xuXG5cdFx0XHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgZmxlbjsgaSArKyApIHtcblxuXHRcdFx0XHRcdFx0Y29uc3QgZmFjZSA9IGZhY2VzWyBpIF07XG5cdFx0XHRcdFx0XHRmMyggZmFjZVsgMiBdLCBmYWNlWyAxIF0sIGZhY2VbIDAgXSApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gVG9wIGZhY2VzXG5cblx0XHRcdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBmbGVuOyBpICsrICkge1xuXG5cdFx0XHRcdFx0XHRjb25zdCBmYWNlID0gZmFjZXNbIGkgXTtcblx0XHRcdFx0XHRcdGYzKCBmYWNlWyAwIF0gKyB2bGVuICogc3RlcHMsIGZhY2VbIDEgXSArIHZsZW4gKiBzdGVwcywgZmFjZVsgMiBdICsgdmxlbiAqIHN0ZXBzICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHNjb3BlLmFkZEdyb3VwKCBzdGFydCwgdmVydGljZXNBcnJheS5sZW5ndGggLyAzIC0gc3RhcnQsIDAgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBDcmVhdGUgZmFjZXMgZm9yIHRoZSB6LXNpZGVzIG9mIHRoZSBzaGFwZVxuXG5cdFx0XHRmdW5jdGlvbiBidWlsZFNpZGVGYWNlcygpIHtcblxuXHRcdFx0XHRjb25zdCBzdGFydCA9IHZlcnRpY2VzQXJyYXkubGVuZ3RoIC8gMztcblx0XHRcdFx0bGV0IGxheWVyb2Zmc2V0ID0gMDtcblx0XHRcdFx0c2lkZXdhbGxzKCBjb250b3VyLCBsYXllcm9mZnNldCApO1xuXHRcdFx0XHRsYXllcm9mZnNldCArPSBjb250b3VyLmxlbmd0aDtcblxuXHRcdFx0XHRmb3IgKCBsZXQgaCA9IDAsIGhsID0gaG9sZXMubGVuZ3RoOyBoIDwgaGw7IGggKysgKSB7XG5cblx0XHRcdFx0XHRjb25zdCBhaG9sZSA9IGhvbGVzWyBoIF07XG5cdFx0XHRcdFx0c2lkZXdhbGxzKCBhaG9sZSwgbGF5ZXJvZmZzZXQgKTtcblxuXHRcdFx0XHRcdC8vLCB0cnVlXG5cdFx0XHRcdFx0bGF5ZXJvZmZzZXQgKz0gYWhvbGUubGVuZ3RoO1xuXG5cdFx0XHRcdH1cblxuXG5cdFx0XHRcdHNjb3BlLmFkZEdyb3VwKCBzdGFydCwgdmVydGljZXNBcnJheS5sZW5ndGggLyAzIC0gc3RhcnQsIDEgKTtcblxuXG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIHNpZGV3YWxscyggY29udG91ciwgbGF5ZXJvZmZzZXQgKSB7XG5cblx0XHRcdFx0bGV0IGkgPSBjb250b3VyLmxlbmd0aDtcblxuXHRcdFx0XHR3aGlsZSAoIC0tIGkgPj0gMCApIHtcblxuXHRcdFx0XHRcdGNvbnN0IGogPSBpO1xuXHRcdFx0XHRcdGxldCBrID0gaSAtIDE7XG5cdFx0XHRcdFx0aWYgKCBrIDwgMCApIGsgPSBjb250b3VyLmxlbmd0aCAtIDE7XG5cblx0XHRcdFx0XHQvL2NvbnNvbGUubG9nKCdiJywgaSxqLCBpLTEsIGssdmVydGljZXMubGVuZ3RoKTtcblxuXHRcdFx0XHRcdGZvciAoIGxldCBzID0gMCwgc2wgPSAoIHN0ZXBzICsgYmV2ZWxTZWdtZW50cyAqIDIgKTsgcyA8IHNsOyBzICsrICkge1xuXG5cdFx0XHRcdFx0XHRjb25zdCBzbGVuMSA9IHZsZW4gKiBzO1xuXHRcdFx0XHRcdFx0Y29uc3Qgc2xlbjIgPSB2bGVuICogKCBzICsgMSApO1xuXG5cdFx0XHRcdFx0XHRjb25zdCBhID0gbGF5ZXJvZmZzZXQgKyBqICsgc2xlbjEsXG5cdFx0XHRcdFx0XHRcdGIgPSBsYXllcm9mZnNldCArIGsgKyBzbGVuMSxcblx0XHRcdFx0XHRcdFx0YyA9IGxheWVyb2Zmc2V0ICsgayArIHNsZW4yLFxuXHRcdFx0XHRcdFx0XHRkID0gbGF5ZXJvZmZzZXQgKyBqICsgc2xlbjI7XG5cblx0XHRcdFx0XHRcdGY0KCBhLCBiLCBjLCBkICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIHYoIHgsIHksIHogKSB7XG5cblx0XHRcdFx0cGxhY2Vob2xkZXIucHVzaCggeCApO1xuXHRcdFx0XHRwbGFjZWhvbGRlci5wdXNoKCB5ICk7XG5cdFx0XHRcdHBsYWNlaG9sZGVyLnB1c2goIHogKTtcblxuXHRcdFx0fVxuXG5cblx0XHRcdGZ1bmN0aW9uIGYzKCBhLCBiLCBjICkge1xuXG5cdFx0XHRcdGFkZFZlcnRleCggYSApO1xuXHRcdFx0XHRhZGRWZXJ0ZXgoIGIgKTtcblx0XHRcdFx0YWRkVmVydGV4KCBjICk7XG5cblx0XHRcdFx0Y29uc3QgbmV4dEluZGV4ID0gdmVydGljZXNBcnJheS5sZW5ndGggLyAzO1xuXHRcdFx0XHRjb25zdCB1dnMgPSB1dmdlbi5nZW5lcmF0ZVRvcFVWKCBzY29wZSwgdmVydGljZXNBcnJheSwgbmV4dEluZGV4IC0gMywgbmV4dEluZGV4IC0gMiwgbmV4dEluZGV4IC0gMSApO1xuXG5cdFx0XHRcdGFkZFVWKCB1dnNbIDAgXSApO1xuXHRcdFx0XHRhZGRVViggdXZzWyAxIF0gKTtcblx0XHRcdFx0YWRkVVYoIHV2c1sgMiBdICk7XG5cblx0XHRcdH1cblxuXHRcdFx0ZnVuY3Rpb24gZjQoIGEsIGIsIGMsIGQgKSB7XG5cblx0XHRcdFx0YWRkVmVydGV4KCBhICk7XG5cdFx0XHRcdGFkZFZlcnRleCggYiApO1xuXHRcdFx0XHRhZGRWZXJ0ZXgoIGQgKTtcblxuXHRcdFx0XHRhZGRWZXJ0ZXgoIGIgKTtcblx0XHRcdFx0YWRkVmVydGV4KCBjICk7XG5cdFx0XHRcdGFkZFZlcnRleCggZCApO1xuXG5cblx0XHRcdFx0Y29uc3QgbmV4dEluZGV4ID0gdmVydGljZXNBcnJheS5sZW5ndGggLyAzO1xuXHRcdFx0XHRjb25zdCB1dnMgPSB1dmdlbi5nZW5lcmF0ZVNpZGVXYWxsVVYoIHNjb3BlLCB2ZXJ0aWNlc0FycmF5LCBuZXh0SW5kZXggLSA2LCBuZXh0SW5kZXggLSAzLCBuZXh0SW5kZXggLSAyLCBuZXh0SW5kZXggLSAxICk7XG5cblx0XHRcdFx0YWRkVVYoIHV2c1sgMCBdICk7XG5cdFx0XHRcdGFkZFVWKCB1dnNbIDEgXSApO1xuXHRcdFx0XHRhZGRVViggdXZzWyAzIF0gKTtcblxuXHRcdFx0XHRhZGRVViggdXZzWyAxIF0gKTtcblx0XHRcdFx0YWRkVVYoIHV2c1sgMiBdICk7XG5cdFx0XHRcdGFkZFVWKCB1dnNbIDMgXSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIGFkZFZlcnRleCggaW5kZXggKSB7XG5cblx0XHRcdFx0dmVydGljZXNBcnJheS5wdXNoKCBwbGFjZWhvbGRlclsgaW5kZXggKiAzICsgMCBdICk7XG5cdFx0XHRcdHZlcnRpY2VzQXJyYXkucHVzaCggcGxhY2Vob2xkZXJbIGluZGV4ICogMyArIDEgXSApO1xuXHRcdFx0XHR2ZXJ0aWNlc0FycmF5LnB1c2goIHBsYWNlaG9sZGVyWyBpbmRleCAqIDMgKyAyIF0gKTtcblxuXHRcdFx0fVxuXG5cblx0XHRcdGZ1bmN0aW9uIGFkZFVWKCB2ZWN0b3IyICkge1xuXG5cdFx0XHRcdHV2QXJyYXkucHVzaCggdmVjdG9yMi54ICk7XG5cdFx0XHRcdHV2QXJyYXkucHVzaCggdmVjdG9yMi55ICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9XG5cblx0Y29weSggc291cmNlICkge1xuXG5cdFx0c3VwZXIuY29weSggc291cmNlICk7XG5cblx0XHR0aGlzLnBhcmFtZXRlcnMgPSBPYmplY3QuYXNzaWduKCB7fSwgc291cmNlLnBhcmFtZXRlcnMgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHR0b0pTT04oKSB7XG5cblx0XHRjb25zdCBkYXRhID0gc3VwZXIudG9KU09OKCk7XG5cblx0XHRjb25zdCBzaGFwZXMgPSB0aGlzLnBhcmFtZXRlcnMuc2hhcGVzO1xuXHRcdGNvbnN0IG9wdGlvbnMgPSB0aGlzLnBhcmFtZXRlcnMub3B0aW9ucztcblxuXHRcdHJldHVybiB0b0pTT04oIHNoYXBlcywgb3B0aW9ucywgZGF0YSApO1xuXG5cdH1cblxuXHRzdGF0aWMgZnJvbUpTT04oIGRhdGEsIHNoYXBlcyApIHtcblxuXHRcdGNvbnN0IGdlb21ldHJ5U2hhcGVzID0gW107XG5cblx0XHRmb3IgKCBsZXQgaiA9IDAsIGpsID0gZGF0YS5zaGFwZXMubGVuZ3RoOyBqIDwgamw7IGogKysgKSB7XG5cblx0XHRcdGNvbnN0IHNoYXBlID0gc2hhcGVzWyBkYXRhLnNoYXBlc1sgaiBdIF07XG5cblx0XHRcdGdlb21ldHJ5U2hhcGVzLnB1c2goIHNoYXBlICk7XG5cblx0XHR9XG5cblx0XHRjb25zdCBleHRydWRlUGF0aCA9IGRhdGEub3B0aW9ucy5leHRydWRlUGF0aDtcblxuXHRcdGlmICggZXh0cnVkZVBhdGggIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0ZGF0YS5vcHRpb25zLmV4dHJ1ZGVQYXRoID0gbmV3IEN1cnZlc1sgZXh0cnVkZVBhdGgudHlwZSBdKCkuZnJvbUpTT04oIGV4dHJ1ZGVQYXRoICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gbmV3IEV4dHJ1ZGVHZW9tZXRyeSggZ2VvbWV0cnlTaGFwZXMsIGRhdGEub3B0aW9ucyApO1xuXG5cdH1cblxufVxuXG5jb25zdCBXb3JsZFVWR2VuZXJhdG9yID0ge1xuXG5cdGdlbmVyYXRlVG9wVVY6IGZ1bmN0aW9uICggZ2VvbWV0cnksIHZlcnRpY2VzLCBpbmRleEEsIGluZGV4QiwgaW5kZXhDICkge1xuXG5cdFx0Y29uc3QgYV94ID0gdmVydGljZXNbIGluZGV4QSAqIDMgXTtcblx0XHRjb25zdCBhX3kgPSB2ZXJ0aWNlc1sgaW5kZXhBICogMyArIDEgXTtcblx0XHRjb25zdCBiX3ggPSB2ZXJ0aWNlc1sgaW5kZXhCICogMyBdO1xuXHRcdGNvbnN0IGJfeSA9IHZlcnRpY2VzWyBpbmRleEIgKiAzICsgMSBdO1xuXHRcdGNvbnN0IGNfeCA9IHZlcnRpY2VzWyBpbmRleEMgKiAzIF07XG5cdFx0Y29uc3QgY195ID0gdmVydGljZXNbIGluZGV4QyAqIDMgKyAxIF07XG5cblx0XHRyZXR1cm4gW1xuXHRcdFx0bmV3IFZlY3RvcjIoIGFfeCwgYV95ICksXG5cdFx0XHRuZXcgVmVjdG9yMiggYl94LCBiX3kgKSxcblx0XHRcdG5ldyBWZWN0b3IyKCBjX3gsIGNfeSApXG5cdFx0XTtcblxuXHR9LFxuXG5cdGdlbmVyYXRlU2lkZVdhbGxVVjogZnVuY3Rpb24gKCBnZW9tZXRyeSwgdmVydGljZXMsIGluZGV4QSwgaW5kZXhCLCBpbmRleEMsIGluZGV4RCApIHtcblxuXHRcdGNvbnN0IGFfeCA9IHZlcnRpY2VzWyBpbmRleEEgKiAzIF07XG5cdFx0Y29uc3QgYV95ID0gdmVydGljZXNbIGluZGV4QSAqIDMgKyAxIF07XG5cdFx0Y29uc3QgYV96ID0gdmVydGljZXNbIGluZGV4QSAqIDMgKyAyIF07XG5cdFx0Y29uc3QgYl94ID0gdmVydGljZXNbIGluZGV4QiAqIDMgXTtcblx0XHRjb25zdCBiX3kgPSB2ZXJ0aWNlc1sgaW5kZXhCICogMyArIDEgXTtcblx0XHRjb25zdCBiX3ogPSB2ZXJ0aWNlc1sgaW5kZXhCICogMyArIDIgXTtcblx0XHRjb25zdCBjX3ggPSB2ZXJ0aWNlc1sgaW5kZXhDICogMyBdO1xuXHRcdGNvbnN0IGNfeSA9IHZlcnRpY2VzWyBpbmRleEMgKiAzICsgMSBdO1xuXHRcdGNvbnN0IGNfeiA9IHZlcnRpY2VzWyBpbmRleEMgKiAzICsgMiBdO1xuXHRcdGNvbnN0IGRfeCA9IHZlcnRpY2VzWyBpbmRleEQgKiAzIF07XG5cdFx0Y29uc3QgZF95ID0gdmVydGljZXNbIGluZGV4RCAqIDMgKyAxIF07XG5cdFx0Y29uc3QgZF96ID0gdmVydGljZXNbIGluZGV4RCAqIDMgKyAyIF07XG5cblx0XHRpZiAoIE1hdGguYWJzKCBhX3kgLSBiX3kgKSA8IE1hdGguYWJzKCBhX3ggLSBiX3ggKSApIHtcblxuXHRcdFx0cmV0dXJuIFtcblx0XHRcdFx0bmV3IFZlY3RvcjIoIGFfeCwgMSAtIGFfeiApLFxuXHRcdFx0XHRuZXcgVmVjdG9yMiggYl94LCAxIC0gYl96ICksXG5cdFx0XHRcdG5ldyBWZWN0b3IyKCBjX3gsIDEgLSBjX3ogKSxcblx0XHRcdFx0bmV3IFZlY3RvcjIoIGRfeCwgMSAtIGRfeiApXG5cdFx0XHRdO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0cmV0dXJuIFtcblx0XHRcdFx0bmV3IFZlY3RvcjIoIGFfeSwgMSAtIGFfeiApLFxuXHRcdFx0XHRuZXcgVmVjdG9yMiggYl95LCAxIC0gYl96ICksXG5cdFx0XHRcdG5ldyBWZWN0b3IyKCBjX3ksIDEgLSBjX3ogKSxcblx0XHRcdFx0bmV3IFZlY3RvcjIoIGRfeSwgMSAtIGRfeiApXG5cdFx0XHRdO1xuXG5cdFx0fVxuXG5cdH1cblxufTtcblxuZnVuY3Rpb24gdG9KU09OKCBzaGFwZXMsIG9wdGlvbnMsIGRhdGEgKSB7XG5cblx0ZGF0YS5zaGFwZXMgPSBbXTtcblxuXHRpZiAoIEFycmF5LmlzQXJyYXkoIHNoYXBlcyApICkge1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gc2hhcGVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdGNvbnN0IHNoYXBlID0gc2hhcGVzWyBpIF07XG5cblx0XHRcdGRhdGEuc2hhcGVzLnB1c2goIHNoYXBlLnV1aWQgKTtcblxuXHRcdH1cblxuXHR9IGVsc2Uge1xuXG5cdFx0ZGF0YS5zaGFwZXMucHVzaCggc2hhcGVzLnV1aWQgKTtcblxuXHR9XG5cblx0ZGF0YS5vcHRpb25zID0gT2JqZWN0LmFzc2lnbigge30sIG9wdGlvbnMgKTtcblxuXHRpZiAoIG9wdGlvbnMuZXh0cnVkZVBhdGggIT09IHVuZGVmaW5lZCApIGRhdGEub3B0aW9ucy5leHRydWRlUGF0aCA9IG9wdGlvbnMuZXh0cnVkZVBhdGgudG9KU09OKCk7XG5cblx0cmV0dXJuIGRhdGE7XG5cbn1cblxuXG5leHBvcnQgeyBFeHRydWRlR2VvbWV0cnkgfTtcbiIsImV4cG9ydCAqIGZyb20gJy4vQm94R2VvbWV0cnkuanMnO1xuZXhwb3J0ICogZnJvbSAnLi9DYXBzdWxlR2VvbWV0cnkuanMnO1xuZXhwb3J0ICogZnJvbSAnLi9DaXJjbGVHZW9tZXRyeS5qcyc7XG5leHBvcnQgKiBmcm9tICcuL0NvbmVHZW9tZXRyeS5qcyc7XG5leHBvcnQgKiBmcm9tICcuL0N5bGluZGVyR2VvbWV0cnkuanMnO1xuZXhwb3J0ICogZnJvbSAnLi9Eb2RlY2FoZWRyb25HZW9tZXRyeS5qcyc7XG5leHBvcnQgKiBmcm9tICcuL0VkZ2VzR2VvbWV0cnkuanMnO1xuZXhwb3J0ICogZnJvbSAnLi9FeHRydWRlR2VvbWV0cnkuanMnO1xuZXhwb3J0ICogZnJvbSAnLi9JY29zYWhlZHJvbkdlb21ldHJ5LmpzJztcbmV4cG9ydCAqIGZyb20gJy4vTGF0aGVHZW9tZXRyeS5qcyc7XG5leHBvcnQgKiBmcm9tICcuL09jdGFoZWRyb25HZW9tZXRyeS5qcyc7XG5leHBvcnQgKiBmcm9tICcuL1BsYW5lR2VvbWV0cnkuanMnO1xuZXhwb3J0ICogZnJvbSAnLi9Qb2x5aGVkcm9uR2VvbWV0cnkuanMnO1xuZXhwb3J0ICogZnJvbSAnLi9SaW5nR2VvbWV0cnkuanMnO1xuZXhwb3J0ICogZnJvbSAnLi9TaGFwZUdlb21ldHJ5LmpzJztcbmV4cG9ydCAqIGZyb20gJy4vU3BoZXJlR2VvbWV0cnkuanMnO1xuZXhwb3J0ICogZnJvbSAnLi9UZXRyYWhlZHJvbkdlb21ldHJ5LmpzJztcbmV4cG9ydCAqIGZyb20gJy4vVG9ydXNHZW9tZXRyeS5qcyc7XG5leHBvcnQgKiBmcm9tICcuL1RvcnVzS25vdEdlb21ldHJ5LmpzJztcbmV4cG9ydCAqIGZyb20gJy4vVHViZUdlb21ldHJ5LmpzJztcbmV4cG9ydCAqIGZyb20gJy4vV2lyZWZyYW1lR2VvbWV0cnkuanMnO1xuIiwiaW1wb3J0IHsgUG9seWhlZHJvbkdlb21ldHJ5IH0gZnJvbSAnLi9Qb2x5aGVkcm9uR2VvbWV0cnkuanMnO1xuXG5jbGFzcyBJY29zYWhlZHJvbkdlb21ldHJ5IGV4dGVuZHMgUG9seWhlZHJvbkdlb21ldHJ5IHtcblxuXHRjb25zdHJ1Y3RvciggcmFkaXVzID0gMSwgZGV0YWlsID0gMCApIHtcblxuXHRcdGNvbnN0IHQgPSAoIDEgKyBNYXRoLnNxcnQoIDUgKSApIC8gMjtcblxuXHRcdGNvbnN0IHZlcnRpY2VzID0gW1xuXHRcdFx0LSAxLCB0LCAwLCBcdDEsIHQsIDAsIFx0LSAxLCAtIHQsIDAsIFx0MSwgLSB0LCAwLFxuXHRcdFx0MCwgLSAxLCB0LCBcdDAsIDEsIHQsXHQwLCAtIDEsIC0gdCwgXHQwLCAxLCAtIHQsXG5cdFx0XHR0LCAwLCAtIDEsIFx0dCwgMCwgMSwgXHQtIHQsIDAsIC0gMSwgXHQtIHQsIDAsIDFcblx0XHRdO1xuXG5cdFx0Y29uc3QgaW5kaWNlcyA9IFtcblx0XHRcdDAsIDExLCA1LCBcdDAsIDUsIDEsIFx0MCwgMSwgNywgXHQwLCA3LCAxMCwgXHQwLCAxMCwgMTEsXG5cdFx0XHQxLCA1LCA5LCBcdDUsIDExLCA0LFx0MTEsIDEwLCAyLFx0MTAsIDcsIDYsXHQ3LCAxLCA4LFxuXHRcdFx0MywgOSwgNCwgXHQzLCA0LCAyLFx0MywgMiwgNixcdDMsIDYsIDgsXHQzLCA4LCA5LFxuXHRcdFx0NCwgOSwgNSwgXHQyLCA0LCAxMSxcdDYsIDIsIDEwLFx0OCwgNiwgNyxcdDksIDgsIDFcblx0XHRdO1xuXG5cdFx0c3VwZXIoIHZlcnRpY2VzLCBpbmRpY2VzLCByYWRpdXMsIGRldGFpbCApO1xuXG5cdFx0dGhpcy50eXBlID0gJ0ljb3NhaGVkcm9uR2VvbWV0cnknO1xuXG5cdFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xuXHRcdFx0cmFkaXVzOiByYWRpdXMsXG5cdFx0XHRkZXRhaWw6IGRldGFpbFxuXHRcdH07XG5cblx0fVxuXG5cdHN0YXRpYyBmcm9tSlNPTiggZGF0YSApIHtcblxuXHRcdHJldHVybiBuZXcgSWNvc2FoZWRyb25HZW9tZXRyeSggZGF0YS5yYWRpdXMsIGRhdGEuZGV0YWlsICk7XG5cblx0fVxuXG59XG5cblxuZXhwb3J0IHsgSWNvc2FoZWRyb25HZW9tZXRyeSB9O1xuIiwiaW1wb3J0IHsgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSB9IGZyb20gJy4uL2NvcmUvQnVmZmVyQXR0cmlidXRlLmpzJztcbmltcG9ydCB7IEJ1ZmZlckdlb21ldHJ5IH0gZnJvbSAnLi4vY29yZS9CdWZmZXJHZW9tZXRyeS5qcyc7XG5pbXBvcnQgeyBWZWN0b3IzIH0gZnJvbSAnLi4vbWF0aC9WZWN0b3IzLmpzJztcbmltcG9ydCB7IFZlY3RvcjIgfSBmcm9tICcuLi9tYXRoL1ZlY3RvcjIuanMnO1xuaW1wb3J0ICogYXMgTWF0aFV0aWxzIGZyb20gJy4uL21hdGgvTWF0aFV0aWxzLmpzJztcblxuY2xhc3MgTGF0aGVHZW9tZXRyeSBleHRlbmRzIEJ1ZmZlckdlb21ldHJ5IHtcblxuXHRjb25zdHJ1Y3RvciggcG9pbnRzID0gWyBuZXcgVmVjdG9yMiggMCwgLSAwLjUgKSwgbmV3IFZlY3RvcjIoIDAuNSwgMCApLCBuZXcgVmVjdG9yMiggMCwgMC41ICkgXSwgc2VnbWVudHMgPSAxMiwgcGhpU3RhcnQgPSAwLCBwaGlMZW5ndGggPSBNYXRoLlBJICogMiApIHtcblxuXHRcdHN1cGVyKCk7XG5cblx0XHR0aGlzLnR5cGUgPSAnTGF0aGVHZW9tZXRyeSc7XG5cblx0XHR0aGlzLnBhcmFtZXRlcnMgPSB7XG5cdFx0XHRwb2ludHM6IHBvaW50cyxcblx0XHRcdHNlZ21lbnRzOiBzZWdtZW50cyxcblx0XHRcdHBoaVN0YXJ0OiBwaGlTdGFydCxcblx0XHRcdHBoaUxlbmd0aDogcGhpTGVuZ3RoXG5cdFx0fTtcblxuXHRcdHNlZ21lbnRzID0gTWF0aC5mbG9vciggc2VnbWVudHMgKTtcblxuXHRcdC8vIGNsYW1wIHBoaUxlbmd0aCBzbyBpdCdzIGluIHJhbmdlIG9mIFsgMCwgMlBJIF1cblxuXHRcdHBoaUxlbmd0aCA9IE1hdGhVdGlscy5jbGFtcCggcGhpTGVuZ3RoLCAwLCBNYXRoLlBJICogMiApO1xuXG5cdFx0Ly8gYnVmZmVyc1xuXG5cdFx0Y29uc3QgaW5kaWNlcyA9IFtdO1xuXHRcdGNvbnN0IHZlcnRpY2VzID0gW107XG5cdFx0Y29uc3QgdXZzID0gW107XG5cdFx0Y29uc3QgaW5pdE5vcm1hbHMgPSBbXTtcblx0XHRjb25zdCBub3JtYWxzID0gW107XG5cblx0XHQvLyBoZWxwZXIgdmFyaWFibGVzXG5cblx0XHRjb25zdCBpbnZlcnNlU2VnbWVudHMgPSAxLjAgLyBzZWdtZW50cztcblx0XHRjb25zdCB2ZXJ0ZXggPSBuZXcgVmVjdG9yMygpO1xuXHRcdGNvbnN0IHV2ID0gbmV3IFZlY3RvcjIoKTtcblx0XHRjb25zdCBub3JtYWwgPSBuZXcgVmVjdG9yMygpO1xuXHRcdGNvbnN0IGN1ck5vcm1hbCA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0Y29uc3QgcHJldk5vcm1hbCA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0bGV0IGR4ID0gMDtcblx0XHRsZXQgZHkgPSAwO1xuXG5cdFx0Ly8gcHJlLWNvbXB1dGUgbm9ybWFscyBmb3IgaW5pdGlhbCBcIm1lcmlkaWFuXCJcblxuXHRcdGZvciAoIGxldCBqID0gMDsgaiA8PSAoIHBvaW50cy5sZW5ndGggLSAxICk7IGogKysgKSB7XG5cblx0XHRcdHN3aXRjaCAoIGogKSB7XG5cblx0XHRcdFx0Y2FzZSAwOlx0XHRcdFx0Ly8gc3BlY2lhbCBoYW5kbGluZyBmb3IgMXN0IHZlcnRleCBvbiBwYXRoXG5cblx0XHRcdFx0XHRkeCA9IHBvaW50c1sgaiArIDEgXS54IC0gcG9pbnRzWyBqIF0ueDtcblx0XHRcdFx0XHRkeSA9IHBvaW50c1sgaiArIDEgXS55IC0gcG9pbnRzWyBqIF0ueTtcblxuXHRcdFx0XHRcdG5vcm1hbC54ID0gZHkgKiAxLjA7XG5cdFx0XHRcdFx0bm9ybWFsLnkgPSAtIGR4O1xuXHRcdFx0XHRcdG5vcm1hbC56ID0gZHkgKiAwLjA7XG5cblx0XHRcdFx0XHRwcmV2Tm9ybWFsLmNvcHkoIG5vcm1hbCApO1xuXG5cdFx0XHRcdFx0bm9ybWFsLm5vcm1hbGl6ZSgpO1xuXG5cdFx0XHRcdFx0aW5pdE5vcm1hbHMucHVzaCggbm9ybWFsLngsIG5vcm1hbC55LCBub3JtYWwueiApO1xuXG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAoIHBvaW50cy5sZW5ndGggLSAxICk6XHQvLyBzcGVjaWFsIGhhbmRsaW5nIGZvciBsYXN0IFZlcnRleCBvbiBwYXRoXG5cblx0XHRcdFx0XHRpbml0Tm9ybWFscy5wdXNoKCBwcmV2Tm9ybWFsLngsIHByZXZOb3JtYWwueSwgcHJldk5vcm1hbC56ICk7XG5cblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRkZWZhdWx0Olx0XHRcdC8vIGRlZmF1bHQgaGFuZGxpbmcgZm9yIGFsbCB2ZXJ0aWNlcyBpbiBiZXR3ZWVuXG5cblx0XHRcdFx0XHRkeCA9IHBvaW50c1sgaiArIDEgXS54IC0gcG9pbnRzWyBqIF0ueDtcblx0XHRcdFx0XHRkeSA9IHBvaW50c1sgaiArIDEgXS55IC0gcG9pbnRzWyBqIF0ueTtcblxuXHRcdFx0XHRcdG5vcm1hbC54ID0gZHkgKiAxLjA7XG5cdFx0XHRcdFx0bm9ybWFsLnkgPSAtIGR4O1xuXHRcdFx0XHRcdG5vcm1hbC56ID0gZHkgKiAwLjA7XG5cblx0XHRcdFx0XHRjdXJOb3JtYWwuY29weSggbm9ybWFsICk7XG5cblx0XHRcdFx0XHRub3JtYWwueCArPSBwcmV2Tm9ybWFsLng7XG5cdFx0XHRcdFx0bm9ybWFsLnkgKz0gcHJldk5vcm1hbC55O1xuXHRcdFx0XHRcdG5vcm1hbC56ICs9IHByZXZOb3JtYWwuejtcblxuXHRcdFx0XHRcdG5vcm1hbC5ub3JtYWxpemUoKTtcblxuXHRcdFx0XHRcdGluaXROb3JtYWxzLnB1c2goIG5vcm1hbC54LCBub3JtYWwueSwgbm9ybWFsLnogKTtcblxuXHRcdFx0XHRcdHByZXZOb3JtYWwuY29weSggY3VyTm9ybWFsICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdC8vIGdlbmVyYXRlIHZlcnRpY2VzLCB1dnMgYW5kIG5vcm1hbHNcblxuXHRcdGZvciAoIGxldCBpID0gMDsgaSA8PSBzZWdtZW50czsgaSArKyApIHtcblxuXHRcdFx0Y29uc3QgcGhpID0gcGhpU3RhcnQgKyBpICogaW52ZXJzZVNlZ21lbnRzICogcGhpTGVuZ3RoO1xuXG5cdFx0XHRjb25zdCBzaW4gPSBNYXRoLnNpbiggcGhpICk7XG5cdFx0XHRjb25zdCBjb3MgPSBNYXRoLmNvcyggcGhpICk7XG5cblx0XHRcdGZvciAoIGxldCBqID0gMDsgaiA8PSAoIHBvaW50cy5sZW5ndGggLSAxICk7IGogKysgKSB7XG5cblx0XHRcdFx0Ly8gdmVydGV4XG5cblx0XHRcdFx0dmVydGV4LnggPSBwb2ludHNbIGogXS54ICogc2luO1xuXHRcdFx0XHR2ZXJ0ZXgueSA9IHBvaW50c1sgaiBdLnk7XG5cdFx0XHRcdHZlcnRleC56ID0gcG9pbnRzWyBqIF0ueCAqIGNvcztcblxuXHRcdFx0XHR2ZXJ0aWNlcy5wdXNoKCB2ZXJ0ZXgueCwgdmVydGV4LnksIHZlcnRleC56ICk7XG5cblx0XHRcdFx0Ly8gdXZcblxuXHRcdFx0XHR1di54ID0gaSAvIHNlZ21lbnRzO1xuXHRcdFx0XHR1di55ID0gaiAvICggcG9pbnRzLmxlbmd0aCAtIDEgKTtcblxuXHRcdFx0XHR1dnMucHVzaCggdXYueCwgdXYueSApO1xuXG5cdFx0XHRcdC8vIG5vcm1hbFxuXG5cdFx0XHRcdGNvbnN0IHggPSBpbml0Tm9ybWFsc1sgMyAqIGogKyAwIF0gKiBzaW47XG5cdFx0XHRcdGNvbnN0IHkgPSBpbml0Tm9ybWFsc1sgMyAqIGogKyAxIF07XG5cdFx0XHRcdGNvbnN0IHogPSBpbml0Tm9ybWFsc1sgMyAqIGogKyAwIF0gKiBjb3M7XG5cblx0XHRcdFx0bm9ybWFscy5wdXNoKCB4LCB5LCB6ICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdC8vIGluZGljZXNcblxuXHRcdGZvciAoIGxldCBpID0gMDsgaSA8IHNlZ21lbnRzOyBpICsrICkge1xuXG5cdFx0XHRmb3IgKCBsZXQgaiA9IDA7IGogPCAoIHBvaW50cy5sZW5ndGggLSAxICk7IGogKysgKSB7XG5cblx0XHRcdFx0Y29uc3QgYmFzZSA9IGogKyBpICogcG9pbnRzLmxlbmd0aDtcblxuXHRcdFx0XHRjb25zdCBhID0gYmFzZTtcblx0XHRcdFx0Y29uc3QgYiA9IGJhc2UgKyBwb2ludHMubGVuZ3RoO1xuXHRcdFx0XHRjb25zdCBjID0gYmFzZSArIHBvaW50cy5sZW5ndGggKyAxO1xuXHRcdFx0XHRjb25zdCBkID0gYmFzZSArIDE7XG5cblx0XHRcdFx0Ly8gZmFjZXNcblxuXHRcdFx0XHRpbmRpY2VzLnB1c2goIGEsIGIsIGQgKTtcblx0XHRcdFx0aW5kaWNlcy5wdXNoKCBjLCBkLCBiICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdC8vIGJ1aWxkIGdlb21ldHJ5XG5cblx0XHR0aGlzLnNldEluZGV4KCBpbmRpY2VzICk7XG5cdFx0dGhpcy5zZXRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCB2ZXJ0aWNlcywgMyApICk7XG5cdFx0dGhpcy5zZXRBdHRyaWJ1dGUoICd1dicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCB1dnMsIDIgKSApO1xuXHRcdHRoaXMuc2V0QXR0cmlidXRlKCAnbm9ybWFsJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIG5vcm1hbHMsIDMgKSApO1xuXG5cdH1cblxuXHRjb3B5KCBzb3VyY2UgKSB7XG5cblx0XHRzdXBlci5jb3B5KCBzb3VyY2UgKTtcblxuXHRcdHRoaXMucGFyYW1ldGVycyA9IE9iamVjdC5hc3NpZ24oIHt9LCBzb3VyY2UucGFyYW1ldGVycyApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHN0YXRpYyBmcm9tSlNPTiggZGF0YSApIHtcblxuXHRcdHJldHVybiBuZXcgTGF0aGVHZW9tZXRyeSggZGF0YS5wb2ludHMsIGRhdGEuc2VnbWVudHMsIGRhdGEucGhpU3RhcnQsIGRhdGEucGhpTGVuZ3RoICk7XG5cblx0fVxuXG59XG5cblxuZXhwb3J0IHsgTGF0aGVHZW9tZXRyeSB9O1xuIiwiaW1wb3J0IHsgUG9seWhlZHJvbkdlb21ldHJ5IH0gZnJvbSAnLi9Qb2x5aGVkcm9uR2VvbWV0cnkuanMnO1xuXG5jbGFzcyBPY3RhaGVkcm9uR2VvbWV0cnkgZXh0ZW5kcyBQb2x5aGVkcm9uR2VvbWV0cnkge1xuXG5cdGNvbnN0cnVjdG9yKCByYWRpdXMgPSAxLCBkZXRhaWwgPSAwICkge1xuXG5cdFx0Y29uc3QgdmVydGljZXMgPSBbXG5cdFx0XHQxLCAwLCAwLCBcdC0gMSwgMCwgMCxcdDAsIDEsIDAsXG5cdFx0XHQwLCAtIDEsIDAsIFx0MCwgMCwgMSxcdDAsIDAsIC0gMVxuXHRcdF07XG5cblx0XHRjb25zdCBpbmRpY2VzID0gW1xuXHRcdFx0MCwgMiwgNCxcdDAsIDQsIDMsXHQwLCAzLCA1LFxuXHRcdFx0MCwgNSwgMixcdDEsIDIsIDUsXHQxLCA1LCAzLFxuXHRcdFx0MSwgMywgNCxcdDEsIDQsIDJcblx0XHRdO1xuXG5cdFx0c3VwZXIoIHZlcnRpY2VzLCBpbmRpY2VzLCByYWRpdXMsIGRldGFpbCApO1xuXG5cdFx0dGhpcy50eXBlID0gJ09jdGFoZWRyb25HZW9tZXRyeSc7XG5cblx0XHR0aGlzLnBhcmFtZXRlcnMgPSB7XG5cdFx0XHRyYWRpdXM6IHJhZGl1cyxcblx0XHRcdGRldGFpbDogZGV0YWlsXG5cdFx0fTtcblxuXHR9XG5cblx0c3RhdGljIGZyb21KU09OKCBkYXRhICkge1xuXG5cdFx0cmV0dXJuIG5ldyBPY3RhaGVkcm9uR2VvbWV0cnkoIGRhdGEucmFkaXVzLCBkYXRhLmRldGFpbCApO1xuXG5cdH1cblxufVxuXG5leHBvcnQgeyBPY3RhaGVkcm9uR2VvbWV0cnkgfTtcbiIsImltcG9ydCB7IEJ1ZmZlckdlb21ldHJ5IH0gZnJvbSAnLi4vY29yZS9CdWZmZXJHZW9tZXRyeS5qcyc7XG5pbXBvcnQgeyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlIH0gZnJvbSAnLi4vY29yZS9CdWZmZXJBdHRyaWJ1dGUuanMnO1xuXG5jbGFzcyBQbGFuZUdlb21ldHJ5IGV4dGVuZHMgQnVmZmVyR2VvbWV0cnkge1xuXG5cdGNvbnN0cnVjdG9yKCB3aWR0aCA9IDEsIGhlaWdodCA9IDEsIHdpZHRoU2VnbWVudHMgPSAxLCBoZWlnaHRTZWdtZW50cyA9IDEgKSB7XG5cblx0XHRzdXBlcigpO1xuXG5cdFx0dGhpcy50eXBlID0gJ1BsYW5lR2VvbWV0cnknO1xuXG5cdFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xuXHRcdFx0d2lkdGg6IHdpZHRoLFxuXHRcdFx0aGVpZ2h0OiBoZWlnaHQsXG5cdFx0XHR3aWR0aFNlZ21lbnRzOiB3aWR0aFNlZ21lbnRzLFxuXHRcdFx0aGVpZ2h0U2VnbWVudHM6IGhlaWdodFNlZ21lbnRzXG5cdFx0fTtcblxuXHRcdGNvbnN0IHdpZHRoX2hhbGYgPSB3aWR0aCAvIDI7XG5cdFx0Y29uc3QgaGVpZ2h0X2hhbGYgPSBoZWlnaHQgLyAyO1xuXG5cdFx0Y29uc3QgZ3JpZFggPSBNYXRoLmZsb29yKCB3aWR0aFNlZ21lbnRzICk7XG5cdFx0Y29uc3QgZ3JpZFkgPSBNYXRoLmZsb29yKCBoZWlnaHRTZWdtZW50cyApO1xuXG5cdFx0Y29uc3QgZ3JpZFgxID0gZ3JpZFggKyAxO1xuXHRcdGNvbnN0IGdyaWRZMSA9IGdyaWRZICsgMTtcblxuXHRcdGNvbnN0IHNlZ21lbnRfd2lkdGggPSB3aWR0aCAvIGdyaWRYO1xuXHRcdGNvbnN0IHNlZ21lbnRfaGVpZ2h0ID0gaGVpZ2h0IC8gZ3JpZFk7XG5cblx0XHQvL1xuXG5cdFx0Y29uc3QgaW5kaWNlcyA9IFtdO1xuXHRcdGNvbnN0IHZlcnRpY2VzID0gW107XG5cdFx0Y29uc3Qgbm9ybWFscyA9IFtdO1xuXHRcdGNvbnN0IHV2cyA9IFtdO1xuXG5cdFx0Zm9yICggbGV0IGl5ID0gMDsgaXkgPCBncmlkWTE7IGl5ICsrICkge1xuXG5cdFx0XHRjb25zdCB5ID0gaXkgKiBzZWdtZW50X2hlaWdodCAtIGhlaWdodF9oYWxmO1xuXG5cdFx0XHRmb3IgKCBsZXQgaXggPSAwOyBpeCA8IGdyaWRYMTsgaXggKysgKSB7XG5cblx0XHRcdFx0Y29uc3QgeCA9IGl4ICogc2VnbWVudF93aWR0aCAtIHdpZHRoX2hhbGY7XG5cblx0XHRcdFx0dmVydGljZXMucHVzaCggeCwgLSB5LCAwICk7XG5cblx0XHRcdFx0bm9ybWFscy5wdXNoKCAwLCAwLCAxICk7XG5cblx0XHRcdFx0dXZzLnB1c2goIGl4IC8gZ3JpZFggKTtcblx0XHRcdFx0dXZzLnB1c2goIDEgLSAoIGl5IC8gZ3JpZFkgKSApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRmb3IgKCBsZXQgaXkgPSAwOyBpeSA8IGdyaWRZOyBpeSArKyApIHtcblxuXHRcdFx0Zm9yICggbGV0IGl4ID0gMDsgaXggPCBncmlkWDsgaXggKysgKSB7XG5cblx0XHRcdFx0Y29uc3QgYSA9IGl4ICsgZ3JpZFgxICogaXk7XG5cdFx0XHRcdGNvbnN0IGIgPSBpeCArIGdyaWRYMSAqICggaXkgKyAxICk7XG5cdFx0XHRcdGNvbnN0IGMgPSAoIGl4ICsgMSApICsgZ3JpZFgxICogKCBpeSArIDEgKTtcblx0XHRcdFx0Y29uc3QgZCA9ICggaXggKyAxICkgKyBncmlkWDEgKiBpeTtcblxuXHRcdFx0XHRpbmRpY2VzLnB1c2goIGEsIGIsIGQgKTtcblx0XHRcdFx0aW5kaWNlcy5wdXNoKCBiLCBjLCBkICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHRoaXMuc2V0SW5kZXgoIGluZGljZXMgKTtcblx0XHR0aGlzLnNldEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHZlcnRpY2VzLCAzICkgKTtcblx0XHR0aGlzLnNldEF0dHJpYnV0ZSggJ25vcm1hbCcsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBub3JtYWxzLCAzICkgKTtcblx0XHR0aGlzLnNldEF0dHJpYnV0ZSggJ3V2JywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHV2cywgMiApICk7XG5cblx0fVxuXG5cdGNvcHkoIHNvdXJjZSApIHtcblxuXHRcdHN1cGVyLmNvcHkoIHNvdXJjZSApO1xuXG5cdFx0dGhpcy5wYXJhbWV0ZXJzID0gT2JqZWN0LmFzc2lnbigge30sIHNvdXJjZS5wYXJhbWV0ZXJzICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c3RhdGljIGZyb21KU09OKCBkYXRhICkge1xuXG5cdFx0cmV0dXJuIG5ldyBQbGFuZUdlb21ldHJ5KCBkYXRhLndpZHRoLCBkYXRhLmhlaWdodCwgZGF0YS53aWR0aFNlZ21lbnRzLCBkYXRhLmhlaWdodFNlZ21lbnRzICk7XG5cblx0fVxuXG59XG5cbmV4cG9ydCB7IFBsYW5lR2VvbWV0cnkgfTtcbiIsImltcG9ydCB7IEJ1ZmZlckdlb21ldHJ5IH0gZnJvbSAnLi4vY29yZS9CdWZmZXJHZW9tZXRyeS5qcyc7XG5pbXBvcnQgeyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlIH0gZnJvbSAnLi4vY29yZS9CdWZmZXJBdHRyaWJ1dGUuanMnO1xuaW1wb3J0IHsgVmVjdG9yMyB9IGZyb20gJy4uL21hdGgvVmVjdG9yMy5qcyc7XG5pbXBvcnQgeyBWZWN0b3IyIH0gZnJvbSAnLi4vbWF0aC9WZWN0b3IyLmpzJztcblxuY2xhc3MgUG9seWhlZHJvbkdlb21ldHJ5IGV4dGVuZHMgQnVmZmVyR2VvbWV0cnkge1xuXG5cdGNvbnN0cnVjdG9yKCB2ZXJ0aWNlcyA9IFtdLCBpbmRpY2VzID0gW10sIHJhZGl1cyA9IDEsIGRldGFpbCA9IDAgKSB7XG5cblx0XHRzdXBlcigpO1xuXG5cdFx0dGhpcy50eXBlID0gJ1BvbHloZWRyb25HZW9tZXRyeSc7XG5cblx0XHR0aGlzLnBhcmFtZXRlcnMgPSB7XG5cdFx0XHR2ZXJ0aWNlczogdmVydGljZXMsXG5cdFx0XHRpbmRpY2VzOiBpbmRpY2VzLFxuXHRcdFx0cmFkaXVzOiByYWRpdXMsXG5cdFx0XHRkZXRhaWw6IGRldGFpbFxuXHRcdH07XG5cblx0XHQvLyBkZWZhdWx0IGJ1ZmZlciBkYXRhXG5cblx0XHRjb25zdCB2ZXJ0ZXhCdWZmZXIgPSBbXTtcblx0XHRjb25zdCB1dkJ1ZmZlciA9IFtdO1xuXG5cdFx0Ly8gdGhlIHN1YmRpdmlzaW9uIGNyZWF0ZXMgdGhlIHZlcnRleCBidWZmZXIgZGF0YVxuXG5cdFx0c3ViZGl2aWRlKCBkZXRhaWwgKTtcblxuXHRcdC8vIGFsbCB2ZXJ0aWNlcyBzaG91bGQgbGllIG9uIGEgY29uY2VwdHVhbCBzcGhlcmUgd2l0aCBhIGdpdmVuIHJhZGl1c1xuXG5cdFx0YXBwbHlSYWRpdXMoIHJhZGl1cyApO1xuXG5cdFx0Ly8gZmluYWxseSwgY3JlYXRlIHRoZSB1diBkYXRhXG5cblx0XHRnZW5lcmF0ZVVWcygpO1xuXG5cdFx0Ly8gYnVpbGQgbm9uLWluZGV4ZWQgZ2VvbWV0cnlcblxuXHRcdHRoaXMuc2V0QXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggdmVydGV4QnVmZmVyLCAzICkgKTtcblx0XHR0aGlzLnNldEF0dHJpYnV0ZSggJ25vcm1hbCcsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCB2ZXJ0ZXhCdWZmZXIuc2xpY2UoKSwgMyApICk7XG5cdFx0dGhpcy5zZXRBdHRyaWJ1dGUoICd1dicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCB1dkJ1ZmZlciwgMiApICk7XG5cblx0XHRpZiAoIGRldGFpbCA9PT0gMCApIHtcblxuXHRcdFx0dGhpcy5jb21wdXRlVmVydGV4Tm9ybWFscygpOyAvLyBmbGF0IG5vcm1hbHNcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHRoaXMubm9ybWFsaXplTm9ybWFscygpOyAvLyBzbW9vdGggbm9ybWFsc1xuXG5cdFx0fVxuXG5cdFx0Ly8gaGVscGVyIGZ1bmN0aW9uc1xuXG5cdFx0ZnVuY3Rpb24gc3ViZGl2aWRlKCBkZXRhaWwgKSB7XG5cblx0XHRcdGNvbnN0IGEgPSBuZXcgVmVjdG9yMygpO1xuXHRcdFx0Y29uc3QgYiA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0XHRjb25zdCBjID0gbmV3IFZlY3RvcjMoKTtcblxuXHRcdFx0Ly8gaXRlcmF0ZSBvdmVyIGFsbCBmYWNlcyBhbmQgYXBwbHkgYSBzdWJkaXZpc2lvbiB3aXRoIHRoZSBnaXZlbiBkZXRhaWwgdmFsdWVcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgaW5kaWNlcy5sZW5ndGg7IGkgKz0gMyApIHtcblxuXHRcdFx0XHQvLyBnZXQgdGhlIHZlcnRpY2VzIG9mIHRoZSBmYWNlXG5cblx0XHRcdFx0Z2V0VmVydGV4QnlJbmRleCggaW5kaWNlc1sgaSArIDAgXSwgYSApO1xuXHRcdFx0XHRnZXRWZXJ0ZXhCeUluZGV4KCBpbmRpY2VzWyBpICsgMSBdLCBiICk7XG5cdFx0XHRcdGdldFZlcnRleEJ5SW5kZXgoIGluZGljZXNbIGkgKyAyIF0sIGMgKTtcblxuXHRcdFx0XHQvLyBwZXJmb3JtIHN1YmRpdmlzaW9uXG5cblx0XHRcdFx0c3ViZGl2aWRlRmFjZSggYSwgYiwgYywgZGV0YWlsICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHN1YmRpdmlkZUZhY2UoIGEsIGIsIGMsIGRldGFpbCApIHtcblxuXHRcdFx0Y29uc3QgY29scyA9IGRldGFpbCArIDE7XG5cblx0XHRcdC8vIHdlIHVzZSB0aGlzIG11bHRpZGltZW5zaW9uYWwgYXJyYXkgYXMgYSBkYXRhIHN0cnVjdHVyZSBmb3IgY3JlYXRpbmcgdGhlIHN1YmRpdmlzaW9uXG5cblx0XHRcdGNvbnN0IHYgPSBbXTtcblxuXHRcdFx0Ly8gY29uc3RydWN0IGFsbCBvZiB0aGUgdmVydGljZXMgZm9yIHRoaXMgc3ViZGl2aXNpb25cblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDw9IGNvbHM7IGkgKysgKSB7XG5cblx0XHRcdFx0dlsgaSBdID0gW107XG5cblx0XHRcdFx0Y29uc3QgYWogPSBhLmNsb25lKCkubGVycCggYywgaSAvIGNvbHMgKTtcblx0XHRcdFx0Y29uc3QgYmogPSBiLmNsb25lKCkubGVycCggYywgaSAvIGNvbHMgKTtcblxuXHRcdFx0XHRjb25zdCByb3dzID0gY29scyAtIGk7XG5cblx0XHRcdFx0Zm9yICggbGV0IGogPSAwOyBqIDw9IHJvd3M7IGogKysgKSB7XG5cblx0XHRcdFx0XHRpZiAoIGogPT09IDAgJiYgaSA9PT0gY29scyApIHtcblxuXHRcdFx0XHRcdFx0dlsgaSBdWyBqIF0gPSBhajtcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdHZbIGkgXVsgaiBdID0gYWouY2xvbmUoKS5sZXJwKCBiaiwgaiAvIHJvd3MgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gY29uc3RydWN0IGFsbCBvZiB0aGUgZmFjZXNcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgY29sczsgaSArKyApIHtcblxuXHRcdFx0XHRmb3IgKCBsZXQgaiA9IDA7IGogPCAyICogKCBjb2xzIC0gaSApIC0gMTsgaiArKyApIHtcblxuXHRcdFx0XHRcdGNvbnN0IGsgPSBNYXRoLmZsb29yKCBqIC8gMiApO1xuXG5cdFx0XHRcdFx0aWYgKCBqICUgMiA9PT0gMCApIHtcblxuXHRcdFx0XHRcdFx0cHVzaFZlcnRleCggdlsgaSBdWyBrICsgMSBdICk7XG5cdFx0XHRcdFx0XHRwdXNoVmVydGV4KCB2WyBpICsgMSBdWyBrIF0gKTtcblx0XHRcdFx0XHRcdHB1c2hWZXJ0ZXgoIHZbIGkgXVsgayBdICk7XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRwdXNoVmVydGV4KCB2WyBpIF1bIGsgKyAxIF0gKTtcblx0XHRcdFx0XHRcdHB1c2hWZXJ0ZXgoIHZbIGkgKyAxIF1bIGsgKyAxIF0gKTtcblx0XHRcdFx0XHRcdHB1c2hWZXJ0ZXgoIHZbIGkgKyAxIF1bIGsgXSApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gYXBwbHlSYWRpdXMoIHJhZGl1cyApIHtcblxuXHRcdFx0Y29uc3QgdmVydGV4ID0gbmV3IFZlY3RvcjMoKTtcblxuXHRcdFx0Ly8gaXRlcmF0ZSBvdmVyIHRoZSBlbnRpcmUgYnVmZmVyIGFuZCBhcHBseSB0aGUgcmFkaXVzIHRvIGVhY2ggdmVydGV4XG5cblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IHZlcnRleEJ1ZmZlci5sZW5ndGg7IGkgKz0gMyApIHtcblxuXHRcdFx0XHR2ZXJ0ZXgueCA9IHZlcnRleEJ1ZmZlclsgaSArIDAgXTtcblx0XHRcdFx0dmVydGV4LnkgPSB2ZXJ0ZXhCdWZmZXJbIGkgKyAxIF07XG5cdFx0XHRcdHZlcnRleC56ID0gdmVydGV4QnVmZmVyWyBpICsgMiBdO1xuXG5cdFx0XHRcdHZlcnRleC5ub3JtYWxpemUoKS5tdWx0aXBseVNjYWxhciggcmFkaXVzICk7XG5cblx0XHRcdFx0dmVydGV4QnVmZmVyWyBpICsgMCBdID0gdmVydGV4Lng7XG5cdFx0XHRcdHZlcnRleEJ1ZmZlclsgaSArIDEgXSA9IHZlcnRleC55O1xuXHRcdFx0XHR2ZXJ0ZXhCdWZmZXJbIGkgKyAyIF0gPSB2ZXJ0ZXguejtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZ2VuZXJhdGVVVnMoKSB7XG5cblx0XHRcdGNvbnN0IHZlcnRleCA9IG5ldyBWZWN0b3IzKCk7XG5cblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IHZlcnRleEJ1ZmZlci5sZW5ndGg7IGkgKz0gMyApIHtcblxuXHRcdFx0XHR2ZXJ0ZXgueCA9IHZlcnRleEJ1ZmZlclsgaSArIDAgXTtcblx0XHRcdFx0dmVydGV4LnkgPSB2ZXJ0ZXhCdWZmZXJbIGkgKyAxIF07XG5cdFx0XHRcdHZlcnRleC56ID0gdmVydGV4QnVmZmVyWyBpICsgMiBdO1xuXG5cdFx0XHRcdGNvbnN0IHUgPSBhemltdXRoKCB2ZXJ0ZXggKSAvIDIgLyBNYXRoLlBJICsgMC41O1xuXHRcdFx0XHRjb25zdCB2ID0gaW5jbGluYXRpb24oIHZlcnRleCApIC8gTWF0aC5QSSArIDAuNTtcblx0XHRcdFx0dXZCdWZmZXIucHVzaCggdSwgMSAtIHYgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRjb3JyZWN0VVZzKCk7XG5cblx0XHRcdGNvcnJlY3RTZWFtKCk7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBjb3JyZWN0U2VhbSgpIHtcblxuXHRcdFx0Ly8gaGFuZGxlIGNhc2Ugd2hlbiBmYWNlIHN0cmFkZGxlcyB0aGUgc2VhbSwgc2VlICMzMjY5XG5cblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IHV2QnVmZmVyLmxlbmd0aDsgaSArPSA2ICkge1xuXG5cdFx0XHRcdC8vIHV2IGRhdGEgb2YgYSBzaW5nbGUgZmFjZVxuXG5cdFx0XHRcdGNvbnN0IHgwID0gdXZCdWZmZXJbIGkgKyAwIF07XG5cdFx0XHRcdGNvbnN0IHgxID0gdXZCdWZmZXJbIGkgKyAyIF07XG5cdFx0XHRcdGNvbnN0IHgyID0gdXZCdWZmZXJbIGkgKyA0IF07XG5cblx0XHRcdFx0Y29uc3QgbWF4ID0gTWF0aC5tYXgoIHgwLCB4MSwgeDIgKTtcblx0XHRcdFx0Y29uc3QgbWluID0gTWF0aC5taW4oIHgwLCB4MSwgeDIgKTtcblxuXHRcdFx0XHQvLyAwLjkgaXMgc29tZXdoYXQgYXJiaXRyYXJ5XG5cblx0XHRcdFx0aWYgKCBtYXggPiAwLjkgJiYgbWluIDwgMC4xICkge1xuXG5cdFx0XHRcdFx0aWYgKCB4MCA8IDAuMiApIHV2QnVmZmVyWyBpICsgMCBdICs9IDE7XG5cdFx0XHRcdFx0aWYgKCB4MSA8IDAuMiApIHV2QnVmZmVyWyBpICsgMiBdICs9IDE7XG5cdFx0XHRcdFx0aWYgKCB4MiA8IDAuMiApIHV2QnVmZmVyWyBpICsgNCBdICs9IDE7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBwdXNoVmVydGV4KCB2ZXJ0ZXggKSB7XG5cblx0XHRcdHZlcnRleEJ1ZmZlci5wdXNoKCB2ZXJ0ZXgueCwgdmVydGV4LnksIHZlcnRleC56ICk7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBnZXRWZXJ0ZXhCeUluZGV4KCBpbmRleCwgdmVydGV4ICkge1xuXG5cdFx0XHRjb25zdCBzdHJpZGUgPSBpbmRleCAqIDM7XG5cblx0XHRcdHZlcnRleC54ID0gdmVydGljZXNbIHN0cmlkZSArIDAgXTtcblx0XHRcdHZlcnRleC55ID0gdmVydGljZXNbIHN0cmlkZSArIDEgXTtcblx0XHRcdHZlcnRleC56ID0gdmVydGljZXNbIHN0cmlkZSArIDIgXTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGNvcnJlY3RVVnMoKSB7XG5cblx0XHRcdGNvbnN0IGEgPSBuZXcgVmVjdG9yMygpO1xuXHRcdFx0Y29uc3QgYiA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0XHRjb25zdCBjID0gbmV3IFZlY3RvcjMoKTtcblxuXHRcdFx0Y29uc3QgY2VudHJvaWQgPSBuZXcgVmVjdG9yMygpO1xuXG5cdFx0XHRjb25zdCB1dkEgPSBuZXcgVmVjdG9yMigpO1xuXHRcdFx0Y29uc3QgdXZCID0gbmV3IFZlY3RvcjIoKTtcblx0XHRcdGNvbnN0IHV2QyA9IG5ldyBWZWN0b3IyKCk7XG5cblx0XHRcdGZvciAoIGxldCBpID0gMCwgaiA9IDA7IGkgPCB2ZXJ0ZXhCdWZmZXIubGVuZ3RoOyBpICs9IDksIGogKz0gNiApIHtcblxuXHRcdFx0XHRhLnNldCggdmVydGV4QnVmZmVyWyBpICsgMCBdLCB2ZXJ0ZXhCdWZmZXJbIGkgKyAxIF0sIHZlcnRleEJ1ZmZlclsgaSArIDIgXSApO1xuXHRcdFx0XHRiLnNldCggdmVydGV4QnVmZmVyWyBpICsgMyBdLCB2ZXJ0ZXhCdWZmZXJbIGkgKyA0IF0sIHZlcnRleEJ1ZmZlclsgaSArIDUgXSApO1xuXHRcdFx0XHRjLnNldCggdmVydGV4QnVmZmVyWyBpICsgNiBdLCB2ZXJ0ZXhCdWZmZXJbIGkgKyA3IF0sIHZlcnRleEJ1ZmZlclsgaSArIDggXSApO1xuXG5cdFx0XHRcdHV2QS5zZXQoIHV2QnVmZmVyWyBqICsgMCBdLCB1dkJ1ZmZlclsgaiArIDEgXSApO1xuXHRcdFx0XHR1dkIuc2V0KCB1dkJ1ZmZlclsgaiArIDIgXSwgdXZCdWZmZXJbIGogKyAzIF0gKTtcblx0XHRcdFx0dXZDLnNldCggdXZCdWZmZXJbIGogKyA0IF0sIHV2QnVmZmVyWyBqICsgNSBdICk7XG5cblx0XHRcdFx0Y2VudHJvaWQuY29weSggYSApLmFkZCggYiApLmFkZCggYyApLmRpdmlkZVNjYWxhciggMyApO1xuXG5cdFx0XHRcdGNvbnN0IGF6aSA9IGF6aW11dGgoIGNlbnRyb2lkICk7XG5cblx0XHRcdFx0Y29ycmVjdFVWKCB1dkEsIGogKyAwLCBhLCBhemkgKTtcblx0XHRcdFx0Y29ycmVjdFVWKCB1dkIsIGogKyAyLCBiLCBhemkgKTtcblx0XHRcdFx0Y29ycmVjdFVWKCB1dkMsIGogKyA0LCBjLCBhemkgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gY29ycmVjdFVWKCB1diwgc3RyaWRlLCB2ZWN0b3IsIGF6aW11dGggKSB7XG5cblx0XHRcdGlmICggKCBhemltdXRoIDwgMCApICYmICggdXYueCA9PT0gMSApICkge1xuXG5cdFx0XHRcdHV2QnVmZmVyWyBzdHJpZGUgXSA9IHV2LnggLSAxO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggKCB2ZWN0b3IueCA9PT0gMCApICYmICggdmVjdG9yLnogPT09IDAgKSApIHtcblxuXHRcdFx0XHR1dkJ1ZmZlclsgc3RyaWRlIF0gPSBhemltdXRoIC8gMiAvIE1hdGguUEkgKyAwLjU7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdC8vIEFuZ2xlIGFyb3VuZCB0aGUgWSBheGlzLCBjb3VudGVyLWNsb2Nrd2lzZSB3aGVuIGxvb2tpbmcgZnJvbSBhYm92ZS5cblxuXHRcdGZ1bmN0aW9uIGF6aW11dGgoIHZlY3RvciApIHtcblxuXHRcdFx0cmV0dXJuIE1hdGguYXRhbjIoIHZlY3Rvci56LCAtIHZlY3Rvci54ICk7XG5cblx0XHR9XG5cblxuXHRcdC8vIEFuZ2xlIGFib3ZlIHRoZSBYWiBwbGFuZS5cblxuXHRcdGZ1bmN0aW9uIGluY2xpbmF0aW9uKCB2ZWN0b3IgKSB7XG5cblx0XHRcdHJldHVybiBNYXRoLmF0YW4yKCAtIHZlY3Rvci55LCBNYXRoLnNxcnQoICggdmVjdG9yLnggKiB2ZWN0b3IueCApICsgKCB2ZWN0b3IueiAqIHZlY3Rvci56ICkgKSApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRjb3B5KCBzb3VyY2UgKSB7XG5cblx0XHRzdXBlci5jb3B5KCBzb3VyY2UgKTtcblxuXHRcdHRoaXMucGFyYW1ldGVycyA9IE9iamVjdC5hc3NpZ24oIHt9LCBzb3VyY2UucGFyYW1ldGVycyApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHN0YXRpYyBmcm9tSlNPTiggZGF0YSApIHtcblxuXHRcdHJldHVybiBuZXcgUG9seWhlZHJvbkdlb21ldHJ5KCBkYXRhLnZlcnRpY2VzLCBkYXRhLmluZGljZXMsIGRhdGEucmFkaXVzLCBkYXRhLmRldGFpbHMgKTtcblxuXHR9XG5cbn1cblxuZXhwb3J0IHsgUG9seWhlZHJvbkdlb21ldHJ5IH07XG4iLCJpbXBvcnQgeyBCdWZmZXJHZW9tZXRyeSB9IGZyb20gJy4uL2NvcmUvQnVmZmVyR2VvbWV0cnkuanMnO1xuaW1wb3J0IHsgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSB9IGZyb20gJy4uL2NvcmUvQnVmZmVyQXR0cmlidXRlLmpzJztcbmltcG9ydCB7IFZlY3RvcjIgfSBmcm9tICcuLi9tYXRoL1ZlY3RvcjIuanMnO1xuaW1wb3J0IHsgVmVjdG9yMyB9IGZyb20gJy4uL21hdGgvVmVjdG9yMy5qcyc7XG5cbmNsYXNzIFJpbmdHZW9tZXRyeSBleHRlbmRzIEJ1ZmZlckdlb21ldHJ5IHtcblxuXHRjb25zdHJ1Y3RvciggaW5uZXJSYWRpdXMgPSAwLjUsIG91dGVyUmFkaXVzID0gMSwgdGhldGFTZWdtZW50cyA9IDMyLCBwaGlTZWdtZW50cyA9IDEsIHRoZXRhU3RhcnQgPSAwLCB0aGV0YUxlbmd0aCA9IE1hdGguUEkgKiAyICkge1xuXG5cdFx0c3VwZXIoKTtcblxuXHRcdHRoaXMudHlwZSA9ICdSaW5nR2VvbWV0cnknO1xuXG5cdFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xuXHRcdFx0aW5uZXJSYWRpdXM6IGlubmVyUmFkaXVzLFxuXHRcdFx0b3V0ZXJSYWRpdXM6IG91dGVyUmFkaXVzLFxuXHRcdFx0dGhldGFTZWdtZW50czogdGhldGFTZWdtZW50cyxcblx0XHRcdHBoaVNlZ21lbnRzOiBwaGlTZWdtZW50cyxcblx0XHRcdHRoZXRhU3RhcnQ6IHRoZXRhU3RhcnQsXG5cdFx0XHR0aGV0YUxlbmd0aDogdGhldGFMZW5ndGhcblx0XHR9O1xuXG5cdFx0dGhldGFTZWdtZW50cyA9IE1hdGgubWF4KCAzLCB0aGV0YVNlZ21lbnRzICk7XG5cdFx0cGhpU2VnbWVudHMgPSBNYXRoLm1heCggMSwgcGhpU2VnbWVudHMgKTtcblxuXHRcdC8vIGJ1ZmZlcnNcblxuXHRcdGNvbnN0IGluZGljZXMgPSBbXTtcblx0XHRjb25zdCB2ZXJ0aWNlcyA9IFtdO1xuXHRcdGNvbnN0IG5vcm1hbHMgPSBbXTtcblx0XHRjb25zdCB1dnMgPSBbXTtcblxuXHRcdC8vIHNvbWUgaGVscGVyIHZhcmlhYmxlc1xuXG5cdFx0bGV0IHJhZGl1cyA9IGlubmVyUmFkaXVzO1xuXHRcdGNvbnN0IHJhZGl1c1N0ZXAgPSAoICggb3V0ZXJSYWRpdXMgLSBpbm5lclJhZGl1cyApIC8gcGhpU2VnbWVudHMgKTtcblx0XHRjb25zdCB2ZXJ0ZXggPSBuZXcgVmVjdG9yMygpO1xuXHRcdGNvbnN0IHV2ID0gbmV3IFZlY3RvcjIoKTtcblxuXHRcdC8vIGdlbmVyYXRlIHZlcnRpY2VzLCBub3JtYWxzIGFuZCB1dnNcblxuXHRcdGZvciAoIGxldCBqID0gMDsgaiA8PSBwaGlTZWdtZW50czsgaiArKyApIHtcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDw9IHRoZXRhU2VnbWVudHM7IGkgKysgKSB7XG5cblx0XHRcdFx0Ly8gdmFsdWVzIGFyZSBnZW5lcmF0ZSBmcm9tIHRoZSBpbnNpZGUgb2YgdGhlIHJpbmcgdG8gdGhlIG91dHNpZGVcblxuXHRcdFx0XHRjb25zdCBzZWdtZW50ID0gdGhldGFTdGFydCArIGkgLyB0aGV0YVNlZ21lbnRzICogdGhldGFMZW5ndGg7XG5cblx0XHRcdFx0Ly8gdmVydGV4XG5cblx0XHRcdFx0dmVydGV4LnggPSByYWRpdXMgKiBNYXRoLmNvcyggc2VnbWVudCApO1xuXHRcdFx0XHR2ZXJ0ZXgueSA9IHJhZGl1cyAqIE1hdGguc2luKCBzZWdtZW50ICk7XG5cblx0XHRcdFx0dmVydGljZXMucHVzaCggdmVydGV4LngsIHZlcnRleC55LCB2ZXJ0ZXgueiApO1xuXG5cdFx0XHRcdC8vIG5vcm1hbFxuXG5cdFx0XHRcdG5vcm1hbHMucHVzaCggMCwgMCwgMSApO1xuXG5cdFx0XHRcdC8vIHV2XG5cblx0XHRcdFx0dXYueCA9ICggdmVydGV4LnggLyBvdXRlclJhZGl1cyArIDEgKSAvIDI7XG5cdFx0XHRcdHV2LnkgPSAoIHZlcnRleC55IC8gb3V0ZXJSYWRpdXMgKyAxICkgLyAyO1xuXG5cdFx0XHRcdHV2cy5wdXNoKCB1di54LCB1di55ICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gaW5jcmVhc2UgdGhlIHJhZGl1cyBmb3IgbmV4dCByb3cgb2YgdmVydGljZXNcblxuXHRcdFx0cmFkaXVzICs9IHJhZGl1c1N0ZXA7XG5cblx0XHR9XG5cblx0XHQvLyBpbmRpY2VzXG5cblx0XHRmb3IgKCBsZXQgaiA9IDA7IGogPCBwaGlTZWdtZW50czsgaiArKyApIHtcblxuXHRcdFx0Y29uc3QgdGhldGFTZWdtZW50TGV2ZWwgPSBqICogKCB0aGV0YVNlZ21lbnRzICsgMSApO1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCB0aGV0YVNlZ21lbnRzOyBpICsrICkge1xuXG5cdFx0XHRcdGNvbnN0IHNlZ21lbnQgPSBpICsgdGhldGFTZWdtZW50TGV2ZWw7XG5cblx0XHRcdFx0Y29uc3QgYSA9IHNlZ21lbnQ7XG5cdFx0XHRcdGNvbnN0IGIgPSBzZWdtZW50ICsgdGhldGFTZWdtZW50cyArIDE7XG5cdFx0XHRcdGNvbnN0IGMgPSBzZWdtZW50ICsgdGhldGFTZWdtZW50cyArIDI7XG5cdFx0XHRcdGNvbnN0IGQgPSBzZWdtZW50ICsgMTtcblxuXHRcdFx0XHQvLyBmYWNlc1xuXG5cdFx0XHRcdGluZGljZXMucHVzaCggYSwgYiwgZCApO1xuXHRcdFx0XHRpbmRpY2VzLnB1c2goIGIsIGMsIGQgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Ly8gYnVpbGQgZ2VvbWV0cnlcblxuXHRcdHRoaXMuc2V0SW5kZXgoIGluZGljZXMgKTtcblx0XHR0aGlzLnNldEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHZlcnRpY2VzLCAzICkgKTtcblx0XHR0aGlzLnNldEF0dHJpYnV0ZSggJ25vcm1hbCcsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBub3JtYWxzLCAzICkgKTtcblx0XHR0aGlzLnNldEF0dHJpYnV0ZSggJ3V2JywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHV2cywgMiApICk7XG5cblx0fVxuXG5cdGNvcHkoIHNvdXJjZSApIHtcblxuXHRcdHN1cGVyLmNvcHkoIHNvdXJjZSApO1xuXG5cdFx0dGhpcy5wYXJhbWV0ZXJzID0gT2JqZWN0LmFzc2lnbigge30sIHNvdXJjZS5wYXJhbWV0ZXJzICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c3RhdGljIGZyb21KU09OKCBkYXRhICkge1xuXG5cdFx0cmV0dXJuIG5ldyBSaW5nR2VvbWV0cnkoIGRhdGEuaW5uZXJSYWRpdXMsIGRhdGEub3V0ZXJSYWRpdXMsIGRhdGEudGhldGFTZWdtZW50cywgZGF0YS5waGlTZWdtZW50cywgZGF0YS50aGV0YVN0YXJ0LCBkYXRhLnRoZXRhTGVuZ3RoICk7XG5cblx0fVxuXG59XG5cblxuZXhwb3J0IHsgUmluZ0dlb21ldHJ5IH07XG4iLCJpbXBvcnQgeyBCdWZmZXJHZW9tZXRyeSB9IGZyb20gJy4uL2NvcmUvQnVmZmVyR2VvbWV0cnkuanMnO1xuaW1wb3J0IHsgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSB9IGZyb20gJy4uL2NvcmUvQnVmZmVyQXR0cmlidXRlLmpzJztcbmltcG9ydCB7IFNoYXBlIH0gZnJvbSAnLi4vZXh0cmFzL2NvcmUvU2hhcGUuanMnO1xuaW1wb3J0IHsgU2hhcGVVdGlscyB9IGZyb20gJy4uL2V4dHJhcy9TaGFwZVV0aWxzLmpzJztcbmltcG9ydCB7IFZlY3RvcjIgfSBmcm9tICcuLi9tYXRoL1ZlY3RvcjIuanMnO1xuXG5jbGFzcyBTaGFwZUdlb21ldHJ5IGV4dGVuZHMgQnVmZmVyR2VvbWV0cnkge1xuXG5cdGNvbnN0cnVjdG9yKCBzaGFwZXMgPSBuZXcgU2hhcGUoIFsgbmV3IFZlY3RvcjIoIDAsIDAuNSApLCBuZXcgVmVjdG9yMiggLSAwLjUsIC0gMC41ICksIG5ldyBWZWN0b3IyKCAwLjUsIC0gMC41ICkgXSApLCBjdXJ2ZVNlZ21lbnRzID0gMTIgKSB7XG5cblx0XHRzdXBlcigpO1xuXG5cdFx0dGhpcy50eXBlID0gJ1NoYXBlR2VvbWV0cnknO1xuXG5cdFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xuXHRcdFx0c2hhcGVzOiBzaGFwZXMsXG5cdFx0XHRjdXJ2ZVNlZ21lbnRzOiBjdXJ2ZVNlZ21lbnRzXG5cdFx0fTtcblxuXHRcdC8vIGJ1ZmZlcnNcblxuXHRcdGNvbnN0IGluZGljZXMgPSBbXTtcblx0XHRjb25zdCB2ZXJ0aWNlcyA9IFtdO1xuXHRcdGNvbnN0IG5vcm1hbHMgPSBbXTtcblx0XHRjb25zdCB1dnMgPSBbXTtcblxuXHRcdC8vIGhlbHBlciB2YXJpYWJsZXNcblxuXHRcdGxldCBncm91cFN0YXJ0ID0gMDtcblx0XHRsZXQgZ3JvdXBDb3VudCA9IDA7XG5cblx0XHQvLyBhbGxvdyBzaW5nbGUgYW5kIGFycmF5IHZhbHVlcyBmb3IgXCJzaGFwZXNcIiBwYXJhbWV0ZXJcblxuXHRcdGlmICggQXJyYXkuaXNBcnJheSggc2hhcGVzICkgPT09IGZhbHNlICkge1xuXG5cdFx0XHRhZGRTaGFwZSggc2hhcGVzICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBzaGFwZXMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdGFkZFNoYXBlKCBzaGFwZXNbIGkgXSApO1xuXG5cdFx0XHRcdHRoaXMuYWRkR3JvdXAoIGdyb3VwU3RhcnQsIGdyb3VwQ291bnQsIGkgKTsgLy8gZW5hYmxlcyBNdWx0aU1hdGVyaWFsIHN1cHBvcnRcblxuXHRcdFx0XHRncm91cFN0YXJ0ICs9IGdyb3VwQ291bnQ7XG5cdFx0XHRcdGdyb3VwQ291bnQgPSAwO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHQvLyBidWlsZCBnZW9tZXRyeVxuXG5cdFx0dGhpcy5zZXRJbmRleCggaW5kaWNlcyApO1xuXHRcdHRoaXMuc2V0QXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggdmVydGljZXMsIDMgKSApO1xuXHRcdHRoaXMuc2V0QXR0cmlidXRlKCAnbm9ybWFsJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIG5vcm1hbHMsIDMgKSApO1xuXHRcdHRoaXMuc2V0QXR0cmlidXRlKCAndXYnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggdXZzLCAyICkgKTtcblxuXG5cdFx0Ly8gaGVscGVyIGZ1bmN0aW9uc1xuXG5cdFx0ZnVuY3Rpb24gYWRkU2hhcGUoIHNoYXBlICkge1xuXG5cdFx0XHRjb25zdCBpbmRleE9mZnNldCA9IHZlcnRpY2VzLmxlbmd0aCAvIDM7XG5cdFx0XHRjb25zdCBwb2ludHMgPSBzaGFwZS5leHRyYWN0UG9pbnRzKCBjdXJ2ZVNlZ21lbnRzICk7XG5cblx0XHRcdGxldCBzaGFwZVZlcnRpY2VzID0gcG9pbnRzLnNoYXBlO1xuXHRcdFx0Y29uc3Qgc2hhcGVIb2xlcyA9IHBvaW50cy5ob2xlcztcblxuXHRcdFx0Ly8gY2hlY2sgZGlyZWN0aW9uIG9mIHZlcnRpY2VzXG5cblx0XHRcdGlmICggU2hhcGVVdGlscy5pc0Nsb2NrV2lzZSggc2hhcGVWZXJ0aWNlcyApID09PSBmYWxzZSApIHtcblxuXHRcdFx0XHRzaGFwZVZlcnRpY2VzID0gc2hhcGVWZXJ0aWNlcy5yZXZlcnNlKCk7XG5cblx0XHRcdH1cblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gc2hhcGVIb2xlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdGNvbnN0IHNoYXBlSG9sZSA9IHNoYXBlSG9sZXNbIGkgXTtcblxuXHRcdFx0XHRpZiAoIFNoYXBlVXRpbHMuaXNDbG9ja1dpc2UoIHNoYXBlSG9sZSApID09PSB0cnVlICkge1xuXG5cdFx0XHRcdFx0c2hhcGVIb2xlc1sgaSBdID0gc2hhcGVIb2xlLnJldmVyc2UoKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgZmFjZXMgPSBTaGFwZVV0aWxzLnRyaWFuZ3VsYXRlU2hhcGUoIHNoYXBlVmVydGljZXMsIHNoYXBlSG9sZXMgKTtcblxuXHRcdFx0Ly8gam9pbiB2ZXJ0aWNlcyBvZiBpbm5lciBhbmQgb3V0ZXIgcGF0aHMgdG8gYSBzaW5nbGUgYXJyYXlcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gc2hhcGVIb2xlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdGNvbnN0IHNoYXBlSG9sZSA9IHNoYXBlSG9sZXNbIGkgXTtcblx0XHRcdFx0c2hhcGVWZXJ0aWNlcyA9IHNoYXBlVmVydGljZXMuY29uY2F0KCBzaGFwZUhvbGUgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyB2ZXJ0aWNlcywgbm9ybWFscywgdXZzXG5cblx0XHRcdGZvciAoIGxldCBpID0gMCwgbCA9IHNoYXBlVmVydGljZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRjb25zdCB2ZXJ0ZXggPSBzaGFwZVZlcnRpY2VzWyBpIF07XG5cblx0XHRcdFx0dmVydGljZXMucHVzaCggdmVydGV4LngsIHZlcnRleC55LCAwICk7XG5cdFx0XHRcdG5vcm1hbHMucHVzaCggMCwgMCwgMSApO1xuXHRcdFx0XHR1dnMucHVzaCggdmVydGV4LngsIHZlcnRleC55ICk7IC8vIHdvcmxkIHV2c1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIGluZGljZXNcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gZmFjZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRjb25zdCBmYWNlID0gZmFjZXNbIGkgXTtcblxuXHRcdFx0XHRjb25zdCBhID0gZmFjZVsgMCBdICsgaW5kZXhPZmZzZXQ7XG5cdFx0XHRcdGNvbnN0IGIgPSBmYWNlWyAxIF0gKyBpbmRleE9mZnNldDtcblx0XHRcdFx0Y29uc3QgYyA9IGZhY2VbIDIgXSArIGluZGV4T2Zmc2V0O1xuXG5cdFx0XHRcdGluZGljZXMucHVzaCggYSwgYiwgYyApO1xuXHRcdFx0XHRncm91cENvdW50ICs9IDM7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9XG5cblx0Y29weSggc291cmNlICkge1xuXG5cdFx0c3VwZXIuY29weSggc291cmNlICk7XG5cblx0XHR0aGlzLnBhcmFtZXRlcnMgPSBPYmplY3QuYXNzaWduKCB7fSwgc291cmNlLnBhcmFtZXRlcnMgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHR0b0pTT04oKSB7XG5cblx0XHRjb25zdCBkYXRhID0gc3VwZXIudG9KU09OKCk7XG5cblx0XHRjb25zdCBzaGFwZXMgPSB0aGlzLnBhcmFtZXRlcnMuc2hhcGVzO1xuXG5cdFx0cmV0dXJuIHRvSlNPTiggc2hhcGVzLCBkYXRhICk7XG5cblx0fVxuXG5cdHN0YXRpYyBmcm9tSlNPTiggZGF0YSwgc2hhcGVzICkge1xuXG5cdFx0Y29uc3QgZ2VvbWV0cnlTaGFwZXMgPSBbXTtcblxuXHRcdGZvciAoIGxldCBqID0gMCwgamwgPSBkYXRhLnNoYXBlcy5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcblxuXHRcdFx0Y29uc3Qgc2hhcGUgPSBzaGFwZXNbIGRhdGEuc2hhcGVzWyBqIF0gXTtcblxuXHRcdFx0Z2VvbWV0cnlTaGFwZXMucHVzaCggc2hhcGUgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBuZXcgU2hhcGVHZW9tZXRyeSggZ2VvbWV0cnlTaGFwZXMsIGRhdGEuY3VydmVTZWdtZW50cyApO1xuXG5cdH1cblxufVxuXG5mdW5jdGlvbiB0b0pTT04oIHNoYXBlcywgZGF0YSApIHtcblxuXHRkYXRhLnNoYXBlcyA9IFtdO1xuXG5cdGlmICggQXJyYXkuaXNBcnJheSggc2hhcGVzICkgKSB7XG5cblx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBzaGFwZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0Y29uc3Qgc2hhcGUgPSBzaGFwZXNbIGkgXTtcblxuXHRcdFx0ZGF0YS5zaGFwZXMucHVzaCggc2hhcGUudXVpZCApO1xuXG5cdFx0fVxuXG5cdH0gZWxzZSB7XG5cblx0XHRkYXRhLnNoYXBlcy5wdXNoKCBzaGFwZXMudXVpZCApO1xuXG5cdH1cblxuXHRyZXR1cm4gZGF0YTtcblxufVxuXG5leHBvcnQgeyBTaGFwZUdlb21ldHJ5IH07XG4iLCJpbXBvcnQgeyBCdWZmZXJHZW9tZXRyeSB9IGZyb20gJy4uL2NvcmUvQnVmZmVyR2VvbWV0cnkuanMnO1xuaW1wb3J0IHsgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSB9IGZyb20gJy4uL2NvcmUvQnVmZmVyQXR0cmlidXRlLmpzJztcbmltcG9ydCB7IFZlY3RvcjMgfSBmcm9tICcuLi9tYXRoL1ZlY3RvcjMuanMnO1xuXG5jbGFzcyBTcGhlcmVHZW9tZXRyeSBleHRlbmRzIEJ1ZmZlckdlb21ldHJ5IHtcblxuXHRjb25zdHJ1Y3RvciggcmFkaXVzID0gMSwgd2lkdGhTZWdtZW50cyA9IDMyLCBoZWlnaHRTZWdtZW50cyA9IDE2LCBwaGlTdGFydCA9IDAsIHBoaUxlbmd0aCA9IE1hdGguUEkgKiAyLCB0aGV0YVN0YXJ0ID0gMCwgdGhldGFMZW5ndGggPSBNYXRoLlBJICkge1xuXG5cdFx0c3VwZXIoKTtcblxuXHRcdHRoaXMudHlwZSA9ICdTcGhlcmVHZW9tZXRyeSc7XG5cblx0XHR0aGlzLnBhcmFtZXRlcnMgPSB7XG5cdFx0XHRyYWRpdXM6IHJhZGl1cyxcblx0XHRcdHdpZHRoU2VnbWVudHM6IHdpZHRoU2VnbWVudHMsXG5cdFx0XHRoZWlnaHRTZWdtZW50czogaGVpZ2h0U2VnbWVudHMsXG5cdFx0XHRwaGlTdGFydDogcGhpU3RhcnQsXG5cdFx0XHRwaGlMZW5ndGg6IHBoaUxlbmd0aCxcblx0XHRcdHRoZXRhU3RhcnQ6IHRoZXRhU3RhcnQsXG5cdFx0XHR0aGV0YUxlbmd0aDogdGhldGFMZW5ndGhcblx0XHR9O1xuXG5cdFx0d2lkdGhTZWdtZW50cyA9IE1hdGgubWF4KCAzLCBNYXRoLmZsb29yKCB3aWR0aFNlZ21lbnRzICkgKTtcblx0XHRoZWlnaHRTZWdtZW50cyA9IE1hdGgubWF4KCAyLCBNYXRoLmZsb29yKCBoZWlnaHRTZWdtZW50cyApICk7XG5cblx0XHRjb25zdCB0aGV0YUVuZCA9IE1hdGgubWluKCB0aGV0YVN0YXJ0ICsgdGhldGFMZW5ndGgsIE1hdGguUEkgKTtcblxuXHRcdGxldCBpbmRleCA9IDA7XG5cdFx0Y29uc3QgZ3JpZCA9IFtdO1xuXG5cdFx0Y29uc3QgdmVydGV4ID0gbmV3IFZlY3RvcjMoKTtcblx0XHRjb25zdCBub3JtYWwgPSBuZXcgVmVjdG9yMygpO1xuXG5cdFx0Ly8gYnVmZmVyc1xuXG5cdFx0Y29uc3QgaW5kaWNlcyA9IFtdO1xuXHRcdGNvbnN0IHZlcnRpY2VzID0gW107XG5cdFx0Y29uc3Qgbm9ybWFscyA9IFtdO1xuXHRcdGNvbnN0IHV2cyA9IFtdO1xuXG5cdFx0Ly8gZ2VuZXJhdGUgdmVydGljZXMsIG5vcm1hbHMgYW5kIHV2c1xuXG5cdFx0Zm9yICggbGV0IGl5ID0gMDsgaXkgPD0gaGVpZ2h0U2VnbWVudHM7IGl5ICsrICkge1xuXG5cdFx0XHRjb25zdCB2ZXJ0aWNlc1JvdyA9IFtdO1xuXG5cdFx0XHRjb25zdCB2ID0gaXkgLyBoZWlnaHRTZWdtZW50cztcblxuXHRcdFx0Ly8gc3BlY2lhbCBjYXNlIGZvciB0aGUgcG9sZXNcblxuXHRcdFx0bGV0IHVPZmZzZXQgPSAwO1xuXG5cdFx0XHRpZiAoIGl5ID09PSAwICYmIHRoZXRhU3RhcnQgPT09IDAgKSB7XG5cblx0XHRcdFx0dU9mZnNldCA9IDAuNSAvIHdpZHRoU2VnbWVudHM7XG5cblx0XHRcdH0gZWxzZSBpZiAoIGl5ID09PSBoZWlnaHRTZWdtZW50cyAmJiB0aGV0YUVuZCA9PT0gTWF0aC5QSSApIHtcblxuXHRcdFx0XHR1T2Zmc2V0ID0gLSAwLjUgLyB3aWR0aFNlZ21lbnRzO1xuXG5cdFx0XHR9XG5cblx0XHRcdGZvciAoIGxldCBpeCA9IDA7IGl4IDw9IHdpZHRoU2VnbWVudHM7IGl4ICsrICkge1xuXG5cdFx0XHRcdGNvbnN0IHUgPSBpeCAvIHdpZHRoU2VnbWVudHM7XG5cblx0XHRcdFx0Ly8gdmVydGV4XG5cblx0XHRcdFx0dmVydGV4LnggPSAtIHJhZGl1cyAqIE1hdGguY29zKCBwaGlTdGFydCArIHUgKiBwaGlMZW5ndGggKSAqIE1hdGguc2luKCB0aGV0YVN0YXJ0ICsgdiAqIHRoZXRhTGVuZ3RoICk7XG5cdFx0XHRcdHZlcnRleC55ID0gcmFkaXVzICogTWF0aC5jb3MoIHRoZXRhU3RhcnQgKyB2ICogdGhldGFMZW5ndGggKTtcblx0XHRcdFx0dmVydGV4LnogPSByYWRpdXMgKiBNYXRoLnNpbiggcGhpU3RhcnQgKyB1ICogcGhpTGVuZ3RoICkgKiBNYXRoLnNpbiggdGhldGFTdGFydCArIHYgKiB0aGV0YUxlbmd0aCApO1xuXG5cdFx0XHRcdHZlcnRpY2VzLnB1c2goIHZlcnRleC54LCB2ZXJ0ZXgueSwgdmVydGV4LnogKTtcblxuXHRcdFx0XHQvLyBub3JtYWxcblxuXHRcdFx0XHRub3JtYWwuY29weSggdmVydGV4ICkubm9ybWFsaXplKCk7XG5cdFx0XHRcdG5vcm1hbHMucHVzaCggbm9ybWFsLngsIG5vcm1hbC55LCBub3JtYWwueiApO1xuXG5cdFx0XHRcdC8vIHV2XG5cblx0XHRcdFx0dXZzLnB1c2goIHUgKyB1T2Zmc2V0LCAxIC0gdiApO1xuXG5cdFx0XHRcdHZlcnRpY2VzUm93LnB1c2goIGluZGV4ICsrICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Z3JpZC5wdXNoKCB2ZXJ0aWNlc1JvdyApO1xuXG5cdFx0fVxuXG5cdFx0Ly8gaW5kaWNlc1xuXG5cdFx0Zm9yICggbGV0IGl5ID0gMDsgaXkgPCBoZWlnaHRTZWdtZW50czsgaXkgKysgKSB7XG5cblx0XHRcdGZvciAoIGxldCBpeCA9IDA7IGl4IDwgd2lkdGhTZWdtZW50czsgaXggKysgKSB7XG5cblx0XHRcdFx0Y29uc3QgYSA9IGdyaWRbIGl5IF1bIGl4ICsgMSBdO1xuXHRcdFx0XHRjb25zdCBiID0gZ3JpZFsgaXkgXVsgaXggXTtcblx0XHRcdFx0Y29uc3QgYyA9IGdyaWRbIGl5ICsgMSBdWyBpeCBdO1xuXHRcdFx0XHRjb25zdCBkID0gZ3JpZFsgaXkgKyAxIF1bIGl4ICsgMSBdO1xuXG5cdFx0XHRcdGlmICggaXkgIT09IDAgfHwgdGhldGFTdGFydCA+IDAgKSBpbmRpY2VzLnB1c2goIGEsIGIsIGQgKTtcblx0XHRcdFx0aWYgKCBpeSAhPT0gaGVpZ2h0U2VnbWVudHMgLSAxIHx8IHRoZXRhRW5kIDwgTWF0aC5QSSApIGluZGljZXMucHVzaCggYiwgYywgZCApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHQvLyBidWlsZCBnZW9tZXRyeVxuXG5cdFx0dGhpcy5zZXRJbmRleCggaW5kaWNlcyApO1xuXHRcdHRoaXMuc2V0QXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggdmVydGljZXMsIDMgKSApO1xuXHRcdHRoaXMuc2V0QXR0cmlidXRlKCAnbm9ybWFsJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIG5vcm1hbHMsIDMgKSApO1xuXHRcdHRoaXMuc2V0QXR0cmlidXRlKCAndXYnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggdXZzLCAyICkgKTtcblxuXHR9XG5cblx0Y29weSggc291cmNlICkge1xuXG5cdFx0c3VwZXIuY29weSggc291cmNlICk7XG5cblx0XHR0aGlzLnBhcmFtZXRlcnMgPSBPYmplY3QuYXNzaWduKCB7fSwgc291cmNlLnBhcmFtZXRlcnMgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzdGF0aWMgZnJvbUpTT04oIGRhdGEgKSB7XG5cblx0XHRyZXR1cm4gbmV3IFNwaGVyZUdlb21ldHJ5KCBkYXRhLnJhZGl1cywgZGF0YS53aWR0aFNlZ21lbnRzLCBkYXRhLmhlaWdodFNlZ21lbnRzLCBkYXRhLnBoaVN0YXJ0LCBkYXRhLnBoaUxlbmd0aCwgZGF0YS50aGV0YVN0YXJ0LCBkYXRhLnRoZXRhTGVuZ3RoICk7XG5cblx0fVxuXG59XG5cbmV4cG9ydCB7IFNwaGVyZUdlb21ldHJ5IH07XG4iLCJpbXBvcnQgeyBQb2x5aGVkcm9uR2VvbWV0cnkgfSBmcm9tICcuL1BvbHloZWRyb25HZW9tZXRyeS5qcyc7XG5cbmNsYXNzIFRldHJhaGVkcm9uR2VvbWV0cnkgZXh0ZW5kcyBQb2x5aGVkcm9uR2VvbWV0cnkge1xuXG5cdGNvbnN0cnVjdG9yKCByYWRpdXMgPSAxLCBkZXRhaWwgPSAwICkge1xuXG5cdFx0Y29uc3QgdmVydGljZXMgPSBbXG5cdFx0XHQxLCAxLCAxLCBcdC0gMSwgLSAxLCAxLCBcdC0gMSwgMSwgLSAxLCBcdDEsIC0gMSwgLSAxXG5cdFx0XTtcblxuXHRcdGNvbnN0IGluZGljZXMgPSBbXG5cdFx0XHQyLCAxLCAwLCBcdDAsIDMsIDIsXHQxLCAzLCAwLFx0MiwgMywgMVxuXHRcdF07XG5cblx0XHRzdXBlciggdmVydGljZXMsIGluZGljZXMsIHJhZGl1cywgZGV0YWlsICk7XG5cblx0XHR0aGlzLnR5cGUgPSAnVGV0cmFoZWRyb25HZW9tZXRyeSc7XG5cblx0XHR0aGlzLnBhcmFtZXRlcnMgPSB7XG5cdFx0XHRyYWRpdXM6IHJhZGl1cyxcblx0XHRcdGRldGFpbDogZGV0YWlsXG5cdFx0fTtcblxuXHR9XG5cblx0c3RhdGljIGZyb21KU09OKCBkYXRhICkge1xuXG5cdFx0cmV0dXJuIG5ldyBUZXRyYWhlZHJvbkdlb21ldHJ5KCBkYXRhLnJhZGl1cywgZGF0YS5kZXRhaWwgKTtcblxuXHR9XG5cbn1cblxuZXhwb3J0IHsgVGV0cmFoZWRyb25HZW9tZXRyeSB9O1xuIiwiaW1wb3J0IHsgQnVmZmVyR2VvbWV0cnkgfSBmcm9tICcuLi9jb3JlL0J1ZmZlckdlb21ldHJ5LmpzJztcbmltcG9ydCB7IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUgfSBmcm9tICcuLi9jb3JlL0J1ZmZlckF0dHJpYnV0ZS5qcyc7XG5pbXBvcnQgeyBWZWN0b3IzIH0gZnJvbSAnLi4vbWF0aC9WZWN0b3IzLmpzJztcblxuY2xhc3MgVG9ydXNHZW9tZXRyeSBleHRlbmRzIEJ1ZmZlckdlb21ldHJ5IHtcblxuXHRjb25zdHJ1Y3RvciggcmFkaXVzID0gMSwgdHViZSA9IDAuNCwgcmFkaWFsU2VnbWVudHMgPSAxMiwgdHVidWxhclNlZ21lbnRzID0gNDgsIGFyYyA9IE1hdGguUEkgKiAyICkge1xuXG5cdFx0c3VwZXIoKTtcblxuXHRcdHRoaXMudHlwZSA9ICdUb3J1c0dlb21ldHJ5JztcblxuXHRcdHRoaXMucGFyYW1ldGVycyA9IHtcblx0XHRcdHJhZGl1czogcmFkaXVzLFxuXHRcdFx0dHViZTogdHViZSxcblx0XHRcdHJhZGlhbFNlZ21lbnRzOiByYWRpYWxTZWdtZW50cyxcblx0XHRcdHR1YnVsYXJTZWdtZW50czogdHVidWxhclNlZ21lbnRzLFxuXHRcdFx0YXJjOiBhcmNcblx0XHR9O1xuXG5cdFx0cmFkaWFsU2VnbWVudHMgPSBNYXRoLmZsb29yKCByYWRpYWxTZWdtZW50cyApO1xuXHRcdHR1YnVsYXJTZWdtZW50cyA9IE1hdGguZmxvb3IoIHR1YnVsYXJTZWdtZW50cyApO1xuXG5cdFx0Ly8gYnVmZmVyc1xuXG5cdFx0Y29uc3QgaW5kaWNlcyA9IFtdO1xuXHRcdGNvbnN0IHZlcnRpY2VzID0gW107XG5cdFx0Y29uc3Qgbm9ybWFscyA9IFtdO1xuXHRcdGNvbnN0IHV2cyA9IFtdO1xuXG5cdFx0Ly8gaGVscGVyIHZhcmlhYmxlc1xuXG5cdFx0Y29uc3QgY2VudGVyID0gbmV3IFZlY3RvcjMoKTtcblx0XHRjb25zdCB2ZXJ0ZXggPSBuZXcgVmVjdG9yMygpO1xuXHRcdGNvbnN0IG5vcm1hbCA9IG5ldyBWZWN0b3IzKCk7XG5cblx0XHQvLyBnZW5lcmF0ZSB2ZXJ0aWNlcywgbm9ybWFscyBhbmQgdXZzXG5cblx0XHRmb3IgKCBsZXQgaiA9IDA7IGogPD0gcmFkaWFsU2VnbWVudHM7IGogKysgKSB7XG5cblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8PSB0dWJ1bGFyU2VnbWVudHM7IGkgKysgKSB7XG5cblx0XHRcdFx0Y29uc3QgdSA9IGkgLyB0dWJ1bGFyU2VnbWVudHMgKiBhcmM7XG5cdFx0XHRcdGNvbnN0IHYgPSBqIC8gcmFkaWFsU2VnbWVudHMgKiBNYXRoLlBJICogMjtcblxuXHRcdFx0XHQvLyB2ZXJ0ZXhcblxuXHRcdFx0XHR2ZXJ0ZXgueCA9ICggcmFkaXVzICsgdHViZSAqIE1hdGguY29zKCB2ICkgKSAqIE1hdGguY29zKCB1ICk7XG5cdFx0XHRcdHZlcnRleC55ID0gKCByYWRpdXMgKyB0dWJlICogTWF0aC5jb3MoIHYgKSApICogTWF0aC5zaW4oIHUgKTtcblx0XHRcdFx0dmVydGV4LnogPSB0dWJlICogTWF0aC5zaW4oIHYgKTtcblxuXHRcdFx0XHR2ZXJ0aWNlcy5wdXNoKCB2ZXJ0ZXgueCwgdmVydGV4LnksIHZlcnRleC56ICk7XG5cblx0XHRcdFx0Ly8gbm9ybWFsXG5cblx0XHRcdFx0Y2VudGVyLnggPSByYWRpdXMgKiBNYXRoLmNvcyggdSApO1xuXHRcdFx0XHRjZW50ZXIueSA9IHJhZGl1cyAqIE1hdGguc2luKCB1ICk7XG5cdFx0XHRcdG5vcm1hbC5zdWJWZWN0b3JzKCB2ZXJ0ZXgsIGNlbnRlciApLm5vcm1hbGl6ZSgpO1xuXG5cdFx0XHRcdG5vcm1hbHMucHVzaCggbm9ybWFsLngsIG5vcm1hbC55LCBub3JtYWwueiApO1xuXG5cdFx0XHRcdC8vIHV2XG5cblx0XHRcdFx0dXZzLnB1c2goIGkgLyB0dWJ1bGFyU2VnbWVudHMgKTtcblx0XHRcdFx0dXZzLnB1c2goIGogLyByYWRpYWxTZWdtZW50cyApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHQvLyBnZW5lcmF0ZSBpbmRpY2VzXG5cblx0XHRmb3IgKCBsZXQgaiA9IDE7IGogPD0gcmFkaWFsU2VnbWVudHM7IGogKysgKSB7XG5cblx0XHRcdGZvciAoIGxldCBpID0gMTsgaSA8PSB0dWJ1bGFyU2VnbWVudHM7IGkgKysgKSB7XG5cblx0XHRcdFx0Ly8gaW5kaWNlc1xuXG5cdFx0XHRcdGNvbnN0IGEgPSAoIHR1YnVsYXJTZWdtZW50cyArIDEgKSAqIGogKyBpIC0gMTtcblx0XHRcdFx0Y29uc3QgYiA9ICggdHVidWxhclNlZ21lbnRzICsgMSApICogKCBqIC0gMSApICsgaSAtIDE7XG5cdFx0XHRcdGNvbnN0IGMgPSAoIHR1YnVsYXJTZWdtZW50cyArIDEgKSAqICggaiAtIDEgKSArIGk7XG5cdFx0XHRcdGNvbnN0IGQgPSAoIHR1YnVsYXJTZWdtZW50cyArIDEgKSAqIGogKyBpO1xuXG5cdFx0XHRcdC8vIGZhY2VzXG5cblx0XHRcdFx0aW5kaWNlcy5wdXNoKCBhLCBiLCBkICk7XG5cdFx0XHRcdGluZGljZXMucHVzaCggYiwgYywgZCApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHQvLyBidWlsZCBnZW9tZXRyeVxuXG5cdFx0dGhpcy5zZXRJbmRleCggaW5kaWNlcyApO1xuXHRcdHRoaXMuc2V0QXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggdmVydGljZXMsIDMgKSApO1xuXHRcdHRoaXMuc2V0QXR0cmlidXRlKCAnbm9ybWFsJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIG5vcm1hbHMsIDMgKSApO1xuXHRcdHRoaXMuc2V0QXR0cmlidXRlKCAndXYnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggdXZzLCAyICkgKTtcblxuXHR9XG5cblx0Y29weSggc291cmNlICkge1xuXG5cdFx0c3VwZXIuY29weSggc291cmNlICk7XG5cblx0XHR0aGlzLnBhcmFtZXRlcnMgPSBPYmplY3QuYXNzaWduKCB7fSwgc291cmNlLnBhcmFtZXRlcnMgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzdGF0aWMgZnJvbUpTT04oIGRhdGEgKSB7XG5cblx0XHRyZXR1cm4gbmV3IFRvcnVzR2VvbWV0cnkoIGRhdGEucmFkaXVzLCBkYXRhLnR1YmUsIGRhdGEucmFkaWFsU2VnbWVudHMsIGRhdGEudHVidWxhclNlZ21lbnRzLCBkYXRhLmFyYyApO1xuXG5cdH1cblxufVxuXG5leHBvcnQgeyBUb3J1c0dlb21ldHJ5IH07XG4iLCJpbXBvcnQgeyBCdWZmZXJHZW9tZXRyeSB9IGZyb20gJy4uL2NvcmUvQnVmZmVyR2VvbWV0cnkuanMnO1xuaW1wb3J0IHsgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSB9IGZyb20gJy4uL2NvcmUvQnVmZmVyQXR0cmlidXRlLmpzJztcbmltcG9ydCB7IFZlY3RvcjMgfSBmcm9tICcuLi9tYXRoL1ZlY3RvcjMuanMnO1xuXG5jbGFzcyBUb3J1c0tub3RHZW9tZXRyeSBleHRlbmRzIEJ1ZmZlckdlb21ldHJ5IHtcblxuXHRjb25zdHJ1Y3RvciggcmFkaXVzID0gMSwgdHViZSA9IDAuNCwgdHVidWxhclNlZ21lbnRzID0gNjQsIHJhZGlhbFNlZ21lbnRzID0gOCwgcCA9IDIsIHEgPSAzICkge1xuXG5cdFx0c3VwZXIoKTtcblxuXHRcdHRoaXMudHlwZSA9ICdUb3J1c0tub3RHZW9tZXRyeSc7XG5cblx0XHR0aGlzLnBhcmFtZXRlcnMgPSB7XG5cdFx0XHRyYWRpdXM6IHJhZGl1cyxcblx0XHRcdHR1YmU6IHR1YmUsXG5cdFx0XHR0dWJ1bGFyU2VnbWVudHM6IHR1YnVsYXJTZWdtZW50cyxcblx0XHRcdHJhZGlhbFNlZ21lbnRzOiByYWRpYWxTZWdtZW50cyxcblx0XHRcdHA6IHAsXG5cdFx0XHRxOiBxXG5cdFx0fTtcblxuXHRcdHR1YnVsYXJTZWdtZW50cyA9IE1hdGguZmxvb3IoIHR1YnVsYXJTZWdtZW50cyApO1xuXHRcdHJhZGlhbFNlZ21lbnRzID0gTWF0aC5mbG9vciggcmFkaWFsU2VnbWVudHMgKTtcblxuXHRcdC8vIGJ1ZmZlcnNcblxuXHRcdGNvbnN0IGluZGljZXMgPSBbXTtcblx0XHRjb25zdCB2ZXJ0aWNlcyA9IFtdO1xuXHRcdGNvbnN0IG5vcm1hbHMgPSBbXTtcblx0XHRjb25zdCB1dnMgPSBbXTtcblxuXHRcdC8vIGhlbHBlciB2YXJpYWJsZXNcblxuXHRcdGNvbnN0IHZlcnRleCA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0Y29uc3Qgbm9ybWFsID0gbmV3IFZlY3RvcjMoKTtcblxuXHRcdGNvbnN0IFAxID0gbmV3IFZlY3RvcjMoKTtcblx0XHRjb25zdCBQMiA9IG5ldyBWZWN0b3IzKCk7XG5cblx0XHRjb25zdCBCID0gbmV3IFZlY3RvcjMoKTtcblx0XHRjb25zdCBUID0gbmV3IFZlY3RvcjMoKTtcblx0XHRjb25zdCBOID0gbmV3IFZlY3RvcjMoKTtcblxuXHRcdC8vIGdlbmVyYXRlIHZlcnRpY2VzLCBub3JtYWxzIGFuZCB1dnNcblxuXHRcdGZvciAoIGxldCBpID0gMDsgaSA8PSB0dWJ1bGFyU2VnbWVudHM7ICsrIGkgKSB7XG5cblx0XHRcdC8vIHRoZSByYWRpYW4gXCJ1XCIgaXMgdXNlZCB0byBjYWxjdWxhdGUgdGhlIHBvc2l0aW9uIG9uIHRoZSB0b3J1cyBjdXJ2ZSBvZiB0aGUgY3VycmVudCB0dWJ1bGFyIHNlZ21lbnRcblxuXHRcdFx0Y29uc3QgdSA9IGkgLyB0dWJ1bGFyU2VnbWVudHMgKiBwICogTWF0aC5QSSAqIDI7XG5cblx0XHRcdC8vIG5vdyB3ZSBjYWxjdWxhdGUgdHdvIHBvaW50cy4gUDEgaXMgb3VyIGN1cnJlbnQgcG9zaXRpb24gb24gdGhlIGN1cnZlLCBQMiBpcyBhIGxpdHRsZSBmYXJ0aGVyIGFoZWFkLlxuXHRcdFx0Ly8gdGhlc2UgcG9pbnRzIGFyZSB1c2VkIHRvIGNyZWF0ZSBhIHNwZWNpYWwgXCJjb29yZGluYXRlIHNwYWNlXCIsIHdoaWNoIGlzIG5lY2Vzc2FyeSB0byBjYWxjdWxhdGUgdGhlIGNvcnJlY3QgdmVydGV4IHBvc2l0aW9uc1xuXG5cdFx0XHRjYWxjdWxhdGVQb3NpdGlvbk9uQ3VydmUoIHUsIHAsIHEsIHJhZGl1cywgUDEgKTtcblx0XHRcdGNhbGN1bGF0ZVBvc2l0aW9uT25DdXJ2ZSggdSArIDAuMDEsIHAsIHEsIHJhZGl1cywgUDIgKTtcblxuXHRcdFx0Ly8gY2FsY3VsYXRlIG9ydGhvbm9ybWFsIGJhc2lzXG5cblx0XHRcdFQuc3ViVmVjdG9ycyggUDIsIFAxICk7XG5cdFx0XHROLmFkZFZlY3RvcnMoIFAyLCBQMSApO1xuXHRcdFx0Qi5jcm9zc1ZlY3RvcnMoIFQsIE4gKTtcblx0XHRcdE4uY3Jvc3NWZWN0b3JzKCBCLCBUICk7XG5cblx0XHRcdC8vIG5vcm1hbGl6ZSBCLCBOLiBUIGNhbiBiZSBpZ25vcmVkLCB3ZSBkb24ndCB1c2UgaXRcblxuXHRcdFx0Qi5ub3JtYWxpemUoKTtcblx0XHRcdE4ubm9ybWFsaXplKCk7XG5cblx0XHRcdGZvciAoIGxldCBqID0gMDsgaiA8PSByYWRpYWxTZWdtZW50czsgKysgaiApIHtcblxuXHRcdFx0XHQvLyBub3cgY2FsY3VsYXRlIHRoZSB2ZXJ0aWNlcy4gdGhleSBhcmUgbm90aGluZyBtb3JlIHRoYW4gYW4gZXh0cnVzaW9uIG9mIHRoZSB0b3J1cyBjdXJ2ZS5cblx0XHRcdFx0Ly8gYmVjYXVzZSB3ZSBleHRydWRlIGEgc2hhcGUgaW4gdGhlIHh5LXBsYW5lLCB0aGVyZSBpcyBubyBuZWVkIHRvIGNhbGN1bGF0ZSBhIHotdmFsdWUuXG5cblx0XHRcdFx0Y29uc3QgdiA9IGogLyByYWRpYWxTZWdtZW50cyAqIE1hdGguUEkgKiAyO1xuXHRcdFx0XHRjb25zdCBjeCA9IC0gdHViZSAqIE1hdGguY29zKCB2ICk7XG5cdFx0XHRcdGNvbnN0IGN5ID0gdHViZSAqIE1hdGguc2luKCB2ICk7XG5cblx0XHRcdFx0Ly8gbm93IGNhbGN1bGF0ZSB0aGUgZmluYWwgdmVydGV4IHBvc2l0aW9uLlxuXHRcdFx0XHQvLyBmaXJzdCB3ZSBvcmllbnQgdGhlIGV4dHJ1c2lvbiB3aXRoIG91ciBiYXNpcyB2ZWN0b3JzLCB0aGVuIHdlIGFkZCBpdCB0byB0aGUgY3VycmVudCBwb3NpdGlvbiBvbiB0aGUgY3VydmVcblxuXHRcdFx0XHR2ZXJ0ZXgueCA9IFAxLnggKyAoIGN4ICogTi54ICsgY3kgKiBCLnggKTtcblx0XHRcdFx0dmVydGV4LnkgPSBQMS55ICsgKCBjeCAqIE4ueSArIGN5ICogQi55ICk7XG5cdFx0XHRcdHZlcnRleC56ID0gUDEueiArICggY3ggKiBOLnogKyBjeSAqIEIueiApO1xuXG5cdFx0XHRcdHZlcnRpY2VzLnB1c2goIHZlcnRleC54LCB2ZXJ0ZXgueSwgdmVydGV4LnogKTtcblxuXHRcdFx0XHQvLyBub3JtYWwgKFAxIGlzIGFsd2F5cyB0aGUgY2VudGVyL29yaWdpbiBvZiB0aGUgZXh0cnVzaW9uLCB0aHVzIHdlIGNhbiB1c2UgaXQgdG8gY2FsY3VsYXRlIHRoZSBub3JtYWwpXG5cblx0XHRcdFx0bm9ybWFsLnN1YlZlY3RvcnMoIHZlcnRleCwgUDEgKS5ub3JtYWxpemUoKTtcblxuXHRcdFx0XHRub3JtYWxzLnB1c2goIG5vcm1hbC54LCBub3JtYWwueSwgbm9ybWFsLnogKTtcblxuXHRcdFx0XHQvLyB1dlxuXG5cdFx0XHRcdHV2cy5wdXNoKCBpIC8gdHVidWxhclNlZ21lbnRzICk7XG5cdFx0XHRcdHV2cy5wdXNoKCBqIC8gcmFkaWFsU2VnbWVudHMgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Ly8gZ2VuZXJhdGUgaW5kaWNlc1xuXG5cdFx0Zm9yICggbGV0IGogPSAxOyBqIDw9IHR1YnVsYXJTZWdtZW50czsgaiArKyApIHtcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAxOyBpIDw9IHJhZGlhbFNlZ21lbnRzOyBpICsrICkge1xuXG5cdFx0XHRcdC8vIGluZGljZXNcblxuXHRcdFx0XHRjb25zdCBhID0gKCByYWRpYWxTZWdtZW50cyArIDEgKSAqICggaiAtIDEgKSArICggaSAtIDEgKTtcblx0XHRcdFx0Y29uc3QgYiA9ICggcmFkaWFsU2VnbWVudHMgKyAxICkgKiBqICsgKCBpIC0gMSApO1xuXHRcdFx0XHRjb25zdCBjID0gKCByYWRpYWxTZWdtZW50cyArIDEgKSAqIGogKyBpO1xuXHRcdFx0XHRjb25zdCBkID0gKCByYWRpYWxTZWdtZW50cyArIDEgKSAqICggaiAtIDEgKSArIGk7XG5cblx0XHRcdFx0Ly8gZmFjZXNcblxuXHRcdFx0XHRpbmRpY2VzLnB1c2goIGEsIGIsIGQgKTtcblx0XHRcdFx0aW5kaWNlcy5wdXNoKCBiLCBjLCBkICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdC8vIGJ1aWxkIGdlb21ldHJ5XG5cblx0XHR0aGlzLnNldEluZGV4KCBpbmRpY2VzICk7XG5cdFx0dGhpcy5zZXRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCB2ZXJ0aWNlcywgMyApICk7XG5cdFx0dGhpcy5zZXRBdHRyaWJ1dGUoICdub3JtYWwnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggbm9ybWFscywgMyApICk7XG5cdFx0dGhpcy5zZXRBdHRyaWJ1dGUoICd1dicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCB1dnMsIDIgKSApO1xuXG5cdFx0Ly8gdGhpcyBmdW5jdGlvbiBjYWxjdWxhdGVzIHRoZSBjdXJyZW50IHBvc2l0aW9uIG9uIHRoZSB0b3J1cyBjdXJ2ZVxuXG5cdFx0ZnVuY3Rpb24gY2FsY3VsYXRlUG9zaXRpb25PbkN1cnZlKCB1LCBwLCBxLCByYWRpdXMsIHBvc2l0aW9uICkge1xuXG5cdFx0XHRjb25zdCBjdSA9IE1hdGguY29zKCB1ICk7XG5cdFx0XHRjb25zdCBzdSA9IE1hdGguc2luKCB1ICk7XG5cdFx0XHRjb25zdCBxdU92ZXJQID0gcSAvIHAgKiB1O1xuXHRcdFx0Y29uc3QgY3MgPSBNYXRoLmNvcyggcXVPdmVyUCApO1xuXG5cdFx0XHRwb3NpdGlvbi54ID0gcmFkaXVzICogKCAyICsgY3MgKSAqIDAuNSAqIGN1O1xuXHRcdFx0cG9zaXRpb24ueSA9IHJhZGl1cyAqICggMiArIGNzICkgKiBzdSAqIDAuNTtcblx0XHRcdHBvc2l0aW9uLnogPSByYWRpdXMgKiBNYXRoLnNpbiggcXVPdmVyUCApICogMC41O1xuXG5cdFx0fVxuXG5cdH1cblxuXHRjb3B5KCBzb3VyY2UgKSB7XG5cblx0XHRzdXBlci5jb3B5KCBzb3VyY2UgKTtcblxuXHRcdHRoaXMucGFyYW1ldGVycyA9IE9iamVjdC5hc3NpZ24oIHt9LCBzb3VyY2UucGFyYW1ldGVycyApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHN0YXRpYyBmcm9tSlNPTiggZGF0YSApIHtcblxuXHRcdHJldHVybiBuZXcgVG9ydXNLbm90R2VvbWV0cnkoIGRhdGEucmFkaXVzLCBkYXRhLnR1YmUsIGRhdGEudHVidWxhclNlZ21lbnRzLCBkYXRhLnJhZGlhbFNlZ21lbnRzLCBkYXRhLnAsIGRhdGEucSApO1xuXG5cdH1cblxufVxuXG5leHBvcnQgeyBUb3J1c0tub3RHZW9tZXRyeSB9O1xuIiwiaW1wb3J0IHsgQnVmZmVyR2VvbWV0cnkgfSBmcm9tICcuLi9jb3JlL0J1ZmZlckdlb21ldHJ5LmpzJztcbmltcG9ydCB7IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUgfSBmcm9tICcuLi9jb3JlL0J1ZmZlckF0dHJpYnV0ZS5qcyc7XG5pbXBvcnQgKiBhcyBDdXJ2ZXMgZnJvbSAnLi4vZXh0cmFzL2N1cnZlcy9DdXJ2ZXMuanMnO1xuaW1wb3J0IHsgVmVjdG9yMiB9IGZyb20gJy4uL21hdGgvVmVjdG9yMi5qcyc7XG5pbXBvcnQgeyBWZWN0b3IzIH0gZnJvbSAnLi4vbWF0aC9WZWN0b3IzLmpzJztcblxuY2xhc3MgVHViZUdlb21ldHJ5IGV4dGVuZHMgQnVmZmVyR2VvbWV0cnkge1xuXG5cdGNvbnN0cnVjdG9yKCBwYXRoID0gbmV3IEN1cnZlc1sgJ1F1YWRyYXRpY0JlemllckN1cnZlMycgXSggbmV3IFZlY3RvcjMoIC0gMSwgLSAxLCAwICksIG5ldyBWZWN0b3IzKCAtIDEsIDEsIDAgKSwgbmV3IFZlY3RvcjMoIDEsIDEsIDAgKSApLCB0dWJ1bGFyU2VnbWVudHMgPSA2NCwgcmFkaXVzID0gMSwgcmFkaWFsU2VnbWVudHMgPSA4LCBjbG9zZWQgPSBmYWxzZSApIHtcblxuXHRcdHN1cGVyKCk7XG5cblx0XHR0aGlzLnR5cGUgPSAnVHViZUdlb21ldHJ5JztcblxuXHRcdHRoaXMucGFyYW1ldGVycyA9IHtcblx0XHRcdHBhdGg6IHBhdGgsXG5cdFx0XHR0dWJ1bGFyU2VnbWVudHM6IHR1YnVsYXJTZWdtZW50cyxcblx0XHRcdHJhZGl1czogcmFkaXVzLFxuXHRcdFx0cmFkaWFsU2VnbWVudHM6IHJhZGlhbFNlZ21lbnRzLFxuXHRcdFx0Y2xvc2VkOiBjbG9zZWRcblx0XHR9O1xuXG5cdFx0Y29uc3QgZnJhbWVzID0gcGF0aC5jb21wdXRlRnJlbmV0RnJhbWVzKCB0dWJ1bGFyU2VnbWVudHMsIGNsb3NlZCApO1xuXG5cdFx0Ly8gZXhwb3NlIGludGVybmFsc1xuXG5cdFx0dGhpcy50YW5nZW50cyA9IGZyYW1lcy50YW5nZW50cztcblx0XHR0aGlzLm5vcm1hbHMgPSBmcmFtZXMubm9ybWFscztcblx0XHR0aGlzLmJpbm9ybWFscyA9IGZyYW1lcy5iaW5vcm1hbHM7XG5cblx0XHQvLyBoZWxwZXIgdmFyaWFibGVzXG5cblx0XHRjb25zdCB2ZXJ0ZXggPSBuZXcgVmVjdG9yMygpO1xuXHRcdGNvbnN0IG5vcm1hbCA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0Y29uc3QgdXYgPSBuZXcgVmVjdG9yMigpO1xuXHRcdGxldCBQID0gbmV3IFZlY3RvcjMoKTtcblxuXHRcdC8vIGJ1ZmZlclxuXG5cdFx0Y29uc3QgdmVydGljZXMgPSBbXTtcblx0XHRjb25zdCBub3JtYWxzID0gW107XG5cdFx0Y29uc3QgdXZzID0gW107XG5cdFx0Y29uc3QgaW5kaWNlcyA9IFtdO1xuXG5cdFx0Ly8gY3JlYXRlIGJ1ZmZlciBkYXRhXG5cblx0XHRnZW5lcmF0ZUJ1ZmZlckRhdGEoKTtcblxuXHRcdC8vIGJ1aWxkIGdlb21ldHJ5XG5cblx0XHR0aGlzLnNldEluZGV4KCBpbmRpY2VzICk7XG5cdFx0dGhpcy5zZXRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCB2ZXJ0aWNlcywgMyApICk7XG5cdFx0dGhpcy5zZXRBdHRyaWJ1dGUoICdub3JtYWwnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggbm9ybWFscywgMyApICk7XG5cdFx0dGhpcy5zZXRBdHRyaWJ1dGUoICd1dicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCB1dnMsIDIgKSApO1xuXG5cdFx0Ly8gZnVuY3Rpb25zXG5cblx0XHRmdW5jdGlvbiBnZW5lcmF0ZUJ1ZmZlckRhdGEoKSB7XG5cblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IHR1YnVsYXJTZWdtZW50czsgaSArKyApIHtcblxuXHRcdFx0XHRnZW5lcmF0ZVNlZ21lbnQoIGkgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBpZiB0aGUgZ2VvbWV0cnkgaXMgbm90IGNsb3NlZCwgZ2VuZXJhdGUgdGhlIGxhc3Qgcm93IG9mIHZlcnRpY2VzIGFuZCBub3JtYWxzXG5cdFx0XHQvLyBhdCB0aGUgcmVndWxhciBwb3NpdGlvbiBvbiB0aGUgZ2l2ZW4gcGF0aFxuXHRcdFx0Ly9cblx0XHRcdC8vIGlmIHRoZSBnZW9tZXRyeSBpcyBjbG9zZWQsIGR1cGxpY2F0ZSB0aGUgZmlyc3Qgcm93IG9mIHZlcnRpY2VzIGFuZCBub3JtYWxzICh1dnMgd2lsbCBkaWZmZXIpXG5cblx0XHRcdGdlbmVyYXRlU2VnbWVudCggKCBjbG9zZWQgPT09IGZhbHNlICkgPyB0dWJ1bGFyU2VnbWVudHMgOiAwICk7XG5cblx0XHRcdC8vIHV2cyBhcmUgZ2VuZXJhdGVkIGluIGEgc2VwYXJhdGUgZnVuY3Rpb24uXG5cdFx0XHQvLyB0aGlzIG1ha2VzIGl0IGVhc3kgY29tcHV0ZSBjb3JyZWN0IHZhbHVlcyBmb3IgY2xvc2VkIGdlb21ldHJpZXNcblxuXHRcdFx0Z2VuZXJhdGVVVnMoKTtcblxuXHRcdFx0Ly8gZmluYWxseSBjcmVhdGUgZmFjZXNcblxuXHRcdFx0Z2VuZXJhdGVJbmRpY2VzKCk7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBnZW5lcmF0ZVNlZ21lbnQoIGkgKSB7XG5cblx0XHRcdC8vIHdlIHVzZSBnZXRQb2ludEF0IHRvIHNhbXBsZSBldmVubHkgZGlzdHJpYnV0ZWQgcG9pbnRzIGZyb20gdGhlIGdpdmVuIHBhdGhcblxuXHRcdFx0UCA9IHBhdGguZ2V0UG9pbnRBdCggaSAvIHR1YnVsYXJTZWdtZW50cywgUCApO1xuXG5cdFx0XHQvLyByZXRyaWV2ZSBjb3JyZXNwb25kaW5nIG5vcm1hbCBhbmQgYmlub3JtYWxcblxuXHRcdFx0Y29uc3QgTiA9IGZyYW1lcy5ub3JtYWxzWyBpIF07XG5cdFx0XHRjb25zdCBCID0gZnJhbWVzLmJpbm9ybWFsc1sgaSBdO1xuXG5cdFx0XHQvLyBnZW5lcmF0ZSBub3JtYWxzIGFuZCB2ZXJ0aWNlcyBmb3IgdGhlIGN1cnJlbnQgc2VnbWVudFxuXG5cdFx0XHRmb3IgKCBsZXQgaiA9IDA7IGogPD0gcmFkaWFsU2VnbWVudHM7IGogKysgKSB7XG5cblx0XHRcdFx0Y29uc3QgdiA9IGogLyByYWRpYWxTZWdtZW50cyAqIE1hdGguUEkgKiAyO1xuXG5cdFx0XHRcdGNvbnN0IHNpbiA9IE1hdGguc2luKCB2ICk7XG5cdFx0XHRcdGNvbnN0IGNvcyA9IC0gTWF0aC5jb3MoIHYgKTtcblxuXHRcdFx0XHQvLyBub3JtYWxcblxuXHRcdFx0XHRub3JtYWwueCA9ICggY29zICogTi54ICsgc2luICogQi54ICk7XG5cdFx0XHRcdG5vcm1hbC55ID0gKCBjb3MgKiBOLnkgKyBzaW4gKiBCLnkgKTtcblx0XHRcdFx0bm9ybWFsLnogPSAoIGNvcyAqIE4ueiArIHNpbiAqIEIueiApO1xuXHRcdFx0XHRub3JtYWwubm9ybWFsaXplKCk7XG5cblx0XHRcdFx0bm9ybWFscy5wdXNoKCBub3JtYWwueCwgbm9ybWFsLnksIG5vcm1hbC56ICk7XG5cblx0XHRcdFx0Ly8gdmVydGV4XG5cblx0XHRcdFx0dmVydGV4LnggPSBQLnggKyByYWRpdXMgKiBub3JtYWwueDtcblx0XHRcdFx0dmVydGV4LnkgPSBQLnkgKyByYWRpdXMgKiBub3JtYWwueTtcblx0XHRcdFx0dmVydGV4LnogPSBQLnogKyByYWRpdXMgKiBub3JtYWwuejtcblxuXHRcdFx0XHR2ZXJ0aWNlcy5wdXNoKCB2ZXJ0ZXgueCwgdmVydGV4LnksIHZlcnRleC56ICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGdlbmVyYXRlSW5kaWNlcygpIHtcblxuXHRcdFx0Zm9yICggbGV0IGogPSAxOyBqIDw9IHR1YnVsYXJTZWdtZW50czsgaiArKyApIHtcblxuXHRcdFx0XHRmb3IgKCBsZXQgaSA9IDE7IGkgPD0gcmFkaWFsU2VnbWVudHM7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRjb25zdCBhID0gKCByYWRpYWxTZWdtZW50cyArIDEgKSAqICggaiAtIDEgKSArICggaSAtIDEgKTtcblx0XHRcdFx0XHRjb25zdCBiID0gKCByYWRpYWxTZWdtZW50cyArIDEgKSAqIGogKyAoIGkgLSAxICk7XG5cdFx0XHRcdFx0Y29uc3QgYyA9ICggcmFkaWFsU2VnbWVudHMgKyAxICkgKiBqICsgaTtcblx0XHRcdFx0XHRjb25zdCBkID0gKCByYWRpYWxTZWdtZW50cyArIDEgKSAqICggaiAtIDEgKSArIGk7XG5cblx0XHRcdFx0XHQvLyBmYWNlc1xuXG5cdFx0XHRcdFx0aW5kaWNlcy5wdXNoKCBhLCBiLCBkICk7XG5cdFx0XHRcdFx0aW5kaWNlcy5wdXNoKCBiLCBjLCBkICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBnZW5lcmF0ZVVWcygpIHtcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDw9IHR1YnVsYXJTZWdtZW50czsgaSArKyApIHtcblxuXHRcdFx0XHRmb3IgKCBsZXQgaiA9IDA7IGogPD0gcmFkaWFsU2VnbWVudHM7IGogKysgKSB7XG5cblx0XHRcdFx0XHR1di54ID0gaSAvIHR1YnVsYXJTZWdtZW50cztcblx0XHRcdFx0XHR1di55ID0gaiAvIHJhZGlhbFNlZ21lbnRzO1xuXG5cdFx0XHRcdFx0dXZzLnB1c2goIHV2LngsIHV2LnkgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9XG5cblx0Y29weSggc291cmNlICkge1xuXG5cdFx0c3VwZXIuY29weSggc291cmNlICk7XG5cblx0XHR0aGlzLnBhcmFtZXRlcnMgPSBPYmplY3QuYXNzaWduKCB7fSwgc291cmNlLnBhcmFtZXRlcnMgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHR0b0pTT04oKSB7XG5cblx0XHRjb25zdCBkYXRhID0gc3VwZXIudG9KU09OKCk7XG5cblx0XHRkYXRhLnBhdGggPSB0aGlzLnBhcmFtZXRlcnMucGF0aC50b0pTT04oKTtcblxuXHRcdHJldHVybiBkYXRhO1xuXG5cdH1cblxuXHRzdGF0aWMgZnJvbUpTT04oIGRhdGEgKSB7XG5cblx0XHQvLyBUaGlzIG9ubHkgd29ya3MgZm9yIGJ1aWx0LWluIGN1cnZlcyAoZS5nLiBDYXRtdWxsUm9tQ3VydmUzKS5cblx0XHQvLyBVc2VyIGRlZmluZWQgY3VydmVzIG9yIGluc3RhbmNlcyBvZiBDdXJ2ZVBhdGggd2lsbCBub3QgYmUgZGVzZXJpYWxpemVkLlxuXHRcdHJldHVybiBuZXcgVHViZUdlb21ldHJ5KFxuXHRcdFx0bmV3IEN1cnZlc1sgZGF0YS5wYXRoLnR5cGUgXSgpLmZyb21KU09OKCBkYXRhLnBhdGggKSxcblx0XHRcdGRhdGEudHVidWxhclNlZ21lbnRzLFxuXHRcdFx0ZGF0YS5yYWRpdXMsXG5cdFx0XHRkYXRhLnJhZGlhbFNlZ21lbnRzLFxuXHRcdFx0ZGF0YS5jbG9zZWRcblx0XHQpO1xuXG5cdH1cblxufVxuXG5cbmV4cG9ydCB7IFR1YmVHZW9tZXRyeSB9O1xuIiwiaW1wb3J0IHsgQnVmZmVyR2VvbWV0cnkgfSBmcm9tICcuLi9jb3JlL0J1ZmZlckdlb21ldHJ5LmpzJztcbmltcG9ydCB7IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUgfSBmcm9tICcuLi9jb3JlL0J1ZmZlckF0dHJpYnV0ZS5qcyc7XG5pbXBvcnQgeyBWZWN0b3IzIH0gZnJvbSAnLi4vbWF0aC9WZWN0b3IzLmpzJztcblxuY2xhc3MgV2lyZWZyYW1lR2VvbWV0cnkgZXh0ZW5kcyBCdWZmZXJHZW9tZXRyeSB7XG5cblx0Y29uc3RydWN0b3IoIGdlb21ldHJ5ID0gbnVsbCApIHtcblxuXHRcdHN1cGVyKCk7XG5cblx0XHR0aGlzLnR5cGUgPSAnV2lyZWZyYW1lR2VvbWV0cnknO1xuXG5cdFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xuXHRcdFx0Z2VvbWV0cnk6IGdlb21ldHJ5XG5cdFx0fTtcblxuXHRcdGlmICggZ2VvbWV0cnkgIT09IG51bGwgKSB7XG5cblx0XHRcdC8vIGJ1ZmZlclxuXG5cdFx0XHRjb25zdCB2ZXJ0aWNlcyA9IFtdO1xuXHRcdFx0Y29uc3QgZWRnZXMgPSBuZXcgU2V0KCk7XG5cblx0XHRcdC8vIGhlbHBlciB2YXJpYWJsZXNcblxuXHRcdFx0Y29uc3Qgc3RhcnQgPSBuZXcgVmVjdG9yMygpO1xuXHRcdFx0Y29uc3QgZW5kID0gbmV3IFZlY3RvcjMoKTtcblxuXHRcdFx0aWYgKCBnZW9tZXRyeS5pbmRleCAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHQvLyBpbmRleGVkIEJ1ZmZlckdlb21ldHJ5XG5cblx0XHRcdFx0Y29uc3QgcG9zaXRpb24gPSBnZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xuXHRcdFx0XHRjb25zdCBpbmRpY2VzID0gZ2VvbWV0cnkuaW5kZXg7XG5cdFx0XHRcdGxldCBncm91cHMgPSBnZW9tZXRyeS5ncm91cHM7XG5cblx0XHRcdFx0aWYgKCBncm91cHMubGVuZ3RoID09PSAwICkge1xuXG5cdFx0XHRcdFx0Z3JvdXBzID0gWyB7IHN0YXJ0OiAwLCBjb3VudDogaW5kaWNlcy5jb3VudCwgbWF0ZXJpYWxJbmRleDogMCB9IF07XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIGNyZWF0ZSBhIGRhdGEgc3RydWN0dXJlIHRoYXQgY29udGFpbnMgYWxsIGVkZ2VzIHdpdGhvdXQgZHVwbGljYXRlc1xuXG5cdFx0XHRcdGZvciAoIGxldCBvID0gMCwgb2wgPSBncm91cHMubGVuZ3RoOyBvIDwgb2w7ICsrIG8gKSB7XG5cblx0XHRcdFx0XHRjb25zdCBncm91cCA9IGdyb3Vwc1sgbyBdO1xuXG5cdFx0XHRcdFx0Y29uc3QgZ3JvdXBTdGFydCA9IGdyb3VwLnN0YXJ0O1xuXHRcdFx0XHRcdGNvbnN0IGdyb3VwQ291bnQgPSBncm91cC5jb3VudDtcblxuXHRcdFx0XHRcdGZvciAoIGxldCBpID0gZ3JvdXBTdGFydCwgbCA9ICggZ3JvdXBTdGFydCArIGdyb3VwQ291bnQgKTsgaSA8IGw7IGkgKz0gMyApIHtcblxuXHRcdFx0XHRcdFx0Zm9yICggbGV0IGogPSAwOyBqIDwgMzsgaiArKyApIHtcblxuXHRcdFx0XHRcdFx0XHRjb25zdCBpbmRleDEgPSBpbmRpY2VzLmdldFgoIGkgKyBqICk7XG5cdFx0XHRcdFx0XHRcdGNvbnN0IGluZGV4MiA9IGluZGljZXMuZ2V0WCggaSArICggaiArIDEgKSAlIDMgKTtcblxuXHRcdFx0XHRcdFx0XHRzdGFydC5mcm9tQnVmZmVyQXR0cmlidXRlKCBwb3NpdGlvbiwgaW5kZXgxICk7XG5cdFx0XHRcdFx0XHRcdGVuZC5mcm9tQnVmZmVyQXR0cmlidXRlKCBwb3NpdGlvbiwgaW5kZXgyICk7XG5cblx0XHRcdFx0XHRcdFx0aWYgKCBpc1VuaXF1ZUVkZ2UoIHN0YXJ0LCBlbmQsIGVkZ2VzICkgPT09IHRydWUgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHR2ZXJ0aWNlcy5wdXNoKCBzdGFydC54LCBzdGFydC55LCBzdGFydC56ICk7XG5cdFx0XHRcdFx0XHRcdFx0dmVydGljZXMucHVzaCggZW5kLngsIGVuZC55LCBlbmQueiApO1xuXG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyBub24taW5kZXhlZCBCdWZmZXJHZW9tZXRyeVxuXG5cdFx0XHRcdGNvbnN0IHBvc2l0aW9uID0gZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbjtcblxuXHRcdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSAoIHBvc2l0aW9uLmNvdW50IC8gMyApOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdGZvciAoIGxldCBqID0gMDsgaiA8IDM7IGogKysgKSB7XG5cblx0XHRcdFx0XHRcdC8vIHRocmVlIGVkZ2VzIHBlciB0cmlhbmdsZSwgYW4gZWRnZSBpcyByZXByZXNlbnRlZCBhcyAoaW5kZXgxLCBpbmRleDIpXG5cdFx0XHRcdFx0XHQvLyBlLmcuIHRoZSBmaXJzdCB0cmlhbmdsZSBoYXMgdGhlIGZvbGxvd2luZyBlZGdlczogKDAsMSksKDEsMiksKDIsMClcblxuXHRcdFx0XHRcdFx0Y29uc3QgaW5kZXgxID0gMyAqIGkgKyBqO1xuXHRcdFx0XHRcdFx0Y29uc3QgaW5kZXgyID0gMyAqIGkgKyAoICggaiArIDEgKSAlIDMgKTtcblxuXHRcdFx0XHRcdFx0c3RhcnQuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggcG9zaXRpb24sIGluZGV4MSApO1xuXHRcdFx0XHRcdFx0ZW5kLmZyb21CdWZmZXJBdHRyaWJ1dGUoIHBvc2l0aW9uLCBpbmRleDIgKTtcblxuXHRcdFx0XHRcdFx0aWYgKCBpc1VuaXF1ZUVkZ2UoIHN0YXJ0LCBlbmQsIGVkZ2VzICkgPT09IHRydWUgKSB7XG5cblx0XHRcdFx0XHRcdFx0dmVydGljZXMucHVzaCggc3RhcnQueCwgc3RhcnQueSwgc3RhcnQueiApO1xuXHRcdFx0XHRcdFx0XHR2ZXJ0aWNlcy5wdXNoKCBlbmQueCwgZW5kLnksIGVuZC56ICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gYnVpbGQgZ2VvbWV0cnlcblxuXHRcdFx0dGhpcy5zZXRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCB2ZXJ0aWNlcywgMyApICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdGNvcHkoIHNvdXJjZSApIHtcblxuXHRcdHN1cGVyLmNvcHkoIHNvdXJjZSApO1xuXG5cdFx0dGhpcy5wYXJhbWV0ZXJzID0gT2JqZWN0LmFzc2lnbigge30sIHNvdXJjZS5wYXJhbWV0ZXJzICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cbn1cblxuZnVuY3Rpb24gaXNVbmlxdWVFZGdlKCBzdGFydCwgZW5kLCBlZGdlcyApIHtcblxuXHRjb25zdCBoYXNoMSA9IGAke3N0YXJ0Lnh9LCR7c3RhcnQueX0sJHtzdGFydC56fS0ke2VuZC54fSwke2VuZC55fSwke2VuZC56fWA7XG5cdGNvbnN0IGhhc2gyID0gYCR7ZW5kLnh9LCR7ZW5kLnl9LCR7ZW5kLnp9LSR7c3RhcnQueH0sJHtzdGFydC55fSwke3N0YXJ0Lnp9YDsgLy8gY29pbmNpZGVudCBlZGdlXG5cblx0aWYgKCBlZGdlcy5oYXMoIGhhc2gxICkgPT09IHRydWUgfHwgZWRnZXMuaGFzKCBoYXNoMiApID09PSB0cnVlICkge1xuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXG5cdH0gZWxzZSB7XG5cblx0XHRlZGdlcy5hZGQoIGhhc2gxICk7XG5cdFx0ZWRnZXMuYWRkKCBoYXNoMiApO1xuXHRcdHJldHVybiB0cnVlO1xuXG5cdH1cblxufVxuXG5cbmV4cG9ydCB7IFdpcmVmcmFtZUdlb21ldHJ5IH07XG4iLCJpbXBvcnQgeyBWZWN0b3IzIH0gZnJvbSAnLi9WZWN0b3IzLmpzJztcblxuY2xhc3MgQm94MyB7XG5cblx0Y29uc3RydWN0b3IoIG1pbiA9IG5ldyBWZWN0b3IzKCArIEluZmluaXR5LCArIEluZmluaXR5LCArIEluZmluaXR5ICksIG1heCA9IG5ldyBWZWN0b3IzKCAtIEluZmluaXR5LCAtIEluZmluaXR5LCAtIEluZmluaXR5ICkgKSB7XG5cblx0XHR0aGlzLmlzQm94MyA9IHRydWU7XG5cblx0XHR0aGlzLm1pbiA9IG1pbjtcblx0XHR0aGlzLm1heCA9IG1heDtcblxuXHR9XG5cblx0c2V0KCBtaW4sIG1heCApIHtcblxuXHRcdHRoaXMubWluLmNvcHkoIG1pbiApO1xuXHRcdHRoaXMubWF4LmNvcHkoIG1heCApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHNldEZyb21BcnJheSggYXJyYXkgKSB7XG5cblx0XHR0aGlzLm1ha2VFbXB0eSgpO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBpbCA9IGFycmF5Lmxlbmd0aDsgaSA8IGlsOyBpICs9IDMgKSB7XG5cblx0XHRcdHRoaXMuZXhwYW5kQnlQb2ludCggX3ZlY3Rvci5mcm9tQXJyYXkoIGFycmF5LCBpICkgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzZXRGcm9tQnVmZmVyQXR0cmlidXRlKCBhdHRyaWJ1dGUgKSB7XG5cblx0XHR0aGlzLm1ha2VFbXB0eSgpO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBpbCA9IGF0dHJpYnV0ZS5jb3VudDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHR0aGlzLmV4cGFuZEJ5UG9pbnQoIF92ZWN0b3IuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggYXR0cmlidXRlLCBpICkgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzZXRGcm9tUG9pbnRzKCBwb2ludHMgKSB7XG5cblx0XHR0aGlzLm1ha2VFbXB0eSgpO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBpbCA9IHBvaW50cy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0dGhpcy5leHBhbmRCeVBvaW50KCBwb2ludHNbIGkgXSApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHNldEZyb21DZW50ZXJBbmRTaXplKCBjZW50ZXIsIHNpemUgKSB7XG5cblx0XHRjb25zdCBoYWxmU2l6ZSA9IF92ZWN0b3IuY29weSggc2l6ZSApLm11bHRpcGx5U2NhbGFyKCAwLjUgKTtcblxuXHRcdHRoaXMubWluLmNvcHkoIGNlbnRlciApLnN1YiggaGFsZlNpemUgKTtcblx0XHR0aGlzLm1heC5jb3B5KCBjZW50ZXIgKS5hZGQoIGhhbGZTaXplICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c2V0RnJvbU9iamVjdCggb2JqZWN0LCBwcmVjaXNlID0gZmFsc2UgKSB7XG5cblx0XHR0aGlzLm1ha2VFbXB0eSgpO1xuXG5cdFx0cmV0dXJuIHRoaXMuZXhwYW5kQnlPYmplY3QoIG9iamVjdCwgcHJlY2lzZSApO1xuXG5cdH1cblxuXHRjbG9uZSgpIHtcblxuXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMgKTtcblxuXHR9XG5cblx0Y29weSggYm94ICkge1xuXG5cdFx0dGhpcy5taW4uY29weSggYm94Lm1pbiApO1xuXHRcdHRoaXMubWF4LmNvcHkoIGJveC5tYXggKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRtYWtlRW1wdHkoKSB7XG5cblx0XHR0aGlzLm1pbi54ID0gdGhpcy5taW4ueSA9IHRoaXMubWluLnogPSArIEluZmluaXR5O1xuXHRcdHRoaXMubWF4LnggPSB0aGlzLm1heC55ID0gdGhpcy5tYXgueiA9IC0gSW5maW5pdHk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0aXNFbXB0eSgpIHtcblxuXHRcdC8vIHRoaXMgaXMgYSBtb3JlIHJvYnVzdCBjaGVjayBmb3IgZW1wdHkgdGhhbiAoIHZvbHVtZSA8PSAwICkgYmVjYXVzZSB2b2x1bWUgY2FuIGdldCBwb3NpdGl2ZSB3aXRoIHR3byBuZWdhdGl2ZSBheGVzXG5cblx0XHRyZXR1cm4gKCB0aGlzLm1heC54IDwgdGhpcy5taW4ueCApIHx8ICggdGhpcy5tYXgueSA8IHRoaXMubWluLnkgKSB8fCAoIHRoaXMubWF4LnogPCB0aGlzLm1pbi56ICk7XG5cblx0fVxuXG5cdGdldENlbnRlciggdGFyZ2V0ICkge1xuXG5cdFx0cmV0dXJuIHRoaXMuaXNFbXB0eSgpID8gdGFyZ2V0LnNldCggMCwgMCwgMCApIDogdGFyZ2V0LmFkZFZlY3RvcnMoIHRoaXMubWluLCB0aGlzLm1heCApLm11bHRpcGx5U2NhbGFyKCAwLjUgKTtcblxuXHR9XG5cblx0Z2V0U2l6ZSggdGFyZ2V0ICkge1xuXG5cdFx0cmV0dXJuIHRoaXMuaXNFbXB0eSgpID8gdGFyZ2V0LnNldCggMCwgMCwgMCApIDogdGFyZ2V0LnN1YlZlY3RvcnMoIHRoaXMubWF4LCB0aGlzLm1pbiApO1xuXG5cdH1cblxuXHRleHBhbmRCeVBvaW50KCBwb2ludCApIHtcblxuXHRcdHRoaXMubWluLm1pbiggcG9pbnQgKTtcblx0XHR0aGlzLm1heC5tYXgoIHBvaW50ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0ZXhwYW5kQnlWZWN0b3IoIHZlY3RvciApIHtcblxuXHRcdHRoaXMubWluLnN1YiggdmVjdG9yICk7XG5cdFx0dGhpcy5tYXguYWRkKCB2ZWN0b3IgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRleHBhbmRCeVNjYWxhciggc2NhbGFyICkge1xuXG5cdFx0dGhpcy5taW4uYWRkU2NhbGFyKCAtIHNjYWxhciApO1xuXHRcdHRoaXMubWF4LmFkZFNjYWxhciggc2NhbGFyICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0ZXhwYW5kQnlPYmplY3QoIG9iamVjdCwgcHJlY2lzZSA9IGZhbHNlICkge1xuXG5cdFx0Ly8gQ29tcHV0ZXMgdGhlIHdvcmxkLWF4aXMtYWxpZ25lZCBib3VuZGluZyBib3ggb2YgYW4gb2JqZWN0IChpbmNsdWRpbmcgaXRzIGNoaWxkcmVuKSxcblx0XHQvLyBhY2NvdW50aW5nIGZvciBib3RoIHRoZSBvYmplY3QncywgYW5kIGNoaWxkcmVuJ3MsIHdvcmxkIHRyYW5zZm9ybXNcblxuXHRcdG9iamVjdC51cGRhdGVXb3JsZE1hdHJpeCggZmFsc2UsIGZhbHNlICk7XG5cblx0XHRpZiAoIG9iamVjdC5ib3VuZGluZ0JveCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRpZiAoIG9iamVjdC5ib3VuZGluZ0JveCA9PT0gbnVsbCApIHtcblxuXHRcdFx0XHRvYmplY3QuY29tcHV0ZUJvdW5kaW5nQm94KCk7XG5cblx0XHRcdH1cblxuXHRcdFx0X2JveC5jb3B5KCBvYmplY3QuYm91bmRpbmdCb3ggKTtcblx0XHRcdF9ib3guYXBwbHlNYXRyaXg0KCBvYmplY3QubWF0cml4V29ybGQgKTtcblxuXHRcdFx0dGhpcy51bmlvbiggX2JveCApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Y29uc3QgZ2VvbWV0cnkgPSBvYmplY3QuZ2VvbWV0cnk7XG5cblx0XHRcdGlmICggZ2VvbWV0cnkgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRpZiAoIHByZWNpc2UgJiYgZ2VvbWV0cnkuYXR0cmlidXRlcyAhPT0gdW5kZWZpbmVkICYmIGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb24gIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdGNvbnN0IHBvc2l0aW9uID0gZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbjtcblx0XHRcdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBwb3NpdGlvbi5jb3VudDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRcdF92ZWN0b3IuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggcG9zaXRpb24sIGkgKS5hcHBseU1hdHJpeDQoIG9iamVjdC5tYXRyaXhXb3JsZCApO1xuXHRcdFx0XHRcdFx0dGhpcy5leHBhbmRCeVBvaW50KCBfdmVjdG9yICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdGlmICggZ2VvbWV0cnkuYm91bmRpbmdCb3ggPT09IG51bGwgKSB7XG5cblx0XHRcdFx0XHRcdGdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ0JveCgpO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0X2JveC5jb3B5KCBnZW9tZXRyeS5ib3VuZGluZ0JveCApO1xuXHRcdFx0XHRcdF9ib3guYXBwbHlNYXRyaXg0KCBvYmplY3QubWF0cml4V29ybGQgKTtcblxuXHRcdFx0XHRcdHRoaXMudW5pb24oIF9ib3ggKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGNvbnN0IGNoaWxkcmVuID0gb2JqZWN0LmNoaWxkcmVuO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0dGhpcy5leHBhbmRCeU9iamVjdCggY2hpbGRyZW5bIGkgXSwgcHJlY2lzZSApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGNvbnRhaW5zUG9pbnQoIHBvaW50ICkge1xuXG5cdFx0cmV0dXJuIHBvaW50LnggPCB0aGlzLm1pbi54IHx8IHBvaW50LnggPiB0aGlzLm1heC54IHx8XG5cdFx0XHRwb2ludC55IDwgdGhpcy5taW4ueSB8fCBwb2ludC55ID4gdGhpcy5tYXgueSB8fFxuXHRcdFx0cG9pbnQueiA8IHRoaXMubWluLnogfHwgcG9pbnQueiA+IHRoaXMubWF4LnogPyBmYWxzZSA6IHRydWU7XG5cblx0fVxuXG5cdGNvbnRhaW5zQm94KCBib3ggKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5taW4ueCA8PSBib3gubWluLnggJiYgYm94Lm1heC54IDw9IHRoaXMubWF4LnggJiZcblx0XHRcdHRoaXMubWluLnkgPD0gYm94Lm1pbi55ICYmIGJveC5tYXgueSA8PSB0aGlzLm1heC55ICYmXG5cdFx0XHR0aGlzLm1pbi56IDw9IGJveC5taW4ueiAmJiBib3gubWF4LnogPD0gdGhpcy5tYXguejtcblxuXHR9XG5cblx0Z2V0UGFyYW1ldGVyKCBwb2ludCwgdGFyZ2V0ICkge1xuXG5cdFx0Ly8gVGhpcyBjYW4gcG90ZW50aWFsbHkgaGF2ZSBhIGRpdmlkZSBieSB6ZXJvIGlmIHRoZSBib3hcblx0XHQvLyBoYXMgYSBzaXplIGRpbWVuc2lvbiBvZiAwLlxuXG5cdFx0cmV0dXJuIHRhcmdldC5zZXQoXG5cdFx0XHQoIHBvaW50LnggLSB0aGlzLm1pbi54ICkgLyAoIHRoaXMubWF4LnggLSB0aGlzLm1pbi54ICksXG5cdFx0XHQoIHBvaW50LnkgLSB0aGlzLm1pbi55ICkgLyAoIHRoaXMubWF4LnkgLSB0aGlzLm1pbi55ICksXG5cdFx0XHQoIHBvaW50LnogLSB0aGlzLm1pbi56ICkgLyAoIHRoaXMubWF4LnogLSB0aGlzLm1pbi56IClcblx0XHQpO1xuXG5cdH1cblxuXHRpbnRlcnNlY3RzQm94KCBib3ggKSB7XG5cblx0XHQvLyB1c2luZyA2IHNwbGl0dGluZyBwbGFuZXMgdG8gcnVsZSBvdXQgaW50ZXJzZWN0aW9ucy5cblx0XHRyZXR1cm4gYm94Lm1heC54IDwgdGhpcy5taW4ueCB8fCBib3gubWluLnggPiB0aGlzLm1heC54IHx8XG5cdFx0XHRib3gubWF4LnkgPCB0aGlzLm1pbi55IHx8IGJveC5taW4ueSA+IHRoaXMubWF4LnkgfHxcblx0XHRcdGJveC5tYXgueiA8IHRoaXMubWluLnogfHwgYm94Lm1pbi56ID4gdGhpcy5tYXgueiA/IGZhbHNlIDogdHJ1ZTtcblxuXHR9XG5cblx0aW50ZXJzZWN0c1NwaGVyZSggc3BoZXJlICkge1xuXG5cdFx0Ly8gRmluZCB0aGUgcG9pbnQgb24gdGhlIEFBQkIgY2xvc2VzdCB0byB0aGUgc3BoZXJlIGNlbnRlci5cblx0XHR0aGlzLmNsYW1wUG9pbnQoIHNwaGVyZS5jZW50ZXIsIF92ZWN0b3IgKTtcblxuXHRcdC8vIElmIHRoYXQgcG9pbnQgaXMgaW5zaWRlIHRoZSBzcGhlcmUsIHRoZSBBQUJCIGFuZCBzcGhlcmUgaW50ZXJzZWN0LlxuXHRcdHJldHVybiBfdmVjdG9yLmRpc3RhbmNlVG9TcXVhcmVkKCBzcGhlcmUuY2VudGVyICkgPD0gKCBzcGhlcmUucmFkaXVzICogc3BoZXJlLnJhZGl1cyApO1xuXG5cdH1cblxuXHRpbnRlcnNlY3RzUGxhbmUoIHBsYW5lICkge1xuXG5cdFx0Ly8gV2UgY29tcHV0ZSB0aGUgbWluaW11bSBhbmQgbWF4aW11bSBkb3QgcHJvZHVjdCB2YWx1ZXMuIElmIHRob3NlIHZhbHVlc1xuXHRcdC8vIGFyZSBvbiB0aGUgc2FtZSBzaWRlIChiYWNrIG9yIGZyb250KSBvZiB0aGUgcGxhbmUsIHRoZW4gdGhlcmUgaXMgbm8gaW50ZXJzZWN0aW9uLlxuXG5cdFx0bGV0IG1pbiwgbWF4O1xuXG5cdFx0aWYgKCBwbGFuZS5ub3JtYWwueCA+IDAgKSB7XG5cblx0XHRcdG1pbiA9IHBsYW5lLm5vcm1hbC54ICogdGhpcy5taW4ueDtcblx0XHRcdG1heCA9IHBsYW5lLm5vcm1hbC54ICogdGhpcy5tYXgueDtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdG1pbiA9IHBsYW5lLm5vcm1hbC54ICogdGhpcy5tYXgueDtcblx0XHRcdG1heCA9IHBsYW5lLm5vcm1hbC54ICogdGhpcy5taW4ueDtcblxuXHRcdH1cblxuXHRcdGlmICggcGxhbmUubm9ybWFsLnkgPiAwICkge1xuXG5cdFx0XHRtaW4gKz0gcGxhbmUubm9ybWFsLnkgKiB0aGlzLm1pbi55O1xuXHRcdFx0bWF4ICs9IHBsYW5lLm5vcm1hbC55ICogdGhpcy5tYXgueTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdG1pbiArPSBwbGFuZS5ub3JtYWwueSAqIHRoaXMubWF4Lnk7XG5cdFx0XHRtYXggKz0gcGxhbmUubm9ybWFsLnkgKiB0aGlzLm1pbi55O1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBwbGFuZS5ub3JtYWwueiA+IDAgKSB7XG5cblx0XHRcdG1pbiArPSBwbGFuZS5ub3JtYWwueiAqIHRoaXMubWluLno7XG5cdFx0XHRtYXggKz0gcGxhbmUubm9ybWFsLnogKiB0aGlzLm1heC56O1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0bWluICs9IHBsYW5lLm5vcm1hbC56ICogdGhpcy5tYXguejtcblx0XHRcdG1heCArPSBwbGFuZS5ub3JtYWwueiAqIHRoaXMubWluLno7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gKCBtaW4gPD0gLSBwbGFuZS5jb25zdGFudCAmJiBtYXggPj0gLSBwbGFuZS5jb25zdGFudCApO1xuXG5cdH1cblxuXHRpbnRlcnNlY3RzVHJpYW5nbGUoIHRyaWFuZ2xlICkge1xuXG5cdFx0aWYgKCB0aGlzLmlzRW1wdHkoKSApIHtcblxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXG5cdFx0fVxuXG5cdFx0Ly8gY29tcHV0ZSBib3ggY2VudGVyIGFuZCBleHRlbnRzXG5cdFx0dGhpcy5nZXRDZW50ZXIoIF9jZW50ZXIgKTtcblx0XHRfZXh0ZW50cy5zdWJWZWN0b3JzKCB0aGlzLm1heCwgX2NlbnRlciApO1xuXG5cdFx0Ly8gdHJhbnNsYXRlIHRyaWFuZ2xlIHRvIGFhYmIgb3JpZ2luXG5cdFx0X3YwLnN1YlZlY3RvcnMoIHRyaWFuZ2xlLmEsIF9jZW50ZXIgKTtcblx0XHRfdjEuc3ViVmVjdG9ycyggdHJpYW5nbGUuYiwgX2NlbnRlciApO1xuXHRcdF92Mi5zdWJWZWN0b3JzKCB0cmlhbmdsZS5jLCBfY2VudGVyICk7XG5cblx0XHQvLyBjb21wdXRlIGVkZ2UgdmVjdG9ycyBmb3IgdHJpYW5nbGVcblx0XHRfZjAuc3ViVmVjdG9ycyggX3YxLCBfdjAgKTtcblx0XHRfZjEuc3ViVmVjdG9ycyggX3YyLCBfdjEgKTtcblx0XHRfZjIuc3ViVmVjdG9ycyggX3YwLCBfdjIgKTtcblxuXHRcdC8vIHRlc3QgYWdhaW5zdCBheGVzIHRoYXQgYXJlIGdpdmVuIGJ5IGNyb3NzIHByb2R1Y3QgY29tYmluYXRpb25zIG9mIHRoZSBlZGdlcyBvZiB0aGUgdHJpYW5nbGUgYW5kIHRoZSBlZGdlcyBvZiB0aGUgYWFiYlxuXHRcdC8vIG1ha2UgYW4gYXhpcyB0ZXN0aW5nIG9mIGVhY2ggb2YgdGhlIDMgc2lkZXMgb2YgdGhlIGFhYmIgYWdhaW5zdCBlYWNoIG9mIHRoZSAzIHNpZGVzIG9mIHRoZSB0cmlhbmdsZSA9IDkgYXhpcyBvZiBzZXBhcmF0aW9uXG5cdFx0Ly8gYXhpc19paiA9IHVfaSB4IGZfaiAodTAsIHUxLCB1MiA9IGZhY2Ugbm9ybWFscyBvZiBhYWJiID0geCx5LHogYXhlcyB2ZWN0b3JzIHNpbmNlIGFhYmIgaXMgYXhpcyBhbGlnbmVkKVxuXHRcdGxldCBheGVzID0gW1xuXHRcdFx0MCwgLSBfZjAueiwgX2YwLnksIDAsIC0gX2YxLnosIF9mMS55LCAwLCAtIF9mMi56LCBfZjIueSxcblx0XHRcdF9mMC56LCAwLCAtIF9mMC54LCBfZjEueiwgMCwgLSBfZjEueCwgX2YyLnosIDAsIC0gX2YyLngsXG5cdFx0XHQtIF9mMC55LCBfZjAueCwgMCwgLSBfZjEueSwgX2YxLngsIDAsIC0gX2YyLnksIF9mMi54LCAwXG5cdFx0XTtcblx0XHRpZiAoICEgc2F0Rm9yQXhlcyggYXhlcywgX3YwLCBfdjEsIF92MiwgX2V4dGVudHMgKSApIHtcblxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXG5cdFx0fVxuXG5cdFx0Ly8gdGVzdCAzIGZhY2Ugbm9ybWFscyBmcm9tIHRoZSBhYWJiXG5cdFx0YXhlcyA9IFsgMSwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMSBdO1xuXHRcdGlmICggISBzYXRGb3JBeGVzKCBheGVzLCBfdjAsIF92MSwgX3YyLCBfZXh0ZW50cyApICkge1xuXG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cblx0XHR9XG5cblx0XHQvLyBmaW5hbGx5IHRlc3RpbmcgdGhlIGZhY2Ugbm9ybWFsIG9mIHRoZSB0cmlhbmdsZVxuXHRcdC8vIHVzZSBhbHJlYWR5IGV4aXN0aW5nIHRyaWFuZ2xlIGVkZ2UgdmVjdG9ycyBoZXJlXG5cdFx0X3RyaWFuZ2xlTm9ybWFsLmNyb3NzVmVjdG9ycyggX2YwLCBfZjEgKTtcblx0XHRheGVzID0gWyBfdHJpYW5nbGVOb3JtYWwueCwgX3RyaWFuZ2xlTm9ybWFsLnksIF90cmlhbmdsZU5vcm1hbC56IF07XG5cblx0XHRyZXR1cm4gc2F0Rm9yQXhlcyggYXhlcywgX3YwLCBfdjEsIF92MiwgX2V4dGVudHMgKTtcblxuXHR9XG5cblx0Y2xhbXBQb2ludCggcG9pbnQsIHRhcmdldCApIHtcblxuXHRcdHJldHVybiB0YXJnZXQuY29weSggcG9pbnQgKS5jbGFtcCggdGhpcy5taW4sIHRoaXMubWF4ICk7XG5cblx0fVxuXG5cdGRpc3RhbmNlVG9Qb2ludCggcG9pbnQgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5jbGFtcFBvaW50KCBwb2ludCwgX3ZlY3RvciApLmRpc3RhbmNlVG8oIHBvaW50ICk7XG5cblx0fVxuXG5cdGdldEJvdW5kaW5nU3BoZXJlKCB0YXJnZXQgKSB7XG5cblx0XHRpZiAoIHRoaXMuaXNFbXB0eSgpICkge1xuXG5cdFx0XHR0YXJnZXQubWFrZUVtcHR5KCk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHR0aGlzLmdldENlbnRlciggdGFyZ2V0LmNlbnRlciApO1xuXG5cdFx0XHR0YXJnZXQucmFkaXVzID0gdGhpcy5nZXRTaXplKCBfdmVjdG9yICkubGVuZ3RoKCkgKiAwLjU7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGFyZ2V0O1xuXG5cdH1cblxuXHRpbnRlcnNlY3QoIGJveCApIHtcblxuXHRcdHRoaXMubWluLm1heCggYm94Lm1pbiApO1xuXHRcdHRoaXMubWF4Lm1pbiggYm94Lm1heCApO1xuXG5cdFx0Ly8gZW5zdXJlIHRoYXQgaWYgdGhlcmUgaXMgbm8gb3ZlcmxhcCwgdGhlIHJlc3VsdCBpcyBmdWxseSBlbXB0eSwgbm90IHNsaWdodGx5IGVtcHR5IHdpdGggbm9uLWluZi8raW5mIHZhbHVlcyB0aGF0IHdpbGwgY2F1c2Ugc3Vic2VxdWVuY2UgaW50ZXJzZWN0cyB0byBlcnJvbmVvdXNseSByZXR1cm4gdmFsaWQgdmFsdWVzLlxuXHRcdGlmICggdGhpcy5pc0VtcHR5KCkgKSB0aGlzLm1ha2VFbXB0eSgpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHVuaW9uKCBib3ggKSB7XG5cblx0XHR0aGlzLm1pbi5taW4oIGJveC5taW4gKTtcblx0XHR0aGlzLm1heC5tYXgoIGJveC5tYXggKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRhcHBseU1hdHJpeDQoIG1hdHJpeCApIHtcblxuXHRcdC8vIHRyYW5zZm9ybSBvZiBlbXB0eSBib3ggaXMgYW4gZW1wdHkgYm94LlxuXHRcdGlmICggdGhpcy5pc0VtcHR5KCkgKSByZXR1cm4gdGhpcztcblxuXHRcdC8vIE5PVEU6IEkgYW0gdXNpbmcgYSBiaW5hcnkgcGF0dGVybiB0byBzcGVjaWZ5IGFsbCAyXjMgY29tYmluYXRpb25zIGJlbG93XG5cdFx0X3BvaW50c1sgMCBdLnNldCggdGhpcy5taW4ueCwgdGhpcy5taW4ueSwgdGhpcy5taW4ueiApLmFwcGx5TWF0cml4NCggbWF0cml4ICk7IC8vIDAwMFxuXHRcdF9wb2ludHNbIDEgXS5zZXQoIHRoaXMubWluLngsIHRoaXMubWluLnksIHRoaXMubWF4LnogKS5hcHBseU1hdHJpeDQoIG1hdHJpeCApOyAvLyAwMDFcblx0XHRfcG9pbnRzWyAyIF0uc2V0KCB0aGlzLm1pbi54LCB0aGlzLm1heC55LCB0aGlzLm1pbi56ICkuYXBwbHlNYXRyaXg0KCBtYXRyaXggKTsgLy8gMDEwXG5cdFx0X3BvaW50c1sgMyBdLnNldCggdGhpcy5taW4ueCwgdGhpcy5tYXgueSwgdGhpcy5tYXgueiApLmFwcGx5TWF0cml4NCggbWF0cml4ICk7IC8vIDAxMVxuXHRcdF9wb2ludHNbIDQgXS5zZXQoIHRoaXMubWF4LngsIHRoaXMubWluLnksIHRoaXMubWluLnogKS5hcHBseU1hdHJpeDQoIG1hdHJpeCApOyAvLyAxMDBcblx0XHRfcG9pbnRzWyA1IF0uc2V0KCB0aGlzLm1heC54LCB0aGlzLm1pbi55LCB0aGlzLm1heC56ICkuYXBwbHlNYXRyaXg0KCBtYXRyaXggKTsgLy8gMTAxXG5cdFx0X3BvaW50c1sgNiBdLnNldCggdGhpcy5tYXgueCwgdGhpcy5tYXgueSwgdGhpcy5taW4ueiApLmFwcGx5TWF0cml4NCggbWF0cml4ICk7IC8vIDExMFxuXHRcdF9wb2ludHNbIDcgXS5zZXQoIHRoaXMubWF4LngsIHRoaXMubWF4LnksIHRoaXMubWF4LnogKS5hcHBseU1hdHJpeDQoIG1hdHJpeCApOyAvLyAxMTFcblxuXHRcdHRoaXMuc2V0RnJvbVBvaW50cyggX3BvaW50cyApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHRyYW5zbGF0ZSggb2Zmc2V0ICkge1xuXG5cdFx0dGhpcy5taW4uYWRkKCBvZmZzZXQgKTtcblx0XHR0aGlzLm1heC5hZGQoIG9mZnNldCApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGVxdWFscyggYm94ICkge1xuXG5cdFx0cmV0dXJuIGJveC5taW4uZXF1YWxzKCB0aGlzLm1pbiApICYmIGJveC5tYXguZXF1YWxzKCB0aGlzLm1heCApO1xuXG5cdH1cblxufVxuXG5jb25zdCBfcG9pbnRzID0gW1xuXHQvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCksXG5cdC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKSxcblx0LypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpLFxuXHQvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCksXG5cdC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKSxcblx0LypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpLFxuXHQvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCksXG5cdC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKVxuXTtcblxuY29uc3QgX3ZlY3RvciA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcblxuY29uc3QgX2JveCA9IC8qQF9fUFVSRV9fKi8gbmV3IEJveDMoKTtcblxuLy8gdHJpYW5nbGUgY2VudGVyZWQgdmVydGljZXNcblxuY29uc3QgX3YwID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xuY29uc3QgX3YxID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xuY29uc3QgX3YyID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xuXG4vLyB0cmlhbmdsZSBlZGdlIHZlY3RvcnNcblxuY29uc3QgX2YwID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xuY29uc3QgX2YxID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xuY29uc3QgX2YyID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xuXG5jb25zdCBfY2VudGVyID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xuY29uc3QgX2V4dGVudHMgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XG5jb25zdCBfdHJpYW5nbGVOb3JtYWwgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XG5jb25zdCBfdGVzdEF4aXMgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XG5cbmZ1bmN0aW9uIHNhdEZvckF4ZXMoIGF4ZXMsIHYwLCB2MSwgdjIsIGV4dGVudHMgKSB7XG5cblx0Zm9yICggbGV0IGkgPSAwLCBqID0gYXhlcy5sZW5ndGggLSAzOyBpIDw9IGo7IGkgKz0gMyApIHtcblxuXHRcdF90ZXN0QXhpcy5mcm9tQXJyYXkoIGF4ZXMsIGkgKTtcblx0XHQvLyBwcm9qZWN0IHRoZSBhYWJiIG9udG8gdGhlIHNlcGFyYXRpbmcgYXhpc1xuXHRcdGNvbnN0IHIgPSBleHRlbnRzLnggKiBNYXRoLmFicyggX3Rlc3RBeGlzLnggKSArIGV4dGVudHMueSAqIE1hdGguYWJzKCBfdGVzdEF4aXMueSApICsgZXh0ZW50cy56ICogTWF0aC5hYnMoIF90ZXN0QXhpcy56ICk7XG5cdFx0Ly8gcHJvamVjdCBhbGwgMyB2ZXJ0aWNlcyBvZiB0aGUgdHJpYW5nbGUgb250byB0aGUgc2VwYXJhdGluZyBheGlzXG5cdFx0Y29uc3QgcDAgPSB2MC5kb3QoIF90ZXN0QXhpcyApO1xuXHRcdGNvbnN0IHAxID0gdjEuZG90KCBfdGVzdEF4aXMgKTtcblx0XHRjb25zdCBwMiA9IHYyLmRvdCggX3Rlc3RBeGlzICk7XG5cdFx0Ly8gYWN0dWFsIHRlc3QsIGJhc2ljYWxseSBzZWUgaWYgZWl0aGVyIG9mIHRoZSBtb3N0IGV4dHJlbWUgb2YgdGhlIHRyaWFuZ2xlIHBvaW50cyBpbnRlcnNlY3RzIHJcblx0XHRpZiAoIE1hdGgubWF4KCAtIE1hdGgubWF4KCBwMCwgcDEsIHAyICksIE1hdGgubWluKCBwMCwgcDEsIHAyICkgKSA+IHIgKSB7XG5cblx0XHRcdC8vIHBvaW50cyBvZiB0aGUgcHJvamVjdGVkIHRyaWFuZ2xlIGFyZSBvdXRzaWRlIHRoZSBwcm9qZWN0ZWQgaGFsZi1sZW5ndGggb2YgdGhlIGFhYmJcblx0XHRcdC8vIHRoZSBheGlzIGlzIHNlcGFyYXRpbmcgYW5kIHdlIGNhbiBleGl0XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cblx0XHR9XG5cblx0fVxuXG5cdHJldHVybiB0cnVlO1xuXG59XG5cbmV4cG9ydCB7IEJveDMgfTtcbiIsImltcG9ydCB7IFF1YXRlcm5pb24gfSBmcm9tICcuL1F1YXRlcm5pb24uanMnO1xuaW1wb3J0IHsgTWF0cml4NCB9IGZyb20gJy4vTWF0cml4NC5qcyc7XG5pbXBvcnQgeyBjbGFtcCB9IGZyb20gJy4vTWF0aFV0aWxzLmpzJztcblxuY29uc3QgX21hdHJpeCA9IC8qQF9fUFVSRV9fKi8gbmV3IE1hdHJpeDQoKTtcbmNvbnN0IF9xdWF0ZXJuaW9uID0gLypAX19QVVJFX18qLyBuZXcgUXVhdGVybmlvbigpO1xuXG5jbGFzcyBFdWxlciB7XG5cblx0Y29uc3RydWN0b3IoIHggPSAwLCB5ID0gMCwgeiA9IDAsIG9yZGVyID0gRXVsZXIuREVGQVVMVF9PUkRFUiApIHtcblxuXHRcdHRoaXMuaXNFdWxlciA9IHRydWU7XG5cblx0XHR0aGlzLl94ID0geDtcblx0XHR0aGlzLl95ID0geTtcblx0XHR0aGlzLl96ID0gejtcblx0XHR0aGlzLl9vcmRlciA9IG9yZGVyO1xuXG5cdH1cblxuXHRnZXQgeCgpIHtcblxuXHRcdHJldHVybiB0aGlzLl94O1xuXG5cdH1cblxuXHRzZXQgeCggdmFsdWUgKSB7XG5cblx0XHR0aGlzLl94ID0gdmFsdWU7XG5cdFx0dGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpO1xuXG5cdH1cblxuXHRnZXQgeSgpIHtcblxuXHRcdHJldHVybiB0aGlzLl95O1xuXG5cdH1cblxuXHRzZXQgeSggdmFsdWUgKSB7XG5cblx0XHR0aGlzLl95ID0gdmFsdWU7XG5cdFx0dGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpO1xuXG5cdH1cblxuXHRnZXQgeigpIHtcblxuXHRcdHJldHVybiB0aGlzLl96O1xuXG5cdH1cblxuXHRzZXQgeiggdmFsdWUgKSB7XG5cblx0XHR0aGlzLl96ID0gdmFsdWU7XG5cdFx0dGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpO1xuXG5cdH1cblxuXHRnZXQgb3JkZXIoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5fb3JkZXI7XG5cblx0fVxuXG5cdHNldCBvcmRlciggdmFsdWUgKSB7XG5cblx0XHR0aGlzLl9vcmRlciA9IHZhbHVlO1xuXHRcdHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHR9XG5cblx0c2V0KCB4LCB5LCB6LCBvcmRlciA9IHRoaXMuX29yZGVyICkge1xuXG5cdFx0dGhpcy5feCA9IHg7XG5cdFx0dGhpcy5feSA9IHk7XG5cdFx0dGhpcy5feiA9IHo7XG5cdFx0dGhpcy5fb3JkZXIgPSBvcmRlcjtcblxuXHRcdHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRjbG9uZSgpIHtcblxuXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvciggdGhpcy5feCwgdGhpcy5feSwgdGhpcy5feiwgdGhpcy5fb3JkZXIgKTtcblxuXHR9XG5cblx0Y29weSggZXVsZXIgKSB7XG5cblx0XHR0aGlzLl94ID0gZXVsZXIuX3g7XG5cdFx0dGhpcy5feSA9IGV1bGVyLl95O1xuXHRcdHRoaXMuX3ogPSBldWxlci5fejtcblx0XHR0aGlzLl9vcmRlciA9IGV1bGVyLl9vcmRlcjtcblxuXHRcdHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzZXRGcm9tUm90YXRpb25NYXRyaXgoIG0sIG9yZGVyID0gdGhpcy5fb3JkZXIsIHVwZGF0ZSA9IHRydWUgKSB7XG5cblx0XHQvLyBhc3N1bWVzIHRoZSB1cHBlciAzeDMgb2YgbSBpcyBhIHB1cmUgcm90YXRpb24gbWF0cml4IChpLmUsIHVuc2NhbGVkKVxuXG5cdFx0Y29uc3QgdGUgPSBtLmVsZW1lbnRzO1xuXHRcdGNvbnN0IG0xMSA9IHRlWyAwIF0sIG0xMiA9IHRlWyA0IF0sIG0xMyA9IHRlWyA4IF07XG5cdFx0Y29uc3QgbTIxID0gdGVbIDEgXSwgbTIyID0gdGVbIDUgXSwgbTIzID0gdGVbIDkgXTtcblx0XHRjb25zdCBtMzEgPSB0ZVsgMiBdLCBtMzIgPSB0ZVsgNiBdLCBtMzMgPSB0ZVsgMTAgXTtcblxuXHRcdHN3aXRjaCAoIG9yZGVyICkge1xuXG5cdFx0XHRjYXNlICdYWVonOlxuXG5cdFx0XHRcdHRoaXMuX3kgPSBNYXRoLmFzaW4oIGNsYW1wKCBtMTMsIC0gMSwgMSApICk7XG5cblx0XHRcdFx0aWYgKCBNYXRoLmFicyggbTEzICkgPCAwLjk5OTk5OTkgKSB7XG5cblx0XHRcdFx0XHR0aGlzLl94ID0gTWF0aC5hdGFuMiggLSBtMjMsIG0zMyApO1xuXHRcdFx0XHRcdHRoaXMuX3ogPSBNYXRoLmF0YW4yKCAtIG0xMiwgbTExICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdHRoaXMuX3ggPSBNYXRoLmF0YW4yKCBtMzIsIG0yMiApO1xuXHRcdFx0XHRcdHRoaXMuX3ogPSAwO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSAnWVhaJzpcblxuXHRcdFx0XHR0aGlzLl94ID0gTWF0aC5hc2luKCAtIGNsYW1wKCBtMjMsIC0gMSwgMSApICk7XG5cblx0XHRcdFx0aWYgKCBNYXRoLmFicyggbTIzICkgPCAwLjk5OTk5OTkgKSB7XG5cblx0XHRcdFx0XHR0aGlzLl95ID0gTWF0aC5hdGFuMiggbTEzLCBtMzMgKTtcblx0XHRcdFx0XHR0aGlzLl96ID0gTWF0aC5hdGFuMiggbTIxLCBtMjIgKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0dGhpcy5feSA9IE1hdGguYXRhbjIoIC0gbTMxLCBtMTEgKTtcblx0XHRcdFx0XHR0aGlzLl96ID0gMDtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgJ1pYWSc6XG5cblx0XHRcdFx0dGhpcy5feCA9IE1hdGguYXNpbiggY2xhbXAoIG0zMiwgLSAxLCAxICkgKTtcblxuXHRcdFx0XHRpZiAoIE1hdGguYWJzKCBtMzIgKSA8IDAuOTk5OTk5OSApIHtcblxuXHRcdFx0XHRcdHRoaXMuX3kgPSBNYXRoLmF0YW4yKCAtIG0zMSwgbTMzICk7XG5cdFx0XHRcdFx0dGhpcy5feiA9IE1hdGguYXRhbjIoIC0gbTEyLCBtMjIgKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0dGhpcy5feSA9IDA7XG5cdFx0XHRcdFx0dGhpcy5feiA9IE1hdGguYXRhbjIoIG0yMSwgbTExICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlICdaWVgnOlxuXG5cdFx0XHRcdHRoaXMuX3kgPSBNYXRoLmFzaW4oIC0gY2xhbXAoIG0zMSwgLSAxLCAxICkgKTtcblxuXHRcdFx0XHRpZiAoIE1hdGguYWJzKCBtMzEgKSA8IDAuOTk5OTk5OSApIHtcblxuXHRcdFx0XHRcdHRoaXMuX3ggPSBNYXRoLmF0YW4yKCBtMzIsIG0zMyApO1xuXHRcdFx0XHRcdHRoaXMuX3ogPSBNYXRoLmF0YW4yKCBtMjEsIG0xMSApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHR0aGlzLl94ID0gMDtcblx0XHRcdFx0XHR0aGlzLl96ID0gTWF0aC5hdGFuMiggLSBtMTIsIG0yMiApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSAnWVpYJzpcblxuXHRcdFx0XHR0aGlzLl96ID0gTWF0aC5hc2luKCBjbGFtcCggbTIxLCAtIDEsIDEgKSApO1xuXG5cdFx0XHRcdGlmICggTWF0aC5hYnMoIG0yMSApIDwgMC45OTk5OTk5ICkge1xuXG5cdFx0XHRcdFx0dGhpcy5feCA9IE1hdGguYXRhbjIoIC0gbTIzLCBtMjIgKTtcblx0XHRcdFx0XHR0aGlzLl95ID0gTWF0aC5hdGFuMiggLSBtMzEsIG0xMSApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHR0aGlzLl94ID0gMDtcblx0XHRcdFx0XHR0aGlzLl95ID0gTWF0aC5hdGFuMiggbTEzLCBtMzMgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgJ1haWSc6XG5cblx0XHRcdFx0dGhpcy5feiA9IE1hdGguYXNpbiggLSBjbGFtcCggbTEyLCAtIDEsIDEgKSApO1xuXG5cdFx0XHRcdGlmICggTWF0aC5hYnMoIG0xMiApIDwgMC45OTk5OTk5ICkge1xuXG5cdFx0XHRcdFx0dGhpcy5feCA9IE1hdGguYXRhbjIoIG0zMiwgbTIyICk7XG5cdFx0XHRcdFx0dGhpcy5feSA9IE1hdGguYXRhbjIoIG0xMywgbTExICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdHRoaXMuX3ggPSBNYXRoLmF0YW4yKCAtIG0yMywgbTMzICk7XG5cdFx0XHRcdFx0dGhpcy5feSA9IDA7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRkZWZhdWx0OlxuXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkV1bGVyOiAuc2V0RnJvbVJvdGF0aW9uTWF0cml4KCkgZW5jb3VudGVyZWQgYW4gdW5rbm93biBvcmRlcjogJyArIG9yZGVyICk7XG5cblx0XHR9XG5cblx0XHR0aGlzLl9vcmRlciA9IG9yZGVyO1xuXG5cdFx0aWYgKCB1cGRhdGUgPT09IHRydWUgKSB0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c2V0RnJvbVF1YXRlcm5pb24oIHEsIG9yZGVyLCB1cGRhdGUgKSB7XG5cblx0XHRfbWF0cml4Lm1ha2VSb3RhdGlvbkZyb21RdWF0ZXJuaW9uKCBxICk7XG5cblx0XHRyZXR1cm4gdGhpcy5zZXRGcm9tUm90YXRpb25NYXRyaXgoIF9tYXRyaXgsIG9yZGVyLCB1cGRhdGUgKTtcblxuXHR9XG5cblx0c2V0RnJvbVZlY3RvcjMoIHYsIG9yZGVyID0gdGhpcy5fb3JkZXIgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5zZXQoIHYueCwgdi55LCB2LnosIG9yZGVyICk7XG5cblx0fVxuXG5cdHJlb3JkZXIoIG5ld09yZGVyICkge1xuXG5cdFx0Ly8gV0FSTklORzogdGhpcyBkaXNjYXJkcyByZXZvbHV0aW9uIGluZm9ybWF0aW9uIC1iaG91c3RvblxuXG5cdFx0X3F1YXRlcm5pb24uc2V0RnJvbUV1bGVyKCB0aGlzICk7XG5cblx0XHRyZXR1cm4gdGhpcy5zZXRGcm9tUXVhdGVybmlvbiggX3F1YXRlcm5pb24sIG5ld09yZGVyICk7XG5cblx0fVxuXG5cdGVxdWFscyggZXVsZXIgKSB7XG5cblx0XHRyZXR1cm4gKCBldWxlci5feCA9PT0gdGhpcy5feCApICYmICggZXVsZXIuX3kgPT09IHRoaXMuX3kgKSAmJiAoIGV1bGVyLl96ID09PSB0aGlzLl96ICkgJiYgKCBldWxlci5fb3JkZXIgPT09IHRoaXMuX29yZGVyICk7XG5cblx0fVxuXG5cdGZyb21BcnJheSggYXJyYXkgKSB7XG5cblx0XHR0aGlzLl94ID0gYXJyYXlbIDAgXTtcblx0XHR0aGlzLl95ID0gYXJyYXlbIDEgXTtcblx0XHR0aGlzLl96ID0gYXJyYXlbIDIgXTtcblx0XHRpZiAoIGFycmF5WyAzIF0gIT09IHVuZGVmaW5lZCApIHRoaXMuX29yZGVyID0gYXJyYXlbIDMgXTtcblxuXHRcdHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHR0b0FycmF5KCBhcnJheSA9IFtdLCBvZmZzZXQgPSAwICkge1xuXG5cdFx0YXJyYXlbIG9mZnNldCBdID0gdGhpcy5feDtcblx0XHRhcnJheVsgb2Zmc2V0ICsgMSBdID0gdGhpcy5feTtcblx0XHRhcnJheVsgb2Zmc2V0ICsgMiBdID0gdGhpcy5fejtcblx0XHRhcnJheVsgb2Zmc2V0ICsgMyBdID0gdGhpcy5fb3JkZXI7XG5cblx0XHRyZXR1cm4gYXJyYXk7XG5cblx0fVxuXG5cdF9vbkNoYW5nZSggY2FsbGJhY2sgKSB7XG5cblx0XHR0aGlzLl9vbkNoYW5nZUNhbGxiYWNrID0gY2FsbGJhY2s7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0X29uQ2hhbmdlQ2FsbGJhY2soKSB7fVxuXG5cdCpbIFN5bWJvbC5pdGVyYXRvciBdKCkge1xuXG5cdFx0eWllbGQgdGhpcy5feDtcblx0XHR5aWVsZCB0aGlzLl95O1xuXHRcdHlpZWxkIHRoaXMuX3o7XG5cdFx0eWllbGQgdGhpcy5fb3JkZXI7XG5cblx0fVxuXG59XG5cbkV1bGVyLkRFRkFVTFRfT1JERVIgPSAnWFlaJztcblxuZXhwb3J0IHsgRXVsZXIgfTtcbiIsImNvbnN0IF9sdXQgPSBbICcwMCcsICcwMScsICcwMicsICcwMycsICcwNCcsICcwNScsICcwNicsICcwNycsICcwOCcsICcwOScsICcwYScsICcwYicsICcwYycsICcwZCcsICcwZScsICcwZicsICcxMCcsICcxMScsICcxMicsICcxMycsICcxNCcsICcxNScsICcxNicsICcxNycsICcxOCcsICcxOScsICcxYScsICcxYicsICcxYycsICcxZCcsICcxZScsICcxZicsICcyMCcsICcyMScsICcyMicsICcyMycsICcyNCcsICcyNScsICcyNicsICcyNycsICcyOCcsICcyOScsICcyYScsICcyYicsICcyYycsICcyZCcsICcyZScsICcyZicsICczMCcsICczMScsICczMicsICczMycsICczNCcsICczNScsICczNicsICczNycsICczOCcsICczOScsICczYScsICczYicsICczYycsICczZCcsICczZScsICczZicsICc0MCcsICc0MScsICc0MicsICc0MycsICc0NCcsICc0NScsICc0NicsICc0NycsICc0OCcsICc0OScsICc0YScsICc0YicsICc0YycsICc0ZCcsICc0ZScsICc0ZicsICc1MCcsICc1MScsICc1MicsICc1MycsICc1NCcsICc1NScsICc1NicsICc1NycsICc1OCcsICc1OScsICc1YScsICc1YicsICc1YycsICc1ZCcsICc1ZScsICc1ZicsICc2MCcsICc2MScsICc2MicsICc2MycsICc2NCcsICc2NScsICc2NicsICc2NycsICc2OCcsICc2OScsICc2YScsICc2YicsICc2YycsICc2ZCcsICc2ZScsICc2ZicsICc3MCcsICc3MScsICc3MicsICc3MycsICc3NCcsICc3NScsICc3NicsICc3NycsICc3OCcsICc3OScsICc3YScsICc3YicsICc3YycsICc3ZCcsICc3ZScsICc3ZicsICc4MCcsICc4MScsICc4MicsICc4MycsICc4NCcsICc4NScsICc4NicsICc4NycsICc4OCcsICc4OScsICc4YScsICc4YicsICc4YycsICc4ZCcsICc4ZScsICc4ZicsICc5MCcsICc5MScsICc5MicsICc5MycsICc5NCcsICc5NScsICc5NicsICc5NycsICc5OCcsICc5OScsICc5YScsICc5YicsICc5YycsICc5ZCcsICc5ZScsICc5ZicsICdhMCcsICdhMScsICdhMicsICdhMycsICdhNCcsICdhNScsICdhNicsICdhNycsICdhOCcsICdhOScsICdhYScsICdhYicsICdhYycsICdhZCcsICdhZScsICdhZicsICdiMCcsICdiMScsICdiMicsICdiMycsICdiNCcsICdiNScsICdiNicsICdiNycsICdiOCcsICdiOScsICdiYScsICdiYicsICdiYycsICdiZCcsICdiZScsICdiZicsICdjMCcsICdjMScsICdjMicsICdjMycsICdjNCcsICdjNScsICdjNicsICdjNycsICdjOCcsICdjOScsICdjYScsICdjYicsICdjYycsICdjZCcsICdjZScsICdjZicsICdkMCcsICdkMScsICdkMicsICdkMycsICdkNCcsICdkNScsICdkNicsICdkNycsICdkOCcsICdkOScsICdkYScsICdkYicsICdkYycsICdkZCcsICdkZScsICdkZicsICdlMCcsICdlMScsICdlMicsICdlMycsICdlNCcsICdlNScsICdlNicsICdlNycsICdlOCcsICdlOScsICdlYScsICdlYicsICdlYycsICdlZCcsICdlZScsICdlZicsICdmMCcsICdmMScsICdmMicsICdmMycsICdmNCcsICdmNScsICdmNicsICdmNycsICdmOCcsICdmOScsICdmYScsICdmYicsICdmYycsICdmZCcsICdmZScsICdmZicgXTtcblxubGV0IF9zZWVkID0gMTIzNDU2NztcblxuXG5jb25zdCBERUcyUkFEID0gTWF0aC5QSSAvIDE4MDtcbmNvbnN0IFJBRDJERUcgPSAxODAgLyBNYXRoLlBJO1xuXG4vLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzEwNTAzNC9ob3ctdG8tY3JlYXRlLWEtZ3VpZC11dWlkLWluLWphdmFzY3JpcHQvMjE5NjMxMzYjMjE5NjMxMzZcbmZ1bmN0aW9uIGdlbmVyYXRlVVVJRCgpIHtcblxuXHRjb25zdCBkMCA9IE1hdGgucmFuZG9tKCkgKiAweGZmZmZmZmZmIHwgMDtcblx0Y29uc3QgZDEgPSBNYXRoLnJhbmRvbSgpICogMHhmZmZmZmZmZiB8IDA7XG5cdGNvbnN0IGQyID0gTWF0aC5yYW5kb20oKSAqIDB4ZmZmZmZmZmYgfCAwO1xuXHRjb25zdCBkMyA9IE1hdGgucmFuZG9tKCkgKiAweGZmZmZmZmZmIHwgMDtcblx0Y29uc3QgdXVpZCA9IF9sdXRbIGQwICYgMHhmZiBdICsgX2x1dFsgZDAgPj4gOCAmIDB4ZmYgXSArIF9sdXRbIGQwID4+IDE2ICYgMHhmZiBdICsgX2x1dFsgZDAgPj4gMjQgJiAweGZmIF0gKyAnLScgK1xuXHRcdFx0X2x1dFsgZDEgJiAweGZmIF0gKyBfbHV0WyBkMSA+PiA4ICYgMHhmZiBdICsgJy0nICsgX2x1dFsgZDEgPj4gMTYgJiAweDBmIHwgMHg0MCBdICsgX2x1dFsgZDEgPj4gMjQgJiAweGZmIF0gKyAnLScgK1xuXHRcdFx0X2x1dFsgZDIgJiAweDNmIHwgMHg4MCBdICsgX2x1dFsgZDIgPj4gOCAmIDB4ZmYgXSArICctJyArIF9sdXRbIGQyID4+IDE2ICYgMHhmZiBdICsgX2x1dFsgZDIgPj4gMjQgJiAweGZmIF0gK1xuXHRcdFx0X2x1dFsgZDMgJiAweGZmIF0gKyBfbHV0WyBkMyA+PiA4ICYgMHhmZiBdICsgX2x1dFsgZDMgPj4gMTYgJiAweGZmIF0gKyBfbHV0WyBkMyA+PiAyNCAmIDB4ZmYgXTtcblxuXHQvLyAudG9Mb3dlckNhc2UoKSBoZXJlIGZsYXR0ZW5zIGNvbmNhdGVuYXRlZCBzdHJpbmdzIHRvIHNhdmUgaGVhcCBtZW1vcnkgc3BhY2UuXG5cdHJldHVybiB1dWlkLnRvTG93ZXJDYXNlKCk7XG5cbn1cblxuZnVuY3Rpb24gY2xhbXAoIHZhbHVlLCBtaW4sIG1heCApIHtcblxuXHRyZXR1cm4gTWF0aC5tYXgoIG1pbiwgTWF0aC5taW4oIG1heCwgdmFsdWUgKSApO1xuXG59XG5cbi8vIGNvbXB1dGUgZXVjbGlkZWFuIG1vZHVsbyBvZiBtICUgblxuLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTW9kdWxvX29wZXJhdGlvblxuZnVuY3Rpb24gZXVjbGlkZWFuTW9kdWxvKCBuLCBtICkge1xuXG5cdHJldHVybiAoICggbiAlIG0gKSArIG0gKSAlIG07XG5cbn1cblxuLy8gTGluZWFyIG1hcHBpbmcgZnJvbSByYW5nZSA8YTEsIGEyPiB0byByYW5nZSA8YjEsIGIyPlxuZnVuY3Rpb24gbWFwTGluZWFyKCB4LCBhMSwgYTIsIGIxLCBiMiApIHtcblxuXHRyZXR1cm4gYjEgKyAoIHggLSBhMSApICogKCBiMiAtIGIxICkgLyAoIGEyIC0gYTEgKTtcblxufVxuXG4vLyBodHRwczovL3d3dy5nYW1lZGV2Lm5ldC90dXRvcmlhbHMvcHJvZ3JhbW1pbmcvZ2VuZXJhbC1hbmQtZ2FtZXBsYXktcHJvZ3JhbW1pbmcvaW52ZXJzZS1sZXJwLWEtc3VwZXItdXNlZnVsLXlldC1vZnRlbi1vdmVybG9va2VkLWZ1bmN0aW9uLXI1MjMwL1xuZnVuY3Rpb24gaW52ZXJzZUxlcnAoIHgsIHksIHZhbHVlICkge1xuXG5cdGlmICggeCAhPT0geSApIHtcblxuXHRcdHJldHVybiAoIHZhbHVlIC0geCApIC8gKCB5IC0geCApO1xuXG5cdH0gZWxzZSB7XG5cblx0XHRyZXR1cm4gMDtcblxuXHR9XG5cbn1cblxuLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGluZWFyX2ludGVycG9sYXRpb25cbmZ1bmN0aW9uIGxlcnAoIHgsIHksIHQgKSB7XG5cblx0cmV0dXJuICggMSAtIHQgKSAqIHggKyB0ICogeTtcblxufVxuXG4vLyBodHRwOi8vd3d3LnJvcnlkcmlzY29sbC5jb20vMjAxNi8wMy8wNy9mcmFtZS1yYXRlLWluZGVwZW5kZW50LWRhbXBpbmctdXNpbmctbGVycC9cbmZ1bmN0aW9uIGRhbXAoIHgsIHksIGxhbWJkYSwgZHQgKSB7XG5cblx0cmV0dXJuIGxlcnAoIHgsIHksIDEgLSBNYXRoLmV4cCggLSBsYW1iZGEgKiBkdCApICk7XG5cbn1cblxuLy8gaHR0cHM6Ly93d3cuZGVzbW9zLmNvbS9jYWxjdWxhdG9yL3Zjc2pueXo3eDRcbmZ1bmN0aW9uIHBpbmdwb25nKCB4LCBsZW5ndGggPSAxICkge1xuXG5cdHJldHVybiBsZW5ndGggLSBNYXRoLmFicyggZXVjbGlkZWFuTW9kdWxvKCB4LCBsZW5ndGggKiAyICkgLSBsZW5ndGggKTtcblxufVxuXG4vLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1Ntb290aHN0ZXBcbmZ1bmN0aW9uIHNtb290aHN0ZXAoIHgsIG1pbiwgbWF4ICkge1xuXG5cdGlmICggeCA8PSBtaW4gKSByZXR1cm4gMDtcblx0aWYgKCB4ID49IG1heCApIHJldHVybiAxO1xuXG5cdHggPSAoIHggLSBtaW4gKSAvICggbWF4IC0gbWluICk7XG5cblx0cmV0dXJuIHggKiB4ICogKCAzIC0gMiAqIHggKTtcblxufVxuXG5mdW5jdGlvbiBzbW9vdGhlcnN0ZXAoIHgsIG1pbiwgbWF4ICkge1xuXG5cdGlmICggeCA8PSBtaW4gKSByZXR1cm4gMDtcblx0aWYgKCB4ID49IG1heCApIHJldHVybiAxO1xuXG5cdHggPSAoIHggLSBtaW4gKSAvICggbWF4IC0gbWluICk7XG5cblx0cmV0dXJuIHggKiB4ICogeCAqICggeCAqICggeCAqIDYgLSAxNSApICsgMTAgKTtcblxufVxuXG4vLyBSYW5kb20gaW50ZWdlciBmcm9tIDxsb3csIGhpZ2g+IGludGVydmFsXG5mdW5jdGlvbiByYW5kSW50KCBsb3csIGhpZ2ggKSB7XG5cblx0cmV0dXJuIGxvdyArIE1hdGguZmxvb3IoIE1hdGgucmFuZG9tKCkgKiAoIGhpZ2ggLSBsb3cgKyAxICkgKTtcblxufVxuXG4vLyBSYW5kb20gZmxvYXQgZnJvbSA8bG93LCBoaWdoPiBpbnRlcnZhbFxuZnVuY3Rpb24gcmFuZEZsb2F0KCBsb3csIGhpZ2ggKSB7XG5cblx0cmV0dXJuIGxvdyArIE1hdGgucmFuZG9tKCkgKiAoIGhpZ2ggLSBsb3cgKTtcblxufVxuXG4vLyBSYW5kb20gZmxvYXQgZnJvbSA8LXJhbmdlLzIsIHJhbmdlLzI+IGludGVydmFsXG5mdW5jdGlvbiByYW5kRmxvYXRTcHJlYWQoIHJhbmdlICkge1xuXG5cdHJldHVybiByYW5nZSAqICggMC41IC0gTWF0aC5yYW5kb20oKSApO1xuXG59XG5cbi8vIERldGVybWluaXN0aWMgcHNldWRvLXJhbmRvbSBmbG9hdCBpbiB0aGUgaW50ZXJ2YWwgWyAwLCAxIF1cbmZ1bmN0aW9uIHNlZWRlZFJhbmRvbSggcyApIHtcblxuXHRpZiAoIHMgIT09IHVuZGVmaW5lZCApIF9zZWVkID0gcztcblxuXHQvLyBNdWxiZXJyeTMyIGdlbmVyYXRvclxuXG5cdGxldCB0ID0gX3NlZWQgKz0gMHg2RDJCNzlGNTtcblxuXHR0ID0gTWF0aC5pbXVsKCB0IF4gdCA+Pj4gMTUsIHQgfCAxICk7XG5cblx0dCBePSB0ICsgTWF0aC5pbXVsKCB0IF4gdCA+Pj4gNywgdCB8IDYxICk7XG5cblx0cmV0dXJuICggKCB0IF4gdCA+Pj4gMTQgKSA+Pj4gMCApIC8gNDI5NDk2NzI5NjtcblxufVxuXG5mdW5jdGlvbiBkZWdUb1JhZCggZGVncmVlcyApIHtcblxuXHRyZXR1cm4gZGVncmVlcyAqIERFRzJSQUQ7XG5cbn1cblxuZnVuY3Rpb24gcmFkVG9EZWcoIHJhZGlhbnMgKSB7XG5cblx0cmV0dXJuIHJhZGlhbnMgKiBSQUQyREVHO1xuXG59XG5cbmZ1bmN0aW9uIGlzUG93ZXJPZlR3byggdmFsdWUgKSB7XG5cblx0cmV0dXJuICggdmFsdWUgJiAoIHZhbHVlIC0gMSApICkgPT09IDAgJiYgdmFsdWUgIT09IDA7XG5cbn1cblxuZnVuY3Rpb24gY2VpbFBvd2VyT2ZUd28oIHZhbHVlICkge1xuXG5cdHJldHVybiBNYXRoLnBvdyggMiwgTWF0aC5jZWlsKCBNYXRoLmxvZyggdmFsdWUgKSAvIE1hdGguTE4yICkgKTtcblxufVxuXG5mdW5jdGlvbiBmbG9vclBvd2VyT2ZUd28oIHZhbHVlICkge1xuXG5cdHJldHVybiBNYXRoLnBvdyggMiwgTWF0aC5mbG9vciggTWF0aC5sb2coIHZhbHVlICkgLyBNYXRoLkxOMiApICk7XG5cbn1cblxuZnVuY3Rpb24gc2V0UXVhdGVybmlvbkZyb21Qcm9wZXJFdWxlciggcSwgYSwgYiwgYywgb3JkZXIgKSB7XG5cblx0Ly8gSW50cmluc2ljIFByb3BlciBFdWxlciBBbmdsZXMgLSBzZWUgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRXVsZXJfYW5nbGVzXG5cblx0Ly8gcm90YXRpb25zIGFyZSBhcHBsaWVkIHRvIHRoZSBheGVzIGluIHRoZSBvcmRlciBzcGVjaWZpZWQgYnkgJ29yZGVyJ1xuXHQvLyByb3RhdGlvbiBieSBhbmdsZSAnYScgaXMgYXBwbGllZCBmaXJzdCwgdGhlbiBieSBhbmdsZSAnYicsIHRoZW4gYnkgYW5nbGUgJ2MnXG5cdC8vIGFuZ2xlcyBhcmUgaW4gcmFkaWFuc1xuXG5cdGNvbnN0IGNvcyA9IE1hdGguY29zO1xuXHRjb25zdCBzaW4gPSBNYXRoLnNpbjtcblxuXHRjb25zdCBjMiA9IGNvcyggYiAvIDIgKTtcblx0Y29uc3QgczIgPSBzaW4oIGIgLyAyICk7XG5cblx0Y29uc3QgYzEzID0gY29zKCAoIGEgKyBjICkgLyAyICk7XG5cdGNvbnN0IHMxMyA9IHNpbiggKCBhICsgYyApIC8gMiApO1xuXG5cdGNvbnN0IGMxXzMgPSBjb3MoICggYSAtIGMgKSAvIDIgKTtcblx0Y29uc3QgczFfMyA9IHNpbiggKCBhIC0gYyApIC8gMiApO1xuXG5cdGNvbnN0IGMzXzEgPSBjb3MoICggYyAtIGEgKSAvIDIgKTtcblx0Y29uc3QgczNfMSA9IHNpbiggKCBjIC0gYSApIC8gMiApO1xuXG5cdHN3aXRjaCAoIG9yZGVyICkge1xuXG5cdFx0Y2FzZSAnWFlYJzpcblx0XHRcdHEuc2V0KCBjMiAqIHMxMywgczIgKiBjMV8zLCBzMiAqIHMxXzMsIGMyICogYzEzICk7XG5cdFx0XHRicmVhaztcblxuXHRcdGNhc2UgJ1laWSc6XG5cdFx0XHRxLnNldCggczIgKiBzMV8zLCBjMiAqIHMxMywgczIgKiBjMV8zLCBjMiAqIGMxMyApO1xuXHRcdFx0YnJlYWs7XG5cblx0XHRjYXNlICdaWFonOlxuXHRcdFx0cS5zZXQoIHMyICogYzFfMywgczIgKiBzMV8zLCBjMiAqIHMxMywgYzIgKiBjMTMgKTtcblx0XHRcdGJyZWFrO1xuXG5cdFx0Y2FzZSAnWFpYJzpcblx0XHRcdHEuc2V0KCBjMiAqIHMxMywgczIgKiBzM18xLCBzMiAqIGMzXzEsIGMyICogYzEzICk7XG5cdFx0XHRicmVhaztcblxuXHRcdGNhc2UgJ1lYWSc6XG5cdFx0XHRxLnNldCggczIgKiBjM18xLCBjMiAqIHMxMywgczIgKiBzM18xLCBjMiAqIGMxMyApO1xuXHRcdFx0YnJlYWs7XG5cblx0XHRjYXNlICdaWVonOlxuXHRcdFx0cS5zZXQoIHMyICogczNfMSwgczIgKiBjM18xLCBjMiAqIHMxMywgYzIgKiBjMTMgKTtcblx0XHRcdGJyZWFrO1xuXG5cdFx0ZGVmYXVsdDpcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk1hdGhVdGlsczogLnNldFF1YXRlcm5pb25Gcm9tUHJvcGVyRXVsZXIoKSBlbmNvdW50ZXJlZCBhbiB1bmtub3duIG9yZGVyOiAnICsgb3JkZXIgKTtcblxuXHR9XG5cbn1cblxuZnVuY3Rpb24gZGVub3JtYWxpemUoIHZhbHVlLCBhcnJheSApIHtcblxuXHRzd2l0Y2ggKCBhcnJheS5jb25zdHJ1Y3RvciApIHtcblxuXHRcdGNhc2UgRmxvYXQzMkFycmF5OlxuXG5cdFx0XHRyZXR1cm4gdmFsdWU7XG5cblx0XHRjYXNlIFVpbnQzMkFycmF5OlxuXG5cdFx0XHRyZXR1cm4gdmFsdWUgLyA0Mjk0OTY3Mjk1LjA7XG5cblx0XHRjYXNlIFVpbnQxNkFycmF5OlxuXG5cdFx0XHRyZXR1cm4gdmFsdWUgLyA2NTUzNS4wO1xuXG5cdFx0Y2FzZSBVaW50OEFycmF5OlxuXG5cdFx0XHRyZXR1cm4gdmFsdWUgLyAyNTUuMDtcblxuXHRcdGNhc2UgSW50MzJBcnJheTpcblxuXHRcdFx0cmV0dXJuIE1hdGgubWF4KCB2YWx1ZSAvIDIxNDc0ODM2NDcuMCwgLSAxLjAgKTtcblxuXHRcdGNhc2UgSW50MTZBcnJheTpcblxuXHRcdFx0cmV0dXJuIE1hdGgubWF4KCB2YWx1ZSAvIDMyNzY3LjAsIC0gMS4wICk7XG5cblx0XHRjYXNlIEludDhBcnJheTpcblxuXHRcdFx0cmV0dXJuIE1hdGgubWF4KCB2YWx1ZSAvIDEyNy4wLCAtIDEuMCApO1xuXG5cdFx0ZGVmYXVsdDpcblxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnSW52YWxpZCBjb21wb25lbnQgdHlwZS4nICk7XG5cblx0fVxuXG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZSggdmFsdWUsIGFycmF5ICkge1xuXG5cdHN3aXRjaCAoIGFycmF5LmNvbnN0cnVjdG9yICkge1xuXG5cdFx0Y2FzZSBGbG9hdDMyQXJyYXk6XG5cblx0XHRcdHJldHVybiB2YWx1ZTtcblxuXHRcdGNhc2UgVWludDMyQXJyYXk6XG5cblx0XHRcdHJldHVybiBNYXRoLnJvdW5kKCB2YWx1ZSAqIDQyOTQ5NjcyOTUuMCApO1xuXG5cdFx0Y2FzZSBVaW50MTZBcnJheTpcblxuXHRcdFx0cmV0dXJuIE1hdGgucm91bmQoIHZhbHVlICogNjU1MzUuMCApO1xuXG5cdFx0Y2FzZSBVaW50OEFycmF5OlxuXG5cdFx0XHRyZXR1cm4gTWF0aC5yb3VuZCggdmFsdWUgKiAyNTUuMCApO1xuXG5cdFx0Y2FzZSBJbnQzMkFycmF5OlxuXG5cdFx0XHRyZXR1cm4gTWF0aC5yb3VuZCggdmFsdWUgKiAyMTQ3NDgzNjQ3LjAgKTtcblxuXHRcdGNhc2UgSW50MTZBcnJheTpcblxuXHRcdFx0cmV0dXJuIE1hdGgucm91bmQoIHZhbHVlICogMzI3NjcuMCApO1xuXG5cdFx0Y2FzZSBJbnQ4QXJyYXk6XG5cblx0XHRcdHJldHVybiBNYXRoLnJvdW5kKCB2YWx1ZSAqIDEyNy4wICk7XG5cblx0XHRkZWZhdWx0OlxuXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdJbnZhbGlkIGNvbXBvbmVudCB0eXBlLicgKTtcblxuXHR9XG5cbn1cblxuY29uc3QgTWF0aFV0aWxzID0ge1xuXHRERUcyUkFEOiBERUcyUkFELFxuXHRSQUQyREVHOiBSQUQyREVHLFxuXHRnZW5lcmF0ZVVVSUQ6IGdlbmVyYXRlVVVJRCxcblx0Y2xhbXA6IGNsYW1wLFxuXHRldWNsaWRlYW5Nb2R1bG86IGV1Y2xpZGVhbk1vZHVsbyxcblx0bWFwTGluZWFyOiBtYXBMaW5lYXIsXG5cdGludmVyc2VMZXJwOiBpbnZlcnNlTGVycCxcblx0bGVycDogbGVycCxcblx0ZGFtcDogZGFtcCxcblx0cGluZ3Bvbmc6IHBpbmdwb25nLFxuXHRzbW9vdGhzdGVwOiBzbW9vdGhzdGVwLFxuXHRzbW9vdGhlcnN0ZXA6IHNtb290aGVyc3RlcCxcblx0cmFuZEludDogcmFuZEludCxcblx0cmFuZEZsb2F0OiByYW5kRmxvYXQsXG5cdHJhbmRGbG9hdFNwcmVhZDogcmFuZEZsb2F0U3ByZWFkLFxuXHRzZWVkZWRSYW5kb206IHNlZWRlZFJhbmRvbSxcblx0ZGVnVG9SYWQ6IGRlZ1RvUmFkLFxuXHRyYWRUb0RlZzogcmFkVG9EZWcsXG5cdGlzUG93ZXJPZlR3bzogaXNQb3dlck9mVHdvLFxuXHRjZWlsUG93ZXJPZlR3bzogY2VpbFBvd2VyT2ZUd28sXG5cdGZsb29yUG93ZXJPZlR3bzogZmxvb3JQb3dlck9mVHdvLFxuXHRzZXRRdWF0ZXJuaW9uRnJvbVByb3BlckV1bGVyOiBzZXRRdWF0ZXJuaW9uRnJvbVByb3BlckV1bGVyLFxuXHRub3JtYWxpemU6IG5vcm1hbGl6ZSxcblx0ZGVub3JtYWxpemU6IGRlbm9ybWFsaXplXG59O1xuXG5leHBvcnQge1xuXHRERUcyUkFELFxuXHRSQUQyREVHLFxuXHRnZW5lcmF0ZVVVSUQsXG5cdGNsYW1wLFxuXHRldWNsaWRlYW5Nb2R1bG8sXG5cdG1hcExpbmVhcixcblx0aW52ZXJzZUxlcnAsXG5cdGxlcnAsXG5cdGRhbXAsXG5cdHBpbmdwb25nLFxuXHRzbW9vdGhzdGVwLFxuXHRzbW9vdGhlcnN0ZXAsXG5cdHJhbmRJbnQsXG5cdHJhbmRGbG9hdCxcblx0cmFuZEZsb2F0U3ByZWFkLFxuXHRzZWVkZWRSYW5kb20sXG5cdGRlZ1RvUmFkLFxuXHRyYWRUb0RlZyxcblx0aXNQb3dlck9mVHdvLFxuXHRjZWlsUG93ZXJPZlR3byxcblx0Zmxvb3JQb3dlck9mVHdvLFxuXHRzZXRRdWF0ZXJuaW9uRnJvbVByb3BlckV1bGVyLFxuXHRub3JtYWxpemUsXG5cdGRlbm9ybWFsaXplLFxuXHRNYXRoVXRpbHNcbn07XG4iLCJjbGFzcyBNYXRyaXgzIHtcblxuXHRjb25zdHJ1Y3RvciggbjExLCBuMTIsIG4xMywgbjIxLCBuMjIsIG4yMywgbjMxLCBuMzIsIG4zMyApIHtcblxuXHRcdE1hdHJpeDMucHJvdG90eXBlLmlzTWF0cml4MyA9IHRydWU7XG5cblx0XHR0aGlzLmVsZW1lbnRzID0gW1xuXG5cdFx0XHQxLCAwLCAwLFxuXHRcdFx0MCwgMSwgMCxcblx0XHRcdDAsIDAsIDFcblxuXHRcdF07XG5cblx0XHRpZiAoIG4xMSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHR0aGlzLnNldCggbjExLCBuMTIsIG4xMywgbjIxLCBuMjIsIG4yMywgbjMxLCBuMzIsIG4zMyApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRzZXQoIG4xMSwgbjEyLCBuMTMsIG4yMSwgbjIyLCBuMjMsIG4zMSwgbjMyLCBuMzMgKSB7XG5cblx0XHRjb25zdCB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cblx0XHR0ZVsgMCBdID0gbjExOyB0ZVsgMSBdID0gbjIxOyB0ZVsgMiBdID0gbjMxO1xuXHRcdHRlWyAzIF0gPSBuMTI7IHRlWyA0IF0gPSBuMjI7IHRlWyA1IF0gPSBuMzI7XG5cdFx0dGVbIDYgXSA9IG4xMzsgdGVbIDcgXSA9IG4yMzsgdGVbIDggXSA9IG4zMztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRpZGVudGl0eSgpIHtcblxuXHRcdHRoaXMuc2V0KFxuXG5cdFx0XHQxLCAwLCAwLFxuXHRcdFx0MCwgMSwgMCxcblx0XHRcdDAsIDAsIDFcblxuXHRcdCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Y29weSggbSApIHtcblxuXHRcdGNvbnN0IHRlID0gdGhpcy5lbGVtZW50cztcblx0XHRjb25zdCBtZSA9IG0uZWxlbWVudHM7XG5cblx0XHR0ZVsgMCBdID0gbWVbIDAgXTsgdGVbIDEgXSA9IG1lWyAxIF07IHRlWyAyIF0gPSBtZVsgMiBdO1xuXHRcdHRlWyAzIF0gPSBtZVsgMyBdOyB0ZVsgNCBdID0gbWVbIDQgXTsgdGVbIDUgXSA9IG1lWyA1IF07XG5cdFx0dGVbIDYgXSA9IG1lWyA2IF07IHRlWyA3IF0gPSBtZVsgNyBdOyB0ZVsgOCBdID0gbWVbIDggXTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRleHRyYWN0QmFzaXMoIHhBeGlzLCB5QXhpcywgekF4aXMgKSB7XG5cblx0XHR4QXhpcy5zZXRGcm9tTWF0cml4M0NvbHVtbiggdGhpcywgMCApO1xuXHRcdHlBeGlzLnNldEZyb21NYXRyaXgzQ29sdW1uKCB0aGlzLCAxICk7XG5cdFx0ekF4aXMuc2V0RnJvbU1hdHJpeDNDb2x1bW4oIHRoaXMsIDIgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzZXRGcm9tTWF0cml4NCggbSApIHtcblxuXHRcdGNvbnN0IG1lID0gbS5lbGVtZW50cztcblxuXHRcdHRoaXMuc2V0KFxuXG5cdFx0XHRtZVsgMCBdLCBtZVsgNCBdLCBtZVsgOCBdLFxuXHRcdFx0bWVbIDEgXSwgbWVbIDUgXSwgbWVbIDkgXSxcblx0XHRcdG1lWyAyIF0sIG1lWyA2IF0sIG1lWyAxMCBdXG5cblx0XHQpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdG11bHRpcGx5KCBtICkge1xuXG5cdFx0cmV0dXJuIHRoaXMubXVsdGlwbHlNYXRyaWNlcyggdGhpcywgbSApO1xuXG5cdH1cblxuXHRwcmVtdWx0aXBseSggbSApIHtcblxuXHRcdHJldHVybiB0aGlzLm11bHRpcGx5TWF0cmljZXMoIG0sIHRoaXMgKTtcblxuXHR9XG5cblx0bXVsdGlwbHlNYXRyaWNlcyggYSwgYiApIHtcblxuXHRcdGNvbnN0IGFlID0gYS5lbGVtZW50cztcblx0XHRjb25zdCBiZSA9IGIuZWxlbWVudHM7XG5cdFx0Y29uc3QgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG5cdFx0Y29uc3QgYTExID0gYWVbIDAgXSwgYTEyID0gYWVbIDMgXSwgYTEzID0gYWVbIDYgXTtcblx0XHRjb25zdCBhMjEgPSBhZVsgMSBdLCBhMjIgPSBhZVsgNCBdLCBhMjMgPSBhZVsgNyBdO1xuXHRcdGNvbnN0IGEzMSA9IGFlWyAyIF0sIGEzMiA9IGFlWyA1IF0sIGEzMyA9IGFlWyA4IF07XG5cblx0XHRjb25zdCBiMTEgPSBiZVsgMCBdLCBiMTIgPSBiZVsgMyBdLCBiMTMgPSBiZVsgNiBdO1xuXHRcdGNvbnN0IGIyMSA9IGJlWyAxIF0sIGIyMiA9IGJlWyA0IF0sIGIyMyA9IGJlWyA3IF07XG5cdFx0Y29uc3QgYjMxID0gYmVbIDIgXSwgYjMyID0gYmVbIDUgXSwgYjMzID0gYmVbIDggXTtcblxuXHRcdHRlWyAwIF0gPSBhMTEgKiBiMTEgKyBhMTIgKiBiMjEgKyBhMTMgKiBiMzE7XG5cdFx0dGVbIDMgXSA9IGExMSAqIGIxMiArIGExMiAqIGIyMiArIGExMyAqIGIzMjtcblx0XHR0ZVsgNiBdID0gYTExICogYjEzICsgYTEyICogYjIzICsgYTEzICogYjMzO1xuXG5cdFx0dGVbIDEgXSA9IGEyMSAqIGIxMSArIGEyMiAqIGIyMSArIGEyMyAqIGIzMTtcblx0XHR0ZVsgNCBdID0gYTIxICogYjEyICsgYTIyICogYjIyICsgYTIzICogYjMyO1xuXHRcdHRlWyA3IF0gPSBhMjEgKiBiMTMgKyBhMjIgKiBiMjMgKyBhMjMgKiBiMzM7XG5cblx0XHR0ZVsgMiBdID0gYTMxICogYjExICsgYTMyICogYjIxICsgYTMzICogYjMxO1xuXHRcdHRlWyA1IF0gPSBhMzEgKiBiMTIgKyBhMzIgKiBiMjIgKyBhMzMgKiBiMzI7XG5cdFx0dGVbIDggXSA9IGEzMSAqIGIxMyArIGEzMiAqIGIyMyArIGEzMyAqIGIzMztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRtdWx0aXBseVNjYWxhciggcyApIHtcblxuXHRcdGNvbnN0IHRlID0gdGhpcy5lbGVtZW50cztcblxuXHRcdHRlWyAwIF0gKj0gczsgdGVbIDMgXSAqPSBzOyB0ZVsgNiBdICo9IHM7XG5cdFx0dGVbIDEgXSAqPSBzOyB0ZVsgNCBdICo9IHM7IHRlWyA3IF0gKj0gcztcblx0XHR0ZVsgMiBdICo9IHM7IHRlWyA1IF0gKj0gczsgdGVbIDggXSAqPSBzO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGRldGVybWluYW50KCkge1xuXG5cdFx0Y29uc3QgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG5cdFx0Y29uc3QgYSA9IHRlWyAwIF0sIGIgPSB0ZVsgMSBdLCBjID0gdGVbIDIgXSxcblx0XHRcdGQgPSB0ZVsgMyBdLCBlID0gdGVbIDQgXSwgZiA9IHRlWyA1IF0sXG5cdFx0XHRnID0gdGVbIDYgXSwgaCA9IHRlWyA3IF0sIGkgPSB0ZVsgOCBdO1xuXG5cdFx0cmV0dXJuIGEgKiBlICogaSAtIGEgKiBmICogaCAtIGIgKiBkICogaSArIGIgKiBmICogZyArIGMgKiBkICogaCAtIGMgKiBlICogZztcblxuXHR9XG5cblx0aW52ZXJ0KCkge1xuXG5cdFx0Y29uc3QgdGUgPSB0aGlzLmVsZW1lbnRzLFxuXG5cdFx0XHRuMTEgPSB0ZVsgMCBdLCBuMjEgPSB0ZVsgMSBdLCBuMzEgPSB0ZVsgMiBdLFxuXHRcdFx0bjEyID0gdGVbIDMgXSwgbjIyID0gdGVbIDQgXSwgbjMyID0gdGVbIDUgXSxcblx0XHRcdG4xMyA9IHRlWyA2IF0sIG4yMyA9IHRlWyA3IF0sIG4zMyA9IHRlWyA4IF0sXG5cblx0XHRcdHQxMSA9IG4zMyAqIG4yMiAtIG4zMiAqIG4yMyxcblx0XHRcdHQxMiA9IG4zMiAqIG4xMyAtIG4zMyAqIG4xMixcblx0XHRcdHQxMyA9IG4yMyAqIG4xMiAtIG4yMiAqIG4xMyxcblxuXHRcdFx0ZGV0ID0gbjExICogdDExICsgbjIxICogdDEyICsgbjMxICogdDEzO1xuXG5cdFx0aWYgKCBkZXQgPT09IDAgKSByZXR1cm4gdGhpcy5zZXQoIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAgKTtcblxuXHRcdGNvbnN0IGRldEludiA9IDEgLyBkZXQ7XG5cblx0XHR0ZVsgMCBdID0gdDExICogZGV0SW52O1xuXHRcdHRlWyAxIF0gPSAoIG4zMSAqIG4yMyAtIG4zMyAqIG4yMSApICogZGV0SW52O1xuXHRcdHRlWyAyIF0gPSAoIG4zMiAqIG4yMSAtIG4zMSAqIG4yMiApICogZGV0SW52O1xuXG5cdFx0dGVbIDMgXSA9IHQxMiAqIGRldEludjtcblx0XHR0ZVsgNCBdID0gKCBuMzMgKiBuMTEgLSBuMzEgKiBuMTMgKSAqIGRldEludjtcblx0XHR0ZVsgNSBdID0gKCBuMzEgKiBuMTIgLSBuMzIgKiBuMTEgKSAqIGRldEludjtcblxuXHRcdHRlWyA2IF0gPSB0MTMgKiBkZXRJbnY7XG5cdFx0dGVbIDcgXSA9ICggbjIxICogbjEzIC0gbjIzICogbjExICkgKiBkZXRJbnY7XG5cdFx0dGVbIDggXSA9ICggbjIyICogbjExIC0gbjIxICogbjEyICkgKiBkZXRJbnY7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0dHJhbnNwb3NlKCkge1xuXG5cdFx0bGV0IHRtcDtcblx0XHRjb25zdCBtID0gdGhpcy5lbGVtZW50cztcblxuXHRcdHRtcCA9IG1bIDEgXTsgbVsgMSBdID0gbVsgMyBdOyBtWyAzIF0gPSB0bXA7XG5cdFx0dG1wID0gbVsgMiBdOyBtWyAyIF0gPSBtWyA2IF07IG1bIDYgXSA9IHRtcDtcblx0XHR0bXAgPSBtWyA1IF07IG1bIDUgXSA9IG1bIDcgXTsgbVsgNyBdID0gdG1wO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGdldE5vcm1hbE1hdHJpeCggbWF0cml4NCApIHtcblxuXHRcdHJldHVybiB0aGlzLnNldEZyb21NYXRyaXg0KCBtYXRyaXg0ICkuaW52ZXJ0KCkudHJhbnNwb3NlKCk7XG5cblx0fVxuXG5cdHRyYW5zcG9zZUludG9BcnJheSggciApIHtcblxuXHRcdGNvbnN0IG0gPSB0aGlzLmVsZW1lbnRzO1xuXG5cdFx0clsgMCBdID0gbVsgMCBdO1xuXHRcdHJbIDEgXSA9IG1bIDMgXTtcblx0XHRyWyAyIF0gPSBtWyA2IF07XG5cdFx0clsgMyBdID0gbVsgMSBdO1xuXHRcdHJbIDQgXSA9IG1bIDQgXTtcblx0XHRyWyA1IF0gPSBtWyA3IF07XG5cdFx0clsgNiBdID0gbVsgMiBdO1xuXHRcdHJbIDcgXSA9IG1bIDUgXTtcblx0XHRyWyA4IF0gPSBtWyA4IF07XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c2V0VXZUcmFuc2Zvcm0oIHR4LCB0eSwgc3gsIHN5LCByb3RhdGlvbiwgY3gsIGN5ICkge1xuXG5cdFx0Y29uc3QgYyA9IE1hdGguY29zKCByb3RhdGlvbiApO1xuXHRcdGNvbnN0IHMgPSBNYXRoLnNpbiggcm90YXRpb24gKTtcblxuXHRcdHRoaXMuc2V0KFxuXHRcdFx0c3ggKiBjLCBzeCAqIHMsIC0gc3ggKiAoIGMgKiBjeCArIHMgKiBjeSApICsgY3ggKyB0eCxcblx0XHRcdC0gc3kgKiBzLCBzeSAqIGMsIC0gc3kgKiAoIC0gcyAqIGN4ICsgYyAqIGN5ICkgKyBjeSArIHR5LFxuXHRcdFx0MCwgMCwgMVxuXHRcdCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Ly9cblxuXHRzY2FsZSggc3gsIHN5ICkge1xuXG5cdFx0dGhpcy5wcmVtdWx0aXBseSggX20zLm1ha2VTY2FsZSggc3gsIHN5ICkgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRyb3RhdGUoIHRoZXRhICkge1xuXG5cdFx0dGhpcy5wcmVtdWx0aXBseSggX20zLm1ha2VSb3RhdGlvbiggLSB0aGV0YSApICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0dHJhbnNsYXRlKCB0eCwgdHkgKSB7XG5cblx0XHR0aGlzLnByZW11bHRpcGx5KCBfbTMubWFrZVRyYW5zbGF0aW9uKCB0eCwgdHkgKSApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8vIGZvciAyRCBUcmFuc2Zvcm1zXG5cblx0bWFrZVRyYW5zbGF0aW9uKCB4LCB5ICkge1xuXG5cdFx0aWYgKCB4LmlzVmVjdG9yMiApIHtcblxuXHRcdFx0dGhpcy5zZXQoXG5cblx0XHRcdFx0MSwgMCwgeC54LFxuXHRcdFx0XHQwLCAxLCB4LnksXG5cdFx0XHRcdDAsIDAsIDFcblxuXHRcdFx0KTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHRoaXMuc2V0KFxuXG5cdFx0XHRcdDEsIDAsIHgsXG5cdFx0XHRcdDAsIDEsIHksXG5cdFx0XHRcdDAsIDAsIDFcblxuXHRcdFx0KTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRtYWtlUm90YXRpb24oIHRoZXRhICkge1xuXG5cdFx0Ly8gY291bnRlcmNsb2Nrd2lzZVxuXG5cdFx0Y29uc3QgYyA9IE1hdGguY29zKCB0aGV0YSApO1xuXHRcdGNvbnN0IHMgPSBNYXRoLnNpbiggdGhldGEgKTtcblxuXHRcdHRoaXMuc2V0KFxuXG5cdFx0XHRjLCAtIHMsIDAsXG5cdFx0XHRzLCBjLCAwLFxuXHRcdFx0MCwgMCwgMVxuXG5cdFx0KTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRtYWtlU2NhbGUoIHgsIHkgKSB7XG5cblx0XHR0aGlzLnNldChcblxuXHRcdFx0eCwgMCwgMCxcblx0XHRcdDAsIHksIDAsXG5cdFx0XHQwLCAwLCAxXG5cblx0XHQpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdC8vXG5cblx0ZXF1YWxzKCBtYXRyaXggKSB7XG5cblx0XHRjb25zdCB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cdFx0Y29uc3QgbWUgPSBtYXRyaXguZWxlbWVudHM7XG5cblx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCA5OyBpICsrICkge1xuXG5cdFx0XHRpZiAoIHRlWyBpIF0gIT09IG1lWyBpIF0gKSByZXR1cm4gZmFsc2U7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblxuXHR9XG5cblx0ZnJvbUFycmF5KCBhcnJheSwgb2Zmc2V0ID0gMCApIHtcblxuXHRcdGZvciAoIGxldCBpID0gMDsgaSA8IDk7IGkgKysgKSB7XG5cblx0XHRcdHRoaXMuZWxlbWVudHNbIGkgXSA9IGFycmF5WyBpICsgb2Zmc2V0IF07XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0dG9BcnJheSggYXJyYXkgPSBbXSwgb2Zmc2V0ID0gMCApIHtcblxuXHRcdGNvbnN0IHRlID0gdGhpcy5lbGVtZW50cztcblxuXHRcdGFycmF5WyBvZmZzZXQgXSA9IHRlWyAwIF07XG5cdFx0YXJyYXlbIG9mZnNldCArIDEgXSA9IHRlWyAxIF07XG5cdFx0YXJyYXlbIG9mZnNldCArIDIgXSA9IHRlWyAyIF07XG5cblx0XHRhcnJheVsgb2Zmc2V0ICsgMyBdID0gdGVbIDMgXTtcblx0XHRhcnJheVsgb2Zmc2V0ICsgNCBdID0gdGVbIDQgXTtcblx0XHRhcnJheVsgb2Zmc2V0ICsgNSBdID0gdGVbIDUgXTtcblxuXHRcdGFycmF5WyBvZmZzZXQgKyA2IF0gPSB0ZVsgNiBdO1xuXHRcdGFycmF5WyBvZmZzZXQgKyA3IF0gPSB0ZVsgNyBdO1xuXHRcdGFycmF5WyBvZmZzZXQgKyA4IF0gPSB0ZVsgOCBdO1xuXG5cdFx0cmV0dXJuIGFycmF5O1xuXG5cdH1cblxuXHRjbG9uZSgpIHtcblxuXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmZyb21BcnJheSggdGhpcy5lbGVtZW50cyApO1xuXG5cdH1cblxufVxuXG5jb25zdCBfbTMgPSAvKkBfX1BVUkVfXyovIG5ldyBNYXRyaXgzKCk7XG5cbmV4cG9ydCB7IE1hdHJpeDMgfTtcbiIsImltcG9ydCB7IFdlYkdMQ29vcmRpbmF0ZVN5c3RlbSwgV2ViR1BVQ29vcmRpbmF0ZVN5c3RlbSB9IGZyb20gJy4uL2NvbnN0YW50cy5qcyc7XG5pbXBvcnQgeyBWZWN0b3IzIH0gZnJvbSAnLi9WZWN0b3IzLmpzJztcblxuY2xhc3MgTWF0cml4NCB7XG5cblx0Y29uc3RydWN0b3IoIG4xMSwgbjEyLCBuMTMsIG4xNCwgbjIxLCBuMjIsIG4yMywgbjI0LCBuMzEsIG4zMiwgbjMzLCBuMzQsIG40MSwgbjQyLCBuNDMsIG40NCApIHtcblxuXHRcdE1hdHJpeDQucHJvdG90eXBlLmlzTWF0cml4NCA9IHRydWU7XG5cblx0XHR0aGlzLmVsZW1lbnRzID0gW1xuXG5cdFx0XHQxLCAwLCAwLCAwLFxuXHRcdFx0MCwgMSwgMCwgMCxcblx0XHRcdDAsIDAsIDEsIDAsXG5cdFx0XHQwLCAwLCAwLCAxXG5cblx0XHRdO1xuXG5cdFx0aWYgKCBuMTEgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0dGhpcy5zZXQoIG4xMSwgbjEyLCBuMTMsIG4xNCwgbjIxLCBuMjIsIG4yMywgbjI0LCBuMzEsIG4zMiwgbjMzLCBuMzQsIG40MSwgbjQyLCBuNDMsIG40NCApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRzZXQoIG4xMSwgbjEyLCBuMTMsIG4xNCwgbjIxLCBuMjIsIG4yMywgbjI0LCBuMzEsIG4zMiwgbjMzLCBuMzQsIG40MSwgbjQyLCBuNDMsIG40NCApIHtcblxuXHRcdGNvbnN0IHRlID0gdGhpcy5lbGVtZW50cztcblxuXHRcdHRlWyAwIF0gPSBuMTE7IHRlWyA0IF0gPSBuMTI7IHRlWyA4IF0gPSBuMTM7IHRlWyAxMiBdID0gbjE0O1xuXHRcdHRlWyAxIF0gPSBuMjE7IHRlWyA1IF0gPSBuMjI7IHRlWyA5IF0gPSBuMjM7IHRlWyAxMyBdID0gbjI0O1xuXHRcdHRlWyAyIF0gPSBuMzE7IHRlWyA2IF0gPSBuMzI7IHRlWyAxMCBdID0gbjMzOyB0ZVsgMTQgXSA9IG4zNDtcblx0XHR0ZVsgMyBdID0gbjQxOyB0ZVsgNyBdID0gbjQyOyB0ZVsgMTEgXSA9IG40MzsgdGVbIDE1IF0gPSBuNDQ7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0aWRlbnRpdHkoKSB7XG5cblx0XHR0aGlzLnNldChcblxuXHRcdFx0MSwgMCwgMCwgMCxcblx0XHRcdDAsIDEsIDAsIDAsXG5cdFx0XHQwLCAwLCAxLCAwLFxuXHRcdFx0MCwgMCwgMCwgMVxuXG5cdFx0KTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRjbG9uZSgpIHtcblxuXHRcdHJldHVybiBuZXcgTWF0cml4NCgpLmZyb21BcnJheSggdGhpcy5lbGVtZW50cyApO1xuXG5cdH1cblxuXHRjb3B5KCBtICkge1xuXG5cdFx0Y29uc3QgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXHRcdGNvbnN0IG1lID0gbS5lbGVtZW50cztcblxuXHRcdHRlWyAwIF0gPSBtZVsgMCBdOyB0ZVsgMSBdID0gbWVbIDEgXTsgdGVbIDIgXSA9IG1lWyAyIF07IHRlWyAzIF0gPSBtZVsgMyBdO1xuXHRcdHRlWyA0IF0gPSBtZVsgNCBdOyB0ZVsgNSBdID0gbWVbIDUgXTsgdGVbIDYgXSA9IG1lWyA2IF07IHRlWyA3IF0gPSBtZVsgNyBdO1xuXHRcdHRlWyA4IF0gPSBtZVsgOCBdOyB0ZVsgOSBdID0gbWVbIDkgXTsgdGVbIDEwIF0gPSBtZVsgMTAgXTsgdGVbIDExIF0gPSBtZVsgMTEgXTtcblx0XHR0ZVsgMTIgXSA9IG1lWyAxMiBdOyB0ZVsgMTMgXSA9IG1lWyAxMyBdOyB0ZVsgMTQgXSA9IG1lWyAxNCBdOyB0ZVsgMTUgXSA9IG1lWyAxNSBdO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGNvcHlQb3NpdGlvbiggbSApIHtcblxuXHRcdGNvbnN0IHRlID0gdGhpcy5lbGVtZW50cywgbWUgPSBtLmVsZW1lbnRzO1xuXG5cdFx0dGVbIDEyIF0gPSBtZVsgMTIgXTtcblx0XHR0ZVsgMTMgXSA9IG1lWyAxMyBdO1xuXHRcdHRlWyAxNCBdID0gbWVbIDE0IF07XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c2V0RnJvbU1hdHJpeDMoIG0gKSB7XG5cblx0XHRjb25zdCBtZSA9IG0uZWxlbWVudHM7XG5cblx0XHR0aGlzLnNldChcblxuXHRcdFx0bWVbIDAgXSwgbWVbIDMgXSwgbWVbIDYgXSwgMCxcblx0XHRcdG1lWyAxIF0sIG1lWyA0IF0sIG1lWyA3IF0sIDAsXG5cdFx0XHRtZVsgMiBdLCBtZVsgNSBdLCBtZVsgOCBdLCAwLFxuXHRcdFx0MCwgMCwgMCwgMVxuXG5cdFx0KTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRleHRyYWN0QmFzaXMoIHhBeGlzLCB5QXhpcywgekF4aXMgKSB7XG5cblx0XHR4QXhpcy5zZXRGcm9tTWF0cml4Q29sdW1uKCB0aGlzLCAwICk7XG5cdFx0eUF4aXMuc2V0RnJvbU1hdHJpeENvbHVtbiggdGhpcywgMSApO1xuXHRcdHpBeGlzLnNldEZyb21NYXRyaXhDb2x1bW4oIHRoaXMsIDIgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRtYWtlQmFzaXMoIHhBeGlzLCB5QXhpcywgekF4aXMgKSB7XG5cblx0XHR0aGlzLnNldChcblx0XHRcdHhBeGlzLngsIHlBeGlzLngsIHpBeGlzLngsIDAsXG5cdFx0XHR4QXhpcy55LCB5QXhpcy55LCB6QXhpcy55LCAwLFxuXHRcdFx0eEF4aXMueiwgeUF4aXMueiwgekF4aXMueiwgMCxcblx0XHRcdDAsIDAsIDAsIDFcblx0XHQpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGV4dHJhY3RSb3RhdGlvbiggbSApIHtcblxuXHRcdC8vIHRoaXMgbWV0aG9kIGRvZXMgbm90IHN1cHBvcnQgcmVmbGVjdGlvbiBtYXRyaWNlc1xuXG5cdFx0Y29uc3QgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXHRcdGNvbnN0IG1lID0gbS5lbGVtZW50cztcblxuXHRcdGNvbnN0IHNjYWxlWCA9IDEgLyBfdjEuc2V0RnJvbU1hdHJpeENvbHVtbiggbSwgMCApLmxlbmd0aCgpO1xuXHRcdGNvbnN0IHNjYWxlWSA9IDEgLyBfdjEuc2V0RnJvbU1hdHJpeENvbHVtbiggbSwgMSApLmxlbmd0aCgpO1xuXHRcdGNvbnN0IHNjYWxlWiA9IDEgLyBfdjEuc2V0RnJvbU1hdHJpeENvbHVtbiggbSwgMiApLmxlbmd0aCgpO1xuXG5cdFx0dGVbIDAgXSA9IG1lWyAwIF0gKiBzY2FsZVg7XG5cdFx0dGVbIDEgXSA9IG1lWyAxIF0gKiBzY2FsZVg7XG5cdFx0dGVbIDIgXSA9IG1lWyAyIF0gKiBzY2FsZVg7XG5cdFx0dGVbIDMgXSA9IDA7XG5cblx0XHR0ZVsgNCBdID0gbWVbIDQgXSAqIHNjYWxlWTtcblx0XHR0ZVsgNSBdID0gbWVbIDUgXSAqIHNjYWxlWTtcblx0XHR0ZVsgNiBdID0gbWVbIDYgXSAqIHNjYWxlWTtcblx0XHR0ZVsgNyBdID0gMDtcblxuXHRcdHRlWyA4IF0gPSBtZVsgOCBdICogc2NhbGVaO1xuXHRcdHRlWyA5IF0gPSBtZVsgOSBdICogc2NhbGVaO1xuXHRcdHRlWyAxMCBdID0gbWVbIDEwIF0gKiBzY2FsZVo7XG5cdFx0dGVbIDExIF0gPSAwO1xuXG5cdFx0dGVbIDEyIF0gPSAwO1xuXHRcdHRlWyAxMyBdID0gMDtcblx0XHR0ZVsgMTQgXSA9IDA7XG5cdFx0dGVbIDE1IF0gPSAxO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdG1ha2VSb3RhdGlvbkZyb21FdWxlciggZXVsZXIgKSB7XG5cblx0XHRjb25zdCB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cblx0XHRjb25zdCB4ID0gZXVsZXIueCwgeSA9IGV1bGVyLnksIHogPSBldWxlci56O1xuXHRcdGNvbnN0IGEgPSBNYXRoLmNvcyggeCApLCBiID0gTWF0aC5zaW4oIHggKTtcblx0XHRjb25zdCBjID0gTWF0aC5jb3MoIHkgKSwgZCA9IE1hdGguc2luKCB5ICk7XG5cdFx0Y29uc3QgZSA9IE1hdGguY29zKCB6ICksIGYgPSBNYXRoLnNpbiggeiApO1xuXG5cdFx0aWYgKCBldWxlci5vcmRlciA9PT0gJ1hZWicgKSB7XG5cblx0XHRcdGNvbnN0IGFlID0gYSAqIGUsIGFmID0gYSAqIGYsIGJlID0gYiAqIGUsIGJmID0gYiAqIGY7XG5cblx0XHRcdHRlWyAwIF0gPSBjICogZTtcblx0XHRcdHRlWyA0IF0gPSAtIGMgKiBmO1xuXHRcdFx0dGVbIDggXSA9IGQ7XG5cblx0XHRcdHRlWyAxIF0gPSBhZiArIGJlICogZDtcblx0XHRcdHRlWyA1IF0gPSBhZSAtIGJmICogZDtcblx0XHRcdHRlWyA5IF0gPSAtIGIgKiBjO1xuXG5cdFx0XHR0ZVsgMiBdID0gYmYgLSBhZSAqIGQ7XG5cdFx0XHR0ZVsgNiBdID0gYmUgKyBhZiAqIGQ7XG5cdFx0XHR0ZVsgMTAgXSA9IGEgKiBjO1xuXG5cdFx0fSBlbHNlIGlmICggZXVsZXIub3JkZXIgPT09ICdZWFonICkge1xuXG5cdFx0XHRjb25zdCBjZSA9IGMgKiBlLCBjZiA9IGMgKiBmLCBkZSA9IGQgKiBlLCBkZiA9IGQgKiBmO1xuXG5cdFx0XHR0ZVsgMCBdID0gY2UgKyBkZiAqIGI7XG5cdFx0XHR0ZVsgNCBdID0gZGUgKiBiIC0gY2Y7XG5cdFx0XHR0ZVsgOCBdID0gYSAqIGQ7XG5cblx0XHRcdHRlWyAxIF0gPSBhICogZjtcblx0XHRcdHRlWyA1IF0gPSBhICogZTtcblx0XHRcdHRlWyA5IF0gPSAtIGI7XG5cblx0XHRcdHRlWyAyIF0gPSBjZiAqIGIgLSBkZTtcblx0XHRcdHRlWyA2IF0gPSBkZiArIGNlICogYjtcblx0XHRcdHRlWyAxMCBdID0gYSAqIGM7XG5cblx0XHR9IGVsc2UgaWYgKCBldWxlci5vcmRlciA9PT0gJ1pYWScgKSB7XG5cblx0XHRcdGNvbnN0IGNlID0gYyAqIGUsIGNmID0gYyAqIGYsIGRlID0gZCAqIGUsIGRmID0gZCAqIGY7XG5cblx0XHRcdHRlWyAwIF0gPSBjZSAtIGRmICogYjtcblx0XHRcdHRlWyA0IF0gPSAtIGEgKiBmO1xuXHRcdFx0dGVbIDggXSA9IGRlICsgY2YgKiBiO1xuXG5cdFx0XHR0ZVsgMSBdID0gY2YgKyBkZSAqIGI7XG5cdFx0XHR0ZVsgNSBdID0gYSAqIGU7XG5cdFx0XHR0ZVsgOSBdID0gZGYgLSBjZSAqIGI7XG5cblx0XHRcdHRlWyAyIF0gPSAtIGEgKiBkO1xuXHRcdFx0dGVbIDYgXSA9IGI7XG5cdFx0XHR0ZVsgMTAgXSA9IGEgKiBjO1xuXG5cdFx0fSBlbHNlIGlmICggZXVsZXIub3JkZXIgPT09ICdaWVgnICkge1xuXG5cdFx0XHRjb25zdCBhZSA9IGEgKiBlLCBhZiA9IGEgKiBmLCBiZSA9IGIgKiBlLCBiZiA9IGIgKiBmO1xuXG5cdFx0XHR0ZVsgMCBdID0gYyAqIGU7XG5cdFx0XHR0ZVsgNCBdID0gYmUgKiBkIC0gYWY7XG5cdFx0XHR0ZVsgOCBdID0gYWUgKiBkICsgYmY7XG5cblx0XHRcdHRlWyAxIF0gPSBjICogZjtcblx0XHRcdHRlWyA1IF0gPSBiZiAqIGQgKyBhZTtcblx0XHRcdHRlWyA5IF0gPSBhZiAqIGQgLSBiZTtcblxuXHRcdFx0dGVbIDIgXSA9IC0gZDtcblx0XHRcdHRlWyA2IF0gPSBiICogYztcblx0XHRcdHRlWyAxMCBdID0gYSAqIGM7XG5cblx0XHR9IGVsc2UgaWYgKCBldWxlci5vcmRlciA9PT0gJ1laWCcgKSB7XG5cblx0XHRcdGNvbnN0IGFjID0gYSAqIGMsIGFkID0gYSAqIGQsIGJjID0gYiAqIGMsIGJkID0gYiAqIGQ7XG5cblx0XHRcdHRlWyAwIF0gPSBjICogZTtcblx0XHRcdHRlWyA0IF0gPSBiZCAtIGFjICogZjtcblx0XHRcdHRlWyA4IF0gPSBiYyAqIGYgKyBhZDtcblxuXHRcdFx0dGVbIDEgXSA9IGY7XG5cdFx0XHR0ZVsgNSBdID0gYSAqIGU7XG5cdFx0XHR0ZVsgOSBdID0gLSBiICogZTtcblxuXHRcdFx0dGVbIDIgXSA9IC0gZCAqIGU7XG5cdFx0XHR0ZVsgNiBdID0gYWQgKiBmICsgYmM7XG5cdFx0XHR0ZVsgMTAgXSA9IGFjIC0gYmQgKiBmO1xuXG5cdFx0fSBlbHNlIGlmICggZXVsZXIub3JkZXIgPT09ICdYWlknICkge1xuXG5cdFx0XHRjb25zdCBhYyA9IGEgKiBjLCBhZCA9IGEgKiBkLCBiYyA9IGIgKiBjLCBiZCA9IGIgKiBkO1xuXG5cdFx0XHR0ZVsgMCBdID0gYyAqIGU7XG5cdFx0XHR0ZVsgNCBdID0gLSBmO1xuXHRcdFx0dGVbIDggXSA9IGQgKiBlO1xuXG5cdFx0XHR0ZVsgMSBdID0gYWMgKiBmICsgYmQ7XG5cdFx0XHR0ZVsgNSBdID0gYSAqIGU7XG5cdFx0XHR0ZVsgOSBdID0gYWQgKiBmIC0gYmM7XG5cblx0XHRcdHRlWyAyIF0gPSBiYyAqIGYgLSBhZDtcblx0XHRcdHRlWyA2IF0gPSBiICogZTtcblx0XHRcdHRlWyAxMCBdID0gYmQgKiBmICsgYWM7XG5cblx0XHR9XG5cblx0XHQvLyBib3R0b20gcm93XG5cdFx0dGVbIDMgXSA9IDA7XG5cdFx0dGVbIDcgXSA9IDA7XG5cdFx0dGVbIDExIF0gPSAwO1xuXG5cdFx0Ly8gbGFzdCBjb2x1bW5cblx0XHR0ZVsgMTIgXSA9IDA7XG5cdFx0dGVbIDEzIF0gPSAwO1xuXHRcdHRlWyAxNCBdID0gMDtcblx0XHR0ZVsgMTUgXSA9IDE7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0bWFrZVJvdGF0aW9uRnJvbVF1YXRlcm5pb24oIHEgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5jb21wb3NlKCBfemVybywgcSwgX29uZSApO1xuXG5cdH1cblxuXHRsb29rQXQoIGV5ZSwgdGFyZ2V0LCB1cCApIHtcblxuXHRcdGNvbnN0IHRlID0gdGhpcy5lbGVtZW50cztcblxuXHRcdF96LnN1YlZlY3RvcnMoIGV5ZSwgdGFyZ2V0ICk7XG5cblx0XHRpZiAoIF96Lmxlbmd0aFNxKCkgPT09IDAgKSB7XG5cblx0XHRcdC8vIGV5ZSBhbmQgdGFyZ2V0IGFyZSBpbiB0aGUgc2FtZSBwb3NpdGlvblxuXG5cdFx0XHRfei56ID0gMTtcblxuXHRcdH1cblxuXHRcdF96Lm5vcm1hbGl6ZSgpO1xuXHRcdF94LmNyb3NzVmVjdG9ycyggdXAsIF96ICk7XG5cblx0XHRpZiAoIF94Lmxlbmd0aFNxKCkgPT09IDAgKSB7XG5cblx0XHRcdC8vIHVwIGFuZCB6IGFyZSBwYXJhbGxlbFxuXG5cdFx0XHRpZiAoIE1hdGguYWJzKCB1cC56ICkgPT09IDEgKSB7XG5cblx0XHRcdFx0X3oueCArPSAwLjAwMDE7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0X3oueiArPSAwLjAwMDE7XG5cblx0XHRcdH1cblxuXHRcdFx0X3oubm9ybWFsaXplKCk7XG5cdFx0XHRfeC5jcm9zc1ZlY3RvcnMoIHVwLCBfeiApO1xuXG5cdFx0fVxuXG5cdFx0X3gubm9ybWFsaXplKCk7XG5cdFx0X3kuY3Jvc3NWZWN0b3JzKCBfeiwgX3ggKTtcblxuXHRcdHRlWyAwIF0gPSBfeC54OyB0ZVsgNCBdID0gX3kueDsgdGVbIDggXSA9IF96Lng7XG5cdFx0dGVbIDEgXSA9IF94Lnk7IHRlWyA1IF0gPSBfeS55OyB0ZVsgOSBdID0gX3oueTtcblx0XHR0ZVsgMiBdID0gX3guejsgdGVbIDYgXSA9IF95Lno7IHRlWyAxMCBdID0gX3ouejtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRtdWx0aXBseSggbSApIHtcblxuXHRcdHJldHVybiB0aGlzLm11bHRpcGx5TWF0cmljZXMoIHRoaXMsIG0gKTtcblxuXHR9XG5cblx0cHJlbXVsdGlwbHkoIG0gKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5tdWx0aXBseU1hdHJpY2VzKCBtLCB0aGlzICk7XG5cblx0fVxuXG5cdG11bHRpcGx5TWF0cmljZXMoIGEsIGIgKSB7XG5cblx0XHRjb25zdCBhZSA9IGEuZWxlbWVudHM7XG5cdFx0Y29uc3QgYmUgPSBiLmVsZW1lbnRzO1xuXHRcdGNvbnN0IHRlID0gdGhpcy5lbGVtZW50cztcblxuXHRcdGNvbnN0IGExMSA9IGFlWyAwIF0sIGExMiA9IGFlWyA0IF0sIGExMyA9IGFlWyA4IF0sIGExNCA9IGFlWyAxMiBdO1xuXHRcdGNvbnN0IGEyMSA9IGFlWyAxIF0sIGEyMiA9IGFlWyA1IF0sIGEyMyA9IGFlWyA5IF0sIGEyNCA9IGFlWyAxMyBdO1xuXHRcdGNvbnN0IGEzMSA9IGFlWyAyIF0sIGEzMiA9IGFlWyA2IF0sIGEzMyA9IGFlWyAxMCBdLCBhMzQgPSBhZVsgMTQgXTtcblx0XHRjb25zdCBhNDEgPSBhZVsgMyBdLCBhNDIgPSBhZVsgNyBdLCBhNDMgPSBhZVsgMTEgXSwgYTQ0ID0gYWVbIDE1IF07XG5cblx0XHRjb25zdCBiMTEgPSBiZVsgMCBdLCBiMTIgPSBiZVsgNCBdLCBiMTMgPSBiZVsgOCBdLCBiMTQgPSBiZVsgMTIgXTtcblx0XHRjb25zdCBiMjEgPSBiZVsgMSBdLCBiMjIgPSBiZVsgNSBdLCBiMjMgPSBiZVsgOSBdLCBiMjQgPSBiZVsgMTMgXTtcblx0XHRjb25zdCBiMzEgPSBiZVsgMiBdLCBiMzIgPSBiZVsgNiBdLCBiMzMgPSBiZVsgMTAgXSwgYjM0ID0gYmVbIDE0IF07XG5cdFx0Y29uc3QgYjQxID0gYmVbIDMgXSwgYjQyID0gYmVbIDcgXSwgYjQzID0gYmVbIDExIF0sIGI0NCA9IGJlWyAxNSBdO1xuXG5cdFx0dGVbIDAgXSA9IGExMSAqIGIxMSArIGExMiAqIGIyMSArIGExMyAqIGIzMSArIGExNCAqIGI0MTtcblx0XHR0ZVsgNCBdID0gYTExICogYjEyICsgYTEyICogYjIyICsgYTEzICogYjMyICsgYTE0ICogYjQyO1xuXHRcdHRlWyA4IF0gPSBhMTEgKiBiMTMgKyBhMTIgKiBiMjMgKyBhMTMgKiBiMzMgKyBhMTQgKiBiNDM7XG5cdFx0dGVbIDEyIF0gPSBhMTEgKiBiMTQgKyBhMTIgKiBiMjQgKyBhMTMgKiBiMzQgKyBhMTQgKiBiNDQ7XG5cblx0XHR0ZVsgMSBdID0gYTIxICogYjExICsgYTIyICogYjIxICsgYTIzICogYjMxICsgYTI0ICogYjQxO1xuXHRcdHRlWyA1IF0gPSBhMjEgKiBiMTIgKyBhMjIgKiBiMjIgKyBhMjMgKiBiMzIgKyBhMjQgKiBiNDI7XG5cdFx0dGVbIDkgXSA9IGEyMSAqIGIxMyArIGEyMiAqIGIyMyArIGEyMyAqIGIzMyArIGEyNCAqIGI0Mztcblx0XHR0ZVsgMTMgXSA9IGEyMSAqIGIxNCArIGEyMiAqIGIyNCArIGEyMyAqIGIzNCArIGEyNCAqIGI0NDtcblxuXHRcdHRlWyAyIF0gPSBhMzEgKiBiMTEgKyBhMzIgKiBiMjEgKyBhMzMgKiBiMzEgKyBhMzQgKiBiNDE7XG5cdFx0dGVbIDYgXSA9IGEzMSAqIGIxMiArIGEzMiAqIGIyMiArIGEzMyAqIGIzMiArIGEzNCAqIGI0Mjtcblx0XHR0ZVsgMTAgXSA9IGEzMSAqIGIxMyArIGEzMiAqIGIyMyArIGEzMyAqIGIzMyArIGEzNCAqIGI0Mztcblx0XHR0ZVsgMTQgXSA9IGEzMSAqIGIxNCArIGEzMiAqIGIyNCArIGEzMyAqIGIzNCArIGEzNCAqIGI0NDtcblxuXHRcdHRlWyAzIF0gPSBhNDEgKiBiMTEgKyBhNDIgKiBiMjEgKyBhNDMgKiBiMzEgKyBhNDQgKiBiNDE7XG5cdFx0dGVbIDcgXSA9IGE0MSAqIGIxMiArIGE0MiAqIGIyMiArIGE0MyAqIGIzMiArIGE0NCAqIGI0Mjtcblx0XHR0ZVsgMTEgXSA9IGE0MSAqIGIxMyArIGE0MiAqIGIyMyArIGE0MyAqIGIzMyArIGE0NCAqIGI0Mztcblx0XHR0ZVsgMTUgXSA9IGE0MSAqIGIxNCArIGE0MiAqIGIyNCArIGE0MyAqIGIzNCArIGE0NCAqIGI0NDtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRtdWx0aXBseVNjYWxhciggcyApIHtcblxuXHRcdGNvbnN0IHRlID0gdGhpcy5lbGVtZW50cztcblxuXHRcdHRlWyAwIF0gKj0gczsgdGVbIDQgXSAqPSBzOyB0ZVsgOCBdICo9IHM7IHRlWyAxMiBdICo9IHM7XG5cdFx0dGVbIDEgXSAqPSBzOyB0ZVsgNSBdICo9IHM7IHRlWyA5IF0gKj0gczsgdGVbIDEzIF0gKj0gcztcblx0XHR0ZVsgMiBdICo9IHM7IHRlWyA2IF0gKj0gczsgdGVbIDEwIF0gKj0gczsgdGVbIDE0IF0gKj0gcztcblx0XHR0ZVsgMyBdICo9IHM7IHRlWyA3IF0gKj0gczsgdGVbIDExIF0gKj0gczsgdGVbIDE1IF0gKj0gcztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRkZXRlcm1pbmFudCgpIHtcblxuXHRcdGNvbnN0IHRlID0gdGhpcy5lbGVtZW50cztcblxuXHRcdGNvbnN0IG4xMSA9IHRlWyAwIF0sIG4xMiA9IHRlWyA0IF0sIG4xMyA9IHRlWyA4IF0sIG4xNCA9IHRlWyAxMiBdO1xuXHRcdGNvbnN0IG4yMSA9IHRlWyAxIF0sIG4yMiA9IHRlWyA1IF0sIG4yMyA9IHRlWyA5IF0sIG4yNCA9IHRlWyAxMyBdO1xuXHRcdGNvbnN0IG4zMSA9IHRlWyAyIF0sIG4zMiA9IHRlWyA2IF0sIG4zMyA9IHRlWyAxMCBdLCBuMzQgPSB0ZVsgMTQgXTtcblx0XHRjb25zdCBuNDEgPSB0ZVsgMyBdLCBuNDIgPSB0ZVsgNyBdLCBuNDMgPSB0ZVsgMTEgXSwgbjQ0ID0gdGVbIDE1IF07XG5cblx0XHQvL1RPRE86IG1ha2UgdGhpcyBtb3JlIGVmZmljaWVudFxuXHRcdC8vKCBiYXNlZCBvbiBodHRwOi8vd3d3LmV1Y2xpZGVhbnNwYWNlLmNvbS9tYXRocy9hbGdlYnJhL21hdHJpeC9mdW5jdGlvbnMvaW52ZXJzZS9mb3VyRC9pbmRleC5odG0gKVxuXG5cdFx0cmV0dXJuIChcblx0XHRcdG40MSAqIChcblx0XHRcdFx0KyBuMTQgKiBuMjMgKiBuMzJcblx0XHRcdFx0IC0gbjEzICogbjI0ICogbjMyXG5cdFx0XHRcdCAtIG4xNCAqIG4yMiAqIG4zM1xuXHRcdFx0XHQgKyBuMTIgKiBuMjQgKiBuMzNcblx0XHRcdFx0ICsgbjEzICogbjIyICogbjM0XG5cdFx0XHRcdCAtIG4xMiAqIG4yMyAqIG4zNFxuXHRcdFx0KSArXG5cdFx0XHRuNDIgKiAoXG5cdFx0XHRcdCsgbjExICogbjIzICogbjM0XG5cdFx0XHRcdCAtIG4xMSAqIG4yNCAqIG4zM1xuXHRcdFx0XHQgKyBuMTQgKiBuMjEgKiBuMzNcblx0XHRcdFx0IC0gbjEzICogbjIxICogbjM0XG5cdFx0XHRcdCArIG4xMyAqIG4yNCAqIG4zMVxuXHRcdFx0XHQgLSBuMTQgKiBuMjMgKiBuMzFcblx0XHRcdCkgK1xuXHRcdFx0bjQzICogKFxuXHRcdFx0XHQrIG4xMSAqIG4yNCAqIG4zMlxuXHRcdFx0XHQgLSBuMTEgKiBuMjIgKiBuMzRcblx0XHRcdFx0IC0gbjE0ICogbjIxICogbjMyXG5cdFx0XHRcdCArIG4xMiAqIG4yMSAqIG4zNFxuXHRcdFx0XHQgKyBuMTQgKiBuMjIgKiBuMzFcblx0XHRcdFx0IC0gbjEyICogbjI0ICogbjMxXG5cdFx0XHQpICtcblx0XHRcdG40NCAqIChcblx0XHRcdFx0LSBuMTMgKiBuMjIgKiBuMzFcblx0XHRcdFx0IC0gbjExICogbjIzICogbjMyXG5cdFx0XHRcdCArIG4xMSAqIG4yMiAqIG4zM1xuXHRcdFx0XHQgKyBuMTMgKiBuMjEgKiBuMzJcblx0XHRcdFx0IC0gbjEyICogbjIxICogbjMzXG5cdFx0XHRcdCArIG4xMiAqIG4yMyAqIG4zMVxuXHRcdFx0KVxuXG5cdFx0KTtcblxuXHR9XG5cblx0dHJhbnNwb3NlKCkge1xuXG5cdFx0Y29uc3QgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXHRcdGxldCB0bXA7XG5cblx0XHR0bXAgPSB0ZVsgMSBdOyB0ZVsgMSBdID0gdGVbIDQgXTsgdGVbIDQgXSA9IHRtcDtcblx0XHR0bXAgPSB0ZVsgMiBdOyB0ZVsgMiBdID0gdGVbIDggXTsgdGVbIDggXSA9IHRtcDtcblx0XHR0bXAgPSB0ZVsgNiBdOyB0ZVsgNiBdID0gdGVbIDkgXTsgdGVbIDkgXSA9IHRtcDtcblxuXHRcdHRtcCA9IHRlWyAzIF07IHRlWyAzIF0gPSB0ZVsgMTIgXTsgdGVbIDEyIF0gPSB0bXA7XG5cdFx0dG1wID0gdGVbIDcgXTsgdGVbIDcgXSA9IHRlWyAxMyBdOyB0ZVsgMTMgXSA9IHRtcDtcblx0XHR0bXAgPSB0ZVsgMTEgXTsgdGVbIDExIF0gPSB0ZVsgMTQgXTsgdGVbIDE0IF0gPSB0bXA7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c2V0UG9zaXRpb24oIHgsIHksIHogKSB7XG5cblx0XHRjb25zdCB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cblx0XHRpZiAoIHguaXNWZWN0b3IzICkge1xuXG5cdFx0XHR0ZVsgMTIgXSA9IHgueDtcblx0XHRcdHRlWyAxMyBdID0geC55O1xuXHRcdFx0dGVbIDE0IF0gPSB4Lno7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHR0ZVsgMTIgXSA9IHg7XG5cdFx0XHR0ZVsgMTMgXSA9IHk7XG5cdFx0XHR0ZVsgMTQgXSA9IHo7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0aW52ZXJ0KCkge1xuXG5cdFx0Ly8gYmFzZWQgb24gaHR0cDovL3d3dy5ldWNsaWRlYW5zcGFjZS5jb20vbWF0aHMvYWxnZWJyYS9tYXRyaXgvZnVuY3Rpb25zL2ludmVyc2UvZm91ckQvaW5kZXguaHRtXG5cdFx0Y29uc3QgdGUgPSB0aGlzLmVsZW1lbnRzLFxuXG5cdFx0XHRuMTEgPSB0ZVsgMCBdLCBuMjEgPSB0ZVsgMSBdLCBuMzEgPSB0ZVsgMiBdLCBuNDEgPSB0ZVsgMyBdLFxuXHRcdFx0bjEyID0gdGVbIDQgXSwgbjIyID0gdGVbIDUgXSwgbjMyID0gdGVbIDYgXSwgbjQyID0gdGVbIDcgXSxcblx0XHRcdG4xMyA9IHRlWyA4IF0sIG4yMyA9IHRlWyA5IF0sIG4zMyA9IHRlWyAxMCBdLCBuNDMgPSB0ZVsgMTEgXSxcblx0XHRcdG4xNCA9IHRlWyAxMiBdLCBuMjQgPSB0ZVsgMTMgXSwgbjM0ID0gdGVbIDE0IF0sIG40NCA9IHRlWyAxNSBdLFxuXG5cdFx0XHR0MTEgPSBuMjMgKiBuMzQgKiBuNDIgLSBuMjQgKiBuMzMgKiBuNDIgKyBuMjQgKiBuMzIgKiBuNDMgLSBuMjIgKiBuMzQgKiBuNDMgLSBuMjMgKiBuMzIgKiBuNDQgKyBuMjIgKiBuMzMgKiBuNDQsXG5cdFx0XHR0MTIgPSBuMTQgKiBuMzMgKiBuNDIgLSBuMTMgKiBuMzQgKiBuNDIgLSBuMTQgKiBuMzIgKiBuNDMgKyBuMTIgKiBuMzQgKiBuNDMgKyBuMTMgKiBuMzIgKiBuNDQgLSBuMTIgKiBuMzMgKiBuNDQsXG5cdFx0XHR0MTMgPSBuMTMgKiBuMjQgKiBuNDIgLSBuMTQgKiBuMjMgKiBuNDIgKyBuMTQgKiBuMjIgKiBuNDMgLSBuMTIgKiBuMjQgKiBuNDMgLSBuMTMgKiBuMjIgKiBuNDQgKyBuMTIgKiBuMjMgKiBuNDQsXG5cdFx0XHR0MTQgPSBuMTQgKiBuMjMgKiBuMzIgLSBuMTMgKiBuMjQgKiBuMzIgLSBuMTQgKiBuMjIgKiBuMzMgKyBuMTIgKiBuMjQgKiBuMzMgKyBuMTMgKiBuMjIgKiBuMzQgLSBuMTIgKiBuMjMgKiBuMzQ7XG5cblx0XHRjb25zdCBkZXQgPSBuMTEgKiB0MTEgKyBuMjEgKiB0MTIgKyBuMzEgKiB0MTMgKyBuNDEgKiB0MTQ7XG5cblx0XHRpZiAoIGRldCA9PT0gMCApIHJldHVybiB0aGlzLnNldCggMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCApO1xuXG5cdFx0Y29uc3QgZGV0SW52ID0gMSAvIGRldDtcblxuXHRcdHRlWyAwIF0gPSB0MTEgKiBkZXRJbnY7XG5cdFx0dGVbIDEgXSA9ICggbjI0ICogbjMzICogbjQxIC0gbjIzICogbjM0ICogbjQxIC0gbjI0ICogbjMxICogbjQzICsgbjIxICogbjM0ICogbjQzICsgbjIzICogbjMxICogbjQ0IC0gbjIxICogbjMzICogbjQ0ICkgKiBkZXRJbnY7XG5cdFx0dGVbIDIgXSA9ICggbjIyICogbjM0ICogbjQxIC0gbjI0ICogbjMyICogbjQxICsgbjI0ICogbjMxICogbjQyIC0gbjIxICogbjM0ICogbjQyIC0gbjIyICogbjMxICogbjQ0ICsgbjIxICogbjMyICogbjQ0ICkgKiBkZXRJbnY7XG5cdFx0dGVbIDMgXSA9ICggbjIzICogbjMyICogbjQxIC0gbjIyICogbjMzICogbjQxIC0gbjIzICogbjMxICogbjQyICsgbjIxICogbjMzICogbjQyICsgbjIyICogbjMxICogbjQzIC0gbjIxICogbjMyICogbjQzICkgKiBkZXRJbnY7XG5cblx0XHR0ZVsgNCBdID0gdDEyICogZGV0SW52O1xuXHRcdHRlWyA1IF0gPSAoIG4xMyAqIG4zNCAqIG40MSAtIG4xNCAqIG4zMyAqIG40MSArIG4xNCAqIG4zMSAqIG40MyAtIG4xMSAqIG4zNCAqIG40MyAtIG4xMyAqIG4zMSAqIG40NCArIG4xMSAqIG4zMyAqIG40NCApICogZGV0SW52O1xuXHRcdHRlWyA2IF0gPSAoIG4xNCAqIG4zMiAqIG40MSAtIG4xMiAqIG4zNCAqIG40MSAtIG4xNCAqIG4zMSAqIG40MiArIG4xMSAqIG4zNCAqIG40MiArIG4xMiAqIG4zMSAqIG40NCAtIG4xMSAqIG4zMiAqIG40NCApICogZGV0SW52O1xuXHRcdHRlWyA3IF0gPSAoIG4xMiAqIG4zMyAqIG40MSAtIG4xMyAqIG4zMiAqIG40MSArIG4xMyAqIG4zMSAqIG40MiAtIG4xMSAqIG4zMyAqIG40MiAtIG4xMiAqIG4zMSAqIG40MyArIG4xMSAqIG4zMiAqIG40MyApICogZGV0SW52O1xuXG5cdFx0dGVbIDggXSA9IHQxMyAqIGRldEludjtcblx0XHR0ZVsgOSBdID0gKCBuMTQgKiBuMjMgKiBuNDEgLSBuMTMgKiBuMjQgKiBuNDEgLSBuMTQgKiBuMjEgKiBuNDMgKyBuMTEgKiBuMjQgKiBuNDMgKyBuMTMgKiBuMjEgKiBuNDQgLSBuMTEgKiBuMjMgKiBuNDQgKSAqIGRldEludjtcblx0XHR0ZVsgMTAgXSA9ICggbjEyICogbjI0ICogbjQxIC0gbjE0ICogbjIyICogbjQxICsgbjE0ICogbjIxICogbjQyIC0gbjExICogbjI0ICogbjQyIC0gbjEyICogbjIxICogbjQ0ICsgbjExICogbjIyICogbjQ0ICkgKiBkZXRJbnY7XG5cdFx0dGVbIDExIF0gPSAoIG4xMyAqIG4yMiAqIG40MSAtIG4xMiAqIG4yMyAqIG40MSAtIG4xMyAqIG4yMSAqIG40MiArIG4xMSAqIG4yMyAqIG40MiArIG4xMiAqIG4yMSAqIG40MyAtIG4xMSAqIG4yMiAqIG40MyApICogZGV0SW52O1xuXG5cdFx0dGVbIDEyIF0gPSB0MTQgKiBkZXRJbnY7XG5cdFx0dGVbIDEzIF0gPSAoIG4xMyAqIG4yNCAqIG4zMSAtIG4xNCAqIG4yMyAqIG4zMSArIG4xNCAqIG4yMSAqIG4zMyAtIG4xMSAqIG4yNCAqIG4zMyAtIG4xMyAqIG4yMSAqIG4zNCArIG4xMSAqIG4yMyAqIG4zNCApICogZGV0SW52O1xuXHRcdHRlWyAxNCBdID0gKCBuMTQgKiBuMjIgKiBuMzEgLSBuMTIgKiBuMjQgKiBuMzEgLSBuMTQgKiBuMjEgKiBuMzIgKyBuMTEgKiBuMjQgKiBuMzIgKyBuMTIgKiBuMjEgKiBuMzQgLSBuMTEgKiBuMjIgKiBuMzQgKSAqIGRldEludjtcblx0XHR0ZVsgMTUgXSA9ICggbjEyICogbjIzICogbjMxIC0gbjEzICogbjIyICogbjMxICsgbjEzICogbjIxICogbjMyIC0gbjExICogbjIzICogbjMyIC0gbjEyICogbjIxICogbjMzICsgbjExICogbjIyICogbjMzICkgKiBkZXRJbnY7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c2NhbGUoIHYgKSB7XG5cblx0XHRjb25zdCB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cdFx0Y29uc3QgeCA9IHYueCwgeSA9IHYueSwgeiA9IHYuejtcblxuXHRcdHRlWyAwIF0gKj0geDsgdGVbIDQgXSAqPSB5OyB0ZVsgOCBdICo9IHo7XG5cdFx0dGVbIDEgXSAqPSB4OyB0ZVsgNSBdICo9IHk7IHRlWyA5IF0gKj0gejtcblx0XHR0ZVsgMiBdICo9IHg7IHRlWyA2IF0gKj0geTsgdGVbIDEwIF0gKj0gejtcblx0XHR0ZVsgMyBdICo9IHg7IHRlWyA3IF0gKj0geTsgdGVbIDExIF0gKj0gejtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRnZXRNYXhTY2FsZU9uQXhpcygpIHtcblxuXHRcdGNvbnN0IHRlID0gdGhpcy5lbGVtZW50cztcblxuXHRcdGNvbnN0IHNjYWxlWFNxID0gdGVbIDAgXSAqIHRlWyAwIF0gKyB0ZVsgMSBdICogdGVbIDEgXSArIHRlWyAyIF0gKiB0ZVsgMiBdO1xuXHRcdGNvbnN0IHNjYWxlWVNxID0gdGVbIDQgXSAqIHRlWyA0IF0gKyB0ZVsgNSBdICogdGVbIDUgXSArIHRlWyA2IF0gKiB0ZVsgNiBdO1xuXHRcdGNvbnN0IHNjYWxlWlNxID0gdGVbIDggXSAqIHRlWyA4IF0gKyB0ZVsgOSBdICogdGVbIDkgXSArIHRlWyAxMCBdICogdGVbIDEwIF07XG5cblx0XHRyZXR1cm4gTWF0aC5zcXJ0KCBNYXRoLm1heCggc2NhbGVYU3EsIHNjYWxlWVNxLCBzY2FsZVpTcSApICk7XG5cblx0fVxuXG5cdG1ha2VUcmFuc2xhdGlvbiggeCwgeSwgeiApIHtcblxuXHRcdGlmICggeC5pc1ZlY3RvcjMgKSB7XG5cblx0XHRcdHRoaXMuc2V0KFxuXG5cdFx0XHRcdDEsIDAsIDAsIHgueCxcblx0XHRcdFx0MCwgMSwgMCwgeC55LFxuXHRcdFx0XHQwLCAwLCAxLCB4LnosXG5cdFx0XHRcdDAsIDAsIDAsIDFcblxuXHRcdFx0KTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHRoaXMuc2V0KFxuXG5cdFx0XHRcdDEsIDAsIDAsIHgsXG5cdFx0XHRcdDAsIDEsIDAsIHksXG5cdFx0XHRcdDAsIDAsIDEsIHosXG5cdFx0XHRcdDAsIDAsIDAsIDFcblxuXHRcdFx0KTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRtYWtlUm90YXRpb25YKCB0aGV0YSApIHtcblxuXHRcdGNvbnN0IGMgPSBNYXRoLmNvcyggdGhldGEgKSwgcyA9IE1hdGguc2luKCB0aGV0YSApO1xuXG5cdFx0dGhpcy5zZXQoXG5cblx0XHRcdDEsIDAsIDAsIDAsXG5cdFx0XHQwLCBjLCAtIHMsIDAsXG5cdFx0XHQwLCBzLCBjLCAwLFxuXHRcdFx0MCwgMCwgMCwgMVxuXG5cdFx0KTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRtYWtlUm90YXRpb25ZKCB0aGV0YSApIHtcblxuXHRcdGNvbnN0IGMgPSBNYXRoLmNvcyggdGhldGEgKSwgcyA9IE1hdGguc2luKCB0aGV0YSApO1xuXG5cdFx0dGhpcy5zZXQoXG5cblx0XHRcdCBjLCAwLCBzLCAwLFxuXHRcdFx0IDAsIDEsIDAsIDAsXG5cdFx0XHQtIHMsIDAsIGMsIDAsXG5cdFx0XHQgMCwgMCwgMCwgMVxuXG5cdFx0KTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRtYWtlUm90YXRpb25aKCB0aGV0YSApIHtcblxuXHRcdGNvbnN0IGMgPSBNYXRoLmNvcyggdGhldGEgKSwgcyA9IE1hdGguc2luKCB0aGV0YSApO1xuXG5cdFx0dGhpcy5zZXQoXG5cblx0XHRcdGMsIC0gcywgMCwgMCxcblx0XHRcdHMsIGMsIDAsIDAsXG5cdFx0XHQwLCAwLCAxLCAwLFxuXHRcdFx0MCwgMCwgMCwgMVxuXG5cdFx0KTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRtYWtlUm90YXRpb25BeGlzKCBheGlzLCBhbmdsZSApIHtcblxuXHRcdC8vIEJhc2VkIG9uIGh0dHA6Ly93d3cuZ2FtZWRldi5uZXQvcmVmZXJlbmNlL2FydGljbGVzL2FydGljbGUxMTk5LmFzcFxuXG5cdFx0Y29uc3QgYyA9IE1hdGguY29zKCBhbmdsZSApO1xuXHRcdGNvbnN0IHMgPSBNYXRoLnNpbiggYW5nbGUgKTtcblx0XHRjb25zdCB0ID0gMSAtIGM7XG5cdFx0Y29uc3QgeCA9IGF4aXMueCwgeSA9IGF4aXMueSwgeiA9IGF4aXMuejtcblx0XHRjb25zdCB0eCA9IHQgKiB4LCB0eSA9IHQgKiB5O1xuXG5cdFx0dGhpcy5zZXQoXG5cblx0XHRcdHR4ICogeCArIGMsIHR4ICogeSAtIHMgKiB6LCB0eCAqIHogKyBzICogeSwgMCxcblx0XHRcdHR4ICogeSArIHMgKiB6LCB0eSAqIHkgKyBjLCB0eSAqIHogLSBzICogeCwgMCxcblx0XHRcdHR4ICogeiAtIHMgKiB5LCB0eSAqIHogKyBzICogeCwgdCAqIHogKiB6ICsgYywgMCxcblx0XHRcdDAsIDAsIDAsIDFcblxuXHRcdCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0bWFrZVNjYWxlKCB4LCB5LCB6ICkge1xuXG5cdFx0dGhpcy5zZXQoXG5cblx0XHRcdHgsIDAsIDAsIDAsXG5cdFx0XHQwLCB5LCAwLCAwLFxuXHRcdFx0MCwgMCwgeiwgMCxcblx0XHRcdDAsIDAsIDAsIDFcblxuXHRcdCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0bWFrZVNoZWFyKCB4eSwgeHosIHl4LCB5eiwgengsIHp5ICkge1xuXG5cdFx0dGhpcy5zZXQoXG5cblx0XHRcdDEsIHl4LCB6eCwgMCxcblx0XHRcdHh5LCAxLCB6eSwgMCxcblx0XHRcdHh6LCB5eiwgMSwgMCxcblx0XHRcdDAsIDAsIDAsIDFcblxuXHRcdCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Y29tcG9zZSggcG9zaXRpb24sIHF1YXRlcm5pb24sIHNjYWxlICkge1xuXG5cdFx0Y29uc3QgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG5cdFx0Y29uc3QgeCA9IHF1YXRlcm5pb24uX3gsIHkgPSBxdWF0ZXJuaW9uLl95LCB6ID0gcXVhdGVybmlvbi5feiwgdyA9IHF1YXRlcm5pb24uX3c7XG5cdFx0Y29uc3QgeDIgPSB4ICsgeCxcdHkyID0geSArIHksIHoyID0geiArIHo7XG5cdFx0Y29uc3QgeHggPSB4ICogeDIsIHh5ID0geCAqIHkyLCB4eiA9IHggKiB6Mjtcblx0XHRjb25zdCB5eSA9IHkgKiB5MiwgeXogPSB5ICogejIsIHp6ID0geiAqIHoyO1xuXHRcdGNvbnN0IHd4ID0gdyAqIHgyLCB3eSA9IHcgKiB5Miwgd3ogPSB3ICogejI7XG5cblx0XHRjb25zdCBzeCA9IHNjYWxlLngsIHN5ID0gc2NhbGUueSwgc3ogPSBzY2FsZS56O1xuXG5cdFx0dGVbIDAgXSA9ICggMSAtICggeXkgKyB6eiApICkgKiBzeDtcblx0XHR0ZVsgMSBdID0gKCB4eSArIHd6ICkgKiBzeDtcblx0XHR0ZVsgMiBdID0gKCB4eiAtIHd5ICkgKiBzeDtcblx0XHR0ZVsgMyBdID0gMDtcblxuXHRcdHRlWyA0IF0gPSAoIHh5IC0gd3ogKSAqIHN5O1xuXHRcdHRlWyA1IF0gPSAoIDEgLSAoIHh4ICsgenogKSApICogc3k7XG5cdFx0dGVbIDYgXSA9ICggeXogKyB3eCApICogc3k7XG5cdFx0dGVbIDcgXSA9IDA7XG5cblx0XHR0ZVsgOCBdID0gKCB4eiArIHd5ICkgKiBzejtcblx0XHR0ZVsgOSBdID0gKCB5eiAtIHd4ICkgKiBzejtcblx0XHR0ZVsgMTAgXSA9ICggMSAtICggeHggKyB5eSApICkgKiBzejtcblx0XHR0ZVsgMTEgXSA9IDA7XG5cblx0XHR0ZVsgMTIgXSA9IHBvc2l0aW9uLng7XG5cdFx0dGVbIDEzIF0gPSBwb3NpdGlvbi55O1xuXHRcdHRlWyAxNCBdID0gcG9zaXRpb24uejtcblx0XHR0ZVsgMTUgXSA9IDE7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0ZGVjb21wb3NlKCBwb3NpdGlvbiwgcXVhdGVybmlvbiwgc2NhbGUgKSB7XG5cblx0XHRjb25zdCB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cblx0XHRsZXQgc3ggPSBfdjEuc2V0KCB0ZVsgMCBdLCB0ZVsgMSBdLCB0ZVsgMiBdICkubGVuZ3RoKCk7XG5cdFx0Y29uc3Qgc3kgPSBfdjEuc2V0KCB0ZVsgNCBdLCB0ZVsgNSBdLCB0ZVsgNiBdICkubGVuZ3RoKCk7XG5cdFx0Y29uc3Qgc3ogPSBfdjEuc2V0KCB0ZVsgOCBdLCB0ZVsgOSBdLCB0ZVsgMTAgXSApLmxlbmd0aCgpO1xuXG5cdFx0Ly8gaWYgZGV0ZXJtaW5lIGlzIG5lZ2F0aXZlLCB3ZSBuZWVkIHRvIGludmVydCBvbmUgc2NhbGVcblx0XHRjb25zdCBkZXQgPSB0aGlzLmRldGVybWluYW50KCk7XG5cdFx0aWYgKCBkZXQgPCAwICkgc3ggPSAtIHN4O1xuXG5cdFx0cG9zaXRpb24ueCA9IHRlWyAxMiBdO1xuXHRcdHBvc2l0aW9uLnkgPSB0ZVsgMTMgXTtcblx0XHRwb3NpdGlvbi56ID0gdGVbIDE0IF07XG5cblx0XHQvLyBzY2FsZSB0aGUgcm90YXRpb24gcGFydFxuXHRcdF9tMS5jb3B5KCB0aGlzICk7XG5cblx0XHRjb25zdCBpbnZTWCA9IDEgLyBzeDtcblx0XHRjb25zdCBpbnZTWSA9IDEgLyBzeTtcblx0XHRjb25zdCBpbnZTWiA9IDEgLyBzejtcblxuXHRcdF9tMS5lbGVtZW50c1sgMCBdICo9IGludlNYO1xuXHRcdF9tMS5lbGVtZW50c1sgMSBdICo9IGludlNYO1xuXHRcdF9tMS5lbGVtZW50c1sgMiBdICo9IGludlNYO1xuXG5cdFx0X20xLmVsZW1lbnRzWyA0IF0gKj0gaW52U1k7XG5cdFx0X20xLmVsZW1lbnRzWyA1IF0gKj0gaW52U1k7XG5cdFx0X20xLmVsZW1lbnRzWyA2IF0gKj0gaW52U1k7XG5cblx0XHRfbTEuZWxlbWVudHNbIDggXSAqPSBpbnZTWjtcblx0XHRfbTEuZWxlbWVudHNbIDkgXSAqPSBpbnZTWjtcblx0XHRfbTEuZWxlbWVudHNbIDEwIF0gKj0gaW52U1o7XG5cblx0XHRxdWF0ZXJuaW9uLnNldEZyb21Sb3RhdGlvbk1hdHJpeCggX20xICk7XG5cblx0XHRzY2FsZS54ID0gc3g7XG5cdFx0c2NhbGUueSA9IHN5O1xuXHRcdHNjYWxlLnogPSBzejtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRtYWtlUGVyc3BlY3RpdmUoIGxlZnQsIHJpZ2h0LCB0b3AsIGJvdHRvbSwgbmVhciwgZmFyLCBjb29yZGluYXRlU3lzdGVtID0gV2ViR0xDb29yZGluYXRlU3lzdGVtICkge1xuXG5cdFx0Y29uc3QgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXHRcdGNvbnN0IHggPSAyICogbmVhciAvICggcmlnaHQgLSBsZWZ0ICk7XG5cdFx0Y29uc3QgeSA9IDIgKiBuZWFyIC8gKCB0b3AgLSBib3R0b20gKTtcblxuXHRcdGNvbnN0IGEgPSAoIHJpZ2h0ICsgbGVmdCApIC8gKCByaWdodCAtIGxlZnQgKTtcblx0XHRjb25zdCBiID0gKCB0b3AgKyBib3R0b20gKSAvICggdG9wIC0gYm90dG9tICk7XG5cblx0XHRsZXQgYywgZDtcblxuXHRcdGlmICggY29vcmRpbmF0ZVN5c3RlbSA9PT0gV2ViR0xDb29yZGluYXRlU3lzdGVtICkge1xuXG5cdFx0XHRjID0gLSAoIGZhciArIG5lYXIgKSAvICggZmFyIC0gbmVhciApO1xuXHRcdFx0ZCA9ICggLSAyICogZmFyICogbmVhciApIC8gKCBmYXIgLSBuZWFyICk7XG5cblx0XHR9IGVsc2UgaWYgKCBjb29yZGluYXRlU3lzdGVtID09PSBXZWJHUFVDb29yZGluYXRlU3lzdGVtICkge1xuXG5cdFx0XHRjID0gLSBmYXIgLyAoIGZhciAtIG5lYXIgKTtcblx0XHRcdGQgPSAoIC0gZmFyICogbmVhciApIC8gKCBmYXIgLSBuZWFyICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdUSFJFRS5NYXRyaXg0Lm1ha2VQZXJzcGVjdGl2ZSgpOiBJbnZhbGlkIGNvb3JkaW5hdGUgc3lzdGVtOiAnICsgY29vcmRpbmF0ZVN5c3RlbSApO1xuXG5cdFx0fVxuXG5cdFx0dGVbIDAgXSA9IHg7XHR0ZVsgNCBdID0gMDtcdHRlWyA4IF0gPSBhOyBcdHRlWyAxMiBdID0gMDtcblx0XHR0ZVsgMSBdID0gMDtcdHRlWyA1IF0gPSB5O1x0dGVbIDkgXSA9IGI7IFx0dGVbIDEzIF0gPSAwO1xuXHRcdHRlWyAyIF0gPSAwO1x0dGVbIDYgXSA9IDA7XHR0ZVsgMTAgXSA9IGM7IFx0dGVbIDE0IF0gPSBkO1xuXHRcdHRlWyAzIF0gPSAwO1x0dGVbIDcgXSA9IDA7XHR0ZVsgMTEgXSA9IC0gMTtcdHRlWyAxNSBdID0gMDtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRtYWtlT3J0aG9ncmFwaGljKCBsZWZ0LCByaWdodCwgdG9wLCBib3R0b20sIG5lYXIsIGZhciwgY29vcmRpbmF0ZVN5c3RlbSA9IFdlYkdMQ29vcmRpbmF0ZVN5c3RlbSApIHtcblxuXHRcdGNvbnN0IHRlID0gdGhpcy5lbGVtZW50cztcblx0XHRjb25zdCB3ID0gMS4wIC8gKCByaWdodCAtIGxlZnQgKTtcblx0XHRjb25zdCBoID0gMS4wIC8gKCB0b3AgLSBib3R0b20gKTtcblx0XHRjb25zdCBwID0gMS4wIC8gKCBmYXIgLSBuZWFyICk7XG5cblx0XHRjb25zdCB4ID0gKCByaWdodCArIGxlZnQgKSAqIHc7XG5cdFx0Y29uc3QgeSA9ICggdG9wICsgYm90dG9tICkgKiBoO1xuXG5cdFx0bGV0IHosIHpJbnY7XG5cblx0XHRpZiAoIGNvb3JkaW5hdGVTeXN0ZW0gPT09IFdlYkdMQ29vcmRpbmF0ZVN5c3RlbSApIHtcblxuXHRcdFx0eiA9ICggZmFyICsgbmVhciApICogcDtcblx0XHRcdHpJbnYgPSAtIDIgKiBwO1xuXG5cdFx0fSBlbHNlIGlmICggY29vcmRpbmF0ZVN5c3RlbSA9PT0gV2ViR1BVQ29vcmRpbmF0ZVN5c3RlbSApIHtcblxuXHRcdFx0eiA9IG5lYXIgKiBwO1xuXHRcdFx0ekludiA9IC0gMSAqIHA7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdUSFJFRS5NYXRyaXg0Lm1ha2VPcnRob2dyYXBoaWMoKTogSW52YWxpZCBjb29yZGluYXRlIHN5c3RlbTogJyArIGNvb3JkaW5hdGVTeXN0ZW0gKTtcblxuXHRcdH1cblxuXHRcdHRlWyAwIF0gPSAyICogdztcdHRlWyA0IF0gPSAwO1x0XHR0ZVsgOCBdID0gMDsgXHRcdHRlWyAxMiBdID0gLSB4O1xuXHRcdHRlWyAxIF0gPSAwOyBcdFx0dGVbIDUgXSA9IDIgKiBoO1x0dGVbIDkgXSA9IDA7IFx0XHR0ZVsgMTMgXSA9IC0geTtcblx0XHR0ZVsgMiBdID0gMDsgXHRcdHRlWyA2IF0gPSAwO1x0XHR0ZVsgMTAgXSA9IHpJbnY7XHR0ZVsgMTQgXSA9IC0gejtcblx0XHR0ZVsgMyBdID0gMDsgXHRcdHRlWyA3IF0gPSAwO1x0XHR0ZVsgMTEgXSA9IDA7XHRcdHRlWyAxNSBdID0gMTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRlcXVhbHMoIG1hdHJpeCApIHtcblxuXHRcdGNvbnN0IHRlID0gdGhpcy5lbGVtZW50cztcblx0XHRjb25zdCBtZSA9IG1hdHJpeC5lbGVtZW50cztcblxuXHRcdGZvciAoIGxldCBpID0gMDsgaSA8IDE2OyBpICsrICkge1xuXG5cdFx0XHRpZiAoIHRlWyBpIF0gIT09IG1lWyBpIF0gKSByZXR1cm4gZmFsc2U7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblxuXHR9XG5cblx0ZnJvbUFycmF5KCBhcnJheSwgb2Zmc2V0ID0gMCApIHtcblxuXHRcdGZvciAoIGxldCBpID0gMDsgaSA8IDE2OyBpICsrICkge1xuXG5cdFx0XHR0aGlzLmVsZW1lbnRzWyBpIF0gPSBhcnJheVsgaSArIG9mZnNldCBdO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHRvQXJyYXkoIGFycmF5ID0gW10sIG9mZnNldCA9IDAgKSB7XG5cblx0XHRjb25zdCB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cblx0XHRhcnJheVsgb2Zmc2V0IF0gPSB0ZVsgMCBdO1xuXHRcdGFycmF5WyBvZmZzZXQgKyAxIF0gPSB0ZVsgMSBdO1xuXHRcdGFycmF5WyBvZmZzZXQgKyAyIF0gPSB0ZVsgMiBdO1xuXHRcdGFycmF5WyBvZmZzZXQgKyAzIF0gPSB0ZVsgMyBdO1xuXG5cdFx0YXJyYXlbIG9mZnNldCArIDQgXSA9IHRlWyA0IF07XG5cdFx0YXJyYXlbIG9mZnNldCArIDUgXSA9IHRlWyA1IF07XG5cdFx0YXJyYXlbIG9mZnNldCArIDYgXSA9IHRlWyA2IF07XG5cdFx0YXJyYXlbIG9mZnNldCArIDcgXSA9IHRlWyA3IF07XG5cblx0XHRhcnJheVsgb2Zmc2V0ICsgOCBdID0gdGVbIDggXTtcblx0XHRhcnJheVsgb2Zmc2V0ICsgOSBdID0gdGVbIDkgXTtcblx0XHRhcnJheVsgb2Zmc2V0ICsgMTAgXSA9IHRlWyAxMCBdO1xuXHRcdGFycmF5WyBvZmZzZXQgKyAxMSBdID0gdGVbIDExIF07XG5cblx0XHRhcnJheVsgb2Zmc2V0ICsgMTIgXSA9IHRlWyAxMiBdO1xuXHRcdGFycmF5WyBvZmZzZXQgKyAxMyBdID0gdGVbIDEzIF07XG5cdFx0YXJyYXlbIG9mZnNldCArIDE0IF0gPSB0ZVsgMTQgXTtcblx0XHRhcnJheVsgb2Zmc2V0ICsgMTUgXSA9IHRlWyAxNSBdO1xuXG5cdFx0cmV0dXJuIGFycmF5O1xuXG5cdH1cblxufVxuXG5jb25zdCBfdjEgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XG5jb25zdCBfbTEgPSAvKkBfX1BVUkVfXyovIG5ldyBNYXRyaXg0KCk7XG5jb25zdCBfemVybyA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoIDAsIDAsIDAgKTtcbmNvbnN0IF9vbmUgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCAxLCAxLCAxICk7XG5jb25zdCBfeCA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcbmNvbnN0IF95ID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xuY29uc3QgX3ogPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XG5cbmV4cG9ydCB7IE1hdHJpeDQgfTtcbiIsImltcG9ydCAqIGFzIE1hdGhVdGlscyBmcm9tICcuL01hdGhVdGlscy5qcyc7XG5cbmNsYXNzIFF1YXRlcm5pb24ge1xuXG5cdGNvbnN0cnVjdG9yKCB4ID0gMCwgeSA9IDAsIHogPSAwLCB3ID0gMSApIHtcblxuXHRcdHRoaXMuaXNRdWF0ZXJuaW9uID0gdHJ1ZTtcblxuXHRcdHRoaXMuX3ggPSB4O1xuXHRcdHRoaXMuX3kgPSB5O1xuXHRcdHRoaXMuX3ogPSB6O1xuXHRcdHRoaXMuX3cgPSB3O1xuXG5cdH1cblxuXHRzdGF0aWMgc2xlcnBGbGF0KCBkc3QsIGRzdE9mZnNldCwgc3JjMCwgc3JjT2Zmc2V0MCwgc3JjMSwgc3JjT2Zmc2V0MSwgdCApIHtcblxuXHRcdC8vIGZ1enotZnJlZSwgYXJyYXktYmFzZWQgUXVhdGVybmlvbiBTTEVSUCBvcGVyYXRpb25cblxuXHRcdGxldCB4MCA9IHNyYzBbIHNyY09mZnNldDAgKyAwIF0sXG5cdFx0XHR5MCA9IHNyYzBbIHNyY09mZnNldDAgKyAxIF0sXG5cdFx0XHR6MCA9IHNyYzBbIHNyY09mZnNldDAgKyAyIF0sXG5cdFx0XHR3MCA9IHNyYzBbIHNyY09mZnNldDAgKyAzIF07XG5cblx0XHRjb25zdCB4MSA9IHNyYzFbIHNyY09mZnNldDEgKyAwIF0sXG5cdFx0XHR5MSA9IHNyYzFbIHNyY09mZnNldDEgKyAxIF0sXG5cdFx0XHR6MSA9IHNyYzFbIHNyY09mZnNldDEgKyAyIF0sXG5cdFx0XHR3MSA9IHNyYzFbIHNyY09mZnNldDEgKyAzIF07XG5cblx0XHRpZiAoIHQgPT09IDAgKSB7XG5cblx0XHRcdGRzdFsgZHN0T2Zmc2V0ICsgMCBdID0geDA7XG5cdFx0XHRkc3RbIGRzdE9mZnNldCArIDEgXSA9IHkwO1xuXHRcdFx0ZHN0WyBkc3RPZmZzZXQgKyAyIF0gPSB6MDtcblx0XHRcdGRzdFsgZHN0T2Zmc2V0ICsgMyBdID0gdzA7XG5cdFx0XHRyZXR1cm47XG5cblx0XHR9XG5cblx0XHRpZiAoIHQgPT09IDEgKSB7XG5cblx0XHRcdGRzdFsgZHN0T2Zmc2V0ICsgMCBdID0geDE7XG5cdFx0XHRkc3RbIGRzdE9mZnNldCArIDEgXSA9IHkxO1xuXHRcdFx0ZHN0WyBkc3RPZmZzZXQgKyAyIF0gPSB6MTtcblx0XHRcdGRzdFsgZHN0T2Zmc2V0ICsgMyBdID0gdzE7XG5cdFx0XHRyZXR1cm47XG5cblx0XHR9XG5cblx0XHRpZiAoIHcwICE9PSB3MSB8fCB4MCAhPT0geDEgfHwgeTAgIT09IHkxIHx8IHowICE9PSB6MSApIHtcblxuXHRcdFx0bGV0IHMgPSAxIC0gdDtcblx0XHRcdGNvbnN0IGNvcyA9IHgwICogeDEgKyB5MCAqIHkxICsgejAgKiB6MSArIHcwICogdzEsXG5cdFx0XHRcdGRpciA9ICggY29zID49IDAgPyAxIDogLSAxICksXG5cdFx0XHRcdHNxclNpbiA9IDEgLSBjb3MgKiBjb3M7XG5cblx0XHRcdC8vIFNraXAgdGhlIFNsZXJwIGZvciB0aW55IHN0ZXBzIHRvIGF2b2lkIG51bWVyaWMgcHJvYmxlbXM6XG5cdFx0XHRpZiAoIHNxclNpbiA+IE51bWJlci5FUFNJTE9OICkge1xuXG5cdFx0XHRcdGNvbnN0IHNpbiA9IE1hdGguc3FydCggc3FyU2luICksXG5cdFx0XHRcdFx0bGVuID0gTWF0aC5hdGFuMiggc2luLCBjb3MgKiBkaXIgKTtcblxuXHRcdFx0XHRzID0gTWF0aC5zaW4oIHMgKiBsZW4gKSAvIHNpbjtcblx0XHRcdFx0dCA9IE1hdGguc2luKCB0ICogbGVuICkgLyBzaW47XG5cblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgdERpciA9IHQgKiBkaXI7XG5cblx0XHRcdHgwID0geDAgKiBzICsgeDEgKiB0RGlyO1xuXHRcdFx0eTAgPSB5MCAqIHMgKyB5MSAqIHREaXI7XG5cdFx0XHR6MCA9IHowICogcyArIHoxICogdERpcjtcblx0XHRcdHcwID0gdzAgKiBzICsgdzEgKiB0RGlyO1xuXG5cdFx0XHQvLyBOb3JtYWxpemUgaW4gY2FzZSB3ZSBqdXN0IGRpZCBhIGxlcnA6XG5cdFx0XHRpZiAoIHMgPT09IDEgLSB0ICkge1xuXG5cdFx0XHRcdGNvbnN0IGYgPSAxIC8gTWF0aC5zcXJ0KCB4MCAqIHgwICsgeTAgKiB5MCArIHowICogejAgKyB3MCAqIHcwICk7XG5cblx0XHRcdFx0eDAgKj0gZjtcblx0XHRcdFx0eTAgKj0gZjtcblx0XHRcdFx0ejAgKj0gZjtcblx0XHRcdFx0dzAgKj0gZjtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0ZHN0WyBkc3RPZmZzZXQgXSA9IHgwO1xuXHRcdGRzdFsgZHN0T2Zmc2V0ICsgMSBdID0geTA7XG5cdFx0ZHN0WyBkc3RPZmZzZXQgKyAyIF0gPSB6MDtcblx0XHRkc3RbIGRzdE9mZnNldCArIDMgXSA9IHcwO1xuXG5cdH1cblxuXHRzdGF0aWMgbXVsdGlwbHlRdWF0ZXJuaW9uc0ZsYXQoIGRzdCwgZHN0T2Zmc2V0LCBzcmMwLCBzcmNPZmZzZXQwLCBzcmMxLCBzcmNPZmZzZXQxICkge1xuXG5cdFx0Y29uc3QgeDAgPSBzcmMwWyBzcmNPZmZzZXQwIF07XG5cdFx0Y29uc3QgeTAgPSBzcmMwWyBzcmNPZmZzZXQwICsgMSBdO1xuXHRcdGNvbnN0IHowID0gc3JjMFsgc3JjT2Zmc2V0MCArIDIgXTtcblx0XHRjb25zdCB3MCA9IHNyYzBbIHNyY09mZnNldDAgKyAzIF07XG5cblx0XHRjb25zdCB4MSA9IHNyYzFbIHNyY09mZnNldDEgXTtcblx0XHRjb25zdCB5MSA9IHNyYzFbIHNyY09mZnNldDEgKyAxIF07XG5cdFx0Y29uc3QgejEgPSBzcmMxWyBzcmNPZmZzZXQxICsgMiBdO1xuXHRcdGNvbnN0IHcxID0gc3JjMVsgc3JjT2Zmc2V0MSArIDMgXTtcblxuXHRcdGRzdFsgZHN0T2Zmc2V0IF0gPSB4MCAqIHcxICsgdzAgKiB4MSArIHkwICogejEgLSB6MCAqIHkxO1xuXHRcdGRzdFsgZHN0T2Zmc2V0ICsgMSBdID0geTAgKiB3MSArIHcwICogeTEgKyB6MCAqIHgxIC0geDAgKiB6MTtcblx0XHRkc3RbIGRzdE9mZnNldCArIDIgXSA9IHowICogdzEgKyB3MCAqIHoxICsgeDAgKiB5MSAtIHkwICogeDE7XG5cdFx0ZHN0WyBkc3RPZmZzZXQgKyAzIF0gPSB3MCAqIHcxIC0geDAgKiB4MSAtIHkwICogeTEgLSB6MCAqIHoxO1xuXG5cdFx0cmV0dXJuIGRzdDtcblxuXHR9XG5cblx0Z2V0IHgoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5feDtcblxuXHR9XG5cblx0c2V0IHgoIHZhbHVlICkge1xuXG5cdFx0dGhpcy5feCA9IHZhbHVlO1xuXHRcdHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHR9XG5cblx0Z2V0IHkoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5feTtcblxuXHR9XG5cblx0c2V0IHkoIHZhbHVlICkge1xuXG5cdFx0dGhpcy5feSA9IHZhbHVlO1xuXHRcdHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHR9XG5cblx0Z2V0IHooKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5fejtcblxuXHR9XG5cblx0c2V0IHooIHZhbHVlICkge1xuXG5cdFx0dGhpcy5feiA9IHZhbHVlO1xuXHRcdHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHR9XG5cblx0Z2V0IHcoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5fdztcblxuXHR9XG5cblx0c2V0IHcoIHZhbHVlICkge1xuXG5cdFx0dGhpcy5fdyA9IHZhbHVlO1xuXHRcdHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHR9XG5cblx0c2V0KCB4LCB5LCB6LCB3ICkge1xuXG5cdFx0dGhpcy5feCA9IHg7XG5cdFx0dGhpcy5feSA9IHk7XG5cdFx0dGhpcy5feiA9IHo7XG5cdFx0dGhpcy5fdyA9IHc7XG5cblx0XHR0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Y2xvbmUoKSB7XG5cblx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoIHRoaXMuX3gsIHRoaXMuX3ksIHRoaXMuX3osIHRoaXMuX3cgKTtcblxuXHR9XG5cblx0Y29weSggcXVhdGVybmlvbiApIHtcblxuXHRcdHRoaXMuX3ggPSBxdWF0ZXJuaW9uLng7XG5cdFx0dGhpcy5feSA9IHF1YXRlcm5pb24ueTtcblx0XHR0aGlzLl96ID0gcXVhdGVybmlvbi56O1xuXHRcdHRoaXMuX3cgPSBxdWF0ZXJuaW9uLnc7XG5cblx0XHR0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c2V0RnJvbUV1bGVyKCBldWxlciwgdXBkYXRlICkge1xuXG5cdFx0Y29uc3QgeCA9IGV1bGVyLl94LCB5ID0gZXVsZXIuX3ksIHogPSBldWxlci5feiwgb3JkZXIgPSBldWxlci5fb3JkZXI7XG5cblx0XHQvLyBodHRwOi8vd3d3Lm1hdGh3b3Jrcy5jb20vbWF0bGFiY2VudHJhbC9maWxlZXhjaGFuZ2UvXG5cdFx0Ly8gXHQyMDY5Ni1mdW5jdGlvbi10by1jb252ZXJ0LWJldHdlZW4tZGNtLWV1bGVyLWFuZ2xlcy1xdWF0ZXJuaW9ucy1hbmQtZXVsZXItdmVjdG9ycy9cblx0XHQvL1x0Y29udGVudC9TcGluQ2FsYy5tXG5cblx0XHRjb25zdCBjb3MgPSBNYXRoLmNvcztcblx0XHRjb25zdCBzaW4gPSBNYXRoLnNpbjtcblxuXHRcdGNvbnN0IGMxID0gY29zKCB4IC8gMiApO1xuXHRcdGNvbnN0IGMyID0gY29zKCB5IC8gMiApO1xuXHRcdGNvbnN0IGMzID0gY29zKCB6IC8gMiApO1xuXG5cdFx0Y29uc3QgczEgPSBzaW4oIHggLyAyICk7XG5cdFx0Y29uc3QgczIgPSBzaW4oIHkgLyAyICk7XG5cdFx0Y29uc3QgczMgPSBzaW4oIHogLyAyICk7XG5cblx0XHRzd2l0Y2ggKCBvcmRlciApIHtcblxuXHRcdFx0Y2FzZSAnWFlaJzpcblx0XHRcdFx0dGhpcy5feCA9IHMxICogYzIgKiBjMyArIGMxICogczIgKiBzMztcblx0XHRcdFx0dGhpcy5feSA9IGMxICogczIgKiBjMyAtIHMxICogYzIgKiBzMztcblx0XHRcdFx0dGhpcy5feiA9IGMxICogYzIgKiBzMyArIHMxICogczIgKiBjMztcblx0XHRcdFx0dGhpcy5fdyA9IGMxICogYzIgKiBjMyAtIHMxICogczIgKiBzMztcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgJ1lYWic6XG5cdFx0XHRcdHRoaXMuX3ggPSBzMSAqIGMyICogYzMgKyBjMSAqIHMyICogczM7XG5cdFx0XHRcdHRoaXMuX3kgPSBjMSAqIHMyICogYzMgLSBzMSAqIGMyICogczM7XG5cdFx0XHRcdHRoaXMuX3ogPSBjMSAqIGMyICogczMgLSBzMSAqIHMyICogYzM7XG5cdFx0XHRcdHRoaXMuX3cgPSBjMSAqIGMyICogYzMgKyBzMSAqIHMyICogczM7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlICdaWFknOlxuXHRcdFx0XHR0aGlzLl94ID0gczEgKiBjMiAqIGMzIC0gYzEgKiBzMiAqIHMzO1xuXHRcdFx0XHR0aGlzLl95ID0gYzEgKiBzMiAqIGMzICsgczEgKiBjMiAqIHMzO1xuXHRcdFx0XHR0aGlzLl96ID0gYzEgKiBjMiAqIHMzICsgczEgKiBzMiAqIGMzO1xuXHRcdFx0XHR0aGlzLl93ID0gYzEgKiBjMiAqIGMzIC0gczEgKiBzMiAqIHMzO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSAnWllYJzpcblx0XHRcdFx0dGhpcy5feCA9IHMxICogYzIgKiBjMyAtIGMxICogczIgKiBzMztcblx0XHRcdFx0dGhpcy5feSA9IGMxICogczIgKiBjMyArIHMxICogYzIgKiBzMztcblx0XHRcdFx0dGhpcy5feiA9IGMxICogYzIgKiBzMyAtIHMxICogczIgKiBjMztcblx0XHRcdFx0dGhpcy5fdyA9IGMxICogYzIgKiBjMyArIHMxICogczIgKiBzMztcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgJ1laWCc6XG5cdFx0XHRcdHRoaXMuX3ggPSBzMSAqIGMyICogYzMgKyBjMSAqIHMyICogczM7XG5cdFx0XHRcdHRoaXMuX3kgPSBjMSAqIHMyICogYzMgKyBzMSAqIGMyICogczM7XG5cdFx0XHRcdHRoaXMuX3ogPSBjMSAqIGMyICogczMgLSBzMSAqIHMyICogYzM7XG5cdFx0XHRcdHRoaXMuX3cgPSBjMSAqIGMyICogYzMgLSBzMSAqIHMyICogczM7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlICdYWlknOlxuXHRcdFx0XHR0aGlzLl94ID0gczEgKiBjMiAqIGMzIC0gYzEgKiBzMiAqIHMzO1xuXHRcdFx0XHR0aGlzLl95ID0gYzEgKiBzMiAqIGMzIC0gczEgKiBjMiAqIHMzO1xuXHRcdFx0XHR0aGlzLl96ID0gYzEgKiBjMiAqIHMzICsgczEgKiBzMiAqIGMzO1xuXHRcdFx0XHR0aGlzLl93ID0gYzEgKiBjMiAqIGMzICsgczEgKiBzMiAqIHMzO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuUXVhdGVybmlvbjogLnNldEZyb21FdWxlcigpIGVuY291bnRlcmVkIGFuIHVua25vd24gb3JkZXI6ICcgKyBvcmRlciApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCB1cGRhdGUgIT09IGZhbHNlICkgdGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHNldEZyb21BeGlzQW5nbGUoIGF4aXMsIGFuZ2xlICkge1xuXG5cdFx0Ly8gaHR0cDovL3d3dy5ldWNsaWRlYW5zcGFjZS5jb20vbWF0aHMvZ2VvbWV0cnkvcm90YXRpb25zL2NvbnZlcnNpb25zL2FuZ2xlVG9RdWF0ZXJuaW9uL2luZGV4Lmh0bVxuXG5cdFx0Ly8gYXNzdW1lcyBheGlzIGlzIG5vcm1hbGl6ZWRcblxuXHRcdGNvbnN0IGhhbGZBbmdsZSA9IGFuZ2xlIC8gMiwgcyA9IE1hdGguc2luKCBoYWxmQW5nbGUgKTtcblxuXHRcdHRoaXMuX3ggPSBheGlzLnggKiBzO1xuXHRcdHRoaXMuX3kgPSBheGlzLnkgKiBzO1xuXHRcdHRoaXMuX3ogPSBheGlzLnogKiBzO1xuXHRcdHRoaXMuX3cgPSBNYXRoLmNvcyggaGFsZkFuZ2xlICk7XG5cblx0XHR0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c2V0RnJvbVJvdGF0aW9uTWF0cml4KCBtICkge1xuXG5cdFx0Ly8gaHR0cDovL3d3dy5ldWNsaWRlYW5zcGFjZS5jb20vbWF0aHMvZ2VvbWV0cnkvcm90YXRpb25zL2NvbnZlcnNpb25zL21hdHJpeFRvUXVhdGVybmlvbi9pbmRleC5odG1cblxuXHRcdC8vIGFzc3VtZXMgdGhlIHVwcGVyIDN4MyBvZiBtIGlzIGEgcHVyZSByb3RhdGlvbiBtYXRyaXggKGkuZSwgdW5zY2FsZWQpXG5cblx0XHRjb25zdCB0ZSA9IG0uZWxlbWVudHMsXG5cblx0XHRcdG0xMSA9IHRlWyAwIF0sIG0xMiA9IHRlWyA0IF0sIG0xMyA9IHRlWyA4IF0sXG5cdFx0XHRtMjEgPSB0ZVsgMSBdLCBtMjIgPSB0ZVsgNSBdLCBtMjMgPSB0ZVsgOSBdLFxuXHRcdFx0bTMxID0gdGVbIDIgXSwgbTMyID0gdGVbIDYgXSwgbTMzID0gdGVbIDEwIF0sXG5cblx0XHRcdHRyYWNlID0gbTExICsgbTIyICsgbTMzO1xuXG5cdFx0aWYgKCB0cmFjZSA+IDAgKSB7XG5cblx0XHRcdGNvbnN0IHMgPSAwLjUgLyBNYXRoLnNxcnQoIHRyYWNlICsgMS4wICk7XG5cblx0XHRcdHRoaXMuX3cgPSAwLjI1IC8gcztcblx0XHRcdHRoaXMuX3ggPSAoIG0zMiAtIG0yMyApICogcztcblx0XHRcdHRoaXMuX3kgPSAoIG0xMyAtIG0zMSApICogcztcblx0XHRcdHRoaXMuX3ogPSAoIG0yMSAtIG0xMiApICogcztcblxuXHRcdH0gZWxzZSBpZiAoIG0xMSA+IG0yMiAmJiBtMTEgPiBtMzMgKSB7XG5cblx0XHRcdGNvbnN0IHMgPSAyLjAgKiBNYXRoLnNxcnQoIDEuMCArIG0xMSAtIG0yMiAtIG0zMyApO1xuXG5cdFx0XHR0aGlzLl93ID0gKCBtMzIgLSBtMjMgKSAvIHM7XG5cdFx0XHR0aGlzLl94ID0gMC4yNSAqIHM7XG5cdFx0XHR0aGlzLl95ID0gKCBtMTIgKyBtMjEgKSAvIHM7XG5cdFx0XHR0aGlzLl96ID0gKCBtMTMgKyBtMzEgKSAvIHM7XG5cblx0XHR9IGVsc2UgaWYgKCBtMjIgPiBtMzMgKSB7XG5cblx0XHRcdGNvbnN0IHMgPSAyLjAgKiBNYXRoLnNxcnQoIDEuMCArIG0yMiAtIG0xMSAtIG0zMyApO1xuXG5cdFx0XHR0aGlzLl93ID0gKCBtMTMgLSBtMzEgKSAvIHM7XG5cdFx0XHR0aGlzLl94ID0gKCBtMTIgKyBtMjEgKSAvIHM7XG5cdFx0XHR0aGlzLl95ID0gMC4yNSAqIHM7XG5cdFx0XHR0aGlzLl96ID0gKCBtMjMgKyBtMzIgKSAvIHM7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRjb25zdCBzID0gMi4wICogTWF0aC5zcXJ0KCAxLjAgKyBtMzMgLSBtMTEgLSBtMjIgKTtcblxuXHRcdFx0dGhpcy5fdyA9ICggbTIxIC0gbTEyICkgLyBzO1xuXHRcdFx0dGhpcy5feCA9ICggbTEzICsgbTMxICkgLyBzO1xuXHRcdFx0dGhpcy5feSA9ICggbTIzICsgbTMyICkgLyBzO1xuXHRcdFx0dGhpcy5feiA9IDAuMjUgKiBzO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHNldEZyb21Vbml0VmVjdG9ycyggdkZyb20sIHZUbyApIHtcblxuXHRcdC8vIGFzc3VtZXMgZGlyZWN0aW9uIHZlY3RvcnMgdkZyb20gYW5kIHZUbyBhcmUgbm9ybWFsaXplZFxuXG5cdFx0bGV0IHIgPSB2RnJvbS5kb3QoIHZUbyApICsgMTtcblxuXHRcdGlmICggciA8IE51bWJlci5FUFNJTE9OICkge1xuXG5cdFx0XHQvLyB2RnJvbSBhbmQgdlRvIHBvaW50IGluIG9wcG9zaXRlIGRpcmVjdGlvbnNcblxuXHRcdFx0ciA9IDA7XG5cblx0XHRcdGlmICggTWF0aC5hYnMoIHZGcm9tLnggKSA+IE1hdGguYWJzKCB2RnJvbS56ICkgKSB7XG5cblx0XHRcdFx0dGhpcy5feCA9IC0gdkZyb20ueTtcblx0XHRcdFx0dGhpcy5feSA9IHZGcm9tLng7XG5cdFx0XHRcdHRoaXMuX3ogPSAwO1xuXHRcdFx0XHR0aGlzLl93ID0gcjtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHR0aGlzLl94ID0gMDtcblx0XHRcdFx0dGhpcy5feSA9IC0gdkZyb20uejtcblx0XHRcdFx0dGhpcy5feiA9IHZGcm9tLnk7XG5cdFx0XHRcdHRoaXMuX3cgPSByO1xuXG5cdFx0XHR9XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBjcm9zc1ZlY3RvcnMoIHZGcm9tLCB2VG8gKTsgLy8gaW5saW5lZCB0byBhdm9pZCBjeWNsaWMgZGVwZW5kZW5jeSBvbiBWZWN0b3IzXG5cblx0XHRcdHRoaXMuX3ggPSB2RnJvbS55ICogdlRvLnogLSB2RnJvbS56ICogdlRvLnk7XG5cdFx0XHR0aGlzLl95ID0gdkZyb20ueiAqIHZUby54IC0gdkZyb20ueCAqIHZUby56O1xuXHRcdFx0dGhpcy5feiA9IHZGcm9tLnggKiB2VG8ueSAtIHZGcm9tLnkgKiB2VG8ueDtcblx0XHRcdHRoaXMuX3cgPSByO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMubm9ybWFsaXplKCk7XG5cblx0fVxuXG5cdGFuZ2xlVG8oIHEgKSB7XG5cblx0XHRyZXR1cm4gMiAqIE1hdGguYWNvcyggTWF0aC5hYnMoIE1hdGhVdGlscy5jbGFtcCggdGhpcy5kb3QoIHEgKSwgLSAxLCAxICkgKSApO1xuXG5cdH1cblxuXHRyb3RhdGVUb3dhcmRzKCBxLCBzdGVwICkge1xuXG5cdFx0Y29uc3QgYW5nbGUgPSB0aGlzLmFuZ2xlVG8oIHEgKTtcblxuXHRcdGlmICggYW5nbGUgPT09IDAgKSByZXR1cm4gdGhpcztcblxuXHRcdGNvbnN0IHQgPSBNYXRoLm1pbiggMSwgc3RlcCAvIGFuZ2xlICk7XG5cblx0XHR0aGlzLnNsZXJwKCBxLCB0ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0aWRlbnRpdHkoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5zZXQoIDAsIDAsIDAsIDEgKTtcblxuXHR9XG5cblx0aW52ZXJ0KCkge1xuXG5cdFx0Ly8gcXVhdGVybmlvbiBpcyBhc3N1bWVkIHRvIGhhdmUgdW5pdCBsZW5ndGhcblxuXHRcdHJldHVybiB0aGlzLmNvbmp1Z2F0ZSgpO1xuXG5cdH1cblxuXHRjb25qdWdhdGUoKSB7XG5cblx0XHR0aGlzLl94ICo9IC0gMTtcblx0XHR0aGlzLl95ICo9IC0gMTtcblx0XHR0aGlzLl96ICo9IC0gMTtcblxuXHRcdHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRkb3QoIHYgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5feCAqIHYuX3ggKyB0aGlzLl95ICogdi5feSArIHRoaXMuX3ogKiB2Ll96ICsgdGhpcy5fdyAqIHYuX3c7XG5cblx0fVxuXG5cdGxlbmd0aFNxKCkge1xuXG5cdFx0cmV0dXJuIHRoaXMuX3ggKiB0aGlzLl94ICsgdGhpcy5feSAqIHRoaXMuX3kgKyB0aGlzLl96ICogdGhpcy5feiArIHRoaXMuX3cgKiB0aGlzLl93O1xuXG5cdH1cblxuXHRsZW5ndGgoKSB7XG5cblx0XHRyZXR1cm4gTWF0aC5zcXJ0KCB0aGlzLl94ICogdGhpcy5feCArIHRoaXMuX3kgKiB0aGlzLl95ICsgdGhpcy5feiAqIHRoaXMuX3ogKyB0aGlzLl93ICogdGhpcy5fdyApO1xuXG5cdH1cblxuXHRub3JtYWxpemUoKSB7XG5cblx0XHRsZXQgbCA9IHRoaXMubGVuZ3RoKCk7XG5cblx0XHRpZiAoIGwgPT09IDAgKSB7XG5cblx0XHRcdHRoaXMuX3ggPSAwO1xuXHRcdFx0dGhpcy5feSA9IDA7XG5cdFx0XHR0aGlzLl96ID0gMDtcblx0XHRcdHRoaXMuX3cgPSAxO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0bCA9IDEgLyBsO1xuXG5cdFx0XHR0aGlzLl94ID0gdGhpcy5feCAqIGw7XG5cdFx0XHR0aGlzLl95ID0gdGhpcy5feSAqIGw7XG5cdFx0XHR0aGlzLl96ID0gdGhpcy5feiAqIGw7XG5cdFx0XHR0aGlzLl93ID0gdGhpcy5fdyAqIGw7XG5cblx0XHR9XG5cblx0XHR0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0bXVsdGlwbHkoIHEgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5tdWx0aXBseVF1YXRlcm5pb25zKCB0aGlzLCBxICk7XG5cblx0fVxuXG5cdHByZW11bHRpcGx5KCBxICkge1xuXG5cdFx0cmV0dXJuIHRoaXMubXVsdGlwbHlRdWF0ZXJuaW9ucyggcSwgdGhpcyApO1xuXG5cdH1cblxuXHRtdWx0aXBseVF1YXRlcm5pb25zKCBhLCBiICkge1xuXG5cdFx0Ly8gZnJvbSBodHRwOi8vd3d3LmV1Y2xpZGVhbnNwYWNlLmNvbS9tYXRocy9hbGdlYnJhL3JlYWxOb3JtZWRBbGdlYnJhL3F1YXRlcm5pb25zL2NvZGUvaW5kZXguaHRtXG5cblx0XHRjb25zdCBxYXggPSBhLl94LCBxYXkgPSBhLl95LCBxYXogPSBhLl96LCBxYXcgPSBhLl93O1xuXHRcdGNvbnN0IHFieCA9IGIuX3gsIHFieSA9IGIuX3ksIHFieiA9IGIuX3osIHFidyA9IGIuX3c7XG5cblx0XHR0aGlzLl94ID0gcWF4ICogcWJ3ICsgcWF3ICogcWJ4ICsgcWF5ICogcWJ6IC0gcWF6ICogcWJ5O1xuXHRcdHRoaXMuX3kgPSBxYXkgKiBxYncgKyBxYXcgKiBxYnkgKyBxYXogKiBxYnggLSBxYXggKiBxYno7XG5cdFx0dGhpcy5feiA9IHFheiAqIHFidyArIHFhdyAqIHFieiArIHFheCAqIHFieSAtIHFheSAqIHFieDtcblx0XHR0aGlzLl93ID0gcWF3ICogcWJ3IC0gcWF4ICogcWJ4IC0gcWF5ICogcWJ5IC0gcWF6ICogcWJ6O1xuXG5cdFx0dGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHNsZXJwKCBxYiwgdCApIHtcblxuXHRcdGlmICggdCA9PT0gMCApIHJldHVybiB0aGlzO1xuXHRcdGlmICggdCA9PT0gMSApIHJldHVybiB0aGlzLmNvcHkoIHFiICk7XG5cblx0XHRjb25zdCB4ID0gdGhpcy5feCwgeSA9IHRoaXMuX3ksIHogPSB0aGlzLl96LCB3ID0gdGhpcy5fdztcblxuXHRcdC8vIGh0dHA6Ly93d3cuZXVjbGlkZWFuc3BhY2UuY29tL21hdGhzL2FsZ2VicmEvcmVhbE5vcm1lZEFsZ2VicmEvcXVhdGVybmlvbnMvc2xlcnAvXG5cblx0XHRsZXQgY29zSGFsZlRoZXRhID0gdyAqIHFiLl93ICsgeCAqIHFiLl94ICsgeSAqIHFiLl95ICsgeiAqIHFiLl96O1xuXG5cdFx0aWYgKCBjb3NIYWxmVGhldGEgPCAwICkge1xuXG5cdFx0XHR0aGlzLl93ID0gLSBxYi5fdztcblx0XHRcdHRoaXMuX3ggPSAtIHFiLl94O1xuXHRcdFx0dGhpcy5feSA9IC0gcWIuX3k7XG5cdFx0XHR0aGlzLl96ID0gLSBxYi5fejtcblxuXHRcdFx0Y29zSGFsZlRoZXRhID0gLSBjb3NIYWxmVGhldGE7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHR0aGlzLmNvcHkoIHFiICk7XG5cblx0XHR9XG5cblx0XHRpZiAoIGNvc0hhbGZUaGV0YSA+PSAxLjAgKSB7XG5cblx0XHRcdHRoaXMuX3cgPSB3O1xuXHRcdFx0dGhpcy5feCA9IHg7XG5cdFx0XHR0aGlzLl95ID0geTtcblx0XHRcdHRoaXMuX3ogPSB6O1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH1cblxuXHRcdGNvbnN0IHNxclNpbkhhbGZUaGV0YSA9IDEuMCAtIGNvc0hhbGZUaGV0YSAqIGNvc0hhbGZUaGV0YTtcblxuXHRcdGlmICggc3FyU2luSGFsZlRoZXRhIDw9IE51bWJlci5FUFNJTE9OICkge1xuXG5cdFx0XHRjb25zdCBzID0gMSAtIHQ7XG5cdFx0XHR0aGlzLl93ID0gcyAqIHcgKyB0ICogdGhpcy5fdztcblx0XHRcdHRoaXMuX3ggPSBzICogeCArIHQgKiB0aGlzLl94O1xuXHRcdFx0dGhpcy5feSA9IHMgKiB5ICsgdCAqIHRoaXMuX3k7XG5cdFx0XHR0aGlzLl96ID0gcyAqIHogKyB0ICogdGhpcy5fejtcblxuXHRcdFx0dGhpcy5ub3JtYWxpemUoKTtcblx0XHRcdHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9XG5cblx0XHRjb25zdCBzaW5IYWxmVGhldGEgPSBNYXRoLnNxcnQoIHNxclNpbkhhbGZUaGV0YSApO1xuXHRcdGNvbnN0IGhhbGZUaGV0YSA9IE1hdGguYXRhbjIoIHNpbkhhbGZUaGV0YSwgY29zSGFsZlRoZXRhICk7XG5cdFx0Y29uc3QgcmF0aW9BID0gTWF0aC5zaW4oICggMSAtIHQgKSAqIGhhbGZUaGV0YSApIC8gc2luSGFsZlRoZXRhLFxuXHRcdFx0cmF0aW9CID0gTWF0aC5zaW4oIHQgKiBoYWxmVGhldGEgKSAvIHNpbkhhbGZUaGV0YTtcblxuXHRcdHRoaXMuX3cgPSAoIHcgKiByYXRpb0EgKyB0aGlzLl93ICogcmF0aW9CICk7XG5cdFx0dGhpcy5feCA9ICggeCAqIHJhdGlvQSArIHRoaXMuX3ggKiByYXRpb0IgKTtcblx0XHR0aGlzLl95ID0gKCB5ICogcmF0aW9BICsgdGhpcy5feSAqIHJhdGlvQiApO1xuXHRcdHRoaXMuX3ogPSAoIHogKiByYXRpb0EgKyB0aGlzLl96ICogcmF0aW9CICk7XG5cblx0XHR0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c2xlcnBRdWF0ZXJuaW9ucyggcWEsIHFiLCB0ICkge1xuXG5cdFx0cmV0dXJuIHRoaXMuY29weSggcWEgKS5zbGVycCggcWIsIHQgKTtcblxuXHR9XG5cblx0cmFuZG9tKCkge1xuXG5cdFx0Ly8gRGVyaXZlZCBmcm9tIGh0dHA6Ly9wbGFubmluZy5jcy51aXVjLmVkdS9ub2RlMTk4Lmh0bWxcblx0XHQvLyBOb3RlLCB0aGlzIHNvdXJjZSB1c2VzIHcsIHgsIHksIHogb3JkZXJpbmcsXG5cdFx0Ly8gc28gd2Ugc3dhcCB0aGUgb3JkZXIgYmVsb3cuXG5cblx0XHRjb25zdCB1MSA9IE1hdGgucmFuZG9tKCk7XG5cdFx0Y29uc3Qgc3FydDF1MSA9IE1hdGguc3FydCggMSAtIHUxICk7XG5cdFx0Y29uc3Qgc3FydHUxID0gTWF0aC5zcXJ0KCB1MSApO1xuXG5cdFx0Y29uc3QgdTIgPSAyICogTWF0aC5QSSAqIE1hdGgucmFuZG9tKCk7XG5cblx0XHRjb25zdCB1MyA9IDIgKiBNYXRoLlBJICogTWF0aC5yYW5kb20oKTtcblxuXHRcdHJldHVybiB0aGlzLnNldChcblx0XHRcdHNxcnQxdTEgKiBNYXRoLmNvcyggdTIgKSxcblx0XHRcdHNxcnR1MSAqIE1hdGguc2luKCB1MyApLFxuXHRcdFx0c3FydHUxICogTWF0aC5jb3MoIHUzICksXG5cdFx0XHRzcXJ0MXUxICogTWF0aC5zaW4oIHUyICksXG5cdFx0KTtcblxuXHR9XG5cblx0ZXF1YWxzKCBxdWF0ZXJuaW9uICkge1xuXG5cdFx0cmV0dXJuICggcXVhdGVybmlvbi5feCA9PT0gdGhpcy5feCApICYmICggcXVhdGVybmlvbi5feSA9PT0gdGhpcy5feSApICYmICggcXVhdGVybmlvbi5feiA9PT0gdGhpcy5feiApICYmICggcXVhdGVybmlvbi5fdyA9PT0gdGhpcy5fdyApO1xuXG5cdH1cblxuXHRmcm9tQXJyYXkoIGFycmF5LCBvZmZzZXQgPSAwICkge1xuXG5cdFx0dGhpcy5feCA9IGFycmF5WyBvZmZzZXQgXTtcblx0XHR0aGlzLl95ID0gYXJyYXlbIG9mZnNldCArIDEgXTtcblx0XHR0aGlzLl96ID0gYXJyYXlbIG9mZnNldCArIDIgXTtcblx0XHR0aGlzLl93ID0gYXJyYXlbIG9mZnNldCArIDMgXTtcblxuXHRcdHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHR0b0FycmF5KCBhcnJheSA9IFtdLCBvZmZzZXQgPSAwICkge1xuXG5cdFx0YXJyYXlbIG9mZnNldCBdID0gdGhpcy5feDtcblx0XHRhcnJheVsgb2Zmc2V0ICsgMSBdID0gdGhpcy5feTtcblx0XHRhcnJheVsgb2Zmc2V0ICsgMiBdID0gdGhpcy5fejtcblx0XHRhcnJheVsgb2Zmc2V0ICsgMyBdID0gdGhpcy5fdztcblxuXHRcdHJldHVybiBhcnJheTtcblxuXHR9XG5cblx0ZnJvbUJ1ZmZlckF0dHJpYnV0ZSggYXR0cmlidXRlLCBpbmRleCApIHtcblxuXHRcdHRoaXMuX3ggPSBhdHRyaWJ1dGUuZ2V0WCggaW5kZXggKTtcblx0XHR0aGlzLl95ID0gYXR0cmlidXRlLmdldFkoIGluZGV4ICk7XG5cdFx0dGhpcy5feiA9IGF0dHJpYnV0ZS5nZXRaKCBpbmRleCApO1xuXHRcdHRoaXMuX3cgPSBhdHRyaWJ1dGUuZ2V0VyggaW5kZXggKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHR0b0pTT04oKSB7XG5cblx0XHRyZXR1cm4gdGhpcy50b0FycmF5KCk7XG5cblx0fVxuXG5cdF9vbkNoYW5nZSggY2FsbGJhY2sgKSB7XG5cblx0XHR0aGlzLl9vbkNoYW5nZUNhbGxiYWNrID0gY2FsbGJhY2s7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0X29uQ2hhbmdlQ2FsbGJhY2soKSB7fVxuXG5cdCpbIFN5bWJvbC5pdGVyYXRvciBdKCkge1xuXG5cdFx0eWllbGQgdGhpcy5feDtcblx0XHR5aWVsZCB0aGlzLl95O1xuXHRcdHlpZWxkIHRoaXMuX3o7XG5cdFx0eWllbGQgdGhpcy5fdztcblxuXHR9XG5cbn1cblxuZXhwb3J0IHsgUXVhdGVybmlvbiB9O1xuIiwiaW1wb3J0IHsgQm94MyB9IGZyb20gJy4vQm94My5qcyc7XG5pbXBvcnQgeyBWZWN0b3IzIH0gZnJvbSAnLi9WZWN0b3IzLmpzJztcblxuY29uc3QgX2JveCA9IC8qQF9fUFVSRV9fKi8gbmV3IEJveDMoKTtcbmNvbnN0IF92MSA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcbmNvbnN0IF92MiA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcblxuY2xhc3MgU3BoZXJlIHtcblxuXHRjb25zdHJ1Y3RvciggY2VudGVyID0gbmV3IFZlY3RvcjMoKSwgcmFkaXVzID0gLSAxICkge1xuXG5cdFx0dGhpcy5jZW50ZXIgPSBjZW50ZXI7XG5cdFx0dGhpcy5yYWRpdXMgPSByYWRpdXM7XG5cblx0fVxuXG5cdHNldCggY2VudGVyLCByYWRpdXMgKSB7XG5cblx0XHR0aGlzLmNlbnRlci5jb3B5KCBjZW50ZXIgKTtcblx0XHR0aGlzLnJhZGl1cyA9IHJhZGl1cztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzZXRGcm9tUG9pbnRzKCBwb2ludHMsIG9wdGlvbmFsQ2VudGVyICkge1xuXG5cdFx0Y29uc3QgY2VudGVyID0gdGhpcy5jZW50ZXI7XG5cblx0XHRpZiAoIG9wdGlvbmFsQ2VudGVyICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGNlbnRlci5jb3B5KCBvcHRpb25hbENlbnRlciApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0X2JveC5zZXRGcm9tUG9pbnRzKCBwb2ludHMgKS5nZXRDZW50ZXIoIGNlbnRlciApO1xuXG5cdFx0fVxuXG5cdFx0bGV0IG1heFJhZGl1c1NxID0gMDtcblxuXHRcdGZvciAoIGxldCBpID0gMCwgaWwgPSBwb2ludHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdG1heFJhZGl1c1NxID0gTWF0aC5tYXgoIG1heFJhZGl1c1NxLCBjZW50ZXIuZGlzdGFuY2VUb1NxdWFyZWQoIHBvaW50c1sgaSBdICkgKTtcblxuXHRcdH1cblxuXHRcdHRoaXMucmFkaXVzID0gTWF0aC5zcXJ0KCBtYXhSYWRpdXNTcSApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGNvcHkoIHNwaGVyZSApIHtcblxuXHRcdHRoaXMuY2VudGVyLmNvcHkoIHNwaGVyZS5jZW50ZXIgKTtcblx0XHR0aGlzLnJhZGl1cyA9IHNwaGVyZS5yYWRpdXM7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0aXNFbXB0eSgpIHtcblxuXHRcdHJldHVybiAoIHRoaXMucmFkaXVzIDwgMCApO1xuXG5cdH1cblxuXHRtYWtlRW1wdHkoKSB7XG5cblx0XHR0aGlzLmNlbnRlci5zZXQoIDAsIDAsIDAgKTtcblx0XHR0aGlzLnJhZGl1cyA9IC0gMTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRjb250YWluc1BvaW50KCBwb2ludCApIHtcblxuXHRcdHJldHVybiAoIHBvaW50LmRpc3RhbmNlVG9TcXVhcmVkKCB0aGlzLmNlbnRlciApIDw9ICggdGhpcy5yYWRpdXMgKiB0aGlzLnJhZGl1cyApICk7XG5cblx0fVxuXG5cdGRpc3RhbmNlVG9Qb2ludCggcG9pbnQgKSB7XG5cblx0XHRyZXR1cm4gKCBwb2ludC5kaXN0YW5jZVRvKCB0aGlzLmNlbnRlciApIC0gdGhpcy5yYWRpdXMgKTtcblxuXHR9XG5cblx0aW50ZXJzZWN0c1NwaGVyZSggc3BoZXJlICkge1xuXG5cdFx0Y29uc3QgcmFkaXVzU3VtID0gdGhpcy5yYWRpdXMgKyBzcGhlcmUucmFkaXVzO1xuXG5cdFx0cmV0dXJuIHNwaGVyZS5jZW50ZXIuZGlzdGFuY2VUb1NxdWFyZWQoIHRoaXMuY2VudGVyICkgPD0gKCByYWRpdXNTdW0gKiByYWRpdXNTdW0gKTtcblxuXHR9XG5cblx0aW50ZXJzZWN0c0JveCggYm94ICkge1xuXG5cdFx0cmV0dXJuIGJveC5pbnRlcnNlY3RzU3BoZXJlKCB0aGlzICk7XG5cblx0fVxuXG5cdGludGVyc2VjdHNQbGFuZSggcGxhbmUgKSB7XG5cblx0XHRyZXR1cm4gTWF0aC5hYnMoIHBsYW5lLmRpc3RhbmNlVG9Qb2ludCggdGhpcy5jZW50ZXIgKSApIDw9IHRoaXMucmFkaXVzO1xuXG5cdH1cblxuXHRjbGFtcFBvaW50KCBwb2ludCwgdGFyZ2V0ICkge1xuXG5cdFx0Y29uc3QgZGVsdGFMZW5ndGhTcSA9IHRoaXMuY2VudGVyLmRpc3RhbmNlVG9TcXVhcmVkKCBwb2ludCApO1xuXG5cdFx0dGFyZ2V0LmNvcHkoIHBvaW50ICk7XG5cblx0XHRpZiAoIGRlbHRhTGVuZ3RoU3EgPiAoIHRoaXMucmFkaXVzICogdGhpcy5yYWRpdXMgKSApIHtcblxuXHRcdFx0dGFyZ2V0LnN1YiggdGhpcy5jZW50ZXIgKS5ub3JtYWxpemUoKTtcblx0XHRcdHRhcmdldC5tdWx0aXBseVNjYWxhciggdGhpcy5yYWRpdXMgKS5hZGQoIHRoaXMuY2VudGVyICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGFyZ2V0O1xuXG5cdH1cblxuXHRnZXRCb3VuZGluZ0JveCggdGFyZ2V0ICkge1xuXG5cdFx0aWYgKCB0aGlzLmlzRW1wdHkoKSApIHtcblxuXHRcdFx0Ly8gRW1wdHkgc3BoZXJlIHByb2R1Y2VzIGVtcHR5IGJvdW5kaW5nIGJveFxuXHRcdFx0dGFyZ2V0Lm1ha2VFbXB0eSgpO1xuXHRcdFx0cmV0dXJuIHRhcmdldDtcblxuXHRcdH1cblxuXHRcdHRhcmdldC5zZXQoIHRoaXMuY2VudGVyLCB0aGlzLmNlbnRlciApO1xuXHRcdHRhcmdldC5leHBhbmRCeVNjYWxhciggdGhpcy5yYWRpdXMgKTtcblxuXHRcdHJldHVybiB0YXJnZXQ7XG5cblx0fVxuXG5cdGFwcGx5TWF0cml4NCggbWF0cml4ICkge1xuXG5cdFx0dGhpcy5jZW50ZXIuYXBwbHlNYXRyaXg0KCBtYXRyaXggKTtcblx0XHR0aGlzLnJhZGl1cyA9IHRoaXMucmFkaXVzICogbWF0cml4LmdldE1heFNjYWxlT25BeGlzKCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0dHJhbnNsYXRlKCBvZmZzZXQgKSB7XG5cblx0XHR0aGlzLmNlbnRlci5hZGQoIG9mZnNldCApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGV4cGFuZEJ5UG9pbnQoIHBvaW50ICkge1xuXG5cdFx0aWYgKCB0aGlzLmlzRW1wdHkoKSApIHtcblxuXHRcdFx0dGhpcy5jZW50ZXIuY29weSggcG9pbnQgKTtcblxuXHRcdFx0dGhpcy5yYWRpdXMgPSAwO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH1cblxuXHRcdF92MS5zdWJWZWN0b3JzKCBwb2ludCwgdGhpcy5jZW50ZXIgKTtcblxuXHRcdGNvbnN0IGxlbmd0aFNxID0gX3YxLmxlbmd0aFNxKCk7XG5cblx0XHRpZiAoIGxlbmd0aFNxID4gKCB0aGlzLnJhZGl1cyAqIHRoaXMucmFkaXVzICkgKSB7XG5cblx0XHRcdC8vIGNhbGN1bGF0ZSB0aGUgbWluaW1hbCBzcGhlcmVcblxuXHRcdFx0Y29uc3QgbGVuZ3RoID0gTWF0aC5zcXJ0KCBsZW5ndGhTcSApO1xuXG5cdFx0XHRjb25zdCBkZWx0YSA9ICggbGVuZ3RoIC0gdGhpcy5yYWRpdXMgKSAqIDAuNTtcblxuXHRcdFx0dGhpcy5jZW50ZXIuYWRkU2NhbGVkVmVjdG9yKCBfdjEsIGRlbHRhIC8gbGVuZ3RoICk7XG5cblx0XHRcdHRoaXMucmFkaXVzICs9IGRlbHRhO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHVuaW9uKCBzcGhlcmUgKSB7XG5cblx0XHRpZiAoIHNwaGVyZS5pc0VtcHR5KCkgKSB7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLmlzRW1wdHkoKSApIHtcblxuXHRcdFx0dGhpcy5jb3B5KCBzcGhlcmUgKTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9XG5cblx0XHRpZiAoIHRoaXMuY2VudGVyLmVxdWFscyggc3BoZXJlLmNlbnRlciApID09PSB0cnVlICkge1xuXG5cdFx0XHQgdGhpcy5yYWRpdXMgPSBNYXRoLm1heCggdGhpcy5yYWRpdXMsIHNwaGVyZS5yYWRpdXMgKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdF92Mi5zdWJWZWN0b3JzKCBzcGhlcmUuY2VudGVyLCB0aGlzLmNlbnRlciApLnNldExlbmd0aCggc3BoZXJlLnJhZGl1cyApO1xuXG5cdFx0XHR0aGlzLmV4cGFuZEJ5UG9pbnQoIF92MS5jb3B5KCBzcGhlcmUuY2VudGVyICkuYWRkKCBfdjIgKSApO1xuXG5cdFx0XHR0aGlzLmV4cGFuZEJ5UG9pbnQoIF92MS5jb3B5KCBzcGhlcmUuY2VudGVyICkuc3ViKCBfdjIgKSApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGVxdWFscyggc3BoZXJlICkge1xuXG5cdFx0cmV0dXJuIHNwaGVyZS5jZW50ZXIuZXF1YWxzKCB0aGlzLmNlbnRlciApICYmICggc3BoZXJlLnJhZGl1cyA9PT0gdGhpcy5yYWRpdXMgKTtcblxuXHR9XG5cblx0Y2xvbmUoKSB7XG5cblx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzICk7XG5cblx0fVxuXG59XG5cbmV4cG9ydCB7IFNwaGVyZSB9O1xuIiwiaW1wb3J0IHsgVmVjdG9yMyB9IGZyb20gJy4vVmVjdG9yMy5qcyc7XG5cbmNvbnN0IF92MCA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcbmNvbnN0IF92MSA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcbmNvbnN0IF92MiA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcbmNvbnN0IF92MyA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcblxuY29uc3QgX3ZhYiA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcbmNvbnN0IF92YWMgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XG5jb25zdCBfdmJjID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xuY29uc3QgX3ZhcCA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcbmNvbnN0IF92YnAgPSAvKkBfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XG5jb25zdCBfdmNwID0gLypAX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xuXG5sZXQgd2FybmVkR2V0VVYgPSBmYWxzZTtcblxuY2xhc3MgVHJpYW5nbGUge1xuXG5cdGNvbnN0cnVjdG9yKCBhID0gbmV3IFZlY3RvcjMoKSwgYiA9IG5ldyBWZWN0b3IzKCksIGMgPSBuZXcgVmVjdG9yMygpICkge1xuXG5cdFx0dGhpcy5hID0gYTtcblx0XHR0aGlzLmIgPSBiO1xuXHRcdHRoaXMuYyA9IGM7XG5cblx0fVxuXG5cdHN0YXRpYyBnZXROb3JtYWwoIGEsIGIsIGMsIHRhcmdldCApIHtcblxuXHRcdHRhcmdldC5zdWJWZWN0b3JzKCBjLCBiICk7XG5cdFx0X3YwLnN1YlZlY3RvcnMoIGEsIGIgKTtcblx0XHR0YXJnZXQuY3Jvc3MoIF92MCApO1xuXG5cdFx0Y29uc3QgdGFyZ2V0TGVuZ3RoU3EgPSB0YXJnZXQubGVuZ3RoU3EoKTtcblx0XHRpZiAoIHRhcmdldExlbmd0aFNxID4gMCApIHtcblxuXHRcdFx0cmV0dXJuIHRhcmdldC5tdWx0aXBseVNjYWxhciggMSAvIE1hdGguc3FydCggdGFyZ2V0TGVuZ3RoU3EgKSApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRhcmdldC5zZXQoIDAsIDAsIDAgKTtcblxuXHR9XG5cblx0Ly8gc3RhdGljL2luc3RhbmNlIG1ldGhvZCB0byBjYWxjdWxhdGUgYmFyeWNlbnRyaWMgY29vcmRpbmF0ZXNcblx0Ly8gYmFzZWQgb246IGh0dHA6Ly93d3cuYmxhY2twYXduLmNvbS90ZXh0cy9wb2ludGlucG9seS9kZWZhdWx0Lmh0bWxcblx0c3RhdGljIGdldEJhcnljb29yZCggcG9pbnQsIGEsIGIsIGMsIHRhcmdldCApIHtcblxuXHRcdF92MC5zdWJWZWN0b3JzKCBjLCBhICk7XG5cdFx0X3YxLnN1YlZlY3RvcnMoIGIsIGEgKTtcblx0XHRfdjIuc3ViVmVjdG9ycyggcG9pbnQsIGEgKTtcblxuXHRcdGNvbnN0IGRvdDAwID0gX3YwLmRvdCggX3YwICk7XG5cdFx0Y29uc3QgZG90MDEgPSBfdjAuZG90KCBfdjEgKTtcblx0XHRjb25zdCBkb3QwMiA9IF92MC5kb3QoIF92MiApO1xuXHRcdGNvbnN0IGRvdDExID0gX3YxLmRvdCggX3YxICk7XG5cdFx0Y29uc3QgZG90MTIgPSBfdjEuZG90KCBfdjIgKTtcblxuXHRcdGNvbnN0IGRlbm9tID0gKCBkb3QwMCAqIGRvdDExIC0gZG90MDEgKiBkb3QwMSApO1xuXG5cdFx0Ly8gY29sbGluZWFyIG9yIHNpbmd1bGFyIHRyaWFuZ2xlXG5cdFx0aWYgKCBkZW5vbSA9PT0gMCApIHtcblxuXHRcdFx0Ly8gYXJiaXRyYXJ5IGxvY2F0aW9uIG91dHNpZGUgb2YgdHJpYW5nbGU/XG5cdFx0XHQvLyBub3Qgc3VyZSBpZiB0aGlzIGlzIHRoZSBiZXN0IGlkZWEsIG1heWJlIHNob3VsZCBiZSByZXR1cm5pbmcgdW5kZWZpbmVkXG5cdFx0XHRyZXR1cm4gdGFyZ2V0LnNldCggLSAyLCAtIDEsIC0gMSApO1xuXG5cdFx0fVxuXG5cdFx0Y29uc3QgaW52RGVub20gPSAxIC8gZGVub207XG5cdFx0Y29uc3QgdSA9ICggZG90MTEgKiBkb3QwMiAtIGRvdDAxICogZG90MTIgKSAqIGludkRlbm9tO1xuXHRcdGNvbnN0IHYgPSAoIGRvdDAwICogZG90MTIgLSBkb3QwMSAqIGRvdDAyICkgKiBpbnZEZW5vbTtcblxuXHRcdC8vIGJhcnljZW50cmljIGNvb3JkaW5hdGVzIG11c3QgYWx3YXlzIHN1bSB0byAxXG5cdFx0cmV0dXJuIHRhcmdldC5zZXQoIDEgLSB1IC0gdiwgdiwgdSApO1xuXG5cdH1cblxuXHRzdGF0aWMgY29udGFpbnNQb2ludCggcG9pbnQsIGEsIGIsIGMgKSB7XG5cblx0XHR0aGlzLmdldEJhcnljb29yZCggcG9pbnQsIGEsIGIsIGMsIF92MyApO1xuXG5cdFx0cmV0dXJuICggX3YzLnggPj0gMCApICYmICggX3YzLnkgPj0gMCApICYmICggKCBfdjMueCArIF92My55ICkgPD0gMSApO1xuXG5cdH1cblxuXHRzdGF0aWMgZ2V0VVYoIHBvaW50LCBwMSwgcDIsIHAzLCB1djEsIHV2MiwgdXYzLCB0YXJnZXQgKSB7IC8vIEBkZXByZWNhdGVkLCByMTUxXG5cblx0XHRpZiAoIHdhcm5lZEdldFVWID09PSBmYWxzZSApIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuVHJpYW5nbGUuZ2V0VVYoKSBoYXMgYmVlbiByZW5hbWVkIHRvIFRIUkVFLlRyaWFuZ2xlLmdldEludGVycG9sYXRpb24oKS4nICk7XG5cblx0XHRcdHdhcm5lZEdldFVWID0gdHJ1ZTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmdldEludGVycG9sYXRpb24oIHBvaW50LCBwMSwgcDIsIHAzLCB1djEsIHV2MiwgdXYzLCB0YXJnZXQgKTtcblxuXHR9XG5cblx0c3RhdGljIGdldEludGVycG9sYXRpb24oIHBvaW50LCBwMSwgcDIsIHAzLCB2MSwgdjIsIHYzLCB0YXJnZXQgKSB7XG5cblx0XHR0aGlzLmdldEJhcnljb29yZCggcG9pbnQsIHAxLCBwMiwgcDMsIF92MyApO1xuXG5cdFx0dGFyZ2V0LnNldFNjYWxhciggMCApO1xuXHRcdHRhcmdldC5hZGRTY2FsZWRWZWN0b3IoIHYxLCBfdjMueCApO1xuXHRcdHRhcmdldC5hZGRTY2FsZWRWZWN0b3IoIHYyLCBfdjMueSApO1xuXHRcdHRhcmdldC5hZGRTY2FsZWRWZWN0b3IoIHYzLCBfdjMueiApO1xuXG5cdFx0cmV0dXJuIHRhcmdldDtcblxuXHR9XG5cblx0c3RhdGljIGlzRnJvbnRGYWNpbmcoIGEsIGIsIGMsIGRpcmVjdGlvbiApIHtcblxuXHRcdF92MC5zdWJWZWN0b3JzKCBjLCBiICk7XG5cdFx0X3YxLnN1YlZlY3RvcnMoIGEsIGIgKTtcblxuXHRcdC8vIHN0cmljdGx5IGZyb250IGZhY2luZ1xuXHRcdHJldHVybiAoIF92MC5jcm9zcyggX3YxICkuZG90KCBkaXJlY3Rpb24gKSA8IDAgKSA/IHRydWUgOiBmYWxzZTtcblxuXHR9XG5cblx0c2V0KCBhLCBiLCBjICkge1xuXG5cdFx0dGhpcy5hLmNvcHkoIGEgKTtcblx0XHR0aGlzLmIuY29weSggYiApO1xuXHRcdHRoaXMuYy5jb3B5KCBjICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c2V0RnJvbVBvaW50c0FuZEluZGljZXMoIHBvaW50cywgaTAsIGkxLCBpMiApIHtcblxuXHRcdHRoaXMuYS5jb3B5KCBwb2ludHNbIGkwIF0gKTtcblx0XHR0aGlzLmIuY29weSggcG9pbnRzWyBpMSBdICk7XG5cdFx0dGhpcy5jLmNvcHkoIHBvaW50c1sgaTIgXSApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHNldEZyb21BdHRyaWJ1dGVBbmRJbmRpY2VzKCBhdHRyaWJ1dGUsIGkwLCBpMSwgaTIgKSB7XG5cblx0XHR0aGlzLmEuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggYXR0cmlidXRlLCBpMCApO1xuXHRcdHRoaXMuYi5mcm9tQnVmZmVyQXR0cmlidXRlKCBhdHRyaWJ1dGUsIGkxICk7XG5cdFx0dGhpcy5jLmZyb21CdWZmZXJBdHRyaWJ1dGUoIGF0dHJpYnV0ZSwgaTIgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRjbG9uZSgpIHtcblxuXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMgKTtcblxuXHR9XG5cblx0Y29weSggdHJpYW5nbGUgKSB7XG5cblx0XHR0aGlzLmEuY29weSggdHJpYW5nbGUuYSApO1xuXHRcdHRoaXMuYi5jb3B5KCB0cmlhbmdsZS5iICk7XG5cdFx0dGhpcy5jLmNvcHkoIHRyaWFuZ2xlLmMgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRnZXRBcmVhKCkge1xuXG5cdFx0X3YwLnN1YlZlY3RvcnMoIHRoaXMuYywgdGhpcy5iICk7XG5cdFx0X3YxLnN1YlZlY3RvcnMoIHRoaXMuYSwgdGhpcy5iICk7XG5cblx0XHRyZXR1cm4gX3YwLmNyb3NzKCBfdjEgKS5sZW5ndGgoKSAqIDAuNTtcblxuXHR9XG5cblx0Z2V0TWlkcG9pbnQoIHRhcmdldCApIHtcblxuXHRcdHJldHVybiB0YXJnZXQuYWRkVmVjdG9ycyggdGhpcy5hLCB0aGlzLmIgKS5hZGQoIHRoaXMuYyApLm11bHRpcGx5U2NhbGFyKCAxIC8gMyApO1xuXG5cdH1cblxuXHRnZXROb3JtYWwoIHRhcmdldCApIHtcblxuXHRcdHJldHVybiBUcmlhbmdsZS5nZXROb3JtYWwoIHRoaXMuYSwgdGhpcy5iLCB0aGlzLmMsIHRhcmdldCApO1xuXG5cdH1cblxuXHRnZXRQbGFuZSggdGFyZ2V0ICkge1xuXG5cdFx0cmV0dXJuIHRhcmdldC5zZXRGcm9tQ29wbGFuYXJQb2ludHMoIHRoaXMuYSwgdGhpcy5iLCB0aGlzLmMgKTtcblxuXHR9XG5cblx0Z2V0QmFyeWNvb3JkKCBwb2ludCwgdGFyZ2V0ICkge1xuXG5cdFx0cmV0dXJuIFRyaWFuZ2xlLmdldEJhcnljb29yZCggcG9pbnQsIHRoaXMuYSwgdGhpcy5iLCB0aGlzLmMsIHRhcmdldCApO1xuXG5cdH1cblxuXHRnZXRVViggcG9pbnQsIHV2MSwgdXYyLCB1djMsIHRhcmdldCApIHsgLy8gQGRlcHJlY2F0ZWQsIHIxNTFcblxuXHRcdGlmICggd2FybmVkR2V0VVYgPT09IGZhbHNlICkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5UcmlhbmdsZS5nZXRVVigpIGhhcyBiZWVuIHJlbmFtZWQgdG8gVEhSRUUuVHJpYW5nbGUuZ2V0SW50ZXJwb2xhdGlvbigpLicgKTtcblxuXHRcdFx0d2FybmVkR2V0VVYgPSB0cnVlO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIFRyaWFuZ2xlLmdldEludGVycG9sYXRpb24oIHBvaW50LCB0aGlzLmEsIHRoaXMuYiwgdGhpcy5jLCB1djEsIHV2MiwgdXYzLCB0YXJnZXQgKTtcblxuXHR9XG5cblx0Z2V0SW50ZXJwb2xhdGlvbiggcG9pbnQsIHYxLCB2MiwgdjMsIHRhcmdldCApIHtcblxuXHRcdHJldHVybiBUcmlhbmdsZS5nZXRJbnRlcnBvbGF0aW9uKCBwb2ludCwgdGhpcy5hLCB0aGlzLmIsIHRoaXMuYywgdjEsIHYyLCB2MywgdGFyZ2V0ICk7XG5cblx0fVxuXG5cdGNvbnRhaW5zUG9pbnQoIHBvaW50ICkge1xuXG5cdFx0cmV0dXJuIFRyaWFuZ2xlLmNvbnRhaW5zUG9pbnQoIHBvaW50LCB0aGlzLmEsIHRoaXMuYiwgdGhpcy5jICk7XG5cblx0fVxuXG5cdGlzRnJvbnRGYWNpbmcoIGRpcmVjdGlvbiApIHtcblxuXHRcdHJldHVybiBUcmlhbmdsZS5pc0Zyb250RmFjaW5nKCB0aGlzLmEsIHRoaXMuYiwgdGhpcy5jLCBkaXJlY3Rpb24gKTtcblxuXHR9XG5cblx0aW50ZXJzZWN0c0JveCggYm94ICkge1xuXG5cdFx0cmV0dXJuIGJveC5pbnRlcnNlY3RzVHJpYW5nbGUoIHRoaXMgKTtcblxuXHR9XG5cblx0Y2xvc2VzdFBvaW50VG9Qb2ludCggcCwgdGFyZ2V0ICkge1xuXG5cdFx0Y29uc3QgYSA9IHRoaXMuYSwgYiA9IHRoaXMuYiwgYyA9IHRoaXMuYztcblx0XHRsZXQgdiwgdztcblxuXHRcdC8vIGFsZ29yaXRobSB0aGFua3MgdG8gUmVhbC1UaW1lIENvbGxpc2lvbiBEZXRlY3Rpb24gYnkgQ2hyaXN0ZXIgRXJpY3Nvbixcblx0XHQvLyBwdWJsaXNoZWQgYnkgTW9yZ2FuIEthdWZtYW5uIFB1Ymxpc2hlcnMsIChjKSAyMDA1IEVsc2V2aWVyIEluYy4sXG5cdFx0Ly8gdW5kZXIgdGhlIGFjY29tcGFueWluZyBsaWNlbnNlOyBzZWUgY2hhcHRlciA1LjEuNSBmb3IgZGV0YWlsZWQgZXhwbGFuYXRpb24uXG5cdFx0Ly8gYmFzaWNhbGx5LCB3ZSdyZSBkaXN0aW5ndWlzaGluZyB3aGljaCBvZiB0aGUgdm9yb25vaSByZWdpb25zIG9mIHRoZSB0cmlhbmdsZVxuXHRcdC8vIHRoZSBwb2ludCBsaWVzIGluIHdpdGggdGhlIG1pbmltdW0gYW1vdW50IG9mIHJlZHVuZGFudCBjb21wdXRhdGlvbi5cblxuXHRcdF92YWIuc3ViVmVjdG9ycyggYiwgYSApO1xuXHRcdF92YWMuc3ViVmVjdG9ycyggYywgYSApO1xuXHRcdF92YXAuc3ViVmVjdG9ycyggcCwgYSApO1xuXHRcdGNvbnN0IGQxID0gX3ZhYi5kb3QoIF92YXAgKTtcblx0XHRjb25zdCBkMiA9IF92YWMuZG90KCBfdmFwICk7XG5cdFx0aWYgKCBkMSA8PSAwICYmIGQyIDw9IDAgKSB7XG5cblx0XHRcdC8vIHZlcnRleCByZWdpb24gb2YgQTsgYmFyeWNlbnRyaWMgY29vcmRzICgxLCAwLCAwKVxuXHRcdFx0cmV0dXJuIHRhcmdldC5jb3B5KCBhICk7XG5cblx0XHR9XG5cblx0XHRfdmJwLnN1YlZlY3RvcnMoIHAsIGIgKTtcblx0XHRjb25zdCBkMyA9IF92YWIuZG90KCBfdmJwICk7XG5cdFx0Y29uc3QgZDQgPSBfdmFjLmRvdCggX3ZicCApO1xuXHRcdGlmICggZDMgPj0gMCAmJiBkNCA8PSBkMyApIHtcblxuXHRcdFx0Ly8gdmVydGV4IHJlZ2lvbiBvZiBCOyBiYXJ5Y2VudHJpYyBjb29yZHMgKDAsIDEsIDApXG5cdFx0XHRyZXR1cm4gdGFyZ2V0LmNvcHkoIGIgKTtcblxuXHRcdH1cblxuXHRcdGNvbnN0IHZjID0gZDEgKiBkNCAtIGQzICogZDI7XG5cdFx0aWYgKCB2YyA8PSAwICYmIGQxID49IDAgJiYgZDMgPD0gMCApIHtcblxuXHRcdFx0diA9IGQxIC8gKCBkMSAtIGQzICk7XG5cdFx0XHQvLyBlZGdlIHJlZ2lvbiBvZiBBQjsgYmFyeWNlbnRyaWMgY29vcmRzICgxLXYsIHYsIDApXG5cdFx0XHRyZXR1cm4gdGFyZ2V0LmNvcHkoIGEgKS5hZGRTY2FsZWRWZWN0b3IoIF92YWIsIHYgKTtcblxuXHRcdH1cblxuXHRcdF92Y3Auc3ViVmVjdG9ycyggcCwgYyApO1xuXHRcdGNvbnN0IGQ1ID0gX3ZhYi5kb3QoIF92Y3AgKTtcblx0XHRjb25zdCBkNiA9IF92YWMuZG90KCBfdmNwICk7XG5cdFx0aWYgKCBkNiA+PSAwICYmIGQ1IDw9IGQ2ICkge1xuXG5cdFx0XHQvLyB2ZXJ0ZXggcmVnaW9uIG9mIEM7IGJhcnljZW50cmljIGNvb3JkcyAoMCwgMCwgMSlcblx0XHRcdHJldHVybiB0YXJnZXQuY29weSggYyApO1xuXG5cdFx0fVxuXG5cdFx0Y29uc3QgdmIgPSBkNSAqIGQyIC0gZDEgKiBkNjtcblx0XHRpZiAoIHZiIDw9IDAgJiYgZDIgPj0gMCAmJiBkNiA8PSAwICkge1xuXG5cdFx0XHR3ID0gZDIgLyAoIGQyIC0gZDYgKTtcblx0XHRcdC8vIGVkZ2UgcmVnaW9uIG9mIEFDOyBiYXJ5Y2VudHJpYyBjb29yZHMgKDEtdywgMCwgdylcblx0XHRcdHJldHVybiB0YXJnZXQuY29weSggYSApLmFkZFNjYWxlZFZlY3RvciggX3ZhYywgdyApO1xuXG5cdFx0fVxuXG5cdFx0Y29uc3QgdmEgPSBkMyAqIGQ2IC0gZDUgKiBkNDtcblx0XHRpZiAoIHZhIDw9IDAgJiYgKCBkNCAtIGQzICkgPj0gMCAmJiAoIGQ1IC0gZDYgKSA+PSAwICkge1xuXG5cdFx0XHRfdmJjLnN1YlZlY3RvcnMoIGMsIGIgKTtcblx0XHRcdHcgPSAoIGQ0IC0gZDMgKSAvICggKCBkNCAtIGQzICkgKyAoIGQ1IC0gZDYgKSApO1xuXHRcdFx0Ly8gZWRnZSByZWdpb24gb2YgQkM7IGJhcnljZW50cmljIGNvb3JkcyAoMCwgMS13LCB3KVxuXHRcdFx0cmV0dXJuIHRhcmdldC5jb3B5KCBiICkuYWRkU2NhbGVkVmVjdG9yKCBfdmJjLCB3ICk7IC8vIGVkZ2UgcmVnaW9uIG9mIEJDXG5cblx0XHR9XG5cblx0XHQvLyBmYWNlIHJlZ2lvblxuXHRcdGNvbnN0IGRlbm9tID0gMSAvICggdmEgKyB2YiArIHZjICk7XG5cdFx0Ly8gdSA9IHZhICogZGVub21cblx0XHR2ID0gdmIgKiBkZW5vbTtcblx0XHR3ID0gdmMgKiBkZW5vbTtcblxuXHRcdHJldHVybiB0YXJnZXQuY29weSggYSApLmFkZFNjYWxlZFZlY3RvciggX3ZhYiwgdiApLmFkZFNjYWxlZFZlY3RvciggX3ZhYywgdyApO1xuXG5cdH1cblxuXHRlcXVhbHMoIHRyaWFuZ2xlICkge1xuXG5cdFx0cmV0dXJuIHRyaWFuZ2xlLmEuZXF1YWxzKCB0aGlzLmEgKSAmJiB0cmlhbmdsZS5iLmVxdWFscyggdGhpcy5iICkgJiYgdHJpYW5nbGUuYy5lcXVhbHMoIHRoaXMuYyApO1xuXG5cdH1cblxufVxuXG5leHBvcnQgeyBUcmlhbmdsZSB9O1xuIiwiaW1wb3J0ICogYXMgTWF0aFV0aWxzIGZyb20gJy4vTWF0aFV0aWxzLmpzJztcblxuY2xhc3MgVmVjdG9yMiB7XG5cblx0Y29uc3RydWN0b3IoIHggPSAwLCB5ID0gMCApIHtcblxuXHRcdFZlY3RvcjIucHJvdG90eXBlLmlzVmVjdG9yMiA9IHRydWU7XG5cblx0XHR0aGlzLnggPSB4O1xuXHRcdHRoaXMueSA9IHk7XG5cblx0fVxuXG5cdGdldCB3aWR0aCgpIHtcblxuXHRcdHJldHVybiB0aGlzLng7XG5cblx0fVxuXG5cdHNldCB3aWR0aCggdmFsdWUgKSB7XG5cblx0XHR0aGlzLnggPSB2YWx1ZTtcblxuXHR9XG5cblx0Z2V0IGhlaWdodCgpIHtcblxuXHRcdHJldHVybiB0aGlzLnk7XG5cblx0fVxuXG5cdHNldCBoZWlnaHQoIHZhbHVlICkge1xuXG5cdFx0dGhpcy55ID0gdmFsdWU7XG5cblx0fVxuXG5cdHNldCggeCwgeSApIHtcblxuXHRcdHRoaXMueCA9IHg7XG5cdFx0dGhpcy55ID0geTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzZXRTY2FsYXIoIHNjYWxhciApIHtcblxuXHRcdHRoaXMueCA9IHNjYWxhcjtcblx0XHR0aGlzLnkgPSBzY2FsYXI7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c2V0WCggeCApIHtcblxuXHRcdHRoaXMueCA9IHg7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c2V0WSggeSApIHtcblxuXHRcdHRoaXMueSA9IHk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c2V0Q29tcG9uZW50KCBpbmRleCwgdmFsdWUgKSB7XG5cblx0XHRzd2l0Y2ggKCBpbmRleCApIHtcblxuXHRcdFx0Y2FzZSAwOiB0aGlzLnggPSB2YWx1ZTsgYnJlYWs7XG5cdFx0XHRjYXNlIDE6IHRoaXMueSA9IHZhbHVlOyBicmVhaztcblx0XHRcdGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvciggJ2luZGV4IGlzIG91dCBvZiByYW5nZTogJyArIGluZGV4ICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Z2V0Q29tcG9uZW50KCBpbmRleCApIHtcblxuXHRcdHN3aXRjaCAoIGluZGV4ICkge1xuXG5cdFx0XHRjYXNlIDA6IHJldHVybiB0aGlzLng7XG5cdFx0XHRjYXNlIDE6IHJldHVybiB0aGlzLnk7XG5cdFx0XHRkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoICdpbmRleCBpcyBvdXQgb2YgcmFuZ2U6ICcgKyBpbmRleCApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRjbG9uZSgpIHtcblxuXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvciggdGhpcy54LCB0aGlzLnkgKTtcblxuXHR9XG5cblx0Y29weSggdiApIHtcblxuXHRcdHRoaXMueCA9IHYueDtcblx0XHR0aGlzLnkgPSB2Lnk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0YWRkKCB2ICkge1xuXG5cdFx0dGhpcy54ICs9IHYueDtcblx0XHR0aGlzLnkgKz0gdi55O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGFkZFNjYWxhciggcyApIHtcblxuXHRcdHRoaXMueCArPSBzO1xuXHRcdHRoaXMueSArPSBzO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGFkZFZlY3RvcnMoIGEsIGIgKSB7XG5cblx0XHR0aGlzLnggPSBhLnggKyBiLng7XG5cdFx0dGhpcy55ID0gYS55ICsgYi55O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGFkZFNjYWxlZFZlY3RvciggdiwgcyApIHtcblxuXHRcdHRoaXMueCArPSB2LnggKiBzO1xuXHRcdHRoaXMueSArPSB2LnkgKiBzO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHN1YiggdiApIHtcblxuXHRcdHRoaXMueCAtPSB2Lng7XG5cdFx0dGhpcy55IC09IHYueTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzdWJTY2FsYXIoIHMgKSB7XG5cblx0XHR0aGlzLnggLT0gcztcblx0XHR0aGlzLnkgLT0gcztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzdWJWZWN0b3JzKCBhLCBiICkge1xuXG5cdFx0dGhpcy54ID0gYS54IC0gYi54O1xuXHRcdHRoaXMueSA9IGEueSAtIGIueTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRtdWx0aXBseSggdiApIHtcblxuXHRcdHRoaXMueCAqPSB2Lng7XG5cdFx0dGhpcy55ICo9IHYueTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRtdWx0aXBseVNjYWxhciggc2NhbGFyICkge1xuXG5cdFx0dGhpcy54ICo9IHNjYWxhcjtcblx0XHR0aGlzLnkgKj0gc2NhbGFyO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGRpdmlkZSggdiApIHtcblxuXHRcdHRoaXMueCAvPSB2Lng7XG5cdFx0dGhpcy55IC89IHYueTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRkaXZpZGVTY2FsYXIoIHNjYWxhciApIHtcblxuXHRcdHJldHVybiB0aGlzLm11bHRpcGx5U2NhbGFyKCAxIC8gc2NhbGFyICk7XG5cblx0fVxuXG5cdGFwcGx5TWF0cml4MyggbSApIHtcblxuXHRcdGNvbnN0IHggPSB0aGlzLngsIHkgPSB0aGlzLnk7XG5cdFx0Y29uc3QgZSA9IG0uZWxlbWVudHM7XG5cblx0XHR0aGlzLnggPSBlWyAwIF0gKiB4ICsgZVsgMyBdICogeSArIGVbIDYgXTtcblx0XHR0aGlzLnkgPSBlWyAxIF0gKiB4ICsgZVsgNCBdICogeSArIGVbIDcgXTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRtaW4oIHYgKSB7XG5cblx0XHR0aGlzLnggPSBNYXRoLm1pbiggdGhpcy54LCB2LnggKTtcblx0XHR0aGlzLnkgPSBNYXRoLm1pbiggdGhpcy55LCB2LnkgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRtYXgoIHYgKSB7XG5cblx0XHR0aGlzLnggPSBNYXRoLm1heCggdGhpcy54LCB2LnggKTtcblx0XHR0aGlzLnkgPSBNYXRoLm1heCggdGhpcy55LCB2LnkgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRjbGFtcCggbWluLCBtYXggKSB7XG5cblx0XHQvLyBhc3N1bWVzIG1pbiA8IG1heCwgY29tcG9uZW50d2lzZVxuXG5cdFx0dGhpcy54ID0gTWF0aC5tYXgoIG1pbi54LCBNYXRoLm1pbiggbWF4LngsIHRoaXMueCApICk7XG5cdFx0dGhpcy55ID0gTWF0aC5tYXgoIG1pbi55LCBNYXRoLm1pbiggbWF4LnksIHRoaXMueSApICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Y2xhbXBTY2FsYXIoIG1pblZhbCwgbWF4VmFsICkge1xuXG5cdFx0dGhpcy54ID0gTWF0aC5tYXgoIG1pblZhbCwgTWF0aC5taW4oIG1heFZhbCwgdGhpcy54ICkgKTtcblx0XHR0aGlzLnkgPSBNYXRoLm1heCggbWluVmFsLCBNYXRoLm1pbiggbWF4VmFsLCB0aGlzLnkgKSApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGNsYW1wTGVuZ3RoKCBtaW4sIG1heCApIHtcblxuXHRcdGNvbnN0IGxlbmd0aCA9IHRoaXMubGVuZ3RoKCk7XG5cblx0XHRyZXR1cm4gdGhpcy5kaXZpZGVTY2FsYXIoIGxlbmd0aCB8fCAxICkubXVsdGlwbHlTY2FsYXIoIE1hdGgubWF4KCBtaW4sIE1hdGgubWluKCBtYXgsIGxlbmd0aCApICkgKTtcblxuXHR9XG5cblx0Zmxvb3IoKSB7XG5cblx0XHR0aGlzLnggPSBNYXRoLmZsb29yKCB0aGlzLnggKTtcblx0XHR0aGlzLnkgPSBNYXRoLmZsb29yKCB0aGlzLnkgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRjZWlsKCkge1xuXG5cdFx0dGhpcy54ID0gTWF0aC5jZWlsKCB0aGlzLnggKTtcblx0XHR0aGlzLnkgPSBNYXRoLmNlaWwoIHRoaXMueSApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHJvdW5kKCkge1xuXG5cdFx0dGhpcy54ID0gTWF0aC5yb3VuZCggdGhpcy54ICk7XG5cdFx0dGhpcy55ID0gTWF0aC5yb3VuZCggdGhpcy55ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0cm91bmRUb1plcm8oKSB7XG5cblx0XHR0aGlzLnggPSBNYXRoLnRydW5jKCB0aGlzLnggKTtcblx0XHR0aGlzLnkgPSBNYXRoLnRydW5jKCB0aGlzLnkgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRuZWdhdGUoKSB7XG5cblx0XHR0aGlzLnggPSAtIHRoaXMueDtcblx0XHR0aGlzLnkgPSAtIHRoaXMueTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRkb3QoIHYgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy54ICogdi54ICsgdGhpcy55ICogdi55O1xuXG5cdH1cblxuXHRjcm9zcyggdiApIHtcblxuXHRcdHJldHVybiB0aGlzLnggKiB2LnkgLSB0aGlzLnkgKiB2Lng7XG5cblx0fVxuXG5cdGxlbmd0aFNxKCkge1xuXG5cdFx0cmV0dXJuIHRoaXMueCAqIHRoaXMueCArIHRoaXMueSAqIHRoaXMueTtcblxuXHR9XG5cblx0bGVuZ3RoKCkge1xuXG5cdFx0cmV0dXJuIE1hdGguc3FydCggdGhpcy54ICogdGhpcy54ICsgdGhpcy55ICogdGhpcy55ICk7XG5cblx0fVxuXG5cdG1hbmhhdHRhbkxlbmd0aCgpIHtcblxuXHRcdHJldHVybiBNYXRoLmFicyggdGhpcy54ICkgKyBNYXRoLmFicyggdGhpcy55ICk7XG5cblx0fVxuXG5cdG5vcm1hbGl6ZSgpIHtcblxuXHRcdHJldHVybiB0aGlzLmRpdmlkZVNjYWxhciggdGhpcy5sZW5ndGgoKSB8fCAxICk7XG5cblx0fVxuXG5cdGFuZ2xlKCkge1xuXG5cdFx0Ly8gY29tcHV0ZXMgdGhlIGFuZ2xlIGluIHJhZGlhbnMgd2l0aCByZXNwZWN0IHRvIHRoZSBwb3NpdGl2ZSB4LWF4aXNcblxuXHRcdGNvbnN0IGFuZ2xlID0gTWF0aC5hdGFuMiggLSB0aGlzLnksIC0gdGhpcy54ICkgKyBNYXRoLlBJO1xuXG5cdFx0cmV0dXJuIGFuZ2xlO1xuXG5cdH1cblxuXHRhbmdsZVRvKCB2ICkge1xuXG5cdFx0Y29uc3QgZGVub21pbmF0b3IgPSBNYXRoLnNxcnQoIHRoaXMubGVuZ3RoU3EoKSAqIHYubGVuZ3RoU3EoKSApO1xuXG5cdFx0aWYgKCBkZW5vbWluYXRvciA9PT0gMCApIHJldHVybiBNYXRoLlBJIC8gMjtcblxuXHRcdGNvbnN0IHRoZXRhID0gdGhpcy5kb3QoIHYgKSAvIGRlbm9taW5hdG9yO1xuXG5cdFx0Ly8gY2xhbXAsIHRvIGhhbmRsZSBudW1lcmljYWwgcHJvYmxlbXNcblxuXHRcdHJldHVybiBNYXRoLmFjb3MoIE1hdGhVdGlscy5jbGFtcCggdGhldGEsIC0gMSwgMSApICk7XG5cblx0fVxuXG5cdGRpc3RhbmNlVG8oIHYgKSB7XG5cblx0XHRyZXR1cm4gTWF0aC5zcXJ0KCB0aGlzLmRpc3RhbmNlVG9TcXVhcmVkKCB2ICkgKTtcblxuXHR9XG5cblx0ZGlzdGFuY2VUb1NxdWFyZWQoIHYgKSB7XG5cblx0XHRjb25zdCBkeCA9IHRoaXMueCAtIHYueCwgZHkgPSB0aGlzLnkgLSB2Lnk7XG5cdFx0cmV0dXJuIGR4ICogZHggKyBkeSAqIGR5O1xuXG5cdH1cblxuXHRtYW5oYXR0YW5EaXN0YW5jZVRvKCB2ICkge1xuXG5cdFx0cmV0dXJuIE1hdGguYWJzKCB0aGlzLnggLSB2LnggKSArIE1hdGguYWJzKCB0aGlzLnkgLSB2LnkgKTtcblxuXHR9XG5cblx0c2V0TGVuZ3RoKCBsZW5ndGggKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5ub3JtYWxpemUoKS5tdWx0aXBseVNjYWxhciggbGVuZ3RoICk7XG5cblx0fVxuXG5cdGxlcnAoIHYsIGFscGhhICkge1xuXG5cdFx0dGhpcy54ICs9ICggdi54IC0gdGhpcy54ICkgKiBhbHBoYTtcblx0XHR0aGlzLnkgKz0gKCB2LnkgLSB0aGlzLnkgKSAqIGFscGhhO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGxlcnBWZWN0b3JzKCB2MSwgdjIsIGFscGhhICkge1xuXG5cdFx0dGhpcy54ID0gdjEueCArICggdjIueCAtIHYxLnggKSAqIGFscGhhO1xuXHRcdHRoaXMueSA9IHYxLnkgKyAoIHYyLnkgLSB2MS55ICkgKiBhbHBoYTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRlcXVhbHMoIHYgKSB7XG5cblx0XHRyZXR1cm4gKCAoIHYueCA9PT0gdGhpcy54ICkgJiYgKCB2LnkgPT09IHRoaXMueSApICk7XG5cblx0fVxuXG5cdGZyb21BcnJheSggYXJyYXksIG9mZnNldCA9IDAgKSB7XG5cblx0XHR0aGlzLnggPSBhcnJheVsgb2Zmc2V0IF07XG5cdFx0dGhpcy55ID0gYXJyYXlbIG9mZnNldCArIDEgXTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHR0b0FycmF5KCBhcnJheSA9IFtdLCBvZmZzZXQgPSAwICkge1xuXG5cdFx0YXJyYXlbIG9mZnNldCBdID0gdGhpcy54O1xuXHRcdGFycmF5WyBvZmZzZXQgKyAxIF0gPSB0aGlzLnk7XG5cblx0XHRyZXR1cm4gYXJyYXk7XG5cblx0fVxuXG5cdGZyb21CdWZmZXJBdHRyaWJ1dGUoIGF0dHJpYnV0ZSwgaW5kZXggKSB7XG5cblx0XHR0aGlzLnggPSBhdHRyaWJ1dGUuZ2V0WCggaW5kZXggKTtcblx0XHR0aGlzLnkgPSBhdHRyaWJ1dGUuZ2V0WSggaW5kZXggKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRyb3RhdGVBcm91bmQoIGNlbnRlciwgYW5nbGUgKSB7XG5cblx0XHRjb25zdCBjID0gTWF0aC5jb3MoIGFuZ2xlICksIHMgPSBNYXRoLnNpbiggYW5nbGUgKTtcblxuXHRcdGNvbnN0IHggPSB0aGlzLnggLSBjZW50ZXIueDtcblx0XHRjb25zdCB5ID0gdGhpcy55IC0gY2VudGVyLnk7XG5cblx0XHR0aGlzLnggPSB4ICogYyAtIHkgKiBzICsgY2VudGVyLng7XG5cdFx0dGhpcy55ID0geCAqIHMgKyB5ICogYyArIGNlbnRlci55O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHJhbmRvbSgpIHtcblxuXHRcdHRoaXMueCA9IE1hdGgucmFuZG9tKCk7XG5cdFx0dGhpcy55ID0gTWF0aC5yYW5kb20oKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHQqWyBTeW1ib2wuaXRlcmF0b3IgXSgpIHtcblxuXHRcdHlpZWxkIHRoaXMueDtcblx0XHR5aWVsZCB0aGlzLnk7XG5cblx0fVxuXG59XG5cbmV4cG9ydCB7IFZlY3RvcjIgfTtcbiIsImltcG9ydCAqIGFzIE1hdGhVdGlscyBmcm9tICcuL01hdGhVdGlscy5qcyc7XG5pbXBvcnQgeyBRdWF0ZXJuaW9uIH0gZnJvbSAnLi9RdWF0ZXJuaW9uLmpzJztcblxuY2xhc3MgVmVjdG9yMyB7XG5cblx0Y29uc3RydWN0b3IoIHggPSAwLCB5ID0gMCwgeiA9IDAgKSB7XG5cblx0XHRWZWN0b3IzLnByb3RvdHlwZS5pc1ZlY3RvcjMgPSB0cnVlO1xuXG5cdFx0dGhpcy54ID0geDtcblx0XHR0aGlzLnkgPSB5O1xuXHRcdHRoaXMueiA9IHo7XG5cblx0fVxuXG5cdHNldCggeCwgeSwgeiApIHtcblxuXHRcdGlmICggeiA9PT0gdW5kZWZpbmVkICkgeiA9IHRoaXMuejsgLy8gc3ByaXRlLnNjYWxlLnNldCh4LHkpXG5cblx0XHR0aGlzLnggPSB4O1xuXHRcdHRoaXMueSA9IHk7XG5cdFx0dGhpcy56ID0gejtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzZXRTY2FsYXIoIHNjYWxhciApIHtcblxuXHRcdHRoaXMueCA9IHNjYWxhcjtcblx0XHR0aGlzLnkgPSBzY2FsYXI7XG5cdFx0dGhpcy56ID0gc2NhbGFyO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHNldFgoIHggKSB7XG5cblx0XHR0aGlzLnggPSB4O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHNldFkoIHkgKSB7XG5cblx0XHR0aGlzLnkgPSB5O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHNldFooIHogKSB7XG5cblx0XHR0aGlzLnogPSB6O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHNldENvbXBvbmVudCggaW5kZXgsIHZhbHVlICkge1xuXG5cdFx0c3dpdGNoICggaW5kZXggKSB7XG5cblx0XHRcdGNhc2UgMDogdGhpcy54ID0gdmFsdWU7IGJyZWFrO1xuXHRcdFx0Y2FzZSAxOiB0aGlzLnkgPSB2YWx1ZTsgYnJlYWs7XG5cdFx0XHRjYXNlIDI6IHRoaXMueiA9IHZhbHVlOyBicmVhaztcblx0XHRcdGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvciggJ2luZGV4IGlzIG91dCBvZiByYW5nZTogJyArIGluZGV4ICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Z2V0Q29tcG9uZW50KCBpbmRleCApIHtcblxuXHRcdHN3aXRjaCAoIGluZGV4ICkge1xuXG5cdFx0XHRjYXNlIDA6IHJldHVybiB0aGlzLng7XG5cdFx0XHRjYXNlIDE6IHJldHVybiB0aGlzLnk7XG5cdFx0XHRjYXNlIDI6IHJldHVybiB0aGlzLno7XG5cdFx0XHRkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoICdpbmRleCBpcyBvdXQgb2YgcmFuZ2U6ICcgKyBpbmRleCApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRjbG9uZSgpIHtcblxuXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvciggdGhpcy54LCB0aGlzLnksIHRoaXMueiApO1xuXG5cdH1cblxuXHRjb3B5KCB2ICkge1xuXG5cdFx0dGhpcy54ID0gdi54O1xuXHRcdHRoaXMueSA9IHYueTtcblx0XHR0aGlzLnogPSB2Lno7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0YWRkKCB2ICkge1xuXG5cdFx0dGhpcy54ICs9IHYueDtcblx0XHR0aGlzLnkgKz0gdi55O1xuXHRcdHRoaXMueiArPSB2Lno7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0YWRkU2NhbGFyKCBzICkge1xuXG5cdFx0dGhpcy54ICs9IHM7XG5cdFx0dGhpcy55ICs9IHM7XG5cdFx0dGhpcy56ICs9IHM7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0YWRkVmVjdG9ycyggYSwgYiApIHtcblxuXHRcdHRoaXMueCA9IGEueCArIGIueDtcblx0XHR0aGlzLnkgPSBhLnkgKyBiLnk7XG5cdFx0dGhpcy56ID0gYS56ICsgYi56O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGFkZFNjYWxlZFZlY3RvciggdiwgcyApIHtcblxuXHRcdHRoaXMueCArPSB2LnggKiBzO1xuXHRcdHRoaXMueSArPSB2LnkgKiBzO1xuXHRcdHRoaXMueiArPSB2LnogKiBzO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHN1YiggdiApIHtcblxuXHRcdHRoaXMueCAtPSB2Lng7XG5cdFx0dGhpcy55IC09IHYueTtcblx0XHR0aGlzLnogLT0gdi56O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHN1YlNjYWxhciggcyApIHtcblxuXHRcdHRoaXMueCAtPSBzO1xuXHRcdHRoaXMueSAtPSBzO1xuXHRcdHRoaXMueiAtPSBzO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHN1YlZlY3RvcnMoIGEsIGIgKSB7XG5cblx0XHR0aGlzLnggPSBhLnggLSBiLng7XG5cdFx0dGhpcy55ID0gYS55IC0gYi55O1xuXHRcdHRoaXMueiA9IGEueiAtIGIuejtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRtdWx0aXBseSggdiApIHtcblxuXHRcdHRoaXMueCAqPSB2Lng7XG5cdFx0dGhpcy55ICo9IHYueTtcblx0XHR0aGlzLnogKj0gdi56O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdG11bHRpcGx5U2NhbGFyKCBzY2FsYXIgKSB7XG5cblx0XHR0aGlzLnggKj0gc2NhbGFyO1xuXHRcdHRoaXMueSAqPSBzY2FsYXI7XG5cdFx0dGhpcy56ICo9IHNjYWxhcjtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRtdWx0aXBseVZlY3RvcnMoIGEsIGIgKSB7XG5cblx0XHR0aGlzLnggPSBhLnggKiBiLng7XG5cdFx0dGhpcy55ID0gYS55ICogYi55O1xuXHRcdHRoaXMueiA9IGEueiAqIGIuejtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRhcHBseUV1bGVyKCBldWxlciApIHtcblxuXHRcdHJldHVybiB0aGlzLmFwcGx5UXVhdGVybmlvbiggX3F1YXRlcm5pb24uc2V0RnJvbUV1bGVyKCBldWxlciApICk7XG5cblx0fVxuXG5cdGFwcGx5QXhpc0FuZ2xlKCBheGlzLCBhbmdsZSApIHtcblxuXHRcdHJldHVybiB0aGlzLmFwcGx5UXVhdGVybmlvbiggX3F1YXRlcm5pb24uc2V0RnJvbUF4aXNBbmdsZSggYXhpcywgYW5nbGUgKSApO1xuXG5cdH1cblxuXHRhcHBseU1hdHJpeDMoIG0gKSB7XG5cblx0XHRjb25zdCB4ID0gdGhpcy54LCB5ID0gdGhpcy55LCB6ID0gdGhpcy56O1xuXHRcdGNvbnN0IGUgPSBtLmVsZW1lbnRzO1xuXG5cdFx0dGhpcy54ID0gZVsgMCBdICogeCArIGVbIDMgXSAqIHkgKyBlWyA2IF0gKiB6O1xuXHRcdHRoaXMueSA9IGVbIDEgXSAqIHggKyBlWyA0IF0gKiB5ICsgZVsgNyBdICogejtcblx0XHR0aGlzLnogPSBlWyAyIF0gKiB4ICsgZVsgNSBdICogeSArIGVbIDggXSAqIHo7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0YXBwbHlOb3JtYWxNYXRyaXgoIG0gKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5hcHBseU1hdHJpeDMoIG0gKS5ub3JtYWxpemUoKTtcblxuXHR9XG5cblx0YXBwbHlNYXRyaXg0KCBtICkge1xuXG5cdFx0Y29uc3QgeCA9IHRoaXMueCwgeSA9IHRoaXMueSwgeiA9IHRoaXMuejtcblx0XHRjb25zdCBlID0gbS5lbGVtZW50cztcblxuXHRcdGNvbnN0IHcgPSAxIC8gKCBlWyAzIF0gKiB4ICsgZVsgNyBdICogeSArIGVbIDExIF0gKiB6ICsgZVsgMTUgXSApO1xuXG5cdFx0dGhpcy54ID0gKCBlWyAwIF0gKiB4ICsgZVsgNCBdICogeSArIGVbIDggXSAqIHogKyBlWyAxMiBdICkgKiB3O1xuXHRcdHRoaXMueSA9ICggZVsgMSBdICogeCArIGVbIDUgXSAqIHkgKyBlWyA5IF0gKiB6ICsgZVsgMTMgXSApICogdztcblx0XHR0aGlzLnogPSAoIGVbIDIgXSAqIHggKyBlWyA2IF0gKiB5ICsgZVsgMTAgXSAqIHogKyBlWyAxNCBdICkgKiB3O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGFwcGx5UXVhdGVybmlvbiggcSApIHtcblxuXHRcdGNvbnN0IHggPSB0aGlzLngsIHkgPSB0aGlzLnksIHogPSB0aGlzLno7XG5cdFx0Y29uc3QgcXggPSBxLngsIHF5ID0gcS55LCBxeiA9IHEueiwgcXcgPSBxLnc7XG5cblx0XHQvLyBjYWxjdWxhdGUgcXVhdCAqIHZlY3RvclxuXG5cdFx0Y29uc3QgaXggPSBxdyAqIHggKyBxeSAqIHogLSBxeiAqIHk7XG5cdFx0Y29uc3QgaXkgPSBxdyAqIHkgKyBxeiAqIHggLSBxeCAqIHo7XG5cdFx0Y29uc3QgaXogPSBxdyAqIHogKyBxeCAqIHkgLSBxeSAqIHg7XG5cdFx0Y29uc3QgaXcgPSAtIHF4ICogeCAtIHF5ICogeSAtIHF6ICogejtcblxuXHRcdC8vIGNhbGN1bGF0ZSByZXN1bHQgKiBpbnZlcnNlIHF1YXRcblxuXHRcdHRoaXMueCA9IGl4ICogcXcgKyBpdyAqIC0gcXggKyBpeSAqIC0gcXogLSBpeiAqIC0gcXk7XG5cdFx0dGhpcy55ID0gaXkgKiBxdyArIGl3ICogLSBxeSArIGl6ICogLSBxeCAtIGl4ICogLSBxejtcblx0XHR0aGlzLnogPSBpeiAqIHF3ICsgaXcgKiAtIHF6ICsgaXggKiAtIHF5IC0gaXkgKiAtIHF4O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHByb2plY3QoIGNhbWVyYSApIHtcblxuXHRcdHJldHVybiB0aGlzLmFwcGx5TWF0cml4NCggY2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZSApLmFwcGx5TWF0cml4NCggY2FtZXJhLnByb2plY3Rpb25NYXRyaXggKTtcblxuXHR9XG5cblx0dW5wcm9qZWN0KCBjYW1lcmEgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5hcHBseU1hdHJpeDQoIGNhbWVyYS5wcm9qZWN0aW9uTWF0cml4SW52ZXJzZSApLmFwcGx5TWF0cml4NCggY2FtZXJhLm1hdHJpeFdvcmxkICk7XG5cblx0fVxuXG5cdHRyYW5zZm9ybURpcmVjdGlvbiggbSApIHtcblxuXHRcdC8vIGlucHV0OiBUSFJFRS5NYXRyaXg0IGFmZmluZSBtYXRyaXhcblx0XHQvLyB2ZWN0b3IgaW50ZXJwcmV0ZWQgYXMgYSBkaXJlY3Rpb25cblxuXHRcdGNvbnN0IHggPSB0aGlzLngsIHkgPSB0aGlzLnksIHogPSB0aGlzLno7XG5cdFx0Y29uc3QgZSA9IG0uZWxlbWVudHM7XG5cblx0XHR0aGlzLnggPSBlWyAwIF0gKiB4ICsgZVsgNCBdICogeSArIGVbIDggXSAqIHo7XG5cdFx0dGhpcy55ID0gZVsgMSBdICogeCArIGVbIDUgXSAqIHkgKyBlWyA5IF0gKiB6O1xuXHRcdHRoaXMueiA9IGVbIDIgXSAqIHggKyBlWyA2IF0gKiB5ICsgZVsgMTAgXSAqIHo7XG5cblx0XHRyZXR1cm4gdGhpcy5ub3JtYWxpemUoKTtcblxuXHR9XG5cblx0ZGl2aWRlKCB2ICkge1xuXG5cdFx0dGhpcy54IC89IHYueDtcblx0XHR0aGlzLnkgLz0gdi55O1xuXHRcdHRoaXMueiAvPSB2Lno7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0ZGl2aWRlU2NhbGFyKCBzY2FsYXIgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5tdWx0aXBseVNjYWxhciggMSAvIHNjYWxhciApO1xuXG5cdH1cblxuXHRtaW4oIHYgKSB7XG5cblx0XHR0aGlzLnggPSBNYXRoLm1pbiggdGhpcy54LCB2LnggKTtcblx0XHR0aGlzLnkgPSBNYXRoLm1pbiggdGhpcy55LCB2LnkgKTtcblx0XHR0aGlzLnogPSBNYXRoLm1pbiggdGhpcy56LCB2LnogKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRtYXgoIHYgKSB7XG5cblx0XHR0aGlzLnggPSBNYXRoLm1heCggdGhpcy54LCB2LnggKTtcblx0XHR0aGlzLnkgPSBNYXRoLm1heCggdGhpcy55LCB2LnkgKTtcblx0XHR0aGlzLnogPSBNYXRoLm1heCggdGhpcy56LCB2LnogKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRjbGFtcCggbWluLCBtYXggKSB7XG5cblx0XHQvLyBhc3N1bWVzIG1pbiA8IG1heCwgY29tcG9uZW50d2lzZVxuXG5cdFx0dGhpcy54ID0gTWF0aC5tYXgoIG1pbi54LCBNYXRoLm1pbiggbWF4LngsIHRoaXMueCApICk7XG5cdFx0dGhpcy55ID0gTWF0aC5tYXgoIG1pbi55LCBNYXRoLm1pbiggbWF4LnksIHRoaXMueSApICk7XG5cdFx0dGhpcy56ID0gTWF0aC5tYXgoIG1pbi56LCBNYXRoLm1pbiggbWF4LnosIHRoaXMueiApICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Y2xhbXBTY2FsYXIoIG1pblZhbCwgbWF4VmFsICkge1xuXG5cdFx0dGhpcy54ID0gTWF0aC5tYXgoIG1pblZhbCwgTWF0aC5taW4oIG1heFZhbCwgdGhpcy54ICkgKTtcblx0XHR0aGlzLnkgPSBNYXRoLm1heCggbWluVmFsLCBNYXRoLm1pbiggbWF4VmFsLCB0aGlzLnkgKSApO1xuXHRcdHRoaXMueiA9IE1hdGgubWF4KCBtaW5WYWwsIE1hdGgubWluKCBtYXhWYWwsIHRoaXMueiApICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Y2xhbXBMZW5ndGgoIG1pbiwgbWF4ICkge1xuXG5cdFx0Y29uc3QgbGVuZ3RoID0gdGhpcy5sZW5ndGgoKTtcblxuXHRcdHJldHVybiB0aGlzLmRpdmlkZVNjYWxhciggbGVuZ3RoIHx8IDEgKS5tdWx0aXBseVNjYWxhciggTWF0aC5tYXgoIG1pbiwgTWF0aC5taW4oIG1heCwgbGVuZ3RoICkgKSApO1xuXG5cdH1cblxuXHRmbG9vcigpIHtcblxuXHRcdHRoaXMueCA9IE1hdGguZmxvb3IoIHRoaXMueCApO1xuXHRcdHRoaXMueSA9IE1hdGguZmxvb3IoIHRoaXMueSApO1xuXHRcdHRoaXMueiA9IE1hdGguZmxvb3IoIHRoaXMueiApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGNlaWwoKSB7XG5cblx0XHR0aGlzLnggPSBNYXRoLmNlaWwoIHRoaXMueCApO1xuXHRcdHRoaXMueSA9IE1hdGguY2VpbCggdGhpcy55ICk7XG5cdFx0dGhpcy56ID0gTWF0aC5jZWlsKCB0aGlzLnogKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRyb3VuZCgpIHtcblxuXHRcdHRoaXMueCA9IE1hdGgucm91bmQoIHRoaXMueCApO1xuXHRcdHRoaXMueSA9IE1hdGgucm91bmQoIHRoaXMueSApO1xuXHRcdHRoaXMueiA9IE1hdGgucm91bmQoIHRoaXMueiApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHJvdW5kVG9aZXJvKCkge1xuXG5cdFx0dGhpcy54ID0gTWF0aC50cnVuYyggdGhpcy54ICk7XG5cdFx0dGhpcy55ID0gTWF0aC50cnVuYyggdGhpcy55ICk7XG5cdFx0dGhpcy56ID0gTWF0aC50cnVuYyggdGhpcy56ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0bmVnYXRlKCkge1xuXG5cdFx0dGhpcy54ID0gLSB0aGlzLng7XG5cdFx0dGhpcy55ID0gLSB0aGlzLnk7XG5cdFx0dGhpcy56ID0gLSB0aGlzLno7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0ZG90KCB2ICkge1xuXG5cdFx0cmV0dXJuIHRoaXMueCAqIHYueCArIHRoaXMueSAqIHYueSArIHRoaXMueiAqIHYuejtcblxuXHR9XG5cblx0Ly8gVE9ETyBsZW5ndGhTcXVhcmVkP1xuXG5cdGxlbmd0aFNxKCkge1xuXG5cdFx0cmV0dXJuIHRoaXMueCAqIHRoaXMueCArIHRoaXMueSAqIHRoaXMueSArIHRoaXMueiAqIHRoaXMuejtcblxuXHR9XG5cblx0bGVuZ3RoKCkge1xuXG5cdFx0cmV0dXJuIE1hdGguc3FydCggdGhpcy54ICogdGhpcy54ICsgdGhpcy55ICogdGhpcy55ICsgdGhpcy56ICogdGhpcy56ICk7XG5cblx0fVxuXG5cdG1hbmhhdHRhbkxlbmd0aCgpIHtcblxuXHRcdHJldHVybiBNYXRoLmFicyggdGhpcy54ICkgKyBNYXRoLmFicyggdGhpcy55ICkgKyBNYXRoLmFicyggdGhpcy56ICk7XG5cblx0fVxuXG5cdG5vcm1hbGl6ZSgpIHtcblxuXHRcdHJldHVybiB0aGlzLmRpdmlkZVNjYWxhciggdGhpcy5sZW5ndGgoKSB8fCAxICk7XG5cblx0fVxuXG5cdHNldExlbmd0aCggbGVuZ3RoICkge1xuXG5cdFx0cmV0dXJuIHRoaXMubm9ybWFsaXplKCkubXVsdGlwbHlTY2FsYXIoIGxlbmd0aCApO1xuXG5cdH1cblxuXHRsZXJwKCB2LCBhbHBoYSApIHtcblxuXHRcdHRoaXMueCArPSAoIHYueCAtIHRoaXMueCApICogYWxwaGE7XG5cdFx0dGhpcy55ICs9ICggdi55IC0gdGhpcy55ICkgKiBhbHBoYTtcblx0XHR0aGlzLnogKz0gKCB2LnogLSB0aGlzLnogKSAqIGFscGhhO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdGxlcnBWZWN0b3JzKCB2MSwgdjIsIGFscGhhICkge1xuXG5cdFx0dGhpcy54ID0gdjEueCArICggdjIueCAtIHYxLnggKSAqIGFscGhhO1xuXHRcdHRoaXMueSA9IHYxLnkgKyAoIHYyLnkgLSB2MS55ICkgKiBhbHBoYTtcblx0XHR0aGlzLnogPSB2MS56ICsgKCB2Mi56IC0gdjEueiApICogYWxwaGE7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0Y3Jvc3MoIHYgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5jcm9zc1ZlY3RvcnMoIHRoaXMsIHYgKTtcblxuXHR9XG5cblx0Y3Jvc3NWZWN0b3JzKCBhLCBiICkge1xuXG5cdFx0Y29uc3QgYXggPSBhLngsIGF5ID0gYS55LCBheiA9IGEuejtcblx0XHRjb25zdCBieCA9IGIueCwgYnkgPSBiLnksIGJ6ID0gYi56O1xuXG5cdFx0dGhpcy54ID0gYXkgKiBieiAtIGF6ICogYnk7XG5cdFx0dGhpcy55ID0gYXogKiBieCAtIGF4ICogYno7XG5cdFx0dGhpcy56ID0gYXggKiBieSAtIGF5ICogYng7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0cHJvamVjdE9uVmVjdG9yKCB2ICkge1xuXG5cdFx0Y29uc3QgZGVub21pbmF0b3IgPSB2Lmxlbmd0aFNxKCk7XG5cblx0XHRpZiAoIGRlbm9taW5hdG9yID09PSAwICkgcmV0dXJuIHRoaXMuc2V0KCAwLCAwLCAwICk7XG5cblx0XHRjb25zdCBzY2FsYXIgPSB2LmRvdCggdGhpcyApIC8gZGVub21pbmF0b3I7XG5cblx0XHRyZXR1cm4gdGhpcy5jb3B5KCB2ICkubXVsdGlwbHlTY2FsYXIoIHNjYWxhciApO1xuXG5cdH1cblxuXHRwcm9qZWN0T25QbGFuZSggcGxhbmVOb3JtYWwgKSB7XG5cblx0XHRfdmVjdG9yLmNvcHkoIHRoaXMgKS5wcm9qZWN0T25WZWN0b3IoIHBsYW5lTm9ybWFsICk7XG5cblx0XHRyZXR1cm4gdGhpcy5zdWIoIF92ZWN0b3IgKTtcblxuXHR9XG5cblx0cmVmbGVjdCggbm9ybWFsICkge1xuXG5cdFx0Ly8gcmVmbGVjdCBpbmNpZGVudCB2ZWN0b3Igb2ZmIHBsYW5lIG9ydGhvZ29uYWwgdG8gbm9ybWFsXG5cdFx0Ly8gbm9ybWFsIGlzIGFzc3VtZWQgdG8gaGF2ZSB1bml0IGxlbmd0aFxuXG5cdFx0cmV0dXJuIHRoaXMuc3ViKCBfdmVjdG9yLmNvcHkoIG5vcm1hbCApLm11bHRpcGx5U2NhbGFyKCAyICogdGhpcy5kb3QoIG5vcm1hbCApICkgKTtcblxuXHR9XG5cblx0YW5nbGVUbyggdiApIHtcblxuXHRcdGNvbnN0IGRlbm9taW5hdG9yID0gTWF0aC5zcXJ0KCB0aGlzLmxlbmd0aFNxKCkgKiB2Lmxlbmd0aFNxKCkgKTtcblxuXHRcdGlmICggZGVub21pbmF0b3IgPT09IDAgKSByZXR1cm4gTWF0aC5QSSAvIDI7XG5cblx0XHRjb25zdCB0aGV0YSA9IHRoaXMuZG90KCB2ICkgLyBkZW5vbWluYXRvcjtcblxuXHRcdC8vIGNsYW1wLCB0byBoYW5kbGUgbnVtZXJpY2FsIHByb2JsZW1zXG5cblx0XHRyZXR1cm4gTWF0aC5hY29zKCBNYXRoVXRpbHMuY2xhbXAoIHRoZXRhLCAtIDEsIDEgKSApO1xuXG5cdH1cblxuXHRkaXN0YW5jZVRvKCB2ICkge1xuXG5cdFx0cmV0dXJuIE1hdGguc3FydCggdGhpcy5kaXN0YW5jZVRvU3F1YXJlZCggdiApICk7XG5cblx0fVxuXG5cdGRpc3RhbmNlVG9TcXVhcmVkKCB2ICkge1xuXG5cdFx0Y29uc3QgZHggPSB0aGlzLnggLSB2LngsIGR5ID0gdGhpcy55IC0gdi55LCBkeiA9IHRoaXMueiAtIHYuejtcblxuXHRcdHJldHVybiBkeCAqIGR4ICsgZHkgKiBkeSArIGR6ICogZHo7XG5cblx0fVxuXG5cdG1hbmhhdHRhbkRpc3RhbmNlVG8oIHYgKSB7XG5cblx0XHRyZXR1cm4gTWF0aC5hYnMoIHRoaXMueCAtIHYueCApICsgTWF0aC5hYnMoIHRoaXMueSAtIHYueSApICsgTWF0aC5hYnMoIHRoaXMueiAtIHYueiApO1xuXG5cdH1cblxuXHRzZXRGcm9tU3BoZXJpY2FsKCBzICkge1xuXG5cdFx0cmV0dXJuIHRoaXMuc2V0RnJvbVNwaGVyaWNhbENvb3Jkcyggcy5yYWRpdXMsIHMucGhpLCBzLnRoZXRhICk7XG5cblx0fVxuXG5cdHNldEZyb21TcGhlcmljYWxDb29yZHMoIHJhZGl1cywgcGhpLCB0aGV0YSApIHtcblxuXHRcdGNvbnN0IHNpblBoaVJhZGl1cyA9IE1hdGguc2luKCBwaGkgKSAqIHJhZGl1cztcblxuXHRcdHRoaXMueCA9IHNpblBoaVJhZGl1cyAqIE1hdGguc2luKCB0aGV0YSApO1xuXHRcdHRoaXMueSA9IE1hdGguY29zKCBwaGkgKSAqIHJhZGl1cztcblx0XHR0aGlzLnogPSBzaW5QaGlSYWRpdXMgKiBNYXRoLmNvcyggdGhldGEgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzZXRGcm9tQ3lsaW5kcmljYWwoIGMgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5zZXRGcm9tQ3lsaW5kcmljYWxDb29yZHMoIGMucmFkaXVzLCBjLnRoZXRhLCBjLnkgKTtcblxuXHR9XG5cblx0c2V0RnJvbUN5bGluZHJpY2FsQ29vcmRzKCByYWRpdXMsIHRoZXRhLCB5ICkge1xuXG5cdFx0dGhpcy54ID0gcmFkaXVzICogTWF0aC5zaW4oIHRoZXRhICk7XG5cdFx0dGhpcy55ID0geTtcblx0XHR0aGlzLnogPSByYWRpdXMgKiBNYXRoLmNvcyggdGhldGEgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzZXRGcm9tTWF0cml4UG9zaXRpb24oIG0gKSB7XG5cblx0XHRjb25zdCBlID0gbS5lbGVtZW50cztcblxuXHRcdHRoaXMueCA9IGVbIDEyIF07XG5cdFx0dGhpcy55ID0gZVsgMTMgXTtcblx0XHR0aGlzLnogPSBlWyAxNCBdO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHNldEZyb21NYXRyaXhTY2FsZSggbSApIHtcblxuXHRcdGNvbnN0IHN4ID0gdGhpcy5zZXRGcm9tTWF0cml4Q29sdW1uKCBtLCAwICkubGVuZ3RoKCk7XG5cdFx0Y29uc3Qgc3kgPSB0aGlzLnNldEZyb21NYXRyaXhDb2x1bW4oIG0sIDEgKS5sZW5ndGgoKTtcblx0XHRjb25zdCBzeiA9IHRoaXMuc2V0RnJvbU1hdHJpeENvbHVtbiggbSwgMiApLmxlbmd0aCgpO1xuXG5cdFx0dGhpcy54ID0gc3g7XG5cdFx0dGhpcy55ID0gc3k7XG5cdFx0dGhpcy56ID0gc3o7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0c2V0RnJvbU1hdHJpeENvbHVtbiggbSwgaW5kZXggKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5mcm9tQXJyYXkoIG0uZWxlbWVudHMsIGluZGV4ICogNCApO1xuXG5cdH1cblxuXHRzZXRGcm9tTWF0cml4M0NvbHVtbiggbSwgaW5kZXggKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5mcm9tQXJyYXkoIG0uZWxlbWVudHMsIGluZGV4ICogMyApO1xuXG5cdH1cblxuXHRzZXRGcm9tRXVsZXIoIGUgKSB7XG5cblx0XHR0aGlzLnggPSBlLl94O1xuXHRcdHRoaXMueSA9IGUuX3k7XG5cdFx0dGhpcy56ID0gZS5fejtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRzZXRGcm9tQ29sb3IoIGMgKSB7XG5cblx0XHR0aGlzLnggPSBjLnI7XG5cdFx0dGhpcy55ID0gYy5nO1xuXHRcdHRoaXMueiA9IGMuYjtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHRlcXVhbHMoIHYgKSB7XG5cblx0XHRyZXR1cm4gKCAoIHYueCA9PT0gdGhpcy54ICkgJiYgKCB2LnkgPT09IHRoaXMueSApICYmICggdi56ID09PSB0aGlzLnogKSApO1xuXG5cdH1cblxuXHRmcm9tQXJyYXkoIGFycmF5LCBvZmZzZXQgPSAwICkge1xuXG5cdFx0dGhpcy54ID0gYXJyYXlbIG9mZnNldCBdO1xuXHRcdHRoaXMueSA9IGFycmF5WyBvZmZzZXQgKyAxIF07XG5cdFx0dGhpcy56ID0gYXJyYXlbIG9mZnNldCArIDIgXTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxuXHR0b0FycmF5KCBhcnJheSA9IFtdLCBvZmZzZXQgPSAwICkge1xuXG5cdFx0YXJyYXlbIG9mZnNldCBdID0gdGhpcy54O1xuXHRcdGFycmF5WyBvZmZzZXQgKyAxIF0gPSB0aGlzLnk7XG5cdFx0YXJyYXlbIG9mZnNldCArIDIgXSA9IHRoaXMuejtcblxuXHRcdHJldHVybiBhcnJheTtcblxuXHR9XG5cblx0ZnJvbUJ1ZmZlckF0dHJpYnV0ZSggYXR0cmlidXRlLCBpbmRleCApIHtcblxuXHRcdHRoaXMueCA9IGF0dHJpYnV0ZS5nZXRYKCBpbmRleCApO1xuXHRcdHRoaXMueSA9IGF0dHJpYnV0ZS5nZXRZKCBpbmRleCApO1xuXHRcdHRoaXMueiA9IGF0dHJpYnV0ZS5nZXRaKCBpbmRleCApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHJhbmRvbSgpIHtcblxuXHRcdHRoaXMueCA9IE1hdGgucmFuZG9tKCk7XG5cdFx0dGhpcy55ID0gTWF0aC5yYW5kb20oKTtcblx0XHR0aGlzLnogPSBNYXRoLnJhbmRvbSgpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG5cdHJhbmRvbURpcmVjdGlvbigpIHtcblxuXHRcdC8vIERlcml2ZWQgZnJvbSBodHRwczovL21hdGh3b3JsZC53b2xmcmFtLmNvbS9TcGhlcmVQb2ludFBpY2tpbmcuaHRtbFxuXG5cdFx0Y29uc3QgdSA9ICggTWF0aC5yYW5kb20oKSAtIDAuNSApICogMjtcblx0XHRjb25zdCB0ID0gTWF0aC5yYW5kb20oKSAqIE1hdGguUEkgKiAyO1xuXHRcdGNvbnN0IGYgPSBNYXRoLnNxcnQoIDEgLSB1ICoqIDIgKTtcblxuXHRcdHRoaXMueCA9IGYgKiBNYXRoLmNvcyggdCApO1xuXHRcdHRoaXMueSA9IGYgKiBNYXRoLnNpbiggdCApO1xuXHRcdHRoaXMueiA9IHU7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cblx0KlsgU3ltYm9sLml0ZXJhdG9yIF0oKSB7XG5cblx0XHR5aWVsZCB0aGlzLng7XG5cdFx0eWllbGQgdGhpcy55O1xuXHRcdHlpZWxkIHRoaXMuejtcblxuXHR9XG5cbn1cblxuY29uc3QgX3ZlY3RvciA9IC8qQF9fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcbmNvbnN0IF9xdWF0ZXJuaW9uID0gLypAX19QVVJFX18qLyBuZXcgUXVhdGVybmlvbigpO1xuXG5leHBvcnQgeyBWZWN0b3IzIH07XG4iLCJmdW5jdGlvbiBhcnJheU1pbiggYXJyYXkgKSB7XG5cblx0aWYgKCBhcnJheS5sZW5ndGggPT09IDAgKSByZXR1cm4gSW5maW5pdHk7XG5cblx0bGV0IG1pbiA9IGFycmF5WyAwIF07XG5cblx0Zm9yICggbGV0IGkgPSAxLCBsID0gYXJyYXkubGVuZ3RoOyBpIDwgbDsgKysgaSApIHtcblxuXHRcdGlmICggYXJyYXlbIGkgXSA8IG1pbiApIG1pbiA9IGFycmF5WyBpIF07XG5cblx0fVxuXG5cdHJldHVybiBtaW47XG5cbn1cblxuZnVuY3Rpb24gYXJyYXlNYXgoIGFycmF5ICkge1xuXG5cdGlmICggYXJyYXkubGVuZ3RoID09PSAwICkgcmV0dXJuIC0gSW5maW5pdHk7XG5cblx0bGV0IG1heCA9IGFycmF5WyAwIF07XG5cblx0Zm9yICggbGV0IGkgPSAxLCBsID0gYXJyYXkubGVuZ3RoOyBpIDwgbDsgKysgaSApIHtcblxuXHRcdGlmICggYXJyYXlbIGkgXSA+IG1heCApIG1heCA9IGFycmF5WyBpIF07XG5cblx0fVxuXG5cdHJldHVybiBtYXg7XG5cbn1cblxuZnVuY3Rpb24gYXJyYXlOZWVkc1VpbnQzMiggYXJyYXkgKSB7XG5cblx0Ly8gYXNzdW1lcyBsYXJnZXIgdmFsdWVzIHVzdWFsbHkgb24gbGFzdFxuXG5cdGZvciAoIGxldCBpID0gYXJyYXkubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLSBpICkge1xuXG5cdFx0aWYgKCBhcnJheVsgaSBdID49IDY1NTM1ICkgcmV0dXJuIHRydWU7IC8vIGFjY291bnQgZm9yIFBSSU1JVElWRV9SRVNUQVJUX0ZJWEVEX0lOREVYLCAjMjQ1NjVcblxuXHR9XG5cblx0cmV0dXJuIGZhbHNlO1xuXG59XG5cbmNvbnN0IFRZUEVEX0FSUkFZUyA9IHtcblx0SW50OEFycmF5OiBJbnQ4QXJyYXksXG5cdFVpbnQ4QXJyYXk6IFVpbnQ4QXJyYXksXG5cdFVpbnQ4Q2xhbXBlZEFycmF5OiBVaW50OENsYW1wZWRBcnJheSxcblx0SW50MTZBcnJheTogSW50MTZBcnJheSxcblx0VWludDE2QXJyYXk6IFVpbnQxNkFycmF5LFxuXHRJbnQzMkFycmF5OiBJbnQzMkFycmF5LFxuXHRVaW50MzJBcnJheTogVWludDMyQXJyYXksXG5cdEZsb2F0MzJBcnJheTogRmxvYXQzMkFycmF5LFxuXHRGbG9hdDY0QXJyYXk6IEZsb2F0NjRBcnJheVxufTtcblxuZnVuY3Rpb24gZ2V0VHlwZWRBcnJheSggdHlwZSwgYnVmZmVyICkge1xuXG5cdHJldHVybiBuZXcgVFlQRURfQVJSQVlTWyB0eXBlIF0oIGJ1ZmZlciApO1xuXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnROUyggbmFtZSApIHtcblxuXHRyZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKCAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCcsIG5hbWUgKTtcblxufVxuXG5mdW5jdGlvbiBjcmVhdGVDYW52YXNFbGVtZW50KCkge1xuXG5cdGNvbnN0IGNhbnZhcyA9IGNyZWF0ZUVsZW1lbnROUyggJ2NhbnZhcycgKTtcblx0Y2FudmFzLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuXHRyZXR1cm4gY2FudmFzO1xuXG59XG5cbmNvbnN0IF9jYWNoZSA9IHt9O1xuXG5mdW5jdGlvbiB3YXJuT25jZSggbWVzc2FnZSApIHtcblxuXHRpZiAoIG1lc3NhZ2UgaW4gX2NhY2hlICkgcmV0dXJuO1xuXG5cdF9jYWNoZVsgbWVzc2FnZSBdID0gdHJ1ZTtcblxuXHRjb25zb2xlLndhcm4oIG1lc3NhZ2UgKTtcblxufVxuXG5leHBvcnQgeyBhcnJheU1pbiwgYXJyYXlNYXgsIGFycmF5TmVlZHNVaW50MzIsIGdldFR5cGVkQXJyYXksIGNyZWF0ZUVsZW1lbnROUywgY3JlYXRlQ2FudmFzRWxlbWVudCwgd2Fybk9uY2UgfTtcbiIsIlwidXNlIHN0cmljdFwiXG5cbm1vZHVsZS5leHBvcnRzID0gdHJpYW5ndWxhdGVDdWJlXG5cbnZhciBwZXJtID0gcmVxdWlyZShcInBlcm11dGF0aW9uLXJhbmtcIilcbnZhciBzZ24gPSByZXF1aXJlKFwicGVybXV0YXRpb24tcGFyaXR5XCIpXG52YXIgZ2FtbWEgPSByZXF1aXJlKFwiZ2FtbWFcIilcblxuZnVuY3Rpb24gdHJpYW5ndWxhdGVDdWJlKGRpbWVuc2lvbikge1xuICBpZihkaW1lbnNpb24gPCAwKSB7XG4gICAgcmV0dXJuIFsgXVxuICB9XG4gIGlmKGRpbWVuc2lvbiA9PT0gMCkge1xuICAgIHJldHVybiBbIFswXSBdXG4gIH1cbiAgdmFyIGRmYWN0b3JpYWwgPSBNYXRoLnJvdW5kKGdhbW1hKGRpbWVuc2lvbisxKSl8MFxuICB2YXIgcmVzdWx0ID0gW11cbiAgZm9yKHZhciBpPTA7IGk8ZGZhY3RvcmlhbDsgKytpKSB7XG4gICAgdmFyIHAgPSBwZXJtLnVucmFuayhkaW1lbnNpb24sIGkpXG4gICAgdmFyIGNlbGwgPSBbIDAgXVxuICAgIHZhciB2ID0gMFxuICAgIGZvcih2YXIgaj0wOyBqPHAubGVuZ3RoOyArK2opIHtcbiAgICAgIHYgKz0gKDE8PHBbal0pXG4gICAgICBjZWxsLnB1c2godilcbiAgICB9XG4gICAgaWYoc2duKHApIDwgMSkge1xuICAgICAgY2VsbFswXSA9IHZcbiAgICAgIGNlbGxbZGltZW5zaW9uXSA9IDBcbiAgICB9XG4gICAgcmVzdWx0LnB1c2goY2VsbClcbiAgfVxuICByZXR1cm4gcmVzdWx0XG59IiwiXCJ1c2Ugc3RyaWN0XCJcblxubW9kdWxlLmV4cG9ydHMgPSB0d29Qcm9kdWN0XG5cbnZhciBTUExJVFRFUiA9ICsoTWF0aC5wb3coMiwgMjcpICsgMS4wKVxuXG5mdW5jdGlvbiB0d29Qcm9kdWN0KGEsIGIsIHJlc3VsdCkge1xuICB2YXIgeCA9IGEgKiBiXG5cbiAgdmFyIGMgPSBTUExJVFRFUiAqIGFcbiAgdmFyIGFiaWcgPSBjIC0gYVxuICB2YXIgYWhpID0gYyAtIGFiaWdcbiAgdmFyIGFsbyA9IGEgLSBhaGlcblxuICB2YXIgZCA9IFNQTElUVEVSICogYlxuICB2YXIgYmJpZyA9IGQgLSBiXG4gIHZhciBiaGkgPSBkIC0gYmJpZ1xuICB2YXIgYmxvID0gYiAtIGJoaVxuXG4gIHZhciBlcnIxID0geCAtIChhaGkgKiBiaGkpXG4gIHZhciBlcnIyID0gZXJyMSAtIChhbG8gKiBiaGkpXG4gIHZhciBlcnIzID0gZXJyMiAtIChhaGkgKiBibG8pXG5cbiAgdmFyIHkgPSBhbG8gKiBibG8gLSBlcnIzXG5cbiAgaWYocmVzdWx0KSB7XG4gICAgcmVzdWx0WzBdID0geVxuICAgIHJlc3VsdFsxXSA9IHhcbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cblxuICByZXR1cm4gWyB5LCB4IF1cbn0iLCJcInVzZSBzdHJpY3RcIlxuXG5tb2R1bGUuZXhwb3J0cyA9IGZhc3RUd29TdW1cblxuZnVuY3Rpb24gZmFzdFR3b1N1bShhLCBiLCByZXN1bHQpIHtcblx0dmFyIHggPSBhICsgYlxuXHR2YXIgYnYgPSB4IC0gYVxuXHR2YXIgYXYgPSB4IC0gYnZcblx0dmFyIGJyID0gYiAtIGJ2XG5cdHZhciBhciA9IGEgLSBhdlxuXHRpZihyZXN1bHQpIHtcblx0XHRyZXN1bHRbMF0gPSBhciArIGJyXG5cdFx0cmVzdWx0WzFdID0geFxuXHRcdHJldHVybiByZXN1bHRcblx0fVxuXHRyZXR1cm4gW2FyK2JyLCB4XVxufSIsIid1c2Ugc3RyaWN0J1xuXG52YXIgYml0cyA9IHJlcXVpcmUoJ2JpdC10d2lkZGxlJylcbnZhciBkdXAgPSByZXF1aXJlKCdkdXAnKVxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlclxuXG4vL0xlZ2FjeSBwb29sIHN1cHBvcnRcbmlmKCFnbG9iYWwuX19UWVBFREFSUkFZX1BPT0wpIHtcbiAgZ2xvYmFsLl9fVFlQRURBUlJBWV9QT09MID0ge1xuICAgICAgVUlOVDggICAgIDogZHVwKFszMiwgMF0pXG4gICAgLCBVSU5UMTYgICAgOiBkdXAoWzMyLCAwXSlcbiAgICAsIFVJTlQzMiAgICA6IGR1cChbMzIsIDBdKVxuICAgICwgQklHVUlOVDY0IDogZHVwKFszMiwgMF0pXG4gICAgLCBJTlQ4ICAgICAgOiBkdXAoWzMyLCAwXSlcbiAgICAsIElOVDE2ICAgICA6IGR1cChbMzIsIDBdKVxuICAgICwgSU5UMzIgICAgIDogZHVwKFszMiwgMF0pXG4gICAgLCBCSUdJTlQ2NCAgOiBkdXAoWzMyLCAwXSlcbiAgICAsIEZMT0FUICAgICA6IGR1cChbMzIsIDBdKVxuICAgICwgRE9VQkxFICAgIDogZHVwKFszMiwgMF0pXG4gICAgLCBEQVRBICAgICAgOiBkdXAoWzMyLCAwXSlcbiAgICAsIFVJTlQ4QyAgICA6IGR1cChbMzIsIDBdKVxuICAgICwgQlVGRkVSICAgIDogZHVwKFszMiwgMF0pXG4gIH1cbn1cblxudmFyIGhhc1VpbnQ4QyA9ICh0eXBlb2YgVWludDhDbGFtcGVkQXJyYXkpICE9PSAndW5kZWZpbmVkJ1xudmFyIGhhc0JpZ1VpbnQ2NCA9ICh0eXBlb2YgQmlnVWludDY0QXJyYXkpICE9PSAndW5kZWZpbmVkJ1xudmFyIGhhc0JpZ0ludDY0ID0gKHR5cGVvZiBCaWdJbnQ2NEFycmF5KSAhPT0gJ3VuZGVmaW5lZCdcbnZhciBQT09MID0gZ2xvYmFsLl9fVFlQRURBUlJBWV9QT09MXG5cbi8vVXBncmFkZSBwb29sXG5pZighUE9PTC5VSU5UOEMpIHtcbiAgUE9PTC5VSU5UOEMgPSBkdXAoWzMyLCAwXSlcbn1cbmlmKCFQT09MLkJJR1VJTlQ2NCkge1xuICBQT09MLkJJR1VJTlQ2NCA9IGR1cChbMzIsIDBdKVxufVxuaWYoIVBPT0wuQklHSU5UNjQpIHtcbiAgUE9PTC5CSUdJTlQ2NCA9IGR1cChbMzIsIDBdKVxufVxuaWYoIVBPT0wuQlVGRkVSKSB7XG4gIFBPT0wuQlVGRkVSID0gZHVwKFszMiwgMF0pXG59XG5cbi8vTmV3IHRlY2huaXF1ZTogT25seSBhbGxvY2F0ZSBmcm9tIEFycmF5QnVmZmVyVmlldyBhbmQgQnVmZmVyXG52YXIgREFUQSAgICA9IFBPT0wuREFUQVxuICAsIEJVRkZFUiAgPSBQT09MLkJVRkZFUlxuXG5leHBvcnRzLmZyZWUgPSBmdW5jdGlvbiBmcmVlKGFycmF5KSB7XG4gIGlmKEJ1ZmZlci5pc0J1ZmZlcihhcnJheSkpIHtcbiAgICBCVUZGRVJbYml0cy5sb2cyKGFycmF5Lmxlbmd0aCldLnB1c2goYXJyYXkpXG4gIH0gZWxzZSB7XG4gICAgaWYoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGFycmF5KSAhPT0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJykge1xuICAgICAgYXJyYXkgPSBhcnJheS5idWZmZXJcbiAgICB9XG4gICAgaWYoIWFycmF5KSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgdmFyIG4gPSBhcnJheS5sZW5ndGggfHwgYXJyYXkuYnl0ZUxlbmd0aFxuICAgIHZhciBsb2dfbiA9IGJpdHMubG9nMihuKXwwXG4gICAgREFUQVtsb2dfbl0ucHVzaChhcnJheSlcbiAgfVxufVxuXG5mdW5jdGlvbiBmcmVlQXJyYXlCdWZmZXIoYnVmZmVyKSB7XG4gIGlmKCFidWZmZXIpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgbiA9IGJ1ZmZlci5sZW5ndGggfHwgYnVmZmVyLmJ5dGVMZW5ndGhcbiAgdmFyIGxvZ19uID0gYml0cy5sb2cyKG4pXG4gIERBVEFbbG9nX25dLnB1c2goYnVmZmVyKVxufVxuXG5mdW5jdGlvbiBmcmVlVHlwZWRBcnJheShhcnJheSkge1xuICBmcmVlQXJyYXlCdWZmZXIoYXJyYXkuYnVmZmVyKVxufVxuXG5leHBvcnRzLmZyZWVVaW50OCA9XG5leHBvcnRzLmZyZWVVaW50MTYgPVxuZXhwb3J0cy5mcmVlVWludDMyID1cbmV4cG9ydHMuZnJlZUJpZ1VpbnQ2NCA9XG5leHBvcnRzLmZyZWVJbnQ4ID1cbmV4cG9ydHMuZnJlZUludDE2ID1cbmV4cG9ydHMuZnJlZUludDMyID1cbmV4cG9ydHMuZnJlZUJpZ0ludDY0ID1cbmV4cG9ydHMuZnJlZUZsb2F0MzIgPSBcbmV4cG9ydHMuZnJlZUZsb2F0ID1cbmV4cG9ydHMuZnJlZUZsb2F0NjQgPSBcbmV4cG9ydHMuZnJlZURvdWJsZSA9IFxuZXhwb3J0cy5mcmVlVWludDhDbGFtcGVkID0gXG5leHBvcnRzLmZyZWVEYXRhVmlldyA9IGZyZWVUeXBlZEFycmF5XG5cbmV4cG9ydHMuZnJlZUFycmF5QnVmZmVyID0gZnJlZUFycmF5QnVmZmVyXG5cbmV4cG9ydHMuZnJlZUJ1ZmZlciA9IGZ1bmN0aW9uIGZyZWVCdWZmZXIoYXJyYXkpIHtcbiAgQlVGRkVSW2JpdHMubG9nMihhcnJheS5sZW5ndGgpXS5wdXNoKGFycmF5KVxufVxuXG5leHBvcnRzLm1hbGxvYyA9IGZ1bmN0aW9uIG1hbGxvYyhuLCBkdHlwZSkge1xuICBpZihkdHlwZSA9PT0gdW5kZWZpbmVkIHx8IGR0eXBlID09PSAnYXJyYXlidWZmZXInKSB7XG4gICAgcmV0dXJuIG1hbGxvY0FycmF5QnVmZmVyKG4pXG4gIH0gZWxzZSB7XG4gICAgc3dpdGNoKGR0eXBlKSB7XG4gICAgICBjYXNlICd1aW50OCc6XG4gICAgICAgIHJldHVybiBtYWxsb2NVaW50OChuKVxuICAgICAgY2FzZSAndWludDE2JzpcbiAgICAgICAgcmV0dXJuIG1hbGxvY1VpbnQxNihuKVxuICAgICAgY2FzZSAndWludDMyJzpcbiAgICAgICAgcmV0dXJuIG1hbGxvY1VpbnQzMihuKVxuICAgICAgY2FzZSAnaW50OCc6XG4gICAgICAgIHJldHVybiBtYWxsb2NJbnQ4KG4pXG4gICAgICBjYXNlICdpbnQxNic6XG4gICAgICAgIHJldHVybiBtYWxsb2NJbnQxNihuKVxuICAgICAgY2FzZSAnaW50MzInOlxuICAgICAgICByZXR1cm4gbWFsbG9jSW50MzIobilcbiAgICAgIGNhc2UgJ2Zsb2F0JzpcbiAgICAgIGNhc2UgJ2Zsb2F0MzInOlxuICAgICAgICByZXR1cm4gbWFsbG9jRmxvYXQobilcbiAgICAgIGNhc2UgJ2RvdWJsZSc6XG4gICAgICBjYXNlICdmbG9hdDY0JzpcbiAgICAgICAgcmV0dXJuIG1hbGxvY0RvdWJsZShuKVxuICAgICAgY2FzZSAndWludDhfY2xhbXBlZCc6XG4gICAgICAgIHJldHVybiBtYWxsb2NVaW50OENsYW1wZWQobilcbiAgICAgIGNhc2UgJ2JpZ2ludDY0JzpcbiAgICAgICAgcmV0dXJuIG1hbGxvY0JpZ0ludDY0KG4pXG4gICAgICBjYXNlICdiaWd1aW50NjQnOlxuICAgICAgICByZXR1cm4gbWFsbG9jQmlnVWludDY0KG4pXG4gICAgICBjYXNlICdidWZmZXInOlxuICAgICAgICByZXR1cm4gbWFsbG9jQnVmZmVyKG4pXG4gICAgICBjYXNlICdkYXRhJzpcbiAgICAgIGNhc2UgJ2RhdGF2aWV3JzpcbiAgICAgICAgcmV0dXJuIG1hbGxvY0RhdGFWaWV3KG4pXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBudWxsXG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsXG59XG5cbmZ1bmN0aW9uIG1hbGxvY0FycmF5QnVmZmVyKG4pIHtcbiAgdmFyIG4gPSBiaXRzLm5leHRQb3cyKG4pXG4gIHZhciBsb2dfbiA9IGJpdHMubG9nMihuKVxuICB2YXIgZCA9IERBVEFbbG9nX25dXG4gIGlmKGQubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiBkLnBvcCgpXG4gIH1cbiAgcmV0dXJuIG5ldyBBcnJheUJ1ZmZlcihuKVxufVxuZXhwb3J0cy5tYWxsb2NBcnJheUJ1ZmZlciA9IG1hbGxvY0FycmF5QnVmZmVyXG5cbmZ1bmN0aW9uIG1hbGxvY1VpbnQ4KG4pIHtcbiAgcmV0dXJuIG5ldyBVaW50OEFycmF5KG1hbGxvY0FycmF5QnVmZmVyKG4pLCAwLCBuKVxufVxuZXhwb3J0cy5tYWxsb2NVaW50OCA9IG1hbGxvY1VpbnQ4XG5cbmZ1bmN0aW9uIG1hbGxvY1VpbnQxNihuKSB7XG4gIHJldHVybiBuZXcgVWludDE2QXJyYXkobWFsbG9jQXJyYXlCdWZmZXIoMipuKSwgMCwgbilcbn1cbmV4cG9ydHMubWFsbG9jVWludDE2ID0gbWFsbG9jVWludDE2XG5cbmZ1bmN0aW9uIG1hbGxvY1VpbnQzMihuKSB7XG4gIHJldHVybiBuZXcgVWludDMyQXJyYXkobWFsbG9jQXJyYXlCdWZmZXIoNCpuKSwgMCwgbilcbn1cbmV4cG9ydHMubWFsbG9jVWludDMyID0gbWFsbG9jVWludDMyXG5cbmZ1bmN0aW9uIG1hbGxvY0ludDgobikge1xuICByZXR1cm4gbmV3IEludDhBcnJheShtYWxsb2NBcnJheUJ1ZmZlcihuKSwgMCwgbilcbn1cbmV4cG9ydHMubWFsbG9jSW50OCA9IG1hbGxvY0ludDhcblxuZnVuY3Rpb24gbWFsbG9jSW50MTYobikge1xuICByZXR1cm4gbmV3IEludDE2QXJyYXkobWFsbG9jQXJyYXlCdWZmZXIoMipuKSwgMCwgbilcbn1cbmV4cG9ydHMubWFsbG9jSW50MTYgPSBtYWxsb2NJbnQxNlxuXG5mdW5jdGlvbiBtYWxsb2NJbnQzMihuKSB7XG4gIHJldHVybiBuZXcgSW50MzJBcnJheShtYWxsb2NBcnJheUJ1ZmZlcig0Km4pLCAwLCBuKVxufVxuZXhwb3J0cy5tYWxsb2NJbnQzMiA9IG1hbGxvY0ludDMyXG5cbmZ1bmN0aW9uIG1hbGxvY0Zsb2F0KG4pIHtcbiAgcmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkobWFsbG9jQXJyYXlCdWZmZXIoNCpuKSwgMCwgbilcbn1cbmV4cG9ydHMubWFsbG9jRmxvYXQzMiA9IGV4cG9ydHMubWFsbG9jRmxvYXQgPSBtYWxsb2NGbG9hdFxuXG5mdW5jdGlvbiBtYWxsb2NEb3VibGUobikge1xuICByZXR1cm4gbmV3IEZsb2F0NjRBcnJheShtYWxsb2NBcnJheUJ1ZmZlcig4Km4pLCAwLCBuKVxufVxuZXhwb3J0cy5tYWxsb2NGbG9hdDY0ID0gZXhwb3J0cy5tYWxsb2NEb3VibGUgPSBtYWxsb2NEb3VibGVcblxuZnVuY3Rpb24gbWFsbG9jVWludDhDbGFtcGVkKG4pIHtcbiAgaWYoaGFzVWludDhDKSB7XG4gICAgcmV0dXJuIG5ldyBVaW50OENsYW1wZWRBcnJheShtYWxsb2NBcnJheUJ1ZmZlcihuKSwgMCwgbilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbWFsbG9jVWludDgobilcbiAgfVxufVxuZXhwb3J0cy5tYWxsb2NVaW50OENsYW1wZWQgPSBtYWxsb2NVaW50OENsYW1wZWRcblxuZnVuY3Rpb24gbWFsbG9jQmlnVWludDY0KG4pIHtcbiAgaWYoaGFzQmlnVWludDY0KSB7XG4gICAgcmV0dXJuIG5ldyBCaWdVaW50NjRBcnJheShtYWxsb2NBcnJheUJ1ZmZlcig4Km4pLCAwLCBuKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5leHBvcnRzLm1hbGxvY0JpZ1VpbnQ2NCA9IG1hbGxvY0JpZ1VpbnQ2NFxuXG5mdW5jdGlvbiBtYWxsb2NCaWdJbnQ2NChuKSB7XG4gIGlmIChoYXNCaWdJbnQ2NCkge1xuICAgIHJldHVybiBuZXcgQmlnSW50NjRBcnJheShtYWxsb2NBcnJheUJ1ZmZlcig4Km4pLCAwLCBuKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5leHBvcnRzLm1hbGxvY0JpZ0ludDY0ID0gbWFsbG9jQmlnSW50NjRcblxuZnVuY3Rpb24gbWFsbG9jRGF0YVZpZXcobikge1xuICByZXR1cm4gbmV3IERhdGFWaWV3KG1hbGxvY0FycmF5QnVmZmVyKG4pLCAwLCBuKVxufVxuZXhwb3J0cy5tYWxsb2NEYXRhVmlldyA9IG1hbGxvY0RhdGFWaWV3XG5cbmZ1bmN0aW9uIG1hbGxvY0J1ZmZlcihuKSB7XG4gIG4gPSBiaXRzLm5leHRQb3cyKG4pXG4gIHZhciBsb2dfbiA9IGJpdHMubG9nMihuKVxuICB2YXIgY2FjaGUgPSBCVUZGRVJbbG9nX25dXG4gIGlmKGNhY2hlLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4gY2FjaGUucG9wKClcbiAgfVxuICByZXR1cm4gbmV3IEJ1ZmZlcihuKVxufVxuZXhwb3J0cy5tYWxsb2NCdWZmZXIgPSBtYWxsb2NCdWZmZXJcblxuZXhwb3J0cy5jbGVhckNhY2hlID0gZnVuY3Rpb24gY2xlYXJDYWNoZSgpIHtcbiAgZm9yKHZhciBpPTA7IGk8MzI7ICsraSkge1xuICAgIFBPT0wuVUlOVDhbaV0ubGVuZ3RoID0gMFxuICAgIFBPT0wuVUlOVDE2W2ldLmxlbmd0aCA9IDBcbiAgICBQT09MLlVJTlQzMltpXS5sZW5ndGggPSAwXG4gICAgUE9PTC5JTlQ4W2ldLmxlbmd0aCA9IDBcbiAgICBQT09MLklOVDE2W2ldLmxlbmd0aCA9IDBcbiAgICBQT09MLklOVDMyW2ldLmxlbmd0aCA9IDBcbiAgICBQT09MLkZMT0FUW2ldLmxlbmd0aCA9IDBcbiAgICBQT09MLkRPVUJMRVtpXS5sZW5ndGggPSAwXG4gICAgUE9PTC5CSUdVSU5UNjRbaV0ubGVuZ3RoID0gMFxuICAgIFBPT0wuQklHSU5UNjRbaV0ubGVuZ3RoID0gMFxuICAgIFBPT0wuVUlOVDhDW2ldLmxlbmd0aCA9IDBcbiAgICBEQVRBW2ldLmxlbmd0aCA9IDBcbiAgICBCVUZGRVJbaV0ubGVuZ3RoID0gMFxuICB9XG59XG4iLCJcInVzZSBzdHJpY3RcIjsgXCJ1c2UgcmVzdHJpY3RcIjtcblxubW9kdWxlLmV4cG9ydHMgPSBVbmlvbkZpbmQ7XG5cbmZ1bmN0aW9uIFVuaW9uRmluZChjb3VudCkge1xuICB0aGlzLnJvb3RzID0gbmV3IEFycmF5KGNvdW50KTtcbiAgdGhpcy5yYW5rcyA9IG5ldyBBcnJheShjb3VudCk7XG4gIFxuICBmb3IodmFyIGk9MDsgaTxjb3VudDsgKytpKSB7XG4gICAgdGhpcy5yb290c1tpXSA9IGk7XG4gICAgdGhpcy5yYW5rc1tpXSA9IDA7XG4gIH1cbn1cblxudmFyIHByb3RvID0gVW5pb25GaW5kLnByb3RvdHlwZVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkocHJvdG8sIFwibGVuZ3RoXCIsIHtcbiAgXCJnZXRcIjogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucm9vdHMubGVuZ3RoXG4gIH1cbn0pXG5cbnByb3RvLm1ha2VTZXQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIG4gPSB0aGlzLnJvb3RzLmxlbmd0aDtcbiAgdGhpcy5yb290cy5wdXNoKG4pO1xuICB0aGlzLnJhbmtzLnB1c2goMCk7XG4gIHJldHVybiBuO1xufVxuXG5wcm90by5maW5kID0gZnVuY3Rpb24oeCkge1xuICB2YXIgeDAgPSB4XG4gIHZhciByb290cyA9IHRoaXMucm9vdHM7XG4gIHdoaWxlKHJvb3RzW3hdICE9PSB4KSB7XG4gICAgeCA9IHJvb3RzW3hdXG4gIH1cbiAgd2hpbGUocm9vdHNbeDBdICE9PSB4KSB7XG4gICAgdmFyIHkgPSByb290c1t4MF1cbiAgICByb290c1t4MF0gPSB4XG4gICAgeDAgPSB5XG4gIH1cbiAgcmV0dXJuIHg7XG59XG5cbnByb3RvLmxpbmsgPSBmdW5jdGlvbih4LCB5KSB7XG4gIHZhciB4ciA9IHRoaXMuZmluZCh4KVxuICAgICwgeXIgPSB0aGlzLmZpbmQoeSk7XG4gIGlmKHhyID09PSB5cikge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgcmFua3MgPSB0aGlzLnJhbmtzXG4gICAgLCByb290cyA9IHRoaXMucm9vdHNcbiAgICAsIHhkICAgID0gcmFua3NbeHJdXG4gICAgLCB5ZCAgICA9IHJhbmtzW3lyXTtcbiAgaWYoeGQgPCB5ZCkge1xuICAgIHJvb3RzW3hyXSA9IHlyO1xuICB9IGVsc2UgaWYoeWQgPCB4ZCkge1xuICAgIHJvb3RzW3lyXSA9IHhyO1xuICB9IGVsc2Uge1xuICAgIHJvb3RzW3lyXSA9IHhyO1xuICAgICsrcmFua3NbeHJdO1xuICB9XG59IiwiXCJ1c2Ugc3RyaWN0XCJcblxuZnVuY3Rpb24gdW5pcXVlX3ByZWQobGlzdCwgY29tcGFyZSkge1xuICB2YXIgcHRyID0gMVxuICAgICwgbGVuID0gbGlzdC5sZW5ndGhcbiAgICAsIGE9bGlzdFswXSwgYj1saXN0WzBdXG4gIGZvcih2YXIgaT0xOyBpPGxlbjsgKytpKSB7XG4gICAgYiA9IGFcbiAgICBhID0gbGlzdFtpXVxuICAgIGlmKGNvbXBhcmUoYSwgYikpIHtcbiAgICAgIGlmKGkgPT09IHB0cikge1xuICAgICAgICBwdHIrK1xuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuICAgICAgbGlzdFtwdHIrK10gPSBhXG4gICAgfVxuICB9XG4gIGxpc3QubGVuZ3RoID0gcHRyXG4gIHJldHVybiBsaXN0XG59XG5cbmZ1bmN0aW9uIHVuaXF1ZV9lcShsaXN0KSB7XG4gIHZhciBwdHIgPSAxXG4gICAgLCBsZW4gPSBsaXN0Lmxlbmd0aFxuICAgICwgYT1saXN0WzBdLCBiID0gbGlzdFswXVxuICBmb3IodmFyIGk9MTsgaTxsZW47ICsraSwgYj1hKSB7XG4gICAgYiA9IGFcbiAgICBhID0gbGlzdFtpXVxuICAgIGlmKGEgIT09IGIpIHtcbiAgICAgIGlmKGkgPT09IHB0cikge1xuICAgICAgICBwdHIrK1xuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuICAgICAgbGlzdFtwdHIrK10gPSBhXG4gICAgfVxuICB9XG4gIGxpc3QubGVuZ3RoID0gcHRyXG4gIHJldHVybiBsaXN0XG59XG5cbmZ1bmN0aW9uIHVuaXF1ZShsaXN0LCBjb21wYXJlLCBzb3J0ZWQpIHtcbiAgaWYobGlzdC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gbGlzdFxuICB9XG4gIGlmKGNvbXBhcmUpIHtcbiAgICBpZighc29ydGVkKSB7XG4gICAgICBsaXN0LnNvcnQoY29tcGFyZSlcbiAgICB9XG4gICAgcmV0dXJuIHVuaXF1ZV9wcmVkKGxpc3QsIGNvbXBhcmUpXG4gIH1cbiAgaWYoIXNvcnRlZCkge1xuICAgIGxpc3Quc29ydCgpXG4gIH1cbiAgcmV0dXJuIHVuaXF1ZV9lcShsaXN0KVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHVuaXF1ZVxuIiwiXCJ1c2Ugc3RyaWN0XCJcblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVUZXh0XG5cbnZhciB2ZWN0b3JpemVUZXh0ID0gcmVxdWlyZShcIi4vbGliL3Z0ZXh0XCIpXG52YXIgZGVmYXVsdENhbnZhcyA9IG51bGxcbnZhciBkZWZhdWx0Q29udGV4dCA9IG51bGxcblxuaWYodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJykge1xuICBkZWZhdWx0Q2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJylcbiAgZGVmYXVsdENhbnZhcy53aWR0aCA9IDgxOTJcbiAgZGVmYXVsdENhbnZhcy5oZWlnaHQgPSAxMDI0XG4gIGRlZmF1bHRDb250ZXh0ID0gZGVmYXVsdENhbnZhcy5nZXRDb250ZXh0KFwiMmRcIilcbn1cblxuZnVuY3Rpb24gY3JlYXRlVGV4dChzdHIsIG9wdGlvbnMpIHtcbiAgaWYoKHR5cGVvZiBvcHRpb25zICE9PSBcIm9iamVjdFwiKSB8fCAob3B0aW9ucyA9PT0gbnVsbCkpIHtcbiAgICBvcHRpb25zID0ge31cbiAgfVxuICByZXR1cm4gdmVjdG9yaXplVGV4dChcbiAgICBzdHIsXG4gICAgb3B0aW9ucy5jYW52YXMgfHwgZGVmYXVsdENhbnZhcyxcbiAgICBvcHRpb25zLmNvbnRleHQgfHwgZGVmYXVsdENvbnRleHQsXG4gICAgb3B0aW9ucylcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gdmVjdG9yaXplVGV4dFxubW9kdWxlLmV4cG9ydHMucHJvY2Vzc1BpeGVscyA9IHByb2Nlc3NQaXhlbHNcblxudmFyIHN1cmZhY2VOZXRzID0gcmVxdWlyZSgnc3VyZmFjZS1uZXRzJylcbnZhciBuZGFycmF5ID0gcmVxdWlyZSgnbmRhcnJheScpXG52YXIgc2ltcGxpZnkgPSByZXF1aXJlKCdzaW1wbGlmeS1wbGFuYXItZ3JhcGgnKVxudmFyIGNsZWFuUFNMRyA9IHJlcXVpcmUoJ2NsZWFuLXBzbGcnKVxudmFyIGNkdDJkID0gcmVxdWlyZSgnY2R0MmQnKVxudmFyIHRvUG9seWdvbkNyYXBweSA9IHJlcXVpcmUoJ3BsYW5hci1ncmFwaC10by1wb2x5bGluZScpXG5cbnZhciBUQUdfYm9sZCA9IFwiYlwiXG52YXIgQ0hSX2JvbGQgPSAnYnwnXG5cbnZhciBUQUdfaXRhbGljID0gXCJpXCJcbnZhciBDSFJfaXRhbGljID0gJ2l8J1xuXG52YXIgVEFHX3N1cGVyID0gXCJzdXBcIlxudmFyIENIUl9zdXBlcjAgPSAnKydcbnZhciBDSFJfc3VwZXIgPSAnKzEnXG5cbnZhciBUQUdfc3ViID0gXCJzdWJcIlxudmFyIENIUl9zdWIwID0gJy0nXG52YXIgQ0hSX3N1YiA9ICctMSdcblxuZnVuY3Rpb24gcGFyc2VUYWcodGFnLCBUQUdfQ0hSLCBzdHIsIG1hcCkge1xuXG4gIHZhciBvcG5UYWcgPSAgXCI8XCIgICsgdGFnICsgXCI+XCJcbiAgdmFyIGNsc1RhZyA9ICBcIjwvXCIgKyB0YWcgKyBcIj5cIlxuXG4gIHZhciBuT1BOID0gb3BuVGFnLmxlbmd0aFxuICB2YXIgbkNMUyA9IGNsc1RhZy5sZW5ndGhcblxuICB2YXIgaXNSZWN1cnNpdmUgPSAoVEFHX0NIUlswXSA9PT0gQ0hSX3N1cGVyMCkgfHxcbiAgICAgICAgICAgICAgICAgICAgKFRBR19DSFJbMF0gPT09IENIUl9zdWIwKTtcblxuICB2YXIgYSA9IDBcbiAgdmFyIGIgPSAtbkNMU1xuICB3aGlsZSAoYSA+IC0xKSB7XG4gICAgYSA9IHN0ci5pbmRleE9mKG9wblRhZywgYSlcbiAgICBpZihhID09PSAtMSkgYnJlYWtcblxuICAgIGIgPSBzdHIuaW5kZXhPZihjbHNUYWcsIGEgKyBuT1BOKVxuICAgIGlmKGIgPT09IC0xKSBicmVha1xuXG4gICAgaWYoYiA8PSBhKSBicmVha1xuXG4gICAgZm9yKHZhciBpID0gYTsgaSA8IGIgKyBuQ0xTOyArK2kpe1xuICAgICAgaWYoKGkgPCBhICsgbk9QTikgfHwgKGkgPj0gYikpIHtcbiAgICAgICAgbWFwW2ldID0gbnVsbFxuICAgICAgICBzdHIgPSBzdHIuc3Vic3RyKDAsIGkpICsgXCIgXCIgKyBzdHIuc3Vic3RyKGkgKyAxKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYobWFwW2ldICE9PSBudWxsKSB7XG4gICAgICAgICAgdmFyIHBvcyA9IG1hcFtpXS5pbmRleE9mKFRBR19DSFJbMF0pXG4gICAgICAgICAgaWYocG9zID09PSAtMSkge1xuICAgICAgICAgICAgbWFwW2ldICs9IFRBR19DSFJcbiAgICAgICAgICB9IGVsc2UgeyAvLyBpLmUuIHRvIGhhbmRsZSBtdWx0aXBsZSBzdWIvc3VwZXItc2NyaXB0c1xuICAgICAgICAgICAgaWYoaXNSZWN1cnNpdmUpIHtcbiAgICAgICAgICAgICAgLy8gaS5lIHRvIGluY3JlYXNlIHRoZSBzdWIvc3VwIG51bWJlclxuICAgICAgICAgICAgICBtYXBbaV0gPSBtYXBbaV0uc3Vic3RyKDAsIHBvcyArIDEpICsgKDEgKyBwYXJzZUludChtYXBbaV1bcG9zICsgMV0pKSArIG1hcFtpXS5zdWJzdHIocG9zICsgMilcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgc3RhcnQgPSBhICsgbk9QTlxuICAgIHZhciByZW1haW5pbmdTdHIgPSBzdHIuc3Vic3RyKHN0YXJ0LCBiIC0gc3RhcnQpXG5cbiAgICB2YXIgYyA9IHJlbWFpbmluZ1N0ci5pbmRleE9mKG9wblRhZylcbiAgICBpZihjICE9PSAtMSkgYSA9IGNcbiAgICBlbHNlIGEgPSBiICsgbkNMU1xuICB9XG5cbiAgcmV0dXJuIG1hcFxufVxuXG5mdW5jdGlvbiB0cmFuc2Zvcm1Qb3NpdGlvbnMocG9zaXRpb25zLCBvcHRpb25zLCBzaXplKSB7XG4gIHZhciBhbGlnbiA9IG9wdGlvbnMudGV4dEFsaWduIHx8IFwic3RhcnRcIlxuICB2YXIgYmFzZWxpbmUgPSBvcHRpb25zLnRleHRCYXNlbGluZSB8fCBcImFscGhhYmV0aWNcIlxuXG4gIHZhciBsbyA9IFsxPDwzMCwgMTw8MzBdXG4gIHZhciBoaSA9IFswLDBdXG4gIHZhciBuID0gcG9zaXRpb25zLmxlbmd0aFxuICBmb3IodmFyIGk9MDsgaTxuOyArK2kpIHtcbiAgICB2YXIgcCA9IHBvc2l0aW9uc1tpXVxuICAgIGZvcih2YXIgaj0wOyBqPDI7ICsraikge1xuICAgICAgbG9bal0gPSBNYXRoLm1pbihsb1tqXSwgcFtqXSl8MFxuICAgICAgaGlbal0gPSBNYXRoLm1heChoaVtqXSwgcFtqXSl8MFxuICAgIH1cbiAgfVxuXG4gIHZhciB4U2hpZnQgPSAwXG4gIHN3aXRjaChhbGlnbikge1xuICAgIGNhc2UgXCJjZW50ZXJcIjpcbiAgICAgIHhTaGlmdCA9IC0wLjUgKiAobG9bMF0gKyBoaVswXSlcbiAgICBicmVha1xuXG4gICAgY2FzZSBcInJpZ2h0XCI6XG4gICAgY2FzZSBcImVuZFwiOlxuICAgICAgeFNoaWZ0ID0gLWhpWzBdXG4gICAgYnJlYWtcblxuICAgIGNhc2UgXCJsZWZ0XCI6XG4gICAgY2FzZSBcInN0YXJ0XCI6XG4gICAgICB4U2hpZnQgPSAtbG9bMF1cbiAgICBicmVha1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihcInZlY3Rvcml6ZS10ZXh0OiBVbnJlY29nbml6ZWQgdGV4dEFsaWduOiAnXCIgKyBhbGlnbiArIFwiJ1wiKVxuICB9XG5cbiAgdmFyIHlTaGlmdCA9IDBcbiAgc3dpdGNoKGJhc2VsaW5lKSB7XG4gICAgY2FzZSBcImhhbmdpbmdcIjpcbiAgICBjYXNlIFwidG9wXCI6XG4gICAgICB5U2hpZnQgPSAtbG9bMV1cbiAgICBicmVha1xuXG4gICAgY2FzZSBcIm1pZGRsZVwiOlxuICAgICAgeVNoaWZ0ID0gLTAuNSAqIChsb1sxXSArIGhpWzFdKVxuICAgIGJyZWFrXG5cbiAgICBjYXNlIFwiYWxwaGFiZXRpY1wiOlxuICAgIGNhc2UgXCJpZGVvZ3JhcGhpY1wiOlxuICAgICAgeVNoaWZ0ID0gLTMgKiBzaXplXG4gICAgYnJlYWtcblxuICAgIGNhc2UgXCJib3R0b21cIjpcbiAgICAgIHlTaGlmdCA9IC1oaVsxXVxuICAgIGJyZWFrXG5cbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwidmVjdG9yaXplLXRleHQ6IFVucmVjb2dpbml6ZWQgdGV4dEJhc2VsaW5lOiAnXCIgKyBiYXNlbGluZSArIFwiJ1wiKVxuICB9XG5cbiAgdmFyIHNjYWxlID0gMS4wIC8gc2l6ZVxuICBpZihcImxpbmVIZWlnaHRcIiBpbiBvcHRpb25zKSB7XG4gICAgc2NhbGUgKj0gK29wdGlvbnMubGluZUhlaWdodFxuICB9IGVsc2UgaWYoXCJ3aWR0aFwiIGluIG9wdGlvbnMpIHtcbiAgICBzY2FsZSA9IG9wdGlvbnMud2lkdGggLyAoaGlbMF0gLSBsb1swXSlcbiAgfSBlbHNlIGlmKFwiaGVpZ2h0XCIgaW4gb3B0aW9ucykge1xuICAgIHNjYWxlID0gb3B0aW9ucy5oZWlnaHQgLyAoaGlbMV0gLSBsb1sxXSlcbiAgfVxuXG4gIHJldHVybiBwb3NpdGlvbnMubWFwKGZ1bmN0aW9uKHApIHtcbiAgICByZXR1cm4gWyBzY2FsZSAqIChwWzBdICsgeFNoaWZ0KSwgc2NhbGUgKiAocFsxXSArIHlTaGlmdCkgXVxuICB9KVxufVxuXG5mdW5jdGlvbiBnZXRQaXhlbHMoY2FudmFzLCBjb250ZXh0LCByYXdTdHJpbmcsIGZvbnRTaXplLCBsaW5lU3BhY2luZywgc3R5bGV0YWdzKSB7XG5cbiAgcmF3U3RyaW5nID0gcmF3U3RyaW5nLnJlcGxhY2UoL1xcbi9nLCAnJykgLy8gZG9uJ3QgYWNjZXB0IFxcbiBpbiB0aGUgaW5wdXRcblxuICBpZihzdHlsZXRhZ3MuYnJlYWtsaW5lcyA9PT0gdHJ1ZSkge1xuICAgIHJhd1N0cmluZyA9IHJhd1N0cmluZy5yZXBsYWNlKC9cXDxiclxcPi9nLCAnXFxuJykgLy8gcmVwbGFjZSA8YnI+IHRhZ3Mgd2l0aCBcXG4gaW4gdGhlIHN0cmluZ1xuICB9IGVsc2Uge1xuICAgIHJhd1N0cmluZyA9IHJhd1N0cmluZy5yZXBsYWNlKC9cXDxiclxcPi9nLCAnICcpIC8vIGRvbid0IGFjY2VwdCA8YnI+IHRhZ3MgaW4gdGhlIGlucHV0IGFuZCByZXBsYWNlIHdpdGggc3BhY2UgaW4gdGhpcyBjYXNlXG4gIH1cblxuICB2YXIgYWN0aXZlU3R5bGUgPSBcIlwiXG4gIHZhciBtYXAgPSBbXVxuICBmb3IoaiA9IDA7IGogPCByYXdTdHJpbmcubGVuZ3RoOyArK2opIHtcbiAgICBtYXBbal0gPSBhY3RpdmVTdHlsZVxuICB9XG5cbiAgaWYoc3R5bGV0YWdzLmJvbGRzID09PSB0cnVlKSBtYXAgPSBwYXJzZVRhZyhUQUdfYm9sZCwgQ0hSX2JvbGQsIHJhd1N0cmluZywgbWFwKVxuICBpZihzdHlsZXRhZ3MuaXRhbGljcyA9PT0gdHJ1ZSkgbWFwID0gcGFyc2VUYWcoVEFHX2l0YWxpYywgQ0hSX2l0YWxpYywgcmF3U3RyaW5nLCBtYXApXG4gIGlmKHN0eWxldGFncy5zdXBlcnNjcmlwdHMgPT09IHRydWUpIG1hcCA9IHBhcnNlVGFnKFRBR19zdXBlciwgQ0hSX3N1cGVyLCByYXdTdHJpbmcsIG1hcClcbiAgaWYoc3R5bGV0YWdzLnN1YnNjcmlwdHMgPT09IHRydWUpIG1hcCA9IHBhcnNlVGFnKFRBR19zdWIsIENIUl9zdWIsIHJhd1N0cmluZywgbWFwKVxuXG4gIHZhciBhbGxTdHlsZXMgPSBbXVxuICB2YXIgcGxhaW5UZXh0ID0gXCJcIlxuICBmb3IoaiA9IDA7IGogPCByYXdTdHJpbmcubGVuZ3RoOyArK2opIHtcbiAgICBpZihtYXBbal0gIT09IG51bGwpIHtcbiAgICAgIHBsYWluVGV4dCArPSByYXdTdHJpbmdbal1cbiAgICAgIGFsbFN0eWxlcy5wdXNoKG1hcFtqXSlcbiAgICB9XG4gIH1cblxuICB2YXIgYWxsVGV4dHMgPSBwbGFpblRleHQuc3BsaXQoJ1xcbicpXG5cbiAgdmFyIG51bWJlck9mTGluZXMgPSBhbGxUZXh0cy5sZW5ndGhcbiAgdmFyIGxpbmVIZWlnaHQgPSBNYXRoLnJvdW5kKGxpbmVTcGFjaW5nICogZm9udFNpemUpXG4gIHZhciBvZmZzZXRYID0gZm9udFNpemVcbiAgdmFyIG9mZnNldFkgPSBmb250U2l6ZSAqIDJcbiAgdmFyIG1heFdpZHRoID0gMFxuICB2YXIgbWluSGVpZ2h0ID0gbnVtYmVyT2ZMaW5lcyAqIGxpbmVIZWlnaHQgKyBvZmZzZXRZXG5cbiAgaWYoY2FudmFzLmhlaWdodCA8IG1pbkhlaWdodCkge1xuICAgIGNhbnZhcy5oZWlnaHQgPSBtaW5IZWlnaHRcbiAgfVxuXG4gIGNvbnRleHQuZmlsbFN0eWxlID0gXCIjMDAwXCJcbiAgY29udGV4dC5maWxsUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpXG5cbiAgY29udGV4dC5maWxsU3R5bGUgPSBcIiNmZmZcIlxuICB2YXIgaSwgaiwgeFBvcywgeVBvcywgelBvc1xuICB2YXIgbkRvbmUgPSAwXG5cbiAgdmFyIGJ1ZmZlciA9IFwiXCJcbiAgZnVuY3Rpb24gd3JpdGVCdWZmZXIoKSB7XG4gICAgaWYoYnVmZmVyICE9PSBcIlwiKSB7XG4gICAgICB2YXIgZGVsdGEgPSBjb250ZXh0Lm1lYXN1cmVUZXh0KGJ1ZmZlcikud2lkdGhcblxuICAgICAgY29udGV4dC5maWxsVGV4dChidWZmZXIsIG9mZnNldFggKyB4UG9zLCBvZmZzZXRZICsgeVBvcylcbiAgICAgIHhQb3MgKz0gZGVsdGFcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnZXRUZXh0Rm9udFNpemUoKSB7XG4gICAgcmV0dXJuIFwiXCIgKyBNYXRoLnJvdW5kKHpQb3MpICsgXCJweCBcIjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNoYW5nZVN0eWxlKG9sZFN0eWxlLCBuZXdTdHlsZSkge1xuICAgIHZhciBjdHhGb250ID0gXCJcIiArIGNvbnRleHQuZm9udDtcblxuICAgIGlmKHN0eWxldGFncy5zdWJzY3JpcHRzID09PSB0cnVlKSB7XG4gICAgICB2YXIgb2xkSW5kZXhfU3ViID0gb2xkU3R5bGUuaW5kZXhPZihDSFJfc3ViMCk7XG4gICAgICB2YXIgbmV3SW5kZXhfU3ViID0gbmV3U3R5bGUuaW5kZXhPZihDSFJfc3ViMCk7XG5cbiAgICAgIHZhciBvbGRTdWIgPSAob2xkSW5kZXhfU3ViID4gLTEpID8gcGFyc2VJbnQob2xkU3R5bGVbMSArIG9sZEluZGV4X1N1Yl0pIDogMDtcbiAgICAgIHZhciBuZXdTdWIgPSAobmV3SW5kZXhfU3ViID4gLTEpID8gcGFyc2VJbnQobmV3U3R5bGVbMSArIG5ld0luZGV4X1N1Yl0pIDogMDtcblxuICAgICAgaWYob2xkU3ViICE9PSBuZXdTdWIpIHtcbiAgICAgICAgY3R4Rm9udCA9IGN0eEZvbnQucmVwbGFjZShnZXRUZXh0Rm9udFNpemUoKSwgXCI/cHggXCIpXG4gICAgICAgIHpQb3MgKj0gTWF0aC5wb3coMC43NSwgKG5ld1N1YiAtIG9sZFN1YikpXG4gICAgICAgIGN0eEZvbnQgPSBjdHhGb250LnJlcGxhY2UoXCI/cHggXCIsIGdldFRleHRGb250U2l6ZSgpKVxuICAgICAgfVxuICAgICAgeVBvcyArPSAwLjI1ICogbGluZUhlaWdodCAqIChuZXdTdWIgLSBvbGRTdWIpO1xuICAgIH1cblxuICAgIGlmKHN0eWxldGFncy5zdXBlcnNjcmlwdHMgPT09IHRydWUpIHtcbiAgICAgIHZhciBvbGRJbmRleF9TdXBlciA9IG9sZFN0eWxlLmluZGV4T2YoQ0hSX3N1cGVyMCk7XG4gICAgICB2YXIgbmV3SW5kZXhfU3VwZXIgPSBuZXdTdHlsZS5pbmRleE9mKENIUl9zdXBlcjApO1xuXG4gICAgICB2YXIgb2xkU3VwZXIgPSAob2xkSW5kZXhfU3VwZXIgPiAtMSkgPyBwYXJzZUludChvbGRTdHlsZVsxICsgb2xkSW5kZXhfU3VwZXJdKSA6IDA7XG4gICAgICB2YXIgbmV3U3VwZXIgPSAobmV3SW5kZXhfU3VwZXIgPiAtMSkgPyBwYXJzZUludChuZXdTdHlsZVsxICsgbmV3SW5kZXhfU3VwZXJdKSA6IDA7XG5cbiAgICAgIGlmKG9sZFN1cGVyICE9PSBuZXdTdXBlcikge1xuICAgICAgICBjdHhGb250ID0gY3R4Rm9udC5yZXBsYWNlKGdldFRleHRGb250U2l6ZSgpLCBcIj9weCBcIilcbiAgICAgICAgelBvcyAqPSBNYXRoLnBvdygwLjc1LCAobmV3U3VwZXIgLSBvbGRTdXBlcikpXG4gICAgICAgIGN0eEZvbnQgPSBjdHhGb250LnJlcGxhY2UoXCI/cHggXCIsIGdldFRleHRGb250U2l6ZSgpKVxuICAgICAgfVxuICAgICAgeVBvcyAtPSAwLjI1ICogbGluZUhlaWdodCAqIChuZXdTdXBlciAtIG9sZFN1cGVyKTtcbiAgICB9XG5cbiAgICBpZihzdHlsZXRhZ3MuYm9sZHMgPT09IHRydWUpIHtcbiAgICAgIHZhciB3YXNCb2xkID0gKG9sZFN0eWxlLmluZGV4T2YoQ0hSX2JvbGQpID4gLTEpXG4gICAgICB2YXIgaXNfQm9sZCA9IChuZXdTdHlsZS5pbmRleE9mKENIUl9ib2xkKSA+IC0xKVxuXG4gICAgICBpZighd2FzQm9sZCAmJiBpc19Cb2xkKSB7XG4gICAgICAgIGlmKHdhc0l0YWxpYykge1xuICAgICAgICAgIGN0eEZvbnQgPSBjdHhGb250LnJlcGxhY2UoXCJpdGFsaWMgXCIsIFwiaXRhbGljIGJvbGQgXCIpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3R4Rm9udCA9IFwiYm9sZCBcIiArIGN0eEZvbnRcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYod2FzQm9sZCAmJiAhaXNfQm9sZCkge1xuICAgICAgICBjdHhGb250ID0gY3R4Rm9udC5yZXBsYWNlKFwiYm9sZCBcIiwgJycpXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYoc3R5bGV0YWdzLml0YWxpY3MgPT09IHRydWUpIHtcbiAgICAgIHZhciB3YXNJdGFsaWMgPSAob2xkU3R5bGUuaW5kZXhPZihDSFJfaXRhbGljKSA+IC0xKVxuICAgICAgdmFyIGlzX0l0YWxpYyA9IChuZXdTdHlsZS5pbmRleE9mKENIUl9pdGFsaWMpID4gLTEpXG5cbiAgICAgIGlmKCF3YXNJdGFsaWMgJiYgaXNfSXRhbGljKSB7XG4gICAgICAgIGN0eEZvbnQgPSBcIml0YWxpYyBcIiArIGN0eEZvbnRcbiAgICAgIH1cbiAgICAgIGlmKHdhc0l0YWxpYyAmJiAhaXNfSXRhbGljKSB7XG4gICAgICAgIGN0eEZvbnQgPSBjdHhGb250LnJlcGxhY2UoXCJpdGFsaWMgXCIsICcnKVxuICAgICAgfVxuICAgIH1cbiAgICBjb250ZXh0LmZvbnQgPSBjdHhGb250XG4gIH1cblxuICBmb3IoaSA9IDA7IGkgPCBudW1iZXJPZkxpbmVzOyArK2kpIHtcbiAgICB2YXIgdHh0ID0gYWxsVGV4dHNbaV0gKyAnXFxuJ1xuICAgIHhQb3MgPSAwXG4gICAgeVBvcyA9IGkgKiBsaW5lSGVpZ2h0XG4gICAgelBvcyA9IGZvbnRTaXplXG5cbiAgICBidWZmZXIgPSBcIlwiXG4gICAgXG4gICAgZm9yKGogPSAwOyBqIDwgdHh0Lmxlbmd0aDsgKytqKSB7XG4gICAgICB2YXIgc3R5bGUgPSAoaiArIG5Eb25lIDwgYWxsU3R5bGVzLmxlbmd0aCkgPyBhbGxTdHlsZXNbaiArIG5Eb25lXSA6IGFsbFN0eWxlc1thbGxTdHlsZXMubGVuZ3RoIC0gMV1cbiAgICAgIGlmKGFjdGl2ZVN0eWxlID09PSBzdHlsZSkge1xuICAgICAgICBidWZmZXIgKz0gdHh0W2pdXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3cml0ZUJ1ZmZlcigpXG4gICAgICAgIGJ1ZmZlciA9IHR4dFtqXVxuXG4gICAgICAgIGlmKHN0eWxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBjaGFuZ2VTdHlsZShhY3RpdmVTdHlsZSwgc3R5bGUpXG4gICAgICAgICAgYWN0aXZlU3R5bGUgPSBzdHlsZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHdyaXRlQnVmZmVyKClcblxuICAgIG5Eb25lICs9IHR4dC5sZW5ndGhcblxuICAgIHZhciB3aWR0aCA9IE1hdGgucm91bmQoeFBvcyArIDIgKiBvZmZzZXRYKSB8IDBcbiAgICBpZihtYXhXaWR0aCA8IHdpZHRoKSBtYXhXaWR0aCA9IHdpZHRoXG4gIH1cblxuICAvL0N1dCBwaXhlbHMgZnJvbSBpbWFnZVxuICB2YXIgeEN1dCA9IG1heFdpZHRoXG4gIHZhciB5Q3V0ID0gb2Zmc2V0WSArIGxpbmVIZWlnaHQgKiBudW1iZXJPZkxpbmVzXG4gIHZhciBwaXhlbHMgPSBuZGFycmF5KGNvbnRleHQuZ2V0SW1hZ2VEYXRhKDAsIDAsIHhDdXQsIHlDdXQpLmRhdGEsIFt5Q3V0LCB4Q3V0LCA0XSlcbiAgcmV0dXJuIHBpeGVscy5waWNrKC0xLCAtMSwgMCkudHJhbnNwb3NlKDEsIDApXG59XG5cbmZ1bmN0aW9uIGdldENvbnRvdXIocGl4ZWxzLCBkb1NpbXBsaWZ5KSB7XG4gIHZhciBjb250b3VyID0gc3VyZmFjZU5ldHMocGl4ZWxzLCAxMjgpXG4gIGlmKGRvU2ltcGxpZnkpIHtcbiAgICByZXR1cm4gc2ltcGxpZnkoY29udG91ci5jZWxscywgY29udG91ci5wb3NpdGlvbnMsIDAuMjUpXG4gIH1cbiAgcmV0dXJuIHtcbiAgICBlZGdlczogY29udG91ci5jZWxscyxcbiAgICBwb3NpdGlvbnM6IGNvbnRvdXIucG9zaXRpb25zXG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc1BpeGVsc0ltcGwocGl4ZWxzLCBvcHRpb25zLCBzaXplLCBzaW1wbGlmeSkge1xuICAvL0V4dHJhY3QgY29udG91clxuICB2YXIgY29udG91ciA9IGdldENvbnRvdXIocGl4ZWxzLCBzaW1wbGlmeSlcblxuICAvL0FwcGx5IHdhcnAgdG8gcG9zaXRpb25zXG4gIHZhciBwb3NpdGlvbnMgPSB0cmFuc2Zvcm1Qb3NpdGlvbnMoY29udG91ci5wb3NpdGlvbnMsIG9wdGlvbnMsIHNpemUpXG4gIHZhciBlZGdlcyAgICAgPSBjb250b3VyLmVkZ2VzXG4gIHZhciBmbGlwID0gXCJjY3dcIiA9PT0gb3B0aW9ucy5vcmllbnRhdGlvblxuXG4gIC8vQ2xlYW4gdXAgdGhlIFBTTEcsIHJlc29sdmUgc2VsZiBpbnRlcnNlY3Rpb25zLCBldGMuXG4gIGNsZWFuUFNMRyhwb3NpdGlvbnMsIGVkZ2VzKVxuXG4gIC8vSWYgdHJpYW5ndWxhdGUgZmxhZyBwYXNzZWQsIHRyaWFuZ3VsYXRlIHRoZSByZXN1bHRcbiAgaWYob3B0aW9ucy5wb2x5Z29ucyB8fCBvcHRpb25zLnBvbHlnb24gfHwgb3B0aW9ucy5wb2x5bGluZSkge1xuICAgIHZhciByZXN1bHQgPSB0b1BvbHlnb25DcmFwcHkoZWRnZXMsIHBvc2l0aW9ucylcbiAgICB2YXIgbnJlc3VsdCA9IG5ldyBBcnJheShyZXN1bHQubGVuZ3RoKVxuICAgIGZvcih2YXIgaT0wOyBpPHJlc3VsdC5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIGxvb3BzID0gcmVzdWx0W2ldXG4gICAgICB2YXIgbmxvb3BzID0gbmV3IEFycmF5KGxvb3BzLmxlbmd0aClcbiAgICAgIGZvcih2YXIgaj0wOyBqPGxvb3BzLmxlbmd0aDsgKytqKSB7XG4gICAgICAgIHZhciBsb29wID0gbG9vcHNbal1cbiAgICAgICAgdmFyIG5sb29wID0gbmV3IEFycmF5KGxvb3AubGVuZ3RoKVxuICAgICAgICBmb3IodmFyIGs9MDsgazxsb29wLmxlbmd0aDsgKytrKSB7XG4gICAgICAgICAgbmxvb3Bba10gPSBwb3NpdGlvbnNbbG9vcFtrXV0uc2xpY2UoKVxuICAgICAgICB9XG4gICAgICAgIGlmKGZsaXApIHtcbiAgICAgICAgICBubG9vcC5yZXZlcnNlKClcbiAgICAgICAgfVxuICAgICAgICBubG9vcHNbal0gPSBubG9vcFxuICAgICAgfVxuICAgICAgbnJlc3VsdFtpXSA9IG5sb29wc1xuICAgIH1cbiAgICByZXR1cm4gbnJlc3VsdFxuICB9IGVsc2UgaWYob3B0aW9ucy50cmlhbmdsZXMgfHwgb3B0aW9ucy50cmlhbmd1bGF0ZSB8fCBvcHRpb25zLnRyaWFuZ2xlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNlbGxzOiBjZHQyZChwb3NpdGlvbnMsIGVkZ2VzLCB7XG4gICAgICAgIGRlbGF1bmF5OiBmYWxzZSxcbiAgICAgICAgZXh0ZXJpb3I6IGZhbHNlLFxuICAgICAgICBpbnRlcmlvcjogdHJ1ZVxuICAgICAgfSksXG4gICAgICBwb3NpdGlvbnM6IHBvc2l0aW9uc1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4ge1xuICAgICAgZWRnZXM6ICAgICBlZGdlcyxcbiAgICAgIHBvc2l0aW9uczogcG9zaXRpb25zXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NQaXhlbHMocGl4ZWxzLCBvcHRpb25zLCBzaXplKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHByb2Nlc3NQaXhlbHNJbXBsKHBpeGVscywgb3B0aW9ucywgc2l6ZSwgdHJ1ZSlcbiAgfSBjYXRjaChlKSB7fVxuICB0cnkge1xuICAgIHJldHVybiBwcm9jZXNzUGl4ZWxzSW1wbChwaXhlbHMsIG9wdGlvbnMsIHNpemUsIGZhbHNlKVxuICB9IGNhdGNoKGUpIHt9XG4gIGlmKG9wdGlvbnMucG9seWdvbnMgfHwgb3B0aW9ucy5wb2x5bGluZSB8fCBvcHRpb25zLnBvbHlnb24pIHtcbiAgICByZXR1cm4gW11cbiAgfVxuICBpZihvcHRpb25zLnRyaWFuZ2xlcyB8fCBvcHRpb25zLnRyaWFuZ3VsYXRlIHx8IG9wdGlvbnMudHJpYW5nbGUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY2VsbHM6IFtdLFxuICAgICAgcG9zaXRpb25zOiBbXVxuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIGVkZ2VzOiBbXSxcbiAgICBwb3NpdGlvbnM6IFtdXG4gIH1cbn1cblxuZnVuY3Rpb24gdmVjdG9yaXplVGV4dChzdHIsIGNhbnZhcywgY29udGV4dCwgb3B0aW9ucykge1xuICB2YXIgc2l6ZSA9IDY0XG4gIHZhciBsaW5lU3BhY2luZyA9IDEuMjVcbiAgdmFyIHN0eWxldGFncyA9IHtcbiAgICBicmVha2xpbmVzOiBmYWxzZSxcbiAgICBib2xkczogZmFsc2UsXG4gICAgaXRhbGljczogZmFsc2UsXG4gICAgc3Vic2NyaXB0czogZmFsc2UsXG4gICAgc3VwZXJzY3JpcHRzOiBmYWxzZVxuICB9XG5cbiAgaWYob3B0aW9ucykge1xuXG4gICAgaWYob3B0aW9ucy5zaXplICYmXG4gICAgICAgb3B0aW9ucy5zaXplID4gMCkgc2l6ZSA9XG4gICAgICAgb3B0aW9ucy5zaXplXG5cbiAgICBpZihvcHRpb25zLmxpbmVTcGFjaW5nICYmXG4gICAgICAgb3B0aW9ucy5saW5lU3BhY2luZyA+IDApIGxpbmVTcGFjaW5nID1cbiAgICAgICBvcHRpb25zLmxpbmVTcGFjaW5nXG5cbiAgICBpZihvcHRpb25zLnN0eWxldGFncyAmJlxuICAgICAgIG9wdGlvbnMuc3R5bGV0YWdzLmJyZWFrbGluZXMpIHN0eWxldGFncy5icmVha2xpbmVzID1cbiAgICAgICBvcHRpb25zLnN0eWxldGFncy5icmVha2xpbmVzID8gdHJ1ZSA6IGZhbHNlXG5cbiAgICBpZihvcHRpb25zLnN0eWxldGFncyAmJlxuICAgICAgIG9wdGlvbnMuc3R5bGV0YWdzLmJvbGRzKSBzdHlsZXRhZ3MuYm9sZHMgPVxuICAgICAgIG9wdGlvbnMuc3R5bGV0YWdzLmJvbGRzID8gdHJ1ZSA6IGZhbHNlXG5cbiAgICBpZihvcHRpb25zLnN0eWxldGFncyAmJlxuICAgICAgIG9wdGlvbnMuc3R5bGV0YWdzLml0YWxpY3MpIHN0eWxldGFncy5pdGFsaWNzID1cbiAgICAgICBvcHRpb25zLnN0eWxldGFncy5pdGFsaWNzID8gdHJ1ZSA6IGZhbHNlXG5cbiAgICBpZihvcHRpb25zLnN0eWxldGFncyAmJlxuICAgICAgIG9wdGlvbnMuc3R5bGV0YWdzLnN1YnNjcmlwdHMpIHN0eWxldGFncy5zdWJzY3JpcHRzID1cbiAgICAgICBvcHRpb25zLnN0eWxldGFncy5zdWJzY3JpcHRzID8gdHJ1ZSA6IGZhbHNlXG5cbiAgICBpZihvcHRpb25zLnN0eWxldGFncyAmJlxuICAgICAgIG9wdGlvbnMuc3R5bGV0YWdzLnN1cGVyc2NyaXB0cykgc3R5bGV0YWdzLnN1cGVyc2NyaXB0cyA9XG4gICAgICAgb3B0aW9ucy5zdHlsZXRhZ3Muc3VwZXJzY3JpcHRzID8gdHJ1ZSA6IGZhbHNlXG4gIH1cblxuICBjb250ZXh0LmZvbnQgPSBbXG4gICAgb3B0aW9ucy5mb250U3R5bGUsXG4gICAgb3B0aW9ucy5mb250VmFyaWFudCxcbiAgICBvcHRpb25zLmZvbnRXZWlnaHQsXG4gICAgc2l6ZSArIFwicHhcIixcbiAgICBvcHRpb25zLmZvbnRcbiAgXS5maWx0ZXIoZnVuY3Rpb24oZCkge3JldHVybiBkfSkuam9pbihcIiBcIilcbiAgY29udGV4dC50ZXh0QWxpZ24gPSBcInN0YXJ0XCJcbiAgY29udGV4dC50ZXh0QmFzZWxpbmUgPSBcImFscGhhYmV0aWNcIlxuICBjb250ZXh0LmRpcmVjdGlvbiA9IFwibHRyXCJcblxuICB2YXIgcGl4ZWxzID0gZ2V0UGl4ZWxzKGNhbnZhcywgY29udGV4dCwgc3RyLCBzaXplLCBsaW5lU3BhY2luZywgc3R5bGV0YWdzKVxuXG4gIHJldHVybiBwcm9jZXNzUGl4ZWxzKHBpeGVscywgb3B0aW9ucywgc2l6ZSlcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnY3dpc2UtY29tcGlsZXInKSh7XG4gICAgYXJnczogWydhcnJheScsIHtcbiAgICAgICAgb2Zmc2V0OiBbMV0sXG4gICAgICAgIGFycmF5OiAwXG4gICAgfSwgJ3NjYWxhcicsICdzY2FsYXInLCAnaW5kZXgnXSxcbiAgICBwcmU6IHtcbiAgICAgICAgXCJib2R5XCI6IFwie31cIixcbiAgICAgICAgXCJhcmdzXCI6IFtdLFxuICAgICAgICBcInRoaXNWYXJzXCI6IFtdLFxuICAgICAgICBcImxvY2FsVmFyc1wiOiBbXVxuICAgIH0sXG4gICAgcG9zdDoge1xuICAgICAgICBcImJvZHlcIjogXCJ7fVwiLFxuICAgICAgICBcImFyZ3NcIjogW10sXG4gICAgICAgIFwidGhpc1ZhcnNcIjogW10sXG4gICAgICAgIFwibG9jYWxWYXJzXCI6IFtdXG4gICAgfSxcbiAgICBib2R5OiB7XG4gICAgICAgIFwiYm9keVwiOiBcIntcXG4gICAgICAgIHZhciBfaW5saW5lXzFfZGEgPSBfaW5saW5lXzFfYXJnMF8gLSBfaW5saW5lXzFfYXJnM19cXG4gICAgICAgIHZhciBfaW5saW5lXzFfZGIgPSBfaW5saW5lXzFfYXJnMV8gLSBfaW5saW5lXzFfYXJnM19cXG4gICAgICAgIGlmKChfaW5saW5lXzFfZGEgPj0gMCkgIT09IChfaW5saW5lXzFfZGIgPj0gMCkpIHtcXG4gICAgICAgICAgX2lubGluZV8xX2FyZzJfLnB1c2goX2lubGluZV8xX2FyZzRfWzBdICsgMC41ICsgMC41ICogKF9pbmxpbmVfMV9kYSArIF9pbmxpbmVfMV9kYikgLyAoX2lubGluZV8xX2RhIC0gX2lubGluZV8xX2RiKSlcXG4gICAgICAgIH1cXG4gICAgICB9XCIsXG4gICAgICAgIFwiYXJnc1wiOiBbe1xuICAgICAgICAgICAgXCJuYW1lXCI6IFwiX2lubGluZV8xX2FyZzBfXCIsXG4gICAgICAgICAgICBcImx2YWx1ZVwiOiBmYWxzZSxcbiAgICAgICAgICAgIFwicnZhbHVlXCI6IHRydWUsXG4gICAgICAgICAgICBcImNvdW50XCI6IDFcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgXCJuYW1lXCI6IFwiX2lubGluZV8xX2FyZzFfXCIsXG4gICAgICAgICAgICBcImx2YWx1ZVwiOiBmYWxzZSxcbiAgICAgICAgICAgIFwicnZhbHVlXCI6IHRydWUsXG4gICAgICAgICAgICBcImNvdW50XCI6IDFcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgXCJuYW1lXCI6IFwiX2lubGluZV8xX2FyZzJfXCIsXG4gICAgICAgICAgICBcImx2YWx1ZVwiOiBmYWxzZSxcbiAgICAgICAgICAgIFwicnZhbHVlXCI6IHRydWUsXG4gICAgICAgICAgICBcImNvdW50XCI6IDFcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgXCJuYW1lXCI6IFwiX2lubGluZV8xX2FyZzNfXCIsXG4gICAgICAgICAgICBcImx2YWx1ZVwiOiBmYWxzZSxcbiAgICAgICAgICAgIFwicnZhbHVlXCI6IHRydWUsXG4gICAgICAgICAgICBcImNvdW50XCI6IDJcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgXCJuYW1lXCI6IFwiX2lubGluZV8xX2FyZzRfXCIsXG4gICAgICAgICAgICBcImx2YWx1ZVwiOiBmYWxzZSxcbiAgICAgICAgICAgIFwicnZhbHVlXCI6IHRydWUsXG4gICAgICAgICAgICBcImNvdW50XCI6IDFcbiAgICAgICAgfV0sXG4gICAgICAgIFwidGhpc1ZhcnNcIjogW10sXG4gICAgICAgIFwibG9jYWxWYXJzXCI6IFtcIl9pbmxpbmVfMV9kYVwiLCBcIl9pbmxpbmVfMV9kYlwiXVxuICAgIH0sXG4gICAgZnVuY05hbWU6ICd6ZXJvQ3Jvc3NpbmdzJ1xufSlcbiIsIlwidXNlIHN0cmljdFwiXG5cbm1vZHVsZS5leHBvcnRzID0gZmluZFplcm9Dcm9zc2luZ3NcblxudmFyIGNvcmUgPSByZXF1aXJlKFwiLi9saWIvemMtY29yZVwiKVxuXG5mdW5jdGlvbiBmaW5kWmVyb0Nyb3NzaW5ncyhhcnJheSwgbGV2ZWwpIHtcbiAgdmFyIGNyb3NzID0gW11cbiAgbGV2ZWwgPSArbGV2ZWwgfHwgMC4wXG4gIGNvcmUoYXJyYXkuaGkoYXJyYXkuc2hhcGVbMF0tMSksIGNyb3NzLCBsZXZlbClcbiAgcmV0dXJuIGNyb3NzXG59IiwiLy8gaGFuZGxlcyBjb2RlIGV2YWx1YXRpb24gYW5kIGF0dGFjaGluZyByZWxldmFudCBvYmplY3RzIHRvIGdsb2JhbCBhbmQgZXZhbHVhdGlvbiBjb250ZXh0c1xuXG5pbXBvcnQgU2FuZGJveCBmcm9tICcuL2xpYi9zYW5kYm94LmpzJ1xuaW1wb3J0IEFycmF5VXRpbHMgZnJvbSAnLi9saWIvYXJyYXktdXRpbHMuanMnXG5cbmNsYXNzIEV2YWxTYW5kYm94IHtcbiAgY29uc3RydWN0b3IocGFyZW50LCBtYWtlR2xvYmFsLCB1c2VyUHJvcHMgPSBbXSkge1xuICAgIHRoaXMubWFrZUdsb2JhbCA9IG1ha2VHbG9iYWxcbiAgICB0aGlzLnNhbmRib3ggPSBTYW5kYm94KHBhcmVudClcbiAgICB0aGlzLnBhcmVudCA9IHBhcmVudFxuICAgIHZhciBwcm9wZXJ0aWVzID0gT2JqZWN0LmtleXMocGFyZW50KVxuICAgIHByb3BlcnRpZXMuZm9yRWFjaCgocHJvcGVydHkpID0+IHRoaXMuYWRkKHByb3BlcnR5KSlcbiAgICB0aGlzLnVzZXJQcm9wcyA9IHVzZXJQcm9wc1xuICB9XG5cbiAgYWRkKG5hbWUpIHtcbiAgICBpZih0aGlzLm1ha2VHbG9iYWwpIHdpbmRvd1tuYW1lXSA9IHRoaXMucGFyZW50W25hbWVdXG4gICAgLy8gdGhpcy5zYW5kYm94LmFkZFRvQ29udGV4dChuYW1lLCBgcGFyZW50LiR7bmFtZX1gKVxuICB9XG5cbi8vIHNldHMgb24gd2luZG93IGFzIHdlbGwgYXMgc3ludGggb2JqZWN0IGlmIGdsb2JhbCAobm90IG5lZWRlZCBmb3Igb2JqZWN0cywgd2hpY2ggY2FuIGJlIHNldCBkaXJlY3RseSlcblxuICBzZXQocHJvcGVydHksIHZhbHVlKSB7XG4gICAgaWYodGhpcy5tYWtlR2xvYmFsKSB7XG4gICAgICB3aW5kb3dbcHJvcGVydHldID0gdmFsdWVcbiAgICB9XG4gICAgdGhpcy5wYXJlbnRbcHJvcGVydHldID0gdmFsdWVcbiAgfVxuXG4gIHRpY2soKSB7XG4gICAgaWYodGhpcy5tYWtlR2xvYmFsKSB7XG4gICAgICB0aGlzLnVzZXJQcm9wcy5mb3JFYWNoKChwcm9wZXJ0eSkgPT4ge1xuICAgICAgICB0aGlzLnBhcmVudFtwcm9wZXJ0eV0gPSB3aW5kb3dbcHJvcGVydHldXG4gICAgICB9KVxuICAgICAgLy8gIHRoaXMucGFyZW50LnNwZWVkID0gd2luZG93LnNwZWVkXG4gICAgfSBlbHNlIHtcblxuICAgIH1cbiAgfVxuXG4gIGV2YWwoY29kZSkge1xuICAgIHRoaXMuc2FuZGJveC5ldmFsKGNvZGUpXG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgRXZhbFNhbmRib3hcbiIsImltcG9ydCBhcnJheVV0aWxzIGZyb20gJy4vbGliL2FycmF5LXV0aWxzLmpzJ1xuaW1wb3J0IHtnZXRMb29rdXB9IGZyb20gXCIuL3R5cGVzLmpzXCI7XG5cbi8vIFtXSVBdIGhvdyB0byB0cmVhdCBkaWZmZXJlbnQgZGltZW5zaW9ucyAoPylcbmNvbnN0IERFRkFVTFRfQ09OVkVSU0lPTlMgPSB7XG4gIGZsb2F0OiB7XG4gICAgJ3ZlYzQnOiB7IG5hbWU6ICdzdW0nLCBhcmdzOiBbWzEsIDEsIDEsIDFdXSB9LFxuICAgICd2ZWMyJzogeyBuYW1lOiAnc3VtJywgYXJnczogW1sxLCAxXV0gfVxuICB9XG59XG5cbmZ1bmN0aW9uIGZpbGxBcnJheVdpdGhEZWZhdWx0cyhhcnIsIGxlbikge1xuICAvLyBmaWxsIHRoZSBhcnJheSB3aXRoIGRlZmF1bHQgdmFsdWVzIGlmIGl0J3MgdG9vIHNob3J0XG4gIHdoaWxlIChhcnIubGVuZ3RoIDwgbGVuKSB7XG4gICAgaWYgKGFyci5sZW5ndGggPT09IDMpIHsgLy8gcHVzaCBhIDEgYXMgdGhlIGRlZmF1bHQgZm9yIC5hIGluIHZlYzRcbiAgICAgIGFyci5wdXNoKDEuMClcbiAgICB9IGVsc2Uge1xuICAgICAgYXJyLnB1c2goMC4wKVxuICAgIH1cbiAgfVxuICByZXR1cm4gYXJyLnNsaWNlKDAsIGxlbilcbn1cblxuY29uc3QgZW5zdXJlX2RlY2ltYWxfZG90ID0gKHZhbCkgPT4ge1xuICB2YWwgPSB2YWwudG9TdHJpbmcoKVxuICBpZiAodmFsLmluZGV4T2YoJy4nKSA8IDApIHtcbiAgICB2YWwgKz0gJy4nXG4gIH1cbiAgcmV0dXJuIHZhbFxufVxuXG5cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZm9ybWF0QXJndW1lbnRzKHRyYW5zZm9ybSwgc3RhcnRJbmRleCwgc3ludGhDb250ZXh0KSB7XG4gIGNvbnN0IGRlZmF1bHRBcmdzID0gdHJhbnNmb3JtLnRyYW5zZm9ybS5pbnB1dHNcbiAgY29uc3QgdXNlckFyZ3MgPSB0cmFuc2Zvcm0udXNlckFyZ3NcbiAgY29uc3QgeyBnZW5lcmF0b3JzIH0gPSB0cmFuc2Zvcm0uc3ludGhcbiAgY29uc3QgeyBzcmMgfSA9IGdlbmVyYXRvcnMgLy8gZGVwZW5kcyBvbiBzeW50aCBoYXZpbmcgc3JjKCkgZnVuY3Rpb25cbiAgcmV0dXJuIGRlZmF1bHRBcmdzLm1hcCgoaW5wdXQsIGluZGV4KSA9PiB7XG4gICAgY29uc3QgdHlwZWRBcmcgPSB7XG4gICAgICB2YWx1ZTogaW5wdXQuZGVmYXVsdCxcbiAgICAgIHR5cGU6IGlucHV0LnR5cGUsIC8vXG4gICAgICBpc1VuaWZvcm06IGZhbHNlLFxuICAgICAgbmFtZTogaW5wdXQubmFtZSxcbiAgICAgIHZlY0xlbjogMFxuICAgICAgLy8gIGdlbmVyYXRlR2xzbDogbnVsbCAvLyBmdW5jdGlvbiBmb3IgY3JlYXRpbmcgZ2xzbFxuICAgIH1cblxuICAgIGlmICh0eXBlZEFyZy50eXBlID09PSAnZmxvYXQnKSB0eXBlZEFyZy52YWx1ZSA9IGVuc3VyZV9kZWNpbWFsX2RvdChpbnB1dC5kZWZhdWx0KVxuICAgIGlmIChpbnB1dC50eXBlLnN0YXJ0c1dpdGgoJ3ZlYycpKSB7XG4gICAgICB0cnkge1xuICAgICAgICB0eXBlZEFyZy52ZWNMZW4gPSBOdW1iZXIucGFyc2VJbnQoaW5wdXQudHlwZS5zdWJzdHIoMykpXG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGBFcnJvciBkZXRlcm1pbmluZyBsZW5ndGggb2YgdmVjdG9yIGlucHV0IHR5cGUgJHtpbnB1dC50eXBlfSAoJHtpbnB1dC5uYW1lfSlgKVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGlmIHVzZXIgaGFzIGlucHV0IHNvbWV0aGluZyBmb3IgdGhpcyBhcmd1bWVudFxuICAgIGlmICh1c2VyQXJncy5sZW5ndGggPiBpbmRleCkge1xuICAgICAgdHlwZWRBcmcudmFsdWUgPSB1c2VyQXJnc1tpbmRleF07XG4gICAgICBpZiAodHlwZW9mIHR5cGVkQXJnLnZhbHVlID09PSAnZnVuY3Rpb24nICYmIHR5cGVkQXJnLnZhbHVlLm5hbWUgIT09ICdyZWdsVGV4dHVyZTJEJyAmJiB0eXBlZEFyZy52YWx1ZS5uYW1lICE9PSAncmVnbEZyYW1lYnVmZmVyJykge1xuICAgICAgICB0eXBlZEFyZy52YWx1ZSA9IGdldEZ1bmN0aW9uVmFsdWUodHlwZWRBcmcudmFsdWUsIGlucHV0KTtcbiAgICAgICAgdHlwZWRBcmcuaXNVbmlmb3JtID0gdHJ1ZVxuICAgICAgfSBlbHNlIGlmICh0eXBlZEFyZy52YWx1ZS5jb25zdHJ1Y3RvciA9PT0gQXJyYXkpIHtcbiAgICAgICAgdHlwZWRBcmcudmFsdWUgPSBnZXRBcnJheVZhbHVlKHR5cGVkQXJnLnZhbHVlLCBpbnB1dCwgdHlwZWRBcmcudmVjTGVuKVxuICAgICAgICB0eXBlZEFyZy5pc1VuaWZvcm0gPSB0cnVlXG4gICAgICAgIC8vIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc3RhcnRJbmRleCA8IDApIHtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHR5cGVkQXJnLnZhbHVlICYmIHR5cGVkQXJnLnZhbHVlLnRyYW5zZm9ybXMpIHtcbiAgICAgICAgY29uc3QgZmluYWxfdHJhbnNmb3JtID0gdHlwZWRBcmcudmFsdWUudHJhbnNmb3Jtc1t0eXBlZEFyZy52YWx1ZS50cmFuc2Zvcm1zLmxlbmd0aCAtIDFdXG5cbiAgICAgICAgaWYgKGZpbmFsX3RyYW5zZm9ybS50cmFuc2Zvcm0uZ2xzbF9yZXR1cm5fdHlwZSAhPT0gaW5wdXQudHlwZSkge1xuICAgICAgICAgIGNvbnN0IGRlZmF1bHRzID0gREVGQVVMVF9DT05WRVJTSU9OU1tpbnB1dC50eXBlXVxuICAgICAgICAgIGlmICh0eXBlb2YgZGVmYXVsdHMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBjb25zdCBkZWZhdWx0X2RlZiA9IGRlZmF1bHRzW2ZpbmFsX3RyYW5zZm9ybS50cmFuc2Zvcm0uZ2xzbF9yZXR1cm5fdHlwZV1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgZGVmYXVsdF9kZWYgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHsgbmFtZSwgYXJncyB9ID0gZGVmYXVsdF9kZWZcbiAgICAgICAgICAgICAgdHlwZWRBcmcudmFsdWUgPSB0eXBlZEFyZy52YWx1ZVtuYW1lXSguLi5hcmdzKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHR5cGVkQXJnLmlzVW5pZm9ybSA9IGZhbHNlXG4gICAgICB9IGVsc2UgaWYgKHR5cGVkQXJnLnR5cGUgPT09ICdmbG9hdCcgJiYgdHlwZW9mIHR5cGVkQXJnLnZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgICB0eXBlZEFyZy52YWx1ZSA9IGVuc3VyZV9kZWNpbWFsX2RvdCh0eXBlZEFyZy52YWx1ZSlcbiAgICAgIH0gZWxzZSBpZiAodHlwZWRBcmcudHlwZS5zdGFydHNXaXRoKCd2ZWMnKSAmJiB0eXBlb2YgdHlwZWRBcmcudmFsdWUgIT09ICdmdW5jdGlvbicgJiYgIXR5cGVkQXJnLnZhbHVlLmdldFRleHR1cmUpIHtcbiAgICAgICAgdHlwZWRBcmcuaXNVbmlmb3JtID0gZmFsc2VcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHlwZWRBcmcudmFsdWUpIHx8IHR5cGVkQXJnLnZhbHVlIGluc3RhbmNlb2YgRmxvYXQzMkFycmF5IHx8IHR5cGVkQXJnLnZhbHVlIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgICAgIC8vIHRvZG86IGFjY2VwdCBzbWFsbGVyIGFycmF5cz9cbiAgICAgICAgICB0eXBlZEFyZy52YWx1ZSA9IGAke3R5cGVkQXJnLnR5cGV9KCR7dHlwZWRBcmcudmFsdWUubWFwKGVuc3VyZV9kZWNpbWFsX2RvdCkuam9pbignLCAnKX0pYFxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiB0eXBlZEFyZy52YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICBjb25zdCBsZW5ndGggPSBwYXJzZUludCh0eXBlZEFyZy50eXBlLnN1YnN0cigtMSkpO1xuICAgICAgICAgIGNvbnN0IGFyciA9IEFycmF5KGxlbmd0aCkuZmlsbCh0eXBlZEFyZy52YWx1ZSk7XG4gICAgICAgICAgdHlwZWRBcmcudmFsdWUgPSBgJHt0eXBlZEFyZy50eXBlfSgke2Fyci5tYXAoZW5zdXJlX2RlY2ltYWxfZG90KS5qb2luKCcsICcpfSlgXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaW5wdXQudHlwZSA9PT0gJ3NhbXBsZXIyRCcpIHtcbiAgICAgICAgLy8gdHlwZWRBcmcudGV4ID0gdHlwZWRBcmcudmFsdWVcbiAgICAgICAgdmFyIHggPSB0eXBlZEFyZy52YWx1ZVxuICAgICAgICB0eXBlZEFyZy52YWx1ZSA9IHguZ2V0VGV4dHVyZSA/ICgpID0+ICh4LmdldFRleHR1cmUoKSkgOiB4XG4gICAgICAgIHR5cGVkQXJnLmlzVW5pZm9ybSA9IHRydWVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGlmIHBhc3NpbmcgaW4gYSB0ZXh0dXJlIHJlZmVyZW5jZSwgd2hlbiBmdW5jdGlvbiBhc2tzIGZvciB2ZWM0LCBjb252ZXJ0IHRvIHZlYzRcbiAgICAgICAgaWYgKHR5cGVkQXJnLnZhbHVlLmdldFRleHR1cmUgfHwgdHlwZWRBcmcudmFsdWUubmFtZSA9PT0gJ3JlZ2xUZXh0dXJlMkQnKSB7XG4gICAgICAgICAgdmFyIHgxID0gdHlwZWRBcmcudmFsdWVcbiAgICAgICAgICBpZiAoaW5wdXQudHlwZSA9PT0gJ3ZlYzQnKSB7XG4gICAgICAgICAgICB0eXBlZEFyZy52YWx1ZSA9IHNyYyh4MSlcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgZ2V0dGVyID0gZ2V0TG9va3VwW2lucHV0LnR5cGVdO1xuICAgICAgICAgICAgdHlwZWRBcmcudmFsdWUgPSBzcmMoeDEpW2dldHRlcl07XG4gICAgICAgICAgfVxuICAgICAgICAgIHR5cGVkQXJnLmlzVW5pZm9ybSA9IGZhbHNlXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gYWRkIHRwIHVuaWZvcm0gYXJyYXkgaWYgaXMgYSBmdW5jdGlvbiB0aGF0IHdpbGwgcGFzcyBpbiBhIGRpZmZlcmVudCB2YWx1ZSBvbiBlYWNoIHJlbmRlciBmcmFtZSxcbiAgICAgIC8vIG9yIGEgdGV4dHVyZS8gZXh0ZXJuYWwgc291cmNlXG5cbiAgICAgIGlmIChpbnB1dC5pc1VuaWZvcm0pIHR5cGVkQXJnLmlzVW5pZm9ybSA9IGlucHV0LmlzVW5pZm9ybTtcbiAgICAgIGlmICh0eXBlZEFyZy5pc1VuaWZvcm0pIHtcbiAgICAgICAgdHlwZWRBcmcubmFtZSArPSBzdGFydEluZGV4XG4gICAgICAgIC8vICBzaGFkZXJQYXJhbXMudW5pZm9ybXMucHVzaCh0eXBlZEFyZylcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHR5cGVkQXJnXG4gIH0pXG59XG5cbmZ1bmN0aW9uIGdldEZ1bmN0aW9uVmFsdWUodmFsdWUsIGlucHV0KSB7XG4gIC8vIGlmICh0eXBlZEFyZy52ZWNMZW4gPiAwKSB7IC8vIGV4cGVjdGVkIGlucHV0IGlzIGEgdmVjdG9yLCBub3QgYSBzY2FsYXJcbiAgLy8gICAgdHlwZWRBcmcudmFsdWUgPSAoY29udGV4dCwgcHJvcHMsIGJhdGNoSWQpID0+IChmaWxsQXJyYXlXaXRoRGVmYXVsdHModXNlckFyZ3NbaW5kZXhdKHByb3BzKSwgdHlwZWRBcmcudmVjTGVuKSlcbiAgLy8gfSBlbHNlIHtcbiAgcmV0dXJuIChjb250ZXh0LCBwcm9wcywgYmF0Y2hJZCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCB2YWwgPSB2YWx1ZShwcm9wcylcbiAgICAgIGlmKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiB2YWxcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUud2FybignZnVuY3Rpb24gZG9lcyBub3QgcmV0dXJuIGEgbnVtYmVyJywgdmFsdWUpXG4gICAgICB9XG4gICAgICByZXR1cm4gaW5wdXQuZGVmYXVsdFxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNvbnNvbGUud2FybignRVJST1InLCBlKVxuICAgICAgcmV0dXJuIGlucHV0LmRlZmF1bHRcbiAgICB9XG4gIH1cbiAgLy8gIH1cbn1cblxuZnVuY3Rpb24gZ2V0QXJyYXlWYWx1ZSh2YWx1ZSwgaW5wdXQsIHZlY0xlbiA9IDApIHtcbiAgLy8gICBpZiAodHlwZWRBcmcudmVjTGVuID4gMCkgeyAvLyBleHBlY3RlZCBpbnB1dCBpcyBhIHZlY3Rvciwgbm90IGEgc2NhbGFyXG4gIC8vICAgICB0eXBlZEFyZy5pc1VuaWZvcm0gPSB0cnVlXG4gIC8vICAgICB0eXBlZEFyZy52YWx1ZSA9IGZpbGxBcnJheVdpdGhEZWZhdWx0cyh0eXBlZEFyZy52YWx1ZSwgdHlwZWRBcmcudmVjTGVuKVxuICAvLyAgfSBlbHNlIHtcbiAgLy8gIGNvbnNvbGUubG9nKFwiaXMgQXJyYXlcIilcbiAgLy8gZmlsdGVyIG91dCB2YWx1ZXMgdGhhdCBhcmUgbm90IGEgbnVtYmVyXG4gIC8vIGNvbnN0IGZpbHRlcmVkQXJyYXkgPSB1c2VyQXJnc1tpbmRleF0uZmlsdGVyKCh2YWwpID0+IHR5cGVvZiB2YWwgPT09ICdudW1iZXInKVxuICAvLyB0eXBlZEFyZy52YWx1ZSA9IChjb250ZXh0LCBwcm9wcywgYmF0Y2hJZCkgPT4gYXJyYXlVdGlscy5nZXRWYWx1ZShmaWx0ZXJlZEFycmF5KShwcm9wcylcbiAgaWYgKHZlY0xlbikge1xuICAgIHJldHVybiAoY29udGV4dCwgcHJvcHMsIGJhdGNoSWQpID0+IHtcbiAgICAgIGNvbnN0IHZhbHVlcyA9IEFycmF5KHZlY0xlbik7XG4gICAgICBmb3IgKGxldCBpPTA7IGk8dmVjTGVuOyBpKyspIHtcbiAgICAgICAgY29uc3QgdiA9IHZhbHVlW2ldO1xuICAgICAgICBjb25zdCBkZWZhdWx0VmFsdWUgPSBpbnB1dC5kZWZhdWx0ID8gaW5wdXQuZGVmYXVsdC5jb25zdHJ1Y3RvciA9PT0gQXJyYXkgPyBpbnB1dC5kZWZhdWx0W2ldIDogaW5wdXQuZGVmYXVsdCA6IDA7XG4gICAgICAgIGlmICh0eXBlb2YgdiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHZhbHVlc1tpXSA9IGdldEZ1bmN0aW9uVmFsdWUodiwge2RlZmF1bHQ6IGRlZmF1bHRWYWx1ZX0pKGNvbnRleHQsIHByb3BzLCBiYXRjaElkKTtcbiAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHYpKSB7XG4gICAgICAgICAgdmFsdWVzW2ldID0gYXJyYXlVdGlscy5nZXRWYWx1ZSh2KShwcm9wcylcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgdiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICB2YWx1ZXNbaV0gPSB2O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHZhbHVlc1tpXSA9IGRlZmF1bHRWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICB9XG4gIH1cbiAgZWxzZSB7XG4gICAgcmV0dXJuIChjb250ZXh0LCBwcm9wcywgYmF0Y2hJZCkgPT4gYXJyYXlVdGlscy5nZXRWYWx1ZSh2YWx1ZSkocHJvcHMpXG4gIH1cbn0iLCJpbXBvcnQgZm9ybWF0QXJndW1lbnRzIGZyb20gJy4vZm9ybWF0LWFyZ3VtZW50cy5qcydcbmltcG9ydCB7dHlwZUxvb2t1cCwgZ2V0TG9va3VwLCBnZXRUeXBlTG9va3VwLCBjYXN0VHlwZX0gZnJvbSBcIi4vdHlwZXMuanNcIjtcblxuLy8gY29udmVydHMgYSB0cmVlIG9mIGphdmFzY3JpcHQgZnVuY3Rpb25zIHRvIGEgc2hhZGVyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihzb3VyY2UpIHtcbiAgcmV0dXJuIGdlbmVyYXRlUGFyYW1zKGNyZWF0ZVBhcmFtcygpLCBzb3VyY2UsIHNvdXJjZS50cmFuc2Zvcm1zKVxufVxuXG5mdW5jdGlvbiBjcmVhdGVQYXJhbXMob3B0aW9ucyA9IHt9KSB7XG4gIHJldHVybiBPYmplY3QuYXNzaWduKHtcbiAgICB1bmlmb3JtczogW10sIC8vIGxpc3Qgb2YgdW5pZm9ybXMgdXNlZCBpbiBzaGFkZXJcbiAgICBnbHNsRnVuY3Rpb25zOiBbXSwgLy8gbGlzdCBvZiBmdW5jdGlvbnMgdXNlZCBpbiBzaGFkZXJcbiAgICBmcmFnQ29sb3I6ICcnLFxuICAgIHBvc2l0aW9uOiAnJyxcbiAgfSwgb3B0aW9ucylcbn1cblxuZnVuY3Rpb24gZ2VuZXJhdGVQYXJhbXMoc2hhZGVyUGFyYW1zLCBzb3VyY2UsIHRyYW5zZm9ybXMpIHtcbiAgaWYgKCFzaGFkZXJQYXJhbXMuZnJhZ0NvbG9yKSB7XG4gICAgc2hhZGVyUGFyYW1zLmZyYWdDb2xvciA9IGdlbmVyYXRlR2xzbChzb3VyY2UsIHRyYW5zZm9ybXMsIHNoYWRlclBhcmFtcykoJ3N0JywgJ3ZlYzQnLCAxLjApXG4gIH1cbiAgaWYgKCFzaGFkZXJQYXJhbXMucG9zaXRpb24gJiYgIXNoYWRlclBhcmFtcy5jb21iaW5lKSB7XG4gICAgc2hhZGVyUGFyYW1zLnBvc2l0aW9uID0gZ2VuZXJhdGVHbHNsKHNvdXJjZSwgdHJhbnNmb3Jtcy5maWx0ZXIoKHRyKSA9PiB7XG4gICAgICByZXR1cm4gdHIudHJhbnNmb3JtLnR5cGUgIT09ICdjb21iaW5lJyAmJiB0ci50cmFuc2Zvcm0udHlwZSAhPT0gJ2NsZWFyJztcbiAgICB9KSwgc2hhZGVyUGFyYW1zKSgnc3QnLCAndmVjNCcsIDEuMCkgLy8gdG9kbzogc2hvdWxkIGJlIHZlYzNcbiAgfVxuICAvLyByZW1vdmUgdW5pZm9ybXMgd2l0aCBkdXBsaWNhdGUgbmFtZXNcbiAgaWYgKHNoYWRlclBhcmFtcy51bmlmb3Jtcykge1xuICAgIGxldCB1bmlmb3JtcyA9IHt9XG4gICAgc2hhZGVyUGFyYW1zLnVuaWZvcm1zLmZvckVhY2goKHVuaWZvcm0pID0+IHVuaWZvcm1zW3VuaWZvcm0ubmFtZV0gPSB1bmlmb3JtKVxuICAgIHNoYWRlclBhcmFtcy51bmlmb3JtcyA9IE9iamVjdC52YWx1ZXModW5pZm9ybXMpXG4gIH1cbiAgcmV0dXJuIHNoYWRlclBhcmFtc1xufVxuXG4vLyByZWN1cnNpdmUgZnVuY3Rpb24gZm9yIGdlbmVyYXRpbmcgc2hhZGVyIHN0cmluZyBmcm9tIG9iamVjdCBjb250YWluaW5nIGZ1bmN0aW9ucyBhbmQgdXNlciBhcmd1bWVudHMuIE9yZGVyIG9mIGZ1bmN0aW9ucyBpbiBzdHJpbmcgZGVwZW5kcyBvbiB0eXBlIG9mIGZ1bmN0aW9uXG4vLyB0byBkbzogaW1wcm92ZSB2YXJpYWJsZSBuYW1lc1xuZnVuY3Rpb24gZ2VuZXJhdGVHbHNsIChzb3VyY2UsIHRyYW5zZm9ybXMsIHNoYWRlclBhcmFtcykge1xuICAvLyB0cmFuc2Zvcm0gZnVuY3Rpb24gdGhhdCBvdXRwdXRzIGEgc2hhZGVyIHN0cmluZyBjb3JyZXNwb25kaW5nIHRvIGdsX0ZyYWdDb2xvclxuICBjb25zdCBlbXB0eSA9ICgpID0+ICcnO1xuICB2YXIgZnJhZ0NvbG9yID0gZW1wdHlcbiAgdHJhbnNmb3Jtcy5tYXAoKHRyYW5zZm9ybSwgaSkgPT4ge1xuICAgIGlmICh0cmFuc2Zvcm0udHJhbnNmb3JtLnR5cGUgPT09ICdnbHNsJykge1xuICAgICAgZnJhZ0NvbG9yID0gKCkgPT4gdHJhbnNmb3JtLnVzZXJBcmdzWzBdO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodHJhbnNmb3JtLnRyYW5zZm9ybS50eXBlID09PSAndmVydCcgJiYgIXNvdXJjZS5nZW9tZXRyeSkge1xuICAgICAgc291cmNlLnNldEdlb21ldHJ5KHRyYW5zZm9ybS51c2VyQXJnc1swXSk7XG4gICAgICB0cmFuc2Zvcm0udXNlckFyZ3MgPSB0cmFuc2Zvcm0udXNlckFyZ3Muc2xpY2UoMSk7XG4gICAgfVxuICAgIHZhciBpbnB1dHMgPSBmb3JtYXRBcmd1bWVudHModHJhbnNmb3JtLCBzaGFkZXJQYXJhbXMudW5pZm9ybXMubGVuZ3RoKVxuICAgIGlmICh0cmFuc2Zvcm0udHJhbnNmb3JtLnR5cGUgPT09ICdjbGVhcicpIHtcbiAgICAgIHNvdXJjZS5wYXNzZXMudW5zaGlmdCh7Y2xlYXI6IHRyYW5zZm9ybS50cmFuc2Zvcm0ubmFtZSwgdXNlckFyZ3M6IGlucHV0cy5tYXAoKGkpID0+IGkudmFsdWUpfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaW5wdXRzLmZvckVhY2goKGlucHV0KSA9PiB7XG4gICAgICBpZihpbnB1dC5pc1VuaWZvcm0pIHNoYWRlclBhcmFtcy51bmlmb3Jtcy5wdXNoKGlucHV0KVxuICAgIH0pXG5cbiAgICAvLyBhZGQgbmV3IGdsc2wgZnVuY3Rpb24gdG8gcnVubmluZyBsaXN0IG9mIGZ1bmN0aW9uc1xuICAgIGlmKCFjb250YWlucyh0cmFuc2Zvcm0sIHNoYWRlclBhcmFtcy5nbHNsRnVuY3Rpb25zKSkgc2hhZGVyUGFyYW1zLmdsc2xGdW5jdGlvbnMucHVzaCh0cmFuc2Zvcm0pXG5cbiAgICAvLyBjdXJyZW50IGZ1bmN0aW9uIGZvciBnZW5lcmF0aW5nIGZyYWcgY29sb3Igc2hhZGVyIGNvZGVcbiAgICB2YXIgZjAgPSBmcmFnQ29sb3JcbiAgICBpZiAodHJhbnNmb3JtLnRyYW5zZm9ybS50eXBlID09PSAnc3JjJyB8fCB0cmFuc2Zvcm0udHJhbnNmb3JtLnR5cGUgPT09ICd2ZXJ0Jykge1xuICAgICAgZnJhZ0NvbG9yID0gKHV2LCByZXR1cm5UeXBlLCBhbHBoYSkgPT4gYCR7c2hhZGVyU3RyaW5nKHV2LCB0cmFuc2Zvcm0sIGlucHV0cywgc2hhZGVyUGFyYW1zLCByZXR1cm5UeXBlLCBhbHBoYSl9YFxuICAgIH0gZWxzZSBpZiAodHJhbnNmb3JtLnRyYW5zZm9ybS50eXBlID09PSAnY29vcmQnKSB7XG4gICAgICBmcmFnQ29sb3IgPSBmMCA9PT0gZW1wdHlcbiAgICAgICAgPyAodXYsIHJldHVyblR5cGUsIGFscGhhKSA9PiBgJHtzaGFkZXJTdHJpbmcodXYsIHRyYW5zZm9ybSwgaW5wdXRzLCBzaGFkZXJQYXJhbXMsIHJldHVyblR5cGUsIGFscGhhKX1gXG4gICAgICAgIDogKHV2LCByZXR1cm5UeXBlLCBhbHBoYSkgPT4gYCR7ZjAoYCR7c2hhZGVyU3RyaW5nKHV2LCB0cmFuc2Zvcm0sIGlucHV0cywgc2hhZGVyUGFyYW1zLCAndmVjMicpfWAsIHJldHVyblR5cGUsIGFscGhhKX1gXG4gICAgfSBlbHNlIGlmICh0cmFuc2Zvcm0udHJhbnNmb3JtLnR5cGUgPT09ICdjb2xvcicpIHtcbiAgICAgIGZyYWdDb2xvciA9ICh1diwgcmV0dXJuVHlwZSwgYWxwaGEpID0+ICBgJHtzaGFkZXJTdHJpbmcoYCR7ZjAodXYsICd2ZWM0Jyl9YCwgdHJhbnNmb3JtLCBpbnB1dHMsIHNoYWRlclBhcmFtcywgcmV0dXJuVHlwZSwgYWxwaGEpfWBcbiAgICB9IGVsc2UgaWYgKHRyYW5zZm9ybS50cmFuc2Zvcm0udHlwZSA9PT0gJ2NvbWJpbmUnKSB7XG4gICAgICAvLyBjb21iaW5pbmcgdHdvIGdlbmVyYXRlZCBzaGFkZXIgc3RyaW5ncyAoaS5lLiBmb3IgYmxlbmQsIG11bHQsIGFkZCBmdW50aW9ucylcbiAgICAgIGlmIChzb3VyY2UudHJhbnNmb3Jtc1swXS50cmFuc2Zvcm0udmVydCB8fCAoaW5wdXRzWzBdLnZhbHVlICYmIGlucHV0c1swXS52YWx1ZS50cmFuc2Zvcm1zICYmIGlucHV0c1swXS52YWx1ZS50cmFuc2Zvcm1zWzBdLnRyYW5zZm9ybS52ZXJ0KSkge1xuICAgICAgICBjb25zdCBwYXJhbXMgPSBPYmplY3QuYXNzaWduKHt9LCBzaGFkZXJQYXJhbXMsIHtcbiAgICAgICAgICBmcmFnQ29sb3I6IGZyYWdDb2xvcignc3QnLCAndmVjNCcsIDEuMCkgfHwgJ3ZlYzQoMCknLFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihzaGFkZXJQYXJhbXMsIGNyZWF0ZVBhcmFtcyh7XG4gICAgICAgICAgZ2xzbEZ1bmN0aW9uczogW3RyYW5zZm9ybV0sXG4gICAgICAgICAgY29tYmluZTogdHJ1ZSxcbiAgICAgICAgfSkpO1xuICAgICAgICBjb25zdCB0cmFucyA9IHNvdXJjZS50cmFuc2Zvcm1zLnNsaWNlKDAsIHNvdXJjZS50cmFuc2Zvcm1zLmluZGV4T2YodHJhbnNmb3JtKSk7XG4gICAgICAgIHNvdXJjZS5wYXNzZXMudW5zaGlmdChzb3VyY2UuY3JlYXRlUGFzcyhnZW5lcmF0ZVBhcmFtcyhwYXJhbXMsIHNvdXJjZSwgdHJhbnMpLCB7ZnJhbWVidWZmZXI6IHNvdXJjZS5vdXRwdXQudGVtcFswXX0pKTtcbiAgICAgICAgY29uc3QgdGVtcDAgPSBzcmMoc291cmNlLm91dHB1dC50ZW1wWzBdKTtcbiAgICAgICAgZjAgPSAodXYsIHJldHVyblR5cGUsIGFscGhhKSA9PiBgJHtnZW5lcmF0ZUdsc2wodGVtcDAsIHRlbXAwLnRyYW5zZm9ybXMsIHNoYWRlclBhcmFtcykodXYsIHJldHVyblR5cGUsIGFscGhhKX1gXG4gICAgICB9XG4gICAgICB2YXIgZjE7XG4gICAgICBpZiAoaW5wdXRzWzBdLnZhbHVlICYmIGlucHV0c1swXS52YWx1ZS50cmFuc2Zvcm1zKSB7XG4gICAgICAgIGlmIChpbnB1dHNbMF0udmFsdWUudHJhbnNmb3Jtc1swXS50cmFuc2Zvcm0udmVydCB8fCBzb3VyY2UudHJhbnNmb3Jtc1swXS50cmFuc2Zvcm0udmVydCkge1xuICAgICAgICAgIGlucHV0c1swXS52YWx1ZS5vdXRwdXQgPSBzb3VyY2Uub3V0cHV0O1xuICAgICAgICAgIHNvdXJjZS5wYXNzZXMudW5zaGlmdCguLi5pbnB1dHNbMF0udmFsdWUuY29tcGlsZSh7ZnJhbWVidWZmZXI6IHNvdXJjZS5vdXRwdXQudGVtcFsxXX0pKTtcbiAgICAgICAgICBjb25zdCB0ZW1wMSA9IHNyYyhzb3VyY2Uub3V0cHV0LnRlbXBbMV0pO1xuICAgICAgICAgIGYxID0gKHV2LCByZXR1cm5UeXBlLCBhbHBoYSkgPT4gYCR7Z2VuZXJhdGVHbHNsKHRlbXAxLCB0ZW1wMS50cmFuc2Zvcm1zLCBzaGFkZXJQYXJhbXMpKHV2LCByZXR1cm5UeXBlLCBhbHBoYSl9YFxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGYxID0gKHV2LCByZXR1cm5UeXBlLCBhbHBoYSkgPT4gYCR7Z2VuZXJhdGVHbHNsKGlucHV0c1swXS52YWx1ZSwgaW5wdXRzWzBdLnZhbHVlLnRyYW5zZm9ybXMsIHNoYWRlclBhcmFtcykodXYsIHJldHVyblR5cGUsIGFscGhhKX1gXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBmMSA9IChpbnB1dHNbMF0uaXNVbmlmb3JtID8gKCkgPT4gaW5wdXRzWzBdLm5hbWUgOiAoKSA9PiBpbnB1dHNbMF0udmFsdWUpXG4gICAgICB9XG4gICAgICBmcmFnQ29sb3IgPSAodXYsIHJldHVyblR5cGUsIGFscGhhKSA9PiBgJHtzaGFkZXJTdHJpbmcoYCR7ZjAodXYsICd2ZWM0Jyl9LCAke2YxKHV2LCAndmVjNCcpfWAsIHRyYW5zZm9ybSwgaW5wdXRzLnNsaWNlKDEpLCBzaGFkZXJQYXJhbXMsIHJldHVyblR5cGUsIGFscGhhKX1gXG4gICAgfSBlbHNlIGlmICh0cmFuc2Zvcm0udHJhbnNmb3JtLnR5cGUgPT09ICdjb21iaW5lQ29vcmQnKSB7XG4gICAgICAvLyBjb21iaW5pbmcgdHdvIGdlbmVyYXRlZCBzaGFkZXIgc3RyaW5ncyAoaS5lLiBmb3IgbW9kdWxhdGUgZnVuY3Rpb25zKVxuICAgICAgdmFyIGYxID0gaW5wdXRzWzBdLnZhbHVlICYmIGlucHV0c1swXS52YWx1ZS50cmFuc2Zvcm1zXG4gICAgICAgICAgPyAodXYsIHJldHVyblR5cGUsIGFscGhhKSA9PiBgJHtnZW5lcmF0ZUdsc2woaW5wdXRzWzBdLnZhbHVlLCBpbnB1dHNbMF0udmFsdWUudHJhbnNmb3Jtcywgc2hhZGVyUGFyYW1zKSh1diwgcmV0dXJuVHlwZSwgYWxwaGEpfWBcbiAgICAgICAgICA6IChpbnB1dHNbMF0uaXNVbmlmb3JtID8gKCkgPT4gaW5wdXRzWzBdLm5hbWUgOiAoKSA9PiBpbnB1dHNbMF0udmFsdWUpXG4gICAgICBmcmFnQ29sb3IgPSAodXYsIHJldHVyblR5cGUsIGFscGhhKSA9PiBgJHtmMChgJHtzaGFkZXJTdHJpbmcoYCR7dXZ9LCAke2YxKHV2LCAndmVjNCcpfWAsIHRyYW5zZm9ybSwgaW5wdXRzLnNsaWNlKDEpLCBzaGFkZXJQYXJhbXMsICd2ZWMyJyl9YCwgcmV0dXJuVHlwZSwgYWxwaGEpfWBcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBjb25zb2xlLndhcm4oJ25vIHN1cHBvcnQgZm9yIHR5cGU6ICcgKyB0cmFuc2Zvcm0udHJhbnNmb3JtLnR5cGUpXG4gICAgfVxuICB9KVxuICBpZiAoc291cmNlLmdldHRlcikge1xuICAgIHZhciBmMiA9IGZyYWdDb2xvclxuICAgIGZyYWdDb2xvciA9ICh1diwgcmV0dXJuVHlwZSwgYWxwaGEpID0+IGNhc3RUeXBlKGYyKHV2LCByZXR1cm5UeXBlLCBhbHBoYSkgKyBgLiR7c291cmNlLmdldHRlcn1gLCBnZXRUeXBlTG9va3VwW3NvdXJjZS5nZXR0ZXJdLCByZXR1cm5UeXBlLCAxLjApXG4gIH1cbiAgcmV0dXJuIGZyYWdDb2xvclxufVxuXG4vLyBhc3NlbWJsZXMgYSBzaGFkZXIgc3RyaW5nIGNvbnRhaW5pbmcgdGhlIGFyZ3VtZW50cyBhbmQgdGhlIGZ1bmN0aW9uIG5hbWUsIGkuZS4gJ29zYyh1diwgZnJlcXVlbmN5KSdcbmZ1bmN0aW9uIHNoYWRlclN0cmluZyAodXYsIHRyYW5zZm9ybSwgaW5wdXRzLCBzaGFkZXJQYXJhbXMsIHJldHVyblR5cGUsIGFscGhhID0gMC4wKSB7XG4gIGNvbnN0IHN0ciA9IGlucHV0cy5tYXAoKGlucHV0KSA9PiB7XG4gICAgaWYgKGlucHV0LmlzVW5pZm9ybSkge1xuICAgICAgcmV0dXJuIGlucHV0Lm5hbWVcbiAgICB9IGVsc2UgaWYgKGlucHV0LnZhbHVlICYmIGlucHV0LnZhbHVlLnRyYW5zZm9ybXMpIHtcbiAgICAgIC8vIHRoaXMgYnkgZGVmaW5pdGlvbiBuZWVkcyB0byBiZSBhIGdlbmVyYXRvciwgaGVuY2Ugd2Ugc3RhcnQgd2l0aCAnc3QnIGFzIHRoZSBpbml0aWFsIHZhbHVlIGZvciBnZW5lcmF0aW5nIHRoZSBnbHNsIGZyYWdtZW50XG4gICAgICBpZiAoIWlucHV0LnZhbHVlLmdldHRlciAmJiB0eXBlTG9va3VwW2lucHV0LnZhbHVlLnRyYW5zZm9ybXNbMF0udHJhbnNmb3JtLnR5cGVdICE9PSBpbnB1dC50eXBlKSB7XG4gICAgICAgIC8vIHRvZG86IGFkZCBnZXR0ZXIgb25seSBpZiBpbnB1dC50eXBlIGlzIGxhcmdlclxuICAgICAgICBpbnB1dC52YWx1ZS5nZXR0ZXIgPSBnZXRMb29rdXBbaW5wdXQudHlwZV07XG4gICAgICB9XG4gICAgICByZXR1cm4gYCR7Z2VuZXJhdGVHbHNsKGlucHV0LnZhbHVlLCBpbnB1dC52YWx1ZS50cmFuc2Zvcm1zLCBzaGFkZXJQYXJhbXMpKCdzdCcsIGlucHV0LnR5cGUpfWBcbiAgICB9XG4gICAgcmV0dXJuIGlucHV0LnZhbHVlXG4gIH0pLnJlZHVjZSgocCwgYykgPT4gYCR7cH0sICR7Y31gLCAnJylcblxuICB2YXIgZnVuYyA9IGAke3RyYW5zZm9ybS50cmFuc2Zvcm0uZ2xzbE5hbWV9KCR7dXZ9JHtzdHJ9KWBcbiAgcmV0dXJuIGNhc3RUeXBlKGZ1bmMsIHR5cGVMb29rdXBbdHJhbnNmb3JtLnRyYW5zZm9ybS50eXBlXS5yZXR1cm5UeXBlLCByZXR1cm5UeXBlLCBhbHBoYSk7XG59XG5cbi8vIGNoZWNrIHdoZXRoZXIgYXJyYXlcbmZ1bmN0aW9uIGNvbnRhaW5zKG9iamVjdCwgYXJyKSB7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspe1xuICAgIGlmKG9iamVjdC5uYW1lID09IGFycltpXS5uYW1lKSByZXR1cm4gdHJ1ZVxuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG5cblxuIiwiaW1wb3J0IEdsc2xTb3VyY2UgZnJvbSAnLi9nbHNsLXNvdXJjZS5qcydcbmltcG9ydCBnbHNsRnVuY3Rpb25zIGZyb20gJy4vZ2xzbC9nbHNsLWZ1bmN0aW9ucy5qcydcbmltcG9ydCB2ZXJ0RnVuY3Rpb25zIGZyb20gJy4vZ2xzbC92ZXJ0LWZ1bmN0aW9ucy5qcydcbmltcG9ydCB7dHlwZUxvb2t1cH0gZnJvbSBcIi4vdHlwZXMuanNcIjtcblxuY2xhc3MgR2VuZXJhdG9yRmFjdG9yeSB7XG4gIGNvbnN0cnVjdG9yICh7XG4gICAgICBkZWZhdWx0VW5pZm9ybXMsXG4gICAgICBkZWZhdWx0T3V0cHV0LFxuICAgICAgZXh0ZW5kVHJhbnNmb3JtcyA9IFtdLFxuICAgICAgY2hhbmdlTGlzdGVuZXIgPSAoKCkgPT4ge30pXG4gICAgfSA9IHt9XG4gICAgKSB7XG4gICAgdGhpcy5kZWZhdWx0T3V0cHV0ID0gZGVmYXVsdE91dHB1dFxuICAgIHRoaXMuZGVmYXVsdFVuaWZvcm1zID0gZGVmYXVsdFVuaWZvcm1zXG4gICAgdGhpcy5jaGFuZ2VMaXN0ZW5lciA9IGNoYW5nZUxpc3RlbmVyXG4gICAgdGhpcy5leHRlbmRUcmFuc2Zvcm1zID0gZXh0ZW5kVHJhbnNmb3Jtc1xuICAgIHRoaXMuZ2VuZXJhdG9ycyA9IHt9XG4gICAgdGhpcy51dGlscyA9IHt9XG4gICAgdGhpcy5pbml0KClcbiAgfVxuICBpbml0ICgpIHtcbiAgICBjb25zdCBmdW5jdGlvbnMgPSBnbHNsRnVuY3Rpb25zKClcbiAgICB0aGlzLmdsc2xUcmFuc2Zvcm1zID0ge31cbiAgICB0aGlzLmdlbmVyYXRvcnMgPSBPYmplY3QuZW50cmllcyh0aGlzLmdlbmVyYXRvcnMpLnJlZHVjZSgocHJldiwgW21ldGhvZCwgdHJhbnNmb3JtXSkgPT4ge1xuICAgICAgdGhpcy5jaGFuZ2VMaXN0ZW5lcih7dHlwZTogJ3JlbW92ZScsIHN5bnRoOiB0aGlzLCBtZXRob2R9KVxuICAgICAgcmV0dXJuIHByZXZcbiAgICB9LCB7fSlcblxuICAgIHRoaXMuc291cmNlQ2xhc3MgPSAoKCkgPT4ge1xuICAgICAgcmV0dXJuIGNsYXNzIGV4dGVuZHMgR2xzbFNvdXJjZSB7XG4gICAgICB9XG4gICAgfSkoKVxuXG4gICAgLy8gYWRkIHVzZXIgZGVmaW5pZWQgdHJhbnNmb3Jtc1xuICAgIGlmIChBcnJheS5pc0FycmF5KHRoaXMuZXh0ZW5kVHJhbnNmb3JtcykpIHtcbiAgICAgIGZ1bmN0aW9ucy5jb25jYXQodGhpcy5leHRlbmRUcmFuc2Zvcm1zKVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIHRoaXMuZXh0ZW5kVHJhbnNmb3JtcyA9PT0gJ29iamVjdCcgJiYgdGhpcy5leHRlbmRUcmFuc2Zvcm1zLnR5cGUpIHtcbiAgICAgIGZ1bmN0aW9ucy5wdXNoKHRoaXMuZXh0ZW5kVHJhbnNmb3JtcylcbiAgICB9XG5cbiAgICBmdW5jdGlvbnMubWFwKCh0cmFuc2Zvcm0pID0+IHRoaXMuc2V0RnVuY3Rpb24odHJhbnNmb3JtKSlcblxuICAgIGNvbnN0IGZ1bmN0aW9uczIgPSB2ZXJ0RnVuY3Rpb25zKHRoaXMuZ2VuZXJhdG9ycyk7IC8vIHNhbmRib3ggaXMgbm90IHJlYWR5IGF0IHRoaXMgbW9tZW50IHlldFxuICAgIGZ1bmN0aW9uczIubWFwKCh0cmFuc2Zvcm0pID0+IHRoaXMuc2V0RnVuY3Rpb24odHJhbnNmb3JtKSlcbiB9XG5cbiBfYWRkTWV0aG9kIChtZXRob2QsIHRyYW5zZm9ybSkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzXG4gICAgdGhpcy5nbHNsVHJhbnNmb3Jtc1ttZXRob2RdID0gdHJhbnNmb3JtXG4gICAgbGV0IHJldHZhbCA9IHVuZGVmaW5lZFxuICAgIGlmIChbJ3NyYycsICdjb29yZCcsICdjbGVhcicsICd2ZXJ0JywgJ2dsc2wnXS5pbmRleE9mKHRyYW5zZm9ybS50eXBlKSA+IC0xKSB7XG4gICAgICBjb25zdCBmdW5jID0gKC4uLmFyZ3MpID0+IG5ldyB0aGlzLnNvdXJjZUNsYXNzKHtcbiAgICAgICAgbmFtZTogbWV0aG9kLFxuICAgICAgICB0cmFuc2Zvcm06IHRyYW5zZm9ybSxcbiAgICAgICAgdXNlckFyZ3M6IGFyZ3MsXG4gICAgICAgIGRlZmF1bHRPdXRwdXQ6IHRoaXMuZGVmYXVsdE91dHB1dCxcbiAgICAgICAgZGVmYXVsdFVuaWZvcm1zOiB0aGlzLmRlZmF1bHRVbmlmb3JtcyxcbiAgICAgICAgc3ludGg6IHNlbGYsXG4gICAgICAgIHV0aWxzOiB0aGlzLnV0aWxzLFxuICAgICAgfSlcbiAgICAgIHRoaXMuZ2VuZXJhdG9yc1ttZXRob2RdID0gZnVuY1xuICAgICAgdGhpcy5jaGFuZ2VMaXN0ZW5lcih7dHlwZTogJ2FkZCcsIHN5bnRoOiB0aGlzLCBtZXRob2R9KVxuICAgICAgcmV0dmFsID0gZnVuY1xuICAgIH1cbiAgICB0aGlzLnNvdXJjZUNsYXNzLnByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgIGNvbnN0IHByZXZUcmFuc2Zvcm0gPSB0aGlzLnRyYW5zZm9ybXNbdGhpcy50cmFuc2Zvcm1zLmxlbmd0aC0xXS50cmFuc2Zvcm07XG4gICAgICBpZiAocHJldlRyYW5zZm9ybS50eXBlID09PSAnY2xlYXInIHx8ICh0cmFuc2Zvcm0udHlwZSAhPT0gJ3NyYycgJiYgdHJhbnNmb3JtLnR5cGUgIT09ICd2ZXJ0JykpIHtcbiAgICAgICAgdGhpcy50cmFuc2Zvcm1zLnB1c2goe25hbWU6IG1ldGhvZCwgdHJhbnNmb3JtOiB0cmFuc2Zvcm0sIHVzZXJBcmdzOiBhcmdzLCBzeW50aDogc2VsZn0pXG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihgdHJhbnNmb3JtICR7dHJhbnNmb3JtLm5hbWV9IG5vdCBhbGxvd2VkIGFmdGVyICR7cHJldlRyYW5zZm9ybS5uYW1lfWApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG4gICAgcmV0dXJuIHJldHZhbFxuICB9XG5cbiAgc2V0RnVuY3Rpb24ob2JqKSB7XG4gICAgLy8gdG9kbzogcmVtb3ZlIHV0aWxzIGFuZCBpbnN0ZWFkIG1hbmFnZSBmdW5jdGlvbiBkZXBlbmRlbmNpZXNcbiAgICBpZiAob2JqLnR5cGUgPT09ICd1dGlsJykgdGhpcy51dGlsc1tvYmoubmFtZV0gPSBvYmo7XG4gICAgdmFyIHByb2Nlc3NlZEdsc2wgPSBwcm9jZXNzRnVuY3Rpb24ob2JqKVxuICAgIGlmKHByb2Nlc3NlZEdsc2wpIHRoaXMuX2FkZE1ldGhvZChvYmoubmFtZSwgcHJvY2Vzc2VkR2xzbClcbiAgfVxufVxuXG4vLyBleHBlY3RzIGdsc2wgb2YgZm9ybWF0XG4vLyB7XG4vLyAgIG5hbWU6ICdvc2MnLCAvLyBuYW1lIHRoYXQgd2lsbCBiZSB1c2VkIHRvIGFjY2VzcyBmdW5jdGlvbiBhcyB3ZWxsIGFzIHdpdGhpbiBnbHNsXG4vLyAgIHR5cGU6ICdzcmMnLCAvLyBjYW4gYmUgc3JjOiB2ZWM0KHZlYzIgX3N0KSwgY29vcmQ6IHZlYzIodmVjMiBfc3QpLCBjb2xvcjogdmVjNCh2ZWM0IF9jMCksIGNvbWJpbmU6IHZlYzQodmVjNCBfYzAsIHZlYzQgX2MxKSwgY29tYmluZUNvb3JkOiB2ZWMyKHZlYzIgX3N0LCB2ZWM0IF9jMClcbi8vICAgaW5wdXRzOiBbXG4vLyAgICAge1xuLy8gICAgICAgbmFtZTogJ2ZyZXEnLFxuLy8gICAgICAgdHlwZTogJ2Zsb2F0JywgLy8gJ2Zsb2F0JyAgIC8vLCAndGV4dHVyZScsICd2ZWM0J1xuLy8gICAgICAgZGVmYXVsdDogMC4yXG4vLyAgICAgfSxcbi8vICAgICB7XG4vLyAgICAgICAgICAgbmFtZTogJ3N5bmMnLFxuLy8gICAgICAgICAgIHR5cGU6ICdmbG9hdCcsXG4vLyAgICAgICAgICAgZGVmYXVsdDogMC4xXG4vLyAgICAgICAgIH0sXG4vLyAgICAgICAgIHtcbi8vICAgICAgICAgICBuYW1lOiAnb2Zmc2V0Jyxcbi8vICAgICAgICAgICB0eXBlOiAnZmxvYXQnLFxuLy8gICAgICAgICAgIGRlZmF1bHQ6IDAuMFxuLy8gICAgICAgICB9XG4vLyAgIF0sXG4gICAvLyAgZ2xzbDogYFxuICAgLy8gICAgdmVjMiBzdCA9IF9zdDtcbiAgIC8vICAgIGZsb2F0IHIgPSBzaW4oKHN0Lngtb2Zmc2V0KjIvZnJlcSt0aW1lKnN5bmMpKmZyZXEpKjAuNSAgKyAwLjU7XG4gICAvLyAgICBmbG9hdCBnID0gc2luKChzdC54K3RpbWUqc3luYykqZnJlcSkqMC41ICsgMC41O1xuICAgLy8gICAgZmxvYXQgYiA9IHNpbigoc3QueCtvZmZzZXQvZnJlcSt0aW1lKnN5bmMpKmZyZXEpKjAuNSAgKyAwLjU7XG4gICAvLyAgICByZXR1cm4gdmVjNChyLCBnLCBiLCAxLjApO1xuICAgLy8gYFxuLy8gfVxuXG4vLyAvLyBnZW5lcmF0ZXMgZ2xzbCBmdW5jdGlvbjpcbi8vIGB2ZWM0IG9zYyh2ZWMyIF9zdCwgZmxvYXQgZnJlcSwgZmxvYXQgc3luYywgZmxvYXQgb2Zmc2V0KXtcbi8vICB2ZWMyIHN0ID0gX3N0O1xuLy8gIGZsb2F0IHIgPSBzaW4oKHN0Lngtb2Zmc2V0KjIvZnJlcSt0aW1lKnN5bmMpKmZyZXEpKjAuNSAgKyAwLjU7XG4vLyAgZmxvYXQgZyA9IHNpbigoc3QueCt0aW1lKnN5bmMpKmZyZXEpKjAuNSArIDAuNTtcbi8vICBmbG9hdCBiID0gc2luKChzdC54K29mZnNldC9mcmVxK3RpbWUqc3luYykqZnJlcSkqMC41ICArIDAuNTtcbi8vICByZXR1cm4gdmVjNChyLCBnLCBiLCAxLjApO1xuLy8gfWBcblxuZnVuY3Rpb24gcHJvY2Vzc0Z1bmN0aW9uKG9iaikge1xuICBvYmouZ2xzbE5hbWUgfHwgKG9iai5nbHNsTmFtZSA9IG9iai5uYW1lKTtcbiAgaWYgKG9iai50eXBlID09PSAnY2xlYXInIHx8IG9iai50eXBlID09PSAnZ2xzbCcpIHJldHVybiBvYmo7XG4gIGVsc2UgaWYgKG9iai50eXBlID09PSAndXRpbCcpIHtcbiAgICByZXR1cm4gcHJvY2Vzc0dsc2wob2JqLCBvYmoucmV0dXJuVHlwZSk7XG4gIH1cbiAgbGV0IHQgPSB0eXBlTG9va3VwW29iai50eXBlXVxuICBpZih0KSB7XG4gICAgcmV0dXJuIHByb2Nlc3NHbHNsKG9iaiwgdC5yZXR1cm5UeXBlLCB0LmFyZ3MpO1xuICB9IGVsc2Uge1xuICAgIGNvbnNvbGUud2FybihgdHlwZSAke29iai50eXBlfSBub3QgcmVjb2duaXplZGAsIG9iailcbiAgfVxuXG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NHbHNsKG9iaiwgcmV0dXJuVHlwZSwgYXJncyA9IFtdKSB7XG4gICAgbGV0IGJhc2VBcmdzID0gYXJncy5tYXAoKGFyZykgPT4gYXJnKS5qb2luKFwiLCBcIilcbiAgICBsZXQgY3VzdG9tQXJncyA9IChvYmouaW5wdXRzIHx8IChvYmouaW5wdXRzID0gW10pKS5tYXAoKGlucHV0KSA9PiBgJHtpbnB1dC50eXBlfSAke2lucHV0Lm5hbWV9YCkuam9pbignLCAnKVxuICAgIGxldCBhbGxBcmdzID0gYCR7YmFzZUFyZ3N9JHtjdXN0b21BcmdzLmxlbmd0aCA+IDAgPyAnLCAnKyBjdXN0b21BcmdzOiAnJ31gXG5cbiAgICBjb25zdCBmdW5jID0gYCR7cmV0dXJuVHlwZSB8fCAnJ30gJHtvYmouZ2xzbE5hbWV9KCR7YWxsQXJnc31gO1xuICAgIGNvbnN0IGZpeE9yV3JhcCA9IChnbHNsKSA9PiB7XG4gICAgICAgIGlmIChnbHNsLmluZGV4T2YoZnVuYykgPT09IC0xKSB7XG4gICAgICAgICAgICBpZiAoZ2xzbC5pbmRleE9mKGAke3JldHVyblR5cGV9IG1haW4oJHthbGxBcmdzfWApID4gLTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2xzbC5yZXBsYWNlKGAke3JldHVyblR5cGV9IG1haW4oJHthbGxBcmdzfWAsIGZ1bmMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKG9iai5wcmltaXRpdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHByaW1pdGl2ZUZuID0gb2JqLnByaW1pdGl2ZS5zcGxpdChcIiBcIikuam9pbihcIlwiKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGdsc2wuaW5kZXhPZihwcmltaXRpdmVGbikgPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdsc2wucmVwbGFjZShgJHtyZXR1cm5UeXBlfSAke3ByaW1pdGl2ZUZufSgke2FsbEFyZ3N9YCwgZnVuYyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJldHVyblR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGBcbiAgJHtmdW5jfSkge1xuICAgICAgJHtnbHNsfVxuICB9XG5gXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBnbHNsO1xuICAgIH1cbiAgICBvYmouZ2xzbCA9IGZpeE9yV3JhcChvYmouZ2xzbCk7XG4gICAgaWYgKG9iai52ZXJ0KSB7XG4gICAgICAgIG9iai52ZXJ0ID0gZml4T3JXcmFwKG9iai52ZXJ0KTtcbiAgICB9XG5cbiAgICAvLyBhZGQgZXh0cmEgaW5wdXQgdG8gYmVnaW5uaW5nIGZvciBiYWNrd2FyZCBjb21iYXRpYmlsaXR5IEB0b2RvIHVwZGF0ZSBjb21waWxlciBzbyB0aGlzIGlzIG5vIGxvbmdlciBuZWNlc3NhcnlcbiAgICBpZihvYmoudHlwZSA9PT0gJ2NvbWJpbmUnIHx8IG9iai50eXBlID09PSAnY29tYmluZUNvb3JkJykgb2JqLmlucHV0cy51bnNoaWZ0KHtcbiAgICAgICAgbmFtZTogJ2NvbG9yJyxcbiAgICAgICAgdHlwZTogJ3ZlYzQnXG4gICAgfSlcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgb2JqLCB7IHJldHVyblR5cGUgfSlcbn1cblxuZXhwb3J0IGRlZmF1bHQgR2VuZXJhdG9yRmFjdG9yeVxuIiwiaW1wb3J0IGdlbmVyYXRlR2xzbCBmcm9tICcuL2dlbmVyYXRlLWdsc2wuanMnXG5pbXBvcnQgdXRpbGl0eUdsc2wgZnJvbSAnLi9nbHNsL3V0aWxpdHktZnVuY3Rpb25zLmpzJ1xuaW1wb3J0IHZlY3Rvcml6ZVRleHQgZnJvbSAndmVjdG9yaXplLXRleHQnO1xuXG52YXIgR2xzbFNvdXJjZSA9IGZ1bmN0aW9uIChvYmopIHtcbiAgdGhpcy50cmFuc2Zvcm1zID0gW11cbiAgdGhpcy50cmFuc2Zvcm1zLnB1c2gob2JqKVxuICB0aGlzLmRlZmF1bHRPdXRwdXQgPSBvYmouZGVmYXVsdE91dHB1dFxuICB0aGlzLm91dHB1dCA9IG51bGxcbiAgdGhpcy5zeW50aCA9IG9iai5zeW50aFxuICB0aGlzLnR5cGUgPSAnR2xzbFNvdXJjZSdcbiAgdGhpcy5kZWZhdWx0VW5pZm9ybXMgPSBvYmouZGVmYXVsdFVuaWZvcm1zXG4gIHRoaXMudXRpbHMgPSBPYmplY3QuYXNzaWduKHt9LCB1dGlsaXR5R2xzbCwgb2JqLnV0aWxzKTtcbiAgdGhpcy5ibGVuZE1vZGUgPSB0eXBlb2Yob2JqLnRyYW5zZm9ybS5ibGVuZE1vZGUpICE9PSAndW5kZWZpbmVkJyA/IG9iai50cmFuc2Zvcm0uYmxlbmRNb2RlIDogZmFsc2U7XG4gIHRoaXMubGluZVdpZHRoID0gb2JqLnRyYW5zZm9ybS5saW5lV2lkdGggfHwgMTtcbiAgdGhpcy5fdmlld3BvcnQgPSB7fTtcbiAgcmV0dXJuIHRoaXNcbn1cblxuR2xzbFNvdXJjZS5wcm90b3R5cGUuYWRkVHJhbnNmb3JtID0gZnVuY3Rpb24gKG9iaikgIHtcbiAgdGhpcy50cmFuc2Zvcm1zLnB1c2gob2JqKVxufVxuXG5HbHNsU291cmNlLnByb3RvdHlwZS5vdXQgPSBmdW5jdGlvbiAoX291dHB1dCkge1xuICB2YXIgb3V0cHV0ID0gX291dHB1dCB8fCB0aGlzLmRlZmF1bHRPdXRwdXRcbiAgdGhpcy5vdXRwdXQgPSBvdXRwdXQ7XG4gIHZhciBnbHNsID0gdGhpcy5jb21waWxlKClcbiAgdGhpcy5zeW50aC5jdXJyZW50RnVuY3Rpb25zID0gW11cbiAgaWYob3V0cHV0KSB0cnl7XG4gICAgb3V0cHV0LnJlbmRlcihnbHNsKVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUubG9nKCdzaGFkZXIgY291bGQgbm90IGNvbXBpbGUnLCBlcnJvcilcbiAgfVxuICByZXR1cm4gdGhpcztcbn1cblxuR2xzbFNvdXJjZS5wcm90b3R5cGUudGV4ID0gZnVuY3Rpb24oX291dHB1dCwgb3B0aW9ucyA9IHt9KSB7XG4gIGlmICghdGhpcy5vdXRwdXQpIHtcbiAgICB0aGlzLm91dChfb3V0cHV0KTtcbiAgfVxuICByZXR1cm4gdGhpcy5vdXRwdXQucmVuZGVyVGV4dHVyZShvcHRpb25zKTtcbn1cblxuR2xzbFNvdXJjZS5wcm90b3R5cGUuY29tcGlsZSA9IGZ1bmN0aW9uIChvcHRpb25zID0ge30pIHtcbiAgdGhpcy5wYXNzZXMgPSBbXVxuICB0aGlzLnBhc3Nlcy5wdXNoKHRoaXMuY3JlYXRlUGFzcyhnZW5lcmF0ZUdsc2wodGhpcyksIG9wdGlvbnMpKVxuICByZXR1cm4gdGhpcy5wYXNzZXNcbn1cblxuR2xzbFNvdXJjZS5wcm90b3R5cGUuZ2V0SW5mbyA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMudHJhbnNmb3Jtcy5sZW5ndGggPiAwKSB7XG4gICAgdmFyIHNoYWRlckluZm8gPSBnZW5lcmF0ZUdsc2wodGhpcylcbiAgICB2YXIgdW5pZm9ybXMgPSB7fVxuICAgIHNoYWRlckluZm8udW5pZm9ybXMuZm9yRWFjaCgodW5pZm9ybSkgPT4geyB1bmlmb3Jtc1t1bmlmb3JtLm5hbWVdID0gdW5pZm9ybS52YWx1ZSB9KVxuICAgIHJldHVybiB7XG4gICAgICBzaGFkZXJJbmZvLFxuICAgICAgdXRpbGl0eUdsc2w6IHRoaXMudXRpbHMsXG4gICAgICAvLyB0b2RvOiBkaWZmZXJzIGZyb20gY29tcGlsZVxuICAgICAgdmVydDogdGhpcy50cmFuc2Zvcm1zWzBdLnRyYW5zZm9ybS52ZXJ0LFxuICAgICAgLy8gdG9kbzogZGlmZmVycyBmcm9tIGNvbXBpbGVcbiAgICAgIGF0dHJpYnV0ZXM6IHRoaXMudHJhbnNmb3Jtc1swXS50cmFuc2Zvcm0uYXR0cmlidXRlcyxcbiAgICAgIC8vIHRvZG86IGRpZmZlcnMgZnJvbSBjb21waWxlXG4gICAgICBhdHRyaWJ1dGVzQ291bnQ6IHRoaXMudHJhbnNmb3Jtc1swXS50cmFuc2Zvcm0uYXR0cmlidXRlc0NvdW50LFxuICAgICAgcHJpbWl0aXZlOiB0aGlzLnRyYW5zZm9ybXNbMF0udHJhbnNmb3JtLnByaW1pdGl2ZSxcbiAgICAgIHVuaWZvcm1zOiBPYmplY3QuYXNzaWduKHt9LCB0aGlzLmRlZmF1bHRVbmlmb3JtcywgdW5pZm9ybXMpXG4gICAgfTtcbiAgfVxufVxuXG5HbHNsU291cmNlLnByb3RvdHlwZS5jcmVhdGVQYXNzID0gZnVuY3Rpb24oc2hhZGVySW5mbywgb3B0aW9ucyA9IHt9KSB7XG4gIHZhciB1bmlmb3JtcyA9IHt9XG4gIHNoYWRlckluZm8udW5pZm9ybXMuZm9yRWFjaCgodW5pZm9ybSkgPT4geyB1bmlmb3Jtc1t1bmlmb3JtLm5hbWVdID0gdW5pZm9ybS52YWx1ZSB9KVxuXG4gIGlmIChzaGFkZXJJbmZvLmNvbWJpbmUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdmVydDogR2xzbFNvdXJjZS5jb21waWxlVmVydCh0aGlzLmRlZmF1bHRPdXRwdXQucHJlY2lzaW9uLCBmYWxzZSwge1xuICAgICAgICBnbHNsTmFtZTogJ2NvbWJpbmUnLFxuICAgICAgfSwgc2hhZGVySW5mbyksXG4gICAgICB1c2VyQXJnczogdGhpcy50cmFuc2Zvcm1zWzBdLnVzZXJBcmdzLFxuICAgICAgLy8gdG9kbzogZml4IG9yIGRlbGV0ZVxuICAgICAgLy8gYmxlbmRNb2RlOiB0aGlzLmJsZW5kTW9kZSxcbiAgICAgIGxpbmVXaWR0aDogdGhpcy5saW5lV2lkdGgsXG4gICAgICBmcmFnOiBHbHNsU291cmNlLmNvbXBpbGVGcmFnKHRoaXMuZGVmYXVsdE91dHB1dC5wcmVjaXNpb24sIHNoYWRlckluZm8sIHRoaXMudXRpbHMpLFxuICAgICAgdW5pZm9ybXM6IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuZGVmYXVsdFVuaWZvcm1zLCB1bmlmb3JtcyksXG4gICAgICB2aWV3cG9ydDogdGhpcy5fdmlld3BvcnQsXG4gICAgfTtcbiAgfVxuXG4gIGNvbnN0IHZlcnRUcmFuc2Zvcm0gPSB0aGlzLnRyYW5zZm9ybXNbMF0udHJhbnNmb3JtLnR5cGUgPT09ICdjbGVhcicgPyB0aGlzLnRyYW5zZm9ybXNbMV0gOiB0aGlzLnRyYW5zZm9ybXNbMF07XG4gIHJldHVybiBPYmplY3QuYXNzaWduKHtcbiAgICB2ZXJ0OiBHbHNsU291cmNlLmNvbXBpbGVWZXJ0KHRoaXMuZGVmYXVsdE91dHB1dC5wcmVjaXNpb24sIHRydWUsIHZlcnRUcmFuc2Zvcm0udHJhbnNmb3JtLCBzaGFkZXJJbmZvLCB0aGlzLnV0aWxzKSxcbiAgICBwcmltaXRpdmU6IHZlcnRUcmFuc2Zvcm0udHJhbnNmb3JtLnByaW1pdGl2ZSxcbiAgICB1c2VyQXJnczogdmVydFRyYW5zZm9ybS51c2VyQXJncyxcbiAgICBnZW9tZXRyeTogdGhpcy5nZW9tZXRyeSxcbiAgICBibGVuZE1vZGU6IHRoaXMuYmxlbmRNb2RlLFxuICAgIGxpbmVXaWR0aDogdGhpcy5saW5lV2lkdGgsXG4gICAgZnJhZzogR2xzbFNvdXJjZS5jb21waWxlRnJhZyh0aGlzLmRlZmF1bHRPdXRwdXQucHJlY2lzaW9uLCBzaGFkZXJJbmZvLCB0aGlzLnV0aWxzKSxcbiAgICB1bmlmb3JtczogT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5kZWZhdWx0VW5pZm9ybXMsIHVuaWZvcm1zKSxcbiAgICB2aWV3cG9ydDogdGhpcy5fdmlld3BvcnQsXG4gIH0sIG9wdGlvbnMpXG59XG5cbkdsc2xTb3VyY2UuY29tcGlsZUhlYWRlciA9IGZ1bmN0aW9uKHByZWNpc2lvbiwgdW5pZm9ybXMgPSB7fSwgdXRpbHMgPSB7fSkge1xuICByZXR1cm4gYFxuICBwcmVjaXNpb24gJHtwcmVjaXNpb259IGZsb2F0O1xuICAke09iamVjdC52YWx1ZXModW5pZm9ybXMpLm1hcCgodW5pZm9ybSkgPT4ge1xuICAgIGxldCB0eXBlID0gdW5pZm9ybS50eXBlXG4gICAgc3dpdGNoICh1bmlmb3JtLnR5cGUpIHtcbiAgICAgIGNhc2UgJ3RleHR1cmUnOlxuICAgICAgICB0eXBlID0gJ3NhbXBsZXIyRCdcbiAgICAgICAgYnJlYWtcbiAgICB9XG4gICAgcmV0dXJuIGBcbiAgICAgIHVuaWZvcm0gJHt0eXBlfSAke3VuaWZvcm0ubmFtZX07YFxuICB9KS5qb2luKCcnKX1cbiAgdW5pZm9ybSBmbG9hdCB0aW1lO1xuICB1bmlmb3JtIHZlYzIgcmVzb2x1dGlvbjtcbiAgdmFyeWluZyB2ZWMzIHZwb3NpdGlvbjtcbiAgdmFyeWluZyB2ZWMyIHZ1djtcbiAgdmFyeWluZyB2ZWMzIHZub3JtYWw7XG4gIHVuaWZvcm0gc2FtcGxlcjJEIHByZXZCdWZmZXI7XG4gIFxuICAke09iamVjdC52YWx1ZXModXRpbHMpLm1hcCgodHJhbnNmb3JtKSA9PiB7XG4gICAgLy8gIGNvbnNvbGUubG9nKHRyYW5zZm9ybS5nbHNsKVxuICAgIHJldHVybiBgXG4gICAgICAgICAgICAke3RyYW5zZm9ybS5nbHNsfVxuICAgICAgICAgIGBcbiAgfSkuam9pbignJyl9XG4gIGBcbn1cblxuR2xzbFNvdXJjZS5jb21waWxlRnJhZyA9IGZ1bmN0aW9uKHByZWNpc2lvbiwgc2hhZGVySW5mbywgdXRpbHMpIHtcbiAgY29uc3QgaGVhZGVyID0gdGhpcy5jb21waWxlSGVhZGVyKHByZWNpc2lvbiwgc2hhZGVySW5mby51bmlmb3JtcywgdXRpbHMpO1xuICByZXR1cm4gaGVhZGVyICsgYFxuICBcbiAgJHtzaGFkZXJJbmZvLmdsc2xGdW5jdGlvbnMubWFwKCh0cmFuc2Zvcm0pID0+IHtcbiAgICByZXR1cm4gYFxuICAgICAgICAgICAgJHt0cmFuc2Zvcm0udHJhbnNmb3JtLmdsc2x9XG4gICAgICAgICAgYFxuICB9KS5qb2luKCcnKX1cblxuICB2b2lkIG1haW4gKCkge1xuICAgIHZlYzQgYyA9IHZlYzQoMSwgMCwgMCwgMSk7XG4gICAgLy92ZWMyIHN0ID0gZ2xfRnJhZ0Nvb3JkLnh5L3Jlc29sdXRpb24ueHk7XG4gICAgdmVjMiBzdCA9IHZ1djtcbiAgICBnbF9GcmFnQ29sb3IgPSAke3NoYWRlckluZm8uZnJhZ0NvbG9yfTtcbiAgfVxuICBgXG59XG5cbkdsc2xTb3VyY2UuY29tcGlsZVZlcnQgPSBmdW5jdGlvbihwcmVjaXNpb24sIHVzZUNhbWVyYSwgdHJhbnNmb3JtLCBzaGFkZXJJbmZvLCB1dGlscykge1xuICBjb25zdCB1c2VVViA9IHR5cGVvZih0cmFuc2Zvcm0udXNlVVYpICE9PSAndW5kZWZpbmVkJ1xuICAgID8gdHJhbnNmb3JtLnVzZVVWXG4gICAgOiAoIXRyYW5zZm9ybS5wcmltaXRpdmUgfHwgWydwb2ludHMnLCAnbGluZXMnLCAnbGluZSBzdHJpcCcsICdsaW5lIGxvb3AnXS5pbmRleE9mKHRyYW5zZm9ybS5wcmltaXRpdmUpID09PSAtMSk7XG4gIGNvbnN0IHVzZU5vcm1hbCA9IHR5cGVvZih0cmFuc2Zvcm0udXNlTm9ybWFsKSAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgID8gdHJhbnNmb3JtLnVzZU5vcm1hbFxuICAgICAgOiB0cmFuc2Zvcm0udHlwZSA9PT0gJ3ZlcnQnICYmICghdHJhbnNmb3JtLnByaW1pdGl2ZSB8fCBbJ3BvaW50cycsICdsaW5lcycsICdsaW5lIHN0cmlwJywgJ2xpbmUgbG9vcCddLmluZGV4T2YodHJhbnNmb3JtLnByaW1pdGl2ZSkgPT09IC0xKVxuXG4gIGxldCB2ZXJ0SGVhZGVyID0gYFxuICBwcmVjaXNpb24gJHtwcmVjaXNpb259IGZsb2F0O1xuICB1bmlmb3JtIG1hdDQgcHJvamVjdGlvbiwgdmlldztcbiAgYXR0cmlidXRlIHZlYzMgcG9zaXRpb247XG4gICR7dXNlVVYgPyAnYXR0cmlidXRlIHZlYzIgdXY7JyA6ICcnfVxuICAke3VzZU5vcm1hbCA/ICdhdHRyaWJ1dGUgdmVjMyBub3JtYWw7JyA6ICcnfVxuICB2YXJ5aW5nIHZlYzMgdnBvc2l0aW9uO1xuICB2YXJ5aW5nIHZlYzIgdnV2O1xuICB2YXJ5aW5nIHZlYzMgdm5vcm1hbDtcbiAgYFxuICBsZXQgdmVydEZuID0gYFxuICB2b2lkICR7dHJhbnNmb3JtLmdsc2xOYW1lfSgpIHtcbiAgICB2cG9zaXRpb24gPSBwb3NpdGlvbjtcbiAgICBnbF9Qb3NpdGlvbiA9ICR7dXNlQ2FtZXJhID8gJ3Byb2plY3Rpb24gKiB2aWV3ICogJyA6ICcnfXZlYzQocG9zaXRpb24sIDEuMCk7XG4gIH0gXG4gIGBcbiAgbGV0IHZlcnRDYWxsID0gYCR7dHJhbnNmb3JtLmdsc2xOYW1lfSgpO2A7XG4gIGlmICh0cmFuc2Zvcm0udmVydCkge1xuICAgIHZlcnRIZWFkZXIgPSB0aGlzLmNvbXBpbGVIZWFkZXIocHJlY2lzaW9uLCBzaGFkZXJJbmZvLnVuaWZvcm1zLCB1dGlscykgKyBgXG4gICAgdW5pZm9ybSBtYXQ0IHByb2plY3Rpb24sIHZpZXc7XG4gICAgYXR0cmlidXRlIHZlYzMgcG9zaXRpb247XG4gICAgJHt1c2VVViA/ICdhdHRyaWJ1dGUgdmVjMiB1djsnIDogJyd9XG4gICAgJHt1c2VOb3JtYWwgPyAnYXR0cmlidXRlIHZlYzMgbm9ybWFsOycgOiAnJ31cbiAgICBcbiAgICAke3NoYWRlckluZm8uZ2xzbEZ1bmN0aW9ucy5tYXAoKHRyYW5zKSA9PiB7XG4gICAgICBpZiAodHJhbnMudHJhbnNmb3JtLm5hbWUgIT09IHRyYW5zZm9ybS5uYW1lKSB7XG4gICAgICAgIHJldHVybiBgXG4gICAgICAgICAgICAke3RyYW5zLnRyYW5zZm9ybS5nbHNsfVxuICAgICAgICAgIGBcbiAgICAgIH1cbiAgICB9KS5qb2luKCcnKX1cbiAgICBgXG4gICAgdmVydEZuID0gdHJhbnNmb3JtLnZlcnQ7XG4gICAgdmVydENhbGwgPSBgXG4gICAgJHt1c2VVViA/ICd2ZWMyIHN0ID0gdXY7JyA6ICd2ZWMyIHN0ID0gcG9zaXRpb24ueHk7J31cbiAgICB2cG9zaXRpb24gPSAke3NoYWRlckluZm8ucG9zaXRpb259Lnh5ejtcbiAgICBnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb24gKiB2aWV3ICogdmVjNCh2cG9zaXRpb24sIDEuMCk7XG4gICAgYDtcbiAgfVxuXG4gIHJldHVybiB2ZXJ0SGVhZGVyICsgYFxuICAgIFxuICAke3ZlcnRGbn1cblxuICB2b2lkIG1haW4gKCkge1xuICAgICR7dXNlVVYgPyAndnV2ID0gdXY7JyA6ICcnfVxuICAgICR7dXNlTm9ybWFsID8gJ3Zub3JtYWwgPSBub3JtYWw7JyA6ICcnfVxuICAgICR7dmVydENhbGx9XG4gIH1gXG59XG5cbi8vIHRvZG86IG1ha2UgaHlkcmEtc3ludGggZnVuY3Rpb25cbkdsc2xTb3VyY2UucHJvdG90eXBlLnNldEJsZW5kID0gZnVuY3Rpb24oYmxlbmRNb2RlID0gdHJ1ZSkge1xuICB0aGlzLmJsZW5kTW9kZSA9IGJsZW5kTW9kZTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbkdsc2xTb3VyY2UucHJvdG90eXBlLnNldExpbmVXaWR0aCA9IGZ1bmN0aW9uKGxpbmVXaWR0aCkge1xuICB0aGlzLmxpbmVXaWR0aCA9IGxpbmVXaWR0aDtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbkdsc2xTb3VyY2UucHJvdG90eXBlLnNldEdlb21ldHJ5ID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgY29uc3QgaXNHZW9tZXRyeSA9ICh2KSA9PiAodi5pc0J1ZmZlckdlb21ldHJ5IHx8ICh2LnBvc2l0aW9ucyAmJiB2LmVkZ2VzKSk7XG4gIGNvbnN0IGlzQ2xhc3MgPSAodikgPT4gdHlwZW9mIHYgPT09ICdmdW5jdGlvbicgJiYgL15cXHMqY2xhc3NcXHMrLy50ZXN0KHYudG9TdHJpbmcoKSk7XG4gIGlmICghaW5wdXQpIGlucHV0ID0gW107XG4gIGlmICghaXNHZW9tZXRyeShpbnB1dCkpIHtcbiAgICBjb25zdCB2ZXJ0VHJhbnNmb3JtID0gdGhpcy50cmFuc2Zvcm1zWzBdLnRyYW5zZm9ybS50eXBlID09PSAnY2xlYXInID8gdGhpcy50cmFuc2Zvcm1zWzFdIDogdGhpcy50cmFuc2Zvcm1zWzBdO1xuICAgIGlmICghQXJyYXkuaXNBcnJheShpbnB1dCkpIGlucHV0ID0gW2lucHV0XTtcbiAgICBpZiAoaXNDbGFzcyh2ZXJ0VHJhbnNmb3JtLnRyYW5zZm9ybS5nZW9tZXRyeSkpIHtcbiAgICAgIGlmICh2ZXJ0VHJhbnNmb3JtLnRyYW5zZm9ybS5nZW9tZXRyeSA9PT0gR3JpZEdlb21ldHJ5ICYmIHZlcnRUcmFuc2Zvcm0udHJhbnNmb3JtLnByaW1pdGl2ZSAmJiB0eXBlb2YoaW5wdXRbMF0pICE9PSAnc3RyaW5nJykge1xuICAgICAgICBpbnB1dC51bnNoaWZ0KHZlcnRUcmFuc2Zvcm0udHJhbnNmb3JtLnByaW1pdGl2ZSk7XG4gICAgICB9XG4gICAgICBpbnB1dCA9IG5ldyAodmVydFRyYW5zZm9ybS50cmFuc2Zvcm0uZ2VvbWV0cnkpKC4uLmlucHV0KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBpZiAodmVydFRyYW5zZm9ybS50cmFuc2Zvcm0uZ2VvbWV0cnkgPT09IHZlY3Rvcml6ZVRleHQgJiYgaW5wdXQubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGlucHV0LnB1c2goe1xuICAgICAgICAgIHRleHRBbGlnbjogJ2NlbnRlcicsXG4gICAgICAgICAgdGV4dEJhc2VsaW5lOiAnbWlkZGxlJyxcbiAgICAgICAgICAvLyBmb250OiAnYXJpYWwnLFxuICAgICAgICAgIC8vIHRyaWFuZ2xlczogdHJ1ZSwgLy8gdG9kbzogbWFrZSBpdCB3b3JrXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaW5wdXQgPSAodmVydFRyYW5zZm9ybS50cmFuc2Zvcm0uZ2VvbWV0cnkpKC4uLmlucHV0KTtcbiAgICB9XG4gIH1cbiAgdGhpcy5nZW9tZXRyeSA9IGlucHV0O1xufVxuXG5HbHNsU291cmNlLnByb3RvdHlwZS52aWV3cG9ydCA9IGZ1bmN0aW9uKHgsIHksIHcsIGgpIHtcbiAgdGhpcy5fdmlld3BvcnQgPSB7eCwgeSwgdywgaH07XG4gIHJldHVybiB0aGlzO1xufVxuXG5jb25zdCBnbHNsUHJvcHMgPSBbJ3gnLCAneScsICd6JywgJ3h5JywgJ3h6JywgJ3l4JywgJ3l6JywgJ3p4JywgJ3p5JywgJ3h5eicsICd4eXp3J107XG5nbHNsUHJvcHMubWFwKChwcm9wKSA9PiB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShHbHNsU291cmNlLnByb3RvdHlwZSwgcHJvcCwge1xuICAgIGdldCgpIHtcbiAgICAgIHRoaXMuZ2V0dGVyID0gcHJvcDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSk7XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgR2xzbFNvdXJjZVxuIiwiaW1wb3J0IHtCdWZmZXJHZW9tZXRyeX0gZnJvbSBcInRocmVlL3NyYy9jb3JlL0J1ZmZlckdlb21ldHJ5XCI7XG5pbXBvcnQge0Zsb2F0MzJCdWZmZXJBdHRyaWJ1dGV9IGZyb20gXCJ0aHJlZS9zcmMvY29yZS9CdWZmZXJBdHRyaWJ1dGVcIjtcblxuY2xhc3MgR3JpZEdlb21ldHJ5IGV4dGVuZHMgQnVmZmVyR2VvbWV0cnkge1xuICAgIGNvbnN0cnVjdG9yKHR5cGUsIHdpZHRoLCBoZWlnaHQsIG9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIoKTtcblxuICAgICAgICB0aGlzLnR5cGUgPSAnR3JpZEdlb21ldHJ5JztcblxuICAgICAgICB0aGlzLnBhcmFtZXRlcnMgPSB7XG4gICAgICAgICAgICBwcmltaXRpdmU6IHR5cGUsXG4gICAgICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICAgICAgICAgIG9wdGlvbnM6IG9wdGlvbnMsXG4gICAgICAgIH07XG5cbiAgICAgICAgbGV0IHZlcnRpY2VzO1xuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ3BvaW50cyc6IHtcbiAgICAgICAgICAgICAgICB3aWR0aCB8fCAod2lkdGggPSAxKTtcbiAgICAgICAgICAgICAgICBoZWlnaHQgfHwgKGhlaWdodCA9IDEpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvdW50ID0gd2lkdGggKiBoZWlnaHQ7XG4gICAgICAgICAgICAgICAgdmVydGljZXMgPSBGbG9hdDMyQXJyYXkuZnJvbSh7bGVuZ3RoOiBjb3VudCAqIDN9LCAodiwgaykgPT4ge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGslMykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoKGsrMSkgLyAzICUgd2lkdGggLyB3aWR0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgoTWF0aC5mbG9vcigoay0xKSAvIDMgLyB3aWR0aCkrMC41KSAvIGhlaWdodCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ2xpbmVzJzoge1xuICAgICAgICAgICAgICAgIHdpZHRoIHx8ICh3aWR0aCA9IDEpO1xuICAgICAgICAgICAgICAgIGhlaWdodCB8fCAoaGVpZ2h0ID0gMSk7XG4gICAgICAgICAgICAgICAgY29uc3QgY291bnQgPSAyICogKHdpZHRoICsgaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICB2ZXJ0aWNlcyA9IEZsb2F0MzJBcnJheS5mcm9tKHtsZW5ndGg6IGNvdW50ICogM30sICh2LCBrKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChrIDwgKHdpZHRoICogNikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoayU2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKChrKzMpIC8gNiAlIHdpZHRoIC8gd2lkdGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDAuMDAwMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoKGspIC8gNiAlIHdpZHRoIC8gd2lkdGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDAuOTk5OTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoayU2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMC4wMDAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgoaysyKSAvIDYgJSBoZWlnaHQgLyBoZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDAuOTk5OTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoKGstMSkgLyA2ICUgaGVpZ2h0IC8gaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnbGluZSBzdHJpcCc6IHtcbiAgICAgICAgICAgICAgICB3aWR0aCB8fCAod2lkdGggPSAxMCk7XG4gICAgICAgICAgICAgICAgaGVpZ2h0IHx8IChoZWlnaHQgPSAxKTtcbiAgICAgICAgICAgICAgICBjb25zdCBjb3VudCA9IHdpZHRoICogaGVpZ2h0O1xuICAgICAgICAgICAgICAgIGNvbnN0IGNsb3NlZCA9IHR5cGVvZihvcHRpb25zKSA9PT0gJ3VuZGVmaW5lZCcgPyB0cnVlIDogb3B0aW9ucztcbiAgICAgICAgICAgICAgICB2ZXJ0aWNlcyA9IEZsb2F0MzJBcnJheS5mcm9tKHtsZW5ndGg6IGNvdW50ICogM30sICh2LCBrKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRvZG86IHdpbGwgYmUgTmFOIHdoZW4gcG9pbnRzWzBdID09IDFcbiAgICAgICAgICAgICAgICAgICAgLy8gdG9kbzogbWluaW11bSAyIHBvaW50cz9cbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChrJTMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGsgLyAzICUgd2lkdGggLyAod2lkdGgtY2xvc2VkKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IoKGstMSkgLyAzIC8gd2lkdGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdsaW5lIGxvb3AnOiB7XG4gICAgICAgICAgICAgICAgd2lkdGggfHwgKHdpZHRoID0gMTApO1xuICAgICAgICAgICAgICAgIGhlaWdodCB8fCAoaGVpZ2h0ID0gMSk7XG4gICAgICAgICAgICAgICAgY29uc3QgY291bnQgPSB3aWR0aCAqIGhlaWdodDtcbiAgICAgICAgICAgICAgICB2ZXJ0aWNlcyA9IEZsb2F0MzJBcnJheS5mcm9tKHtsZW5ndGg6IGNvdW50ICogM30sICh2LCBrKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoayUzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChrIC8gMyAlIHdpZHRoIC8gd2lkdGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLmZsb29yKChrLTEpIC8gMyAvIHdpZHRoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBpbnZhbGlkIEdyaWRHZW9tZXRyeSB0eXBlOiAke3R5cGV9YCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHZlcnRpY2VzLCAzICkgKTtcblxuICAgIH1cbn1cblxuZXhwb3J0IHsgR3JpZEdlb21ldHJ5IH07IiwiLypcbkZvcm1hdCBmb3IgYWRkaW5nIGZ1bmN0aW9ucyB0byBoeWRyYS4gRm9yIGVhY2ggZW50cnkgaW4gdGhpcyBmaWxlLCBoeWRyYSBhdXRvbWF0aWNhbGx5IGdlbmVyYXRlcyBhIGdsc2wgZnVuY3Rpb24gYW5kIGphdmFzY3JpcHQgZnVuY3Rpb24gd2l0aCB0aGUgc2FtZSBuYW1lLiBZb3UgY2FuIGFsc28gYXNzIGZ1bmN0aW9ucyBkeW5hbWljYWxseSB1c2luZyBzZXRGdW5jdGlvbihvYmplY3QpLlxuXG57XG4gIG5hbWU6ICdvc2MnLCAvLyBuYW1lIHRoYXQgd2lsbCBiZSB1c2VkIHRvIGFjY2VzcyBmdW5jdGlvbiBpbiBqcyBhcyB3ZWxsIGFzIGluIGdsc2xcbiAgdHlwZTogJ3NyYycsIC8vIGNhbiBiZSAnc3JjJywgJ2NvbG9yJywgJ2NvbWJpbmUnLCAnY29tYmluZUNvb3JkcycuIHNlZSBiZWxvdyBmb3IgbW9yZSBpbmZvXG4gIGlucHV0czogW1xuICAgIHtcbiAgICAgIG5hbWU6ICdmcmVxJyxcbiAgICAgIHR5cGU6ICdmbG9hdCcsXG4gICAgICBkZWZhdWx0OiAwLjJcbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdzeW5jJyxcbiAgICAgIHR5cGU6ICdmbG9hdCcsXG4gICAgICBkZWZhdWx0OiAwLjFcbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6ICdvZmZzZXQnLFxuICAgICAgdHlwZTogJ2Zsb2F0JyxcbiAgICAgIGRlZmF1bHQ6IDAuMFxuICAgIH1cbiAgXSxcbiAgICBnbHNsOiBgXG4gICAgICB2ZWMyIHN0ID0gX3N0O1xuICAgICAgZmxvYXQgciA9IHNpbigoc3QueC1vZmZzZXQqMi9mcmVxK3RpbWUqc3luYykqZnJlcSkqMC41ICArIDAuNTtcbiAgICAgIGZsb2F0IGcgPSBzaW4oKHN0LngrdGltZSpzeW5jKSpmcmVxKSowLjUgKyAwLjU7XG4gICAgICBmbG9hdCBiID0gc2luKChzdC54K29mZnNldC9mcmVxK3RpbWUqc3luYykqZnJlcSkqMC41ICArIDAuNTtcbiAgICAgIHJldHVybiB2ZWM0KHIsIGcsIGIsIDEuMCk7XG4gICBgXG59XG5cbi8vIFRoZSBhYm92ZSBjb2RlIGdlbmVyYXRlcyB0aGUgZ2xzbCBmdW5jdGlvbjpcbmB2ZWM0IG9zYyh2ZWMyIF9zdCwgZmxvYXQgZnJlcSwgZmxvYXQgc3luYywgZmxvYXQgb2Zmc2V0KXtcbiB2ZWMyIHN0ID0gX3N0O1xuIGZsb2F0IHIgPSBzaW4oKHN0Lngtb2Zmc2V0KjIvZnJlcSt0aW1lKnN5bmMpKmZyZXEpKjAuNSAgKyAwLjU7XG4gZmxvYXQgZyA9IHNpbigoc3QueCt0aW1lKnN5bmMpKmZyZXEpKjAuNSArIDAuNTtcbiBmbG9hdCBiID0gc2luKChzdC54K29mZnNldC9mcmVxK3RpbWUqc3luYykqZnJlcSkqMC41ICArIDAuNTtcbiByZXR1cm4gdmVjNChyLCBnLCBiLCAxLjApO1xufWBcblxuXG5UeXBlcyBhbmQgZGVmYXVsdCBhcmd1bWVudHMgZm9yIGh5ZHJhIGZ1bmN0aW9ucy5cblRoZSB2YWx1ZSBpbiB0aGUgJ3R5cGUnIGZpZWxkIGxldHMgdGhlIHBhcnNlciBrbm93IHdoaWNoIHR5cGUgdGhlIGZ1bmN0aW9uIHdpbGwgYmUgcmV0dXJuZWQgYXMgd2VsbCBhcyBkZWZhdWx0IGFyZ3VtZW50cy5cblxuY29uc3QgdHlwZXMgPSB7XG4gICdzcmMnOiB7XG4gICAgcmV0dXJuVHlwZTogJ3ZlYzQnLFxuICAgIGFyZ3M6IFsndmVjMiBfc3QnXVxuICB9LFxuICAnY29vcmQnOiB7XG4gICAgcmV0dXJuVHlwZTogJ3ZlYzInLFxuICAgIGFyZ3M6IFsndmVjMiBfc3QnXVxuICB9LFxuICAnY29sb3InOiB7XG4gICAgcmV0dXJuVHlwZTogJ3ZlYzQnLFxuICAgIGFyZ3M6IFsndmVjNCBfYzAnXVxuICB9LFxuICAnY29tYmluZSc6IHtcbiAgICByZXR1cm5UeXBlOiAndmVjNCcsXG4gICAgYXJnczogWyd2ZWM0IF9jMCcsICd2ZWM0IF9jMSddXG4gIH0sXG4gICdjb21iaW5lQ29vcmQnOiB7XG4gICAgcmV0dXJuVHlwZTogJ3ZlYzInLFxuICAgIGFyZ3M6IFsndmVjMiBfc3QnLCAndmVjNCBfYzAnXVxuICB9XG59XG5cbiovXG5cbmV4cG9ydCBkZWZhdWx0ICgpID0+IFtcbiAge1xuICBuYW1lOiAnbm9pc2UnLFxuICB0eXBlOiAnc3JjJyxcbiAgaW5wdXRzOiBbXG4gICAge1xuICAgICAgdHlwZTogJ2Zsb2F0JyxcbiAgICAgIG5hbWU6ICdzY2FsZScsXG4gICAgICBkZWZhdWx0OiAxMCxcbiAgICB9LFxue1xuICAgICAgdHlwZTogJ2Zsb2F0JyxcbiAgICAgIG5hbWU6ICdvZmZzZXQnLFxuICAgICAgZGVmYXVsdDogMC4xLFxuICAgIH1cbiAgXSxcbiAgZ2xzbDpcbmAgICByZXR1cm4gdmVjNCh2ZWMzKF9ub2lzZSh2ZWMzKF9zdCpzY2FsZSwgb2Zmc2V0KnRpbWUpKSksIDEuMCk7YFxufSxcbntcbiAgbmFtZTogJ3Zvcm9ub2knLFxuICB0eXBlOiAnc3JjJyxcbiAgaW5wdXRzOiBbXG4gICAge1xuICAgICAgdHlwZTogJ2Zsb2F0JyxcbiAgICAgIG5hbWU6ICdzY2FsZScsXG4gICAgICBkZWZhdWx0OiA1LFxuICAgIH0sXG57XG4gICAgICB0eXBlOiAnZmxvYXQnLFxuICAgICAgbmFtZTogJ3NwZWVkJyxcbiAgICAgIGRlZmF1bHQ6IDAuMyxcbiAgICB9LFxue1xuICAgICAgdHlwZTogJ2Zsb2F0JyxcbiAgICAgIG5hbWU6ICdibGVuZGluZycsXG4gICAgICBkZWZhdWx0OiAwLjMsXG4gICAgfVxuICBdLFxuICBnbHNsOlxuYCAgIHZlYzMgY29sb3IgPSB2ZWMzKC4wKTtcbiAgIC8vIFNjYWxlXG4gICBfc3QgKj0gc2NhbGU7XG4gICAvLyBUaWxlIHRoZSBzcGFjZVxuICAgdmVjMiBpX3N0ID0gZmxvb3IoX3N0KTtcbiAgIHZlYzIgZl9zdCA9IGZyYWN0KF9zdCk7XG4gICBmbG9hdCBtX2Rpc3QgPSAxMC47ICAvLyBtaW5pbXVuIGRpc3RhbmNlXG4gICB2ZWMyIG1fcG9pbnQ7ICAgICAgICAvLyBtaW5pbXVtIHBvaW50XG4gICBmb3IgKGludCBqPS0xOyBqPD0xOyBqKysgKSB7XG4gICBmb3IgKGludCBpPS0xOyBpPD0xOyBpKysgKSB7XG4gICB2ZWMyIG5laWdoYm9yID0gdmVjMihmbG9hdChpKSxmbG9hdChqKSk7XG4gICB2ZWMyIHAgPSBpX3N0ICsgbmVpZ2hib3I7XG4gICB2ZWMyIHBvaW50ID0gZnJhY3Qoc2luKHZlYzIoZG90KHAsdmVjMigxMjcuMSwzMTEuNykpLGRvdChwLHZlYzIoMjY5LjUsMTgzLjMpKSkpKjQzNzU4LjU0NTMpO1xuICAgcG9pbnQgPSAwLjUgKyAwLjUqc2luKHRpbWUqc3BlZWQgKyA2LjI4MzEqcG9pbnQpO1xuICAgdmVjMiBkaWZmID0gbmVpZ2hib3IgKyBwb2ludCAtIGZfc3Q7XG4gICBmbG9hdCBkaXN0ID0gbGVuZ3RoKGRpZmYpO1xuICAgaWYoIGRpc3QgPCBtX2Rpc3QgKSB7XG4gICBtX2Rpc3QgPSBkaXN0O1xuICAgbV9wb2ludCA9IHBvaW50O1xuICAgfVxuICAgfVxuICAgfVxuICAgLy8gQXNzaWduIGEgY29sb3IgdXNpbmcgdGhlIGNsb3Nlc3QgcG9pbnQgcG9zaXRpb25cbiAgIGNvbG9yICs9IGRvdChtX3BvaW50LHZlYzIoLjMsLjYpKTtcbiAgIGNvbG9yICo9IDEuMCAtIGJsZW5kaW5nKm1fZGlzdDtcbiAgIHJldHVybiB2ZWM0KGNvbG9yLCAxLjApO2Bcbn0sXG57XG4gIG5hbWU6ICdvc2MnLFxuICB0eXBlOiAnc3JjJyxcbiAgaW5wdXRzOiBbXG4gICAge1xuICAgICAgdHlwZTogJ2Zsb2F0JyxcbiAgICAgIG5hbWU6ICdmcmVxdWVuY3knLFxuICAgICAgZGVmYXVsdDogNjAsXG4gICAgfSxcbntcbiAgICAgIHR5cGU6ICdmbG9hdCcsXG4gICAgICBuYW1lOiAnc3luYycsXG4gICAgICBkZWZhdWx0OiAwLjEsXG4gICAgfSxcbntcbiAgICAgIHR5cGU6ICdmbG9hdCcsXG4gICAgICBuYW1lOiAnb2Zmc2V0JyxcbiAgICAgIGRlZmF1bHQ6IDAsXG4gICAgfVxuICBdLFxuICBnbHNsOlxuYCAgIHZlYzIgc3QgPSBfc3Q7XG4gICBmbG9hdCByID0gc2luKChzdC54LW9mZnNldC9mcmVxdWVuY3krdGltZSpzeW5jKSpmcmVxdWVuY3kpKjAuNSAgKyAwLjU7XG4gICBmbG9hdCBnID0gc2luKChzdC54K3RpbWUqc3luYykqZnJlcXVlbmN5KSowLjUgKyAwLjU7XG4gICBmbG9hdCBiID0gc2luKChzdC54K29mZnNldC9mcmVxdWVuY3krdGltZSpzeW5jKSpmcmVxdWVuY3kpKjAuNSAgKyAwLjU7XG4gICByZXR1cm4gdmVjNChyLCBnLCBiLCAxLjApO2Bcbn0sXG57XG4gIG5hbWU6ICdzaGFwZScsXG4gIHR5cGU6ICdzcmMnLFxuICBpbnB1dHM6IFtcbiAgICB7XG4gICAgICB0eXBlOiAnZmxvYXQnLFxuICAgICAgbmFtZTogJ3NpZGVzJyxcbiAgICAgIGRlZmF1bHQ6IDMsXG4gICAgfSxcbntcbiAgICAgIHR5cGU6ICdmbG9hdCcsXG4gICAgICBuYW1lOiAncmFkaXVzJyxcbiAgICAgIGRlZmF1bHQ6IDAuMyxcbiAgICB9LFxue1xuICAgICAgdHlwZTogJ2Zsb2F0JyxcbiAgICAgIG5hbWU6ICdzbW9vdGhpbmcnLFxuICAgICAgZGVmYXVsdDogMC4wMSxcbiAgICB9XG4gIF0sXG4gIGdsc2w6XG5gICAgdmVjMiBzdCA9IF9zdCAqIDIuIC0gMS47XG4gICAvLyBBbmdsZSBhbmQgcmFkaXVzIGZyb20gdGhlIGN1cnJlbnQgcGl4ZWxcbiAgIGZsb2F0IGEgPSBhdGFuKHN0Lngsc3QueSkrMy4xNDE2O1xuICAgZmxvYXQgciA9ICgyLiozLjE0MTYpL3NpZGVzO1xuICAgZmxvYXQgZCA9IGNvcyhmbG9vciguNSthL3IpKnItYSkqbGVuZ3RoKHN0KTtcbiAgIHJldHVybiB2ZWM0KHZlYzMoMS4wLXNtb290aHN0ZXAocmFkaXVzLHJhZGl1cyArIHNtb290aGluZyArIDAuMDAwMDAwMSxkKSksIDEuMCk7YFxufSxcbntcbiAgbmFtZTogJ2dyYWRpZW50JyxcbiAgdHlwZTogJ3NyYycsXG4gIGlucHV0czogW1xuICAgIHtcbiAgICAgIHR5cGU6ICdmbG9hdCcsXG4gICAgICBuYW1lOiAnc3BlZWQnLFxuICAgICAgZGVmYXVsdDogMCxcbiAgICB9XG4gIF0sXG4gIGdsc2w6XG5gICAgcmV0dXJuIHZlYzQoX3N0LCBzaW4odGltZSpzcGVlZCksIDEuMCk7YFxufSxcbntcbiAgbmFtZTogJ3NyYycsXG4gIHR5cGU6ICdzcmMnLFxuICBpbnB1dHM6IFtcbiAgICB7XG4gICAgICB0eXBlOiAnc2FtcGxlcjJEJyxcbiAgICAgIG5hbWU6ICd0ZXgnLFxuICAgICAgZGVmYXVsdDogTmFOLFxuICAgIH1cbiAgXSxcbiAgZ2xzbDpcbmAgICAvLyAgdmVjMiB1diA9IGdsX0ZyYWdDb29yZC54eS92ZWMyKDEyODAuLCA3MjAuKTtcbiAgIHJldHVybiB0ZXh0dXJlMkQodGV4LCBmcmFjdChfc3QpKTtgXG59LFxue1xuICBuYW1lOiAnc29saWQnLFxuICB0eXBlOiAnc3JjJyxcbiAgaW5wdXRzOiBbXG4gICAge1xuICAgICAgdHlwZTogJ2Zsb2F0JyxcbiAgICAgIG5hbWU6ICdyJyxcbiAgICAgIGRlZmF1bHQ6IDAsXG4gICAgfSxcbntcbiAgICAgIHR5cGU6ICdmbG9hdCcsXG4gICAgICBuYW1lOiAnZycsXG4gICAgICBkZWZhdWx0OiAwLFxuICAgIH0sXG57XG4gICAgICB0eXBlOiAnZmxvYXQnLFxuICAgICAgbmFtZTogJ2InLFxuICAgICAgZGVmYXVsdDogMCxcbiAgICB9LFxue1xuICAgICAgdHlwZTogJ2Zsb2F0JyxcbiAgICAgIG5hbWU6ICdhJyxcbiAgICAgIGRlZmF1bHQ6IDEsXG4gICAgfVxuICBdLFxuICBnbHNsOlxuYCAgIHJldHVybiB2ZWM0KHIsIGcsIGIsIGEpO2Bcbn0sXG57XG4gIG5hbWU6ICdyb3RhdGUnLFxuICB0eXBlOiAnY29vcmQnLFxuICBpbnB1dHM6IFtcbiAgICB7XG4gICAgICB0eXBlOiAnZmxvYXQnLFxuICAgICAgbmFtZTogJ2FuZ2xlJyxcbiAgICAgIGRlZmF1bHQ6IDEwLFxuICAgIH0sXG57XG4gICAgICB0eXBlOiAnZmxvYXQnLFxuICAgICAgbmFtZTogJ3NwZWVkJyxcbiAgICAgIGRlZmF1bHQ6IDAsXG4gICAgfVxuICBdLFxuICBnbHNsOlxuYCAgdmVjMiB4eSA9IF9zdCAtIHZlYzIoMC41KTtcbiAgIC8vIENvbnZlcnQgZGVncmVlcyB0byByYWRpYW5zXG4gICBmbG9hdCBhbmcgPSBhbmdsZSAqICgzLjE0MTU5MjY1MzU4OTc5MyAvIDE4MC4wKTtcbiAgIGFuZyA9IGFuZyArIHNwZWVkICp0aW1lO1xuICAgeHkgPSBtYXQyKGNvcyhhbmcpLC1zaW4oYW5nKSwgc2luKGFuZyksY29zKGFuZykpKnh5O1xuICAgeHkgKz0gMC41O1xuICAgcmV0dXJuIHh5O2Bcbn0sXG57XG4gIG5hbWU6ICdzY2FsZScsXG4gIHR5cGU6ICdjb29yZCcsXG4gIGlucHV0czogW1xuICAgIHtcbiAgICAgIHR5cGU6ICdmbG9hdCcsXG4gICAgICBuYW1lOiAnYW1vdW50JyxcbiAgICAgIGRlZmF1bHQ6IDEuNSxcbiAgICB9LFxue1xuICAgICAgdHlwZTogJ2Zsb2F0JyxcbiAgICAgIG5hbWU6ICd4TXVsdCcsXG4gICAgICBkZWZhdWx0OiAxLFxuICAgIH0sXG57XG4gICAgICB0eXBlOiAnZmxvYXQnLFxuICAgICAgbmFtZTogJ3lNdWx0JyxcbiAgICAgIGRlZmF1bHQ6IDEsXG4gICAgfSxcbntcbiAgICAgIHR5cGU6ICdmbG9hdCcsXG4gICAgICBuYW1lOiAnb2Zmc2V0WCcsXG4gICAgICBkZWZhdWx0OiAwLjUsXG4gICAgfSxcbntcbiAgICAgIHR5cGU6ICdmbG9hdCcsXG4gICAgICBuYW1lOiAnb2Zmc2V0WScsXG4gICAgICBkZWZhdWx0OiAwLjUsXG4gICAgfVxuICBdLFxuICBnbHNsOlxuYCAgIHZlYzIgeHkgPSBfc3QgLSB2ZWMyKG9mZnNldFgsIG9mZnNldFkpO1xuICAgeHkqPSgxLjAvdmVjMihhbW91bnQqeE11bHQsIGFtb3VudCp5TXVsdCkpO1xuICAgeHkrPXZlYzIob2Zmc2V0WCwgb2Zmc2V0WSk7XG4gICByZXR1cm4geHk7XG4gICBgXG59LFxue1xuICBuYW1lOiAncGl4ZWxhdGUnLFxuICB0eXBlOiAnY29vcmQnLFxuICBpbnB1dHM6IFtcbiAgICB7XG4gICAgICB0eXBlOiAnZmxvYXQnLFxuICAgICAgbmFtZTogJ3BpeGVsWCcsXG4gICAgICBkZWZhdWx0OiAyMCxcbiAgICB9LFxue1xuICAgICAgdHlwZTogJ2Zsb2F0JyxcbiAgICAgIG5hbWU6ICdwaXhlbFknLFxuICAgICAgZGVmYXVsdDogMjAsXG4gICAgfVxuICBdLFxuICBnbHNsOlxuYCAgIHZlYzIgeHkgPSB2ZWMyKHBpeGVsWCwgcGl4ZWxZKTtcbiAgIHJldHVybiAoZmxvb3IoX3N0ICogeHkpICsgMC41KS94eTtgXG59LFxue1xuICBuYW1lOiAncG9zdGVyaXplJyxcbiAgdHlwZTogJ2NvbG9yJyxcbiAgaW5wdXRzOiBbXG4gICAge1xuICAgICAgdHlwZTogJ2Zsb2F0JyxcbiAgICAgIG5hbWU6ICdiaW5zJyxcbiAgICAgIGRlZmF1bHQ6IDMsXG4gICAgfSxcbntcbiAgICAgIHR5cGU6ICdmbG9hdCcsXG4gICAgICBuYW1lOiAnZ2FtbWEnLFxuICAgICAgZGVmYXVsdDogMC42LFxuICAgIH1cbiAgXSxcbiAgZ2xzbDpcbmAgICB2ZWM0IGMyID0gcG93KF9jMCwgdmVjNChnYW1tYSkpO1xuICAgYzIgKj0gdmVjNChiaW5zKTtcbiAgIGMyID0gZmxvb3IoYzIpO1xuICAgYzIvPSB2ZWM0KGJpbnMpO1xuICAgYzIgPSBwb3coYzIsIHZlYzQoMS4wL2dhbW1hKSk7XG4gICByZXR1cm4gdmVjNChjMi54eXosIF9jMC5hKTtgXG59LFxue1xuICBuYW1lOiAnc2hpZnQnLFxuICB0eXBlOiAnY29sb3InLFxuICBpbnB1dHM6IFtcbiAgICB7XG4gICAgICB0eXBlOiAnZmxvYXQnLFxuICAgICAgbmFtZTogJ3InLFxuICAgICAgZGVmYXVsdDogMC41LFxuICAgIH0sXG57XG4gICAgICB0eXBlOiAnZmxvYXQnLFxuICAgICAgbmFtZTogJ2cnLFxuICAgICAgZGVmYXVsdDogMCxcbiAgICB9LFxue1xuICAgICAgdHlwZTogJ2Zsb2F0JyxcbiAgICAgIG5hbWU6ICdiJyxcbiAgICAgIGRlZmF1bHQ6IDAsXG4gICAgfSxcbntcbiAgICAgIHR5cGU6ICdmbG9hdCcsXG4gICAgICBuYW1lOiAnYScsXG4gICAgICBkZWZhdWx0OiAwLFxuICAgIH1cbiAgXSxcbiAgZ2xzbDpcbmAgICB2ZWM0IGMyID0gdmVjNChfYzApO1xuICAgYzIuciA9IGZyYWN0KGMyLnIgKyByKTtcbiAgIGMyLmcgPSBmcmFjdChjMi5nICsgZyk7XG4gICBjMi5iID0gZnJhY3QoYzIuYiArIGIpO1xuICAgYzIuYSA9IGZyYWN0KGMyLmEgKyBhKTtcbiAgIHJldHVybiB2ZWM0KGMyLnJnYmEpO2Bcbn0sXG57XG4gIG5hbWU6ICdyZXBlYXQnLFxuICB0eXBlOiAnY29vcmQnLFxuICBpbnB1dHM6IFtcbiAgICB7XG4gICAgICB0eXBlOiAnZmxvYXQnLFxuICAgICAgbmFtZTogJ3JlcGVhdFgnLFxuICAgICAgZGVmYXVsdDogMyxcbiAgICB9LFxue1xuICAgICAgdHlwZTogJ2Zsb2F0JyxcbiAgICAgIG5hbWU6ICdyZXBlYXRZJyxcbiAgICAgIGRlZmF1bHQ6IDMsXG4gICAgfSxcbntcbiAgICAgIHR5cGU6ICdmbG9hdCcsXG4gICAgICBuYW1lOiAnb2Zmc2V0WCcsXG4gICAgICBkZWZhdWx0OiAwLFxuICAgIH0sXG57XG4gICAgICB0eXBlOiAnZmxvYXQnLFxuICAgICAgbmFtZTogJ29mZnNldFknLFxuICAgICAgZGVmYXVsdDogMCxcbiAgICB9XG4gIF0sXG4gIGdsc2w6XG5gICAgdmVjMiBzdCA9IF9zdCAqIHZlYzIocmVwZWF0WCwgcmVwZWF0WSk7XG4gICBzdC54ICs9IHN0ZXAoMS4sIG1vZChzdC55LDIuMCkpICogb2Zmc2V0WDtcbiAgIHN0LnkgKz0gc3RlcCgxLiwgbW9kKHN0LngsMi4wKSkgKiBvZmZzZXRZO1xuICAgcmV0dXJuIGZyYWN0KHN0KTtgXG59LFxue1xuICBuYW1lOiAnbW9kdWxhdGVSZXBlYXQnLFxuICB0eXBlOiAnY29tYmluZUNvb3JkJyxcbiAgaW5wdXRzOiBbXG4gICAge1xuICAgICAgdHlwZTogJ2Zsb2F0JyxcbiAgICAgIG5hbWU6ICdyZXBlYXRYJyxcbiAgICAgIGRlZmF1bHQ6IDMsXG4gICAgfSxcbntcbiAgICAgIHR5cGU6ICdmbG9hdCcsXG4gICAgICBuYW1lOiAncmVwZWF0WScsXG4gICAgICBkZWZhdWx0OiAzLFxuICAgIH0sXG57XG4gICAgICB0eXBlOiAnZmxvYXQnLFxuICAgICAgbmFtZTogJ29mZnNldFgnLFxuICAgICAgZGVmYXVsdDogMC41LFxuICAgIH0sXG57XG4gICAgICB0eXBlOiAnZmxvYXQnLFxuICAgICAgbmFtZTogJ29mZnNldFknLFxuICAgICAgZGVmYXVsdDogMC41LFxuICAgIH1cbiAgXSxcbiAgZ2xzbDpcbmAgICB2ZWMyIHN0ID0gX3N0ICogdmVjMihyZXBlYXRYLCByZXBlYXRZKTtcbiAgIHN0LnggKz0gc3RlcCgxLiwgbW9kKHN0LnksMi4wKSkgKyBfYzAuciAqIG9mZnNldFg7XG4gICBzdC55ICs9IHN0ZXAoMS4sIG1vZChzdC54LDIuMCkpICsgX2MwLmcgKiBvZmZzZXRZO1xuICAgcmV0dXJuIGZyYWN0KHN0KTtgXG59LFxue1xuICBuYW1lOiAncmVwZWF0WCcsXG4gIHR5cGU6ICdjb29yZCcsXG4gIGlucHV0czogW1xuICAgIHtcbiAgICAgIHR5cGU6ICdmbG9hdCcsXG4gICAgICBuYW1lOiAncmVwcycsXG4gICAgICBkZWZhdWx0OiAzLFxuICAgIH0sXG57XG4gICAgICB0eXBlOiAnZmxvYXQnLFxuICAgICAgbmFtZTogJ29mZnNldCcsXG4gICAgICBkZWZhdWx0OiAwLFxuICAgIH1cbiAgXSxcbiAgZ2xzbDpcbmAgICB2ZWMyIHN0ID0gX3N0ICogdmVjMihyZXBzLCAxLjApO1xuICAgLy8gIGZsb2F0IGYgPSAgbW9kKF9zdC55LDIuMCk7XG4gICBzdC55ICs9IHN0ZXAoMS4sIG1vZChzdC54LDIuMCkpKiBvZmZzZXQ7XG4gICByZXR1cm4gZnJhY3Qoc3QpO2Bcbn0sXG57XG4gIG5hbWU6ICdtb2R1bGF0ZVJlcGVhdFgnLFxuICB0eXBlOiAnY29tYmluZUNvb3JkJyxcbiAgaW5wdXRzOiBbXG4gICAge1xuICAgICAgdHlwZTogJ2Zsb2F0JyxcbiAgICAgIG5hbWU6ICdyZXBzJyxcbiAgICAgIGRlZmF1bHQ6IDMsXG4gICAgfSxcbntcbiAgICAgIHR5cGU6ICdmbG9hdCcsXG4gICAgICBuYW1lOiAnb2Zmc2V0JyxcbiAgICAgIGRlZmF1bHQ6IDAuNSxcbiAgICB9XG4gIF0sXG4gIGdsc2w6XG5gICAgdmVjMiBzdCA9IF9zdCAqIHZlYzIocmVwcywgMS4wKTtcbiAgIC8vICBmbG9hdCBmID0gIG1vZChfc3QueSwyLjApO1xuICAgc3QueSArPSBzdGVwKDEuLCBtb2Qoc3QueCwyLjApKSArIF9jMC5yICogb2Zmc2V0O1xuICAgcmV0dXJuIGZyYWN0KHN0KTtgXG59LFxue1xuICBuYW1lOiAncmVwZWF0WScsXG4gIHR5cGU6ICdjb29yZCcsXG4gIGlucHV0czogW1xuICAgIHtcbiAgICAgIHR5cGU6ICdmbG9hdCcsXG4gICAgICBuYW1lOiAncmVwcycsXG4gICAgICBkZWZhdWx0OiAzLFxuICAgIH0sXG57XG4gICAgICB0eXBlOiAnZmxvYXQnLFxuICAgICAgbmFtZTogJ29mZnNldCcsXG4gICAgICBkZWZhdWx0OiAwLFxuICAgIH1cbiAgXSxcbiAgZ2xzbDpcbmAgICB2ZWMyIHN0ID0gX3N0ICogdmVjMigxLjAsIHJlcHMpO1xuICAgLy8gIGZsb2F0IGYgPSAgbW9kKF9zdC55LDIuMCk7XG4gICBzdC54ICs9IHN0ZXAoMS4sIG1vZChzdC55LDIuMCkpKiBvZmZzZXQ7XG4gICByZXR1cm4gZnJhY3Qoc3QpO2Bcbn0sXG57XG4gIG5hbWU6ICdtb2R1bGF0ZVJlcGVhdFknLFxuICB0eXBlOiAnY29tYmluZUNvb3JkJyxcbiAgaW5wdXRzOiBbXG4gICAge1xuICAgICAgdHlwZTogJ2Zsb2F0JyxcbiAgICAgIG5hbWU6ICdyZXBzJyxcbiAgICAgIGRlZmF1bHQ6IDMsXG4gICAgfSxcbntcbiAgICAgIHR5cGU6ICdmbG9hdCcsXG4gICAgICBuYW1lOiAnb2Zmc2V0JyxcbiAgICAgIGRlZmF1bHQ6IDAuNSxcbiAgICB9XG4gIF0sXG4gIGdsc2w6XG5gICAgdmVjMiBzdCA9IF9zdCAqIHZlYzIocmVwcywgMS4wKTtcbiAgIC8vICBmbG9hdCBmID0gIG1vZChfc3QueSwyLjApO1xuICAgc3QueCArPSBzdGVwKDEuLCBtb2Qoc3QueSwyLjApKSArIF9jMC5yICogb2Zmc2V0O1xuICAgcmV0dXJuIGZyYWN0KHN0KTtgXG59LFxue1xuICBuYW1lOiAna2FsZWlkJyxcbiAgdHlwZTogJ2Nvb3JkJyxcbiAgaW5wdXRzOiBbXG4gICAge1xuICAgICAgdHlwZTogJ2Zsb2F0JyxcbiAgICAgIG5hbWU6ICduU2lkZXMnLFxuICAgICAgZGVmYXVsdDogNCxcbiAgICB9XG4gIF0sXG4gIGdsc2w6XG5gICAgdmVjMiBzdCA9IF9zdDtcbiAgIHN0IC09IDAuNTtcbiAgIGZsb2F0IHIgPSBsZW5ndGgoc3QpO1xuICAgZmxvYXQgYSA9IGF0YW4oc3QueSwgc3QueCk7XG4gICBmbG9hdCBwaSA9IDIuKjMuMTQxNjtcbiAgIGEgPSBtb2QoYSxwaS9uU2lkZXMpO1xuICAgYSA9IGFicyhhLXBpL25TaWRlcy8yLik7XG4gICByZXR1cm4gcip2ZWMyKGNvcyhhKSwgc2luKGEpKTtgXG59LFxue1xuICBuYW1lOiAnbW9kdWxhdGVLYWxlaWQnLFxuICB0eXBlOiAnY29tYmluZUNvb3JkJyxcbiAgaW5wdXRzOiBbXG4gICAge1xuICAgICAgdHlwZTogJ2Zsb2F0JyxcbiAgICAgIG5hbWU6ICduU2lkZXMnLFxuICAgICAgZGVmYXVsdDogNCxcbiAgICB9XG4gIF0sXG4gIGdsc2w6XG5gICAgdmVjMiBzdCA9IF9zdCAtIDAuNTtcbiAgIGZsb2F0IHIgPSBsZW5ndGgoc3QpO1xuICAgZmxvYXQgYSA9IGF0YW4oc3QueSwgc3QueCk7XG4gICBmbG9hdCBwaSA9IDIuKjMuMTQxNjtcbiAgIGEgPSBtb2QoYSxwaS9uU2lkZXMpO1xuICAgYSA9IGFicyhhLXBpL25TaWRlcy8yLik7XG4gICByZXR1cm4gKF9jMC5yK3IpKnZlYzIoY29zKGEpLCBzaW4oYSkpO2Bcbn0sXG57XG4gIG5hbWU6ICdzY3JvbGwnLFxuICB0eXBlOiAnY29vcmQnLFxuICBpbnB1dHM6IFtcbiAgICB7XG4gICAgICB0eXBlOiAnZmxvYXQnLFxuICAgICAgbmFtZTogJ3Njcm9sbFgnLFxuICAgICAgZGVmYXVsdDogMC41LFxuICAgIH0sXG57XG4gICAgICB0eXBlOiAnZmxvYXQnLFxuICAgICAgbmFtZTogJ3Njcm9sbFknLFxuICAgICAgZGVmYXVsdDogMC41LFxuICAgIH0sXG57XG4gICAgICB0eXBlOiAnZmxvYXQnLFxuICAgICAgbmFtZTogJ3NwZWVkWCcsXG4gICAgICBkZWZhdWx0OiAwLFxuICAgIH0sXG57XG4gICAgICB0eXBlOiAnZmxvYXQnLFxuICAgICAgbmFtZTogJ3NwZWVkWScsXG4gICAgICBkZWZhdWx0OiAwLFxuICAgIH1cbiAgXSxcbiAgZ2xzbDpcbmBcbiAgIF9zdC54ICs9IHNjcm9sbFggKyB0aW1lKnNwZWVkWDtcbiAgIF9zdC55ICs9IHNjcm9sbFkgKyB0aW1lKnNwZWVkWTtcbiAgIHJldHVybiBmcmFjdChfc3QpO2Bcbn0sXG57XG4gIG5hbWU6ICdzY3JvbGxYJyxcbiAgdHlwZTogJ2Nvb3JkJyxcbiAgaW5wdXRzOiBbXG4gICAge1xuICAgICAgdHlwZTogJ2Zsb2F0JyxcbiAgICAgIG5hbWU6ICdzY3JvbGxYJyxcbiAgICAgIGRlZmF1bHQ6IDAuNSxcbiAgICB9LFxue1xuICAgICAgdHlwZTogJ2Zsb2F0JyxcbiAgICAgIG5hbWU6ICdzcGVlZCcsXG4gICAgICBkZWZhdWx0OiAwLFxuICAgIH1cbiAgXSxcbiAgZ2xzbDpcbmAgICBfc3QueCArPSBzY3JvbGxYICsgdGltZSpzcGVlZDtcbiAgIHJldHVybiBmcmFjdChfc3QpO2Bcbn0sXG57XG4gIG5hbWU6ICdtb2R1bGF0ZVNjcm9sbFgnLFxuICB0eXBlOiAnY29tYmluZUNvb3JkJyxcbiAgaW5wdXRzOiBbXG4gICAge1xuICAgICAgdHlwZTogJ2Zsb2F0JyxcbiAgICAgIG5hbWU6ICdzY3JvbGxYJyxcbiAgICAgIGRlZmF1bHQ6IDAuNSxcbiAgICB9LFxue1xuICAgICAgdHlwZTogJ2Zsb2F0JyxcbiAgICAgIG5hbWU6ICdzcGVlZCcsXG4gICAgICBkZWZhdWx0OiAwLFxuICAgIH1cbiAgXSxcbiAgZ2xzbDpcbmAgICBfc3QueCArPSBfYzAucipzY3JvbGxYICsgdGltZSpzcGVlZDtcbiAgIHJldHVybiBmcmFjdChfc3QpO2Bcbn0sXG57XG4gIG5hbWU6ICdzY3JvbGxZJyxcbiAgdHlwZTogJ2Nvb3JkJyxcbiAgaW5wdXRzOiBbXG4gICAge1xuICAgICAgdHlwZTogJ2Zsb2F0JyxcbiAgICAgIG5hbWU6ICdzY3JvbGxZJyxcbiAgICAgIGRlZmF1bHQ6IDAuNSxcbiAgICB9LFxue1xuICAgICAgdHlwZTogJ2Zsb2F0JyxcbiAgICAgIG5hbWU6ICdzcGVlZCcsXG4gICAgICBkZWZhdWx0OiAwLFxuICAgIH1cbiAgXSxcbiAgZ2xzbDpcbmAgICBfc3QueSArPSBzY3JvbGxZICsgdGltZSpzcGVlZDtcbiAgIHJldHVybiBmcmFjdChfc3QpO2Bcbn0sXG57XG4gIG5hbWU6ICdtb2R1bGF0ZVNjcm9sbFknLFxuICB0eXBlOiAnY29tYmluZUNvb3JkJyxcbiAgaW5wdXRzOiBbXG4gICAge1xuICAgICAgdHlwZTogJ2Zsb2F0JyxcbiAgICAgIG5hbWU6ICdzY3JvbGxZJyxcbiAgICAgIGRlZmF1bHQ6IDAuNSxcbiAgICB9LFxue1xuICAgICAgdHlwZTogJ2Zsb2F0JyxcbiAgICAgIG5hbWU6ICdzcGVlZCcsXG4gICAgICBkZWZhdWx0OiAwLFxuICAgIH1cbiAgXSxcbiAgZ2xzbDpcbmAgICBfc3QueSArPSBfYzAucipzY3JvbGxZICsgdGltZSpzcGVlZDtcbiAgIHJldHVybiBmcmFjdChfc3QpO2Bcbn0sXG57XG4gIG5hbWU6ICdhZGQnLFxuICB0eXBlOiAnY29tYmluZScsXG4gIGlucHV0czogW1xuICAgIHtcbiAgICAgIHR5cGU6ICdmbG9hdCcsXG4gICAgICBuYW1lOiAnYW1vdW50JyxcbiAgICAgIGRlZmF1bHQ6IDEsXG4gICAgfVxuICBdLFxuICBnbHNsOlxuYCAgIHJldHVybiAoX2MwK19jMSkqYW1vdW50ICsgX2MwKigxLjAtYW1vdW50KTtgXG59LFxue1xuICBuYW1lOiAnc3ViJyxcbiAgdHlwZTogJ2NvbWJpbmUnLFxuICBpbnB1dHM6IFtcbiAgICB7XG4gICAgICB0eXBlOiAnZmxvYXQnLFxuICAgICAgbmFtZTogJ2Ftb3VudCcsXG4gICAgICBkZWZhdWx0OiAxLFxuICAgIH1cbiAgXSxcbiAgZ2xzbDpcbmAgICByZXR1cm4gKF9jMC1fYzEpKmFtb3VudCArIF9jMCooMS4wLWFtb3VudCk7YFxufSxcbntcbiAgbmFtZTogJ2xheWVyJyxcbiAgdHlwZTogJ2NvbWJpbmUnLFxuICBpbnB1dHM6IFtcblxuICBdLFxuICBnbHNsOlxuYCAgIHJldHVybiB2ZWM0KG1peChfYzAucmdiLCBfYzEucmdiLCBfYzEuYSksIGNsYW1wKF9jMC5hICsgX2MxLmEsIDAuMCwgMS4wKSk7YFxufSxcbntcbiAgbmFtZTogJ2JsZW5kJyxcbiAgdHlwZTogJ2NvbWJpbmUnLFxuICBpbnB1dHM6IFtcbiAgICB7XG4gICAgICB0eXBlOiAnZmxvYXQnLFxuICAgICAgbmFtZTogJ2Ftb3VudCcsXG4gICAgICBkZWZhdWx0OiAwLjUsXG4gICAgfVxuICBdLFxuICBnbHNsOlxuYCAgIHJldHVybiBfYzAqKDEuMC1hbW91bnQpK19jMSphbW91bnQ7YFxufSxcbntcbiAgbmFtZTogJ211bHQnLFxuICB0eXBlOiAnY29tYmluZScsXG4gIGlucHV0czogW1xuICAgIHtcbiAgICAgIHR5cGU6ICdmbG9hdCcsXG4gICAgICBuYW1lOiAnYW1vdW50JyxcbiAgICAgIGRlZmF1bHQ6IDEsXG4gICAgfVxuICBdLFxuICBnbHNsOlxuYCAgIHJldHVybiBfYzAqKDEuMC1hbW91bnQpKyhfYzAqX2MxKSphbW91bnQ7YFxufSxcbntcbiAgbmFtZTogJ2RpZmYnLFxuICB0eXBlOiAnY29tYmluZScsXG4gIGlucHV0czogW1xuXG4gIF0sXG4gIGdsc2w6XG5gICAgcmV0dXJuIHZlYzQoYWJzKF9jMC5yZ2ItX2MxLnJnYiksIG1heChfYzAuYSwgX2MxLmEpKTtgXG59LFxue1xuICBuYW1lOiAnbW9kdWxhdGUnLFxuICB0eXBlOiAnY29tYmluZUNvb3JkJyxcbiAgaW5wdXRzOiBbXG4gICAge1xuICAgICAgdHlwZTogJ2Zsb2F0JyxcbiAgICAgIG5hbWU6ICdhbW91bnQnLFxuICAgICAgZGVmYXVsdDogMC4xLFxuICAgIH1cbiAgXSxcbiAgZ2xzbDpcbmAgICAvLyAgcmV0dXJuIGZyYWN0KHN0KyhfYzAueHktMC41KSphbW91bnQpO1xuICAgcmV0dXJuIF9zdCArIF9jMC54eSphbW91bnQ7YFxufSxcbntcbiAgbmFtZTogJ21vZHVsYXRlU2NhbGUnLFxuICB0eXBlOiAnY29tYmluZUNvb3JkJyxcbiAgaW5wdXRzOiBbXG4gICAge1xuICAgICAgdHlwZTogJ2Zsb2F0JyxcbiAgICAgIG5hbWU6ICdtdWx0aXBsZScsXG4gICAgICBkZWZhdWx0OiAxLFxuICAgIH0sXG57XG4gICAgICB0eXBlOiAnZmxvYXQnLFxuICAgICAgbmFtZTogJ29mZnNldCcsXG4gICAgICBkZWZhdWx0OiAxLFxuICAgIH1cbiAgXSxcbiAgZ2xzbDpcbmAgICB2ZWMyIHh5ID0gX3N0IC0gdmVjMigwLjUpO1xuICAgeHkqPSgxLjAvdmVjMihvZmZzZXQgKyBtdWx0aXBsZSpfYzAuciwgb2Zmc2V0ICsgbXVsdGlwbGUqX2MwLmcpKTtcbiAgIHh5Kz12ZWMyKDAuNSk7XG4gICByZXR1cm4geHk7YFxufSxcbntcbiAgbmFtZTogJ21vZHVsYXRlUGl4ZWxhdGUnLFxuICB0eXBlOiAnY29tYmluZUNvb3JkJyxcbiAgaW5wdXRzOiBbXG4gICAge1xuICAgICAgdHlwZTogJ2Zsb2F0JyxcbiAgICAgIG5hbWU6ICdtdWx0aXBsZScsXG4gICAgICBkZWZhdWx0OiAxMCxcbiAgICB9LFxue1xuICAgICAgdHlwZTogJ2Zsb2F0JyxcbiAgICAgIG5hbWU6ICdvZmZzZXQnLFxuICAgICAgZGVmYXVsdDogMyxcbiAgICB9XG4gIF0sXG4gIGdsc2w6XG5gICAgdmVjMiB4eSA9IHZlYzIob2Zmc2V0ICsgX2MwLngqbXVsdGlwbGUsIG9mZnNldCArIF9jMC55Km11bHRpcGxlKTtcbiAgIHJldHVybiAoZmxvb3IoX3N0ICogeHkpICsgMC41KS94eTtgXG59LFxue1xuICBuYW1lOiAnbW9kdWxhdGVSb3RhdGUnLFxuICB0eXBlOiAnY29tYmluZUNvb3JkJyxcbiAgaW5wdXRzOiBbXG4gICAge1xuICAgICAgdHlwZTogJ2Zsb2F0JyxcbiAgICAgIG5hbWU6ICdtdWx0aXBsZScsXG4gICAgICBkZWZhdWx0OiAxLFxuICAgIH0sXG57XG4gICAgICB0eXBlOiAnZmxvYXQnLFxuICAgICAgbmFtZTogJ29mZnNldCcsXG4gICAgICBkZWZhdWx0OiAwLFxuICAgIH1cbiAgXSxcbiAgZ2xzbDpcbmAgICB2ZWMyIHh5ID0gX3N0IC0gdmVjMigwLjUpO1xuICAgZmxvYXQgYW5nbGUgPSBvZmZzZXQgKyBfYzAueCAqIG11bHRpcGxlO1xuICAgeHkgPSBtYXQyKGNvcyhhbmdsZSksLXNpbihhbmdsZSksIHNpbihhbmdsZSksY29zKGFuZ2xlKSkqeHk7XG4gICB4eSArPSAwLjU7XG4gICByZXR1cm4geHk7YFxufSxcbntcbiAgbmFtZTogJ21vZHVsYXRlSHVlJyxcbiAgdHlwZTogJ2NvbWJpbmVDb29yZCcsXG4gIGlucHV0czogW1xuICAgIHtcbiAgICAgIHR5cGU6ICdmbG9hdCcsXG4gICAgICBuYW1lOiAnYW1vdW50JyxcbiAgICAgIGRlZmF1bHQ6IDEsXG4gICAgfVxuICBdLFxuICBnbHNsOlxuYCAgIHJldHVybiBfc3QgKyAodmVjMihfYzAuZyAtIF9jMC5yLCBfYzAuYiAtIF9jMC5nKSAqIGFtb3VudCAqIDEuMC9yZXNvbHV0aW9uKTtgXG59LFxue1xuICBuYW1lOiAnaW52ZXJ0JyxcbiAgdHlwZTogJ2NvbG9yJyxcbiAgaW5wdXRzOiBbXG4gICAge1xuICAgICAgdHlwZTogJ2Zsb2F0JyxcbiAgICAgIG5hbWU6ICdhbW91bnQnLFxuICAgICAgZGVmYXVsdDogMSxcbiAgICB9XG4gIF0sXG4gIGdsc2w6XG5gICAgcmV0dXJuIHZlYzQoKDEuMC1fYzAucmdiKSphbW91bnQgKyBfYzAucmdiKigxLjAtYW1vdW50KSwgX2MwLmEpO2Bcbn0sXG57XG4gIG5hbWU6ICdjb250cmFzdCcsXG4gIHR5cGU6ICdjb2xvcicsXG4gIGlucHV0czogW1xuICAgIHtcbiAgICAgIHR5cGU6ICdmbG9hdCcsXG4gICAgICBuYW1lOiAnYW1vdW50JyxcbiAgICAgIGRlZmF1bHQ6IDEuNixcbiAgICB9XG4gIF0sXG4gIGdsc2w6XG5gICAgdmVjNCBjID0gKF9jMC12ZWM0KDAuNSkpKnZlYzQoYW1vdW50KSArIHZlYzQoMC41KTtcbiAgIHJldHVybiB2ZWM0KGMucmdiLCBfYzAuYSk7YFxufSxcbntcbiAgbmFtZTogJ2JyaWdodG5lc3MnLFxuICB0eXBlOiAnY29sb3InLFxuICBpbnB1dHM6IFtcbiAgICB7XG4gICAgICB0eXBlOiAnZmxvYXQnLFxuICAgICAgbmFtZTogJ2Ftb3VudCcsXG4gICAgICBkZWZhdWx0OiAwLjQsXG4gICAgfVxuICBdLFxuICBnbHNsOlxuYCAgIHJldHVybiB2ZWM0KF9jMC5yZ2IgKyB2ZWMzKGFtb3VudCksIF9jMC5hKTtgXG59LFxue1xuICBuYW1lOiAnbWFzaycsXG4gIHR5cGU6ICdjb21iaW5lJyxcbiAgaW5wdXRzOiBbXG5cbiAgXSxcbiAgZ2xzbDpcbiAgYCAgIGZsb2F0IGEgPSBfbHVtaW5hbmNlKF9jMS5yZ2IpO1xuICByZXR1cm4gdmVjNChfYzAucmdiKmEsIGEqX2MwLmEpO2Bcbn0sXG5cbntcbiAgbmFtZTogJ2x1bWEnLFxuICB0eXBlOiAnY29sb3InLFxuICBpbnB1dHM6IFtcbiAgICB7XG4gICAgICB0eXBlOiAnZmxvYXQnLFxuICAgICAgbmFtZTogJ3RocmVzaG9sZCcsXG4gICAgICBkZWZhdWx0OiAwLjUsXG4gICAgfSxcbntcbiAgICAgIHR5cGU6ICdmbG9hdCcsXG4gICAgICBuYW1lOiAndG9sZXJhbmNlJyxcbiAgICAgIGRlZmF1bHQ6IDAuMSxcbiAgICB9XG4gIF0sXG4gIGdsc2w6XG5gICAgZmxvYXQgYSA9IHNtb290aHN0ZXAodGhyZXNob2xkLSh0b2xlcmFuY2UrMC4wMDAwMDAxKSwgdGhyZXNob2xkKyh0b2xlcmFuY2UrMC4wMDAwMDAxKSwgX2x1bWluYW5jZShfYzAucmdiKSk7XG4gICByZXR1cm4gdmVjNChfYzAucmdiKmEsIGEpO2Bcbn0sXG57XG4gIG5hbWU6ICd0aHJlc2gnLFxuICB0eXBlOiAnY29sb3InLFxuICBpbnB1dHM6IFtcbiAgICB7XG4gICAgICB0eXBlOiAnZmxvYXQnLFxuICAgICAgbmFtZTogJ3RocmVzaG9sZCcsXG4gICAgICBkZWZhdWx0OiAwLjUsXG4gICAgfSxcbntcbiAgICAgIHR5cGU6ICdmbG9hdCcsXG4gICAgICBuYW1lOiAndG9sZXJhbmNlJyxcbiAgICAgIGRlZmF1bHQ6IDAuMDQsXG4gICAgfVxuICBdLFxuICBnbHNsOlxuYCAgIHJldHVybiB2ZWM0KHZlYzMoc21vb3Roc3RlcCh0aHJlc2hvbGQtKHRvbGVyYW5jZSswLjAwMDAwMDEpLCB0aHJlc2hvbGQrKHRvbGVyYW5jZSswLjAwMDAwMDEpLCBfbHVtaW5hbmNlKF9jMC5yZ2IpKSksIF9jMC5hKTtgXG59LFxue1xuICBuYW1lOiAnY29sb3InLFxuICB0eXBlOiAnY29sb3InLFxuICBpbnB1dHM6IFtcbiAgICB7XG4gICAgICB0eXBlOiAnZmxvYXQnLFxuICAgICAgbmFtZTogJ3InLFxuICAgICAgZGVmYXVsdDogMSxcbiAgICB9LFxue1xuICAgICAgdHlwZTogJ2Zsb2F0JyxcbiAgICAgIG5hbWU6ICdnJyxcbiAgICAgIGRlZmF1bHQ6IDEsXG4gICAgfSxcbntcbiAgICAgIHR5cGU6ICdmbG9hdCcsXG4gICAgICBuYW1lOiAnYicsXG4gICAgICBkZWZhdWx0OiAxLFxuICAgIH0sXG57XG4gICAgICB0eXBlOiAnZmxvYXQnLFxuICAgICAgbmFtZTogJ2EnLFxuICAgICAgZGVmYXVsdDogMSxcbiAgICB9XG4gIF0sXG4gIGdsc2w6XG5gICAgdmVjNCBjID0gdmVjNChyLCBnLCBiLCBhKTtcbiAgIHZlYzQgcG9zID0gc3RlcCgwLjAsIGMpOyAvLyBkZXRlY3Qgd2hldGhlciBuZWdhdGl2ZVxuICAgLy8gaWYgPiAwLCByZXR1cm4gciAqIF9jMFxuICAgLy8gaWYgPCAwIHJldHVybiAoMS4wLXIpICogX2MwXG4gICByZXR1cm4gdmVjNChtaXgoKDEuMC1fYzApKmFicyhjKSwgYypfYzAsIHBvcykpO2Bcbn0sXG57XG4gIG5hbWU6ICdzYXR1cmF0ZScsXG4gIHR5cGU6ICdjb2xvcicsXG4gIGlucHV0czogW1xuICAgIHtcbiAgICAgIHR5cGU6ICdmbG9hdCcsXG4gICAgICBuYW1lOiAnYW1vdW50JyxcbiAgICAgIGRlZmF1bHQ6IDIsXG4gICAgfVxuICBdLFxuICBnbHNsOlxuYCAgIGNvbnN0IHZlYzMgVyA9IHZlYzMoMC4yMTI1LCAwLjcxNTQsIDAuMDcyMSk7XG4gICB2ZWMzIGludGVuc2l0eSA9IHZlYzMoZG90KF9jMC5yZ2IsIFcpKTtcbiAgIHJldHVybiB2ZWM0KG1peChpbnRlbnNpdHksIF9jMC5yZ2IsIGFtb3VudCksIF9jMC5hKTtgXG59LFxue1xuICBuYW1lOiAnaHVlJyxcbiAgdHlwZTogJ2NvbG9yJyxcbiAgaW5wdXRzOiBbXG4gICAge1xuICAgICAgdHlwZTogJ2Zsb2F0JyxcbiAgICAgIG5hbWU6ICdodWUnLFxuICAgICAgZGVmYXVsdDogMC40LFxuICAgIH1cbiAgXSxcbiAgZ2xzbDpcbmAgICB2ZWMzIGMgPSBfcmdiVG9Ic3YoX2MwLnJnYik7XG4gICBjLnIgKz0gaHVlO1xuICAgLy8gIGMuciA9IGZyYWN0KGMucik7XG4gICByZXR1cm4gdmVjNChfaHN2VG9SZ2IoYyksIF9jMC5hKTtgXG59LFxue1xuICBuYW1lOiAnY29sb3JhbWEnLFxuICB0eXBlOiAnY29sb3InLFxuICBpbnB1dHM6IFtcbiAgICB7XG4gICAgICB0eXBlOiAnZmxvYXQnLFxuICAgICAgbmFtZTogJ2Ftb3VudCcsXG4gICAgICBkZWZhdWx0OiAwLjAwNSxcbiAgICB9XG4gIF0sXG4gIGdsc2w6XG5gICAgdmVjMyBjID0gX3JnYlRvSHN2KF9jMC5yZ2IpO1xuICAgYyArPSB2ZWMzKGFtb3VudCk7XG4gICBjID0gX2hzdlRvUmdiKGMpO1xuICAgYyA9IGZyYWN0KGMpO1xuICAgcmV0dXJuIHZlYzQoYywgX2MwLmEpO2Bcbn0sXG57XG4gIG5hbWU6ICdwcmV2JyxcbiAgdHlwZTogJ3NyYycsXG4gIGlucHV0czogW1xuXG4gIF0sXG4gIGdsc2w6XG5gICAgcmV0dXJuIHRleHR1cmUyRChwcmV2QnVmZmVyLCBmcmFjdChfc3QpKTtgXG59LFxue1xuICBuYW1lOiAnc3VtJyxcbiAgdHlwZTogJ2NvbG9yJyxcbiAgaW5wdXRzOiBbXG4gICAge1xuICAgICAgdHlwZTogJ3ZlYzQnLFxuICAgICAgbmFtZTogJ3NjYWxlJyxcbiAgICAgIGRlZmF1bHQ6IDEsXG4gICAgfVxuICBdLFxuICBnbHNsOlxuYCAgIHZlYzQgdiA9IF9jMCAqIHM7XG4gICByZXR1cm4gdi5yICsgdi5nICsgdi5iICsgdi5hO1xuICAgfVxuICAgZmxvYXQgc3VtKHZlYzIgX3N0LCB2ZWM0IHMpIHsgLy8gdmVjNCBpcyBub3QgYSB0eXBvLCBiZWNhdXNlIGFyZ3VtZW50IHR5cGUgaXMgbm90IG92ZXJsb2FkZWRcbiAgIHZlYzIgdiA9IF9zdC54eSAqIHMueHk7XG4gICByZXR1cm4gdi54ICsgdi55O2Bcbn0sXG57XG4gIG5hbWU6ICdyJyxcbiAgdHlwZTogJ2NvbG9yJyxcbiAgaW5wdXRzOiBbXG4gICAge1xuICAgICAgdHlwZTogJ2Zsb2F0JyxcbiAgICAgIG5hbWU6ICdzY2FsZScsXG4gICAgICBkZWZhdWx0OiAxLFxuICAgIH0sXG57XG4gICAgICB0eXBlOiAnZmxvYXQnLFxuICAgICAgbmFtZTogJ29mZnNldCcsXG4gICAgICBkZWZhdWx0OiAwLFxuICAgIH1cbiAgXSxcbiAgZ2xzbDpcbmAgICByZXR1cm4gdmVjNChfYzAuciAqIHNjYWxlICsgb2Zmc2V0KTtgXG59LFxue1xuICBuYW1lOiAnZycsXG4gIHR5cGU6ICdjb2xvcicsXG4gIGlucHV0czogW1xuICAgIHtcbiAgICAgIHR5cGU6ICdmbG9hdCcsXG4gICAgICBuYW1lOiAnc2NhbGUnLFxuICAgICAgZGVmYXVsdDogMSxcbiAgICB9LFxue1xuICAgICAgdHlwZTogJ2Zsb2F0JyxcbiAgICAgIG5hbWU6ICdvZmZzZXQnLFxuICAgICAgZGVmYXVsdDogMCxcbiAgICB9XG4gIF0sXG4gIGdsc2w6XG5gICAgcmV0dXJuIHZlYzQoX2MwLmcgKiBzY2FsZSArIG9mZnNldCk7YFxufSxcbntcbiAgbmFtZTogJ2InLFxuICB0eXBlOiAnY29sb3InLFxuICBpbnB1dHM6IFtcbiAgICB7XG4gICAgICB0eXBlOiAnZmxvYXQnLFxuICAgICAgbmFtZTogJ3NjYWxlJyxcbiAgICAgIGRlZmF1bHQ6IDEsXG4gICAgfSxcbntcbiAgICAgIHR5cGU6ICdmbG9hdCcsXG4gICAgICBuYW1lOiAnb2Zmc2V0JyxcbiAgICAgIGRlZmF1bHQ6IDAsXG4gICAgfVxuICBdLFxuICBnbHNsOlxuYCAgIHJldHVybiB2ZWM0KF9jMC5iICogc2NhbGUgKyBvZmZzZXQpO2Bcbn0sXG57XG4gIG5hbWU6ICdhJyxcbiAgdHlwZTogJ2NvbG9yJyxcbiAgaW5wdXRzOiBbXG4gICAge1xuICAgICAgdHlwZTogJ2Zsb2F0JyxcbiAgICAgIG5hbWU6ICdzY2FsZScsXG4gICAgICBkZWZhdWx0OiAxLFxuICAgIH0sXG57XG4gICAgICB0eXBlOiAnZmxvYXQnLFxuICAgICAgbmFtZTogJ29mZnNldCcsXG4gICAgICBkZWZhdWx0OiAwLFxuICAgIH1cbiAgXSxcbiAgZ2xzbDpcbmAgICByZXR1cm4gdmVjNChfYzAuYSAqIHNjYWxlICsgb2Zmc2V0KTtgXG59LFxue1xuICAgIG5hbWU6ICdtYXAnLFxuICAgIHR5cGU6ICdjb2xvcicsXG4gICAgaW5wdXRzOiBbXG4gICAgICAgIHtuYW1lOiAnc3RhcnQxJywgdHlwZTogJ2Zsb2F0JywgZGVmYXVsdDogTmFOfSxcbiAgICAgICAge25hbWU6ICdzdG9wMScsIHR5cGU6ICdmbG9hdCcsIGRlZmF1bHQ6IE5hTn0sXG4gICAgICAgIHtuYW1lOiAnc3RhcnQyJywgdHlwZTogJ2Zsb2F0JywgZGVmYXVsdDogMH0sXG4gICAgICAgIHtuYW1lOiAnc3RvcDInLCB0eXBlOiAnZmxvYXQnLCBkZWZhdWx0OiAxfSxcbiAgICBdLFxuICAgIGdsc2w6IGByZXR1cm4gKF9jMCAtIHN0YXJ0MSkgLyAoc3RvcDEgLSBzdGFydDEpICogKHN0b3AyIC0gc3RhcnQyKSArIHN0YXJ0MjtgXG59LFxue1xuICAgIG5hbWU6ICdjbGVhcicsXG4gICAgdHlwZTogJ2NsZWFyJyxcbiAgICBpbnB1dHM6IFtdLFxuICAgIGdsc2w6IGBgLFxufSxcbntcbiAgICBuYW1lOiAnZmFkZScsXG4gICAgdHlwZTogJ2NsZWFyJyxcbiAgICBpbnB1dHM6IFtcbiAgICAgICAge25hbWU6ICdhbW91bnQnLCB0eXBlOiAnZmxvYXQnLCBkZWZhdWx0OiAnMC4wMSd9LFxuICAgICAgICB7bmFtZTogJ2NhbWVyYScsIHR5cGU6ICdib29sJywgZGVmYXVsdDogZmFsc2V9LFxuICAgIF0sXG4gICAgZ2xzbDogYGAsXG59LFxue1xuICAgIG5hbWU6ICdnbHNsJyxcbiAgICB0eXBlOiAnZ2xzbCcsXG4gICAgaW5wdXRzOiBbXSxcbiAgICBnbHNsOiBgYCxcbn0sXG4gICAgLy8gdG9kbzogbWFrZSB0aGVzZSB0eXBlIGFnbm9zdGljIChuZXcgdHlwZTogJ3V0aWwnPylcbiAgICB7XG4gICAgICAgIG5hbWU6ICdzaW4nLFxuICAgICAgICBnbHNsTmFtZTogJ19zaW4nLFxuICAgICAgICB0eXBlOiAnY29vcmQnLFxuICAgICAgICBpbnB1dHM6IFtcbiAgICAgICAgICAgIHtuYW1lOiAnZnJlcScsIHR5cGU6ICdmbG9hdCcsIGRlZmF1bHQ6IDF9LFxuICAgICAgICAgICAge25hbWU6ICdhbXAnLCB0eXBlOiAnZmxvYXQnLCBkZWZhdWx0OiAwLjV9LFxuICAgICAgICBdLFxuICAgICAgICBnbHNsOiBgcmV0dXJuIHNpbihfc3QgKiBUV09fUEkgKiBmcmVxKSAqIGFtcDtgLFxuICAgIH0sXG4gICAge1xuICAgICAgICBuYW1lOiAnY29zJyxcbiAgICAgICAgZ2xzbE5hbWU6ICdfY29zJyxcbiAgICAgICAgdHlwZTogJ2Nvb3JkJyxcbiAgICAgICAgaW5wdXRzOiBbXG4gICAgICAgICAgICB7bmFtZTogJ2ZyZXEnLCB0eXBlOiAnZmxvYXQnLCBkZWZhdWx0OiAxfSxcbiAgICAgICAgICAgIHtuYW1lOiAnYW1wJywgdHlwZTogJ2Zsb2F0JywgZGVmYXVsdDogMC41fSxcbiAgICAgICAgXSxcbiAgICAgICAgZ2xzbDogYHJldHVybiBjb3MoX3N0ICogVFdPX1BJICogZnJlcSkgKiBhbXA7YCxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgbmFtZTogJ3RhbicsXG4gICAgICAgIGdsc2xOYW1lOiAnX3RhbicsXG4gICAgICAgIHR5cGU6ICdjb29yZCcsXG4gICAgICAgIGlucHV0czogW1xuICAgICAgICAgICAge25hbWU6ICdmcmVxJywgdHlwZTogJ2Zsb2F0JywgZGVmYXVsdDogMX0sXG4gICAgICAgICAgICB7bmFtZTogJ2FtcCcsIHR5cGU6ICdmbG9hdCcsIGRlZmF1bHQ6IDAuNX0sXG4gICAgICAgIF0sXG4gICAgICAgIGdsc2w6IGByZXR1cm4gdGFuKF9zdCAqIFBJICogZnJlcSkgKiBhbXA7YCxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgbmFtZTogJ2F0YW4nLFxuICAgICAgICBnbHNsTmFtZTogJ19hdGFuJyxcbiAgICAgICAgdHlwZTogJ2Nvb3JkJyxcbiAgICAgICAgaW5wdXRzOiBbXG4gICAgICAgICAgICB7bmFtZTogJ2ZyZXEnLCB0eXBlOiAnZmxvYXQnLCBkZWZhdWx0OiAxfSxcbiAgICAgICAgICAgIHtuYW1lOiAnYW1wJywgdHlwZTogJ2Zsb2F0JywgZGVmYXVsdDogMC41fSxcbiAgICAgICAgXSxcbiAgICAgICAgZ2xzbDogYHJldHVybiBhdGFuKF9zdCAqIFBJICogZnJlcSkgKiBhbXA7YCxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgbmFtZTogJ3BvdycsXG4gICAgICAgIGdsc2xOYW1lOiAnX3BvdycsXG4gICAgICAgIHR5cGU6ICdjb29yZCcsXG4gICAgICAgIGlucHV0czogW1xuICAgICAgICAgICAge25hbWU6ICdwb3dlcicsIHR5cGU6ICd2ZWMyJywgZGVmYXVsdDogMn0sXG4gICAgICAgIF0sXG4gICAgICAgIGdsc2w6IGByZXR1cm4gcG93KF9zdCwgcG93ZXIpO2BcbiAgICB9XG5dXG4iLCIvLyBmdW5jdGlvbnMgdGhhdCBhcmUgb25seSB1c2VkIHdpdGhpbiBvdGhlciBmdW5jdGlvbnNcblxuZXhwb3J0IGRlZmF1bHQge1xuICBfcGk6IHtcbiAgICB0eXBlOiAndXRpbCcsXG4gICAgZ2xzbDogYCNkZWZpbmUgUEkgMy4xNDE1OTI2NTM1ODk3OTMyMzg0NjI2NDMzODMyNzk1YCxcbiAgfSxcbiAgX3R3b3BpOiB7XG4gICAgdHlwZTogJ3V0aWwnLFxuICAgIGdsc2w6IGAjZGVmaW5lIFRXT19QSSA2LjI4MzE4NTMwNzE3OTU4NmAsXG4gIH0sXG4gIF9sdW1pbmFuY2U6IHtcbiAgICB0eXBlOiAndXRpbCcsXG4gICAgZ2xzbDogYGZsb2F0IF9sdW1pbmFuY2UodmVjMyByZ2Ipe1xuICAgICAgY29uc3QgdmVjMyBXID0gdmVjMygwLjIxMjUsIDAuNzE1NCwgMC4wNzIxKTtcbiAgICAgIHJldHVybiBkb3QocmdiLCBXKTtcbiAgICB9YFxuICB9LFxuICBfcGVybXV0ZToge1xuICAgIHR5cGU6ICd1dGlsJyxcbiAgICBnbHNsOiBgdmVjNCBfcGVybXV0ZSh2ZWM0IHgpe3JldHVybiBtb2QoKCh4KjM0LjApKzEuMCkqeCwgMjg5LjApO31gXG4gIH0sXG4gIF9tb2QyODk6IHtcbiAgICB0eXBlOiAndXRpbCcsXG4gICAgZ2xzbDogYFxudmVjMyBfbW9kMjg5KHZlYzMgeClcbntcbiAgcmV0dXJuIHggLSBmbG9vcih4ICogKDEuMCAvIDI4OS4wKSkgKiAyODkuMDtcbn1cblxudmVjNCBfbW9kMjg5KHZlYzQgeClcbntcbiAgcmV0dXJuIHggLSBmbG9vcih4ICogKDEuMCAvIDI4OS4wKSkgKiAyODkuMDtcbn1cbmBcbiAgfSxcbiAgX3RheWxvckludlNxcnQ6IHtcbiAgICB0eXBlOiAndXRpbCcsXG4gICAgZ2xzbDogYHZlYzQgX3RheWxvckludlNxcnQodmVjNCByKXtyZXR1cm4gMS43OTI4NDI5MTQwMDE1OSAtIDAuODUzNzM0NzIwOTUzMTQgKiByO31gXG4gIH0sXG4gIC8vXHRTaW1wbGV4IDNEIE5vaXNlXG4gIC8vXHRieSBJYW4gTWNFd2FuLCBBc2hpbWEgQXJ0c1xuICBfbm9pc2U6IHtcbiAgICB0eXBlOiAndXRpbCcsXG4gICAgZ2xzbDogYFxuICBmbG9hdCBfbm9pc2UodmVjMyB2KXtcbiAgICBjb25zdCB2ZWMyICBDID0gdmVjMigxLjAvNi4wLCAxLjAvMy4wKSA7XG4gICAgY29uc3QgdmVjNCAgRCA9IHZlYzQoMC4wLCAwLjUsIDEuMCwgMi4wKTtcblxuICAvLyBGaXJzdCBjb3JuZXJcbiAgICB2ZWMzIGkgID0gZmxvb3IodiArIGRvdCh2LCBDLnl5eSkgKTtcbiAgICB2ZWMzIHgwID0gICB2IC0gaSArIGRvdChpLCBDLnh4eCkgO1xuXG4gIC8vIE90aGVyIGNvcm5lcnNcbiAgICB2ZWMzIGcgPSBzdGVwKHgwLnl6eCwgeDAueHl6KTtcbiAgICB2ZWMzIGwgPSAxLjAgLSBnO1xuICAgIHZlYzMgaTEgPSBtaW4oIGcueHl6LCBsLnp4eSApO1xuICAgIHZlYzMgaTIgPSBtYXgoIGcueHl6LCBsLnp4eSApO1xuXG4gICAgLy8gIHgwID0geDAgLSAwLiArIDAuMCAqIENcbiAgICB2ZWMzIHgxID0geDAgLSBpMSArIDEuMCAqIEMueHh4O1xuICAgIHZlYzMgeDIgPSB4MCAtIGkyICsgMi4wICogQy54eHg7XG4gICAgdmVjMyB4MyA9IHgwIC0gMS4gKyAzLjAgKiBDLnh4eDtcblxuICAvLyBQZXJtdXRhdGlvbnNcbiAgICBpID0gbW9kKGksIDI4OS4wICk7XG4gICAgdmVjNCBwID0gX3Blcm11dGUoIF9wZXJtdXRlKCBfcGVybXV0ZShcbiAgICAgICAgICAgICAgIGkueiArIHZlYzQoMC4wLCBpMS56LCBpMi56LCAxLjAgKSlcbiAgICAgICAgICAgICArIGkueSArIHZlYzQoMC4wLCBpMS55LCBpMi55LCAxLjAgKSlcbiAgICAgICAgICAgICArIGkueCArIHZlYzQoMC4wLCBpMS54LCBpMi54LCAxLjAgKSk7XG5cbiAgLy8gR3JhZGllbnRzXG4gIC8vICggTipOIHBvaW50cyB1bmlmb3JtbHkgb3ZlciBhIHNxdWFyZSwgbWFwcGVkIG9udG8gYW4gb2N0YWhlZHJvbi4pXG4gICAgZmxvYXQgbl8gPSAxLjAvNy4wOyAvLyBOPTdcbiAgICB2ZWMzICBucyA9IG5fICogRC53eXogLSBELnh6eDtcblxuICAgIHZlYzQgaiA9IHAgLSA0OS4wICogZmxvb3IocCAqIG5zLnogKm5zLnopOyAgLy8gIG1vZChwLE4qTilcblxuICAgIHZlYzQgeF8gPSBmbG9vcihqICogbnMueik7XG4gICAgdmVjNCB5XyA9IGZsb29yKGogLSA3LjAgKiB4XyApOyAgICAvLyBtb2QoaixOKVxuXG4gICAgdmVjNCB4ID0geF8gKm5zLnggKyBucy55eXl5O1xuICAgIHZlYzQgeSA9IHlfICpucy54ICsgbnMueXl5eTtcbiAgICB2ZWM0IGggPSAxLjAgLSBhYnMoeCkgLSBhYnMoeSk7XG5cbiAgICB2ZWM0IGIwID0gdmVjNCggeC54eSwgeS54eSApO1xuICAgIHZlYzQgYjEgPSB2ZWM0KCB4Lnp3LCB5Lnp3ICk7XG5cbiAgICB2ZWM0IHMwID0gZmxvb3IoYjApKjIuMCArIDEuMDtcbiAgICB2ZWM0IHMxID0gZmxvb3IoYjEpKjIuMCArIDEuMDtcbiAgICB2ZWM0IHNoID0gLXN0ZXAoaCwgdmVjNCgwLjApKTtcblxuICAgIHZlYzQgYTAgPSBiMC54enl3ICsgczAueHp5dypzaC54eHl5IDtcbiAgICB2ZWM0IGExID0gYjEueHp5dyArIHMxLnh6eXcqc2guenp3dyA7XG5cbiAgICB2ZWMzIHAwID0gdmVjMyhhMC54eSxoLngpO1xuICAgIHZlYzMgcDEgPSB2ZWMzKGEwLnp3LGgueSk7XG4gICAgdmVjMyBwMiA9IHZlYzMoYTEueHksaC56KTtcbiAgICB2ZWMzIHAzID0gdmVjMyhhMS56dyxoLncpO1xuXG4gIC8vTm9ybWFsaXNlIGdyYWRpZW50c1xuICAgIHZlYzQgbm9ybSA9IF90YXlsb3JJbnZTcXJ0KHZlYzQoZG90KHAwLHAwKSwgZG90KHAxLHAxKSwgZG90KHAyLCBwMiksIGRvdChwMyxwMykpKTtcbiAgICBwMCAqPSBub3JtLng7XG4gICAgcDEgKj0gbm9ybS55O1xuICAgIHAyICo9IG5vcm0uejtcbiAgICBwMyAqPSBub3JtLnc7XG5cbiAgLy8gTWl4IGZpbmFsIG5vaXNlIHZhbHVlXG4gICAgdmVjNCBtID0gbWF4KDAuNiAtIHZlYzQoZG90KHgwLHgwKSwgZG90KHgxLHgxKSwgZG90KHgyLHgyKSwgZG90KHgzLHgzKSksIDAuMCk7XG4gICAgbSA9IG0gKiBtO1xuICAgIHJldHVybiA0Mi4wICogZG90KCBtKm0sIHZlYzQoIGRvdChwMCx4MCksIGRvdChwMSx4MSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG90KHAyLHgyKSwgZG90KHAzLHgzKSApICk7XG4gIH1cbiAgICBgXG4gIH0sXG5cbiAgX3JnYlRvSHN2OiB7XG4gICAgdHlwZTogJ3V0aWwnLFxuICAgIGdsc2w6IGB2ZWMzIF9yZ2JUb0hzdih2ZWMzIGMpe1xuICAgICAgICAgICAgdmVjNCBLID0gdmVjNCgwLjAsIC0xLjAgLyAzLjAsIDIuMCAvIDMuMCwgLTEuMCk7XG4gICAgICAgICAgICB2ZWM0IHAgPSBtaXgodmVjNChjLmJnLCBLLnd6KSwgdmVjNChjLmdiLCBLLnh5KSwgc3RlcChjLmIsIGMuZykpO1xuICAgICAgICAgICAgdmVjNCBxID0gbWl4KHZlYzQocC54eXcsIGMuciksIHZlYzQoYy5yLCBwLnl6eCksIHN0ZXAocC54LCBjLnIpKTtcblxuICAgICAgICAgICAgZmxvYXQgZCA9IHEueCAtIG1pbihxLncsIHEueSk7XG4gICAgICAgICAgICBmbG9hdCBlID0gMS4wZS0xMDtcbiAgICAgICAgICAgIHJldHVybiB2ZWMzKGFicyhxLnogKyAocS53IC0gcS55KSAvICg2LjAgKiBkICsgZSkpLCBkIC8gKHEueCArIGUpLCBxLngpO1xuICAgICAgICB9YFxuICB9LFxuICBfaHN2VG9SZ2I6IHtcbiAgICB0eXBlOiAndXRpbCcsXG4gICAgZ2xzbDogYHZlYzMgX2hzdlRvUmdiKHZlYzMgYyl7XG4gICAgICAgIHZlYzQgSyA9IHZlYzQoMS4wLCAyLjAgLyAzLjAsIDEuMCAvIDMuMCwgMy4wKTtcbiAgICAgICAgdmVjMyBwID0gYWJzKGZyYWN0KGMueHh4ICsgSy54eXopICogNi4wIC0gSy53d3cpO1xuICAgICAgICByZXR1cm4gYy56ICogbWl4KEsueHh4LCBjbGFtcChwIC0gSy54eHgsIDAuMCwgMS4wKSwgYy55KTtcbiAgICB9YFxuICB9XG59XG4iLCJpbXBvcnQgZ2xzbCBmcm9tICdnbHNsaWZ5J1xuaW1wb3J0IHtHcmlkR2VvbWV0cnl9IGZyb20gXCIuL2dlb21ldHJpZXMvR3JpZEdlb21ldHJ5LmpzXCI7XG5pbXBvcnQgKiBhcyBUSFJFRSBmcm9tIFwidGhyZWUvc3JjL2dlb21ldHJpZXMvR2VvbWV0cmllcy5qc1wiO1xuaW1wb3J0IHZlY3Rvcml6ZVRleHQgZnJvbSBcInZlY3Rvcml6ZS10ZXh0XCI7XG5cbmNvbnN0IHBvaW50c1ZlcnQgPSBnbHNsKFwiLi9zaGFkZXJzL3ZlcnQvcG9pbnRzLnZlcnRcIik7XG5jb25zdCBsaW5lc1ZlcnQgPSBnbHNsKFwiLi9zaGFkZXJzL3ZlcnQvbGluZXMudmVydFwiKTtcbmNvbnN0IGxpbmVzdHJpcFZlcnQgPSBnbHNsKFwiLi9zaGFkZXJzL3ZlcnQvbGluZXN0cmlwLnZlcnRcIik7XG5jb25zdCBsaW5lbG9vcFZlcnQgPSBnbHNsKFwiLi9zaGFkZXJzL3ZlcnQvbGluZWxvb3AudmVydFwiKTtcblxuY29uc3QgcGRvdHNGcmFnID0gZ2xzbChcIi4vc2hhZGVycy9wZG90cy5mcmFnXCIpO1xuY29uc3QgcHNxdWFyZXNGcmFnID0gZ2xzbChcIi4vc2hhZGVycy9wc3F1YXJlcy5mcmFnXCIpO1xuY29uc3QgcGxpbmVzRnJhZyA9IGdsc2woXCIuL3NoYWRlcnMvcGxpbmVzLmZyYWdcIik7XG5jb25zdCBwbGluZXN0cmlwRnJhZyA9IGdsc2woXCIuL3NoYWRlcnMvcGxpbmVzdHJpcC5mcmFnXCIpO1xuY29uc3QgcGxpbmVsb29wRnJhZyA9IGdsc2woXCIuL3NoYWRlcnMvcGxpbmVsb29wLmZyYWdcIik7XG5jb25zdCBwbGFuZVZlcnQgPSBnbHNsKFwiLi9zaGFkZXJzL3BsYW5lLnZlcnRcIik7XG5jb25zdCBwaG9uZ0ZyYWcgPSBnbHNsKFwiLi9zaGFkZXJzL3Bob25nLmZyYWdcIik7XG5jb25zdCBsYW1iZXJ0RnJhZyA9IGdsc2woXCIuL3NoYWRlcnMvbGFtYmVydC5mcmFnXCIpO1xuXG4vLyB0b2RvOiByZXNwZWN0IG1ha2VHbG9iYWw/XG5PYmplY3QuYXNzaWduKHdpbmRvdywge0dyaWRHZW9tZXRyeSwgdmVjdG9yaXplVGV4dH0pO1xuT2JqZWN0LmFzc2lnbih3aW5kb3csIFRIUkVFKTtcblxuZXhwb3J0IGRlZmF1bHQgKGh5KSA9PiBbXG4gICAge1xuICAgICAgICBuYW1lOiAncGRvdHMnLFxuICAgICAgICB0eXBlOiAndmVydCcsXG4gICAgICAgIGlucHV0czogW1xuICAgICAgICAgICAge25hbWU6ICdwb3MnLCB0eXBlOiAndmVjMycsIGRlZmF1bHQ6IGh5LmdyYWRpZW50KCl9LFxuICAgICAgICAgICAge25hbWU6ICdzaXplJywgdHlwZTogJ2Zsb2F0JywgZGVmYXVsdDogMTB9LFxuICAgICAgICAgICAge25hbWU6ICdjb2xvcicsIHR5cGU6ICd2ZWM0JywgZGVmYXVsdDogMX0sXG4gICAgICAgICAgICB7bmFtZTogJ2ZhZGUnLCB0eXBlOiAnZmxvYXQnLCBkZWZhdWx0OiAwLjAyNX0sXG4gICAgICAgIF0sXG4gICAgICAgIGdsc2w6IHBkb3RzRnJhZyxcbiAgICAgICAgdmVydDogcG9pbnRzVmVydCxcbiAgICAgICAgcHJpbWl0aXZlOiAncG9pbnRzJyxcbiAgICAgICAgYmxlbmRNb2RlOiB0cnVlLFxuICAgICAgICBnZW9tZXRyeTogR3JpZEdlb21ldHJ5LFxuICAgIH0sXG4gICAge1xuICAgICAgICBuYW1lOiAncHNxdWFyZXMnLFxuICAgICAgICB0eXBlOiAndmVydCcsXG4gICAgICAgIGlucHV0czogW1xuICAgICAgICAgICAge25hbWU6ICdwb3MnLCB0eXBlOiAndmVjMycsIGRlZmF1bHQ6IGh5LmdyYWRpZW50KCl9LFxuICAgICAgICAgICAge25hbWU6ICdzaXplJywgdHlwZTogJ2Zsb2F0JywgZGVmYXVsdDogMX0sXG4gICAgICAgICAgICB7bmFtZTogJ2NvbG9yJywgdHlwZTogJ3ZlYzQnLCBkZWZhdWx0OiAxfSxcbiAgICAgICAgICAgIHtuYW1lOiAnZmFkZScsIHR5cGU6ICdmbG9hdCcsIGRlZmF1bHQ6IDAuMDI1fSxcbiAgICAgICAgXSxcbiAgICAgICAgZ2xzbDogcHNxdWFyZXNGcmFnLFxuICAgICAgICB2ZXJ0OiBwb2ludHNWZXJ0LFxuICAgICAgICBwcmltaXRpdmU6ICdwb2ludHMnLFxuICAgICAgICBibGVuZE1vZGU6IHRydWUsXG4gICAgICAgIGdlb21ldHJ5OiBHcmlkR2VvbWV0cnksXG4gICAgfSxcbiAgICB7XG4gICAgICAgIG5hbWU6ICdwbGluZXMnLFxuICAgICAgICB0eXBlOiAndmVydCcsXG4gICAgICAgIGlucHV0czogW1xuICAgICAgICAgICAge25hbWU6ICdwb3MnLCB0eXBlOiAndmVjMycsIGRlZmF1bHQ6IGh5LmdyYWRpZW50KCl9LFxuICAgICAgICAgICAge25hbWU6ICdjb2xvcicsIHR5cGU6ICd2ZWM0JywgZGVmYXVsdDogMX0sXG4gICAgICAgIF0sXG4gICAgICAgIGdsc2w6IHBsaW5lc0ZyYWcsXG4gICAgICAgIHZlcnQ6IGxpbmVzVmVydCxcbiAgICAgICAgcHJpbWl0aXZlOiAnbGluZXMnLFxuICAgICAgICBnZW9tZXRyeTogR3JpZEdlb21ldHJ5LFxuICAgIH0sXG4gICAge1xuICAgICAgICBuYW1lOiAncGxpbmVzdHJpcCcsXG4gICAgICAgIHR5cGU6ICd2ZXJ0JyxcbiAgICAgICAgaW5wdXRzOiBbXG4gICAgICAgICAgICB7bmFtZTogJ3BvcycsIHR5cGU6ICd2ZWMzJywgZGVmYXVsdDogaHkuc29saWQoaHkubm9pc2UoMSkueCwgaHkubm9pc2UoMikueSwgaHkubm9pc2UoMykueikubWFwKC0xLDEsMCwxKX0sXG4gICAgICAgICAgICB7bmFtZTogJ2NvbG9yJywgdHlwZTogJ3ZlYzQnLCBkZWZhdWx0OiAxfSxcbiAgICAgICAgXSxcbiAgICAgICAgZ2xzbDogcGxpbmVzdHJpcEZyYWcsXG4gICAgICAgIHZlcnQ6IGxpbmVzdHJpcFZlcnQsXG4gICAgICAgIHByaW1pdGl2ZTogJ2xpbmUgc3RyaXAnLFxuICAgICAgICBnZW9tZXRyeTogR3JpZEdlb21ldHJ5LFxuICAgIH0sXG4gICAge1xuICAgICAgICBuYW1lOiAncGxpbmVsb29wJyxcbiAgICAgICAgdHlwZTogJ3ZlcnQnLFxuICAgICAgICBpbnB1dHM6IFtcbiAgICAgICAgICAgIHtuYW1lOiAncG9zJywgdHlwZTogJ3ZlYzMnLCBkZWZhdWx0OiBoeS5zb2xpZChoeS5ub2lzZSgxKS54LCBoeS5ub2lzZSgyKS55LCBoeS5ub2lzZSgzKS56KS5tYXAoLTEsMSwwLDEpfSxcbiAgICAgICAgICAgIHtuYW1lOiAnY29sb3InLCB0eXBlOiAndmVjNCcsIGRlZmF1bHQ6IDF9LFxuICAgICAgICBdLFxuICAgICAgICBnbHNsOiBwbGluZWxvb3BGcmFnLFxuICAgICAgICB2ZXJ0OiBsaW5lbG9vcFZlcnQsXG4gICAgICAgIHByaW1pdGl2ZTogJ2xpbmUgbG9vcCcsXG4gICAgICAgIGdlb21ldHJ5OiBHcmlkR2VvbWV0cnksXG4gICAgfSxcbiAgICB7XG4gICAgICAgIG5hbWU6ICdwbGFuZScsXG4gICAgICAgIHR5cGU6ICd2ZXJ0JyxcbiAgICAgICAgaW5wdXRzOiBbXG4gICAgICAgICAgICB7bmFtZTogJ3BvcycsIHR5cGU6ICd2ZWMzJywgZGVmYXVsdDogaHkuZ3JhZGllbnQoKX0sXG4gICAgICAgICAgICB7bmFtZTogJ2NvbG9yJywgdHlwZTogJ3ZlYzQnLCBkZWZhdWx0OiAxfSxcbiAgICAgICAgXSxcbiAgICAgICAgZ2xzbDogYHJldHVybiBjb2xvcjtgLFxuICAgICAgICB2ZXJ0OiBwbGFuZVZlcnQsXG4gICAgICAgIHByaW1pdGl2ZTogJ3RyaWFuZ2xlcycsXG4gICAgICAgIGdlb21ldHJ5OiBUSFJFRS5QbGFuZUdlb21ldHJ5LFxuICAgIH0sXG4gICAge1xuICAgICAgICBuYW1lOiAnYm94JyxcbiAgICAgICAgdHlwZTogJ3ZlcnQnLFxuICAgICAgICBpbnB1dHM6IFtcbiAgICAgICAgICAgIHtuYW1lOiAnY29sb3InLCB0eXBlOiAndmVjNCcsIGRlZmF1bHQ6IDF9LFxuICAgICAgICBdLFxuICAgICAgICBnbHNsOiBgcmV0dXJuIGNvbG9yO2AsXG4gICAgICAgIHByaW1pdGl2ZTogJ3RyaWFuZ2xlcycsXG4gICAgICAgIGdlb21ldHJ5OiBUSFJFRS5Cb3hHZW9tZXRyeSxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgbmFtZTogJ3NwaGVyZScsXG4gICAgICAgIHR5cGU6ICd2ZXJ0JyxcbiAgICAgICAgaW5wdXRzOiBbXG4gICAgICAgICAgICB7bmFtZTogJ2NvbG9yJywgdHlwZTogJ3ZlYzQnLCBkZWZhdWx0OiAxfSxcbiAgICAgICAgXSxcbiAgICAgICAgZ2xzbDogYHJldHVybiBjb2xvcjtgLFxuICAgICAgICBwcmltaXRpdmU6ICd0cmlhbmdsZXMnLFxuICAgICAgICBnZW9tZXRyeTogVEhSRUUuU3BoZXJlR2VvbWV0cnksXG4gICAgfSxcbiAgICB7XG4gICAgICAgIG5hbWU6ICdjeWxpbmRlcicsXG4gICAgICAgIHR5cGU6ICd2ZXJ0JyxcbiAgICAgICAgaW5wdXRzOiBbXG4gICAgICAgICAgICB7bmFtZTogJ2NvbG9yJywgdHlwZTogJ3ZlYzQnLCBkZWZhdWx0OiAxfSxcbiAgICAgICAgXSxcbiAgICAgICAgZ2xzbDogYHJldHVybiBjb2xvcjtgLFxuICAgICAgICBwcmltaXRpdmU6ICd0cmlhbmdsZXMnLFxuICAgICAgICBnZW9tZXRyeTogVEhSRUUuQ3lsaW5kZXJHZW9tZXRyeSxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgbmFtZTogJ2NvbmUnLFxuICAgICAgICB0eXBlOiAndmVydCcsXG4gICAgICAgIGlucHV0czogW1xuICAgICAgICAgICAge25hbWU6ICdjb2xvcicsIHR5cGU6ICd2ZWM0JywgZGVmYXVsdDogMX0sXG4gICAgICAgIF0sXG4gICAgICAgIGdsc2w6IGByZXR1cm4gY29sb3I7YCxcbiAgICAgICAgcHJpbWl0aXZlOiAndHJpYW5nbGVzJyxcbiAgICAgICAgZ2VvbWV0cnk6IFRIUkVFLkNvbmVHZW9tZXRyeSxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgbmFtZTogJ2VkZ2VzJyxcbiAgICAgICAgdHlwZTogJ3ZlcnQnLFxuICAgICAgICBpbnB1dHM6IFtcbiAgICAgICAgICAgIHtuYW1lOiAnY29sb3InLCB0eXBlOiAndmVjNCcsIGRlZmF1bHQ6IDF9LFxuICAgICAgICBdLFxuICAgICAgICBnbHNsOiBgcmV0dXJuIGNvbG9yO2AsXG4gICAgICAgIHByaW1pdGl2ZTogJ2xpbmVzJyxcbiAgICAgICAgZ2VvbWV0cnk6IFRIUkVFLkVkZ2VzR2VvbWV0cnksXG4gICAgfSxcbiAgICB7XG4gICAgICAgIG5hbWU6ICd0ZXh0JyxcbiAgICAgICAgdHlwZTogJ3ZlcnQnLFxuICAgICAgICBpbnB1dHM6IFtcbiAgICAgICAgICAgIHtuYW1lOiAnY29sb3InLCB0eXBlOiAndmVjNCcsIGRlZmF1bHQ6IDF9LFxuICAgICAgICBdLFxuICAgICAgICBnbHNsOiBgcmV0dXJuIGNvbG9yO2AsXG4gICAgICAgIGdlb21ldHJ5OiB2ZWN0b3JpemVUZXh0LFxuICAgICAgICB1c2VVVjogZmFsc2UsXG4gICAgICAgIHVzZU5vcm1hbDogZmFsc2UsXG4gICAgfSxcbiAgICAvLyBsaWdodGluZyByZWxhdGVkIGZ1bmN0aW9uc1xuICAgIHtcbiAgICAgICAgbmFtZTogJ2xhbWJlcnQnLFxuICAgICAgICB0eXBlOiAnY29sb3InLFxuICAgICAgICBpbnB1dHM6IFtcbiAgICAgICAgICAgIHtuYW1lOiAnaW50ZW5zaXR5JywgdHlwZTogJ2Zsb2F0JywgZGVmYXVsdDogMX0sXG4gICAgICAgICAgICB7bmFtZTogJ2xpZ2h0RGlyZWN0aW9uJywgdHlwZTogJ3ZlYzMnLCBkZWZhdWx0OiBbMS4wLCAxLjAsIC0xLjBdfSxcbiAgICAgICAgXSxcbiAgICAgICAgZ2xzbDogbGFtYmVydEZyYWcsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIG5hbWU6ICdwaG9uZycsXG4gICAgICAgIHR5cGU6ICdjb2xvcicsXG4gICAgICAgIGlucHV0czogW1xuICAgICAgICAgICAge25hbWU6ICdzaGluaW5lc3MnLCB0eXBlOiAnZmxvYXQnLCBkZWZhdWx0OiA0fSxcbiAgICAgICAgICAgIHtuYW1lOiAnbGlnaHREaXJlY3Rpb24nLCB0eXBlOiAndmVjMycsIGRlZmF1bHQ6IFsxLjAsIDEuMCwgLTEuMF19LFxuICAgICAgICAgICAge25hbWU6ICdsaWdodENvbG9yJywgdHlwZTogJ3ZlYzMnLCBkZWZhdWx0OiBbMS4wLCAxLjAsIDEuMF19LFxuICAgICAgICAgICAge25hbWU6ICdhbWJpZW50Q29sb3InLCB0eXBlOiAndmVjMycsIGRlZmF1bHQ6IFswLjEsIDAuMSwgMC4xXX0sXG4gICAgICAgICAgICB7bmFtZTogJ3NwZWN1bGFyQ29sb3InLCB0eXBlOiAndmVjMycsIGRlZmF1bHQ6IFsxLjAsIDEuMCwgMS4wXX0sXG4gICAgICAgIF0sXG4gICAgICAgIGdsc2w6IHBob25nRnJhZyxcbiAgICB9LFxuXTtcbiIsImltcG9ydCBXZWJjYW0gZnJvbSAnLi9saWIvd2ViY2FtLmpzJ1xuaW1wb3J0IFNjcmVlbiBmcm9tICcuL2xpYi9zY3JlZW5tZWRpYS5qcydcblxuY2xhc3MgSHlkcmFTb3VyY2Uge1xuICBjb25zdHJ1Y3RvciAoeyByZWdsLCB3aWR0aCwgaGVpZ2h0LCBwYiwgbGFiZWwgPSBcIlwifSkge1xuICAgIHRoaXMubGFiZWwgPSBsYWJlbFxuICAgIHRoaXMucmVnbCA9IHJlZ2xcbiAgICB0aGlzLnNyYyA9IG51bGxcbiAgICB0aGlzLmR5bmFtaWMgPSB0cnVlXG4gICAgdGhpcy53aWR0aCA9IHdpZHRoXG4gICAgdGhpcy5oZWlnaHQgPSBoZWlnaHRcbiAgICB0aGlzLnRleCA9IHRoaXMucmVnbC50ZXh0dXJlKHtcbiAgICAgIC8vICBzaGFwZTogW3dpZHRoLCBoZWlnaHRdXG4gICAgICBzaGFwZTogWyAxLCAxIF1cbiAgICB9KVxuICAgIHRoaXMucGIgPSBwYlxuICB9XG5cbiAgaW5pdCAob3B0cywgcGFyYW1zKSB7XG4gICAgaWYgKCdzcmMnIGluIG9wdHMpIHtcbiAgICAgIHRoaXMuc3JjID0gb3B0cy5zcmNcbiAgICAgIHRoaXMudGV4ID0gdGhpcy5yZWdsLnRleHR1cmUoeyBkYXRhOiB0aGlzLnNyYywgLi4ucGFyYW1zIH0pXG4gICAgfVxuICAgIGlmICgnZHluYW1pYycgaW4gb3B0cykgdGhpcy5keW5hbWljID0gb3B0cy5keW5hbWljXG4gIH1cblxuICBpbml0Q2FtIChpbmRleCwgcGFyYW1zKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXNcbiAgICBXZWJjYW0oaW5kZXgpXG4gICAgICAudGhlbihyZXNwb25zZSA9PiB7XG4gICAgICAgIHNlbGYuc3JjID0gcmVzcG9uc2UudmlkZW9cbiAgICAgICAgc2VsZi5keW5hbWljID0gdHJ1ZVxuICAgICAgICBzZWxmLnRleCA9IHNlbGYucmVnbC50ZXh0dXJlKHsgZGF0YTogc2VsZi5zcmMsIC4uLnBhcmFtcyB9KVxuICAgICAgfSlcbiAgICAgIC5jYXRjaChlcnIgPT4gY29uc29sZS5sb2coJ2NvdWxkIG5vdCBnZXQgY2FtZXJhJywgZXJyKSlcbiAgfVxuXG4gIGluaXRWaWRlbyAodXJsID0gJycsIHBhcmFtcykge1xuICAgIC8vIGNvbnN0IHNlbGYgPSB0aGlzXG4gICAgY29uc3QgdmlkID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndmlkZW8nKVxuICAgIHZpZC5jcm9zc09yaWdpbiA9ICdhbm9ueW1vdXMnXG4gICAgdmlkLmF1dG9wbGF5ID0gdHJ1ZVxuICAgIHZpZC5sb29wID0gdHJ1ZVxuICAgIHZpZC5tdXRlZCA9IHRydWUgLy8gbXV0ZSBpbiBvcmRlciB0byBsb2FkIHdpdGhvdXQgdXNlciBpbnRlcmFjdGlvblxuICAgIGNvbnN0IG9ubG9hZCA9IHZpZC5hZGRFdmVudExpc3RlbmVyKCdsb2FkZWRkYXRhJywgKCkgPT4ge1xuICAgICAgdGhpcy5zcmMgPSB2aWRcbiAgICAgIHZpZC5wbGF5KClcbiAgICAgIHRoaXMudGV4ID0gdGhpcy5yZWdsLnRleHR1cmUoeyBkYXRhOiB0aGlzLnNyYywgLi4ucGFyYW1zfSlcbiAgICAgIHRoaXMuZHluYW1pYyA9IHRydWVcbiAgICB9KVxuICAgIHZpZC5zcmMgPSB1cmxcbiAgfVxuXG4gIGluaXRJbWFnZSAodXJsID0gJycsIHBhcmFtcykge1xuICAgIGNvbnN0IGltZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2ltZycpXG4gICAgaW1nLmNyb3NzT3JpZ2luID0gJ2Fub255bW91cydcbiAgICBpbWcuc3JjID0gdXJsXG4gICAgaW1nLm9ubG9hZCA9ICgpID0+IHtcbiAgICAgIHRoaXMuc3JjID0gaW1nXG4gICAgICB0aGlzLmR5bmFtaWMgPSBmYWxzZVxuICAgICAgdGhpcy50ZXggPSB0aGlzLnJlZ2wudGV4dHVyZSh7IGRhdGE6IHRoaXMuc3JjLCAuLi5wYXJhbXN9KVxuICAgIH1cbiAgfVxuXG4gIGluaXRTdHJlYW0gKHN0cmVhbU5hbWUsIHBhcmFtcykge1xuICAgIC8vICBjb25zb2xlLmxvZyhcImluaXRpbmcgc3RyZWFtIVwiLCBzdHJlYW1OYW1lKVxuICAgIGxldCBzZWxmID0gdGhpc1xuICAgIGlmIChzdHJlYW1OYW1lICYmIHRoaXMucGIpIHtcbiAgICAgIHRoaXMucGIuaW5pdFNvdXJjZShzdHJlYW1OYW1lKVxuXG4gICAgICB0aGlzLnBiLm9uKCdnb3QgdmlkZW8nLCBmdW5jdGlvbiAobmljaywgdmlkZW8pIHtcbiAgICAgICAgaWYgKG5pY2sgPT09IHN0cmVhbU5hbWUpIHtcbiAgICAgICAgICBzZWxmLnNyYyA9IHZpZGVvXG4gICAgICAgICAgc2VsZi5keW5hbWljID0gdHJ1ZVxuICAgICAgICAgIHNlbGYudGV4ID0gc2VsZi5yZWdsLnRleHR1cmUoeyBkYXRhOiBzZWxmLnNyYywgLi4ucGFyYW1zfSlcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICAvLyBpbmRleCBvbmx5IHJlbGV2YW50IGluIGF0b20taHlkcmEgKyBkZXNrdG9wIGFwcHNcbiAgaW5pdFNjcmVlbiAoaW5kZXggPSAwLCBwYXJhbXMpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpc1xuICAgIFNjcmVlbigpXG4gICAgICAudGhlbihmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgICAgc2VsZi5zcmMgPSByZXNwb25zZS52aWRlb1xuICAgICAgICBzZWxmLnRleCA9IHNlbGYucmVnbC50ZXh0dXJlKHsgZGF0YTogc2VsZi5zcmMsIC4uLnBhcmFtc30pXG4gICAgICAgIHNlbGYuZHluYW1pYyA9IHRydWVcbiAgICAgICAgLy8gIGNvbnNvbGUubG9nKFwicmVjZWl2ZWQgc2NyZWVuIGlucHV0XCIpXG4gICAgICB9KVxuICAgICAgLmNhdGNoKGVyciA9PiBjb25zb2xlLmxvZygnY291bGQgbm90IGdldCBzY3JlZW4nLCBlcnIpKVxuICB9XG5cbiAgcmVzaXplICh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgdGhpcy53aWR0aCA9IHdpZHRoXG4gICAgdGhpcy5oZWlnaHQgPSBoZWlnaHRcbiAgfVxuXG4gIGNsZWFyICgpIHtcbiAgICBpZiAodGhpcy5zcmMgJiYgdGhpcy5zcmMuc3JjT2JqZWN0KSB7XG4gICAgICBpZiAodGhpcy5zcmMuc3JjT2JqZWN0LmdldFRyYWNrcykge1xuICAgICAgICB0aGlzLnNyYy5zcmNPYmplY3QuZ2V0VHJhY2tzKCkuZm9yRWFjaCh0cmFjayA9PiB0cmFjay5zdG9wKCkpXG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuc3JjID0gbnVsbFxuICAgIHRoaXMudGV4ID0gdGhpcy5yZWdsLnRleHR1cmUoeyBzaGFwZTogWyAxLCAxIF0gfSlcbiAgfVxuXG4gIHRpY2sgKHRpbWUpIHtcbiAgICAvLyAgY29uc29sZS5sb2codGhpcy5zcmMsIHRoaXMudGV4LndpZHRoLCB0aGlzLnRleC5oZWlnaHQpXG4gICAgaWYgKHRoaXMuc3JjICE9PSBudWxsICYmIHRoaXMuZHluYW1pYyA9PT0gdHJ1ZSkge1xuICAgICAgaWYgKHRoaXMuc3JjLnZpZGVvV2lkdGggJiYgdGhpcy5zcmMudmlkZW9XaWR0aCAhPT0gdGhpcy50ZXgud2lkdGgpIHtcbiAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgdGhpcy5zcmMudmlkZW9XaWR0aCxcbiAgICAgICAgICB0aGlzLnNyYy52aWRlb0hlaWdodCxcbiAgICAgICAgICB0aGlzLnRleC53aWR0aCxcbiAgICAgICAgICB0aGlzLnRleC5oZWlnaHRcbiAgICAgICAgKVxuICAgICAgICB0aGlzLnRleC5yZXNpemUodGhpcy5zcmMudmlkZW9XaWR0aCwgdGhpcy5zcmMudmlkZW9IZWlnaHQpXG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnNyYy53aWR0aCAmJiB0aGlzLnNyYy53aWR0aCAhPT0gdGhpcy50ZXgud2lkdGgpIHtcbiAgICAgICAgdGhpcy50ZXgucmVzaXplKHRoaXMuc3JjLndpZHRoLCB0aGlzLnNyYy5oZWlnaHQpXG4gICAgICB9XG5cbiAgICAgIHRoaXMudGV4LnN1YmltYWdlKHRoaXMuc3JjKVxuICAgIH1cbiAgfVxuXG4gIGdldFRleHR1cmUgKCkge1xuICAgIHJldHVybiB0aGlzLnRleFxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEh5ZHJhU291cmNlXG4iLCJcbmltcG9ydCBPdXRwdXQgZnJvbSAnLi9vdXRwdXQuanMnXG5pbXBvcnQgbG9vcCBmcm9tICdyYWYtbG9vcCdcbmltcG9ydCBTb3VyY2UgZnJvbSAnLi9oeWRyYS1zb3VyY2UuanMnXG5pbXBvcnQgTW91c2VUb29scyBmcm9tICcuL2xpYi9tb3VzZS5qcydcbmltcG9ydCBBdWRpbyBmcm9tICcuL2xpYi9hdWRpby5qcydcbmltcG9ydCBWaWRSZWNvcmRlciBmcm9tICcuL2xpYi92aWRlby1yZWNvcmRlci5qcydcbmltcG9ydCBBcnJheVV0aWxzIGZyb20gJy4vbGliL2FycmF5LXV0aWxzLmpzJ1xuLy8gaW1wb3J0IHN0cnVkZWwgZnJvbSAnLi9saWIvc3RydWRlbC5qcydcbmltcG9ydCBTYW5kYm94IGZyb20gJy4vZXZhbC1zYW5kYm94LmpzJ1xuaW1wb3J0IEdlbmVyYXRvciBmcm9tICcuL2dlbmVyYXRvci1mYWN0b3J5LmpzJ1xuaW1wb3J0IHJlZ2wgZnJvbSAncmVnbCdcbi8vIGNvbnN0IHdpbmRvdyA9IGdsb2JhbC53aW5kb3dcblxuXG5cbmNvbnN0IE1vdXNlID0gTW91c2VUb29scygpXG4vLyB0byBkbzogYWRkIGFiaWxpdHkgdG8gcGFzcyBpbiBjZXJ0YWluIHVuaWZvcm1zIGFuZCB0cmFuc2Zvcm1zXG5jbGFzcyBIeWRyYVJlbmRlcmVyIHtcblxuICBjb25zdHJ1Y3RvciAoe1xuICAgIHBiID0gbnVsbCxcbiAgICB3aWR0aCA9IDEyODAsXG4gICAgaGVpZ2h0ID0gNzIwLFxuICAgIG51bVNvdXJjZXMgPSA0LFxuICAgIG51bU91dHB1dHMgPSA0LFxuICAgIG1ha2VHbG9iYWwgPSB0cnVlLFxuICAgIGF1dG9Mb29wID0gdHJ1ZSxcbiAgICBkZXRlY3RBdWRpbyA9IHRydWUsXG4gICAgZW5hYmxlU3RyZWFtQ2FwdHVyZSA9IHRydWUsXG4gICAgY2FudmFzLFxuICAgIHByZWNpc2lvbixcbiAgICBleHRlbmRUcmFuc2Zvcm1zID0ge30gLy8gYWRkIHlvdXIgb3duIGZ1bmN0aW9ucyBvbiBpbml0XG4gIH0gPSB7fSkge1xuXG4gICAgQXJyYXlVdGlscy5pbml0KClcblxuICAgIHRoaXMucGIgPSBwYlxuXG4gICAgdGhpcy53aWR0aCA9IHdpZHRoXG4gICAgdGhpcy5oZWlnaHQgPSBoZWlnaHRcbiAgICB0aGlzLnJlbmRlckFsbCA9IGZhbHNlXG4gICAgdGhpcy5kZXRlY3RBdWRpbyA9IGRldGVjdEF1ZGlvXG5cbiAgICB0aGlzLl9pbml0Q2FudmFzKGNhbnZhcylcblxuICAgIC8vZ2xvYmFsLndpbmRvdy50ZXN0ID0gJ2hpJ1xuICAgIC8vIG9iamVjdCB0aGF0IGNvbnRhaW5zIGFsbCBwcm9wZXJ0aWVzIHRoYXQgd2lsbCBiZSBtYWRlIGF2YWlsYWJsZSBvbiB0aGUgZ2xvYmFsIGNvbnRleHQgYW5kIGR1cmluZyBsb2NhbCBldmFsdWF0aW9uXG4gICAgdGhpcy5zeW50aCA9IHtcbiAgICAgIHRpbWU6IDAsXG4gICAgICBicG06IDMwLFxuICAgICAgd2lkdGg6IHRoaXMud2lkdGgsXG4gICAgICBoZWlnaHQ6IHRoaXMuaGVpZ2h0LFxuICAgICAgZnBzOiB1bmRlZmluZWQsXG4gICAgICBzdGF0czoge1xuICAgICAgICBmcHM6IDBcbiAgICAgIH0sXG4gICAgICBzcGVlZDogMSxcbiAgICAgIG1vdXNlOiBNb3VzZSxcbiAgICAgIHJlbmRlcjogdGhpcy5fcmVuZGVyLmJpbmQodGhpcyksXG4gICAgICBzZXRSZXNvbHV0aW9uOiB0aGlzLnNldFJlc29sdXRpb24uYmluZCh0aGlzKSxcbiAgICAgIHVwZGF0ZTogKGR0KSA9PiB7fSwvLyB1c2VyIGRlZmluZWQgdXBkYXRlIGZ1bmN0aW9uXG4gICAgICBodXNoOiB0aGlzLmh1c2guYmluZCh0aGlzKSxcbiAgICAgIHRpY2s6IHRoaXMudGljay5iaW5kKHRoaXMpXG4gICAgfVxuXG4gICAgaWYgKG1ha2VHbG9iYWwpIHdpbmRvdy5sb2FkU2NyaXB0ID0gdGhpcy5sb2FkU2NyaXB0XG5cblxuICAgIHRoaXMudGltZVNpbmNlTGFzdFVwZGF0ZSA9IDBcbiAgICB0aGlzLl90aW1lID0gMCAvLyBmb3IgaW50ZXJuYWwgdXNlLCBvbmx5IHRvIHVzZSBmb3IgZGVjaWRpbmcgd2hlbiB0byByZW5kZXIgZnJhbWVzXG5cbiAgICAvLyBvbmx5IGFsbG93IHZhbGlkIHByZWNpc2lvbiBvcHRpb25zXG4gICAgbGV0IHByZWNpc2lvbk9wdGlvbnMgPSBbJ2xvd3AnLCdtZWRpdW1wJywnaGlnaHAnXVxuICAgIGlmKHByZWNpc2lvbiAmJiBwcmVjaXNpb25PcHRpb25zLmluY2x1ZGVzKHByZWNpc2lvbi50b0xvd2VyQ2FzZSgpKSkge1xuICAgICAgdGhpcy5wcmVjaXNpb24gPSBwcmVjaXNpb24udG9Mb3dlckNhc2UoKVxuICAgICAgLy9cbiAgICAgIC8vIGlmKCFwcmVjaXNpb25WYWxpZCl7XG4gICAgICAvLyAgIGNvbnNvbGUud2FybignW2h5ZHJhLXN5bnRoIHdhcm5pbmddXFxuQ29uc3RydWN0b3Igd2FzIHByb3ZpZGVkIGFuIGludmFsaWQgZmxvYXRpbmcgcG9pbnQgcHJlY2lzaW9uIHZhbHVlIG9mIFwiJyArIHByZWNpc2lvbiArICdcIi4gVXNpbmcgZGVmYXVsdCB2YWx1ZSBvZiBcIm1lZGl1bXBcIiBpbnN0ZWFkLicpXG4gICAgICAvLyB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBpc0lPUyA9XG4gICAgKC9pUGFkfGlQaG9uZXxpUG9kLy50ZXN0KG5hdmlnYXRvci5wbGF0Zm9ybSkgfHxcbiAgICAgIChuYXZpZ2F0b3IucGxhdGZvcm0gPT09ICdNYWNJbnRlbCcgJiYgbmF2aWdhdG9yLm1heFRvdWNoUG9pbnRzID4gMSkpICYmXG4gICAgIXdpbmRvdy5NU1N0cmVhbTtcbiAgICAgIHRoaXMucHJlY2lzaW9uID0gaXNJT1MgPyAnaGlnaHAnIDogJ21lZGl1bXAnXG4gICAgfVxuXG5cblxuICAgIHRoaXMuZXh0ZW5kVHJhbnNmb3JtcyA9IGV4dGVuZFRyYW5zZm9ybXNcblxuICAgIC8vIGJvb2xlYW4gdG8gc3RvcmUgd2hlbiB0byBzYXZlIHNjcmVlbnNob3RcbiAgICB0aGlzLnNhdmVGcmFtZSA9IGZhbHNlXG5cbiAgICAvLyBpZiBzdHJlYW0gY2FwdHVyZSBpcyBlbmFibGVkLCB0aGlzIG9iamVjdCBjb250YWlucyB0aGUgY2FwdHVyZSBzdHJlYW1cbiAgICB0aGlzLmNhcHR1cmVTdHJlYW0gPSBudWxsXG5cbiAgICB0aGlzLmdlbmVyYXRvciA9IHVuZGVmaW5lZFxuXG4gICAgdGhpcy5faW5pdFJlZ2woKVxuICAgIHRoaXMuX2luaXRPdXRwdXRzKG51bU91dHB1dHMpXG4gICAgdGhpcy5faW5pdFNvdXJjZXMobnVtU291cmNlcylcbiAgICB0aGlzLl9nZW5lcmF0ZUdsc2xUcmFuc2Zvcm1zKClcblxuICAgIHRoaXMuc3ludGguc2NyZWVuY2FwID0gKCkgPT4ge1xuICAgICAgdGhpcy5zYXZlRnJhbWUgPSB0cnVlXG4gICAgfVxuXG4gICAgaWYgKGVuYWJsZVN0cmVhbUNhcHR1cmUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMuY2FwdHVyZVN0cmVhbSA9IHRoaXMuY2FudmFzLmNhcHR1cmVTdHJlYW0oMjUpXG4gICAgICAgIC8vIHRvIGRvOiBlbmFibGUgY2FwdHVyZSBzdHJlYW0gb2Ygc3BlY2lmaWMgc291cmNlcyBhbmQgb3V0cHV0c1xuICAgICAgICB0aGlzLnN5bnRoLnZpZFJlY29yZGVyID0gbmV3IFZpZFJlY29yZGVyKHRoaXMuY2FwdHVyZVN0cmVhbSlcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdbaHlkcmEtc3ludGggd2FybmluZ11cXG5uZXcgTWVkaWFTb3VyY2UoKSBpcyBub3QgY3VycmVudGx5IHN1cHBvcnRlZCBvbiBpT1MuJylcbiAgICAgICAgY29uc29sZS5lcnJvcihlKVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmKGRldGVjdEF1ZGlvKSB0aGlzLl9pbml0QXVkaW8oKVxuXG4gICAgaWYoYXV0b0xvb3ApIGxvb3AodGhpcy50aWNrLmJpbmQodGhpcykpLnN0YXJ0KClcblxuICAgIC8vIGZpbmFsIGFyZ3VtZW50IGlzIHByb3BlcnRpZXMgdGhhdCB0aGUgdXNlciBjYW4gc2V0LCBhbGwgb3RoZXJzIGFyZSB0cmVhdGVkIGFzIHJlYWQtb25seVxuICAgIHRoaXMuc2FuZGJveCA9IG5ldyBTYW5kYm94KHRoaXMuc3ludGgsIG1ha2VHbG9iYWwsIFsnc3BlZWQnLCAndXBkYXRlJywgJ2JwbScsICdmcHMnXSlcbiAgfVxuXG4gIGV2YWwoY29kZSkge1xuICAgIHRoaXMuc2FuZGJveC5ldmFsKGNvZGUpXG4gIH1cblxuICBnZXRTY3JlZW5JbWFnZShjYWxsYmFjaykge1xuICAgIHRoaXMuaW1hZ2VDYWxsYmFjayA9IGNhbGxiYWNrXG4gICAgdGhpcy5zYXZlRnJhbWUgPSB0cnVlXG4gIH1cblxuICBodXNoKCkge1xuICAgIHRoaXMucy5mb3JFYWNoKChzb3VyY2UpID0+IHtcbiAgICAgIHNvdXJjZS5jbGVhcigpXG4gICAgfSlcbiAgICB0aGlzLm8uZm9yRWFjaCgob3V0cHV0KSA9PiB7XG4gICAgICB0aGlzLnN5bnRoLnNvbGlkKDAsIDAsIDAsIDApLm91dChvdXRwdXQpXG4gICAgfSlcbiAgICB0aGlzLnN5bnRoLnJlbmRlcih0aGlzLm9bMF0pXG4gICAgLy8gdGhpcy5zeW50aC51cGRhdGUgPSAoZHQpID0+IHt9XG4gICAgdGhpcy5zYW5kYm94LnNldCgndXBkYXRlJywgKGR0KSA9PiB7fSlcbiAgfVxuXG4gIGxvYWRTY3JpcHQodXJsID0gXCJcIiwgb25jZSA9IHRydWUpIHtcbiAgIGNvbnN0IHNlbGYgPSB0aGlzIHx8IHdpbmRvdztcbiAgIGNvbnN0IHAgPSBuZXcgUHJvbWlzZSgocmVzLCByZWopID0+IHtcbiAgICAgaWYgKG9uY2UpIHtcbiAgICAgICBzZWxmLmxvYWRlZFNjcmlwdHMgfHwgKHNlbGYubG9hZGVkU2NyaXB0cyA9IHt9KTtcbiAgICAgICBpZiAoc2VsZi5sb2FkZWRTY3JpcHRzW3VybF0pIHtcbiAgICAgICAgIHJlcygpO1xuICAgICAgICAgcmV0dXJuO1xuICAgICAgIH1cbiAgICAgfVxuICAgICB2YXIgc2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKTtcbiAgICAgc2NyaXB0Lm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICBjb25zb2xlLmxvZyhgbG9hZGVkIHNjcmlwdCAke3VybH1gKTtcbiAgICAgICBpZiAob25jZSkge1xuICAgICAgICAgc2VsZi5sb2FkZWRTY3JpcHRzW3VybF0gPSB0cnVlO1xuICAgICAgIH1cbiAgICAgICByZXMoKTtcbiAgICAgfTtcbiAgICAgc2NyaXB0Lm9uZXJyb3IgPSAoZXJyKSA9PiB7XG4gICAgICAgY29uc29sZS5sb2coYGVycm9yIGxvYWRpbmcgc2NyaXB0ICR7dXJsfWAsIFwibG9nLWVycm9yXCIpO1xuICAgICAgIHJlcygpXG4gICAgIH07XG4gICAgIHNjcmlwdC5zcmMgPSB1cmw7XG4gICAgIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcbiAgIH0pO1xuICAgcmV0dXJuIHA7XG4gfVxuXG4gIHNldFJlc29sdXRpb24od2lkdGgsIGhlaWdodCkge1xuICAvLyAgY29uc29sZS5sb2cod2lkdGgsIGhlaWdodClcbiAgICB0aGlzLmNhbnZhcy53aWR0aCA9IHdpZHRoXG4gICAgdGhpcy5jYW52YXMuaGVpZ2h0ID0gaGVpZ2h0XG4gICAgdGhpcy53aWR0aCA9IHdpZHRoIC8vIGlzIHRoaXMgbmVjZXNzYXJ5P1xuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0IC8vID9cbiAgICB0aGlzLnNhbmRib3guc2V0KCd3aWR0aCcsIHdpZHRoKVxuICAgIHRoaXMuc2FuZGJveC5zZXQoJ2hlaWdodCcsIGhlaWdodClcbiAgICB0aGlzLm8uZm9yRWFjaCgob3V0cHV0KSA9PiB7XG4gICAgICBvdXRwdXQucmVzaXplKHdpZHRoLCBoZWlnaHQpXG4gICAgfSlcbiAgICB0aGlzLnMuZm9yRWFjaCgoc291cmNlKSA9PiB7XG4gICAgICBzb3VyY2UucmVzaXplKHdpZHRoLCBoZWlnaHQpXG4gICAgfSlcbiAgICB0aGlzLnJlZ2wuX3JlZnJlc2goKVxuICAgICBjb25zb2xlLmxvZyh0aGlzLmNhbnZhcy53aWR0aClcbiAgfVxuXG4gIGNhbnZhc1RvSW1hZ2UgKGNhbGxiYWNrKSB7XG4gICAgY29uc3QgYSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKVxuICAgIGEuc3R5bGUuZGlzcGxheSA9ICdub25lJ1xuXG4gICAgbGV0IGQgPSBuZXcgRGF0ZSgpXG4gICAgYS5kb3dubG9hZCA9IGBoeWRyYS0ke2QuZ2V0RnVsbFllYXIoKX0tJHtkLmdldE1vbnRoKCkgKyAxfS0ke2QuZ2V0RGF0ZSgpfS0ke2QuZ2V0SG91cnMoKX0uJHtkLmdldE1pbnV0ZXMoKX0uJHtkLmdldFNlY29uZHMoKX0ucG5nYFxuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoYSlcbiAgICB2YXIgc2VsZiA9IHRoaXNcbiAgICB0aGlzLmNhbnZhcy50b0Jsb2IoIChibG9iKSA9PiB7XG4gICAgICAgIGlmKHNlbGYuaW1hZ2VDYWxsYmFjayl7XG4gICAgICAgICAgc2VsZi5pbWFnZUNhbGxiYWNrKGJsb2IpXG4gICAgICAgICAgZGVsZXRlIHNlbGYuaW1hZ2VDYWxsYmFja1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGEuaHJlZiA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYilcbiAgICAgICAgICBjb25zb2xlLmxvZyhhLmhyZWYpXG4gICAgICAgICAgYS5jbGljaygpXG4gICAgICAgIH1cbiAgICB9LCAnaW1hZ2UvcG5nJylcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoYSk7XG4gICAgICB3aW5kb3cuVVJMLnJldm9rZU9iamVjdFVSTChhLmhyZWYpO1xuICAgIH0sIDMwMCk7XG4gIH1cblxuICBfaW5pdEF1ZGlvICgpIHtcbiAgICBjb25zdCB0aGF0ID0gdGhpc1xuICAgIHRoaXMuc3ludGguYSA9IG5ldyBBdWRpbyh7XG4gICAgICBudW1CaW5zOiA0LFxuICAgICAgcGFyZW50RWw6IHRoaXMuY2FudmFzLnBhcmVudE5vZGVcbiAgICAgIC8vIGNoYW5nZUxpc3RlbmVyOiAoe2F1ZGlvfSkgPT4ge1xuICAgICAgLy8gICB0aGF0LmEgPSBhdWRpby5iaW5zLm1hcCgoXywgaW5kZXgpID0+XG4gICAgICAvLyAgICAgKHNjYWxlID0gMSwgb2Zmc2V0ID0gMCkgPT4gKCkgPT4gKGF1ZGlvLmZmdFtpbmRleF0gKiBzY2FsZSArIG9mZnNldClcbiAgICAgIC8vICAgKVxuICAgICAgLy9cbiAgICAgIC8vICAgaWYgKHRoYXQubWFrZUdsb2JhbCkge1xuICAgICAgLy8gICAgIHRoYXQuYS5mb3JFYWNoKChhLCBpbmRleCkgPT4ge1xuICAgICAgLy8gICAgICAgY29uc3QgYW5hbWUgPSBgYSR7aW5kZXh9YFxuICAgICAgLy8gICAgICAgd2luZG93W2FuYW1lXSA9IGFcbiAgICAgIC8vICAgICB9KVxuICAgICAgLy8gICB9XG4gICAgICAvLyB9XG4gICAgfSlcbiAgfVxuXG4gIC8vIGNyZWF0ZSBtYWluIG91dHB1dCBjYW52YXMgYW5kIGFkZCB0byBzY3JlZW5cbiAgX2luaXRDYW52YXMgKGNhbnZhcykge1xuICAgIGlmIChjYW52YXMpIHtcbiAgICAgIHRoaXMuY2FudmFzID0gY2FudmFzXG4gICAgICB0aGlzLndpZHRoID0gY2FudmFzLndpZHRoXG4gICAgICB0aGlzLmhlaWdodCA9IGNhbnZhcy5oZWlnaHRcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKVxuICAgICAgdGhpcy5jYW52YXMud2lkdGggPSB0aGlzLndpZHRoXG4gICAgICB0aGlzLmNhbnZhcy5oZWlnaHQgPSB0aGlzLmhlaWdodFxuICAgICAgdGhpcy5jYW52YXMuc3R5bGUud2lkdGggPSAnMTAwJSdcbiAgICAgIHRoaXMuY2FudmFzLnN0eWxlLmhlaWdodCA9ICcxMDAlJ1xuICAgICAgdGhpcy5jYW52YXMuc3R5bGUuaW1hZ2VSZW5kZXJpbmcgPSAncGl4ZWxhdGVkJ1xuICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0aGlzLmNhbnZhcylcbiAgICB9XG4gIH1cblxuICBfaW5pdFJlZ2wgKCkge1xuICAgIHRoaXMucmVnbCA9IHJlZ2woe1xuICAgIC8vICBwcm9maWxlOiB0cnVlLFxuICAgICAgY2FudmFzOiB0aGlzLmNhbnZhcyxcbiAgICAgIHBpeGVsUmF0aW86IDEvLyxcbiAgICAgIC8vIGV4dGVuc2lvbnM6IFtcbiAgICAgIC8vICAgJ29lc190ZXh0dXJlX2hhbGZfZmxvYXQnLFxuICAgICAgLy8gICAnb2VzX3RleHR1cmVfaGFsZl9mbG9hdF9saW5lYXInXG4gICAgICAvLyBdLFxuICAgICAgLy8gb3B0aW9uYWxFeHRlbnNpb25zOiBbXG4gICAgICAvLyAgICdvZXNfdGV4dHVyZV9mbG9hdCcsXG4gICAgICAvLyAgICdvZXNfdGV4dHVyZV9mbG9hdF9saW5lYXInXG4gICAgIC8vXVxuICAgfSlcblxuICAgIC8vIFRoaXMgY2xlYXJzIHRoZSBjb2xvciBidWZmZXIgdG8gYmxhY2sgYW5kIHRoZSBkZXB0aCBidWZmZXIgdG8gMVxuICAgIHRoaXMucmVnbC5jbGVhcih7XG4gICAgICBjb2xvcjogWzAsIDAsIDAsIDFdXG4gICAgfSlcblxuICAgIHRoaXMucmVuZGVyQWxsID0gdGhpcy5yZWdsKHtcbiAgICAgIGZyYWc6IGBcbiAgICAgIHByZWNpc2lvbiAke3RoaXMucHJlY2lzaW9ufSBmbG9hdDtcbiAgICAgIHZhcnlpbmcgdmVjMiB1djtcbiAgICAgIHVuaWZvcm0gc2FtcGxlcjJEIHRleDA7XG4gICAgICB1bmlmb3JtIHNhbXBsZXIyRCB0ZXgxO1xuICAgICAgdW5pZm9ybSBzYW1wbGVyMkQgdGV4MjtcbiAgICAgIHVuaWZvcm0gc2FtcGxlcjJEIHRleDM7XG5cbiAgICAgIHZvaWQgbWFpbiAoKSB7XG4gICAgICAgIHZlYzIgc3QgPSB2ZWMyKDEuMCAtIHV2LngsIHV2LnkpO1xuICAgICAgICBzdCo9IHZlYzIoMik7XG4gICAgICAgIHZlYzIgcSA9IGZsb29yKHN0KS54eSoodmVjMigyLjAsIDEuMCkpO1xuICAgICAgICBpbnQgcXVhZCA9IGludChxLngpICsgaW50KHEueSk7XG4gICAgICAgIHN0LnggKz0gc3RlcCgxLiwgbW9kKHN0LnksMi4wKSk7XG4gICAgICAgIHN0LnkgKz0gc3RlcCgxLiwgbW9kKHN0LngsMi4wKSk7XG4gICAgICAgIHN0ID0gZnJhY3Qoc3QpO1xuICAgICAgICBpZihxdWFkPT0wKXtcbiAgICAgICAgICBnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlMkQodGV4MCwgc3QpO1xuICAgICAgICB9IGVsc2UgaWYocXVhZD09MSl7XG4gICAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKHRleDEsIHN0KTtcbiAgICAgICAgfSBlbHNlIGlmIChxdWFkPT0yKXtcbiAgICAgICAgICBnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlMkQodGV4Miwgc3QpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGdsX0ZyYWdDb2xvciA9IHRleHR1cmUyRCh0ZXgzLCBzdCk7XG4gICAgICAgIH1cblxuICAgICAgfVxuICAgICAgYCxcbiAgICAgIHZlcnQ6IGBcbiAgICAgIHByZWNpc2lvbiAke3RoaXMucHJlY2lzaW9ufSBmbG9hdDtcbiAgICAgIGF0dHJpYnV0ZSB2ZWMyIHBvc2l0aW9uO1xuICAgICAgdmFyeWluZyB2ZWMyIHV2O1xuXG4gICAgICB2b2lkIG1haW4gKCkge1xuICAgICAgICB1diA9IHBvc2l0aW9uO1xuICAgICAgICBnbF9Qb3NpdGlvbiA9IHZlYzQoMS4wIC0gMi4wICogcG9zaXRpb24sIDAsIDEpO1xuICAgICAgfWAsXG4gICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgIHBvc2l0aW9uOiBbXG4gICAgICAgICAgWy0yLCAwXSxcbiAgICAgICAgICBbMCwgLTJdLFxuICAgICAgICAgIFsyLCAyXVxuICAgICAgICBdXG4gICAgICB9LFxuICAgICAgdW5pZm9ybXM6IHtcbiAgICAgICAgdGV4MDogdGhpcy5yZWdsLnByb3AoJ3RleDAnKSxcbiAgICAgICAgdGV4MTogdGhpcy5yZWdsLnByb3AoJ3RleDEnKSxcbiAgICAgICAgdGV4MjogdGhpcy5yZWdsLnByb3AoJ3RleDInKSxcbiAgICAgICAgdGV4MzogdGhpcy5yZWdsLnByb3AoJ3RleDMnKVxuICAgICAgfSxcbiAgICAgIGNvdW50OiAzLFxuICAgICAgZGVwdGg6IHsgZW5hYmxlOiBmYWxzZSB9XG4gICAgfSlcblxuICAgIHRoaXMucmVuZGVyRmJvID0gdGhpcy5yZWdsKHtcbiAgICAgIGZyYWc6IGBcbiAgICAgIHByZWNpc2lvbiAke3RoaXMucHJlY2lzaW9ufSBmbG9hdDtcbiAgICAgIHZhcnlpbmcgdmVjMiB1djtcbiAgICAgIHVuaWZvcm0gdmVjMiByZXNvbHV0aW9uO1xuICAgICAgdW5pZm9ybSBzYW1wbGVyMkQgdGV4MDtcblxuICAgICAgdm9pZCBtYWluICgpIHtcbiAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKHRleDAsIHZlYzIoMS4wIC0gdXYueCwgdXYueSkpO1xuICAgICAgfVxuICAgICAgYCxcbiAgICAgIHZlcnQ6IGBcbiAgICAgIHByZWNpc2lvbiAke3RoaXMucHJlY2lzaW9ufSBmbG9hdDtcbiAgICAgIGF0dHJpYnV0ZSB2ZWMyIHBvc2l0aW9uO1xuICAgICAgdmFyeWluZyB2ZWMyIHV2O1xuXG4gICAgICB2b2lkIG1haW4gKCkge1xuICAgICAgICB1diA9IHBvc2l0aW9uO1xuICAgICAgICBnbF9Qb3NpdGlvbiA9IHZlYzQoMS4wIC0gMi4wICogcG9zaXRpb24sIDAsIDEpO1xuICAgICAgfWAsXG4gICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgIHBvc2l0aW9uOiBbXG4gICAgICAgICAgWy0yLCAwXSxcbiAgICAgICAgICBbMCwgLTJdLFxuICAgICAgICAgIFsyLCAyXVxuICAgICAgICBdXG4gICAgICB9LFxuICAgICAgdW5pZm9ybXM6IHtcbiAgICAgICAgdGV4MDogdGhpcy5yZWdsLnByb3AoJ3RleDAnKSxcbiAgICAgICAgcmVzb2x1dGlvbjogdGhpcy5yZWdsLnByb3AoJ3Jlc29sdXRpb24nKVxuICAgICAgfSxcbiAgICAgIGNvdW50OiAzLFxuICAgICAgZGVwdGg6IHsgZW5hYmxlOiBmYWxzZSB9XG4gICAgfSlcbiAgfVxuXG4gIF9pbml0T3V0cHV0cyAobnVtT3V0cHV0cykge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzXG4gICAgdGhpcy5vID0gKEFycmF5KG51bU91dHB1dHMpKS5maWxsKCkubWFwKChlbCwgaW5kZXgpID0+IHtcbiAgICAgIHZhciBvID0gbmV3IE91dHB1dChpbmRleCwgdGhpcylcbiAgICAgIHNlbGYuc3ludGhbJ28nK2luZGV4XSA9IG9cbiAgICAgIHJldHVybiBvXG4gICAgfSlcblxuICAgIC8vIHNldCBkZWZhdWx0IG91dHB1dFxuICAgIHRoaXMub3V0cHV0ID0gdGhpcy5vWzBdXG4gIH1cblxuICBfaW5pdFNvdXJjZXMgKG51bVNvdXJjZXMpIHtcbiAgICB0aGlzLnMgPSBbXVxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBudW1Tb3VyY2VzOyBpKyspIHtcbiAgICAgIHRoaXMuY3JlYXRlU291cmNlKGkpXG4gICAgfVxuICB9XG5cbiAgY3JlYXRlU291cmNlIChpKSB7XG4gICAgbGV0IHMgPSBuZXcgU291cmNlKHtyZWdsOiB0aGlzLnJlZ2wsIHBiOiB0aGlzLnBiLCB3aWR0aDogdGhpcy53aWR0aCwgaGVpZ2h0OiB0aGlzLmhlaWdodCwgbGFiZWw6IGBzJHtpfWB9KVxuICAgIHRoaXMuc3ludGhbJ3MnICsgdGhpcy5zLmxlbmd0aF0gPSBzXG4gICAgdGhpcy5zLnB1c2gocylcbiAgICByZXR1cm4gc1xuICB9XG5cbiAgX2dlbmVyYXRlR2xzbFRyYW5zZm9ybXMgKCkge1xuICAgIHZhciBzZWxmID0gdGhpc1xuICAgIHRoaXMuZ2VuZXJhdG9yID0gbmV3IEdlbmVyYXRvcih7XG4gICAgICBkZWZhdWx0T3V0cHV0OiB0aGlzLm9bMF0sXG4gICAgICBkZWZhdWx0VW5pZm9ybXM6IHRoaXMub1swXS51bmlmb3JtcyxcbiAgICAgIGV4dGVuZFRyYW5zZm9ybXM6IHRoaXMuZXh0ZW5kVHJhbnNmb3JtcyxcbiAgICAgIGNoYW5nZUxpc3RlbmVyOiAoe3R5cGUsIG1ldGhvZCwgc3ludGh9KSA9PiB7XG4gICAgICAgICAgaWYgKHR5cGUgPT09ICdhZGQnKSB7XG4gICAgICAgICAgICBzZWxmLnN5bnRoW21ldGhvZF0gPSBzeW50aC5nZW5lcmF0b3JzW21ldGhvZF1cbiAgICAgICAgICAgIGlmKHNlbGYuc2FuZGJveCkgc2VsZi5zYW5kYm94LmFkZChtZXRob2QpXG4gICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAncmVtb3ZlJykge1xuICAgICAgICAgICAgLy8gd2hhdCB0byBkbyBoZXJlPyBkYW5nZXJvdXNseSBkZWxldGluZyB3aW5kb3cgbWV0aG9kc1xuICAgICAgICAgICAgLy9kZWxldGUgd2luZG93W21ldGhvZF1cbiAgICAgICAgICB9XG4gICAgICAvLyAgfVxuICAgICAgfVxuICAgIH0pXG4gICAgdGhpcy5zeW50aC5zZXRGdW5jdGlvbiA9IHRoaXMuZ2VuZXJhdG9yLnNldEZ1bmN0aW9uLmJpbmQodGhpcy5nZW5lcmF0b3IpXG4gIH1cblxuICBfcmVuZGVyIChvdXRwdXQpIHtcbiAgICBpZiAob3V0cHV0KSB7XG4gICAgICB0aGlzLm91dHB1dCA9IG91dHB1dFxuICAgICAgdGhpcy5pc1JlbmRlcmluZ0FsbCA9IGZhbHNlXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaXNSZW5kZXJpbmdBbGwgPSB0cnVlXG4gICAgfVxuICB9XG5cbiAgX3JlbmRlck91dCAoaSkge1xuICAgIHRoaXMub1tpXS50aWNrKHtcbiAgICAgIHRpbWU6IHRoaXMuc3ludGgudGltZSxcbiAgICAgIG1vdXNlOiB0aGlzLnN5bnRoLm1vdXNlLFxuICAgICAgYnBtOiB0aGlzLnN5bnRoLmJwbSxcbiAgICAgIHJlc29sdXRpb246IFt0aGlzLmNhbnZhcy53aWR0aCwgdGhpcy5jYW52YXMuaGVpZ2h0XVxuICAgIH0pXG4gIH1cblxuICAvLyBkdCBpbiBtc1xuICB0aWNrIChkdCwgdW5pZm9ybXMpIHtcbiAgICB0aGlzLnNhbmRib3gudGljaygpXG4gICAgaWYodGhpcy5kZXRlY3RBdWRpbyA9PT0gdHJ1ZSkgdGhpcy5zeW50aC5hLnRpY2soKVxuICAvLyAgbGV0IHVwZGF0ZUludGVydmFsID0gMTAwMC90aGlzLnN5bnRoLmZwcyAvLyBtc1xuICAgIHRoaXMuc2FuZGJveC5zZXQoJ3RpbWUnLCB0aGlzLnN5bnRoLnRpbWUgKz0gZHQgKiAwLjAwMSAqIHRoaXMuc3ludGguc3BlZWQpXG4gICAgdGhpcy50aW1lU2luY2VMYXN0VXBkYXRlICs9IGR0XG4gICAgaWYoIXRoaXMuc3ludGguZnBzIHx8IHRoaXMudGltZVNpbmNlTGFzdFVwZGF0ZSA+PSAxMDAwL3RoaXMuc3ludGguZnBzKSB7XG4gICAgLy8gIGNvbnNvbGUubG9nKDEwMDAvdGhpcy50aW1lU2luY2VMYXN0VXBkYXRlKVxuICAgICAgdGhpcy5zeW50aC5zdGF0cy5mcHMgPSBNYXRoLmNlaWwoMTAwMC90aGlzLnRpbWVTaW5jZUxhc3RVcGRhdGUpXG4gICAgICBpZih0aGlzLnN5bnRoLnVwZGF0ZSkge1xuICAgICAgICB0cnkgeyB0aGlzLnN5bnRoLnVwZGF0ZSh0aGlzLnRpbWVTaW5jZUxhc3RVcGRhdGUpIH0gY2F0Y2ggKGUpIHsgY29uc29sZS5sb2coZSkgfVxuICAgICAgfVxuICAgIC8vICBjb25zb2xlLmxvZyh0aGlzLnN5bnRoLnNwZWVkLCB0aGlzLnN5bnRoLnRpbWUpXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLnNbaV0udGljayh0aGlzLnN5bnRoLnRpbWUpXG4gICAgICB9XG4gICAgLy8gIGNvbnNvbGUubG9nKHRoaXMuY2FudmFzLndpZHRoLCB0aGlzLmNhbnZhcy5oZWlnaHQpXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuby5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLl9yZW5kZXJPdXQoaSk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5pc1JlbmRlcmluZ0FsbCkge1xuICAgICAgICB0aGlzLnJlbmRlckFsbCh7XG4gICAgICAgICAgdGV4MDogdGhpcy5vWzBdLmdldEN1cnJlbnQoKSxcbiAgICAgICAgICB0ZXgxOiB0aGlzLm9bMV0uZ2V0Q3VycmVudCgpLFxuICAgICAgICAgIHRleDI6IHRoaXMub1syXS5nZXRDdXJyZW50KCksXG4gICAgICAgICAgdGV4MzogdGhpcy5vWzNdLmdldEN1cnJlbnQoKSxcbiAgICAgICAgICByZXNvbHV0aW9uOiBbdGhpcy5jYW52YXMud2lkdGgsIHRoaXMuY2FudmFzLmhlaWdodF1cbiAgICAgICAgfSlcbiAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgdGhpcy5yZW5kZXJGYm8oe1xuICAgICAgICAgIHRleDA6IHRoaXMub3V0cHV0LmdldEN1cnJlbnQoKSxcbiAgICAgICAgICByZXNvbHV0aW9uOiBbdGhpcy5jYW52YXMud2lkdGgsIHRoaXMuY2FudmFzLmhlaWdodF1cbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICAgIHRoaXMudGltZVNpbmNlTGFzdFVwZGF0ZSA9IDBcbiAgICB9XG4gICAgaWYodGhpcy5zYXZlRnJhbWUgPT09IHRydWUpIHtcbiAgICAgIHRoaXMuY2FudmFzVG9JbWFnZSgpXG4gICAgICB0aGlzLnNhdmVGcmFtZSA9IGZhbHNlXG4gICAgfVxuICAvLyAgdGhpcy5yZWdsLnBvbGwoKVxuICB9XG5cblxufVxuXG5leHBvcnQgZGVmYXVsdCBIeWRyYVJlbmRlcmVyXG4iLCJpbXBvcnQgU3ludGggZnJvbSAnLi9oeWRyYS1zeW50aC5qcydcbi8vaW1wb3J0IFNoYWRlckdlbmVyYXRvciA9IHJlcXVpcmUoJy4vc2hhZGVyLWdlbmVyYXRvci5qcycpXG4vLyBhbGVydCgnaGknKVxuLy8gZXhwb3J0IGRlZmF1bHQgU3ludGhcbm1vZHVsZS5leHBvcnRzID0gU3ludGhcbiIsIi8vIFdJUCB1dGlscyBmb3Igd29ya2luZyB3aXRoIGFycmF5c1xuLy8gUG9zc2libHkgc2hvdWxkIGJlIGludGVncmF0ZWQgd2l0aCBsZm8gZXh0ZW5zaW9uLCBldGMuXG4vLyB0byBkbzogdHJhbnNmb3JtIHRpbWUgcmF0aGVyIHRoYW4gYXJyYXkgdmFsdWVzLCBzaW1pbGFyIHRvIHdvcmtpbmcgd2l0aCBjb29yZGluYXRlcyBpbiBoeWRyYVxuXG5pbXBvcnQgZWFzaW5nIGZyb20gJy4vZWFzaW5nLWZ1bmN0aW9ucy5qcydcblxudmFyIG1hcCA9IChudW0sIGluX21pbiwgaW5fbWF4LCBvdXRfbWluLCBvdXRfbWF4KSA9PiB7XG4gIHJldHVybiAobnVtIC0gaW5fbWluKSAqIChvdXRfbWF4IC0gb3V0X21pbikgLyAoaW5fbWF4IC0gaW5fbWluKSArIG91dF9taW47XG59XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgaW5pdDogKCkgPT4ge1xuXG4gICAgQXJyYXkucHJvdG90eXBlLmZhc3QgPSBmdW5jdGlvbihzcGVlZCA9IDEpIHtcbiAgICAgIHRoaXMuX3NwZWVkID0gc3BlZWRcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuXG4gICAgQXJyYXkucHJvdG90eXBlLnNtb290aCA9IGZ1bmN0aW9uKHNtb290aCA9IDEpIHtcbiAgICAgIHRoaXMuX3Ntb290aCA9IHNtb290aFxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICBBcnJheS5wcm90b3R5cGUuZWFzZSA9IGZ1bmN0aW9uKGVhc2UgPSAnbGluZWFyJykge1xuICAgICAgaWYgKHR5cGVvZiBlYXNlID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhpcy5fc21vb3RoID0gMVxuICAgICAgICB0aGlzLl9lYXNlID0gZWFzZVxuICAgICAgfVxuICAgICAgZWxzZSBpZiAoZWFzaW5nW2Vhc2VdKXtcbiAgICAgICAgdGhpcy5fc21vb3RoID0gMVxuICAgICAgICB0aGlzLl9lYXNlID0gZWFzaW5nW2Vhc2VdXG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cblxuICAgIEFycmF5LnByb3RvdHlwZS5vZmZzZXQgPSBmdW5jdGlvbihvZmZzZXQgPSAwLjUpIHtcbiAgICAgIHRoaXMuX29mZnNldCA9IG9mZnNldCUxLjBcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuXG4gICAgLy8gQXJyYXkucHJvdG90eXBlLmJvdW5jZSA9IGZ1bmN0aW9uKCkge1xuICAgIC8vICAgdGhpcy5tb2RpZmllcnMuYm91bmNlID0gdHJ1ZVxuICAgIC8vICAgcmV0dXJuIHRoaXNcbiAgICAvLyB9XG5cbiAgICBBcnJheS5wcm90b3R5cGUuZml0ID0gZnVuY3Rpb24obG93ID0gMCwgaGlnaCA9MSkge1xuICAgICAgbGV0IGxvd2VzdCA9IE1hdGgubWluKC4uLnRoaXMpXG4gICAgICBsZXQgaGlnaGVzdCA9ICBNYXRoLm1heCguLi50aGlzKVxuICAgICAgdmFyIG5ld0FyciA9IHRoaXMubWFwKChudW0pID0+IG1hcChudW0sIGxvd2VzdCwgaGlnaGVzdCwgbG93LCBoaWdoKSlcbiAgICAgIG5ld0Fyci5fc3BlZWQgPSB0aGlzLl9zcGVlZFxuICAgICAgbmV3QXJyLl9zbW9vdGggPSB0aGlzLl9zbW9vdGhcbiAgICAgIG5ld0Fyci5fZWFzZSA9IHRoaXMuX2Vhc2VcbiAgICAgIHJldHVybiBuZXdBcnJcbiAgICB9XG4gIH0sXG5cbiAgZ2V0VmFsdWU6IChhcnIgPSBbXSkgPT4gKHt0aW1lLCBicG19KSA9PntcbiAgICBsZXQgc3BlZWQgPSBhcnIuX3NwZWVkID8gYXJyLl9zcGVlZCA6IDFcbiAgICBsZXQgc21vb3RoID0gYXJyLl9zbW9vdGggPyBhcnIuX3Ntb290aCA6IDBcbiAgICBsZXQgaW5kZXggPSB0aW1lICogc3BlZWQgKiAoYnBtIC8gNjApICsgKGFyci5fb2Zmc2V0IHx8IDApXG5cbiAgICBpZiAoc21vb3RoIT09MCkge1xuICAgICAgbGV0IGVhc2UgPSBhcnIuX2Vhc2UgPyBhcnIuX2Vhc2UgOiBlYXNpbmdbJ2xpbmVhciddXG4gICAgICBsZXQgX2luZGV4ID0gaW5kZXggLSAoc21vb3RoIC8gMilcbiAgICAgIGxldCBjdXJyVmFsdWUgPSBhcnJbTWF0aC5mbG9vcihfaW5kZXggJSAoYXJyLmxlbmd0aCkpXVxuICAgICAgbGV0IG5leHRWYWx1ZSA9IGFycltNYXRoLmZsb29yKChfaW5kZXggKyAxKSAlIChhcnIubGVuZ3RoKSldXG4gICAgICBsZXQgdCA9IE1hdGgubWluKChfaW5kZXglMSkvc21vb3RoLDEpXG4gICAgICByZXR1cm4gZWFzZSh0KSAqIChuZXh0VmFsdWUgLSBjdXJyVmFsdWUpICsgY3VyclZhbHVlXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcmV0dXJuIGFycltNYXRoLmZsb29yKGluZGV4ICUgKGFyci5sZW5ndGgpKV1cbiAgICB9XG4gIH1cbn1cbiIsImltcG9ydCBNZXlkYSBmcm9tICdtZXlkYSdcblxuY2xhc3MgQXVkaW8ge1xuICBjb25zdHJ1Y3RvciAoe1xuICAgIG51bUJpbnMgPSA0LFxuICAgIGN1dG9mZiA9IDIsXG4gICAgc21vb3RoID0gMC40LFxuICAgIG1heCA9IDE1LFxuICAgIHNjYWxlID0gMTAsXG4gICAgaXNEcmF3aW5nID0gZmFsc2UsXG4gICAgcGFyZW50RWwgPSBkb2N1bWVudC5ib2R5XG4gIH0pIHtcbiAgICB0aGlzLnZvbCA9IDBcbiAgICB0aGlzLnNjYWxlID0gc2NhbGVcbiAgICB0aGlzLm1heCA9IG1heFxuICAgIHRoaXMuY3V0b2ZmID0gY3V0b2ZmXG4gICAgdGhpcy5zbW9vdGggPSBzbW9vdGhcbiAgICB0aGlzLnNldEJpbnMobnVtQmlucylcblxuICAgIC8vIGJlYXQgZGV0ZWN0aW9uIGZyb206IGh0dHBzOi8vZ2l0aHViLmNvbS90aGVyZXdhc2FndXkvcDUtbXVzaWMtdml6L2Jsb2IvZ2gtcGFnZXMvZGVtb3MvMDFkX2JlYXRfZGV0ZWN0X2FtcGxpdHVkZS9za2V0Y2guanNcbiAgICB0aGlzLmJlYXQgPSB7XG4gICAgICBob2xkRnJhbWVzOiAyMCxcbiAgICAgIHRocmVzaG9sZDogNDAsXG4gICAgICBfY3V0b2ZmOiAwLCAvLyBhZGFwdGl2ZSBiYXNlZCBvbiBzb3VuZCBzdGF0ZVxuICAgICAgZGVjYXk6IDAuOTgsXG4gICAgICBfZnJhbWVzU2luY2VCZWF0OiAwIC8vIGtlZXBzIHRyYWNrIG9mIGZyYW1lc1xuICAgIH1cblxuICAgIHRoaXMub25CZWF0ID0gKCkgPT4ge1xuICAgIC8vICBjb25zb2xlLmxvZyhcImJlYXRcIilcbiAgICB9XG5cbiAgICB0aGlzLmNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpXG4gICAgdGhpcy5jYW52YXMud2lkdGggPSAxMDBcbiAgICB0aGlzLmNhbnZhcy5oZWlnaHQgPSA4MFxuICAgIHRoaXMuY2FudmFzLnN0eWxlLndpZHRoID0gXCIxMDBweFwiXG4gICAgdGhpcy5jYW52YXMuc3R5bGUuaGVpZ2h0ID0gXCI4MHB4XCJcbiAgICB0aGlzLmNhbnZhcy5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSdcbiAgICB0aGlzLmNhbnZhcy5zdHlsZS5yaWdodCA9ICcwcHgnXG4gICAgdGhpcy5jYW52YXMuc3R5bGUuYm90dG9tID0gJzBweCdcbiAgICBwYXJlbnRFbC5hcHBlbmRDaGlsZCh0aGlzLmNhbnZhcylcblxuICAgIHRoaXMuaXNEcmF3aW5nID0gaXNEcmF3aW5nXG4gICAgdGhpcy5jdHggPSB0aGlzLmNhbnZhcy5nZXRDb250ZXh0KCcyZCcpXG4gICAgdGhpcy5jdHguZmlsbFN0eWxlPVwiI0RGRkZGRlwiXG4gICAgdGhpcy5jdHguc3Ryb2tlU3R5bGU9XCIjMGZmXCJcbiAgICB0aGlzLmN0eC5saW5lV2lkdGg9MC41XG4gICAgaWYod2luZG93Lm5hdmlnYXRvci5tZWRpYURldmljZXMpIHtcbiAgICB3aW5kb3cubmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEoe3ZpZGVvOiBmYWxzZSwgYXVkaW86IHRydWV9KVxuICAgICAgLnRoZW4oKHN0cmVhbSkgPT4ge1xuICAgICAgLy8gIGNvbnNvbGUubG9nKCdnb3QgbWljIHN0cmVhbScsIHN0cmVhbSlcbiAgICAgICAgdGhpcy5zdHJlYW0gPSBzdHJlYW1cbiAgICAgICAgdGhpcy5jb250ZXh0ID0gbmV3IEF1ZGlvQ29udGV4dCgpXG4gICAgICAgIC8vICB0aGlzLmNvbnRleHQgPSBuZXcgQXVkaW9Db250ZXh0KClcbiAgICAgICAgbGV0IGF1ZGlvX3N0cmVhbSA9IHRoaXMuY29udGV4dC5jcmVhdGVNZWRpYVN0cmVhbVNvdXJjZShzdHJlYW0pXG5cbiAgICAgIC8vICBjb25zb2xlLmxvZyh0aGlzLmNvbnRleHQpXG4gICAgICAgIHRoaXMubWV5ZGEgPSBNZXlkYS5jcmVhdGVNZXlkYUFuYWx5emVyKHtcbiAgICAgICAgICBhdWRpb0NvbnRleHQ6IHRoaXMuY29udGV4dCxcbiAgICAgICAgICBzb3VyY2U6IGF1ZGlvX3N0cmVhbSxcbiAgICAgICAgICBmZWF0dXJlRXh0cmFjdG9yczogW1xuICAgICAgICAgICAgJ2xvdWRuZXNzJyxcbiAgICAgICAgICAgIC8vICAncGVyY2VwdHVhbFNwcmVhZCcsXG4gICAgICAgICAgICAvLyAgJ3BlcmNlcHR1YWxTaGFycG5lc3MnLFxuICAgICAgICAgICAgLy8gICdzcGVjdHJhbENlbnRyb2lkJ1xuICAgICAgICAgIF1cbiAgICAgICAgfSlcbiAgICAgIH0pXG4gICAgICAuY2F0Y2goKGVycikgPT4gY29uc29sZS5sb2coJ0VSUk9SJywgZXJyKSlcbiAgICB9XG4gIH1cblxuICBkZXRlY3RCZWF0IChsZXZlbCkge1xuICAgIC8vY29uc29sZS5sb2cobGV2ZWwsICAgdGhpcy5iZWF0Ll9jdXRvZmYpXG4gICAgaWYgKGxldmVsID4gdGhpcy5iZWF0Ll9jdXRvZmYgJiYgbGV2ZWwgPiB0aGlzLmJlYXQudGhyZXNob2xkKSB7XG4gICAgICB0aGlzLm9uQmVhdCgpXG4gICAgICB0aGlzLmJlYXQuX2N1dG9mZiA9IGxldmVsICoxLjJcbiAgICAgIHRoaXMuYmVhdC5fZnJhbWVzU2luY2VCZWF0ID0gMFxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodGhpcy5iZWF0Ll9mcmFtZXNTaW5jZUJlYXQgPD0gdGhpcy5iZWF0LmhvbGRGcmFtZXMpe1xuICAgICAgICB0aGlzLmJlYXQuX2ZyYW1lc1NpbmNlQmVhdCArKztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYmVhdC5fY3V0b2ZmICo9IHRoaXMuYmVhdC5kZWNheVxuICAgICAgICB0aGlzLmJlYXQuX2N1dG9mZiA9IE1hdGgubWF4KCAgdGhpcy5iZWF0Ll9jdXRvZmYsIHRoaXMuYmVhdC50aHJlc2hvbGQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHRpY2soKSB7XG4gICBpZih0aGlzLm1leWRhKXtcbiAgICAgdmFyIGZlYXR1cmVzID0gdGhpcy5tZXlkYS5nZXQoKVxuICAgICBpZihmZWF0dXJlcyAmJiBmZWF0dXJlcyAhPT0gbnVsbCl7XG4gICAgICAgdGhpcy52b2wgPSBmZWF0dXJlcy5sb3VkbmVzcy50b3RhbFxuICAgICAgIHRoaXMuZGV0ZWN0QmVhdCh0aGlzLnZvbClcbiAgICAgICAvLyByZWR1Y2UgbG91ZG5lc3MgYXJyYXkgdG8gbnVtYmVyIG9mIGJpbnNcbiAgICAgICBjb25zdCByZWR1Y2VyID0gKGFjY3VtdWxhdG9yLCBjdXJyZW50VmFsdWUpID0+IGFjY3VtdWxhdG9yICsgY3VycmVudFZhbHVlO1xuICAgICAgIGxldCBzcGFjaW5nID0gTWF0aC5mbG9vcihmZWF0dXJlcy5sb3VkbmVzcy5zcGVjaWZpYy5sZW5ndGgvdGhpcy5iaW5zLmxlbmd0aClcbiAgICAgICB0aGlzLnByZXZCaW5zID0gdGhpcy5iaW5zLnNsaWNlKDApXG4gICAgICAgdGhpcy5iaW5zID0gdGhpcy5iaW5zLm1hcCgoYmluLCBpbmRleCkgPT4ge1xuICAgICAgICAgcmV0dXJuIGZlYXR1cmVzLmxvdWRuZXNzLnNwZWNpZmljLnNsaWNlKGluZGV4ICogc3BhY2luZywgKGluZGV4ICsgMSkqc3BhY2luZykucmVkdWNlKHJlZHVjZXIpXG4gICAgICAgfSkubWFwKChiaW4sIGluZGV4KSA9PiB7XG4gICAgICAgICAvLyBtYXAgdG8gc3BlY2lmaWVkIHJhbmdlXG5cbiAgICAgICAgLy8gcmV0dXJuIChiaW4gKiAoMS4wIC0gdGhpcy5zbW9vdGgpICsgdGhpcy5wcmV2Qmluc1tpbmRleF0gKiB0aGlzLnNtb290aClcbiAgICAgICAgICByZXR1cm4gKGJpbiAqICgxLjAgLSB0aGlzLnNldHRpbmdzW2luZGV4XS5zbW9vdGgpICsgdGhpcy5wcmV2Qmluc1tpbmRleF0gKiB0aGlzLnNldHRpbmdzW2luZGV4XS5zbW9vdGgpXG4gICAgICAgfSlcbiAgICAgICAvLyB2YXIgeSA9IHRoaXMuY2FudmFzLmhlaWdodCAtIHNjYWxlKnRoaXMuc2V0dGluZ3NbaW5kZXhdLmN1dG9mZlxuICAgICAgIC8vIHRoaXMuY3R4LmJlZ2luUGF0aCgpXG4gICAgICAgLy8gdGhpcy5jdHgubW92ZVRvKGluZGV4KnNwYWNpbmcsIHkpXG4gICAgICAgLy8gdGhpcy5jdHgubGluZVRvKChpbmRleCsxKSpzcGFjaW5nLCB5KVxuICAgICAgIC8vIHRoaXMuY3R4LnN0cm9rZSgpXG4gICAgICAgLy9cbiAgICAgICAvLyB2YXIgeU1heCA9IHRoaXMuY2FudmFzLmhlaWdodCAtIHNjYWxlKih0aGlzLnNldHRpbmdzW2luZGV4XS5zY2FsZSArIHRoaXMuc2V0dGluZ3NbaW5kZXhdLmN1dG9mZilcbiAgICAgICB0aGlzLmZmdCA9IHRoaXMuYmlucy5tYXAoKGJpbiwgaW5kZXgpID0+IChcbiAgICAgICAgLy8gTWF0aC5tYXgoMCwgKGJpbiAtIHRoaXMuY3V0b2ZmKSAvICh0aGlzLm1heCAtIHRoaXMuY3V0b2ZmKSlcbiAgICAgICAgIE1hdGgubWF4KDAsIChiaW4gLSB0aGlzLnNldHRpbmdzW2luZGV4XS5jdXRvZmYpL3RoaXMuc2V0dGluZ3NbaW5kZXhdLnNjYWxlKVxuICAgICAgICkpXG4gICAgICAgaWYodGhpcy5pc0RyYXdpbmcpIHRoaXMuZHJhdygpXG4gICAgIH1cbiAgIH1cbiAgfVxuXG4gIHNldEN1dG9mZiAoY3V0b2ZmKSB7XG4gICAgdGhpcy5jdXRvZmYgPSBjdXRvZmZcbiAgICB0aGlzLnNldHRpbmdzID0gdGhpcy5zZXR0aW5ncy5tYXAoKGVsKSA9PiB7XG4gICAgICBlbC5jdXRvZmYgPSBjdXRvZmZcbiAgICAgIHJldHVybiBlbFxuICAgIH0pXG4gIH1cblxuICBzZXRTbW9vdGggKHNtb290aCkge1xuICAgIHRoaXMuc21vb3RoID0gc21vb3RoXG4gICAgdGhpcy5zZXR0aW5ncyA9IHRoaXMuc2V0dGluZ3MubWFwKChlbCkgPT4ge1xuICAgICAgZWwuc21vb3RoID0gc21vb3RoXG4gICAgICByZXR1cm4gZWxcbiAgICB9KVxuICB9XG5cbiAgc2V0QmlucyAobnVtQmlucykge1xuICAgIHRoaXMuYmlucyA9IEFycmF5KG51bUJpbnMpLmZpbGwoMClcbiAgICB0aGlzLnByZXZCaW5zID0gQXJyYXkobnVtQmlucykuZmlsbCgwKVxuICAgIHRoaXMuZmZ0ID0gQXJyYXkobnVtQmlucykuZmlsbCgwKVxuICAgIHRoaXMuc2V0dGluZ3MgPSBBcnJheShudW1CaW5zKS5maWxsKDApLm1hcCgoKSA9PiAoe1xuICAgICAgY3V0b2ZmOiB0aGlzLmN1dG9mZixcbiAgICAgIHNjYWxlOiB0aGlzLnNjYWxlLFxuICAgICAgc21vb3RoOiB0aGlzLnNtb290aFxuICAgIH0pKVxuICAgIC8vIHRvIGRvOiB3aGF0IHRvIGRvIGluIG5vbi1nbG9iYWwgbW9kZT9cbiAgICB0aGlzLmJpbnMuZm9yRWFjaCgoYmluLCBpbmRleCkgPT4ge1xuICAgICAgd2luZG93WydhJyArIGluZGV4XSA9IChzY2FsZSA9IDEsIG9mZnNldCA9IDApID0+ICgpID0+IChhLmZmdFtpbmRleF0gKiBzY2FsZSArIG9mZnNldClcbiAgICB9KVxuICAvLyAgY29uc29sZS5sb2codGhpcy5zZXR0aW5ncylcbiAgfVxuXG4gIHNldFNjYWxlKHNjYWxlKXtcbiAgICB0aGlzLnNjYWxlID0gc2NhbGVcbiAgICB0aGlzLnNldHRpbmdzID0gdGhpcy5zZXR0aW5ncy5tYXAoKGVsKSA9PiB7XG4gICAgICBlbC5zY2FsZSA9IHNjYWxlXG4gICAgICByZXR1cm4gZWxcbiAgICB9KVxuICB9XG5cbiAgc2V0TWF4KG1heCkge1xuICAgIHRoaXMubWF4ID0gbWF4XG4gICAgY29uc29sZS5sb2coJ3NldCBtYXggaXMgZGVwcmVjYXRlZCcpXG4gIH1cbiAgaGlkZSgpIHtcbiAgICB0aGlzLmlzRHJhd2luZyA9IGZhbHNlXG4gICAgdGhpcy5jYW52YXMuc3R5bGUuZGlzcGxheSA9ICdub25lJ1xuICB9XG5cbiAgc2hvdygpIHtcbiAgICB0aGlzLmlzRHJhd2luZyA9IHRydWVcbiAgICB0aGlzLmNhbnZhcy5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJ1xuXG4gIH1cblxuICBkcmF3ICgpIHtcbiAgICB0aGlzLmN0eC5jbGVhclJlY3QoMCwgMCwgdGhpcy5jYW52YXMud2lkdGgsIHRoaXMuY2FudmFzLmhlaWdodClcbiAgICB2YXIgc3BhY2luZyA9IHRoaXMuY2FudmFzLndpZHRoIC8gdGhpcy5iaW5zLmxlbmd0aFxuICAgIHZhciBzY2FsZSA9IHRoaXMuY2FudmFzLmhlaWdodCAvICh0aGlzLm1heCAqIDIpXG4gIC8vICBjb25zb2xlLmxvZyh0aGlzLmJpbnMpXG4gICAgdGhpcy5iaW5zLmZvckVhY2goKGJpbiwgaW5kZXgpID0+IHtcblxuICAgICAgdmFyIGhlaWdodCA9IGJpbiAqIHNjYWxlXG5cbiAgICAgdGhpcy5jdHguZmlsbFJlY3QoaW5kZXggKiBzcGFjaW5nLCB0aGlzLmNhbnZhcy5oZWlnaHQgLSBoZWlnaHQsIHNwYWNpbmcsIGhlaWdodClcblxuICAvLyAgIGNvbnNvbGUubG9nKHRoaXMuc2V0dGluZ3NbaW5kZXhdKVxuICAgICB2YXIgeSA9IHRoaXMuY2FudmFzLmhlaWdodCAtIHNjYWxlKnRoaXMuc2V0dGluZ3NbaW5kZXhdLmN1dG9mZlxuICAgICB0aGlzLmN0eC5iZWdpblBhdGgoKVxuICAgICB0aGlzLmN0eC5tb3ZlVG8oaW5kZXgqc3BhY2luZywgeSlcbiAgICAgdGhpcy5jdHgubGluZVRvKChpbmRleCsxKSpzcGFjaW5nLCB5KVxuICAgICB0aGlzLmN0eC5zdHJva2UoKVxuXG4gICAgIHZhciB5TWF4ID0gdGhpcy5jYW52YXMuaGVpZ2h0IC0gc2NhbGUqKHRoaXMuc2V0dGluZ3NbaW5kZXhdLnNjYWxlICsgdGhpcy5zZXR0aW5nc1tpbmRleF0uY3V0b2ZmKVxuICAgICB0aGlzLmN0eC5iZWdpblBhdGgoKVxuICAgICB0aGlzLmN0eC5tb3ZlVG8oaW5kZXgqc3BhY2luZywgeU1heClcbiAgICAgdGhpcy5jdHgubGluZVRvKChpbmRleCsxKSpzcGFjaW5nLCB5TWF4KVxuICAgICB0aGlzLmN0eC5zdHJva2UoKVxuICAgIH0pXG5cblxuICAgIC8qdmFyIHkgPSB0aGlzLmNhbnZhcy5oZWlnaHQgLSBzY2FsZSp0aGlzLmN1dG9mZlxuICAgIHRoaXMuY3R4LmJlZ2luUGF0aCgpXG4gICAgdGhpcy5jdHgubW92ZVRvKDAsIHkpXG4gICAgdGhpcy5jdHgubGluZVRvKHRoaXMuY2FudmFzLndpZHRoLCB5KVxuICAgIHRoaXMuY3R4LnN0cm9rZSgpXG4gICAgdmFyIHlNYXggPSB0aGlzLmNhbnZhcy5oZWlnaHQgLSBzY2FsZSp0aGlzLm1heFxuICAgIHRoaXMuY3R4LmJlZ2luUGF0aCgpXG4gICAgdGhpcy5jdHgubW92ZVRvKDAsIHlNYXgpXG4gICAgdGhpcy5jdHgubGluZVRvKHRoaXMuY2FudmFzLndpZHRoLCB5TWF4KVxuICAgIHRoaXMuY3R4LnN0cm9rZSgpKi9cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBBdWRpb1xuIiwiLy8gZnJvbSBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9ncmUvMTY1MDI5NFxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIC8vIG5vIGVhc2luZywgbm8gYWNjZWxlcmF0aW9uXG4gIGxpbmVhcjogZnVuY3Rpb24gKHQpIHsgcmV0dXJuIHQgfSxcbiAgLy8gYWNjZWxlcmF0aW5nIGZyb20gemVybyB2ZWxvY2l0eVxuICBlYXNlSW5RdWFkOiBmdW5jdGlvbiAodCkgeyByZXR1cm4gdCp0IH0sXG4gIC8vIGRlY2VsZXJhdGluZyB0byB6ZXJvIHZlbG9jaXR5XG4gIGVhc2VPdXRRdWFkOiBmdW5jdGlvbiAodCkgeyByZXR1cm4gdCooMi10KSB9LFxuICAvLyBhY2NlbGVyYXRpb24gdW50aWwgaGFsZndheSwgdGhlbiBkZWNlbGVyYXRpb25cbiAgZWFzZUluT3V0UXVhZDogZnVuY3Rpb24gKHQpIHsgcmV0dXJuIHQ8LjUgPyAyKnQqdCA6IC0xKyg0LTIqdCkqdCB9LFxuICAvLyBhY2NlbGVyYXRpbmcgZnJvbSB6ZXJvIHZlbG9jaXR5XG4gIGVhc2VJbkN1YmljOiBmdW5jdGlvbiAodCkgeyByZXR1cm4gdCp0KnQgfSxcbiAgLy8gZGVjZWxlcmF0aW5nIHRvIHplcm8gdmVsb2NpdHlcbiAgZWFzZU91dEN1YmljOiBmdW5jdGlvbiAodCkgeyByZXR1cm4gKC0tdCkqdCp0KzEgfSxcbiAgLy8gYWNjZWxlcmF0aW9uIHVudGlsIGhhbGZ3YXksIHRoZW4gZGVjZWxlcmF0aW9uXG4gIGVhc2VJbk91dEN1YmljOiBmdW5jdGlvbiAodCkgeyByZXR1cm4gdDwuNSA/IDQqdCp0KnQgOiAodC0xKSooMip0LTIpKigyKnQtMikrMSB9LFxuICAvLyBhY2NlbGVyYXRpbmcgZnJvbSB6ZXJvIHZlbG9jaXR5XG4gIGVhc2VJblF1YXJ0OiBmdW5jdGlvbiAodCkgeyByZXR1cm4gdCp0KnQqdCB9LFxuICAvLyBkZWNlbGVyYXRpbmcgdG8gemVybyB2ZWxvY2l0eVxuICBlYXNlT3V0UXVhcnQ6IGZ1bmN0aW9uICh0KSB7IHJldHVybiAxLSgtLXQpKnQqdCp0IH0sXG4gIC8vIGFjY2VsZXJhdGlvbiB1bnRpbCBoYWxmd2F5LCB0aGVuIGRlY2VsZXJhdGlvblxuICBlYXNlSW5PdXRRdWFydDogZnVuY3Rpb24gKHQpIHsgcmV0dXJuIHQ8LjUgPyA4KnQqdCp0KnQgOiAxLTgqKC0tdCkqdCp0KnQgfSxcbiAgLy8gYWNjZWxlcmF0aW5nIGZyb20gemVybyB2ZWxvY2l0eVxuICBlYXNlSW5RdWludDogZnVuY3Rpb24gKHQpIHsgcmV0dXJuIHQqdCp0KnQqdCB9LFxuICAvLyBkZWNlbGVyYXRpbmcgdG8gemVybyB2ZWxvY2l0eVxuICBlYXNlT3V0UXVpbnQ6IGZ1bmN0aW9uICh0KSB7IHJldHVybiAxKygtLXQpKnQqdCp0KnQgfSxcbiAgLy8gYWNjZWxlcmF0aW9uIHVudGlsIGhhbGZ3YXksIHRoZW4gZGVjZWxlcmF0aW9uXG4gIGVhc2VJbk91dFF1aW50OiBmdW5jdGlvbiAodCkgeyByZXR1cm4gdDwuNSA/IDE2KnQqdCp0KnQqdCA6IDErMTYqKC0tdCkqdCp0KnQqdCB9LFxuICAvLyBzaW4gc2hhcGVcbiAgc2luOiBmdW5jdGlvbiAodCkgeyByZXR1cm4gKDEgKyBNYXRoLnNpbihNYXRoLlBJKnQtTWF0aC5QSS8yKSkvMiB9XG59XG4iLCIvLyBodHRwczovL2dpdGh1Yi5jb20vbWlrb2xhbHlzZW5rby9tb3VzZS1ldmVudFxuXG5jb25zdCBtb3VzZSA9IHt9XG5cbmZ1bmN0aW9uIG1vdXNlQnV0dG9ucyhldikge1xuICBpZih0eXBlb2YgZXYgPT09ICdvYmplY3QnKSB7XG4gICAgaWYoJ2J1dHRvbnMnIGluIGV2KSB7XG4gICAgICByZXR1cm4gZXYuYnV0dG9uc1xuICAgIH0gZWxzZSBpZignd2hpY2gnIGluIGV2KSB7XG4gICAgICB2YXIgYiA9IGV2LndoaWNoXG4gICAgICBpZihiID09PSAyKSB7XG4gICAgICAgIHJldHVybiA0XG4gICAgICB9IGVsc2UgaWYoYiA9PT0gMykge1xuICAgICAgICByZXR1cm4gMlxuICAgICAgfSBlbHNlIGlmKGIgPiAwKSB7XG4gICAgICAgIHJldHVybiAxPDwoYi0xKVxuICAgICAgfVxuICAgIH0gZWxzZSBpZignYnV0dG9uJyBpbiBldikge1xuICAgICAgdmFyIGIgPSBldi5idXR0b25cbiAgICAgIGlmKGIgPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIDRcbiAgICAgIH0gZWxzZSBpZihiID09PSAyKSB7XG4gICAgICAgIHJldHVybiAyXG4gICAgICB9IGVsc2UgaWYoYiA+PSAwKSB7XG4gICAgICAgIHJldHVybiAxPDxiXG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiAwXG59XG5tb3VzZS5idXR0b25zID0gbW91c2VCdXR0b25zXG5cbmZ1bmN0aW9uIG1vdXNlRWxlbWVudChldikge1xuICByZXR1cm4gZXYudGFyZ2V0IHx8IGV2LnNyY0VsZW1lbnQgfHwgd2luZG93XG59XG5tb3VzZS5lbGVtZW50ID0gbW91c2VFbGVtZW50XG5cbmZ1bmN0aW9uIG1vdXNlUmVsYXRpdmVYKGV2KSB7XG4gIGlmKHR5cGVvZiBldiA9PT0gJ29iamVjdCcpIHtcbiAgICBpZigncGFnZVgnIGluIGV2KSB7XG4gICAgICByZXR1cm4gZXYucGFnZVhcbiAgICB9XG4gIH1cbiAgcmV0dXJuIDBcbn1cbm1vdXNlLnggPSBtb3VzZVJlbGF0aXZlWFxuXG5mdW5jdGlvbiBtb3VzZVJlbGF0aXZlWShldikge1xuICBpZih0eXBlb2YgZXYgPT09ICdvYmplY3QnKSB7XG4gICAgaWYoJ3BhZ2VZJyBpbiBldikge1xuICAgICAgcmV0dXJuIGV2LnBhZ2VZXG4gICAgfVxuICB9XG4gIHJldHVybiAwXG59XG5tb3VzZS55ID0gbW91c2VSZWxhdGl2ZVlcblxuZXhwb3J0IGRlZmF1bHQgbW91c2UiLCIvLyBiYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vbWlrb2xhbHlzZW5rby9tb3VzZS1jaGFuZ2VcblxuZXhwb3J0IGRlZmF1bHQgbW91c2VMaXN0ZW5cblxuaW1wb3J0IG1vdXNlIGZyb20gJy4vbW91c2UtZXZlbnQuanMnXG5cbmZ1bmN0aW9uIG1vdXNlTGlzdGVuIChlbGVtZW50LCBjYWxsYmFjaykge1xuICBpZiAoIWNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2sgPSBlbGVtZW50XG4gICAgZWxlbWVudCA9IHdpbmRvd1xuICB9XG5cbiAgdmFyIGJ1dHRvblN0YXRlID0gMFxuICB2YXIgeCA9IDBcbiAgdmFyIHkgPSAwXG4gIHZhciBtb2RzID0ge1xuICAgIHNoaWZ0OiBmYWxzZSxcbiAgICBhbHQ6IGZhbHNlLFxuICAgIGNvbnRyb2w6IGZhbHNlLFxuICAgIG1ldGE6IGZhbHNlXG4gIH1cbiAgdmFyIGF0dGFjaGVkID0gZmFsc2VcblxuICBmdW5jdGlvbiB1cGRhdGVNb2RzIChldikge1xuICAgIHZhciBjaGFuZ2VkID0gZmFsc2VcbiAgICBpZiAoJ2FsdEtleScgaW4gZXYpIHtcbiAgICAgIGNoYW5nZWQgPSBjaGFuZ2VkIHx8IGV2LmFsdEtleSAhPT0gbW9kcy5hbHRcbiAgICAgIG1vZHMuYWx0ID0gISFldi5hbHRLZXlcbiAgICB9XG4gICAgaWYgKCdzaGlmdEtleScgaW4gZXYpIHtcbiAgICAgIGNoYW5nZWQgPSBjaGFuZ2VkIHx8IGV2LnNoaWZ0S2V5ICE9PSBtb2RzLnNoaWZ0XG4gICAgICBtb2RzLnNoaWZ0ID0gISFldi5zaGlmdEtleVxuICAgIH1cbiAgICBpZiAoJ2N0cmxLZXknIGluIGV2KSB7XG4gICAgICBjaGFuZ2VkID0gY2hhbmdlZCB8fCBldi5jdHJsS2V5ICE9PSBtb2RzLmNvbnRyb2xcbiAgICAgIG1vZHMuY29udHJvbCA9ICEhZXYuY3RybEtleVxuICAgIH1cbiAgICBpZiAoJ21ldGFLZXknIGluIGV2KSB7XG4gICAgICBjaGFuZ2VkID0gY2hhbmdlZCB8fCBldi5tZXRhS2V5ICE9PSBtb2RzLm1ldGFcbiAgICAgIG1vZHMubWV0YSA9ICEhZXYubWV0YUtleVxuICAgIH1cbiAgICByZXR1cm4gY2hhbmdlZFxuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlRXZlbnQgKG5leHRCdXR0b25zLCBldikge1xuICAgIHZhciBuZXh0WCA9IG1vdXNlLngoZXYpXG4gICAgdmFyIG5leHRZID0gbW91c2UueShldilcbiAgICBpZiAoJ2J1dHRvbnMnIGluIGV2KSB7XG4gICAgICBuZXh0QnV0dG9ucyA9IGV2LmJ1dHRvbnMgfCAwXG4gICAgfVxuICAgIGlmIChuZXh0QnV0dG9ucyAhPT0gYnV0dG9uU3RhdGUgfHxcbiAgICAgIG5leHRYICE9PSB4IHx8XG4gICAgICBuZXh0WSAhPT0geSB8fFxuICAgICAgdXBkYXRlTW9kcyhldikpIHtcbiAgICAgIGJ1dHRvblN0YXRlID0gbmV4dEJ1dHRvbnMgfCAwXG4gICAgICB4ID0gbmV4dFggfHwgMFxuICAgICAgeSA9IG5leHRZIHx8IDBcbiAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKGJ1dHRvblN0YXRlLCB4LCB5LCBtb2RzKVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNsZWFyU3RhdGUgKGV2KSB7XG4gICAgaGFuZGxlRXZlbnQoMCwgZXYpXG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVCbHVyICgpIHtcbiAgICBpZiAoYnV0dG9uU3RhdGUgfHxcbiAgICAgIHggfHxcbiAgICAgIHkgfHxcbiAgICAgIG1vZHMuc2hpZnQgfHxcbiAgICAgIG1vZHMuYWx0IHx8XG4gICAgICBtb2RzLm1ldGEgfHxcbiAgICAgIG1vZHMuY29udHJvbCkge1xuICAgICAgeCA9IHkgPSAwXG4gICAgICBidXR0b25TdGF0ZSA9IDBcbiAgICAgIG1vZHMuc2hpZnQgPSBtb2RzLmFsdCA9IG1vZHMuY29udHJvbCA9IG1vZHMubWV0YSA9IGZhbHNlXG4gICAgICBjYWxsYmFjayAmJiBjYWxsYmFjaygwLCAwLCAwLCBtb2RzKVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZU1vZHMgKGV2KSB7XG4gICAgaWYgKHVwZGF0ZU1vZHMoZXYpKSB7XG4gICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhidXR0b25TdGF0ZSwgeCwgeSwgbW9kcylcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVNb3VzZU1vdmUgKGV2KSB7XG4gICAgaWYgKG1vdXNlLmJ1dHRvbnMoZXYpID09PSAwKSB7XG4gICAgICBoYW5kbGVFdmVudCgwLCBldilcbiAgICB9IGVsc2Uge1xuICAgICAgaGFuZGxlRXZlbnQoYnV0dG9uU3RhdGUsIGV2KVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZU1vdXNlRG93biAoZXYpIHtcbiAgICBoYW5kbGVFdmVudChidXR0b25TdGF0ZSB8IG1vdXNlLmJ1dHRvbnMoZXYpLCBldilcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZU1vdXNlVXAgKGV2KSB7XG4gICAgaGFuZGxlRXZlbnQoYnV0dG9uU3RhdGUgJiB+bW91c2UuYnV0dG9ucyhldiksIGV2KVxuICB9XG5cbiAgZnVuY3Rpb24gYXR0YWNoTGlzdGVuZXJzICgpIHtcbiAgICBpZiAoYXR0YWNoZWQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBhdHRhY2hlZCA9IHRydWVcblxuICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgaGFuZGxlTW91c2VNb3ZlKVxuXG4gICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBoYW5kbGVNb3VzZURvd24pXG5cbiAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBoYW5kbGVNb3VzZVVwKVxuXG4gICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgY2xlYXJTdGF0ZSlcbiAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZW50ZXInLCBjbGVhclN0YXRlKVxuICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VvdXQnLCBjbGVhclN0YXRlKVxuICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VvdmVyJywgY2xlYXJTdGF0ZSlcblxuICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignYmx1cicsIGhhbmRsZUJsdXIpXG5cbiAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleXVwJywgaGFuZGxlTW9kcylcbiAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBoYW5kbGVNb2RzKVxuICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2V5cHJlc3MnLCBoYW5kbGVNb2RzKVxuXG4gICAgaWYgKGVsZW1lbnQgIT09IHdpbmRvdykge1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2JsdXInLCBoYW5kbGVCbHVyKVxuXG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigna2V5dXAnLCBoYW5kbGVNb2RzKVxuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBoYW5kbGVNb2RzKVxuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2tleXByZXNzJywgaGFuZGxlTW9kcylcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBkZXRhY2hMaXN0ZW5lcnMgKCkge1xuICAgIGlmICghYXR0YWNoZWQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBhdHRhY2hlZCA9IGZhbHNlXG5cbiAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIGhhbmRsZU1vdXNlTW92ZSlcblxuICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgaGFuZGxlTW91c2VEb3duKVxuXG4gICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgaGFuZGxlTW91c2VVcClcblxuICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsIGNsZWFyU3RhdGUpXG4gICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWVudGVyJywgY2xlYXJTdGF0ZSlcbiAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlb3V0JywgY2xlYXJTdGF0ZSlcbiAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlb3ZlcicsIGNsZWFyU3RhdGUpXG5cbiAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2JsdXInLCBoYW5kbGVCbHVyKVxuXG4gICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXl1cCcsIGhhbmRsZU1vZHMpXG4gICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgaGFuZGxlTW9kcylcbiAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleXByZXNzJywgaGFuZGxlTW9kcylcblxuICAgIGlmIChlbGVtZW50ICE9PSB3aW5kb3cpIHtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdibHVyJywgaGFuZGxlQmx1cilcblxuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleXVwJywgaGFuZGxlTW9kcylcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgaGFuZGxlTW9kcylcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlwcmVzcycsIGhhbmRsZU1vZHMpXG4gICAgfVxuICB9XG5cbiAgLy8gQXR0YWNoIGxpc3RlbmVyc1xuICBhdHRhY2hMaXN0ZW5lcnMoKVxuXG4gIHZhciByZXN1bHQgPSB7XG4gICAgZWxlbWVudDogZWxlbWVudFxuICB9XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMocmVzdWx0LCB7XG4gICAgZW5hYmxlZDoge1xuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBhdHRhY2hlZCB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiAoZikge1xuICAgICAgICBpZiAoZikge1xuICAgICAgICAgIGF0dGFjaExpc3RlbmVycygpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGV0YWNoTGlzdGVuZXJzKClcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICB9LFxuICAgIGJ1dHRvbnM6IHtcbiAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYnV0dG9uU3RhdGUgfSxcbiAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICB9LFxuICAgIHg6IHtcbiAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4geCB9LFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgIH0sXG4gICAgeToge1xuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB5IH0sXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgfSxcbiAgICBtb2RzOiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1vZHMgfSxcbiAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICB9XG4gIH0pXG5cbiAgcmV0dXJuIHJlc3VsdFxufVxuIiwiLy8gYXR0ZW1wdCBjdXN0b20gZXZhbHVhdGlvbiBzYW5kYm94IGZvciBoeWRyYSBmdW5jdGlvbnNcbi8vIGZvciBub3csIGp1c3QgYXZvaWRzIHBvbGx1dGluZyB0aGUgZ2xvYmFsIG5hbWVzcGFjZVxuLy8gc2hvdWxkIHByb2JhYmx5IGJlIHJlcGxhY2VkIHdpdGggYW4gYWJzdHJhY3Qgc3ludGF4IHRyZWVcblxuZXhwb3J0IGRlZmF1bHQgKHBhcmVudCkgPT4ge1xuICB2YXIgaW5pdGlhbENvZGUgPSBgYFxuXG4gIHZhciBzYW5kYm94ID0gY3JlYXRlU2FuZGJveChpbml0aWFsQ29kZSlcblxuICB2YXIgYWRkVG9Db250ZXh0ID0gKG5hbWUsIG9iamVjdCkgPT4ge1xuICAgIGluaXRpYWxDb2RlICs9IGBcbiAgICAgIHZhciAke25hbWV9ID0gJHtvYmplY3R9XG4gICAgYFxuICAgIHNhbmRib3ggPSBjcmVhdGVTYW5kYm94KGluaXRpYWxDb2RlKVxuICB9XG5cblxuICByZXR1cm4ge1xuICAgIGFkZFRvQ29udGV4dDogYWRkVG9Db250ZXh0LFxuICAgIGV2YWw6IChjb2RlKSA9PiBzYW5kYm94LmV2YWwoY29kZSlcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVNhbmRib3ggKGluaXRpYWwpIHtcbiAgICBnbG9iYWxUaGlzLmV2YWwoaW5pdGlhbClcbiAgICAvLyBvcHRpb25hbCBwYXJhbXNcbiAgICB2YXIgbG9jYWxFdmFsID0gZnVuY3Rpb24gKGNvZGUpICB7XG4gICAgICBnbG9iYWxUaGlzLmV2YWwoY29kZSlcbiAgICB9XG5cbiAgICAvLyBBUEkvZGF0YSBmb3IgZW5kLXVzZXJcbiAgICByZXR1cm4ge1xuICAgICAgZXZhbDogbG9jYWxFdmFsXG4gICAgfVxuICB9XG59XG4iLCJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAvLyAgYXN5bmMgZnVuY3Rpb24gc3RhcnRDYXB0dXJlKGRpc3BsYXlNZWRpYU9wdGlvbnMpIHtcbiAgICBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldERpc3BsYXlNZWRpYShvcHRpb25zKS50aGVuKChzdHJlYW0pID0+IHtcbiAgICAgIGNvbnN0IHZpZGVvID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndmlkZW8nKVxuICAgICAgdmlkZW8uc3JjT2JqZWN0ID0gc3RyZWFtXG4gICAgICB2aWRlby5hZGRFdmVudExpc3RlbmVyKCdsb2FkZWRtZXRhZGF0YScsICgpID0+IHtcbiAgICAgICAgdmlkZW8ucGxheSgpXG4gICAgICAgIHJlc29sdmUoe3ZpZGVvOiB2aWRlb30pXG4gICAgICB9KVxuICAgIH0pLmNhdGNoKChlcnIpID0+IHJlamVjdChlcnIpKVxuICB9KVxufVxuIiwiY2xhc3MgVmlkZW9SZWNvcmRlciB7XG4gIGNvbnN0cnVjdG9yKHN0cmVhbSkge1xuICAgIHRoaXMubWVkaWFTb3VyY2UgPSBuZXcgTWVkaWFTb3VyY2UoKVxuICAgIHRoaXMuc3RyZWFtID0gc3RyZWFtXG5cbiAgICAvLyB0ZXN0aW5nIHVzaW5nIGEgcmVjb3JkaW5nIGFzIGlucHV0XG4gICAgdGhpcy5vdXRwdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd2aWRlbycpXG4gICAgdGhpcy5vdXRwdXQuYXV0b3BsYXkgPSB0cnVlXG4gICAgdGhpcy5vdXRwdXQubG9vcCA9IHRydWVcblxuICAgIGxldCBzZWxmID0gdGhpc1xuICAgIHRoaXMubWVkaWFTb3VyY2UuYWRkRXZlbnRMaXN0ZW5lcignc291cmNlb3BlbicsICgpID0+IHtcbiAgICAgIGNvbnNvbGUubG9nKCdNZWRpYVNvdXJjZSBvcGVuZWQnKTtcbiAgICAgIHNlbGYuc291cmNlQnVmZmVyID0gc2VsZi5tZWRpYVNvdXJjZS5hZGRTb3VyY2VCdWZmZXIoJ3ZpZGVvL3dlYm07IGNvZGVjcz1cInZwOFwiJyk7XG4gICAgICBjb25zb2xlLmxvZygnU291cmNlIGJ1ZmZlcjogJywgc291cmNlQnVmZmVyKTtcbiAgICB9KVxuICB9XG5cbiAgc3RhcnQoKSB7XG4gIC8vICBsZXQgb3B0aW9ucyA9IHttaW1lVHlwZTogJ3ZpZGVvL3dlYm0nfTtcblxuLy8gICBsZXQgb3B0aW9ucyA9IHttaW1lVHlwZTogJ3ZpZGVvL3dlYm07Y29kZWNzPWgyNjQnfTtcbiAgIGxldCBvcHRpb25zID0ge21pbWVUeXBlOiAndmlkZW8vd2VibTtjb2RlY3M9dnA5J307XG5cbiAgICB0aGlzLnJlY29yZGVkQmxvYnMgPSBbXVxuICAgIHRyeSB7XG4gICAgIHRoaXMubWVkaWFSZWNvcmRlciA9IG5ldyBNZWRpYVJlY29yZGVyKHRoaXMuc3RyZWFtLCBvcHRpb25zKVxuICAgIH0gY2F0Y2ggKGUwKSB7XG4gICAgIGNvbnNvbGUubG9nKCdVbmFibGUgdG8gY3JlYXRlIE1lZGlhUmVjb3JkZXIgd2l0aCBvcHRpb25zIE9iamVjdDogJywgZTApXG4gICAgIHRyeSB7XG4gICAgICAgb3B0aW9ucyA9IHttaW1lVHlwZTogJ3ZpZGVvL3dlYm0sY29kZWNzPXZwOSd9XG4gICAgICAgdGhpcy5tZWRpYVJlY29yZGVyID0gbmV3IE1lZGlhUmVjb3JkZXIodGhpcy5zdHJlYW0sIG9wdGlvbnMpXG4gICAgIH0gY2F0Y2ggKGUxKSB7XG4gICAgICAgY29uc29sZS5sb2coJ1VuYWJsZSB0byBjcmVhdGUgTWVkaWFSZWNvcmRlciB3aXRoIG9wdGlvbnMgT2JqZWN0OiAnLCBlMSlcbiAgICAgICB0cnkge1xuICAgICAgICAgb3B0aW9ucyA9ICd2aWRlby92cDgnIC8vIENocm9tZSA0N1xuICAgICAgICAgdGhpcy5tZWRpYVJlY29yZGVyID0gbmV3IE1lZGlhUmVjb3JkZXIodGhpcy5zdHJlYW0sIG9wdGlvbnMpXG4gICAgICAgfSBjYXRjaCAoZTIpIHtcbiAgICAgICAgIGFsZXJ0KCdNZWRpYVJlY29yZGVyIGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhpcyBicm93c2VyLlxcblxcbicgK1xuICAgICAgICAgICAnVHJ5IEZpcmVmb3ggMjkgb3IgbGF0ZXIsIG9yIENocm9tZSA0NyBvciBsYXRlciwgJyArXG4gICAgICAgICAgICd3aXRoIEVuYWJsZSBleHBlcmltZW50YWwgV2ViIFBsYXRmb3JtIGZlYXR1cmVzIGVuYWJsZWQgZnJvbSBjaHJvbWU6Ly9mbGFncy4nKVxuICAgICAgICAgY29uc29sZS5lcnJvcignRXhjZXB0aW9uIHdoaWxlIGNyZWF0aW5nIE1lZGlhUmVjb3JkZXI6JywgZTIpXG4gICAgICAgICByZXR1cm5cbiAgICAgICB9XG4gICAgIH1cbiAgIH1cbiAgIGNvbnNvbGUubG9nKCdDcmVhdGVkIE1lZGlhUmVjb3JkZXInLCB0aGlzLm1lZGlhUmVjb3JkZXIsICd3aXRoIG9wdGlvbnMnLCBvcHRpb25zKTtcbiAgIHRoaXMubWVkaWFSZWNvcmRlci5vbnN0b3AgPSB0aGlzLl9oYW5kbGVTdG9wLmJpbmQodGhpcylcbiAgIHRoaXMubWVkaWFSZWNvcmRlci5vbmRhdGFhdmFpbGFibGUgPSB0aGlzLl9oYW5kbGVEYXRhQXZhaWxhYmxlLmJpbmQodGhpcylcbiAgIHRoaXMubWVkaWFSZWNvcmRlci5zdGFydCgxMDApIC8vIGNvbGxlY3QgMTAwbXMgb2YgZGF0YVxuICAgY29uc29sZS5sb2coJ01lZGlhUmVjb3JkZXIgc3RhcnRlZCcsIHRoaXMubWVkaWFSZWNvcmRlcilcbiB9XG5cbiAgXG4gICBzdG9wKCl7XG4gICAgIHRoaXMubWVkaWFSZWNvcmRlci5zdG9wKClcbiAgIH1cblxuIF9oYW5kbGVTdG9wKCkge1xuICAgLy9jb25zdCBzdXBlckJ1ZmZlciA9IG5ldyBCbG9iKHJlY29yZGVkQmxvYnMsIHt0eXBlOiAndmlkZW8vd2VibSd9KVxuICAgLy8gY29uc3QgYmxvYiA9IG5ldyBCbG9iKHRoaXMucmVjb3JkZWRCbG9icywge3R5cGU6ICd2aWRlby93ZWJtO2NvZGVjcz1oMjY0J30pXG4gIGNvbnN0IGJsb2IgPSBuZXcgQmxvYih0aGlzLnJlY29yZGVkQmxvYnMsIHt0eXBlOiB0aGlzLm1lZGlhUmVjb3JkZXIubWltZVR5cGV9KVxuICAgY29uc3QgdXJsID0gd2luZG93LlVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYilcbiAgIHRoaXMub3V0cHV0LnNyYyA9IHVybFxuXG4gICAgY29uc3QgYSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKVxuICAgIGEuc3R5bGUuZGlzcGxheSA9ICdub25lJ1xuICAgIGEuaHJlZiA9IHVybFxuICAgIGxldCBkID0gbmV3IERhdGUoKVxuICAgIGEuZG93bmxvYWQgPSBgaHlkcmEtJHtkLmdldEZ1bGxZZWFyKCl9LSR7ZC5nZXRNb250aCgpICsgMX0tJHtkLmdldERhdGUoKX0tJHtkLmdldEhvdXJzKCl9LiR7ZC5nZXRNaW51dGVzKCl9LiR7ZC5nZXRTZWNvbmRzKCl9LndlYm1gXG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChhKVxuICAgIGEuY2xpY2soKVxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChhKTtcbiAgICAgIHdpbmRvdy5VUkwucmV2b2tlT2JqZWN0VVJMKHVybCk7XG4gICAgfSwgMzAwKTtcbiAgfVxuXG4gIF9oYW5kbGVEYXRhQXZhaWxhYmxlKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LmRhdGEgJiYgZXZlbnQuZGF0YS5zaXplID4gMCkge1xuICAgICAgdGhpcy5yZWNvcmRlZEJsb2JzLnB1c2goZXZlbnQuZGF0YSk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFZpZGVvUmVjb3JkZXJcbiIsIi8vY29uc3QgZW51bWVyYXRlRGV2aWNlcyA9IHJlcXVpcmUoJ2VudW1lcmF0ZS1kZXZpY2VzJylcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKGRldmljZUlkKSB7XG4gIHJldHVybiBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmVudW1lcmF0ZURldmljZXMoKVxuICAgIC50aGVuKGRldmljZXMgPT4gZGV2aWNlcy5maWx0ZXIoZGV2aWNlcyA9PiBkZXZpY2VzLmtpbmQgPT09ICd2aWRlb2lucHV0JykpXG4gICAgLnRoZW4oY2FtZXJhcyA9PiB7XG4gICAgICBsZXQgY29uc3RyYWludHMgPSB7IGF1ZGlvOiBmYWxzZSwgdmlkZW86IHRydWV9XG4gICAgICBpZiAoY2FtZXJhc1tkZXZpY2VJZF0pIHtcbiAgICAgICAgY29uc3RyYWludHNbJ3ZpZGVvJ10gPSB7XG4gICAgICAgICAgZGV2aWNlSWQ6IHsgZXhhY3Q6IGNhbWVyYXNbZGV2aWNlSWRdLmRldmljZUlkIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIC8vICBjb25zb2xlLmxvZyhjYW1lcmFzKVxuICAgICAgcmV0dXJuIHdpbmRvdy5uYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYShjb25zdHJhaW50cylcbiAgICB9KVxuICAgIC50aGVuKHN0cmVhbSA9PiB7XG4gICAgICBjb25zdCB2aWRlbyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3ZpZGVvJylcbiAgICAgIHZpZGVvLnNldEF0dHJpYnV0ZSgnYXV0b3BsYXknLCAnJylcbiAgICAgIHZpZGVvLnNldEF0dHJpYnV0ZSgnbXV0ZWQnLCAnJylcbiAgICAgIHZpZGVvLnNldEF0dHJpYnV0ZSgncGxheXNpbmxpbmUnLCAnJylcbiAgICAgIC8vICB2aWRlby5zcmMgPSB3aW5kb3cuVVJMLmNyZWF0ZU9iamVjdFVSTChzdHJlYW0pXG4gICAgICB2aWRlby5zcmNPYmplY3QgPSBzdHJlYW1cbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIHZpZGVvLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWRlZG1ldGFkYXRhJywgKCkgPT4ge1xuICAgICAgICAgIHZpZGVvLnBsYXkoKS50aGVuKCgpID0+IHJlc29sdmUoe3ZpZGVvOiB2aWRlb30pKVxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICB9KVxuICAgIC5jYXRjaChjb25zb2xlLmxvZy5iaW5kKGNvbnNvbGUpKVxufVxuIiwiaW1wb3J0ICogYXMgbWF0NCBmcm9tIFwiZ2wtbWF0NFwiO1xuaW1wb3J0IEdsc2xTb3VyY2UgZnJvbSBcIi4vZ2xzbC1zb3VyY2UuanNcIjtcblxudmFyIE91dHB1dCA9IGZ1bmN0aW9uIChpbmRleCwgc3ludGgpIHtcbiAgdGhpcy5pZCA9IGluZGV4O1xuICB0aGlzLnN5bnRoID0gc3ludGg7XG4gIHRoaXMud2lkdGggPSBzeW50aC53aWR0aFxuICB0aGlzLmhlaWdodCA9IHN5bnRoLmhlaWdodFxuICB0aGlzLnJlZ2wgPSBzeW50aC5yZWdsXG4gIHRoaXMucHJlY2lzaW9uID0gc3ludGgucHJlY2lzaW9uXG4gIHRoaXMubGFiZWwgPSBgbyR7aW5kZXh9YFxuICB0aGlzLnBvc2l0aW9uQnVmZmVyID0gdGhpcy5yZWdsLmJ1ZmZlcihbXG4gICAgWy01LCAtMSwgMF0sXG4gICAgWy0xLCAtNSwgMF0sXG4gICAgWzMsIDMsIDBdXG4gIF0pXG4gIHRoaXMudXZCdWZmZXIgPSB0aGlzLnJlZ2wuYnVmZmVyKFtcbiAgICBbLTIsIDBdLFxuICAgIFswLCAtMl0sXG4gICAgWzIsIDJdXG4gIF0pXG5cbiAgdGhpcy5kcmF3ID0gW11cbiAgdGhpcy5pbml0KClcbiAgdGhpcy5waW5nUG9uZ0luZGV4ID0gMFxuXG4gIC8vIGZvciBlYWNoIG91dHB1dCwgY3JlYXRlIHR3byBmYm9zIGZvciBwaW5ncG9uZ2luZ1xuICB0aGlzLmZib3MgPSAoQXJyYXkoMikpLmZpbGwoKS5tYXAoKCkgPT4gdGhpcy5faW5pdEZibygpKVxuXG4gIC8vIGZvciBlYWNoIG91dHB1dCwgY3JlYXRlIHR3byB0ZW1wIGJ1ZmZlcnNcbiAgdGhpcy50ZW1wID0gKEFycmF5KDIpKS5maWxsKCkubWFwKCgpID0+IHRoaXMuX2luaXRGYm8oKSlcblxuICB0aGlzLmNvcHlQYXNzID0gdGhpcy5yZWdsKHtcbiAgICBmcmFnOiBgXG4gICAgICBwcmVjaXNpb24gJHt0aGlzLnByZWNpc2lvbn0gZmxvYXQ7XG4gICAgICB2YXJ5aW5nIHZlYzIgdXY7XG4gICAgICB1bmlmb3JtIHNhbXBsZXIyRCB0ZXgwO1xuXG4gICAgICB2b2lkIG1haW4gKCkge1xuICAgICAgICBnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlMkQodGV4MCwgdXYpO1xuICAgICAgfVxuICAgICAgYCxcbiAgICB2ZXJ0OiBgXG4gICAgICBwcmVjaXNpb24gJHt0aGlzLnByZWNpc2lvbn0gZmxvYXQ7XG4gICAgICBhdHRyaWJ1dGUgdmVjMiBwb3NpdGlvbjtcbiAgICAgIHZhcnlpbmcgdmVjMiB1djtcblxuICAgICAgdm9pZCBtYWluICgpIHtcbiAgICAgICAgdXYgPSBwb3NpdGlvbjtcbiAgICAgICAgZ2xfUG9zaXRpb24gPSB2ZWM0KDIuMCAqIHBvc2l0aW9uIC0gMS4wLCAwLCAxKTtcbiAgICAgIH1gLFxuICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgIHBvc2l0aW9uOiBbXG4gICAgICAgIFstMiwgMF0sXG4gICAgICAgIFswLCAtMl0sXG4gICAgICAgIFsyLCAyXVxuICAgICAgXVxuICAgIH0sXG4gICAgdW5pZm9ybXM6IHtcbiAgICAgIHRleDA6IHRoaXMucmVnbC5wcm9wKCd0ZXgwJyksXG4gICAgfSxcbiAgICBjb3VudDogMyxcbiAgICBkZXB0aDogeyBlbmFibGU6IGZhbHNlIH0sXG4gICAgZnJhbWVidWZmZXI6ICgpID0+IHRoaXMuZ2V0VGV4dHVyZSgpLFxuICB9KVxufVxuXG5PdXRwdXQucHJvdG90eXBlLl9pbml0RmJvID0gZnVuY3Rpb24ob3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHtjb2xvciwgLi4uZmJPcHRpb25zfSA9IE9iamVjdC5hc3NpZ24oe1xuICAgIGNvbG9yOiB7XG4gICAgICBtYWc6ICduZWFyZXN0JyxcbiAgICAgIHdpZHRoOiB0aGlzLndpZHRoLFxuICAgICAgaGVpZ2h0OiB0aGlzLmhlaWdodCxcbiAgICAgIGZvcm1hdDogJ3JnYmEnXG4gICAgfSxcbiAgfSwgb3B0aW9ucyk7XG4gIHJldHVybiB0aGlzLnJlZ2wuZnJhbWVidWZmZXIoe1xuICAgIGNvbG9yOiB0aGlzLnJlZ2wudGV4dHVyZShjb2xvciksXG4gICAgZGVwdGhTdGVuY2lsOiBmYWxzZSxcbiAgICAuLi5mYk9wdGlvbnMsXG4gIH0pXG59XG5cbk91dHB1dC5wcm90b3R5cGUucmVzaXplID0gZnVuY3Rpb24od2lkdGgsIGhlaWdodCkge1xuICB0aGlzLndpZHRoID0gd2lkdGg7XG4gIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICB0aGlzLmZib3MuZm9yRWFjaCgoZmJvKSA9PiB7XG4gICAgZmJvLnJlc2l6ZSh3aWR0aCwgaGVpZ2h0KVxuICB9KVxuICB0aGlzLnRlbXAuZm9yRWFjaCgodG1wKSA9PiB7XG4gICAgdG1wLnJlc2l6ZSh3aWR0aCwgaGVpZ2h0KVxuICB9KVxufVxuXG5cbk91dHB1dC5wcm90b3R5cGUuZ2V0Q3VycmVudCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuZmJvc1t0aGlzLnBpbmdQb25nSW5kZXhdXG59XG5cbk91dHB1dC5wcm90b3R5cGUuZ2V0VGV4dHVyZSA9IGZ1bmN0aW9uICgpIHtcbiAgIHZhciBpbmRleCA9IHRoaXMucGluZ1BvbmdJbmRleCA/IDAgOiAxXG4gIHJldHVybiB0aGlzLmZib3NbaW5kZXhdXG59XG5cbk91dHB1dC5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5hdHRyaWJ1dGVzID0ge1xuICAgIHBvc2l0aW9uOiB0aGlzLnBvc2l0aW9uQnVmZmVyLFxuICAgIHV2OiB0aGlzLnV2QnVmZmVyLFxuICB9XG4gIHRoaXMudW5pZm9ybXMgPSB7XG4gICAgdGltZTogdGhpcy5yZWdsLnByb3AoJ3RpbWUnKSxcbiAgICByZXNvbHV0aW9uOiB0aGlzLnJlZ2wucHJvcCgncmVzb2x1dGlvbicpLFxuICB9XG5cbiAgdGhpcy5pbml0Q2FtZXJhKCk7XG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuT3V0cHV0LnByb3RvdHlwZS5pbml0Q2FtZXJhID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2NhbWVyYSA9IHRoaXMucmVnbCh7XG4gICAgY29udGV4dDoge1xuICAgICAgcHJvamVjdGlvbjogbWF0NC5pZGVudGl0eShbXSksXG4gICAgICB2aWV3OiBtYXQ0LmlkZW50aXR5KFtdKSxcbiAgICB9LFxuICAgIHVuaWZvcm1zOiB7XG4gICAgICB2aWV3OiB0aGlzLnJlZ2wuY29udGV4dCgndmlldycpLFxuICAgICAgcHJvamVjdGlvbjogdGhpcy5yZWdsLmNvbnRleHQoJ3Byb2plY3Rpb24nKVxuICAgIH1cbiAgfSk7XG59XG5cbk91dHB1dC5wcm90b3R5cGUuY2FtZXJhID0gZnVuY3Rpb24oZXllLCB0YXJnZXQgPSBbMCwwLDBdLCBvcHRpb25zID0ge30pIHtcbiAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe1xuICAgIGZvdnk6IE1hdGguUEkgLyA0LFxuICAgIG5lYXI6IDAuMSxcbiAgICBmYXI6IDEwMDAuMCxcbiAgfSwgb3B0aW9ucyk7XG4gIHRoaXMuZXllID0gZXllO1xuICB0aGlzLnRhcmdldCA9IHRhcmdldDtcbiAgaWYgKGV5ZSAmJiB0YXJnZXQpIHtcbiAgICB0aGlzLl9jYW1lcmEgPSB0aGlzLnJlZ2woe1xuICAgICAgY29udGV4dDoge1xuICAgICAgICBwcm9qZWN0aW9uOiBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgICAgIGlmIChvcHRpb25zLnR5cGUgPT09ICdwZXJzcGVjdGl2ZScpIHtcbiAgICAgICAgICAgIHJldHVybiBtYXQ0LnBlcnNwZWN0aXZlKFtdLFxuICAgICAgICAgICAgICAgIG9wdGlvbnMuZm92eSxcbiAgICAgICAgICAgICAgICBvcHRpb25zLmFzcGVjdCB8fCAoY29udGV4dC52aWV3cG9ydFdpZHRoIC8gY29udGV4dC52aWV3cG9ydEhlaWdodCksXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5uZWFyLFxuICAgICAgICAgICAgICAgIG9wdGlvbnMuZmFyKVxuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBtYXQ0Lm9ydGhvKFtdLCAtMS4wLCAxLjAsIC0xLjAsIDEuMCwgb3B0aW9ucy5uZWFyLCBvcHRpb25zLmZhcik7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB2aWV3OiBmdW5jdGlvbiAoY29udGV4dCwgcHJvcHMpIHtcbiAgICAgICAgICByZXR1cm4gbWF0NC5sb29rQXQoW10sXG4gICAgICAgICAgICAgIHByb3BzLmV5ZSxcbiAgICAgICAgICAgICAgcHJvcHMudGFyZ2V0LFxuICAgICAgICAgICAgICBbMCwgMSwgMF0pXG4gICAgICAgIH0sXG4gICAgICAgIGV5ZTogdGhpcy5yZWdsLnByb3AoJ2V5ZScpLFxuICAgICAgfSxcbiAgICAgIHVuaWZvcm1zOiB7XG4gICAgICAgIHZpZXc6IHRoaXMucmVnbC5jb250ZXh0KCd2aWV3JyksXG4gICAgICAgIHByb2plY3Rpb246IHRoaXMucmVnbC5jb250ZXh0KCdwcm9qZWN0aW9uJyksXG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgZWxzZSB7XG4gICAgdGhpcy5pbml0Q2FtZXJhKCk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59XG5cbk91dHB1dC5wcm90b3R5cGUucGVyc3BlY3RpdmUgPSBmdW5jdGlvbihleWUsIHRhcmdldCA9IFswLDAsMF0sIG9wdGlvbnMgPSB7fSkge1xuICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7dHlwZTogJ3BlcnNwZWN0aXZlJ30sIG9wdGlvbnMpO1xuICByZXR1cm4gdGhpcy5jYW1lcmEoZXllLCB0YXJnZXQsIG9wdGlvbnMpO1xufVxuXG5PdXRwdXQucHJvdG90eXBlLm9ydGhvID0gZnVuY3Rpb24oZXllLCB0YXJnZXQgPSBbMCwwLDBdLCBvcHRpb25zID0ge30pIHtcbiAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe3R5cGU6ICdvcnRobyd9LCBvcHRpb25zKTtcbiAgcmV0dXJuIHRoaXMuY2FtZXJhKGV5ZSwgdGFyZ2V0LCBvcHRpb25zKTtcbn1cblxuT3V0cHV0LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAocGFzc2VzKSB7XG4gIGNvbnN0IHNlbGYgPSB0aGlzXG4gIC8vIGVuc3VyZSBib3RoIGZibydzIGhhdmUgbGFzdCBmcmFtZVxuICB0aGlzLmNvcHlQYXNzKHtcbiAgICB0ZXgwOiB0aGlzLmdldEN1cnJlbnQoKSxcbiAgfSk7XG4gIHNlbGYuZHJhdyA9IFtdO1xuICBzZWxmLnBhc3NlcyA9IHBhc3NlcztcbiAgZm9yIChsZXQgaT0wOyBpPHBhc3Nlcy5sZW5ndGg7IGkrKykge1xuICAgIGxldCBwYXNzID0gcGFzc2VzW2ldXG4gICAgaWYgKHBhc3MuY2xlYXIpIHtcbiAgICAgIHN3aXRjaCAocGFzcy5jbGVhcikge1xuICAgICAgICBjYXNlICdjbGVhcic6XG4gICAgICAgICAgc2VsZi5kcmF3LnB1c2goLi4udGhpcy5jbGVhcihmYWxzZSkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdmYWRlJzoge1xuICAgICAgICAgIGNvbnN0IG9wdCA9IHR5cGVvZihwYXNzLnVzZXJBcmdzWzBdKSA9PT0gJ29iamVjdCcgPyBwYXNzLnVzZXJBcmdzWzBdIDoge2Ftb3VudDogcGFzcy51c2VyQXJnc1swXX07XG4gICAgICAgICAgb3B0Lm5vdyA9IGZhbHNlO1xuICAgICAgICAgIHNlbGYuZHJhdy5wdXNoKHRoaXMuZmFkZShvcHQpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGNvbnNvbGUud2FybihgdW5yZWNvZ25pemVkIGNsZWFyOiAke3Bhc3MuY2xlYXJ9KCR7cGFzcy51c2VyQXJncy5qb2luKFwiLCBcIil9KWApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgY29uc3Qge2F0dHJpYnV0ZXMsIGVsZW1lbnRzLCBwcmltaXRpdmV9ID0gdGhpcy5nZXRBdHRyaWJ1dGVzKHBhc3MucHJpbWl0aXZlLCBwYXNzLmdlb21ldHJ5KTtcbiAgICBjb25zdCB1bmlmb3JtcyA9IHRoaXMuZ2V0VW5pZm9ybXMocGFzcy51bmlmb3Jtcyk7XG4gICAgY29uc3QgYmxlbmQgPSB0aGlzLmdldEJsZW5kKHBhc3MuYmxlbmRNb2RlKTtcbiAgICBjb25zdCBkcmF3ID0gc2VsZi5yZWdsKHtcbiAgICAgIGZyYWc6IHBhc3MuZnJhZyxcbiAgICAgIHZlcnQ6IHBhc3MudmVydCxcbiAgICAgIHZpZXdwb3J0OiB0eXBlb2YocGFzcy52aWV3cG9ydC54KSAhPT0gJ3VuZGVmaW5lZCcgPyB7XG4gICAgICAgIHg6IHBhc3Mudmlld3BvcnQueCAqIHRoaXMuZmJvc1swXS53aWR0aCxcbiAgICAgICAgeTogcGFzcy52aWV3cG9ydC55ICogdGhpcy5mYm9zWzBdLmhlaWdodCxcbiAgICAgICAgd2lkdGg6IHBhc3Mudmlld3BvcnQudyAqIHRoaXMuZmJvc1swXS53aWR0aCxcbiAgICAgICAgaGVpZ2h0OiBwYXNzLnZpZXdwb3J0LmggKiB0aGlzLmZib3NbMF0uaGVpZ2h0LFxuICAgICAgfSA6IHt9LFxuICAgICAgY3VsbDoge1xuICAgICAgICBlbmFibGU6ICEhcGFzcy5nZW9tZXRyeSxcbiAgICAgICAgZmFjZTogJ2JhY2snXG4gICAgICB9LFxuICAgICAgYXR0cmlidXRlcyxcbiAgICAgIHByaW1pdGl2ZSxcbiAgICAgIHVuaWZvcm1zLFxuICAgICAgY291bnQ6IHR5cGVvZihlbGVtZW50cykgPT09ICdudW1iZXInID8gZWxlbWVudHMgOiBlbGVtZW50cy5sZW5ndGgsXG4gICAgICBlbGVtZW50czogdHlwZW9mKGVsZW1lbnRzKSA9PT0gJ251bWJlcicgPyBudWxsIDogZWxlbWVudHMsXG4gICAgICBibGVuZCxcbiAgICAgIGxpbmVXaWR0aDogcGFzcy5saW5lV2lkdGgsXG4gICAgICBmcmFtZWJ1ZmZlcjogcGFzcy5mcmFtZWJ1ZmZlciB8fCAoKCkgPT4ge1xuICAgICAgICBzZWxmLnBpbmdQb25nSW5kZXggPSBzZWxmLnBpbmdQb25nSW5kZXggPyAwIDogMVxuICAgICAgICByZXR1cm4gc2VsZi5mYm9zW3NlbGYucGluZ1BvbmdJbmRleF1cbiAgICAgIH0pLFxuICAgIH0pXG4gICAgc2VsZi5kcmF3LnB1c2goZHJhdylcbiAgfVxufVxuXG5PdXRwdXQucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24obm93ID0gdHJ1ZSkge1xuICBjb25zdCByZXN1bHQgPSBbdGhpcy5mYm9zWzBdLCB0aGlzLmZib3NbMV0sIHRoaXMudGVtcFswXSwgdGhpcy50ZW1wWzFdXS5tYXAoKGZibykgPT4ge1xuICAgIGNvbnN0IGNsZWFyID0gKCkgPT4gdGhpcy5yZWdsLmNsZWFyKHtcbiAgICAgIGNvbG9yOiBbMCwgMCwgMCwgMF0sXG4gICAgICBmcmFtZWJ1ZmZlcjogZmJvLFxuICAgIH0pO1xuICAgIGlmIChub3cpIGNsZWFyKCk7XG4gICAgZWxzZSByZXR1cm4gY2xlYXI7XG4gIH0pO1xuICBpZiAobm93KSByZXR1cm4gdGhpcztcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuT3V0cHV0LnByb3RvdHlwZS5mYWRlID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICBsZXQgYW1vdW50ID0gb3B0aW9ucztcbiAgbGV0IGNhbWVyYSA9IGZhbHNlO1xuICBsZXQgbm93ID0gdHJ1ZTtcbiAgaWYgKHR5cGVvZihvcHRpb25zKSA9PT0gJ29iamVjdCcpIHtcbiAgICAoe2Ftb3VudCwgY2FtZXJhfSA9IG9wdGlvbnMpO1xuICAgIG5vdyA9IHR5cGVvZihvcHRpb25zLm5vdykgPT09ICd1bmRlZmluZWQnID8gdHJ1ZSA6IG9wdGlvbnMubm93O1xuICB9XG4gIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAvLyB0b2RvOiBkbyB3ZSBuZWVkIHRvIGZhZGUgYWxzbyB0ZW1wIGJ1ZmZlcnM/XG4gIGNvbnN0IGZhZGUgPSBzZWxmLnJlZ2woe1xuICAgIGZyYWc6IGBcbiAgICAgICAgICBwcmVjaXNpb24gJHtzZWxmLnByZWNpc2lvbn0gZmxvYXQ7XG4gICAgICAgICAgdmFyeWluZyB2ZWMyIHZ1djtcbiAgICAgICAgICB1bmlmb3JtIHNhbXBsZXIyRCBwcmV2QnVmZmVyO1xuICAgICAgICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgICAgIHZlYzQgY29sb3IgPSBtaXgodGV4dHVyZTJEKHByZXZCdWZmZXIsIHZ1diksIHZlYzQoMCksICR7YW1vdW50fSk7XG4gICAgICAgICAgICBnbF9GcmFnQ29sb3IgPSBjb2xvcjtcbiAgICAgICAgICB9XG4gICAgICAgIGAsXG4gICAgdmVydDogR2xzbFNvdXJjZS5jb21waWxlVmVydCh0aGlzLnByZWNpc2lvbiwgY2FtZXJhLCB7IGdsc2xOYW1lOiAnY2xlYXInIH0pLFxuICAgIGF0dHJpYnV0ZXM6IHNlbGYuYXR0cmlidXRlcyxcbiAgICBwcmltaXRpdmU6ICd0cmlhbmdsZXMnLFxuICAgIHVuaWZvcm1zOiBPYmplY3QuYXNzaWduKHt9LCB7XG4gICAgICBwcmV2QnVmZmVyOiAoKSA9PiAgeyByZXR1cm4gc2VsZi5mYm9zW3NlbGYucGluZ1BvbmdJbmRleF0gfSxcbiAgICB9LCB0aGlzLnVuaWZvcm1zKSxcbiAgICBjb3VudDogMyxcbiAgICAvLyBuZXh0IGZyYW1lYnVmZmVyXG4gICAgZnJhbWVidWZmZXI6ICgpID0+IHtcbiAgICAgIHJldHVybiBzZWxmLmZib3Nbc2VsZi5waW5nUG9uZ0luZGV4ID8gMCA6IDFdXG4gICAgfVxuICB9KTtcbiAgaWYgKG5vdykgcmV0dXJuIHRoaXM7XG4gIHJldHVybiBmYWRlO1xufVxuXG5PdXRwdXQucHJvdG90eXBlLmdldEF0dHJpYnV0ZXMgPSBmdW5jdGlvbihwcmltaXRpdmUsIGdlb21ldHJ5KSB7XG4gIGxldCBlbGVtZW50cyA9IDM7XG4gIGxldCBhdHRyaWJ1dGVzID0gdGhpcy5hdHRyaWJ1dGVzO1xuICBpZiAoZ2VvbWV0cnkpIHtcbiAgICBhdHRyaWJ1dGVzID0ge307XG4gICAgaWYgKGdlb21ldHJ5LmlzQnVmZmVyR2VvbWV0cnkpIHtcbiAgICAgIE9iamVjdC5rZXlzKGdlb21ldHJ5LmF0dHJpYnV0ZXMpLmZvckVhY2goKGtleSkgPT4gYXR0cmlidXRlc1trZXldID0gZ2VvbWV0cnkuYXR0cmlidXRlc1trZXldLmFycmF5KTtcbiAgICAgIGVsZW1lbnRzID0gZ2VvbWV0cnkuaW5kZXggPyBnZW9tZXRyeS5pbmRleC5hcnJheSA6IGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb24uY291bnQ7XG4gICAgICBwcmltaXRpdmUgfHwgKHByaW1pdGl2ZSA9IGdlb21ldHJ5LnBhcmFtZXRlcnMucHJpbWl0aXZlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZ2VvbWV0cnkucG9zaXRpb25zICYmIChnZW9tZXRyeS5lZGdlcyB8fCBnZW9tZXRyeS5jZWxscykpIHtcbiAgICAgIGF0dHJpYnV0ZXMucG9zaXRpb24gPSBbXTsgLy8gdG9kbzogc2hvdWxkIGJlIEZsb2F0MzJBcnJheVxuICAgICAgZ2VvbWV0cnkucG9zaXRpb25zLm1hcCgodiwgaykgPT4gYXR0cmlidXRlcy5wb3NpdGlvbi5wdXNoKHZbMF0sIHZbMV0sIDApKTtcbiAgICAgIGVsZW1lbnRzID0gZ2VvbWV0cnkuZWRnZXMgPyBnZW9tZXRyeS5lZGdlcyA6IGdlb21ldHJ5LmNlbGxzO1xuICAgICAgcHJpbWl0aXZlID0gZ2VvbWV0cnkuZWRnZXMgPyAnbGluZXMnIDogJ3RyaWFuZ2xlcyc7XG4gICAgfVxuICB9XG4gIHByaW1pdGl2ZSB8fCAocHJpbWl0aXZlID0gJ3RyaWFuZ2xlcycpO1xuICByZXR1cm4ge2F0dHJpYnV0ZXMsIGVsZW1lbnRzLCBwcmltaXRpdmV9O1xufVxuXG5PdXRwdXQucHJvdG90eXBlLmdldFVuaWZvcm1zID0gZnVuY3Rpb24odW5pZm9ybXMpIHtcbiAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gIHVuaWZvcm1zID0gT2JqZWN0LmFzc2lnbih1bmlmb3JtcywgeyBwcmV2QnVmZmVyOiAgKCkgPT4gIHtcbiAgICAvLyB0b2RvOiBjaGFuZ2VkLCBvcmlnaW5hbGx5OlxuICAgIC8vIHJldHVybiBzZWxmLmZib3Nbc2VsZi5waW5nUG9uZ0luZGV4XVxuICAgIHJldHVybiBzZWxmLmZib3Nbc2VsZi5waW5nUG9uZ0luZGV4ID8gMCA6IDFdXG4gICAgfVxuICB9KVxuICByZXR1cm4gT2JqZWN0LmtleXModW5pZm9ybXMpLnJlZHVjZSgoYWNjLCBrZXkpID0+IHtcbiAgICBhY2Nba2V5XSA9IHR5cGVvZih1bmlmb3Jtc1trZXldKSA9PT0gJ3N0cmluZycgPyBwYXJzZUZsb2F0KHVuaWZvcm1zW2tleV0pIDogdW5pZm9ybXNba2V5XTtcbiAgICByZXR1cm4gYWNjO1xuICB9LCB7fSk7XG59XG5cbk91dHB1dC5wcm90b3R5cGUuZ2V0QmxlbmQgPSBmdW5jdGlvbihibGVuZE1vZGUpIHtcbiAgbGV0IGZ1bmM7XG4gIHN3aXRjaCAoYmxlbmRNb2RlKSB7XG4gICAgY2FzZSAnY3VzdG9tJzpcbiAgICAgIGZ1bmMgPSB7XG4gICAgICAgIHNyY1JHQjogJ2N1c3RvbScsICAvLyBEZWZpbmUgeW91ciBjdXN0b20gYmxlbmRpbmcgZnVuY3Rpb24gaGVyZVxuICAgICAgICBkc3RSR0I6ICdjdXN0b20nLFxuICAgICAgICBzcmNBbHBoYTogJ2N1c3RvbScsXG4gICAgICAgIGRzdEFscGhhOiAnY3VzdG9tJyxcbiAgICAgIH07XG4gICAgICBicmVhaztcbiAgICBjYXNlICdvdmVybGF5JzpcbiAgICAgIGZ1bmMgPSB7XG4gICAgICAgIHNyY1JHQjogJ2RzdCBjb2xvcicsXG4gICAgICAgIGRzdFJHQjogJ29uZSBtaW51cyBzcmMgY29sb3InLFxuICAgICAgICBzcmNBbHBoYTogJ2RzdCBhbHBoYScsXG4gICAgICAgIGRzdEFscGhhOiAnb25lIG1pbnVzIHNyYyBhbHBoYScsXG4gICAgICB9O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnc2NyZWVuJzpcbiAgICAgIGZ1bmMgPSB7XG4gICAgICAgIHNyY1JHQjogJ29uZSBtaW51cyBkc3QgY29sb3InLFxuICAgICAgICBkc3RSR0I6ICdvbmUnLFxuICAgICAgICBzcmNBbHBoYTogJ29uZSBtaW51cyBkc3QgYWxwaGEnLFxuICAgICAgICBkc3RBbHBoYTogJ29uZScsXG4gICAgICB9O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnbXVsdGlwbHknOlxuICAgICAgZnVuYyA9IHtcbiAgICAgICAgc3JjUkdCOiAnZHN0IGNvbG9yJyxcbiAgICAgICAgZHN0UkdCOiAnemVybycsXG4gICAgICAgIHNyY0FscGhhOiAnZHN0IGFscGhhJyxcbiAgICAgICAgZHN0QWxwaGE6ICd6ZXJvJyxcbiAgICAgIH07XG4gICAgICBicmVhaztcbiAgICBjYXNlICdhZGQnOlxuICAgICAgZnVuYyA9IHtcbiAgICAgICAgc3JjUkdCOiAnb25lJyxcbiAgICAgICAgZHN0UkdCOiAnb25lJyxcbiAgICAgICAgc3JjQWxwaGE6ICdvbmUnLFxuICAgICAgICBkc3RBbHBoYTogJ29uZScsXG4gICAgICB9O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnYWxwaGEnOlxuICAgIGRlZmF1bHQ6XG4gICAgICBmdW5jID0ge1xuICAgICAgICBzcmNSR0I6ICdzcmMgYWxwaGEnLFxuICAgICAgICBzcmNBbHBoYTogMSxcbiAgICAgICAgZHN0UkdCOiAnb25lIG1pbnVzIHNyYyBhbHBoYScsXG4gICAgICAgIGRzdEFscGhhOiAxXG4gICAgICB9O1xuICAgICAgYnJlYWs7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBlbmFibGU6IGJsZW5kTW9kZSA/ICh0eXBlb2YoYmxlbmRNb2RlKSA9PT0gJ3N0cmluZycgPyBibGVuZE1vZGUgIT09ICdkaXNhYmxlZCcgOiBibGVuZE1vZGUpIDogZmFsc2UsXG4gICAgZnVuYyxcbiAgfTtcbn1cblxuT3V0cHV0LnByb3RvdHlwZS50aWNrID0gZnVuY3Rpb24gKHByb3BzKSB7XG4gIGNvbnN0IGRvRHJhdyA9ICgpID0+IHRoaXMuZHJhdy5tYXAoKGZuKSA9PiBmbihwcm9wcykpO1xuICB0aGlzLl9jYW1lcmEoe1xuICAgIGV5ZTogdGhpcy5leWUsXG4gICAgdGFyZ2V0OiB0aGlzLnRhcmdldCxcbiAgfSwgZnVuY3Rpb24oKSB7XG4gICAgZG9EcmF3KCk7XG4gIH0pO1xufVxuXG5PdXRwdXQucHJvdG90eXBlLnJlbmRlclRleHR1cmUgPSBmdW5jdGlvbihvcHRpb25zID0ge30pIHtcbiAgY29uc3QgbmV4dCA9IHRoaXMucGluZ1BvbmdJbmRleCA/IDAgOiAxO1xuICBjb25zdCBvcmlnaW5hbCA9IHRoaXMuZmJvcztcbiAgdGhpcy5mYm9zLm1hcCgoKSA9PiB0aGlzLl9pbml0RmJvKHtjb2xvcjogb3B0aW9uc30pKVxuICB0aGlzLnN5bnRoLl9yZW5kZXJPdXQodGhpcy5pZCk7XG4gIGNvbnN0IGNvbG9yVGV4ID0gdGhpcy5mYm9zW3RoaXMucGluZ1BvbmdJbmRleF0uY29sb3I7XG4gIHRoaXMuZmJvcyA9IG9yaWdpbmFsO1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShjb2xvclRleCkgPyBjb2xvclRleFswXSA6IGNvbG9yVGV4O1xufVxuXG5leHBvcnQgZGVmYXVsdCBPdXRwdXRcbiIsImNvbnN0IHR5cGVMb29rdXAgPSB7XG4gICAgJ3NyYyc6IHtcbiAgICAgICAgcmV0dXJuVHlwZTogJ3ZlYzQnLFxuICAgICAgICBhcmdzOiBbJ3ZlYzIgX3N0J11cbiAgICB9LFxuICAgICd2ZXJ0Jzoge1xuICAgICAgICByZXR1cm5UeXBlOiAndmVjNCcsXG4gICAgICAgIGFyZ3M6IFsndmVjMiBfc3QnXVxuICAgIH0sXG4gICAgJ2Nvb3JkJzoge1xuICAgICAgICByZXR1cm5UeXBlOiAndmVjMicsXG4gICAgICAgIGFyZ3M6IFsndmVjMiBfc3QnXVxuICAgIH0sXG4gICAgJ2NvbG9yJzoge1xuICAgICAgICByZXR1cm5UeXBlOiAndmVjNCcsXG4gICAgICAgIGFyZ3M6IFsndmVjNCBfYzAnXVxuICAgIH0sXG4gICAgJ2NvbWJpbmUnOiB7XG4gICAgICAgIHJldHVyblR5cGU6ICd2ZWM0JyxcbiAgICAgICAgYXJnczogWyd2ZWM0IF9jMCcsICd2ZWM0IF9jMSddXG4gICAgfSxcbiAgICAnY29tYmluZUNvb3JkJzoge1xuICAgICAgICByZXR1cm5UeXBlOiAndmVjMicsXG4gICAgICAgIGFyZ3M6IFsndmVjMiBfc3QnLCAndmVjNCBfYzAnXVxuICAgIH1cbn1cblxuY29uc3QgZ2V0TG9va3VwID0ge2Zsb2F0OiAneCcsIHZlYzI6ICd4eScsIHZlYzM6ICd4eXonLCB2ZWM0OiAneHl6dyd9O1xuXG5jb25zdCBnZXRUeXBlTG9va3VwID0ge1xuICAgIHg6ICdmbG9hdCcsIHk6ICdmbG9hdCcsIHo6ICdmbG9hdCcsXG4gICAgeHk6ICd2ZWMyJywgeXg6ICd2ZWMyJyxcbiAgICB4eXo6ICd2ZWMzJywgeHp5OiAndmVjMycsIHl6eDogJ3ZlYzMnLCB5eHo6ICd2ZWMzJywgenh5OiAndmVjMycsIHp5eDogJ3ZlYzMnLFxuICAgIHh5enc6ICd2ZWM0Jyxcbn07XG5cbmNvbnN0IGNhc3RUeXBlID0gKGZ1bmMsIGZyb21UeXBlLCB0b1R5cGUsIGFscGhhID0gMC4wKSA9PiB7XG4gICAgY29uc3QgZnJvbUxlbiA9IGZyb21UeXBlID09PSAnZmxvYXQnID8gMSA6IGZyb21UeXBlLnN1YnN0cmluZygzKTtcbiAgICBjb25zdCB0b0xlbiA9ICh0b1R5cGUgPT09ICdmbG9hdCcgPyAxIDogdG9UeXBlLnN1YnN0cmluZygzKSk7XG4gICAgaWYgKGZyb21MZW4gPCB0b0xlbikge1xuICAgICAgICBsZXQgZGlmZiA9IHRvTGVuIC0gZnJvbUxlbjtcbiAgICAgICAgbGV0IGxhc3QgPSAnJztcbiAgICAgICAgaWYgKHRvVHlwZSA9PT0gJ3ZlYzQnKSB7XG4gICAgICAgICAgICBkaWZmIC09IDE7XG4gICAgICAgICAgICBsYXN0ID0gJywgJythbHBoYTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jID0gYHZlYyR7dG9MZW59KCR7ZnVuY30keycsIDAuMCcucmVwZWF0KGRpZmYpfSR7bGFzdH0pYDtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmM7XG59XG5cbmV4cG9ydCB7IHR5cGVMb29rdXAsIGdldExvb2t1cCwgZ2V0VHlwZUxvb2t1cCwgY2FzdFR5cGUgfTsiXX0=
